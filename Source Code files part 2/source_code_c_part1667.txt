  // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // count up the number of bytes needed
    //
    *pdwBufferSize = sizeof(FAX_ACTIVITY_LOGGING_CONFIG);
    ULONG_PTR Offset = sizeof(FAX_ACTIVITY_LOGGING_CONFIG);
    PFAX_ACTIVITY_LOGGING_CONFIG pConfig;

    EnterCriticalSection (&g_CsConfig);

    if (NULL != g_ActivityLoggingConfig.lptstrDBPath)
    {
        *pdwBufferSize += StringSize( g_ActivityLoggingConfig.lptstrDBPath );
    }

    *pBuffer = (LPBYTE)MemAlloc( *pdwBufferSize );
    if (NULL == *pBuffer)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    pConfig = (PFAX_ACTIVITY_LOGGING_CONFIG)*pBuffer;

    pConfig->dwSizeOfStruct             = sizeof (FAX_ACTIVITY_LOGGING_CONFIG);
    pConfig->bLogIncoming               = g_ActivityLoggingConfig.bLogIncoming;
    pConfig->bLogOutgoing               = g_ActivityLoggingConfig.bLogOutgoing;

    StoreString(
        g_ActivityLoggingConfig.lptstrDBPath,
        (PULONG_PTR)&pConfig->lptstrDBPath,
        *pBuffer,
        &Offset
        );

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);
    return GetServerErrorCode(dwRes);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetActivityLoggingConfiguration

error_status_t
FAX_SetActivityLoggingConfiguration (
    IN handle_t                             hFaxHandle,
    IN const PFAX_ACTIVITY_LOGGING_CONFIGW  pConfig
)
/*++

Routine name : FAX_SetActivityLoggingConfiguration

Routine description:

    Sets the current activity logging configuration

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pConfig             [in ] - Pointer to new data to set

Return Value:

    Standard RPC error codes

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    DWORD dwRes;
    BOOL fAccess;
    HANDLE hNewInboxFile = INVALID_HANDLE_VALUE;
    HANDLE hNewOutboxFile = INVALID_HANDLE_VALUE;
    BOOL IsSameDir = FALSE;
    FAX_ACTIVITY_LOGGING_CONFIGW ActualConfig;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetActivityLoggingConfiguration"));

    Assert (pConfig);

    if (sizeof (FAX_ACTIVITY_LOGGING_CONFIG) != pConfig->dwSizeOfStruct)
    {
        //
        // Size mismatch
        //
        return ERROR_INVALID_PARAMETER;
    }

    ActualConfig = *pConfig;

    if (ActualConfig.bLogIncoming || ActualConfig.bLogOutgoing)
    {
        DWORD dwLen;

        if ((NULL == ActualConfig.lptstrDBPath) || (!lstrlen (ActualConfig.lptstrDBPath)))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Empty DB file name specified"));
            return ERROR_INVALID_PARAMETER;
        }

        if ((dwLen = lstrlen (ActualConfig.lptstrDBPath)) > MAX_DIR_PATH)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DB file name exceeds MAX_PATH"));
            return ERROR_BUFFER_OVERFLOW;
        }

        if (L'\\' == ActualConfig.lptstrDBPath[dwLen - 1])
        {
            //
            // Activity logging DB name should not end with a backslash.
            //
            ActualConfig.lptstrDBPath[dwLen - 1] = (WCHAR)'\0';
        }
    }
    else
    {
        //
        // If logging is off, the DB path is always NULL
        //
        ActualConfig.lptstrDBPath = NULL;
    }
    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return GetServerErrorCode(rVal);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // Always lock  g_CsInboundActivityLogging and then g_CsOutboundActivityLogging
    //
    EnterCriticalSection (&g_CsInboundActivityLogging);
    EnterCriticalSection (&g_CsOutboundActivityLogging);

    if (ActualConfig.lptstrDBPath)
    {
        //
        // Activity logging is on.
        // Check if the DB path has changed
        //
        if (NULL == g_ActivityLoggingConfig.lptstrDBPath)
        {
            //
            // DB was off
            //
            IsSameDir = FALSE;
        }
        else
        {
            rVal = CheckToSeeIfSameDir( g_ActivityLoggingConfig.lptstrDBPath,
                                        ActualConfig.lptstrDBPath,
                                        &IsSameDir);
            if (ERROR_SUCCESS != rVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CheckToSeeIfSameDir with %ld"), rVal);
            }
        }

        if (ERROR_SUCCESS == rVal && FALSE == IsSameDir)
        {
            //
            // Switch DB path
            //
            rVal = CreateLogDB (ActualConfig.lptstrDBPath, &hNewInboxFile, &hNewOutboxFile);
            if (ERROR_SUCCESS != rVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateLogDB with %ld"), rVal);
            }
        }

        if (ERROR_SUCCESS != rVal)
        {
            if (ERROR_ACCESS_DENIED == rVal ||
                ERROR_SHARING_VIOLATION == rVal)
            {
                rVal = FAX_ERR_FILE_ACCESS_DENIED;
            }
            goto exit;
        }
    }

    //
    // Change the values in the registry.
    // Notice: if the logging is off, the DB path gets written as "".
    //
    rVal = StoreActivityLoggingSettings (&ActualConfig);
    if (ERROR_SUCCESS != rVal)
    {
        //
        // Failed to set stuff
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StoreActivityLoggingSettings failed (ec: %ld)"),
            rVal);
        rVal = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    if (!ReplaceStringWithCopy (&g_ActivityLoggingConfig.lptstrDBPath, ActualConfig.lptstrDBPath))
    {
        rVal = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ReplaceStringWithCopy (ec: %ld)"),
            rVal);

        //
        // Try to rollback
        //
        dwRes = StoreActivityLoggingSettings (&g_ActivityLoggingConfig);
        if (ERROR_SUCCESS != dwRes)
        {
            //
            // Failed to set stuff
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StoreActivityLoggingSettings failed  - rollback failed (ec: %ld)"),
                dwRes);
        }
        goto exit;
    }

    if (FALSE == IsSameDir)
    {
        //
        // change the values that the server is currently using
        //
        if (g_hInboxActivityLogFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle (g_hInboxActivityLogFile))
            {
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CloseHandle failed  - (ec: %ld)"),
                        GetLastError());
            }
        }

        if (g_hOutboxActivityLogFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle (g_hOutboxActivityLogFile))
            {
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CloseHandle failed  - (ec: %ld)"),
                        GetLastError());
            }
        }

        g_hInboxActivityLogFile = hNewInboxFile;
        hNewInboxFile = INVALID_HANDLE_VALUE; // Do not close the file handle

        g_hOutboxActivityLogFile = hNewOutboxFile;
        hNewOutboxFile = INVALID_HANDLE_VALUE; // Do not close the file handle
    }

    g_ActivityLoggingConfig.bLogIncoming = ActualConfig.bLogIncoming;
    g_ActivityLoggingConfig.bLogOutgoing = ActualConfig.bLogOutgoing;

    dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_ACTIVITY_LOGGING);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_ACTIVITY_LOGGING) (ec: %ld)"),
            dwRes);
    }

    Assert (ERROR_SUCCESS == rVal);

exit:
    LeaveCriticalSection (&g_CsOutboundActivityLogging);
    LeaveCriticalSection (&g_CsInboundActivityLogging);

    if (INVALID_HANDLE_VALUE != hNewInboxFile ||
        INVALID_HANDLE_VALUE != hNewOutboxFile)
    {
        WCHAR wszFileName[MAX_PATH*2] = {0};
        Assert (INVALID_HANDLE_VALUE != hNewInboxFile &&
                INVALID_HANDLE_VALUE != hNewOutboxFile);

        //
        // Clean Inbox file
        //
        swprintf (wszFileName,
                  TEXT("%s\\%s"),
                  ActualConfig.lptstrDBPath,
                  ACTIVITY_LOG_INBOX_FILE);

        if (!CloseHandle (hNewInboxFile))
        {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CloseHandle failed  - (ec: %ld)"),
                    GetLastError());
        }
        if (!DeleteFile(wszFileName))
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeleteFile failed  - (ec: %ld)"),
                GetLastError());
        }

        //
        // Clean Outbox file
        //
        swprintf (wszFileName,
                  TEXT("%s\\%s"),
                  ActualConfig.lptstrDBPath,
                  ACTIVITY_LOG_OUTBOX_FILE);

        if (!CloseHandle (hNewOutboxFile))
        {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CloseHandle failed  - (ec: %ld)"),
                    GetLastError());
        }
        if (!DeleteFile(wszFileName))
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeleteFile failed  - (ec: %ld)"),
                GetLastError());
        }
    }
    return GetServerErrorCode(rVal);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetActivityLoggingConfiguration


//********************************************
//*                   FSP
//********************************************

error_status_t
FAX_EnumerateProviders (
    IN  handle_t   hFaxHandle,
    OUT LPBYTE    *pBuffer,
    OUT LPDWORD    pdwBufferSize,
    OUT LPDWORD    lpdwNumProviders
)
/*++

Routine name : FAX_EnumerateProviders

Routine description:

    Enumerates the FSPs

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pBuffer             [out] - Pointer to buffer to hold FSPs array
    pdwBufferSize       [out] - Pointer to buffer size
    lpdwNumProviders    [out] - Size of FSPs array

Return Value:

    Standard RPC error codes

--*/
{
    PLIST_ENTRY                 Next;
    DWORD_PTR                   dwOffset;
    PFAX_DEVICE_PROVIDER_INFO   pFSPs;
    DWORD                       dwIndex;
    DWORD                       dwRes = ERROR_SUCCESS;
    BOOL                        fAccess;

    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumerateProviders"));

    Assert (pdwBufferSize && lpdwNumProviders);     // ref pointer in idl
    if (!pBuffer)                                   // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // First run - traverse list and count size required + list size
    //
    *lpdwNumProviders = 0;
    *pdwBufferSize = 0;
    Next = g_DeviceProvidersListHead.Flink;
    if (NULL == Next)
    {
        //
        // The list is corrupted
        //
        ASSERT_FALSE;
        //
        // We'll crash and we deserve it....
        //
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        PDEVICE_PROVIDER    pProvider;

        (*lpdwNumProviders)++;
        (*pdwBufferSize) += sizeof (FAX_DEVICE_PROVIDER_INFO);
        //
        // Get current provider
        //
        pProvider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        //
        // Advance pointer
        //
        Next = pProvider->ListEntry.Flink;
        (*pdwBufferSize) += StringSize (pProvider->FriendlyName);
        (*pdwBufferSize) += StringSize (pProvider->ImageName);
        (*pdwBufferSize) += StringSize (pProvider->ProviderName);
        (*pdwBufferSize) += StringSize (pProvider->szGUID);
    }
    //
    // Allocate required size
    //
    *pBuffer = (LPBYTE)MemAlloc( *pdwBufferSize );
    if (NULL == *pBuffer)
    {
        return FAX_ERR_SRV_OUTOFMEMORY;
    }
    //
    // Second pass, fill in the array
    //
    pFSPs = (PFAX_DEVICE_PROVIDER_INFO)(*pBuffer);
    dwOffset = (*lpdwNumProviders) * sizeof (FAX_DEVICE_PROVIDER_INFO);
    Next = g_DeviceProvidersListHead.Flink;
    dwIndex = 0;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        PDEVICE_PROVIDER    pProvider;

        //
        // Get current provider
        //
        pProvider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        //
        // Advance pointer
        //
        Next = pProvider->ListEntry.Flink;
        pFSPs[dwIndex].dwSizeOfStruct = sizeof (FAX_DEVICE_PROVIDER_INFO);
        StoreString(
            pProvider->FriendlyName,
            (PULONG_PTR)&(pFSPs[dwIndex].lpctstrFriendlyName),
            *pBuffer,
            &dwOffset
            );
        StoreString(
            pProvider->ImageName,
            (PULONG_PTR)&(pFSPs[dwIndex].lpctstrImageName),
            *pBuffer,
            &dwOffset
            );
        StoreString(
            pProvider->ProviderName,
            (PULONG_PTR)&(pFSPs[dwIndex].lpctstrProviderName),
            *pBuffer,
            &dwOffset
            );
        StoreString(
            pProvider->szGUID,
            (PULONG_PTR)&(pFSPs[dwIndex].lpctstrGUID),
            *pBuffer,
            &dwOffset
            );
        pFSPs[dwIndex].dwCapabilities = pProvider->dwCapabilities;
        pFSPs[dwIndex].Version = pProvider->Version;
        pFSPs[dwIndex].Status = pProvider->Status;
        pFSPs[dwIndex].dwLastError = pProvider->dwLastError;
        dwIndex++;
    }
    Assert (dwIndex == *lpdwNumProviders);
    return ERROR_SUCCESS;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_EnumerateProviders

//********************************************
//*              Extended ports
//********************************************

DWORD
GetExtendedPortSize (
    PLINE_INFO pLineInfo
)
/*++

Routine name : GetExtendedPortSize

Routine description:

    Returns the size occupied by the extended info of a port

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pLineInfo           [in] - Port pointer

Remarks:

    This function should be called with g_CsLine held.

Return Value:

    Size required

--*/
{
    DWORD dwSize = sizeof (FAX_PORT_INFO_EX);
    DEBUG_FUNCTION_NAME(TEXT("GetExtendedPortSize"));

    Assert (pLineInfo);
    dwSize+= StringSize (pLineInfo->DeviceName);
    dwSize+= StringSize (pLineInfo->lptstrDescription);
    Assert (pLineInfo->Provider);
    dwSize+= StringSize (pLineInfo->Provider->FriendlyName);
    dwSize+= StringSize (pLineInfo->Provider->szGUID);
    dwSize+= StringSize (pLineInfo->Csid);
    dwSize+= StringSize (pLineInfo->Tsid);
    return dwSize;
}   // GetExtendedPortSize

VOID
StorePortInfoEx (
    PFAX_PORT_INFO_EX pPortInfoEx,
    PLINE_INFO        pLineInfo,
    LPBYTE            lpBufferStart,
    PULONG_PTR        pupOffset
)
/*++

Routine name : StorePortInfoEx

Routine description:

    Stores a port extended info into a buffer

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pPortInfoEx         [in    ] - Buffer to store
    pLineInfo           [in    ] - Port pointer
    lpBufferStart       [in    ] - Start address of buffer (for offset calculations)
    pupOffset           [in/out] - Current offset

Remarks:

    This function should be called with g_CsLine held.

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("StorePortInfoEx"));

    //
    // Store the data
    //
    pPortInfoEx->dwSizeOfStruct             = sizeof (FAX_PORT_INFO_EX);
    if (g_dwManualAnswerDeviceId == pLineInfo->PermanentLineID)
    {
        //
        // Device is in manual-answer mode
        //
        Assert (!(pLineInfo->Flags & FPF_RECEIVE));
        pPortInfoEx->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
    }
    else if (pLineInfo->Flags & FPF_RECEIVE)
    {
        //
        // Device is in auto-answer mode
        //
        Assert (g_dwManualAnswerDeviceId != pLineInfo->PermanentLineID);
        pPortInfoEx->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
    }
    else
    {
        //
        // Device is not set to receive
        //
        Assert (g_dwManualAnswerDeviceId != pLineInfo->PermanentLineID);
        pPortInfoEx->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
    }
    pPortInfoEx->bSend                      = (pLineInfo->Flags & FPF_SEND) ? TRUE : FALSE;
    pPortInfoEx->dwStatus                   = (pLineInfo->dwReceivingJobsCount ? FAX_DEVICE_STATUS_RECEIVING : 0) |
                                              (pLineInfo->dwSendingJobsCount ? FAX_DEVICE_STATUS_SENDING : 0);
    pPortInfoEx->dwDeviceID                 = pLineInfo->PermanentLineID;
    pPortInfoEx->dwRings                    = pLineInfo->RingsForAnswer;

    StoreString(
        pLineInfo->DeviceName,
        (PULONG_PTR)&pPortInfoEx->lpctstrDeviceName,
        lpBufferStart,
        pupOffset
        );

    StoreString(
        pLineInfo->lptstrDescription,
        (PULONG_PTR)&pPortInfoEx->lptstrDescription,
        lpBufferStart,
        pupOffset
        );

    StoreString(
        pLineInfo->Provider->FriendlyName,
        (PULONG_PTR)&pPortInfoEx->lpctstrProviderName,
        lpBufferStart,
        pupOffset
        );

    StoreString(
        pLineInfo->Provider->szGUID,
        (PULONG_PTR)&pPortInfoEx->lpctstrProviderGUID,
        lpBufferStart,
        pupOffset
        );

    StoreString(
        pLineInfo->Csid,
        (PULONG_PTR)&pPortInfoEx->lptstrCsid,
        lpBufferStart,
        pupOffset
        );

    StoreString(
        pLineInfo->Tsid,
        (PULONG_PTR)&pPortInfoEx->lptstrTsid,
        lpBufferStart,
        pupOffset
        );
}   // StorePortInfoEx

error_status_t
FAX_EnumPortsEx(
    IN handle_t       hFaxHandle,
    IN OUT LPBYTE    *lpBuffer,
    IN OUT LPDWORD    lpdwBufferSize,
    OUT LPDWORD       lpdwNumPorts
)
/*++

Routine name : FAX_EnumPortsEx

Routine description:

    Enumerates the ports

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    lpBuffer            [out] - Pointer to buffer to hold ports array
    lpdwBufferSize      [out] - Pointer to buffer size
    lpdwNumPorts        [out] - Size of ports array

Return Value:

    Standard RPC error codes

--*/
{
    PLIST_ENTRY                 Next;
    DWORD_PTR                   dwOffset;
    DWORD                       dwIndex;
    DWORD                       dwRes = ERROR_SUCCESS;
    PFAX_PORT_INFO_EX           pPorts;
    BOOL                        fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumPortsEx"));

    Assert (lpdwBufferSize && lpdwNumPorts);    // ref pointer in idl
    if (!lpBuffer)                              // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // First run - traverse list and count size required + list size
    //
    *lpdwNumPorts = 0;
    *lpdwBufferSize = 0;

    EnterCriticalSection( &g_CsLine );
    Next = g_TapiLinesListHead.Flink;
    if (NULL == Next)
    {
        //
        // The list is corrupted
        //
        ASSERT_FALSE;
        //
        // We'll crash and we deserve it....
        //
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        PLINE_INFO pLineInfo;

        (*lpdwNumPorts)++;
        //
        // Get current port
        //
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        //
        // Advance pointer
        //
        Next = pLineInfo->ListEntry.Flink;
        //
        // Sum up size
        //
        (*lpdwBufferSize) += GetExtendedPortSize (pLineInfo);
    }
    //
    // Allocate required size
    //
    *lpBuffer = (LPBYTE)MemAlloc( *lpdwBufferSize );
    if (NULL == *lpBuffer)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    //
    // Second pass, fill in the array
    //
    pPorts = (PFAX_PORT_INFO_EX)(*lpBuffer);
    dwOffset = (*lpdwNumPorts) * sizeof (FAX_PORT_INFO_EX);
    Next = g_TapiLinesListHead.Flink;
    dwIndex = 0;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        PLINE_INFO pLineInfo;

        //
        // Get current port
        //
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        //
        // Advance pointer
        //
        Next = pLineInfo->ListEntry.Flink;
        //
        // Store port data
        //
        StorePortInfoEx (&pPorts[dwIndex++],
                         pLineInfo,
                         *lpBuffer,
                         &dwOffset
                        );
    }
    Assert (dwIndex == *lpdwNumPorts);
    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection( &g_CsLine );
    return GetServerErrorCode(dwRes);

    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_EnumPortsEx

error_status_t
FAX_GetPortEx(
    IN handle_t    hFaxHandle,
    IN DWORD       dwDeviceId,
    IN OUT LPBYTE *lpBuffer,
    IN OUT LPDWORD lpdwBufferSize
)
/*++

Routine name : FAX_GetPortEx

Routine description:

    Gets extended port info

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    dwDeviceId          [in ] - Unique device id
    lpBuffer            [out] - Pointer to buffer to hold extended port information
    lpdwBufferSize      [out] - Pointer to buffer size

Return Value:

    Standard RPC error codes

--*/
{
    DWORD_PTR           dwOffset;
    PLINE_INFO          pLineInfo;
    DWORD               dwRes = ERROR_SUCCESS;
    BOOL                fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetPortEx"));

    Assert (lpdwBufferSize);     // ref pointer in idl
    if (!lpBuffer)               // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // Locate the port (device)
    //
    EnterCriticalSection( &g_CsLine );
    pLineInfo = GetTapiLineFromDeviceId( dwDeviceId, FALSE );
    if (!pLineInfo)
    {
        //
        // Port not found
        //
        dwRes = ERROR_BAD_UNIT; // The system cannot find the device specified.
        goto exit;
    }
    //
    // count up the number of bytes needed
    //
    *lpdwBufferSize = GetExtendedPortSize(pLineInfo);
    dwOffset = sizeof (FAX_PORT_INFO_EX);
    //
    // Allocate buffer
    //
    *lpBuffer = (LPBYTE)MemAlloc( *lpdwBufferSize );
    if (NULL == *lpBuffer)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    StorePortInfoEx ((PFAX_PORT_INFO_EX)*lpBuffer,
                     pLineInfo,
                     *lpBuffer,
                     &dwOffset
                    );

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection( &g_CsLine );
    return GetServerErrorCode(dwRes);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetPortEx


error_status_t
FAX_SetPortEx (
    IN handle_t                 hFaxHandle,
    IN DWORD                    dwDeviceId,
    IN const PFAX_PORT_INFO_EX  pNewPortInfo
)
/*++

Routine name : FAX_SetPortEx

Routine description:

    Sets extended port info

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    dwDeviceId          [in ] - Unique device id
    pNewPortInfo        [out] - Pointer to new extended port information

Return Value:

    Standard RPC error codes

--*/
{
    DWORD       dwRes = ERROR_SUCCESS;
    DWORD       rVal;
    PLINE_INFO  pLineInfo;
    BOOL        bVirtualDeviceNeedsUpdate = FALSE;
    BOOL        fAccess;
    BOOL        bDeviceWasSetToReceive;    // Was the device configured to receive faxes?
    BOOL        bDeviceWasEnabled;         // Was the device send/receive/manual receive enabled
    DWORD       dwLastManualAnswerDeviceId = 0;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetPortEx"));

    Assert (pNewPortInfo);

    if (!dwDeviceId)
    {
        return ERROR_INVALID_PARAMETER;
    }
    if (sizeof (FAX_PORT_INFO_EX) != pNewPortInfo->dwSizeOfStruct)
    {
        //
        // Size mismatch
        //
        return ERROR_INVALID_PARAMETER;
    }
    if (MAX_FAX_STRING_LEN <= lstrlen (pNewPortInfo->lptstrDescription))
    {
        return ERROR_BUFFER_OVERFLOW;
    }

    if ((FAX_DEVICE_RECEIVE_MODE_MANUAL < pNewPortInfo->ReceiveMode) ||
        (FAX_DEVICE_RECEIVE_MODE_OFF    > pNewPortInfo->ReceiveMode))

    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("ReceiveMode = %d and > FAX_DEVICE_RECEIVE_MODE_MANUAL"),
                    pNewPortInfo->ReceiveMode);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSectionJobAndQueue;
    EnterCriticalSection( &g_CsLine );

    //
    // Remember the original device set to manual-answer
    //
    dwLastManualAnswerDeviceId = g_dwManualAnswerDeviceId;
    //
    // Locate the port (device)
    //
    pLineInfo = GetTapiLineFromDeviceId (dwDeviceId, FALSE);
    if (!pLineInfo)
    {
        //
        // Port not found
        //
        dwRes = ERROR_BAD_UNIT; // The system cannot find the device specified.
        goto exit;
    }
    bDeviceWasEnabled = IsDeviceEnabled(pLineInfo);
    bDeviceWasSetToReceive = (pLineInfo->Flags & FPF_RECEIVE) ||            // Either device was set to auto-receive or
                             (dwDeviceId == g_dwManualAnswerDeviceId);      // it's the manual answer device id


    if ((pLineInfo->Flags & FPF_VIRTUAL) &&                                 // The device is virtual and
        (FAX_DEVICE_RECEIVE_MODE_MANUAL == pNewPortInfo->ReceiveMode))      // we were asked to set it to manual-answer
    {
        //
        // We don't support manual-answer on non-physical devices
        //
        DebugPrintEx(DEBUG_ERR,
                    TEXT("Device id (%ld) is virtual"),
                    dwDeviceId);
        dwRes = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Check device limit
    //
    if (g_dwDeviceEnabledCount >= g_dwDeviceEnabledLimit &&             // We are at the device limit
        !bDeviceWasEnabled                               &&             // It was not send/receive/manual receive enabled
        (pNewPortInfo->bSend        ||                                  // It is now send  enabled
        pNewPortInfo->ReceiveMode  != FAX_DEVICE_RECEIVE_MODE_OFF))     // It is now receive enabled
    {
        BOOL fLimitExceeded = TRUE;

        //
        // We should now verify if manual answer device changed. If so there is another device to take into device enabled account.
        //
        if (dwLastManualAnswerDeviceId != 0                                 && // There was a device set to manual answer
            FAX_DEVICE_RECEIVE_MODE_MANUAL == pNewPortInfo->ReceiveMode     && // The new device is set to manual
            dwLastManualAnswerDeviceId != dwDeviceId)                          // It is not the same device
        {
            //
            // See if the old device is send enabled
            //
            PLINE_INFO pOldLine;
            pOldLine = GetTapiLineFromDeviceId (dwLastManualAnswerDeviceId, FALSE);
            if (pOldLine)
            {
                if (!(pOldLine->Flags & FPF_SEND))
                {
                    //
                    // The old manual receive device is not send enabled. When the manual receive device will be changed, the old device
                    // will not be enabled anymore, and the enabled device count will be decremented.
                    //
                    fLimitExceeded = FALSE;
                }
            }
        }

        if (TRUE == fLimitExceeded)
        {
            if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
            {
                //
                // API version 0 clients don't know about FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED
                //
                dwRes = ERROR_INVALID_PARAMETER;
            }
            else
            {
                dwRes = FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED;
            }
            goto exit;
        }
    }

    //
    // Store device configuration in the registry
    //
    dwRes = StoreDeviceConfig (dwDeviceId, pNewPortInfo, pLineInfo->Flags & FPF_VIRTUAL ? TRUE : FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }
    //
    // Update data in server's memory
    //
    if (!ReplaceStringWithCopy (&(pLineInfo->lptstrDescription), pNewPortInfo->lptstrDescription))
    {
        dwRes = GetLastError ();
        goto exit;
    }
    if (!ReplaceStringWithCopy (&(pLineInfo->Csid), pNewPortInfo->lptstrCsid))
    {
        dwRes = GetLastError ();
        goto exit;
    }
    if (!ReplaceStringWithCopy (&(pLineInfo->Tsid), pNewPortInfo->lptstrTsid))
    {
        dwRes = GetLastError ();
        goto exit;
    }
    pLineInfo->RingsForAnswer = pNewPortInfo->dwRings;
    //
    // More advanced settings - require additional work
    //

    //
    // Check for changes in the device receive modes
    //
    // We have 9 options here as described in the table below:
    //
    //     New receive mode | Off | Auto | Manual
    // Old receive mode     |     |      |
    // ---------------------+-----+------+--------
    // Off                  |  1  |   2  |   3
    // ---------------------+-----+------+--------
    // Auto                 |  4  |   5  |   6
    // ---------------------+-----+------+--------
    // Manual               |  7  |   8  |   9
    //
    //
    // Options 1, 5, and 9 mean no change and there's no code to handle them explicitly.
    //

    if ((FAX_DEVICE_RECEIVE_MODE_AUTO == pNewPortInfo->ReceiveMode) &&
        (g_dwManualAnswerDeviceId == dwDeviceId))
    {
        //
        // Change #8 - see table above
        //
        // Device was in manual-answer mode and we now switch to auto-answer mode
        // Keep the line open
        //
        pLineInfo->Flags |= FPF_RECEIVE;
        bVirtualDeviceNeedsUpdate = TRUE;
        //
        // Mark no device as manual answer device
        //
        g_dwManualAnswerDeviceId = 0;
        goto UpdateManualDevice;
    }
    else if ((FAX_DEVICE_RECEIVE_MODE_MANUAL == pNewPortInfo->ReceiveMode) &&
             (pLineInfo->Flags & FPF_RECEIVE))
    {
        //
        // Change #6 - see table above
        //
        // Device was in auto-answer mode and we now switch to manual-answer mode
        // Keep the line open
        //
        pLineInfo->Flags &= ~FPF_RECEIVE;
        bVirtualDeviceNeedsUpdate = TRUE;
        //
        // Mark our device as manual answer device
        //
        g_dwManualAnswerDeviceId = dwDeviceId;
        goto UpdateManualDevice;
    }

    if (!bDeviceWasSetToReceive && (pNewPortInfo->ReceiveMode != FAX_DEVICE_RECEIVE_MODE_OFF))
    {
        //
        // The device should start receiving now (manual or auto).
        // Update line info.
        //
        if (FAX_DEVICE_RECEIVE_MODE_AUTO == pNewPortInfo->ReceiveMode)
        {
            //
            // Change #2 - see table above
            //
            // If set to auto-receive, mark that in the device info
            //
            pLineInfo->Flags |= FPF_RECEIVE;
            bVirtualDeviceNeedsUpdate = TRUE;
        }
        else
        {
            //
            // Change #3 - see table above
            //
            // If manual-receive, update the global manual-receive device id
            //
            g_dwManualAnswerDeviceId = dwDeviceId;
        }

        if (!(pLineInfo->Flags & FPF_VIRTUAL) && (!pLineInfo->hLine))
        {
            if (!OpenTapiLine( pLineInfo ))
            {
                DWORD rc = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("OpenTapiLine failed. (ec: %ld)"),
                    rc);
            }
        }
    }
    else if (bDeviceWasSetToReceive && (FAX_DEVICE_RECEIVE_MODE_OFF == pNewPortInfo->ReceiveMode))
    {
        //
        // The device should stop receiving now
        //
        if (dwDeviceId == g_dwManualAnswerDeviceId)
        {
            //
            // Change #7 - see table above
            //
            // The device was in manual-answer mode
            //
            Assert (!(pLineInfo->Flags & FPF_RECEIVE));
            //
            // Set manual-answer device id to 'no device'
            //
            g_dwManualAnswerDeviceId = 0;
        }
        else
        {
            //
            // Change #4 - see table above
            //
            // The device was in auto-answer mode
            //
            Assert (pLineInfo->Flags & FPF_RECEIVE);
            //
            // Update line info
            //
            pLineInfo->Flags &= ~FPF_RECEIVE;
            bVirtualDeviceNeedsUpdate = TRUE;
        }
        if (pLineInfo->State == FPS_AVAILABLE                        &&  // Line is available and
            pLineInfo->hLine                                             // device is open
           )
        {
            //
            // We can not close the line if it is busy.
            // We simply remove the FPF_RECEIVE and ReleaseTapiLine will call lineClose when the job terminates.
            //
            lineClose( pLineInfo->hLine );
            pLineInfo->hLine = 0;
        }
    }
UpdateManualDevice:
    if (dwLastManualAnswerDeviceId != g_dwManualAnswerDeviceId)
    {
        //
        // Manual answer device has changed.
        // Update the registry
        //
        dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                dwRes);
        }
        if (0 != dwLastManualAnswerDeviceId &&
            dwDeviceId != dwLastManualAnswerDeviceId)
        {
            //
            // Another device just stopped being the device in manual-anser mode
            //
            PLINE_INFO pOldLine;
            pOldLine = GetTapiLineFromDeviceId (dwLastManualAnswerDeviceId, FALSE);
            if (pOldLine)
            {
                //
                // The former device still exists, remove receive enabled flag.
                //
                pOldLine->Flags &= ~FPF_RECEIVE;

                if (pOldLine->State == FPS_AVAILABLE        &&  // Line is available and
                    pOldLine->hLine)                            // Device is open
                {
                    //
                    // This is a good time to close the device
                    // which just stopped being the manual-answer device
                    //
                    lineClose(pOldLine->hLine);
                    pOldLine->hLine = 0;
                }

                //
                // Check if this device is still enabled
                //
                if (FALSE == IsDeviceEnabled(pOldLine))
                {
                    Assert (g_dwDeviceEnabledCount);
                    g_dwDeviceEnabledCount -= 1;
                }
            }
        }
    }
    //
    // Check for changes in the device send mode
    //
    if (!(pLineInfo->Flags & FPF_SEND) && pNewPortInfo->bSend)
    {
        //
        // The device should start being available for sending now
        //
        bVirtualDeviceNeedsUpdate = TRUE;
        //
        // We just added a new device to the send
        // capable device collection - signal the queue
        //
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetEvent failed (ec: %lc)"),
                GetLastError);
            g_ScanQueueAfterTimeout = TRUE;
        }
        //
        // Update line info
        //
        pLineInfo->Flags |= FPF_SEND;
        pLineInfo->LastLineClose = 0; // Try to use it on the first try
    }
    else if ((pLineInfo->Flags & FPF_SEND) && !pNewPortInfo->bSend)
    {
        //
        // The device should stop being available for sending now
        // Update line info
        //
        bVirtualDeviceNeedsUpdate = TRUE;
        pLineInfo->Flags &= ~FPF_SEND;
    }
    if (bVirtualDeviceNeedsUpdate)
    {
        //
        // The Send / Receive status has changed - update the virtual device
        //
        UpdateVirtualDeviceSendAndReceiveStatus (pLineInfo,
                                                 pNewPortInfo->bSend,
                                                 (FAX_DEVICE_RECEIVE_MODE_AUTO == pNewPortInfo->ReceiveMode)
                                                );
    }

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_DEVICES);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_DEVICES) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (pLineInfo)
    {
        if (bDeviceWasSetToReceive && !(pLineInfo->Flags & FPF_RECEIVE))
        {
            //
            // This device stopped receiving
            //
            SafeDecIdleCounter (&g_dwReceiveDevicesCount);
        }
        else if (!bDeviceWasSetToReceive && (pLineInfo->Flags & FPF_RECEIVE))
        {
            //
            // This device started receiving
            //
            SafeIncIdleCounter (&g_dwReceiveDevicesCount);
        }

        //
        // Update enabled device count
        //
        if (bDeviceWasEnabled == TRUE)
        {
            if (FALSE == IsDeviceEnabled(pLineInfo))
            {
                Assert (g_dwDeviceEnabledCount);
                g_dwDeviceEnabledCount -= 1;
            }
        }
        else
        {
            //
            // The device was not enabled
            //
            if (TRUE == IsDeviceEnabled(pLineInfo))
            {
                g_dwDeviceEnabledCount += 1;
                Assert (g_dwDeviceEnabledCount <= g_dwDeviceEnabledLimit);
            }
        }
    }
    LeaveCriticalSection( &g_CsLine );
    LeaveCriticalSectionJobAndQueue;

    return GetServerErrorCode(dwRes);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetPortEx



error_status_t
FAX_GetJobEx(
    IN handle_t hFaxHandle,
    IN DWORDLONG dwlMessageId,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize
    )
/*++

Routine name : FAX_GetJobEx

Routine description:

    Fills FAX_JOB_ENTRY_EX of a message specified by its unique ID

Author:

    Oded Sacher (OdedS),    Nov, 1999

Arguments:

    hFaxHandle          [in] - Binding handle
    dwlMessageId        [in] - Unique message ID
    Buffer              [Out] - Buffer to receive FAX_JOB_ENTRY_EX
    BufferSize          [out] - The size of Buffer

Return Value:

    Standard RPC error codes

--*/
{
    PJOB_QUEUE pJobQueue;
    ULONG_PTR Offset = 0;
    DWORD ulRet = ERROR_SUCCESS;
    BOOL bAllMessages = FALSE;
    PSID pUserSid = NULL;
    BOOL fAccess;
    DWORD dwRights;
    DWORD dwClientAPIVersion = FindClientAPIVersion(hFaxHandle);

    DEBUG_FUNCTION_NAME(TEXT("FAX_GetJobEx"));

    Assert (BufferSize);    // ref pointer in idl
    if (!Buffer)            // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    ulRet = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != ulRet)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    ulRet);
        return GetServerErrorCode(ulRet);
    }

    if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT) &&
        FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
        FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH) &&
        FAX_ACCESS_QUERY_JOBS != (dwRights & FAX_ACCESS_QUERY_JOBS))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the needed rights to view jobs in queue"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_ACCESS_QUERY_JOBS == (dwRights & FAX_ACCESS_QUERY_JOBS))
    {
        bAllMessages = TRUE;
    }

    DebugPrintEx(DEBUG_MSG,TEXT("Before Enter g_CsJob & Queue"));
    EnterCriticalSectionJobAndQueue;
    DebugPrintEx(DEBUG_MSG,TEXT("After Enter g_CsJob & Queue"));

    pJobQueue = FindJobQueueEntryByUniqueId (dwlMessageId);
    if (pJobQueue == NULL || pJobQueue->JobType == JT_BROADCAST)
    {
        //
        // dwlMessageId is not a valid queued job Id.
        //
        DebugPrintEx(DEBUG_ERR,TEXT("Invalid Parameter - not a valid job Id"));
        ulRet = FAX_ERR_MESSAGE_NOT_FOUND;
        goto Exit;
    }

    if (pJobQueue->JobType == JT_SEND)
    {
        Assert (pJobQueue->lpParentJob);
        if (pJobQueue->lpParentJob->JobStatus == JS_DELETING)
        {
            //
            // dwlMessageId is being deleted
            //
            DebugPrintEx(DEBUG_ERR,TEXT("Job is deleted - not a valid job Id"));
            ulRet = FAX_ERR_MESSAGE_NOT_FOUND;
            goto Exit;
        }
    }

    if (FALSE == bAllMessages)
    {
        pUserSid = GetClientUserSID();
        if (NULL == pUserSid)
        {
            ulRet = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("GetClientUserSid failed, Error %ld"), ulRet);
            goto Exit;
        }

        if (!UserOwnsJob (pJobQueue, pUserSid))
        {
            DebugPrintEx(DEBUG_WRN,TEXT("UserOwnsJob failed ,Access denied"));
            ulRet = ERROR_ACCESS_DENIED;
            goto Exit;
        }
    }

    //
    // Allocate buffer memory.
    //
    if (!GetJobDataEx(NULL,
                      NULL,
                      NULL,
                      dwClientAPIVersion,
                      pJobQueue,
                      &Offset))
    {
       ulRet = GetLastError();
       DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
       goto Exit;
    }

    *BufferSize = Offset;
    *Buffer = (LPBYTE) MemAlloc( *BufferSize );
    if (*Buffer == NULL)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("ERROR_NOT_ENOUGH_MEMORY (Server)"));
        ulRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    Offset = sizeof(FAX_JOB_STATUSW) + sizeof(FAX_JOB_ENTRY_EXW);
    if (!GetJobDataEx(*Buffer,
                      (PFAX_JOB_ENTRY_EXW)*Buffer,
                      (PFAX_JOB_STATUSW)(*Buffer + sizeof(FAX_JOB_ENTRY_EXW)),
                      dwClientAPIVersion,
                      pJobQueue,
                      &Offset))
    {
        ulRet = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
        MemFree(*Buffer);
        *BufferSize =0;
    }

Exit:
    LeaveCriticalSectionJobAndQueue;
    DebugPrintEx(DEBUG_MSG,TEXT("After Release g_CsJob & g_CsQueue"));

    if (NULL != pUserSid)
    {
        MemFree (pUserSid);
    }
    return GetServerErrorCode(ulRet);

}


error_status_t
FAX_EnumJobsEx(
    IN handle_t hFaxHandle,
    IN DWORD dwJobTypes,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize,
    OUT LPDWORD lpdwJobs
    )
/*++

Routine name : FAX_EnumJobsEx

Routine description:

    Fills an array of FAX_JOB_ENTR_EX of all messages with type specified in  dwJobTypes

Author:

    Oded Sacher (OdedS),    Nov, 1999

Arguments:

    hFaxHandle          [in] - Binding handle
    dwJobTypes          [in] - Specifies the job type filter
    Buffer              [out] - Buffer to receive FAX_JOB_ENTRY_EX
    BufferSize          [out] - The size of the buffer
    lpdwJobs            [out] - Number of FAX_JOB_ENTRY_EX retrieved

Return Value:

    None.

--*/
{
    PJOB_QUEUE pJobQueue;
    DWORD ulRet = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumJobsEx"));
    PLIST_ENTRY Next;
    DWORD rVal = 0;
    ULONG_PTR Offset = 0;
    DWORD Count = 0;
    PFAX_JOB_ENTRY_EXW pJobEntry;
    PFAX_JOB_STATUSW pFaxStatus;
    BOOL bAllMessages = FALSE;
    PSID pUserSid = NULL;
    BOOL fAccess;
    DWORD dwRights;
    DWORD dwClientAPIVersion = FindClientAPIVersion(hFaxHandle);

    Assert (BufferSize && lpdwJobs);    // ref pointer in idl
    if (!Buffer)                        // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    ulRet = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != ulRet)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    ulRet);
        return GetServerErrorCode(ulRet);
    }

    if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT) &&
        FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
        FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH) &&
        FAX_ACCESS_QUERY_JOBS != (dwRights & FAX_ACCESS_QUERY_JOBS))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the needed rights to Enumerate jobs in queue"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_ACCESS_QUERY_JOBS == (dwRights & FAX_ACCESS_QUERY_JOBS))
    {
        bAllMessages = TRUE;
    }

    if (FALSE == bAllMessages)
    {
        pUserSid = GetClientUserSID();
        if (NULL == pUserSid)
        {
            ulRet = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("GetClientUserSid failed, Error %ld"), ulRet);
            return GetServerErrorCode(ulRet);
        }
    }

    DebugPrintEx(DEBUG_MSG,TEXT("Before Enter g_CsJob & Queue"));
    EnterCriticalSectionJobAndQueue;
    DebugPrintEx(DEBUG_MSG,TEXT("After Enter g_CsJob & Queue"));

    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
    {
        pJobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = pJobQueue->ListEntry.Flink;

        if (pJobQueue->JobType == JT_SEND)
        {
            Assert (pJobQueue->lpParentJob);
            if (pJobQueue->lpParentJob->JobStatus == JS_DELETING)
            {
                // do not show this job
                continue;
            }
        }

        if (JT_BROADCAST != pJobQueue->JobType &&
            (pJobQueue->JobType & dwJobTypes))
        {
            if (TRUE == bAllMessages)
            {

                if (!GetJobDataEx(
                      NULL,
                      NULL,
                      NULL,
                      dwClientAPIVersion,
                      pJobQueue,
                      &Offset))
                {
                   ulRet = GetLastError();
                   DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
                   goto Exit;
                }
                Count += 1;
            }
            else
            {
                if (UserOwnsJob (pJobQueue, pUserSid))
                {
                    if (!GetJobDataEx(
                      NULL,
                      NULL,
                      NULL,
                      dwClientAPIVersion,
                      pJobQueue,
                      &Offset))
                    {
                       ulRet = GetLastError();
                       DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
                       goto Exit;
                    }
                    Count += 1;
                }
            }
        }
    }

    //
    // Allocate buffer memory.
    //

    *BufferSize = Offset;
    *Buffer = (LPBYTE) MemAlloc( Offset );
    if (*Buffer == NULL)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("ERROR_NOT_ENOUGH_MEMORY (Server)"));
        ulRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    Offset = (sizeof(FAX_JOB_ENTRY_EXW) + sizeof(FAX_JOB_STATUSW)) * Count;
    pJobEntry = (PFAX_JOB_ENTRY_EXW) *Buffer;
    pFaxStatus = (PFAX_JOB_STATUSW) (*Buffer + (sizeof(FAX_JOB_ENTRY_EXW) * Count));

    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
    {
        pJobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = pJobQueue->ListEntry.Flink;

        if (pJobQueue->JobType == JT_SEND)
        {
            Assert (pJobQueue->lpParentJob);
            if (pJobQueue->lpParentJob->JobStatus == JS_DELETING)
            {
                // do not show this job
                continue;
            }
        }

        if (JT_BROADCAST != pJobQueue->JobType &&
            (pJobQueue->JobType & dwJobTypes))
        {
            if (TRUE == bAllMessages)
            {
                if (!GetJobDataEx (*Buffer, pJobEntry, pFaxStatus, dwClientAPIVersion, pJobQueue, &Offset))
                {
                    ulRet = GetLastError();
                    DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
                    goto Exit;
                }
                pJobEntry ++;
                pFaxStatus ++;
            }
            else
            {
                if (UserOwnsJob (pJobQueue, pUserSid))
                {
                    if (!GetJobDataEx (*Buffer, pJobEntry, pFaxStatus, dwClientAPIVersion, pJobQueue, &Offset))
                    {
                        ulRet = GetLastError();
                        DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
                        goto Exit;
                    }
                    pJobEntry ++;
                    pFaxStatus ++;
                }
            }
        }
    }

    *lpdwJobs = Count;
    Assert (ERROR_SUCCESS == ulRet);

Exit:
    LeaveCriticalSectionJobAndQueue;
    DebugPrintEx(DEBUG_MSG,TEXT("After Release g_CsJob & g_CsQueue"));

    if (ERROR_SUCCESS != ulRet)
    {
        MemFree (*Buffer);
        *BufferSize = 0;
    }

    if (NULL != pUserSid)
    {
        MemFree (pUserSid);
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(ulRet);
}

//********************************************
//*            EFSP registration
//********************************************


error_status_t
FAX_RegisterServiceProviderEx (
    IN handle_t     hFaxHandle,
    IN LPCWSTR      lpctstrGUID,
    IN LPCWSTR      lpctstrFriendlyName,
    IN LPCWSTR      lpctstrImageName,
    IN LPCWSTR      lpctstrTspName,
    IN DWORD        dwFSPIVersion,
    IN DWORD        dwCapabilities
)
/*++

Routine name : FAX_RegisterServiceProviderEx

Routine description:

    Registers an FSP

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle          [in] - Handle to fax server - unused
    lpctstrGUID         [in] - GUID of FSP
    lpctstrFriendlyName [in] - Friendly name of FSP
    lpctstrImageName    [in] - Image name of FSP. May contain environment variables
    lpctstrTspName      [in] - TSP name of FSP.
    dwFSPIVersion       [in] - FSP's API version.
    dwCapabilities      [in] - FSP's extended capabilities.

Return Value:

    Standard RPC error code

--*/
{
    DWORD       dwRes = ERROR_SUCCESS;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    LPCWSTR     lpcwstrExpandedImage = NULL;
    BOOL        fAccess;
    BOOL        bLocalFaxPrinterInstalled;
    DEBUG_FUNCTION_NAME(TEXT("FAX_RegisterServiceProviderEx"));

    Assert (lpctstrGUID && lpctstrFriendlyName && lpctstrImageName && lpctstrTspName);

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (MAX_FAX_STRING_LEN < lstrlen (lpctstrFriendlyName) ||
        MAX_FAX_STRING_LEN < lstrlen (lpctstrImageName) ||
        MAX_FAX_STRING_LEN < lstrlen (lpctstrTspName))
    {
        return ERROR_BUFFER_OVERFLOW;
    }

    //
    // Verify GUID format
    //
    dwRes = IsValidGUID (lpctstrGUID);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid GUID (dwRes: %ld)"),
            dwRes);
        return dwRes;
    }

    //
    // Verify version field range
    //
    if (FSPI_API_VERSION_1 != dwFSPIVersion ||
        dwCapabilities)

    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("dwFSPIVersion invalid (0x%08x), or not valid capability (0x%08x)"),
            dwFSPIVersion,
            dwCapabilities);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make sure the FSP isn't already registered (by it's GUID)
    //
    if (FindFSPByGUID (lpctstrGUID))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FSP with same GUID already exists (%s)"),
            lpctstrGUID);
        return ERROR_ALREADY_EXISTS;
    }
    //
    // Make sure the FSP isn't already registered (by it's TSP name)
    //
    if (FindDeviceProvider ((LPWSTR)lpctstrTspName, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FSP with same TSP name already exists (%s)"),
            lpctstrGUID);
        return ERROR_ALREADY_EXISTS;
    }
    //
    // Make sure the image name parameter points to a file
    //
    lpcwstrExpandedImage = ExpandEnvironmentString (lpctstrImageName);
    if (NULL == lpcwstrExpandedImage)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error expanding image name (%s) (ec = %ld)"),
            lpctstrImageName,
            dwRes);
        return dwRes;
    }
    hFile = CreateFile ( lpcwstrExpandedImage,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        //
        // Couldn't open the file
        //
        dwRes = GetLastError ();
        if (ERROR_FILE_NOT_FOUND == dwRes)
        {
            //
            // Image name (after environment expansion) doesn't exist
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Image file (%s) doesn't exist"),
                lpctstrImageName);
            dwRes = ERROR_INVALID_PARAMETER;
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error opening image file (%s) (ec = %ld)"),
                lpctstrImageName,
                dwRes);
        }
        goto exit;
    }
    //
    // Everything's OK - Add the new FSP to the registry
    //
    dwRes =  AddNewProviderToRegistry (lpctstrGUID,
                                       lpctstrFriendlyName,
                                       lpctstrImageName,
                                       lpctstrTspName,
                                       dwFSPIVersion,
                                       dwCapabilities);

    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AddNewProviderToRegistry returned %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

    //
    // Adding an FSP is always local.
    // If we don't have a fax printer installed, this is the time to install one.
    //
    dwRes = IsLocalFaxPrinterInstalled(&bLocalFaxPrinterInstalled);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Can't really tell is local fax printer is installed.
        // Better install anyway, just to be on the safe side.
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsLocalFaxPrinterInstalled failed with %ld"),
            dwRes);
        bLocalFaxPrinterInstalled = FALSE;
    }
    if (!bLocalFaxPrinterInstalled)
    {
        dwRes = AddLocalFaxPrinter (FAX_PRINTER_NAME, NULL);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("AddLocalFaxPrinter failed with %ld"),
                dwRes);
        }
    }
    //
    // Adding a local printer is non-critical - always assume success
    //
    dwRes = ERROR_SUCCESS;

exit:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle (hFile);
    }
    MemFree ((LPVOID)lpcwstrExpandedImage);
    return dwRes;

    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_RegisterServiceProviderEx

error_status_t
FAX_UnregisterServiceProviderEx (
    IN handle_t  hFaxHandle,
    IN LPCWSTR   lpctstrGUID
)
/*++

Routine name : FAX_UnregisterServiceProviderEx

Routine description:

    Unregisters an FSP

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle          [in] - Handle to fax server - unused
    lpctstrGUID         [in] - GUID of FSP
                                (or provider name for legacy FSPs registered
                                 through FaxRegisterServiceProvider)

Return Value:

    Standard RPC error code

--*/
{
    DWORD            dwRes = ERROR_SUCCESS;
    BOOL             fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_UnregisterServiceProviderEx"));

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (lpctstrGUID);
    //
    // Remove the FSP from registry
    //
    return RemoveProviderFromRegistry (lpctstrGUID);

    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_UnregisterServiceProviderEx

//********************************************
//*     Routing Extension unregistration
//********************************************

//
// Registration of routing extensions is local (non-RPC)
//
error_status_t
FAX_UnregisterRoutingExtension (
    IN handle_t  hFaxHandle,
    IN LPCWSTR   lpctstrExtensionName
)
/*++

Routine name : FAX_UnregisterRoutingExtension

Routine description:

    Unregisters a routing extension

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle              [in] - Handle to fax server - unused
    lpctstrExtensionName    [in] - Unique name of routing extension.
                                   This is the actual registry key.

Return Value:

    Standard RPC error code

--*/
{
    DWORD            dwRes = ERROR_SUCCESS;
    BOOL             fAccess;
    HKEY             hKey = NULL;
    DWORD            dw;
    DEBUG_FUNCTION_NAME(TEXT("FAX_UnregisterRoutingExtension"));

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (lpctstrExtensionName);
    //
    // Remove the routing extension from registry
    //
    dwRes = RegOpenKey (HKEY_LOCAL_MACHINE, REGKEY_ROUTING_EXTENSION_KEY, &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error opening extensions key (ec = %ld)"),
            dwRes);
        return dwRes;
    }
    //
    // Delete (recursively) the extension's key and subkeys.
    //
    if (!DeleteRegistryKey (hKey, lpctstrExtensionName))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error deleting extension key ( %s ) (ec = %ld)"),
            lpctstrExtensionName,
            dwRes);
    }
    dw = RegCloseKey (hKey);
    if (ERROR_SUCCESS != dw)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error closing extensions key (ec = %ld)"),
            dw);
    }
    return dwRes;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_UnregisterRoutingExtension


//********************************************
//*               Archive jobs
//********************************************

error_status_t
FAX_StartMessagesEnum (
    IN  handle_t                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER    Folder,
    OUT PRPC_FAX_MSG_ENUM_HANDLE   lpHandle
)
/*++

Routine name : FAX_StartMessagesEnum

Routine description:

    A fax client application calls the FAX_StartMessagesEnum
    function to start enumerating messages in one of the archives

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in ] - Specifies a fax server handle returned by a call
                            to the FaxConnectFaxServer function.

    Folder          [in ] - The type of the archive where the message resides.
                            FAX_MESSAGE_FOLDER_QUEUE is an invalid
                            value for this parameter.

    lpHandle        [out] - Points to an enumeration handle return value.

Return Value:

    Standard RPC error code

--*/
{
    error_status_t   Rval = ERROR_SUCCESS;
    WIN32_FIND_DATA  FileFindData;
    HANDLE           hFileFind = INVALID_HANDLE_VALUE;
    BOOL             bAllMessages = FALSE;
    PSID             pUserSid = NULL;
    LPWSTR           lpwstrCallerSID = NULL;
    WCHAR            wszSearchPattern[MAX_PATH];
    WCHAR            wszArchiveFolder [MAX_PATH];
    PHANDLE_ENTRY    pHandleEntry;
    BOOL             fAccess;
    DWORD            dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_StartMessagesEnum"));

    Assert (lpHandle);
    if ((FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    if (FAX_MESSAGE_FOLDER_INBOX  == Folder)
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_IN_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to enumerate Inbox messages"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_IN_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
        {
            bAllMessages = TRUE;
        }
    }
    else
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_OUT_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to enumerate Outbox messages"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_OUT_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
           bAllMessages = TRUE;
        }
    }


    EnterCriticalSection (&g_CsConfig);
    lstrcpyn (wszArchiveFolder, g_ArchivesConfig[Folder].lpcstrFolder, MAX_PATH);
    LeaveCriticalSection (&g_CsConfig);
    if (!bAllMessages)
    {
        //
        // We want only the messages of the calling user - get its SID.
        //
        pUserSid = GetClientUserSID();
        if (NULL == pUserSid)
        {
            Rval = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("GetClientUserSid failed, Error %ld"), Rval);
            return GetServerErrorCode(Rval);
        }
        if (!ConvertSidToStringSid (pUserSid, &lpwstrCallerSID))
        {
            Rval = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("ConvertSidToStringSid failed, Error %ld"), Rval);
            goto exit;
        }
        if (0 > _snwprintf (wszSearchPattern,
                            MAX_PATH,
                            L"%s\\%s$*.tif",
                            wszArchiveFolder,
                            lpwstrCallerSID))
        {
            //
            // We exceeded MAX_PATH characters
            //
            Rval = ERROR_BUFFER_OVERFLOW;
            DebugPrintEx(DEBUG_ERR,
                     TEXT("Search pattern exceeds MAX_PATH characters"));
            LocalFree (lpwstrCallerSID);
            goto exit;
        }

        LocalFree (lpwstrCallerSID);
    }
    else
    {
        //
        // Get all archive files
        //
        if (0 > _snwprintf (wszSearchPattern,
                            MAX_PATH,
                            L"%s\\*.tif",
                            wszArchiveFolder))
        {
            //
            // We exceeded MAX_PATH characters
            //
            Rval = ERROR_BUFFER_OVERFLOW;
            DebugPrintEx(DEBUG_ERR,
                     TEXT("Search pattern exceeds MAX_PATH characters"));
            goto exit;
        }
    }
    //
    // Start searching the archive folder.
    // Search pattern is wszSearchPattern
    //
    hFileFind = FindFirstFile (wszSearchPattern, &FileFindData);
    if (INVALID_HANDLE_VALUE == hFileFind)
    {
        Rval = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                 TEXT("FindFirstFile failed, Error %ld"), Rval);

        if (ERROR_FILE_NOT_FOUND == Rval)
        {
            Rval = ERROR_NO_MORE_ITEMS;
        }
        goto exit;
    }
    //
    // Now, create a context handle from the result
    //
    pHandleEntry = CreateNewMsgEnumHandle( hFaxHandle,
                                           hFileFind,
                                           FileFindData.cFileName,
                                           Folder
                                         );
    if (!pHandleEntry)
    {
        Rval = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                 TEXT("CreateNewMsgEnumHandle failed, Error %ld"), Rval);
        goto exit;
    }

    *lpHandle = (HANDLE) pHandleEntry;

    Assert (ERROR_SUCCESS == Rval);

exit:
    if ((ERROR_SUCCESS != Rval) && (INVALID_HANDLE_VALUE != hFileFind))
    {
        //
        // Error and the search handle is still open
        //
        if (!FindClose (hFileFind))
        {
            DWORD dw = GetLastError ();
            DebugPrintEx(DEBUG_ERR,
                 TEXT("FindClose failed, Error %ld"), dw);
        }
    }
    MemFree ((LPVOID)pUserSid);
    return GetServerErrorCode(Rval);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_StartMessagesEnum

error_status_t
FAX_EndMessagesEnum (
    IN OUT LPHANDLE  lpHandle
)
/*++

Routine name : FAX_EndMessagesEnum

Routine description:

    A fax client application calls the FAX_EndMessagesEnum function to stop
    enumerating messages in one of the archives.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lpHandle    [in] - The enumeration handle value.
                       This value is obtained by calling FAX_StartMessagesEnum.

Return Value:

    Standard RPC error code

--*/
{
    error_status_t Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EndMessagesEnum"));

    __try
    {
        CloseFaxHandle( (PHANDLE_ENTRY) *lpHandle );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // for some reason we crashed, so return the exception code
        //
        Rval = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CloseFaxHandle on handle 0x%08x caused exception %ld"),
            *lpHandle,
            Rval);
        ASSERT_FALSE
    }
    if (ERROR_SUCCESS == Rval)
    {
        //
        // NULLify the handle so the rundown will not occur
        //
        *lpHandle = NULL;
    }
    return GetServerErrorCode(Rval);
}   // FAX_EndMessagesEnum

VOID
RPC_FAX_MSG_ENUM_HANDLE_rundown(
    IN HANDLE FaxMsgEnumHandle
    )
/*++

Routine name : RPC_FAX_MSG_ENUM_HANDLE_rundown

Routine description:

    The RPC rundown function of the message enumeration handle.
    This function is called if the client abruptly disconnected on us.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    FaxMsgEnumHandle            [in] - Message enumeration handle.

Return Value:

    None.

--*/
{
    PHANDLE_ENTRY pHandleEntry = (PHANDLE_ENTRY) FaxMsgEnumHandle;
    DEBUG_FUNCTION_NAME(TEXT("RPC_FAX_MSG_ENUM_HANDLE_rundown"));

    DebugPrintEx(DEBUG_MSG,
         TEXT("RPC_FAX_MSG_ENUM_HANDLE_rundown: handle = 0x%08x"),
         FaxMsgEnumHandle);
    __try
    {
        CloseFaxHandle( pHandleEntry );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("RPC_FAX_MSG_ENUM_HANDLE_rundown() crashed, ec=0x%08x"),
                      GetExceptionCode());
    }
}   // RPC_FAX_MSG_ENUM_HANDLE_rundown

static
DWORD
RetrieveMessage (
    LPCWSTR                 lpcwstrFileName,
    FAX_ENUM_MESSAGE_FOLDER Folder,
    PFAX_MESSAGE           *ppFaxMsg
)
/*++

Routine name : RetrieveMessage

Routine description:

    Allocates and reads a message from the archive.
    To free the message call FreeMessageBuffer () on the returned message.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lpcwstrFileName     [in ] - Name (not full path) of the file
                                containing the message to retrieve.

    Folder              [in ] - Archive folder where the message resides.


    ppFaxMsg            [out] - Pointer to a message buffer to allocate.

Return Value:

    Standard Win32 error code.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    WCHAR wszMsgFile [MAX_PATH];
    DEBUG_FUNCTION_NAME(TEXT("RetrieveMessage"));

    EnterCriticalSection (&g_CsConfig);
    int iRes = _snwprintf (wszMsgFile,
                           MAX_PATH,
                           L"%s\\%s",
                           g_ArchivesConfig[Folder].lpcstrFolder,
                           lpcwstrFileName
                          );
    LeaveCriticalSection (&g_CsConfig);
    if (0 > iRes)
    {
        //
        // We exceeded MAX_PATH characters
        //
        DebugPrintEx(DEBUG_ERR,
                 TEXT("Search pattern exceeds MAX_PATH characters"));
        return ERROR_BUFFER_OVERFLOW;
    }
    *ppFaxMsg = (PFAX_MESSAGE) MemAlloc (sizeof (FAX_MESSAGE));
    if (NULL == *ppFaxMsg)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Cannot allocate memory for a FAX_MESSAGE structure"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!GetMessageNTFSStorageProperties (wszMsgFile, *ppFaxMsg))
    {
        if(!GetMessageMsTags (wszMsgFile, *ppFaxMsg))
        {
            dwRes = GetLastError ();
            DebugPrintEx( DEBUG_ERR,
                          TEXT("GetMessageNTFSStorageProperties returned error %ld"),
                          dwRes);
            goto exit;
        }
    }

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        MemFree (*ppFaxMsg);
        *ppFaxMsg = NULL;
    }
    return dwRes;
}   // RetrieveMessage


VOID
FreeMessageBuffer (
    PFAX_MESSAGE pFaxMsg,
    BOOL fDestroy
)
/*++

Routine name : FreeMessageBuffer

Routine description:

    Frees a previously allocated message buffer.
    The allocated message was created by calling RetrieveMessage().

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    pFaxMsg         [in] - Message to free
    fDestroy        [in] - Free structure

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FreeMessageBuffer"));
    MemFree ((LPVOID)pFaxMsg->lpctstrRecipientNumber);
    MemFree ((LPVOID)pFaxMsg->lpctstrRecipientName);
    MemFree ((LPVOID)pFaxMsg->lpctstrSenderNumber);
    MemFree ((LPVOID)pFaxMsg->lpctstrSenderName);
    MemFree ((LPVOID)pFaxMsg->lpctstrTsid);
    MemFree ((LPVOID)pFaxMsg->lpctstrCsid);
    MemFree ((LPVOID)pFaxMsg->lpctstrSenderUserName);
    MemFree ((LPVOID)pFaxMsg->lpctstrBillingCode);
    MemFree ((LPVOID)pFaxMsg->lpctstrDeviceName);
    MemFree ((LPVOID)pFaxMsg->lpctstrDocumentName);
    MemFree ((LPVOID)pFaxMsg->lpctstrSubject);
    MemFree ((LPVOID)pFaxMsg->lpctstrCallerID);
    MemFree ((LPVOID)pFaxMsg->lpctstrRoutingInfo);
    MemFree ((LPVOID)pFaxMsg->lpctstrExtendedStatus);

    if (fDestroy)
    {
        MemFree ((LPVOID)pFaxMsg);
    }

}   // FreeMessageBuffer

static
VOID
SerializeMessage (
    LPBYTE          lpBuffer,
    PULONG_PTR      Offset,
    DWORD           dwClientAPIVersion,
    DWORD           dwMsgIndex,
    PFAX_MESSAGE    pMsg)
/*++

Routine name : SerializeMessage

Routine description:

    Stores a FAX_MESSAGE in an RPC serialized manner into a buffer.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lpBuffer        [in    ] - Pointer to buffer head.
                               If this value is NULL, no serialization is done.
                               Only the pupOffset value gets advanced by the total
                               size required to store the strings in the message
                               (but not the FAX_MESSAGE structure itself).

    Offset          [in/out] - Pointer to a ULONG_PTR specifying the next variable
                               length part of the buffer.

    dwClientAPIVersion  [in] - API version of the client

    dwMsgIndex      [in    ] - The 0-based index of the message to store
                               within the buffer

    pMsg            [in    ] - Source message to store

Return Value:

    None.

--*/
{
    Assert (pMsg);
    DEBUG_FUNCTION_NAME(TEXT("SerializeMessage"));
    PFAX_MESSAGE pDstMsg = (PFAX_MESSAGE)&(lpBuffer[sizeof (FAX_MESSAGE) * dwMsgIndex]);

    if (lpBuffer)
    {
        if (FAX_API_VERSION_1 > dwClientAPIVersion)
        {
            //
            // Clients that use API version 0 can't handle JS_EX_CALL_COMPLETED and JS_EX_CALL_ABORTED
            //
            if (pMsg)
            {
                if (FAX_API_VER_0_MAX_JS_EX < pMsg->dwExtendedStatus)
                {
                    //
                    // Turn off the extended status field
                    //
                    pMsg->dwExtendedStatus = 0;
                    pMsg->dwValidityMask &= ~FAX_JOB_FIELD_STATUS_EX;
                }
            }
        }
        //
        // Copy message structure first
        //
        memcpy (pDstMsg,
                pMsg,
                sizeof (FAX_MESSAGE));
    }
    //
    // Serialize strings
    //
    StoreString (pMsg->lpctstrRecipientNumber,
                 (PULONG_PTR)&pDstMsg->lpctstrRecipientNumber,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrRecipientName,
                 (PULONG_PTR)&pDstMsg->lpctstrRecipientName,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrSenderNumber,
                 (PULONG_PTR)&pDstMsg->lpctstrSenderNumber,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrSenderName,
                 (PULONG_PTR)&pDstMsg->lpctstrSenderName,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrTsid,
                 (PULONG_PTR)&pDstMsg->lpctstrTsid,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrCsid,
                 (PULONG_PTR)&pDstMsg->lpctstrCsid,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrSenderUserName,
                 (PULONG_PTR)&pDstMsg->lpctstrSenderUserName,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrBillingCode,
                 (PULONG_PTR)&pDstMsg->lpctstrBillingCode,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrDeviceName,
                 (PULONG_PTR)&pDstMsg->lpctstrDeviceName,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrDocumentName,
                 (PULONG_PTR)&pDstMsg->lpctstrDocumentName,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrSubject,
                 (PULONG_PTR)&pDstMsg->lpctstrSubject,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrCallerID,
                 (PULONG_PTR)&pDstMsg->lpctstrCallerID,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrRoutingInfo,
                 (PULONG_PTR)&pDstMsg->lpctstrRoutingInfo,
                 lpBuffer,
                 Offset);
    StoreString (pMsg->lpctstrExtendedStatus,
                 (PULONG_PTR)&pDstMsg->lpctstrExtendedStatus,
                 lpBuffer,
                 Offset);
}   // SerializeMessage


error_status_t
FAX_EnumMessages(
   IN     RPC_FAX_MSG_ENUM_HANDLE hEnum,
   IN     DWORD                   dwNumMessages,
   IN OUT LPBYTE                 *lppBuffer,
   IN OUT LPDWORD                 lpdwBufferSize,
   OUT    LPDWORD                 lpdwNumMessagesRetrieved
)
/*++

Routine name : FAX_EnumMessages

Routine description:

    A fax client application calls the FAX_EnumMessages function to enumerate
    messages in one of the archives.

    This function is incremental. That is, it uses an internal context cursor to
    point to the next set of messages to retrieve for each call.

    The cursor is set to point to the begging of the messages in the archive after a
    successful call to FAX_StartMessagesEnum.

    Each successful call to FAX_EnumMessages advances the cursor by the number of
    messages retrieved.

    Once the cursor reaches the end of the enumeration,
    the function fails with ERROR_NO_MORE_ITEMS error code.
    The FAX_EndMessagesEnum function should be called then.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hEnum                       [in ] - The enumeration handle value.
                                        This value is obtained by calling
                                        FAX_StartMessagesEnum.

    dwNumMessages               [in ] - A DWORD value indicating the maximal number
                                        of messages the caller requires to enumerate.
                                        This value cannot be zero.

    lppBuffer                   [out] - A pointer to a buffer of FAX_MESSAGE structures.
                                        This buffer will contain lpdwReturnedMsgs entries.
                                        The buffer will be allocated by the function
                                        and the caller must free it.

    lpdwBufferSize              [out] - The size (in bytes) of the lppBuffer buffer.

    lpdwNumMessagesRetrieved    [out] - Pointer to a DWORD value indicating the actual
                                        number of messages retrieved.
                                        This value cannot exceed dwNumMessages.

Return Value:

    Standard RPC error code

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    DWORD           dw;
    DWORD_PTR       dwOffset;
    PFAX_MESSAGE   *pMsgs = NULL;
    DWORD           dwClientAPIVersion;
    PHANDLE_ENTRY   pHandle = (PHANDLE_ENTRY)hEnum;

    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumMessages"));

    dwClientAPIVersion = pHandle->dwClientAPIVersion;

    Assert (lpdwBufferSize && lpdwNumMessagesRetrieved);    // ref pointer in idl
    if (!lppBuffer)                                         // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    Assert (hEnum && (INVALID_HANDLE_VALUE != pHandle->hFile));
    if (!dwNumMessages)
    {
        return ERROR_INVALID_PARAMETER;
    }
    //
    // Create array of dwNumMessages pointers to FAX_MESSAGE structures and NULLify it.
    //
    pMsgs = (PFAX_MESSAGE *) MemAlloc (sizeof (PFAX_MESSAGE) * dwNumMessages);
    if (!pMsgs)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Cannot allocate memory for a PFAX_MESSAGE array [%ld]"),
                      dwNumMessages);
        return FAX_ERR_SRV_OUTOFMEMORY;
    }
    memset (pMsgs, 0, sizeof (PFAX_MESSAGE) * dwNumMessages);
    //
    // Next, start collecting messages into the array.
    // Stop when dwNumMessages is reached or no more messages are available.
    //
    *lpdwBufferSize = 0;
    *lpdwNumMessagesRetrieved = 0;
    while ((*lpdwNumMessagesRetrieved) < dwNumMessages)
    {
        DWORD_PTR       dwMsgSize = sizeof (FAX_MESSAGE);
        LPWSTR          lpwstrFileToRetrieve;
        WIN32_FIND_DATA FindData;

        if (lstrlen (pHandle->wstrFileName))
        {
            //
            // This is the first file in an enumeration session
            //
            lpwstrFileToRetrieve = pHandle->wstrFileName;
        }
        else
        {
            //
            // Find next file using the find file handle
            //
            if (!FindNextFile (pHandle->hFile, &FindData))
            {
                Rval = GetLastError ();
                if (ERROR_NO_MORE_FILES == Rval)
                {
                    //
                    // This is not a real error - just the end of files.
                    // Break the loop.
                    //
                    Rval = ERROR_SUCCESS;
                    break;
                }
                DebugPrintEx( DEBUG_ERR,
                              TEXT("FindNextFile returned error %ld"),
                              Rval);
                goto exit;
            }
            lpwstrFileToRetrieve = FindData.cFileName;
        }
        //
        // Get the message now from lpwstrFileToRetrieve
        //
        Rval = RetrieveMessage (lpwstrFileToRetrieve,
                                pHandle->Folder,
                                &(pMsgs[*lpdwNumMessagesRetrieved]));
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("RetrieveMessage returned error %ld"),
                          Rval);

            if (ERROR_NOT_ENOUGH_MEMORY != Rval && ERROR_OUTOFMEMORY != Rval)
            {
                //
                //  The error is related to the Message itself.
                //  This will not stop us from searching the rest of the messages.
                //

                //
                // Mark (in the enumeration handle) the fact that the first file was read.
                //
                lstrcpy (pHandle->wstrFileName, L"");
                continue;
            }
            goto exit;
        }
        //
        // Mark (in the enumeration handle) the fact that the first file was read.
        //
        lstrcpy (pHandle->wstrFileName, L"");
        //
        // Get the size of the retrieved message
        //
        SerializeMessage (NULL, &dwMsgSize, dwClientAPIVersion, 0, pMsgs[*lpdwNumMessagesRetrieved]);

        *lpdwBufferSize += (DWORD)dwMsgSize;
        (*lpdwNumMessagesRetrieved)++;
    }   // End of enumeration loop

    if (0 == *lpdwNumMessagesRetrieved)
    {
        //
        // No file(s) retrieved
        //
        *lppBuffer = NULL;
        Assert (0 == *lpdwBufferSize);
        Rval = ERROR_NO_MORE_ITEMS;
        goto exit;
    }
    //
    // Allocate return buffer
    //
    *lppBuffer = (LPBYTE) MemAlloc (*lpdwBufferSize);
    if (!*lppBuffer)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Cannot allocate memory for return buffer (%ld bytes)"),
                      *lpdwBufferSize);
        Rval = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    //
    // Place all messages in the return buffer
    //
    dwOffset = sizeof(FAX_MESSAGE) * (*lpdwNumMessagesRetrieved);
    for (dw = 0; dw < *lpdwNumMessagesRetrieved; dw++)
    {
        //
        // Store retrieved message in return buffer
        //
        SerializeMessage (*lppBuffer, &dwOffset, dwClientAPIVersion, dw, pMsgs[dw]);
    }
    Assert (dwOffset == *lpdwBufferSize);
    Assert (ERROR_SUCCESS == Rval);

exit:

    //
    // Free local array of messages
    //
    for (dw = 0; dw < dwNumMessages; dw++)
    {
        if (NULL != pMsgs[dw])
        {
            FreeMessageBuffer (pMsgs[dw], TRUE);
        }
    }
    //
    // Free array of message pointers
    //
    MemFree (pMsgs);
    return GetServerErrorCode(Rval);
}   // FAX_EnumMessages

static
DWORD
FindArchivedMessage (
    FAX_ENUM_MESSAGE_FOLDER Folder,
    DWORDLONG               dwlMsgId,
    BOOL                    bAllMessages,
    LPWSTR                  lpwstrFileName,
    LPWSTR                  lpwstrFilePath
)
/*++

Routine name : FindArchivedMessage

Routine description:

    Finds the file containing the message in an archive

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    Folder          [in ] - Archive / queue folder
    dwlMessageId    [in ] - Unique message id
    bAllMessages    [in ] - TRUE if the caller is allowed to view all messages
    lpwstrFileName  [out] - Optional. If not NULL, will contain the file name
                            and extension of the archive message file.
    lpwstrFilePath  [out] - Optional. If not NULL, will contain the full path
                            of the archive message file.


Return Value:

    Standard RPC error code

--*/
{
    WCHAR           wszArchiveFolder[MAX_PATH];
    DWORD           dwRes = ERROR_SUCCESS;
    LPWSTR          lpwstrResultFullPath;
    DEBUG_FUNCTION_NAME(TEXT("FindArchivedMessage"));

    EnterCriticalSection (&g_CsConfig);
    lstrcpyn (wszArchiveFolder, g_ArchivesConfig[Folder].lpcstrFolder, MAX_PATH);
    LeaveCriticalSection (&g_CsConfig);

    if (FAX_MESSAGE_FOLDER_INBOX == Folder)
    {
        Assert (TRUE == bAllMessages);
        //
        // Get full name of Inbox archive file
        //
        lpwstrResultFullPath = GetRecievedMessageFileName (dwlMsgId);
        if (!lpwstrResultFullPath)
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetRecievedMessageFileName Failed, Error %ld"), dwRes);
            return dwRes;
        }
    }
    else if (FAX_MESSAGE_FOLDER_SENTITEMS == Folder)
    {
        //
        // Get full name of sent items archive file
        //
        PSID             pUserSid = NULL;

        if (!bAllMessages)
        {
            //
            // If the user doesn't have the right to view all messages
            //
            // Get SID of caller
            //
            pUserSid = GetClientUserSID();
            if (NULL == pUserSid)
            {
                dwRes = GetLastError();
                DebugPrintEx(DEBUG_ERR,
                         TEXT("GetClientUserSid failed, Error %ld"), dwRes);
                return dwRes;
            }
        }
        //
        // Get full name of sent items archive file
        //
        lpwstrResultFullPath = GetSentMessageFileName (dwlMsgId, pUserSid);
        if (!lpwstrResultFullPath)
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetSentMessageFileName Failed, Error %ld"), dwRes);
            MemFree ((LPVOID)pUserSid);
            return dwRes;
        }
        MemFree ((LPVOID)pUserSid);
    }
    else
    {
        //
        // We don't support any other archive type
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad archive folder type %ld"), Folder);
        ASSERT_FALSE;
    }
    if (MAX_PATH < lstrlen (lpwstrResultFullPath))
    {
        //
        // We exceeded MAX_PATH characters
        //
        DebugPrintEx(DEBUG_ERR,
                 TEXT("Message file path exceeds MAX_PATH characters"));
        MemFree ((LPVOID)lpwstrResultFullPath);
        return ERROR_BUFFER_OVERFLOW;
    }
    if (lpwstrFilePath)
    {
        //
        // Copy full path back to caller
        //
        lstrcpy (lpwstrFilePath, lpwstrResultFullPath);
    }
    if (lpwstrFileName)
    {
        WCHAR wszExt[_MAX_EXT];
        //
        // Split just the file name back to the caller (optional)
        //
        _wsplitpath (lpwstrResultFullPath, NULL, NULL, lpwstrFileName, wszExt);
        lstrcat (lpwstrFileName, wszExt);
    }
    MemFree ((LPVOID)lpwstrResultFullPath);
    return ERROR_SUCCESS;
}   // FindArchivedMessage


static
DWORD
CreatePreviewFile (
    DWORDLONG               dwlMsgId,
    BOOL                    bAllMessages,
    PJOB_QUEUE*             lppJobQueue
)
/*++

Routine name : CreatePreviewFile

Routine description:

    Creates a tiff preview file it if does not exist.
    If the function succeeds it increase the job reference count.

Author:

    Oded Sacher (OdedS), Jan, 2000

Arguments:

    dwlMessageId    [in ] - Unique message id
    bAllMessages    [in ] - TRUE if the caller has right to view all messages
    lppJobQueue     [out] - Address of a pointer to receive the job queue with the new preview file.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD           dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CreatePreviewFile"));
    PJOB_QUEUE       pJobQueue;
    PSID             pUserSid = NULL;
    DWORD            dwJobStatus;

    Assert (lppJobQueue);


    EnterCriticalSection (&g_CsQueue);

    //
    // Find queue entry
    //
    pJobQueue = FindJobQueueEntryByUniqueId (dwlMsgId);
    //
    // The caller may view incoming jobs only if they are ROUTING
    // (if they are successfully finished with routing, they're in the archive) or
    // outgoing jobs that are SEND (that is - not broadcast).
    //
    if (pJobQueue == NULL)
    {
        //
        // dwlMsgId is not in the queue .
        //
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Invalid Parameter - bad job Id (%I64ld) ,not in the queue"),
                     dwlMsgId);
        dwRes = FAX_ERR_MESSAGE_NOT_FOUND;
        goto exit;

    }

    dwJobStatus = (JT_SEND== pJobQueue->JobType) ? pJobQueue->lpParentJob->JobStatus : pJobQueue->JobStatus;
    if (dwJobStatus == JS_DELETING)
    {
        //
        // Job is being deleted.
        //
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Invalid Parameter - job Id (%I64ld) is being deleted"),
                     dwlMsgId);
        dwRes = FAX_ERR_MESSAGE_NOT_FOUND;
        goto exit;
    }

    if ( (pJobQueue->JobType != JT_ROUTING) &&
         (pJobQueue->JobType != JT_SEND) )
    {
        //
        // dwlMsgId is not a valid job id in the queue.
        //
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Invalid Parameter - bad job Id (%I64ld), not a recipient or routing job"),
                     dwlMsgId);
        dwRes = ERROR_INVALID_OPERATION;
        goto exit;
    }

    //
    // Basic access checks
    //
    if (!bAllMessages)
    {
        //
        // Make sure the user looks only at his own messages here
        // Get SID of caller
        //
        pUserSid = GetClientUserSID();
        if (NULL == pUserSid)
        {
            dwRes = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("GetClientUserSid failed, Error %ld"), dwRes);
            goto exit;
        }
        if (!UserOwnsJob (pJobQueue, pUserSid))
        {
            DebugPrintEx(DEBUG_WRN,TEXT("UserOwnsJob failed ,Access denied"));
            dwRes = ERROR_ACCESS_DENIED;
            goto exit;
        }
    }

    //
    // Create tiff preview file
    //
    EnterCriticalSection (&pJobQueue->CsPreview);
    if (!CreateTiffFileForPreview(pJobQueue))
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] CreateTiffFileForPreview failed. (ec: %ld)"),
            pJobQueue->JobId,
            dwRes
            );
        LeaveCriticalSection (&pJobQueue->CsPreview);
        goto exit;
    }
    LeaveCriticalSection (&pJobQueue->CsPreview);

    Assert (pJobQueue->PreviewFileName);

    //
    // Return the job queue back to caller
    //
    *lppJobQueue = pJobQueue;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    MemFree ((LPVOID)pUserSid);
    if (ERROR_SUCCESS == dwRes)
    {
        IncreaseJobRefCount (pJobQueue, TRUE);
    }
    LeaveCriticalSection (&g_CsQueue);
    return dwRes;
}   // CreatePreviewFile


error_status_t
FAX_GetMessage (
    IN handle_t                 hFaxHandle,
    IN DWORDLONG                dwlMessageId,
    IN FAX_ENUM_MESSAGE_FOLDER  Folder,
    IN OUT LPBYTE              *lppBuffer,
    IN OUT LPDWORD             lpdwBufferSize
)
/*++

Routine name : FAX_GetMessage

Routine description:

    Removes a message from an archive

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in ] - Unused
    dwlMessageId    [in ] - Unique message id
    Folder          [in ] - Archive folder
    lppBuffer       [out] - Pointer to buffer to hold message information
    lpdwBufferSize  [out] - Pointer to buffer size

Return Value:

    Standard RPC error code

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    DWORD_PTR       dwOffset;
    PFAX_MESSAGE    pMsg = NULL;
    WCHAR           wszMsgFileName[MAX_PATH];
    BOOL            fAccess;
    DWORD           dwRights;
    BOOL            bAllMessages = FALSE;
    DWORD           dwClientAPIVersion;

    DEBUG_FUNCTION_NAME(TEXT("FAX_GetMessage"));

    dwClientAPIVersion = FindClientAPIVersion (hFaxHandle);

    Assert (lpdwBufferSize);    // ref pointer in idl
    if (!lppBuffer)             // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!dwlMessageId)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid message id sepcified (%I64ld)"),
            dwlMessageId);
        return ERROR_INVALID_PARAMETER;
    }
    if ((FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_MESSAGE_FOLDER_INBOX  == Folder)
    {
        if (FAX_ACCESS_QUERY_IN_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to view Inbox messages"));
            return ERROR_ACCESS_DENIED;
        }
        bAllMessages = TRUE;

    }
    else
    {
        Assert (FAX_MESSAGE_FOLDER_SENTITEMS == Folder);

        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_OUT_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to view Sent items messages"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_OUT_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            bAllMessages = TRUE;
        }
    }

    //
    // Locate the file the caller's talking about
    //
    Rval = FindArchivedMessage (Folder, dwlMessageId, bAllMessages, wszMsgFileName, NULL);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindArchivedMessage returned %ld"),
            Rval);
        if (ERROR_FILE_NOT_FOUND == Rval)
        {
            Rval = FAX_ERR_MESSAGE_NOT_FOUND;
        }
        return GetServerErrorCode(Rval);
    }
    //
    // Retrieve FAX_MESSAGE information
    //
    Rval = RetrieveMessage (wszMsgFileName,
                            Folder,
                            &pMsg);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("RetrieveMessage returned error %ld"),
                      Rval);
        if (ERROR_FILE_NOT_FOUND == Rval)
        {
            Rval = FAX_ERR_MESSAGE_NOT_FOUND;
        }
        return GetServerErrorCode(Rval);
    }
    //
    // Calculate required message size
    //
    // until MIDL accepts [out, size_is(,__int64*)]
    ULONG_PTR upBufferSize = sizeof (FAX_MESSAGE);
    SerializeMessage (NULL, &upBufferSize, dwClientAPIVersion, 0, pMsg);
    *lpdwBufferSize = DWORD(upBufferSize);

    //
    // Allocate return buffer
    //
    *lppBuffer = (LPBYTE) MemAlloc (*lpdwBufferSize);
    if (!*lppBuffer)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Cannot allocate memory for return buffer (%ld bytes)"),
                      *lpdwBufferSize);
        Rval = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    //
    // Serialize message in the return buffer
    //
    dwOffset = sizeof(FAX_MESSAGE);
    SerializeMessage (*lppBuffer, &dwOffset, dwClientAPIVersion, 0, pMsg);

    Assert (ERROR_SUCCESS == Rval);

exit:

    if (pMsg)
    {
        FreeMessageBuffer (pMsg, TRUE);
    }
    return GetServerErrorCode(Rval);
}   // FAX_GetMessage

error_status_t
FAX_RemoveMessage (
    IN handle_t                 hFaxHandle,
    IN DWORDLONG                dwlMessageId,
    IN FAX_ENUM_MESSAGE_FOLDER  Folder
)
/*++

Routine name : FAX_RemoveMessage

Routine description:

    Removes a message from an archive

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in] - Unused
    dwlMessageId    [in] - Unique message id
    Folder          [in] - Archive folder

Return Value:

    Standard RPC error code

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    WCHAR           wszMsgFilePath[MAX_PATH];
    HANDLE          hFind;
    WIN32_FIND_DATA FindFileData;
    DWORDLONG       dwlFileSize = 0;
    BOOL            fAccess;
    DWORD           dwRights;
    BOOL            bAllMessages = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("FAX_RemoveMessage"));
    if (!dwlMessageId)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid message id sepcified (%I64ld)"),
            dwlMessageId);
        return ERROR_INVALID_PARAMETER;
    }
    if ((FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_MESSAGE_FOLDER_INBOX == Folder)
    {
        if (FAX_ACCESS_MANAGE_IN_ARCHIVE != (dwRights & FAX_ACCESS_MANAGE_IN_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to manage Inbox messages"));
            return ERROR_ACCESS_DENIED;
        }
        bAllMessages = TRUE;
    }
    else
    {
        Assert (FAX_MESSAGE_FOLDER_SENTITEMS == Folder);

        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_MANAGE_OUT_ARCHIVE != (dwRights & FAX_ACCESS_MANAGE_OUT_ARCHIVE))
        {
                DebugPrintEx(DEBUG_ERR,
                            TEXT("The user does not have the needed rights to manage Sent items messages"));
                return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_MANAGE_OUT_ARCHIVE == (dwRights & FAX_ACCESS_MANAGE_OUT_ARCHIVE))
        {
            bAllMessages = TRUE;
        }
    }

    //
    // Locate the file the caller's talking about
    //
    Rval = FindArchivedMessage (Folder, dwlMessageId, bAllMessages, NULL, wszMsgFilePath);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindArchivedMessage returned %ld"),
            Rval);
        if (ERROR_FILE_NOT_FOUND == Rval)
        {
            Rval = FAX_ERR_MESSAGE_NOT_FOUND;
        }
        return GetServerErrorCode(Rval);
    }
    //
    // Get the file size
    //
    hFind = FindFirstFile( wszMsgFilePath, &FindFileData);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindFirstFile failed (ec: %lc), File %s"),
            GetLastError(),
            wszMsgFilePath);
    }
    else
    {
        dwlFileSize = (MAKELONGLONG(FindFileData.nFileSizeLow ,FindFileData.nFileSizeHigh));
        if (!FindClose(hFind))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindClose failed (ec: %lc)"),
                GetLastError());
        }
    }

    //
    // Try to remove the file (message)
    //
    if (!DeleteFile (wszMsgFilePath))
    {
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("DeleteFile returned %ld on %s"),
            Rval,
            wszMsgFilePath);

        if (ERROR_ACCESS_DENIED == Rval ||
            ERROR_SHARING_VIOLATION == Rval)
        {
            Rval = FAX_ERR_FILE_ACCESS_DENIED;
        }
        else if (ERROR_FILE_NOT_FOUND == Rval)
        {
            Rval = FAX_ERR_MESSAGE_NOT_FOUND;
        }
    }
    else
    {
        // Send event and update archive size for quota management

        PSID lpUserSid = NULL;
        DWORD dwRes;
        FAX_ENUM_EVENT_TYPE EventType;

        if (FAX_MESSAGE_FOLDER_INBOX == Folder)
        {
            EventType = FAX_EVENT_TYPE_IN_ARCHIVE;
        }
        else
        {
            EventType = FAX_EVENT_TYPE_OUT_ARCHIVE;
            if (!GetMessageIdAndUserSid (wszMsgFilePath, Folder, &lpUserSid, NULL)) // We do not need message id
            {
                dwRes = GetLastError();
                DebugPrintEx(DEBUG_ERR,
                             TEXT("GetMessageIdAndUserSid Failed, Error : %ld"),
                             dwRes);
                return Rval;
            }
        }

        dwRes = CreateArchiveEvent (dwlMessageId, EventType, FAX_JOB_EVENT_TYPE_REMOVED, lpUserSid);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_*_ARCHIVE) failed (ec: %lc)"),
                dwRes);
        }

        if (NULL != lpUserSid)
        {
            LocalFree (lpUserSid);
            lpUserSid = NULL;
        }

        if (0 != dwlFileSize)
        {
            // Update archive size
            EnterCriticalSection (&g_CsConfig);
            if (FAX_ARCHIVE_FOLDER_INVALID_SIZE != g_ArchivesConfig[Folder].dwlArchiveSize)
            {
                g_ArchivesConfig[Folder].dwlArchiveSize -= dwlFileSize;
            }
            LeaveCriticalSection (&g_CsConfig);
        }
    }

    return GetServerErrorCode(Rval);
}   // FAX_RemoveMessage

//********************************************
//*               RPC copy
//********************************************

error_status_t
FAX_StartCopyToServer (
    IN  handle_t              hFaxHandle,
    IN  LPCWSTR               lpcwstrFileExt,
    OUT LPWSTR                lpwstrServerFileName,
    OUT PRPC_FAX_COPY_HANDLE  lpHandle
)
/*++

Routine name : FAX_StartCopyToServer

Routine description:

    Start to copy a file to the server

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle           [in ] - Handle to server
    lpcwstrFileExt       [in ] - Extension of file to create on the server
    lpwstrServerFileName [out] - File name (and extension) of file created on the server
    handle               [out] - RPC copy handle

Return Value:

    Standard RPC error code

--*/
{
    error_status_t   Rval = ERROR_SUCCESS;
    HANDLE           hFile = INVALID_HANDLE_VALUE;
    PSID             pUserSid = NULL;
	LPWSTR			 lpwstrUserSid = NULL;
    PHANDLE_ENTRY    pHandleEntry;
    WCHAR            wszQueueFileName[MAX_PATH] = {0};
	WCHAR            wszUserSidPrefix[MAX_PATH] = {0};
    LPWSTR           pwstr;    
	BOOL			fAccess;
	DWORD			dwRights;
	int				Count;
    DEBUG_FUNCTION_NAME(TEXT("FAX_StartCopyToServer"));

    Assert (lpHandle && lpwstrServerFileName && lpcwstrFileExt);
    if (!lstrlen (lpcwstrFileExt))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad extension specified (%s)"),
            lpcwstrFileExt);
        return ERROR_INVALID_PARAMETER;
    }

	//
	// Access check
	//
	Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
	if (ERROR_SUCCESS != Rval)
	{
		DebugPrintEx(DEBUG_ERR,
					TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
					Rval);
		return Rval;
	}

	if (0 == ((FAX_ACCESS_SUBMIT | FAX_ACCESS_SUBMIT_NORMAL | FAX_ACCESS_SUBMIT_HIGH) & dwRights))
	{
		DebugPrintEx(DEBUG_ERR,
					TEXT("The user does not have any Fax submission rights"));
		return ERROR_ACCESS_DENIED;
	}

    //
    //Get the user SID
    //
    pUserSid = GetClientUserSID();
    if (NULL == pUserSid)
    {
       Rval = GetLastError();
       DebugPrintEx(DEBUG_ERR,
                    TEXT("GetClientUserSid Failed, Error : %ld"),
                    Rval);
       return GetServerErrorCode(Rval);
    }	

    if (!ConvertSidToStringSid (pUserSid, &lpwstrUserSid))
    {
		Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ConvertSidToStringSid Failed, error : %ld"),
            Rval);
        goto exit;
    }

	Count = _snwprintf (
		wszUserSidPrefix,
		ARR_SIZE(wszUserSidPrefix)-1,
		L"%s$",
		lpwstrUserSid);

    if (Count < 0)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("_snwprintf Failed, File name bigger than MAX_PATH"));
        Rval = ERROR_BUFFER_OVERFLOW;        
        goto exit;
    }

    //
    // Generate unique file in server's queue
    //
    DWORDLONG dwl = GenerateUniqueFileNameWithPrefix(
							FALSE,
                            g_wszFaxQueueDir,
							wszUserSidPrefix,
                            (LPWSTR)lpcwstrFileExt,							
                            wszQueueFileName,
                            sizeof(wszQueueFileName)/sizeof(wszQueueFileName[0]));
    if (0 == dwl)
    {
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GenerateUniqueFileName failed, ec = %d"),
            Rval);
        goto exit;
    }
    //
    // Open the file for writing (again)
    //
    hFile = CreateFile (
                    wszQueueFileName,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Opening %s for read failed (ec: %ld)"),
            wszQueueFileName,
            Rval);
        goto exit;
    }

	//
    // Get the filename.ext to return buffer (skip the user sid prefix)
    //
    pwstr = wcsrchr( wszQueueFileName, L'$');
    Assert (pwstr);
    //
    // Skip the path and sid prefix
    //
    pwstr++;

    //
    // Create copy context
    //
    pHandleEntry = CreateNewCopyHandle( hFaxHandle,
                                        hFile,
                                        TRUE,     // Copy to server
                                        wszQueueFileName,
                                        NULL);

    if (!pHandleEntry)
    {
        Rval = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                 TEXT("CreateNewCopyHandle failed, Error %ld"), Rval);
        goto exit;
    }
    
    wcsncpy( lpwstrServerFileName, pwstr , MAX_PATH );
    //
    // Return context handle
    //
    *lpHandle = (HANDLE) pHandleEntry;

    Assert (ERROR_SUCCESS == Rval);

exit:

    if (ERROR_SUCCESS != Rval)
    {
        //
        // Some error occured
        //
        if (INVALID_HANDLE_VALUE != hFile)
        {
            //
            // Close the file
            //
            if (CloseHandle (hFile))
            {
                DWORD dwErr = GetLastError ();
                DebugPrintEx(DEBUG_ERR,
                    TEXT("CloseHandle failed, Error %ld"), dwErr);
            }
        }
        if (lstrlen (wszQueueFileName))
        {
            //
            // Remove unused queue file
            //
            if (!DeleteFile (wszQueueFileName))
            {
                DWORD dwErr = GetLastError ();
                DebugPrintEx(DEBUG_ERR,
                    TEXT("DeleteFile failed on %s, Error %ld"),
                    wszQueueFileName,
                    dwErr);
            }
        }
    }
	if (NULL != lpwstrUserSid)
	{
		LocalFree(lpwstrUserSid);
	}
	MemFree (pUserSid);
    return Rval;
}   // FAX_StartCopyToServer


error_status_t
FAX_StartCopyMessageFromServer (
    IN  handle_t                   hFaxHandle,
    IN  DWORDLONG                  dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER    Folder,
    OUT PRPC_FAX_COPY_HANDLE       lpHandle
)
/*++

Routine name : FAX_StartCopyMessageFromServer

Routine description:

    Starts a copy process of a message from the server's archive / queue
    to the caller

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in ] - Handle to server
    dwlMessageId    [in ] - Message id
    Folder          [in ] - Archive / queue folder
    handle          [out] - RPC copy handle

Return Value:

    Standard RPC error code

--*/
{
    error_status_t   Rval = ERROR_SUCCESS;
    HANDLE           hFile = INVALID_HANDLE_VALUE;
    PHANDLE_ENTRY    pHandleEntry;
    PJOB_QUEUE       pJobQueue = NULL;
    WCHAR            wszFileName[MAX_PATH] = {0};
    BOOL             bAllMessages = FALSE;
    BOOL             fAccess;
    DWORD            dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_StartCopyMessageFromServer"));

    Assert (lpHandle);
    if (!dwlMessageId)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("zero message id sepcified"));
        return ERROR_INVALID_PARAMETER;
    }
    if ((FAX_MESSAGE_FOLDER_QUEUE != Folder) &&
        (FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_MESSAGE_FOLDER_INBOX == Folder)
    {
        if (FAX_ACCESS_QUERY_IN_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to preview Inbox tiff files"));
            return ERROR_ACCESS_DENIED;
        }
        bAllMessages = TRUE;
    }

    if (FAX_MESSAGE_FOLDER_SENTITEMS == Folder)
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_OUT_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to preview Sent items tiff files"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_OUT_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            bAllMessages = TRUE;
        }
    }

    if (FAX_MESSAGE_FOLDER_QUEUE == Folder)
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_JOBS != (dwRights & FAX_ACCESS_QUERY_JOBS))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to preview Outbox tiff files"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_JOBS == (dwRights & FAX_ACCESS_QUERY_JOBS))
        {
            bAllMessages = TRUE;
        }
    }

    //
    // Locate the file the caller's talking about
    //
    if (FAX_MESSAGE_FOLDER_QUEUE == Folder)
    {
        Rval = CreatePreviewFile (dwlMessageId, bAllMessages, &pJobQueue);
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreatePreviewFile returned %ld"),
                Rval);
            return GetServerErrorCode(Rval);
        }
        Assert (pJobQueue && pJobQueue->PreviewFileName && pJobQueue->UniqueId == dwlMessageId);
        Assert (wcslen(pJobQueue->PreviewFileName) < MAX_PATH);
        wcscpy (wszFileName, pJobQueue->PreviewFileName);
    }
    else
    {
        Assert (FAX_MESSAGE_FOLDER_SENTITEMS == Folder ||
                FAX_MESSAGE_FOLDER_INBOX == Folder);

        Rval = FindArchivedMessage (Folder, dwlMessageId, bAllMessages, NULL , wszFileName);
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindArchivedMessage returned %ld"),
                Rval);

            if (ERROR_FILE_NOT_FOUND == Rval)
            {
                Rval = FAX_ERR_MESSAGE_NOT_FOUND;
            }
            return GetServerErrorCode(Rval);
        }
    }

    //
    // Open the file for reading
    //
    Assert (wcslen(wszFileName));

    hFile = CreateFile (
                    wszFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        // We must decrease the job refrence count if it is a queued job.
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Opening %s for read failed (ec: %ld)"),
            wszFileName,
            Rval);
        goto exit;
    }
    //
    // Create copy context
    //
    pHandleEntry = CreateNewCopyHandle( hFaxHandle,
                                        hFile,
                                        FALSE,    // Copy from server
                                        NULL,
                                        pJobQueue);
    if (!pHandleEntry)
    {
        Rval = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                 TEXT("CreateNewCopyHandle failed, Error %ld"), Rval);
        goto exit;
    }
    //
    // Return context handle
    //
    *lpHandle = (HANDLE) pHandleEntry;

    Assert (ERROR_SUCCESS == Rval);

exit:
    if (ERROR_SUCCESS != Rval)
    {
        if (FAX_MESSAGE_FOLDER_QUEUE == Folder)
        {
            // Decrease ref count only if it is a queued job.
            EnterCriticalSection (&g_CsQueue);
            DecreaseJobRefCount (pJobQueue, TRUE, TRUE, TRUE);  // TRUE for Preview ref count.
            LeaveCriticalSection (&g_CsQueue);
        }

        if (INVALID_HANDLE_VALUE != hFile)
        {
            //
            // Some error occured - close the file
            //
            if (CloseHandle (hFile))
            {
                DWORD dwErr = GetLastError ();
                DebugPrintEx(DEBUG_ERR,
                    TEXT("CloseHandle failed, Error %ld"), dwErr);
            }
        }
    }
    return GetServerErrorCode(Rval);
}   // FAX_StartCopyMessageFromServer

error_status_t
FAX_WriteFile (
    IN RPC_FAX_COPY_HANDLE    hCopy,                  // RPC copy handle
    IN LPBYTE                 lpbData,                // Data chunk to append to file on server
    IN DWORD                  dwDataSize              // Size of data chunk
)
/*++

Routine name : FAX_WriteFile

Routine description:

    Copies a chunk of data to the server's queue

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hCopy           [in] - Copy context handle
    lpbData         [in] - Pointer to buffer to copy from
    chunk           [in] - Size of source buffer

Return Value:

    Standard RPC error code

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    PHANDLE_ENTRY   pHandle = (PHANDLE_ENTRY)hCopy;
    DWORD           dwBytesWritten;
	BOOL			fAccess;
	DWORD			dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_WriteFile"));

    Assert (lpbData && (INVALID_HANDLE_VALUE != pHandle->hFile));

	//
	// Access check
	//
	Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
	if (ERROR_SUCCESS != Rval)
	{
		DebugPrintEx(DEBUG_ERR,
					TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
					Rval);
		return Rval;
	}

	if (0 == ((FAX_ACCESS_SUBMIT | FAX_ACCESS_SUBMIT_NORMAL | FAX_ACCESS_SUBMIT_HIGH) & dwRights))
	{
		DebugPrintEx(DEBUG_ERR,
					TEXT("The user does not have any Fax submission rights"));
		return ERROR_ACCESS_DENIED;
	}

    if (!pHandle->bCopyToServer)
    {
        DebugPrintEx(DEBUG_ERR,
            TEXT("Handle was created using FAX_StartCopyMessageFromServer"));
        return ERROR_INVALID_HANDLE;
    }
    if (!dwDataSize)
    {
        DebugPrintEx(DEBUG_ERR,
            TEXT("Zero data size"));
        return ERROR_INVALID_PARAMETER;
    }	

    if (!WriteFile (pHandle->hFile,
                    lpbData,
                    dwDataSize,
                    &dwBytesWritten,
                    NULL))
    {
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("WriteFile failed (ec: %ld)"),
            Rval);
        pHandle->bError = TRUE; // Erase local queue file on handle close
        goto exit;
    }
    if (dwBytesWritten != dwDataSize)
    {
        //
        // Strange situation
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("WriteFile was asked to write %ld bytes but wrote only %ld bytes"),
            dwDataSize,
            dwBytesWritten);
        Rval = ERROR_GEN_FAILURE;
        pHandle->bError = TRUE; // Erase local queue file on handle close
        goto exit;
    }

    Assert (ERROR_SUCCESS == Rval);

exit:
    return Rval;
}   // FAX_WriteFile

error_status_t
FAX_ReadFile (
    IN  RPC_FAX_COPY_HANDLE   hCopy,                  // RPC copy handle
    IN  DWORD                 dwMaxDataSize,          // Max size of data to copy
    OUT LPBYTE                lpbData,                // Data buffer to retrieve from server
    OUT LPDWORD               lpdwDataSize            // Size of data retrieved
)
/*++

Routine name : FAX_ReadFile

Routine description:

    Copies a file from the server (in chunks)

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hCopy           [in ] - Copy context
    dwMaxDataSize   [in ] - Max chunk size
    lpbData         [in ] - Pointer to output data buffer
    retrieved       [out] - Number of bytes actually read.
                            A value of zero indicates EOF.

Return Value:

    Standard RPC error code

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    PHANDLE_ENTRY   pHandle = (PHANDLE_ENTRY)hCopy;
    DEBUG_FUNCTION_NAME(TEXT("FAX_ReadFile"));

    Assert (lpdwDataSize && lpbData && (INVALID_HANDLE_VALUE != pHandle->hFile));
    if (pHandle->bCopyToServer)
    {
        DebugPrintEx(DEBUG_ERR,
            TEXT("Handle was created using FAX_StartCopyToServer"));
        return ERROR_INVALID_HANDLE;
    }
    if (!dwMaxDataSize)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("zero dwMaxDataSizee specified"));
        return ERROR_INVALID_PARAMETER;
    }

    if (!ReadFile (pHandle->hFile,
                   lpbData,
                   dwMaxDataSize,
                   lpdwDataSize,
                   NULL))
    {
        Rval = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ReadFile failed (ec: %ld)"),
            Rval);
        goto exit;
    }

    Assert (ERROR_SUCCESS == Rval);

exit:
    return Rval;
}   // FAX_ReadFile

error_status_t
FAX_EndCopy (
    IN OUT PRPC_FAX_MSG_ENUM_HANDLE lphCopy
)
/*++

Routine name : FAX_EndCopy

Routine description:

    Ends a copy process (from / to server)

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lphCopy         [in] - Copy context handle

Return Value:

    Standard RPC error code

--*/
{
    error_status_t Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EndCopy"));

    __try
    {
        CloseFaxHandle( (PHANDLE_ENTRY) *lphCopy );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // for some reason we crashed, so return the exception code
        //
        Rval = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CloseFaxHandle on handle 0x%08x caused exception %ld"),
            *lphCopy,
            Rval);
        ASSERT_FALSE
    }
    if (ERROR_SUCCESS == Rval)
    {
        //
        // NULLify the handle so the rundown will not occur
        //
        *lphCopy = NULL;
    }
    return Rval;
} // FAX_EndCopy


VOID
RPC_FAX_COPY_HANDLE_rundown(
    IN HANDLE FaxCopyHandle
    )
/*++

Routine name : RPC_FAX_COPY_HANDLE_rundown

Routine description:

    The RPC rundown function of the copy handle.
    This function is called if the client abruptly disconnected on us.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    FaxCopyHandle            [in] - Message copy handle.

Return Value:

    None.

--*/
{
    PHANDLE_ENTRY pHandleEntry = (PHANDLE_ENTRY) FaxCopyHandle;
    DEBUG_FUNCTION_NAME(TEXT("RPC_FAX_COPY_HANDLE_rundown"));

    DebugPrintEx(DEBUG_MSG,
         TEXT("RPC_FAX_COPY_HANDLE_rundown: handle = 0x%08x"),
         FaxCopyHandle);
    __try
    {
        if (NULL == pHandleEntry)
        {
            return;

        }
        pHandleEntry->bError = TRUE;
        CloseFaxHandle( pHandleEntry );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("RPC_FAX_COPY_HANDLE_rundown() crashed, ec=0x%08x"),
                      GetExceptionCode());
    }
}   // RPC_FAX_COPY_HANDLE_rundown



error_status_t
FAX_StartServerNotification(
   IN handle_t                      hBinding,
   IN LPCTSTR                       lpcwstrMachineName,
   IN LPCTSTR                       lpcwstrEndPoint,
   IN ULONG64                       Context,
   IN LPWSTR                        lpcwstrProtseqString,
   IN BOOL                          bEventEx,
   IN DWORD                         dwEventTypes,
   OUT PRPC_FAX_EVENT_HANDLE        lpHandle
   )
{
    error_status_t   Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_StartServerNotification"));
    PFAX_CLIENT_DATA pClientData = NULL;
    BOOL bClientAdded = FALSE;

    Assert (lpcwstrEndPoint && lpcwstrMachineName && lpcwstrProtseqString && lpHandle);

	if (wcslen(lpcwstrMachineName) > MAX_COMPUTERNAME_LENGTH ||
		wcslen(lpcwstrEndPoint) >= MAX_ENDPOINT_LEN)
	{
		DebugPrintEx(DEBUG_ERR,
			TEXT("Machine name or endpoint too long. Machine name: %s, Endpoint: %s."),
			lpcwstrMachineName,
			lpcwstrEndPoint);
		return ERROR_BAD_FORMAT;
	}

    //
    // Allocate FAX_CLIENT_DATA to insert to the list of all clients registered for notifications.
    //
    pClientData = (PFAX_CLIENT_DATA) MemAlloc( sizeof(FAX_CLIENT_DATA) );
    if (!pClientData)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't allocate FAX_CLIENT_DATA"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //Get the user SID
    //
    pClientData->UserSid = GetClientUserSID();
    if (NULL == pClientData->UserSid)
    {
       Rval = GetLastError();
       DebugPrintEx(DEBUG_ERR,
                    TEXT("GetClientUserSid Failed, Error : %ld"),
                    Rval);
       MemFree (pClientData);
       return Rval;
    }

    pClientData->hBinding        = hBinding;
    pClientData->bEventEx        = bEventEx;
    pClientData->EventTypes      = dwEventTypes;
    pClientData->StartedMsg      = FALSE;
    pClientData->FaxHandle       = NULL;	
    lstrcpy (pClientData->wstrMachineName, lpcwstrMachineName);
    lstrcpy (pClientData->wstrEndPoint, lpcwstrEndPoint);

    __try
    {
        EnterCriticalSection( &g_CsClients );
        //
        // Create binding to the client RPC server.
        //
        Rval = RpcBindToFaxClient (lpcwstrMachineName,
                                   lpcwstrEndPoint,
                                   L"Security=identification static true",
                                   lpcwstrProtseqString,
                                   &pClientData->FaxHandle);
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcBindToFaxClient faild (ec = %ld)"),
                Rval);
            goto exit;
        }
        //
        // Insert the new client to the clients list
        //
        InsertTailList( &g_ClientsListHead, &pClientData->ListEntry );
        bClientAdded = TRUE;

        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Client added to notification list : MacineName = %s, EndPoint = %s"),
            lpcwstrMachineName,
            lpcwstrEndPoint);

        //
        // Get a context handle from the client
        //
        pClientData->FaxClientHandle = NULL;
        Rval = FAX_OpenConnection( pClientData->FaxHandle, Context, &pClientData->FaxClientHandle );
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("FAX_OpenConnection() failed, ec=0x%08x"), Rval );
            goto exit;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Rval = GetExceptionCode();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("FAX_StartServerNotification crashed (exception = %ld)"),
                Rval);
        goto exit;
    }

    //
    // Return a context handle to the client
    //
    *lpHandle = (HANDLE) pClientData;

    if (!CreateFaxEvent( 0, FEI_FAXSVC_STARTED, 0xffffffff ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateFaxEvent failed. (ec: %ld)"),
            GetLastError());
    }

    Assert (ERROR_SUCCESS == Rval);

exit:
    if (ERROR_SUCCESS != Rval)
    {
        DWORD dwRes;

        if (NULL != pClientData->FaxClientHandle)
        {
            //
            // Close opened connection
            //
            __try
            {
                dwRes = FAX_CloseConnection( &pClientData->FaxClientHandle );
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(DEBUG_ERR,TEXT("FAX_CloseConnection() failed, ec=0x%08x"), dwRes );
                }

                if (NULL != pClientData->FaxHandle)
                {
                    // free binding handle
                    dwRes = RpcBindingFree((RPC_BINDING_HANDLE *)&pClientData->FaxHandle);
                    if (RPC_S_OK != dwRes)
                    {
                        DebugPrintEx(DEBUG_ERR,TEXT("RpcBindingFree() failed, ec=0x%08x"), dwRes );
                    }
                }

            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                dwRes = GetExceptionCode();
                DebugPrintEx(DEBUG_ERR,TEXT("FAX_CloseConnection() crashed: 0x%08x"), dwRes );
            }
        }

        if (TRUE == bClientAdded)
        {
            RemoveEntryList(&pClientData->ListEntry)
        }

        MemFree (pClientData->UserSid);
        MemFree (pClientData);
    }
    LeaveCriticalSection( &g_CsClients );
    return Rval;
}


VOID
RPC_FAX_EVENT_HANDLE_rundown(
    IN HANDLE hFaxEventHandle
    )
{
    DEBUG_FUNCTION_NAME(TEXT("RPC_FAX_EVENT_HANDLE_rundown"));

    PFAX_CLIENT_DATA pClientData = PFAX_CLIENT_DATA(hFaxEventHandle);
    if (NULL == pClientData)
    {
        return;
    }

    EnterCriticalSection( &g_CsClients );
    __try
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RPC_FAX_EVENT_HANDLE_rundown() running for event handle 0x%08x"),
            hFaxEventHandle);

        //
        // Remove relevant connections from notification list
        //

        RemoveEntryList( &pClientData->ListEntry );
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Client removed from notification list : MacineName = %s, EndPoint = %s"),
            pClientData->wstrMachineName,
            pClientData->wstrEndPoint);

        MemFree (pClientData->UserSid);
        MemFree (pClientData);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RPC_FAX_EVENT_HANDLE_rundown() crashed, ec=0x%08x"),
            GetExceptionCode());
    }
    LeaveCriticalSection( &g_CsClients );
    return;
}



DWORD
RemoveClientFromClientsMap (
    IN CClientID* pClientID,
    IN BOOL bCloseConnection
    )
{
    DEBUG_FUNCTION_NAME(TEXT("RemoveClientFromClientsMap"));
    DWORD Rval = ERROR_SUCCESS;
    CClient* pClient = NULL;
    try
    {
        if (TRUE == bCloseConnection)
        {
            pClient = g_pClientsMap->FindClient (*pClientID);
            if (NULL == pClient)
            {
                Rval = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CClientsMap::FindClient failed with ec = %ld"),
                    Rval);
                goto exit;
            }

            Rval = pClient->CloseConnection();
            if (ERROR_SUCCESS != Rval)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CClientsMap::CloseConnection failed with ec = %ld"),
                    Rval);
                goto exit;
            }
        }

        Rval = g_pClientsMap->DelClient(*pClientID);
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CClientsMap::DelClient failed with ec = %ld"),
            Rval);
            goto exit;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or CClient caused exception (%S)"),
            ex.what());
        Rval = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == Rval);

exit:
    return Rval;
} // RemoveClientFromClientsMap


error_status_t
FAX_StartServerNotificationEx(
   IN handle_t                          hBinding,
   IN LPCTSTR                           lpcwstrMachineName,
   IN LPCTSTR                           lpcwstrEndPoint,
   IN ULONG64                           Context,
   IN LPWSTR                            lpcwstrProtseqString,
   IN BOOL                              bEventEx,
   IN DWORD                             dwEventTypes,
   OUT PRPC_FAX_EVENT_EX_HANDLE         lpHandle
   )
{
    error_status_t   Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_StartServerNotificationEx"));
    PSID pUserSid = NULL;
    HANDLE hFaxClientContext = NULL; // Client context handle
    handle_t hFaxHandle = NULL; // binding handle
    CClientID* pContextClientID = NULL;
    CClientID* pOpenConnClientID = NULL;
    BOOL bClientAdded = FALSE;
    BOOL bAllQueueMessages = FALSE;
    BOOL bAllOutArchiveMessages = FALSE;
    BOOL fAccess;
    DWORD dwRights;
    Assert (lpcwstrEndPoint && lpcwstrMachineName && lpcwstrProtseqString && lpHandle);
	
    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    if (dwEventTypes & FAX_EVENT_TYPE_NEW_CALL)
    {
        if (FAX_ACCESS_QUERY_IN_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights - FAX_ACCESS_QUERY_IN_ARCHIVE"));
            return ERROR_ACCESS_DENIED;
        }
    }

    if ( (dwEventTypes & FAX_EVENT_TYPE_IN_QUEUE) ||
         (dwEventTypes & FAX_EVENT_TYPE_OUT_QUEUE) )
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_JOBS != (dwRights & FAX_ACCESS_QUERY_JOBS))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to get events of jobs in queue"));
            return ERROR_ACCESS_DENIED;
        }
    }

    if ( (dwEventTypes & FAX_EVENT_TYPE_CONFIG)        ||
         (dwEventTypes & FAX_EVENT_TYPE_DEVICE_STATUS) ||
         (dwEventTypes & FAX_EVENT_TYPE_ACTIVITY) )
    {
        if (FAX_ACCESS_QUERY_CONFIG != (dwRights & FAX_ACCESS_QUERY_CONFIG))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to get events configuration and activity"));
            return ERROR_ACCESS_DENIED;
        }
    }

    if ( dwEventTypes & FAX_EVENT_TYPE_IN_ARCHIVE )
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_IN_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to get events of jobs in Inbox"));
            return ERROR_ACCESS_DENIED;
        }
    }

    if ( dwEventTypes & FAX_EVENT_TYPE_OUT_ARCHIVE )
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_OUT_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to get events of jobs in Sent items"));
            return ERROR_ACCESS_DENIED;
        }
    }

    //
    // Set bAllQueueMessages to the right value
    //
    if (FAX_ACCESS_QUERY_JOBS == (dwRights & FAX_ACCESS_QUERY_JOBS))
    {
        bAllQueueMessages = TRUE;
    }

    //
    // Set bAllOutArchiveMessages to the right value
    //
    if (FAX_ACCESS_QUERY_OUT_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
    {
        bAllOutArchiveMessages = TRUE;
    }

	if (wcslen(lpcwstrMachineName) > MAX_COMPUTERNAME_LENGTH ||
		wcslen(lpcwstrEndPoint) >= MAX_ENDPOINT_LEN)
	{
		DebugPrintEx(DEBUG_ERR,
			TEXT("Machine name or endpoint too long. Machine name: %s, Endpoint: %s."),
			lpcwstrMachineName,
			lpcwstrEndPoint);
		return ERROR_BAD_FORMAT;
	}

    //
    //Get the user SID
    //
    pUserSid = GetClientUserSID();
    if (NULL == pUserSid)
    {
       Rval = GetLastError();
       DebugPrintEx(DEBUG_ERR,
                    TEXT("GetClientUserSid Failed, Error : %ld"),
                    Rval);
       return GetServerErrorCode(Rval);
    }

    EnterCriticalSection( &g_CsClients );
    //
    // Create binding to the client RPC server.
    //
    Rval = RpcBindToFaxClient (lpcwstrMachineName,
                               lpcwstrEndPoint,
                               L"Security=identification static true",
                               lpcwstrProtseqString,
                               &hFaxHandle);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcBindToFaxClient faild (ec = %ld)"),
            Rval);
        goto exit;
    }
    //
    // Create 2 new client IDs objects
    //
    pContextClientID = new CClientID( g_dwlClientID, lpcwstrMachineName, lpcwstrEndPoint, Context);
    if (NULL == pContextClientID)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocatin CClientID object"));
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    pOpenConnClientID = new CClientID( g_dwlClientID, lpcwstrMachineName, lpcwstrEndPoint, Context);
    if (NULL == pOpenConnClientID)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocatin CClientID object"));
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    try
    {
        CClient Client(*pContextClientID,
                       pUserSid,
                       dwEventTypes,
                       hFaxHandle,
                       bAllQueueMessages,
                       bAllOutArchiveMessages,
                       FindClientAPIVersion(hBinding));

        //
        // Add a new client object to the clients map
        //
        Rval = g_pClientsMap->AddClient(Client);
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CClientsMap::AddClient failed with ec = %ld"),
                Rval);
            goto exit;
        }
        bClientAdded = TRUE;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or CClient caused exception (%S)"),
            ex.what());
        Rval = ERROR_GEN_FAILURE;
        goto exit;
    }

    //
    // Post the CLIENT_OPEN_CONN_COMPLETION_KEY event to the FaxEvent completion port
    //
    if (!PostQueuedCompletionStatus( g_hEventsCompPort,
                                     sizeof(CClientID*),
                                     CLIENT_OPEN_CONN_COMPLETION_KEY,
                                     (LPOVERLAPPED) pOpenConnClientID))
    {
        Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PostQueuedCompletionStatus failed. (ec: %ld)"),
            Rval);
        goto exit;
    }
    pOpenConnClientID = NULL; // FaxEventThread will free pOpenConnClientID

    //
    // Return a context handle to the client
    //
    *lpHandle = (HANDLE) pContextClientID;

    Assert (ERROR_SUCCESS == Rval);

exit:
    if (ERROR_SUCCESS != Rval)
    {
        DWORD dwRes;

        if (TRUE == bClientAdded)
        {
            //
            // Remove client from map, close connection if opened
            //
            dwRes = RemoveClientFromClientsMap (pContextClientID, FALSE);  // Do not call CloseConnection()
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("RemoveClientFromClientsMap, ec=0x%08x"),
                    dwRes );
            }
        }

        if (NULL != hFaxHandle)
        {
            // free binding handle
            dwRes = RpcBindingFree((RPC_BINDING_HANDLE *)&hFaxHandle);
            if (RPC_S_OK != dwRes)
            {
                DebugPrintEx(DEBUG_ERR,TEXT("RpcBindingFree() failed, ec=0x%08x"), dwRes );
            }
        }

        if (pContextClientID != NULL)
        {
            delete pContextClientID;
            pContextClientID = NULL;
        }

        if (pOpenConnClientID != NULL)
        {
            delete pOpenConnClientID;
            pOpenConnClientID = NULL;
        }
    }
    else
    {
        g_dwlClientID++;
    }
    LeaveCriticalSection( &g_CsClients );
    MemFree (pUserSid);
    pUserSid = NULL;
    return GetServerErrorCode(Rval);
}     // FAX_StartServerNotificationEx


VOID
RPC_FAX_EVENT_EX_HANDLE_rundown(
    IN HANDLE hFaxEventHandle
    )
{
    DEBUG_FUNCTION_NAME(TEXT("RPC_FAX_EVENT_EX_HANDLE_rundown"));

    CClientID* pClientID = (CClientID*)(hFaxEventHandle);
    if (NULL == pClientID)
    {
        return;
    }

    EnterCriticalSection( &g_CsClients );
    __try
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RPC_FAX_EVENT_EX_HANDLE_rundown() running for event handle 0x%08x"),
            hFaxEventHandle);
        //
        // Remove relevant connections from notification list
        //
        DWORD Rval = RemoveClientFromClientsMap (pClientID, FALSE); // FALSE - do not close connection (rundown)
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RemoveClientFromClientsMap() failed, ec=%ld"),
            Rval);
        }
        delete pClientID;
        pClientID = NULL;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RPC_FAX_EVENT_EX_HANDLE_rundown() crashed, ec=0x%08x"),
            GetExceptionCode());
    }
    LeaveCriticalSection( &g_CsClients );
    return;
}


error_status_t
FAX_EndServerNotification (
    IN OUT LPHANDLE  lpHandle
)
/*++

Routine name : FAX_EndServerNotification

Routine description:

    A fax client application calls the FAX_EndServerNotification function to stop
    recieving server notifications.

Author:

    Oded Sacher (OdedS), Dec, 1999

Arguments:

    lpHandle    [in] - The notification handle value.
                       This value is obtained by calling FAX_StartServerNotificationEx.

Return Value:

    Standard RPC error code

--*/
{
    error_status_t Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EndServerNotification"));
    CClientID* pClientID = (CClientID*)(*lpHandle);

	if (NULL == pClientID)
	{
		//
		// Empty context handle
		//
		//				
		DebugPrintEx(DEBUG_ERR,
                     _T("Empty context handle"));
        return ERROR_INVALID_PARAMETER;
	}


    EnterCriticalSection( &g_CsClients );

    __try
    {
        Rval = RemoveClientFromClientsMap (pClientID, TRUE); // TRUE - close connection
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RemoveClientFromClientsMap() failed, ec=%ld"),
            Rval);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Rval = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FAX_EndServerNotification() crashed, ec=0x%08x"),
            Rval);
    }

    if (ERROR_SUCCESS == Rval)
    {
        delete pClientID;
        pClientID = NULL;
        //
        // NULLify the handle so the rundown will not occur
        //
        *lpHandle = NULL;
    }

    LeaveCriticalSection( &g_CsClients );
    return GetServerErrorCode(Rval);
}   // FAX_EndServerNotificationEx

//********************************************
//*             Server activity
//********************************************

error_status_t
FAX_GetServerActivity(
    IN handle_t                     hFaxHandle,
    IN OUT PFAX_SERVER_ACTIVITY     pServerActivity
)
/*++

Routine name : FAX_GetServerActivity

Routine description:

    Retrieves the status of the fax server queue activity and event log reports.

Author:

    Oded Sacher (OdedS), Feb, 2000

Arguments:

    hFaxHandle          [in ] - Unused
    pServerActivity     [out] - Returned server activity structure

Return Value:

    Standard RPC error codes

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetServerActivity"));
    DWORD dwRes = ERROR_SUCCESS;
    BOOL fAccess;

    Assert (pServerActivity);

    if (sizeof (FAX_SERVER_ACTIVITY) != pServerActivity->dwSizeOfStruct)
    {
       //
       // Size mismatch
       //
       DebugPrintEx(DEBUG_ERR,
                   TEXT("Invalid size of struct"));
       return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
       DebugPrintEx(DEBUG_ERR,
                   TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                   dwRes);
       return dwRes;
    }

    if (FALSE == fAccess)
    {
       DebugPrintEx(DEBUG_ERR,
                   TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
       return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsActivity);
    CopyMemory (pServerActivity, &g_ServerActivity, sizeof(FAX_SERVER_ACTIVITY));
    LeaveCriticalSection (&g_CsActivity);

    GetEventsCounters( &pServerActivity->dwWarningEvents,
                       &pServerActivity->dwErrorEvents,
                       &pServerActivity->dwInformationEvents);


    return dwRes;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetServerActivity



error_status_t
FAX_SetConfigWizardUsed (
    IN  handle_t hFaxHandle,
    OUT BOOL     bConfigWizardUsed
)
/*++

Routine name : FAX_SetConfigWizardUsed

Routine description:

    Sets if the configuration wizard was used

    Requires no access rights.

Author:

    Eran Yariv (EranY), July 2000

Arguments:

    hFaxHandle           [in ] - Unused
    bConfigWizardUsed    [in]  - Was the wizard used?

Return Value:

    Standard RPC error codes

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetConfigWizardUsed"));
    HKEY hKey;
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwRes2;

    dwRes = RegOpenKey (HKEY_LOCAL_MACHINE, REGKEY_FAXSERVER, &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error opening server key (ec = %ld)"),
            dwRes);
        return dwRes;
    }
    if (!SetRegistryDword (hKey,
                           REGVAL_CFGWZRD_DEVICE,
                           (DWORD)bConfigWizardUsed))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing REGVAL_CFGWZRD_DEVICE (ec = %ld)"),
            dwRes);
        goto exit;
    }

exit:

    dwRes2 = RegCloseKey (hKey);
    if (ERROR_SUCCESS != dwRes2)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error closing server key (ec = %ld)"),
            dwRes2);
    }
    return dwRes;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetConfigWizardUsed


//********************************************
//*            Routing extensions
//********************************************

error_status_t
FAX_EnumRoutingExtensions (
    IN  handle_t   hFaxHandle,
    OUT LPBYTE    *pBuffer,
    OUT LPDWORD    pdwBufferSize,
    OUT LPDWORD    lpdwNumExts
)
/*++

Routine name : FAX_EnumRoutingExtensions

Routine description:

    Enumerates the routing extensions

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pBuffer             [out] - Pointer to buffer to hold routing extensions array
    pdwBufferSize       [out] - Pointer to buffer size
    lpdwNumExts         [out] - Size of FSPs array

Return Value:

    Standard RPC error codes

--*/
{
    extern LIST_ENTRY           g_lstRoutingExtensions;  // Global list of routing extensions
    PLIST_ENTRY                 Next;
    DWORD_PTR                   dwOffset;
    PFAX_ROUTING_EXTENSION_INFO pExts;
    DWORD                       dwIndex;
    DWORD                       dwRes = ERROR_SUCCESS;
    BOOL                        fAccess;

    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumRoutingExtensions"));

    Assert (pdwBufferSize && lpdwNumExts);    // ref pointer in idl
    if (!pBuffer)                              // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // First run - traverse list and count size required + list size
    //
    *lpdwNumExts = 0;
    *pdwBufferSize = 0;
    Next = g_lstRoutingExtensions.Flink;
    if (NULL == Next)
    {
        //
        // The list is corrupted
        //
        ASSERT_FALSE;
        //
        // We'll crash and we deserve it....
        //
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_lstRoutingExtensions)
    {
        PROUTING_EXTENSION    pExt;

        (*lpdwNumExts)++;
        (*pdwBufferSize) += sizeof (FAX_ROUTING_EXTENSION_INFO);
        //
        // Get current extension
        //
        pExt = CONTAINING_RECORD( Next, ROUTING_EXTENSION, ListEntry );
        //
        // Advance pointer
        //
        Next = pExt->ListEntry.Flink;
        (*pdwBufferSize) += StringSize (pExt->FriendlyName);
        (*pdwBufferSize) += StringSize (pExt->ImageName);
        (*pdwBufferSize) += StringSize (pExt->InternalName);
    }
    //
    // Allocate required size
    //
    *pBuffer = (LPBYTE)MemAlloc( *pdwBufferSize );
    if (NULL == *pBuffer)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    //
    // Second pass, fill in the array
    //
    pExts = (PFAX_ROUTING_EXTENSION_INFO)(*pBuffer);
    dwOffset = (*lpdwNumExts) * sizeof (FAX_ROUTING_EXTENSION_INFO);
    Next = g_lstRoutingExtensions.Flink;
    dwIndex = 0;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_lstRoutingExtensions)
    {
        PROUTING_EXTENSION    pExt;
        //
        // Get current extension
        //
        pExt = CONTAINING_RECORD( Next, ROUTING_EXTENSION, ListEntry );
        //
        // Advance pointer
        //
        Next = pExt->ListEntry.Flink;
        pExts[dwIndex].dwSizeOfStruct = sizeof (FAX_ROUTING_EXTENSION_INFO);
        StoreString(
            pExt->FriendlyName,
            (PULONG_PTR)&(pExts[dwIndex].lpctstrFriendlyName),
            *pBuffer,
            &dwOffset
            );
        StoreString(
            pExt->ImageName,
            (PULONG_PTR)&(pExts[dwIndex].lpctstrImageName),
            *pBuffer,
            &dwOffset
            );
        StoreString(
            pExt->InternalName,
            (PULONG_PTR)&(pExts[dwIndex].lpctstrExtensionName),
            *pBuffer,
            &dwOffset
            );
        pExts[dwIndex].Version = pExt->Version;
        pExts[dwIndex].Status = pExt->Status;
        pExts[dwIndex].dwLastError = pExt->dwLastError;
        dwIndex++;
    }
    Assert (dwIndex == *lpdwNumExts);
    return ERROR_SUCCESS;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_EnumRoutingExtensions



DWORD
LineInfoToLegacyDeviceStatus(
    const LINE_INFO *lpcLineInfo
    )
{

    DWORD dwState = 0;
    Assert(lpcLineInfo);

    //
    // Return the line state according to the following backward compatability policy:
    //
    //      For devices that do not support FSPI_CAP_MULTISEND we report the same
    //      status code as in W2K by translating the FSPI_JOB_STATUS kept in the job entry
    //      to the correspondign FPS_code (or just passing the proprietry FSP code).
    //
    //      For devices that support FSPI_CAP_MULTISEND filter the state bits
    //      and return only the following states:
    //      FPS_OFFLINE
    //      FPS_AVAILABLE
    //      FPS_UNAVILABLE
    //      0   - ( if the line is already allocated for the future job but a job is not yet assosiated with the line )
    //

        if (lpcLineInfo->JobEntry )
        {
            //
            // We are either dealing with a legacy FSP or a new EFSP that does not support
            // multisend.
            //
            if (FSPI_API_VERSION_1 == lpcLineInfo->Provider->dwAPIVersion)
            {
                //
                // This is a legacy FSP. For legacy FSP we keep the reported status in LineInfo::State

                //
                dwState = lpcLineInfo->State;
            }
            else
            {
                //
                // Non multisend EFSP. Need to translate the status to legacy status
                //
                dwState = FSPIStatusCodeToFaxDeviceStatusCode(&lpcLineInfo->JobEntry->FSPIJobStatus);
            }
        }
        else
        {
            //
            // This is either a multisend EFSP or a legacy FSP device that does not execute
            // anything.
            // In this case the device state is to be found in LineInfo->State but it is limited to
            // FPS_OFFLINE or FPS_AVAILABLE or FPS_UNAVILABLE or 0
            //
            // LineInfo->State could be 0 if - the line is already allocated for the future job but
            // a job is not yet assosiated with the line
            //
            Assert( (FPS_OFFLINE == lpcLineInfo->State) ||
                    (FPS_AVAILABLE == lpcLineInfo->State) ||
                    (FPS_UNAVAILABLE == lpcLineInfo->State) ||
                    (0 == lpcLineInfo->State) );

            dwState      = lpcLineInfo->State;
        }


        return dwState;
}

//********************************************
//*            Manual answering support
//********************************************

error_status_t
FAX_AnswerCall(
        IN  handle_t    hFaxHandle,
        IN  CONST DWORD dwDeviceId
)
/*++

Routine name : FAX_AnswerCall

Routine description:

    A fax client application calls the FAX_AnswerCall to cause server to answer
    the specified call

Arguments:
    hFaxHandle  - unused
    dwDeviceId  - TAPI Permanent line ID (for identification)

Return Value:

    Standard RPC error code

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    LPLINEMESSAGE lpLineMessage;
    BOOL    fAccess;
    LINE_INFO *pLineInfo;
    DEBUG_FUNCTION_NAME(TEXT("FAX_AnswerCall"));
    UNREFERENCED_PARAMETER (hFaxHandle);

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_QUERY_IN_ARCHIVE, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        rVal = ERROR_ACCESS_DENIED;
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_IN_ARCHIVE"));
        return rVal;
    }
    //
    // Validate the line exists and can answer calls
    //
    EnterCriticalSection( &g_CsLine );
    //
    // Get LineInfo from permanent device ID
    //
    pLineInfo = GetTapiLineFromDeviceId(dwDeviceId, FALSE);
    if(!pLineInfo)
    {
        rVal = ERROR_INVALID_PARAMETER;
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Device %ld not found"),
                     dwDeviceId);
        goto Error;
    }
    //
    // See if the device is still available
    //
    if(pLineInfo->State != FPS_AVAILABLE)
    {
        rVal = ERROR_BUSY;
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Line is not available (LineState is 0x%08x)."),
                     pLineInfo->State);
        goto Error;
    }
    //
    // Allocate and compose a LINEMESSAGE structure that'll be
    // used to notify the server about the new inbound message.
    //
    lpLineMessage = (LPLINEMESSAGE)LocalAlloc(LPTR, sizeof(LINEMESSAGE));
    if (lpLineMessage == NULL)
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate LINEMESSAGE structure"));
        goto Error;
    }
    lpLineMessage->dwParam1 = dwDeviceId;
    //
    // Notify the server.
    //
    if (!PostQueuedCompletionStatus(
            g_TapiCompletionPort,
            sizeof(LINEMESSAGE),
            ANSWERNOW_EVENT_KEY,
            (LPOVERLAPPED)lpLineMessage))
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PostQueuedCompletionStatus failed - %d"),
            GetLastError());
        LocalFree(lpLineMessage);
        goto Error;
    }

Error:
    LeaveCriticalSection( &g_CsLine );
    return rVal;
}   // FAX_AnswerCall


//********************************************
//*   Ivalidate archive folder
//********************************************

error_status_t
FAX_RefreshArchive(
    IN  handle_t                 hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder
)
/*++

Routine name : FAX_RefreshArchive

Routine description:

    A fax client application calls the FAX_RefreshArchive to notify server
    that archive folder has been changed and should be refreshed

Arguments:
    hFaxHandle      - unused
    Folder          - Archive folder name

Return Value:

    Standard RPC error code

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    BOOL    fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_RefreshArchive"));
    UNREFERENCED_PARAMETER (hFaxHandle);

    if(Folder != FAX_MESSAGE_FOLDER_INBOX &&
       Folder != FAX_MESSAGE_FOLDER_SENTITEMS)
    {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Access check
    //
    rVal = FaxSvcAccessCheck ((Folder == FAX_MESSAGE_FOLDER_INBOX) ? FAX_ACCESS_MANAGE_IN_ARCHIVE :
                               FAX_ACCESS_MANAGE_OUT_ARCHIVE,
                               &fAccess,
                               NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        rVal = ERROR_ACCESS_DENIED;
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_IN_ARCHIVE"));
        return rVal;
    }


    //
    // Refresh archive size
    //
    EnterCriticalSection (&g_CsConfig);
    g_ArchivesConfig[Folder].dwlArchiveSize = FAX_ARCHIVE_FOLDER_INVALID_SIZE;
    LeaveCriticalSection (&g_CsConfig);

    //
    // Wake up quota warning thread
    //
    if (!SetEvent (g_hArchiveQuotaWarningEvent))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to set quota warning event, SetEvent failed (ec: %lc)"),
            GetLastError());
    }

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\jobmap.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    jobmap.c

Abstract:


Author:

    Boaz Feldbaum (BoazF) 25-May-1999


Revision History:

--*/

#include "faxsvc.h"
#include <map>
using namespace std;
#pragma hdrstop

typedef map<ULONG_PTR, const JOB_ENTRY *> JOB_MAP, *PJOB_MAP;
class MT_JOB_MAP
{
public:
    MT_JOB_MAP();
    ~MT_JOB_MAP();

public:
    CRITICAL_SECTION CS;
    PJOB_MAP pJobMap;
};

typedef MT_JOB_MAP *PMT_JOB_MAP;

MT_JOB_MAP::MT_JOB_MAP()
{
    pJobMap = new JOB_MAP;
    if (!pJobMap)
    {
        return;
    }

    if (!InitializeCriticalSectionAndSpinCount (&CS, (DWORD)0x10000000))
    {
        delete pJobMap;
        pJobMap = NULL;
    }
};

MT_JOB_MAP::~MT_JOB_MAP()
{
    if (pJobMap)
    {
        DeleteCriticalSection(&CS);
        delete pJobMap;
    }
}

DWORD
FspJobToJobEntry(
    HANDLE hJobMap,
    HANDLE hFspJob,
    PJOB_ENTRY *ppJobEntry)
{
    DWORD ec = ERROR_SUCCESS;
    PMT_JOB_MAP pMtJobMap = (PMT_JOB_MAP)hJobMap;
    BOOL fShouldLeaveCS = FALSE;

    try
    {
        EnterCriticalSection(&pMtJobMap->CS);
        fShouldLeaveCS = TRUE;
        *ppJobEntry = const_cast<PJOB_ENTRY>((*pMtJobMap->pJobMap)[(ULONG_PTR)hFspJob]);
    }
    catch(...)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (fShouldLeaveCS)
    {
        LeaveCriticalSection(&pMtJobMap->CS);
    }

    return(ec);
}

DWORD
AddFspJob(
    HANDLE hJobMap,
    HANDLE hFspJob,
    const JOB_ENTRY *pJobEntry)
{
    DWORD ec = ERROR_SUCCESS;
    PMT_JOB_MAP pMtJobMap = (PMT_JOB_MAP)hJobMap;
    BOOL fShouldLeaveCS = FALSE;

    Assert(hJobMap);
    Assert(hFspJob);

    try
    {
        EnterCriticalSection(&pMtJobMap->CS);
        fShouldLeaveCS = TRUE;
        (*(pMtJobMap->pJobMap))[(ULONG_PTR)hFspJob] = pJobEntry;
    }
    catch(...)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (fShouldLeaveCS)
    {
        LeaveCriticalSection(&pMtJobMap->CS);
    }

    return(ec);
}

DWORD
RemoveFspJob(
    HANDLE hJobMap,
    HANDLE hFspJob)
{
    DWORD ec = ERROR_SUCCESS;
    PMT_JOB_MAP pMtJobMap = (PMT_JOB_MAP)hJobMap;
    BOOL fShouldLeaveCS = FALSE;

    try
    {
        EnterCriticalSection(&pMtJobMap->CS);
        fShouldLeaveCS = TRUE;
        pMtJobMap->pJobMap->erase((ULONG_PTR)hFspJob);
    }
    catch(...)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (fShouldLeaveCS)
    {
        LeaveCriticalSection(&pMtJobMap->CS);
    }

    return(ec);
}

DWORD
CreateJobMap(
    PHANDLE phJobMap)
{
    PMT_JOB_MAP pMtJobMap = new MT_JOB_MAP;

    if (pMtJobMap == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (!pMtJobMap->pJobMap)
    {
        delete pMtJobMap;
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *phJobMap = (HANDLE)pMtJobMap;

    return(ERROR_SUCCESS);
}

DWORD
DestroyJobMap(
    HANDLE hJobMap)
{
    delete (PMT_JOB_MAP)hJobMap;

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\job.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    job.c

Abstract:

    This module implements the job creation and deletion.
    Also included in the file are the queue management
    functions and thread management.

Author:

    Wesley Witt (wesw) 24-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#include "faxreg.h"
#pragma hdrstop
#include <set>
#include <efsputil.h>
using namespace std;

// Globals
LIST_ENTRY          g_JobListHead; //List of currently running jobs (for which FaxDevStartJob was called).
CFaxCriticalSection    g_CsJob;
HANDLE              g_StatusCompletionPortHandle;
DWORD               g_dwFaxSendRetries;
DWORD               g_dwFaxSendRetryDelay;
DWORD               g_dwFaxDirtyDays;
BOOL                g_fFaxUseDeviceTsid;
BOOL                g_fFaxUseBranding;
BOOL                g_fServerCp;
FAX_TIME            g_StartCheapTime;
FAX_TIME            g_StopCheapTime;
DWORD               g_dwNextJobId;
LIST_ENTRY          g_EFSPJobGroupsHead;    // The list of running EFSP job groups.
CFaxCriticalSection  g_csEFSPJobGroups;      // The critical section protecting the EFSP job groups list.

#define JOB_GROUP_FILE_EXTENSION TEXT("FSP")

static LPEFSP_JOB_GROUP EFSPJobGroup_Create( const LINE_INFO * lpLineInfo);
static BOOL EFSPJobGroup_Free(LPEFSP_JOB_GROUP lpGroup, BOOL bDestroy);
static BOOL EFSPJobGroup_SetParentId(LPEFSP_JOB_GROUP lpGroup, LPCFSPI_MESSAGE_ID lpcMessageId);
static BOOL EFSPJobGroup_AddRecipient(LPEFSP_JOB_GROUP lpGroup, PJOB_QUEUE  lpRecipient, BOOL bCommit);
static BOOL EFSPJobGroup_RemoveRecipient(LPEFSP_JOB_GROUP lpGroup, PJOB_QUEUE lpRecipient, BOOL bCommit);
static BOOL EFSPJobGroup_RemoveAllRecipients(LPEFSP_JOB_GROUP lpGroup, BOOL bCommit);
static BOOL EFSPJobGroup_DeleteFile(LPCEFSP_JOB_GROUP lpcGroup);
static BOOL EFSPJobGroup_Save(LPEFSP_JOB_GROUP lpGroup);
static LPEFSP_JOB_GROUP EFSPJobGroup_Load(LPCTSTR lpctstrFileName);
static LPEFSP_JOB_GROUP EFSPJobGroup_Unserialize(LPBYTE lpBuffer, DWORD dwBufferSize);
static BOOL EFSPJobGroup_Validate(LPEFSP_JOB_GROUP lpGroup);
static BOOL EFSPJobGroup_IsPersistent(LPCEFSP_JOB_GROUP lpcGroup);
static BOOL EFSPJobGroup_HandleReestablishFailure(LPEFSP_JOB_GROUP lpGroup);
static BOOL EFSPJobGroup_ExecutionFailureCleanup(LPEFSP_JOB_GROUP lpGroup);
static LPFSPI_MESSAGE_ID EFSPJobGroup_CreateMessageIdsArray(LPCEFSP_JOB_GROUP lpcGroup);
static LPEFSP_JOB_GROUP EFSPJobGroup_Load(LPCTSTR lpctstrFileName);
static BOOL ValidateEFSPJobHandles(const HANDLE * lpchJobs, DWORD dwJobCount);
static BOOL ValidateEFSPPermanentMessageIds(LPCFSPI_MESSAGE_ID lpcMessageIds, DWORD dwMsgIdCount, DWORD dwMaxIdSize);
static BOOL LoadEFSPJobGroups();
static BOOL SendJobReceipt (BOOL bPositive, JOB_QUEUE * lpJobQueue, LPCTSTR lpctstrAttachment);

#if DBG
#define EFSPJobGroup_DbgDump(x) EFSPJobGroup_Dump((x))
static BOOL EFSPJobGroup_Dump(LPEFSP_JOB_GROUP lpGroup);
#else
#define EFSPJobGroup_DbgDump(x)
#endif


static BOOL CheckForJobRetry (PJOB_QUEUE lpJobQueue);

static
DWORD
TranslateCanonicalNumber(
    LPTSTR lptstrCanonicalFaxNumber,
    DWORD  dwDeviceID,
    LPTSTR lptstrDialableAddress,
    LPTSTR lptstrDisplayableAddress
);

static BOOL TerminateMultipleFSPJobs(PHANDLE lpRecipientJobHandles, DWORD dwRecipientCount, PLINE_INFO lpLineInfo);

static PJOB_ENTRY
StartLegacySendJob(
        PJOB_QUEUE lpJobQueue,
        PLINE_INFO lpLineInfo,
        BOOL bHandoff
    );

static BOOL HandleFSPIJobStatusMessage(LPCFSPI_JOB_STATUS_MSG lpcMsg);

static PJOB_ENTRY CreateJobEntry(PJOB_QUEUE lpJobQueue, LINE_INFO * lpLineInfo, BOOL bTranslateNumber, BOOL bHandoffJob);

static BOOL CopyPermanentMessageId(
        LPFSPI_MESSAGE_ID lpMessageIdDst,
        LPCFSPI_MESSAGE_ID lpcMessageIdSrc
    );

BOOL CreateFSPIRecipientMessageIdsArray(    LPFSPI_MESSAGE_ID * lppRecipientMessageIds, DWORD dwRecipientsCount, DWORD dwMessageIdSize);
BOOL FreeFSPIRecipientMessageIdsArray(LPFSPI_MESSAGE_ID lpRecipientMessageIds, DWORD dwRecipientCount);

static BOOL FreeRecipientGroup(
    LIST_ENTRY * lpRecipientsGroup
    );
static BOOL CreateRecipientGroup(
    const PJOB_QUEUE lpcAnchorJob,
    const PLINE_INFO lpcLineInfo,
    LPEFSP_JOB_GROUP lpRecipientsGroup
    );

BOOL FaxPersonalProfileToFSPIPersonalProfile(LPFSPI_PERSONAL_PROFILE lpDst, LPCFAX_PERSONAL_PROFILE lpcSrc);
BOOL
FaxCoverPageToFSPICoverPage(
    LPFSPI_COVERPAGE_INFO lpDst,
    LPCFAX_COVERPAGE_INFO_EXW lpcSrc,
    DWORD dwPageCount);
BOOL CreateFSPIRecipientProfilesArray(
    LPFSPI_PERSONAL_PROFILE * lppRecipientProfiles,
    DWORD dwRecipientCount,
    const LIST_ENTRY * lpcRecipientsGroup
    );
BOOL FreeJobEntry(PJOB_ENTRY lpJobEntry , BOOL bDestroy);



static BOOL UpdatePerfCounters(const JOB_QUEUE * lpcJobQueue);
static BOOL
CreateCoverpageTiffFile(
    IN short Resolution,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo,
    IN LPCWSTR lpcwstrExtension,
    OUT LPWSTR CovTiffFile
    );
BOOL StartFaxDevSendEx(PJOB_QUEUE lpJobQueue, PLINE_INFO pLineInfo);

static LPWSTR
GetFaxPrinterName(
    VOID
    );


DWORD BrandFax(LPCTSTR lpctstrFileName, LPCFSPI_BRAND_INFO pcBrandInfo)

{
    #define MAX_BRANDING_LEN  115
    #define BRANDING_HEIGHT  22 // in scan lines.

    //
    // We allocate fixed size arrays on the stack to avoid many small allocs on the heap.
    //
    LPTSTR lptstrBranding = NULL;
    DWORD  lenBranding =0;
    TCHAR  szBrandingEnd[MAX_BRANDING_LEN+1];
    DWORD  lenBrandingEnd = 0;
    LPTSTR lptstrCallerNumberPlusCompanyName = NULL;
    DWORD  lenCallerNumberPlusCompanyName = 0;
    DWORD  delta =0 ;
    DWORD  ec = ERROR_SUCCESS;
    LPTSTR lptstrDate = NULL;
    LPTSTR lptstrTime = NULL;
    LPTSTR lptstrDateTime = NULL;
    int    lenDate =0 ;
    int    lenTime =0;
    LPDWORD MsgPtr[6];


    LPTSTR lptstrSenderTsid;
    LPTSTR lptstrRecipientPhoneNumber;
    LPTSTR lptstrSenderCompany;

    DWORD dwSenderTsidLen;
    DWORD dwSenderCompanyLen;


    DEBUG_FUNCTION_NAME(TEXT("BrandFax"));

    Assert(lpctstrFileName);
    Assert(pcBrandInfo);


    lptstrSenderTsid = pcBrandInfo->lptstrSenderTsid ? pcBrandInfo->lptstrSenderTsid : TEXT("");
    lptstrRecipientPhoneNumber =  pcBrandInfo->lptstrRecipientPhoneNumber ? pcBrandInfo->lptstrRecipientPhoneNumber : TEXT("");
    lptstrSenderCompany = pcBrandInfo->lptstrSenderCompany ? pcBrandInfo->lptstrSenderCompany : TEXT("");

    dwSenderTsidLen = lptstrSenderTsid ? _tcslen(lptstrSenderTsid) : 0;
    dwSenderCompanyLen = lptstrSenderCompany ? _tcslen(lptstrSenderCompany) : 0;

    lenDate = GetY2KCompliantDate(
                LOCALE_SYSTEM_DEFAULT,
                0,
                &pcBrandInfo->tmDateTime,
                NULL,
                NULL);

    if ( ! lenDate )
    {

        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetY2KCompliantDate() failed (ec: %ld)"),
            ec
        );
        goto Error;
    }

    lptstrDate = (LPTSTR) MemAlloc(lenDate * sizeof(TCHAR)); // lenDate includes terminating NULL
    if (!lptstrDate)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate date buffer of size %ld (ec: %ld)"),
            lenDate * sizeof(TCHAR),
            ec);
        goto Error;
    }

    if (!GetY2KCompliantDate(
                LOCALE_SYSTEM_DEFAULT,
                0,
                &pcBrandInfo->tmDateTime,
                lptstrDate,
                lenDate))
    {

        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetY2KCompliantDate() failed (ec: %ld)"),
            ec
        );
        goto Error;
    }

    lenTime = FaxTimeFormat( LOCALE_SYSTEM_DEFAULT,
                                     TIME_NOSECONDS,
                                     &pcBrandInfo->tmDateTime,
                                     NULL,
                                     NULL,
                                     0 );

    if ( !lenTime )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxTimeFormat() failed (ec: %ld)"),
            ec
        );
        goto Error;
    }


    lptstrTime = (LPTSTR) MemAlloc(lenTime * sizeof(TCHAR)); // lenTime includes terminating NULL
    if (!lptstrTime)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate time buffer of size %ld (ec: %ld)"),
            lenTime * sizeof(TCHAR),
            ec);
        goto Error;
    }
    if ( ! FaxTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            TIME_NOSECONDS,
            &pcBrandInfo->tmDateTime,
            NULL,                // use locale format
            lptstrTime,
            lenTime)  )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxTimeFormat() failed (ec: %ld)"),
            ec
        );
        goto Error;
    }


    //
    // Concatenate date and time
    //
    lptstrDateTime = (LPTSTR) MemAlloc ((lenDate + lenTime) * sizeof(TCHAR) + sizeof(TEXT("%s %s")));
    if (!lptstrDateTime)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate DateTime buffer of size %ld (ec: %ld)"),
            (lenDate + lenTime) * sizeof(TCHAR) + sizeof(TEXT("%s %s")),
            ec);
        goto Error;
    }

    _stprintf( lptstrDateTime,
               TEXT("%s %s"),
               lptstrDate,
               lptstrTime);

    //
    // Create  lpCallerNumberPlusCompanyName
    //

    if (lptstrSenderCompany)
    {
        lptstrCallerNumberPlusCompanyName = (LPTSTR)
            MemAlloc( (dwSenderTsidLen + dwSenderCompanyLen) *
                      sizeof(TCHAR) +
                      sizeof(TEXT("%s %s")));

        if (!lptstrCallerNumberPlusCompanyName)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate CallerNumberPlusCompanyName buffer of size %ld (ec: %ld)"),
                (dwSenderTsidLen + dwSenderCompanyLen) * sizeof(TCHAR) + sizeof(TEXT("%s %s")),
                ec);
            goto Error;
        }

       _stprintf( lptstrCallerNumberPlusCompanyName,
                  TEXT("%s %s"),
                  lptstrSenderTsid,
                  lptstrSenderCompany);
    }
    else {
        lptstrCallerNumberPlusCompanyName = (LPTSTR)
            MemAlloc( (dwSenderTsidLen + 1) * sizeof(TCHAR));

        if (!lptstrCallerNumberPlusCompanyName)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate CallerNumberPlusCompanyName buffer of size %ld (ec: %ld)"),
                (dwSenderTsidLen + 1) * sizeof(TCHAR),
                ec);
            goto Error;
        }
        _stprintf( lptstrCallerNumberPlusCompanyName,
                  TEXT("%s"),
                  lptstrSenderTsid);
    }



    //
    // Try to create a banner of the following format:
    // <szDateTime>  FROM: <szCallerNumberPlusCompanyName>  TO: <pcBrandInfo->lptstrRecipientPhoneNumber>   PAGE: X OF Y
    // If it does not fit we will start chopping it off.
    //
    MsgPtr[0] = (LPDWORD) lptstrDateTime;
    MsgPtr[1] = (LPDWORD) lptstrCallerNumberPlusCompanyName;
    MsgPtr[2] = (LPDWORD) lptstrRecipientPhoneNumber;
    MsgPtr[3] = NULL;

    lenBranding = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        NULL,
                        MSG_BRANDING_FULL,
                        0,
                        (LPTSTR)&lptstrBranding,
                        0,
                        (va_list *) MsgPtr
                        );

    if ( ! lenBranding  )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FormatMessage of MSG_BRANDING_FULL failed (ec: %ld)"),
            ec);
        goto Error;
    }

    Assert(lptstrBranding);

    lenBrandingEnd = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE ,
                        NULL,
                        MSG_BRANDING_END,
                        0,
                        szBrandingEnd,
                        sizeof(szBrandingEnd)/sizeof(TCHAR),
                        NULL
                        );

    if ( !lenBrandingEnd)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FormatMessage of MSG_BRANDING_END failed (ec: %ld)"),
            ec);
        goto Error;
    }

    //
    // Make sure we can fit everything.
    //

    if (lenBranding + lenBrandingEnd + 8 <= MAX_BRANDING_LEN)
    {
        //
        // It fits. Proceed with branding.
        //
       goto lDoBranding;
    }

    //
    // It did not fit. Try a message of the format:
    // <lpDateTime>  FROM: <lpCallerNumberPlusCompanyName>  PAGE: X OF Y
    // This skips the ReceiverNumber. The important part is the CallerNumberPlusCompanyName.
    //
    MsgPtr[0] = (LPDWORD) lptstrDateTime;
    MsgPtr[1] = (LPDWORD) lptstrCallerNumberPlusCompanyName;
    MsgPtr[2] = NULL;

    //
    // Free the previous attempt branding string
    //
    Assert(lptstrBranding);
    LocalFree(lptstrBranding);
    lptstrBranding = NULL;

    lenBranding = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        NULL,
                        MSG_BRANDING_SHORT,
                        0,
                        (LPTSTR)&lptstrBranding,
                        0,
                        (va_list *) MsgPtr
                        );

    if ( !lenBranding )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FormatMessage() failed for MSG_BRANDING_SHORT (ec: %ld)"),
            ec);
        goto Error;
    }

    Assert(lptstrBranding);

    if (lenBranding + lenBrandingEnd + 8 <= MAX_BRANDING_LEN)  {
       goto lDoBranding;
    }

    //
    // It did not fit.
    // We have to truncate the caller number so it fits.
    // delta = how many chars of the company name we need to chop off.
    //
    delta = lenBranding + lenBrandingEnd + 8 - MAX_BRANDING_LEN;

    lenCallerNumberPlusCompanyName = _tcslen (lptstrCallerNumberPlusCompanyName);
    if (lenCallerNumberPlusCompanyName <= delta) {
       DebugPrintEx(
           DEBUG_ERR,
           TEXT("Can not truncate CallerNumberPlusCompanyName to fit brand limit.")
           TEXT(" Delta[%ld] >= lenCallerNumberPlusCompanyName[%ld]"),
           delta,
           lenCallerNumberPlusCompanyName);
       ec = ERROR_BAD_FORMAT;
       goto Error;
    }

    lptstrCallerNumberPlusCompanyName[ lenCallerNumberPlusCompanyName - delta] = TEXT('\0');

    MsgPtr[0] = (LPDWORD) lptstrDateTime;
    MsgPtr[1] = (LPDWORD) lptstrCallerNumberPlusCompanyName;
    MsgPtr[2] = NULL;

    //
    // Free the previous attempt branding string
    //
    Assert(lptstrBranding);
    LocalFree(lptstrBranding);
    lptstrBranding = NULL;

    lenBranding = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        NULL,
                        MSG_BRANDING_SHORT,
                        0,
                        (LPTSTR)&lptstrBranding,
                        0,
                        (va_list *) MsgPtr
                        );

    if ( !lenBranding )
    {

        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FormatMessage() failed (ec: %ld). MSG_BRANDING_SHORT 2nd attempt"),
            ec);
        goto Error;
    }

    Assert(lptstrBranding);
    //
    // If it did noo fit now then we have a bug.
    //
    Assert(lenBranding + lenBrandingEnd + 8 <= MAX_BRANDING_LEN);


lDoBranding:

    __try
    {

        if (! MmrAddBranding(lpctstrFileName, lptstrBranding, szBrandingEnd, BRANDING_HEIGHT) ) {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("MmrAddBranding() failed (ec: %ld)")
                TEXT(" File: [%s]")
                TEXT(" Branding: [%s]")
                TEXT(" Branding End: [%s]")
                TEXT(" Branding Height: [%d]"),
                ec,
                lpctstrFileName,
                lptstrBranding,
                szBrandingEnd,
                BRANDING_HEIGHT);
            goto Error;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER)
    {

        ec = GetExceptionCode();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Exception on call to MmrAddBranding() (ec: %ld).")
                TEXT(" File: [%s]")
                TEXT(" Branding: [%s]")
                TEXT(" Branding End: [%s]")
                TEXT(" Branding Height: [%d]"),
                ec,
                lpctstrFileName,
                lptstrBranding,
                szBrandingEnd,
                BRANDING_HEIGHT);
        goto Error;
     }

    Assert( ERROR_SUCCESS == ec);

    goto Exit;



Error:
        Assert (ERROR_SUCCESS != ec);

Exit:
    if (lptstrBranding)
    {
        LocalFree(lptstrBranding);
        lptstrBranding = NULL;
    }

    MemFree(lptstrDate);
    lptstrDate = NULL;

    MemFree(lptstrTime);
    lptstrTime = NULL;

    MemFree(lptstrDateTime);
    lptstrDateTime = NULL;

    MemFree(lptstrCallerNumberPlusCompanyName);
    lptstrCallerNumberPlusCompanyName = NULL;

    return ec;

}


HRESULT
WINAPI
FaxBrandDocument(
    LPCTSTR lpctsrtFile,
    LPCFSPI_BRAND_INFO lpcBrandInfo)
{

    DEBUG_FUNCTION_NAME(TEXT("FaxBrandDocument"));
    DWORD ec = ERROR_SUCCESS;

    if (!lpctsrtFile)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("NULL target file name"));
        ec = ERROR_INVALID_PARAMETER;
        goto Error;
    }

    if (!lpcBrandInfo)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("NULL branding info"));
        ec = ERROR_INVALID_PARAMETER;
        goto Error;
    }


    if (lpcBrandInfo->dwSizeOfStruct != sizeof(FSPI_BRAND_INFO))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Bad cover page info parameter, dwSizeOfStruct = %d"),
                     lpcBrandInfo->dwSizeOfStruct);
        ec = ERROR_INVALID_PARAMETER;
        goto Error;
    }


    ec = BrandFax(lpctsrtFile, lpcBrandInfo);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("BrandFax() for file %s has failed (ec: %ld)"),
            lpctsrtFile,
            ec);
        goto Error;
    }
    Assert (ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert (ERROR_SUCCESS != ec);
Exit:

    return HRESULT_FROM_WIN32(ec);
}


PJOB_ENTRY
FindJob(
    IN HANDLE FaxHandle
    )

/*++

Routine Description:

    This fuction locates a FAX job by matching
    the FAX handle value.

Arguments:

    FaxHandle       - FAX handle returned from startjob

Return Value:

    NULL for failure.
    Valid pointer to a JOB_ENTRY on success.

--*/

{
    PLIST_ENTRY Next;
    PJOB_ENTRY JobEntry;


    EnterCriticalSection( &g_CsJob );

    Next = g_JobListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &g_CsJob );
        return NULL;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_JobListHead) {

        JobEntry = CONTAINING_RECORD( Next, JOB_ENTRY, ListEntry );

        if ((ULONG_PTR)JobEntry->InstanceData == (ULONG_PTR)FaxHandle) {

            LeaveCriticalSection( &g_CsJob );
            return JobEntry;

        }

        Next = JobEntry->ListEntry.Flink;

    }

    LeaveCriticalSection( &g_CsJob );
    return NULL;
}


BOOL
FindJobByJob(
    IN PJOB_ENTRY JobEntryToFind
    )

/*++

Routine Description:

    This fuction check whether a FAX job exist in g_JobListHead (Job's list)

Arguments:

    JobEntryToFind   - PJOB_ENTRY from StartJob()

Return Value:

    TRUE  - if the job was found
    FALSE - otherwise

--*/

{
    PLIST_ENTRY Next;
    PJOB_ENTRY JobEntry;

    Assert(JobEntryToFind);

    EnterCriticalSection( &g_CsJob );

    Next = g_JobListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &g_CsJob );
        return FALSE;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_JobListHead) {

        JobEntry = CONTAINING_RECORD( Next, JOB_ENTRY, ListEntry );

        if (JobEntry == JobEntryToFind) {

            LeaveCriticalSection( &g_CsJob );
            return TRUE;

        }

        Next = JobEntry->ListEntry.Flink;

    }

    LeaveCriticalSection( &g_CsJob );
    return FALSE;
}


BOOL
FaxSendCallback(
    IN HANDLE FaxHandle,
    IN HCALL CallHandle,
    IN DWORD Reserved1,
    IN DWORD Reserved2
    )

/*++

Routine Description:

    This fuction is called asychronously by a FAX device
    provider after a call is established.  The sole purpose
    of the callback is to communicate the call handle from the
    device provider to the FAX service.

Arguments:

    FaxHandle       - FAX handle returned from startjob
    CallHandle      - Call handle for newly initiated call
    Reserved1       - Always zero.
    Reserved2       - Always zero.

Return Value:

    TRUE for success, FAX operation continues.
    FALSE for failure, FAX operation is terminated.

--*/

{
    PJOB_ENTRY JobEntry;


    JobEntry = FindJob( FaxHandle );
    if (!JobEntry) {

        return FALSE;

    }

    JobEntry->CallHandle = CallHandle;

    return TRUE;

}



//*********************************************************************************
//* Name:   CreateCoverpageTiffFileEx()
//* Author: Ronen Barenboim
//* Date:   March 24, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Generates cover page TIFF file from the specified cover page template
//*     and new Client API parameters.
//*     The function returns the name of the generated file.
//* PARAMETERS:
//*     Resolution    [IN]
//*
//*     dwPageCount [IN]
//*
//*     lpcCoverpageEx [IN]
//*
//*     lpcRecipient [IN]
//*
//*     lpcSender [IN]
//*
//*     lpcwstrExtension [IN] - File extension (optional).
//*
//*     lptstrCovTiffFile [OUT]
//*         A pointer to Unicode string buffer where the function will place
//*         the full path to the generated cover page TIFF file.
//*         The size of this buffer must be (MAX_PATH+1)*sizeof(WCHAR).
//*         The calling function must take care of deleting the file.
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         Otherwise. Use GetLastError() to figure out why it failed.
//*
//* REMARKS:
//*     The function does not allocate any memory.
//*********************************************************************************
BOOL
CreateCoverpageTiffFileEx(
    IN short                        Resolution,
    IN DWORD                        dwPageCount,
    IN LPCFAX_COVERPAGE_INFO_EXW  lpcCoverpageEx,
    IN LPCFAX_PERSONAL_PROFILEW  lpcRecipient,
    IN LPCFAX_PERSONAL_PROFILEW  lpcSender,
    IN LPCWSTR                   lpcwstrExtension,
    OUT LPWSTR lptstrCovTiffFile)
{
    FAX_COVERPAGE_INFOW covLegacy;
    BOOL                bRes = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("CreateCoverpageTiffFileEx"));

    Assert(lpcCoverpageEx);
    Assert(lpcRecipient);
    Assert(lpcSender);
    Assert(lptstrCovTiffFile);

    //
    // Prepare a legacy FAX_COVERPAGE_INFO from the new cover page info
    //
    memset(&covLegacy,0,sizeof(covLegacy));
    covLegacy.SizeOfStruct=sizeof(covLegacy);
    covLegacy.CoverPageName=lpcCoverpageEx->lptstrCoverPageFileName;
    covLegacy.UseServerCoverPage=lpcCoverpageEx->bServerBased;
    covLegacy.RecCity=lpcRecipient->lptstrCity;
    covLegacy.RecCompany=lpcRecipient->lptstrCompany;
    covLegacy.RecCountry=lpcRecipient->lptstrCountry;
    covLegacy.RecDepartment=lpcRecipient->lptstrDepartment;
    covLegacy.RecFaxNumber=lpcRecipient->lptstrFaxNumber;
    covLegacy.RecHomePhone=lpcRecipient->lptstrHomePhone;
    covLegacy.RecName=lpcRecipient->lptstrName;
    covLegacy.RecOfficeLocation=lpcRecipient->lptstrOfficeLocation;
    covLegacy.RecOfficePhone=lpcRecipient->lptstrOfficePhone;
    covLegacy.RecState=lpcRecipient->lptstrState;
    covLegacy.RecStreetAddress=lpcRecipient->lptstrStreetAddress;
    covLegacy.RecTitle=lpcRecipient->lptstrTitle;
    covLegacy.RecZip=lpcRecipient->lptstrZip;
    covLegacy.SdrName=lpcSender->lptstrName;
    covLegacy.SdrFaxNumber=lpcSender->lptstrFaxNumber;
    covLegacy.SdrCompany=lpcSender->lptstrCompany;
    covLegacy.SdrTitle=lpcSender->lptstrTitle;
    covLegacy.SdrDepartment=lpcSender->lptstrDepartment;
    covLegacy.SdrOfficeLocation=lpcSender->lptstrOfficeLocation;
    covLegacy.SdrHomePhone=lpcSender->lptstrHomePhone;
    covLegacy.SdrAddress=lpcSender->lptstrStreetAddress;
    covLegacy.SdrOfficePhone=lpcSender->lptstrOfficePhone;
    covLegacy.Note=lpcCoverpageEx->lptstrNote;
    covLegacy.Subject=lpcCoverpageEx->lptstrSubject;
    covLegacy.PageCount=dwPageCount;

    //
    // Note covLegacy.TimeSent is not set. This field's value is
    // generated by FaxPrintCoverPageW().
    //

    //
    // Now call the legacy CreateCoverPageTiffFile() to generate the cover page file
    //
    if (!CreateCoverpageTiffFile(Resolution, &covLegacy, lpcwstrExtension, lptstrCovTiffFile)) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to generate cover page file for recipient %s@%s. (ec: %ld)"),
            lpcRecipient->lptstrName,
            lpcRecipient->lptstrFaxNumber,
            GetLastError()
            );
        bRes = FALSE;
    }

    return bRes;
}


LPWSTR
GetFaxPrinterName(
    VOID
    )
{
    PPRINTER_INFO_2 PrinterInfo;
    DWORD i;
    DWORD Count;


    PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &Count, 0 );
    if (PrinterInfo == NULL)
    {
        if (ERROR_SUCCESS == GetLastError())
        {
            //
            // No printers are installed
            //
            SetLastError(ERROR_INVALID_PRINTER_NAME);
        }
        return NULL;
    }

    for (i=0; i<Count; i++)
    {
        if (_wcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0 &&
            _wcsicmp( PrinterInfo[i].pPortName, FAX_PORT_NAME ) == 0)
        {
            LPWSTR p = (LPWSTR) StringDup( PrinterInfo[i].pPrinterName );
            MemFree( PrinterInfo );
            if (NULL == p )
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            }
            return p;
        }
    }

    MemFree( PrinterInfo );
    SetLastError (ERROR_INVALID_PRINTER_NAME);
    return NULL;
}

VOID
FreeCpFields(
    PCOVERPAGEFIELDS pCpFields
    )

/*++

Routine Description:

    Frees all memory associated with a coverpage field structure.


Arguments:

    CpFields    - Pointer to a coverpage field structure.

Return Value:

    None.

--*/

{
    DWORD i; 
	LPTSTR* lpptstrString;

    for (i = 0; i < NUM_INSERTION_TAGS; i++)
    {
        lpptstrString = (LPTSTR*) ((LPBYTE)(&(pCpFields->RecName)) + (i * sizeof(LPTSTR)));        
        MemFree (*lpptstrString) ;              
    }
}


BOOL
FillCoverPageFields(
    IN const FAX_COVERPAGE_INFO* pFaxCovInfo,
    OUT PCOVERPAGEFIELDS pCPFields)
/*++

Author:

      Oded Sacher 27-June-2001

Routine Description:

    Fills a COVERPAGEFIELDS structure from the content of a FAX_COVERPAGE_INFO structure.
    Used to prepare a COVERPAGEFIELDS structure for cover page rendering before rendering cover page.

Arguments:

    [IN] pFaxCovInfo - Pointer to a FAX_COVERPAGE_INFO that holds the information to be extracted.

    [OUT] pCPFields - Pointer to a COVERPAGEFIELDS structure that gets filled with
                                      the information from FAX_COVERPAGE_INFO.

Return Value:

    BOOL

Comments:
    The function allocates memory. 
	Call FreeCoverPageFields to free resources.


--*/
{
	DWORD dwDateTimeLen;
    DWORD cch;
    LPTSTR s;
    DWORD ec = 0;
    LPCTSTR *src;
    LPCTSTR *dst;
    DWORD i;
    TCHAR szTimeBuffer[MAX_PATH] = {0};
	TCHAR szNumberOfPages[12] = {0};


    Assert(pFaxCovInfo);
    Assert(pCPFields);

    memset(pCPFields,0,sizeof(COVERPAGEFIELDS));

    pCPFields->ThisStructSize = sizeof(COVERPAGEFIELDS);

    pCPFields->RecName = StringDup(pFaxCovInfo->RecName);
    pCPFields->RecFaxNumber = StringDup(pFaxCovInfo->RecFaxNumber);
    pCPFields->Subject = StringDup(pFaxCovInfo->Subject);
    pCPFields->Note = StringDup(pFaxCovInfo->Note);
    pCPFields->NumberOfPages = StringDup(_itot( pFaxCovInfo->PageCount, szNumberOfPages, 10 ));

    for (i = 0;
         i <= ((LPBYTE)&pFaxCovInfo->SdrOfficePhone - (LPBYTE)&pFaxCovInfo->RecCompany)/sizeof(LPCTSTR);
         i++)
    {
        src = (LPCTSTR *) ((LPBYTE)(&pFaxCovInfo->RecCompany) + (i*sizeof(LPCTSTR)));
        dst = (LPCTSTR *) ((LPBYTE)(&(pCPFields->RecCompany)) + (i*sizeof(LPCTSTR)));

        if (*dst)
        {
            MemFree ( (LPBYTE) *dst ) ;
        }
        *dst = (LPCTSTR) StringDup( *src );
    }
    //
    // the time the fax was sent
    //
    GetLocalTime((LPSYSTEMTIME)&pFaxCovInfo->TimeSent);
    //
    // dwDataTimeLen is the size of s in characters
    //
    dwDateTimeLen = ARR_SIZE(szTimeBuffer);
    s = szTimeBuffer;
    //
    // Get date into s
    //
    GetY2KCompliantDate( LOCALE_USER_DEFAULT, 0, &pFaxCovInfo->TimeSent, s, dwDateTimeLen );
    //
    // Advance s past the date string and attempt to append time
    //
    cch = _tcslen( s );
    s += cch;
    
    if (++cch < dwDateTimeLen)
    {
        *s++ = ' ';
        //
        // DateTimeLen is the decreased by the size of s in characters
        //
        dwDateTimeLen -= cch;
        // 
        // Get the time here
        //
        FaxTimeFormat( LOCALE_USER_DEFAULT, 0, &pFaxCovInfo->TimeSent, NULL, s, dwDateTimeLen );
    }

    pCPFields->TimeSent = StringDup( szTimeBuffer );

    return TRUE;
}


//*****************************************************************************
//* Name:   CreateCoverpageTiffFile
//* Author:
//*****************************************************************************
//* DESCRIPTION:
//*     Renders the specified coverpage into a temp TIFF file and returns the name
//*     of the temp TIFF file.
//* PARAMETERS:
//*     [IN] IN short Resolution:
//*         196 for 200x200 resolution.
//*         98 for 200x100 resolution.
//*     [IN] FAX_COVERPAGE_INFOW *CoverpageInfo:
//*         A pointer to a FAX_COVERPAGE_INFOW structure that contains the cover page
//*         template information (see SDK help).
//*     [IM] LPCWSTR lpcwstrExtension - File extension (".TIF" if NULL)
//*
//*     [OUT] LPWSTR CovTiffFile:
//*         A pointer to a buffer where the function returns the name of the temp file
//*         that contains the rendered cover page TIFF file.
//* RETURN VALUE:
//*         FALSE if the operation failed.
//*         TRUE is succeeded.
//* Comments:
//*         If the operation failes the function takes care of deleting any temp files.
//*****************************************************************************
BOOL
CreateCoverpageTiffFile(
    IN short Resolution,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo,
    IN LPCWSTR lpcwstrExtension,
    OUT LPWSTR CovTiffFile
    )
{
    //WCHAR TempPath[MAX_PATH];
    WCHAR TempFile[MAX_PATH];
	WCHAR wszCpName[MAX_PATH];
    LPWSTR FaxPrinter = NULL;            
    BOOL Rslt = TRUE;
	COVDOCINFO  covDocInfo;
	short Orientation = DMORIENT_PORTRAIT;      
	DWORD ec;
	COVERPAGEFIELDS CpFields = {0};
    DEBUG_FUNCTION_NAME(TEXT("CreateCoverpageTiffFile()"));

    LPCWSTR lpcwstrFileExt =  lpcwstrExtension ? lpcwstrExtension : FAX_TIF_FILE_EXT;
    TempFile[0] = L'\0';

	//
	// Validate the cover page and resolve the full path
	//
	if (!ValidateCoverpage((LPWSTR)CoverpageInfo->CoverPageName,
                           NULL,
                           CoverpageInfo->UseServerCoverPage,
                           wszCpName))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("ValidateCoverpage failed. ec = %ld"),
                     GetLastError());
        Rslt=FALSE;
        goto Exit;
    }

	//
	// Collect the cover page fields
	//
	FillCoverPageFields( CoverpageInfo, &CpFields);

    FaxPrinter = GetFaxPrinterName();
    if (FaxPrinter == NULL)
	{
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("GetFaxPrinterName failed. ec = %ld"),
			GetLastError());
        Rslt=FALSE;
        goto Exit;
    }

	//
	// Get the cover page orientation
	//
	ec = PrintCoverPage(NULL, NULL, wszCpName, &covDocInfo); 
	if (ERROR_SUCCESS != ec)             
    {        
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("PrintCoverPage for coverpage %s failed (ec: %ld)"),
			CoverpageInfo->CoverPageName,
			ec);
        Rslt=FALSE;
        goto Exit;        
    }

    if (!GenerateUniqueFileName( g_wszFaxQueueDir, (LPWSTR)lpcwstrFileExt, TempFile, sizeof(TempFile)/sizeof(WCHAR) ))
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to generate unique file name for merged TIFF file (ec: %ld)."),GetLastError());
        Rslt=FALSE;
        goto Exit;
    }

	//
	// Change the default orientation if needed
	//
	if (covDocInfo.Orientation == DMORIENT_LANDSCAPE)
	{
		Orientation = DMORIENT_LANDSCAPE;
	}

	//
	// Render the cover page to a file
	//
	ec = PrintCoverPageToFile(
		wszCpName,
		TempFile,
		FaxPrinter,
		Orientation,
		Resolution,
		&CpFields);	
	if (ERROR_SUCCESS != ec)             
    {        
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("PrintCoverPageToFile for coverpage %s failed (ec: %ld)"),
			CoverpageInfo->CoverPageName,
			ec);
        Rslt=FALSE;

		if (!DeleteFile( TempFile ))
		{
			DebugPrintEx(
				DEBUG_ERR,
				TEXT("DeleteFile for file %s failed (ec: %ld)"),
				TempFile,
				GetLastError());
		}
        goto Exit;        
    }	   

    wcsncpy( CovTiffFile, TempFile,MAX_PATH-1 );
    CovTiffFile[MAX_PATH-1]=L'\0';
	Rslt = TRUE;
    
Exit:
    MemFree(FaxPrinter);
	FreeCpFields(&CpFields);
    return Rslt;
}


//*****************************************************************************
//* Name:   GetBodyTiffResolution
//* Author:
//*****************************************************************************
//* DESCRIPTION:
//*     Returns the body tiff file resolution. (200x200 or 200x100)
//*     The resolution is determined by the first page only!!
//* PARAMETERS:
//*
//*     [IN] LPCWSTR lpcwstrBodyFile - Body tiff file
//*
//*     [OUT] short* pResolution:
//*         A pointer to a short where the function returns the tiff resolution.
//*         TRUE is 200x200. FALSE is 200x100
//* RETURN VALUE:
//*         FALSE if the operation failed.
//*         TRUE is succeeded.
//* Comments:
//*****************************************************************************
BOOL
GetBodyTiffResolution(
    IN LPCWSTR lpcwstrBodyFile,
    OUT short*  pResolution
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetBodyTiffResolution"));
    TIFF_INFO TiffInfo;
    HANDLE hTiff = NULL;
    BOOL RetVal = TRUE;

    Assert (lpcwstrBodyFile && pResolution);

    //
    // open the tiff file
    //
    hTiff = TiffOpen( lpcwstrBodyFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
    if (hTiff == NULL)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("TiffOpen() failed. Tiff file: %s"),
                lpcwstrBodyFile);
        RetVal = FALSE;
        goto exit;
    }

    if (TiffInfo.YResolution != 98 &&
        TiffInfo.YResolution != 196)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid Tiff Resolutoin. Tiff file: %s, YRes: %ld."),
                lpcwstrBodyFile,
                TiffInfo.YResolution);
        RetVal = FALSE;
        goto exit;
    }

    *pResolution = TiffInfo.YResolution;
    Assert (TRUE == RetVal);

exit:
    if (NULL != hTiff)
    {
        if (!TiffClose(hTiff))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("TiffClose() failed. Tiff file: %s"),
                lpcwstrBodyFile);
        }
    }

    return RetVal;
}

//*********************************************************************************
//* Name:   CreateTiffFile ()
//* Author: Ronen Barenboim
//* Date:   March 24, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates the TIFF file for a job queue.
//*
//*     The function deals with generating the cover page file and merging it
//*     with the body file (if a body exists).
//*     It returns the name of the TIFF file it generated. The caller must delete
//*     this file when it is no longer needed.
//* PARAMETERS:
//*     PJOB_QUEUE lpJob
//*         A pointer to a JOB_QUEUE structure that holds the recipient or routing job
//*         information.
//*     LPCWSTR lpcwstrFileExt - The new file extension (Null will create the default "*.TIF"
//*
//*     LPWSTR lpwstrFullPath - Pointer to a buffer of size MAX_PATH to receive the full path to the new file
//*         Flag that indicates the tiff is for preview
//*
//* RETURN VALUE:
//*     TRUE if successful.
//*     FALSE otherwise.   Set last erorr on failure
//*********************************************************************************
BOOL
CreateTiffFile (
    PJOB_QUEUE lpJob,
    LPCWSTR lpcwstrFileExt,
    LPWSTR lpwstrFullPath
    )
{
    DEBUG_FUNCTION_NAME(TEXT("CreateTiffFile"));
    Assert(lpJob && lpwstrFullPath);
    Assert(JT_SEND == lpJob->JobType ||
           JT_ROUTING == lpJob->JobType);

    PJOB_QUEUE  lpParentJob = NULL;
    WCHAR szCoverPageTiffFile[MAX_PATH] = {0};
    LPCWSTR lpcwstrCoverPageFileName;
    LPCWSTR lpcwstrBodyFileName;
    short Resolution = 0; // Default resolution
    BOOL bRes = FALSE;

    if (JT_SEND == lpJob->JobType)
    {
        lpParentJob = lpJob->lpParentJob;
        Assert(lpParentJob);
    }

    lpcwstrCoverPageFileName = lpParentJob ? lpParentJob->CoverPageEx.lptstrCoverPageFileName : NULL;
    lpcwstrBodyFileName = lpParentJob ? lpParentJob->FileName : lpJob->FileName;

    if (!lpcwstrCoverPageFileName)
    {
        //
        // No cover page specified.
        // The TIFF to send is the body only.
        // Copy the body for each recipient
        //
        Assert(lpcwstrBodyFileName); // must have a body in this case.
        LPCWSTR lpcwstrExt = lpcwstrFileExt ? lpcwstrFileExt : FAX_TIF_FILE_EXT;

        if (!GenerateUniqueFileName( g_wszFaxQueueDir,
                                     (LPWSTR)lpcwstrExt,
                                     szCoverPageTiffFile,
                                     sizeof(szCoverPageTiffFile)/sizeof(WCHAR) ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GenerateUniqueFileName() failed (ec: %ld)."),
                GetLastError());
            goto Exit;
        }

        if (!CopyFile (lpcwstrBodyFileName, szCoverPageTiffFile, FALSE)) // FALSE - File already exist
        {
            DebugPrintEx(DEBUG_ERR,
                    TEXT("CopyFile Failed with %ld "),
                    GetLastError());
            DeleteFile(szCoverPageTiffFile);
            goto Exit;
        }

        bRes = TRUE;
        goto Exit;
    }

    //
    // There is a cover page so the tiff is either just the cover page or the cover page
    // merged with the body.
    //

    if (lpParentJob->FileName)
    {
        if (!GetBodyTiffResolution(lpParentJob->FileName, &Resolution))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetBodyTiffResolution() failed (ec: %ld)."),
                GetLastError());
            goto Exit;
        }
    }

    Assert (Resolution == 0 || Resolution == 98 || Resolution == 196);
    //
    // First create the cover page (This generates a file and returns its name).
    //
    if (!CreateCoverpageTiffFileEx(
                              Resolution,
                              lpJob->PageCount,
                              &lpParentJob->CoverPageEx,
                              &lpJob->RecipientProfile,
                              &lpParentJob->SenderProfile,
                              lpcwstrFileExt,
                              szCoverPageTiffFile))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("[JobId: %ld] Failed to render cover page template %s"),
                     lpJob->JobId,
                     lpParentJob->CoverPageEx.lptstrCoverPageFileName);
        goto Exit;
    }


    if (lpParentJob->FileName)
    {
        //
        // There is a body file specified so merge the body and the cover page into
        // the file specified in szCoverPageTiffFile.
        //
        if (!MergeTiffFiles( szCoverPageTiffFile, lpParentJob->FileName)) {
                DebugPrintEx(DEBUG_ERR,
                             TEXT("[JobId: %ld] Failed to merge cover (%ws) and body (%ws). (ec: %ld)"),
                             lpJob->JobId,
                             szCoverPageTiffFile,
                             lpParentJob->FileName,
                             GetLastError());
                //
                // Get rid of the coverpage TIFF we generated.
                //
                if (!DeleteFile(szCoverPageTiffFile)) {
                    DebugPrintEx(DEBUG_ERR,
                             TEXT("[JobId: %ld] Failed to delete cover page TIFF file %ws. (ec: %ld)"),
                             lpJob->JobId,
                             szCoverPageTiffFile,
                             GetLastError());
                }
                goto Exit;
        }
    }
    bRes =  TRUE;

Exit:
    if (FALSE == bRes)
    {
        //
        // Make sure we set last error
        //
        if (ERROR_SUCCESS == GetLastError())
        {
            SetLastError (ERROR_GEN_FAILURE);
        }
    }
    else
    {
        //
        // Success - return the tiff file path
        //
        wcscpy (lpwstrFullPath, szCoverPageTiffFile);
    }
    return bRes;
} // CreateTiffFile


BOOL
CreateTiffFileForJob (
    PJOB_QUEUE lpRecpJob
    )
{
    DEBUG_FUNCTION_NAME(TEXT("CreateTiffFileForJob"));
    WCHAR wszFullPath[MAX_PATH] = {0};

    Assert(lpRecpJob);

    if (!CreateTiffFile (lpRecpJob, TEXT("FRT"), wszFullPath))
    {
        DebugPrintEx(DEBUG_ERR,
            TEXT("CreateTiffFile failed. (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    if (NULL == (lpRecpJob->FileName = StringDup(wszFullPath)))
    {
        DWORD dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR,
            TEXT("StringDup failed. (ec: %ld)"),
            dwErr);

        if (!DeleteFile(wszFullPath))
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("[JobId: %ld] Failed to delete TIFF file %ws. (ec: %ld)"),
                lpRecpJob->JobId,
                wszFullPath,
                GetLastError());
        }
        SetLastError(dwErr);
        return FALSE;
    }

    return TRUE;
}


BOOL
CreateTiffFileForPreview (
    PJOB_QUEUE lpRecpJob
    )
{
    DEBUG_FUNCTION_NAME(TEXT("CreateTiffFileForPreview"));
    WCHAR wszFullPath[MAX_PATH] = {0};

    Assert(lpRecpJob);

    if (lpRecpJob->PreviewFileName)
    {
        return TRUE;
    }

    if (!CreateTiffFile (lpRecpJob, TEXT("PRV"), wszFullPath))
    {
        DebugPrintEx(DEBUG_ERR,
            TEXT("CreateTiffFile failed. (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    if (NULL == (lpRecpJob->PreviewFileName = StringDup(wszFullPath)))
    {
        DWORD dwErr = GetLastError();
        DebugPrintEx(DEBUG_ERR,
            TEXT("StringDup failed. (ec: %ld)"),
            dwErr);

        if (!DeleteFile(wszFullPath))
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("[JobId: %ld] Failed to delete TIFF file %ws. (ec: %ld)"),
                lpRecpJob->JobId,
                wszFullPath,
                GetLastError());
        }
        SetLastError(dwErr);
        return FALSE;
    }

    return TRUE;
}

DWORD
FaxRouteThread(
    PJOB_QUEUE lpJobQueueEntry
    )

/*++

Routine Description:

    This fuction runs asychronously as a separate thread to
    route an incoming job.

Arguments:

    lpJobQueueEntry  - A pointer to the job for which the routing
                        operation is to be performed.
Return Value:

    Always zero.

--*/
{
    BOOL Routed = TRUE;
    DWORD i;
    DWORD dwRes;
    DWORD CountFailureInfo = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxRouteThread"));

    EnterCriticalSectionJobAndQueue;
    CountFailureInfo = lpJobQueueEntry->CountFailureInfo;
    LeaveCriticalSectionJobAndQueue;

    for (i = 0; i < lpJobQueueEntry->CountFailureInfo; i++)
    {
        BOOL fRouteSucceed;

        fRouteSucceed = FaxRouteRetry( lpJobQueueEntry->FaxRoute, &lpJobQueueEntry->pRouteFailureInfo[i] );
        if (FALSE == fRouteSucceed)
        {
            PROUTING_METHOD pRoutingMethod = FindRoutingMethodByGuid( (lpJobQueueEntry->pRouteFailureInfo[i]).GuidString );
            if (pRoutingMethod)
            {
                WCHAR TmpStr[20] = {0};
                swprintf(TmpStr,TEXT("0x%016I64x"), lpJobQueueEntry->UniqueId);

                FaxLog(FAXLOG_CATEGORY_INBOUND,
                    FAXLOG_LEVEL_MIN,
                    6,
                    MSG_FAX_ROUTE_METHOD_FAILED,
                    TmpStr,
                    lpJobQueueEntry->FaxRoute->DeviceName,
                    lpJobQueueEntry->FaxRoute->Tsid,
                    lpJobQueueEntry->FileName,
                    pRoutingMethod->RoutingExtension->FriendlyName,
                    pRoutingMethod->FriendlyName
                    );
            }
        }
        Routed &= fRouteSucceed;
    }

    EnterCriticalSectionJobAndQueue;

    lpJobQueueEntry->dwLastJobExtendedStatus = 0;
    lpJobQueueEntry->ExStatusString[0] = TEXT('\0');

    if ( Routed )
    {
        lpJobQueueEntry->JobStatus = JS_DELETING;
        DecreaseJobRefCount (lpJobQueueEntry, TRUE);
    }
    else
    {
        //
        // We failed to execute the routing method.
        // reschedule the job.
        //
        DWORD dwMaxRetries;

        EnterCriticalSection (&g_CsConfig);
        dwMaxRetries = g_dwFaxSendRetries;
        LeaveCriticalSection (&g_CsConfig);

        lpJobQueueEntry->SendRetries++;
        if (lpJobQueueEntry->SendRetries <= dwMaxRetries)
        {
            lpJobQueueEntry->JobStatus = JS_RETRYING;
            RescheduleJobQueueEntry( lpJobQueueEntry );
        }
        else
        {
            //
            // retries exceeded, mark job as expired
            //
            MarkJobAsExpired(lpJobQueueEntry);

            WCHAR TmpStr[20] = {0};
            swprintf(TmpStr,TEXT("0x%016I64x"), lpJobQueueEntry->UniqueId);

            FaxLog(FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MIN,
                3,
                MSG_FAX_ROUTE_FAILED,
                TmpStr,
                lpJobQueueEntry->FaxRoute->DeviceName,
                lpJobQueueEntry->FaxRoute->Tsid
                );
        }

        //
        // Create Fax EventEx
        //
        dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                   lpJobQueueEntry
                                 );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(   DEBUG_ERR,
                            _T("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) ")
                            _T("failed for job id %ld (ec: %lc)"),
                            lpJobQueueEntry->UniqueId,
                            dwRes);
        }

        if (!UpdatePersistentJobStatus(lpJobQueueEntry))
        {
            DebugPrintEx(   DEBUG_ERR,
                            _T("Failed to update persistent job status to 0x%08x"),
                            lpJobQueueEntry->JobStatus);
        }
    }

    LeaveCriticalSectionJobAndQueue;

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return ERROR_SUCCESS;
}


DWORD
FaxSendThread(
    PFAX_SEND_ITEM FaxSendItem
    )

/*++

Routine Description:

    This fuction runs asychronously as a separate thread to
    send a FAX document.  There is one send thread per outstanding
    FAX send operation.  The thread ends when the document is
    either successfuly sent or the operation is aborted.

Arguments:

    FaxSendItem     - pointer to a FAX send item packet that
                      describes the requested FAX send operation.

Return Value:

    Always zero.

--*/

{
    FAX_SEND FaxSend; // This structure is passed to FaxDevSend()
    BOOL Rslt = FALSE;
    BOOL Retrying = FALSE;

    BOOL HandoffJob;
    BOOL bFakeJobStatus = FALSE;
    FSPI_JOB_STATUS FakedJobStatus = {0};
    DWORD  PageCount = 0;
    BOOL bRemoveParentJob = FALSE;  // TRUE if at the end of the send the parent job and all
                                    // recipients need to be removed.
    PJOB_QUEUE lpJobQueue = NULL ;  // Points to the Queue entry attached to the running job.
    LPFSPI_JOB_STATUS lpFSPStatus;
    DWORD dwSttRes;
    BOOL bBranding;
    DWORD dwJobId;
    BOOL bCreateTiffFailed = FALSE;
    BOOL fSetSystemIdleTimer = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("FaxSendThread"));

    Assert (FaxSendItem &&
            FaxSendItem->JobEntry &&
            FaxSendItem->JobEntry->LineInfo &&
            FaxSendItem->JobEntry->LineInfo->Provider);


    //
    // Don't let the system go to sleep in the middle of the fax transmission.
    //
    if (NULL == SetThreadExecutionState(ES_SYSTEM_REQUIRED | ES_CONTINUOUS))
    {
        fSetSystemIdleTimer = FALSE;
        DebugPrintEx(DEBUG_ERR,
            TEXT("SetThreadExecutionState() failed"));
    }

    lpJobQueue=FaxSendItem->JobEntry->lpJobQueueEntry;
    Assert(lpJobQueue);

    //
    // Set the information to be sent to FaxDevSend()
    // Note:
    //      The caller number is the sender TSID ! (we have no other indication of the sender phone number)
    //      This means that the FSP will get the sender TSID which might contain text as well (not just a number)
    //
    FaxSend.SizeOfStruct    = sizeof(FAX_SEND);

    FaxSend.CallerName      = FaxSendItem->SenderName;
    FaxSend.CallerNumber    = FaxSendItem->Tsid;
    FaxSend.ReceiverName    = FaxSendItem->RecipientName;
    FaxSend.ReceiverNumber  = FaxSendItem->PhoneNumber;
    FaxSend.CallHandle      = 0; // filled in later via TapiStatusThread, if appropriate
    FaxSend.Reserved[0]     = 0;
    FaxSend.Reserved[1]     = 0;
    FaxSend.Reserved[2]     = 0;

    //
    // Successfully created a new send job on a device. Update counter.
    //
    (VOID)UpdateDeviceJobsCounter (  FaxSendItem->JobEntry->LineInfo,   // Device to update
                                     TRUE,                              // Sending
                                     1,                                 // Number of new jobs
                                     TRUE);                             // Enable events


    HandoffJob = FaxSendItem->JobEntry->HandoffJob;
    if (!lpJobQueue->FileName)
    {
        //
        // We did not generate a body for this recipient yet. This is the
        // time to do so.
        //

        //
        // Set the right body for this job.
        // This is either the body specified at the parent or a merge of the body
        // with the cover page specified in the parent.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId: %ld] Generating body for recipient job."),
            lpJobQueue->JobId
            );

        if (!CreateTiffFileForJob(lpJobQueue))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] CreateTiffFileForJob failed. (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError()
                );
            bCreateTiffFailed = TRUE;
        }
    }
    else
    {
        //
        // We already generated a body for this recipient.
        // somthing is wrong
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] Using cached body in %s."),
            lpJobQueue->JobId,
            lpJobQueue->FileName
            );

        Assert(FALSE);
    }

    if (bCreateTiffFailed ||
        NULL == (FaxSendItem->FileName = StringDup(lpJobQueue->FileName)))
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("[JobId: %ld] CreateTiffFileForJob or StringDup failed"),
               FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
               GetLastError());
        //
        // Simulate an FSP returning a FS_FATAL_ERROR code.
        //
        EnterCriticalSection(&g_CsJob);
        FreeFSPIJobStatus(&FaxSendItem->JobEntry->FSPIJobStatus, FALSE);
        FaxSendItem->JobEntry->FSPIJobStatus.dwJobStatus = FSPI_JS_FAILED;
        FaxSendItem->JobEntry->FSPIJobStatus.dwExtendedStatus = FSPI_ES_FATAL_ERROR;

        if (!HandleFailedSendJob(FaxSendItem->JobEntry))
        {
           DebugPrintEx(
               DEBUG_ERR,
               TEXT("[JobId: %ld] HandleFailedSendJob() failed (ec: %ld)."),
               FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
               GetLastError());
        }
        LeaveCriticalSection(&g_CsJob);
        goto Exit;
    }
    FaxSend.FileName = FaxSendItem->FileName;

    //
    // Add branding banner (the line at the top of each page) to the fax if necessary.
    //
    EnterCriticalSection (&g_CsConfig);
    bBranding = g_fFaxUseBranding;
    LeaveCriticalSection (&g_CsConfig);

    if (bBranding)
    {
        FSPI_BRAND_INFO brandInfo;
        HRESULT hr;
        memset(&brandInfo,0,sizeof(FSPI_BRAND_INFO));
        brandInfo.dwSizeOfStruct=sizeof(FSPI_BRAND_INFO);
        brandInfo.lptstrRecipientPhoneNumber =  FaxSendItem->JobEntry->lpJobQueueEntry->RecipientProfile.lptstrFaxNumber;
        brandInfo.lptstrSenderCompany = FaxSendItem->SenderCompany;
        brandInfo.lptstrSenderTsid = FaxSendItem->Tsid;
        GetLocalTime( &brandInfo.tmDateTime); // can't fail
        hr = FaxBrandDocument(FaxSendItem->FileName,&brandInfo);
        if (FAILED(hr))
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] FaxBrandDocument() failed. (hr: 0x%08X)"),
                lpJobQueue->JobId,
                hr);
            //
            // But we go on since it is better to send the fax without the branding
            // then lose it altogether.
            //
        }
    }

    if (!HandoffJob)
    {
        FaxSendItem->JobEntry->LineInfo->State = FPS_INITIALIZING;
    }
    else
    {
        DWORD dwWaitRes;
        //
        // We need to wait for TapiWorkerThread to get an
        // existing CallHandle and put it in the lineinfo structure.
        //

        //
        // hCallHandleEvent will be signaled by the TAPI thread when the ownership of the call
        // is handoffed to the fax service application.
        //
        Assert (FaxSendItem->JobEntry->hCallHandleEvent);
        dwWaitRes = WaitForSingleObject(FaxSendItem->JobEntry->hCallHandleEvent, 1000 * 60 * 10);  // Wait for 10 minutes
        if (WAIT_OBJECT_0 != dwWaitRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] WaitForSingleObject failed (result = %ld) (ec: %ld).  Handoff failed."),
                lpJobQueue->JobId,
                dwWaitRes,
                GetLastError());
            //
            // Set the call handle to ZERO to indicate handoff failure.
            //
            FaxSendItem->JobEntry->LineInfo->HandoffCallHandle = 0;
        }

        if (!FaxSendItem->JobEntry->LineInfo->HandoffCallHandle)
        {
            //
            // No call handle was set after handoff.
            // Somehow the call handoff failed, we can't send the fax
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] LineInfo->HandoffCallHandle is 0. Handoff failed. Aborting job."),
                lpJobQueue->JobId);
            if ((FaxSendItem->JobEntry->LineInfo->Provider->dwAPIVersion < FSPI_API_VERSION_2) ||
                (FaxSendItem->JobEntry->LineInfo->Provider->dwCapabilities & FSPI_CAP_ABORT_RECIPIENT)
               )
            {
                //
                // Either this is an FSP (Always supports FaxDevAbortOperation) or its an
                // EFSP that has FSPI_CAP_ABORT_RECIPIENT capabilities.
                //
                FaxSendItem->JobEntry->LineInfo->State = FPS_ABORTING;
                __try
                {

                    Rslt = FaxSendItem->JobEntry->LineInfo->Provider->FaxDevAbortOperation(
                            (HANDLE) FaxSendItem->JobEntry->InstanceData);
                    //
                    // Note that FaxDevSend will still be called.
                    // We expect the FSP to fail it send if the job was already aborted.
                    // The FSP is also expected to report FS_USER_ABORT via
                    // FaxDevReport status after FaxDevAbortOperation was called (no matter
                    // if FaxDevSend was called after it or not).
                    //
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    Rslt = FALSE;
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("[JobId: %ld] FaxDevAbortOperation * CRASHED * (exception code: 0x%08x)"),
                        lpJobQueue->JobId,
                        GetExceptionCode());
                }
            }
            else
            {
                //
                // This is an EFSP that does not support aborting of jobs.
                //
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("[JobId: %ld] FaxDevAbortOperation is not available on this EFSP"),
                    lpJobQueue->JobId);
            }
        }
        else
        {
            //
            // Set the call handle, we're ready to send the fax
            //
            FaxSend.CallHandle = FaxSendItem->JobEntry->LineInfo->HandoffCallHandle;
            FaxSendItem->JobEntry->LineInfo->State = FPS_INITIALIZING;

            DebugPrintEx(
                DEBUG_MSG,
                TEXT("[JobId: %ld] Handoff call handle set (0x%08X). Ready to start handoff job."),
                lpJobQueue->JobId,
                FaxSend.CallHandle
                );
        }
    }

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("[JobId: %ld] Calling FaxDevSend().\n\t File: %s\n\tNumber [%s]\n\thLine = 0x%08X\n\tCallHandle = 0x%08X"),
        lpJobQueue->JobId,
        FaxSend.FileName,
        FaxSendItem->JobEntry->DialablePhoneNumber,
        FaxSendItem->JobEntry->LineInfo->hLine,
        FaxSend.CallHandle
        );
    __try
    {

        //
        // Send the fax (This call is blocking)
        //
        Rslt = FaxSendItem->JobEntry->LineInfo->Provider->FaxDevSend(
            (HANDLE) FaxSendItem->JobEntry->InstanceData,
            &FaxSend,
            FaxSendCallback
            );
        if (!Rslt)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] FaxDevSend() failed (ec: 0x%0X)"),
                lpJobQueue->JobId,
                GetLastError());
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Rslt = FALSE;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] FaxDevSend() * CRASHED * with exception code 0x%08X"),
            lpJobQueue->JobId,
            GetExceptionCode());
    }
    //
    // Get the final status of the job.
    //
    dwSttRes = GetDevStatus((HANDLE) FaxSendItem->JobEntry->InstanceData,
                                  FaxSendItem->JobEntry->LineInfo,
                                  &lpFSPStatus);

    if (ERROR_SUCCESS != dwSttRes)
    {
        //
        // Couldn't retrieve device status.
        // Fake one.
        //
        bFakeJobStatus = TRUE;
        DebugPrintEx(DEBUG_ERR,
                     TEXT("[Job: %ld] GetDevStatus failed - %d"),
                     FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
                     dwSttRes);
    }
    else if ((FSPI_JS_COMPLETED       != lpFSPStatus->dwJobStatus) &&
             (FSPI_JS_ABORTED         != lpFSPStatus->dwJobStatus) &&
             (FSPI_JS_FAILED          != lpFSPStatus->dwJobStatus) &&
             (FSPI_JS_DELETED         != lpFSPStatus->dwJobStatus) &&
             (FSPI_JS_SYSTEM_ABORT    != lpFSPStatus->dwJobStatus) &&
             (FSPI_JS_FAILED_NO_RETRY != lpFSPStatus->dwJobStatus))
    {
        //
        // Status returned is unacceptable - fake one.
        //
        bFakeJobStatus = TRUE;
        DebugPrintEx(DEBUG_WRN,
                     TEXT("[Job: %ld] GetDevStatus return unacceptable status - %d. Faking the status"),
                     FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
                     lpFSPStatus->dwJobStatus);
        MemFree (lpFSPStatus);
        lpFSPStatus = NULL;
    }

    //
    // Enter critical section to block out FaxStatusThread
    //
    EnterCriticalSection( &g_CsJob );

    if (bFakeJobStatus)
    {
        //
        // Fake a job status
        //
        lpFSPStatus = &FakedJobStatus;
        FakedJobStatus.dwSizeOfStruct = sizeof (FakedJobStatus);
        if (Rslt)
        {
            //
            // Fake success
            //
            FakedJobStatus.dwJobStatus = FSPI_JS_COMPLETED;
            FakedJobStatus.dwExtendedStatus = 0;
        }
        else
        {
            //
            // Fake failure
            //
            FakedJobStatus.dwJobStatus = FSPI_JS_FAILED;
            FakedJobStatus.dwExtendedStatus = FSPI_ES_FATAL_ERROR;
        }
    }
    if (!UpdateJobStatus(FaxSendItem->JobEntry, lpFSPStatus, FALSE)) // FALSE - Do not send event to the clients.
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] UpdateJobStatus() failed (ec: %ld)."),
            FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
            GetLastError());
        //
        // Fake a status (we must have some valid status in job entry)
        //
        FreeFSPIJobStatus(&FaxSendItem->JobEntry->FSPIJobStatus, FALSE);
        if (Rslt)
        {
            FaxSendItem->JobEntry->FSPIJobStatus.dwJobStatus = FSPI_JS_COMPLETED;
            FaxSendItem->JobEntry->FSPIJobStatus.dwExtendedStatus = 0;
        }
        else
        {
            FaxSendItem->JobEntry->FSPIJobStatus.dwJobStatus = FSPI_JS_FAILED;
            FaxSendItem->JobEntry->FSPIJobStatus.dwExtendedStatus = FSPI_ES_FATAL_ERROR;
        }
    }
    if (!bFakeJobStatus)
    {
        //
        // Note: The FSPI_JOB_STATUS that is returned by GetDevStatus() is
        // to be freed as one block.
        //
        MemFree(lpFSPStatus);
        lpFSPStatus = NULL;
    }
    else
    {
        //
        // This is a faked job status - pointing to a structure on the stack.
        //
    }

    //
    // Block FaxStatusThread from changing this status
    //
    FaxSendItem->JobEntry->fStopUpdateStatus = TRUE;
    LeaveCriticalSection( &g_CsJob );

    if (!Rslt)
    {
        if (!HandleFailedSendJob(FaxSendItem->JobEntry))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] HandleFailedSendJob() failed (ec: %ld)."),
                FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
                GetLastError());
        }
    }
    else
    {
        //
        // cache the job id since we need id to create the FEI_COMPLETED event
        // and when it is generated the job may alrady be gone
        //
        dwJobId = FaxSendItem->JobEntry->lpJobQueueEntry->JobId;

        if (!HandleCompletedSendJob(FaxSendItem->JobEntry))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] HandleCompletedSendJob() failed (ec: %ld)."),
                FaxSendItem->JobEntry->lpJobQueueEntry->JobId,
                GetLastError());
        }
        //
        // The send job is completed. For W2K backward compatibility we should notify
        // FEI_DELETED since the job was allways removed when completed.
        //
        if (!CreateFaxEvent(0, FEI_DELETED, dwJobId))
        {

            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFaxEvent() failed. Event: 0x%08X JobId: %ld DeviceId:  (ec: %ld)"),
                FEI_DELETED,
                dwJobId,
                0,
                GetLastError());
        }
    }

Exit:

    MemFree( FaxSendItem->FileName );
    MemFree( FaxSendItem->PhoneNumber );
    MemFree( FaxSendItem->Tsid );
    MemFree( FaxSendItem->RecipientName );
    MemFree( FaxSendItem->SenderName );
    MemFree( FaxSendItem->SenderDept );
    MemFree( FaxSendItem->SenderCompany );
    MemFree( FaxSendItem->BillingCode );
    MemFree( FaxSendItem->DocumentName );
    MemFree( FaxSendItem );

    //
    // Let the system go back to sleep. Set the system idle timer.
    //
    if (TRUE == fSetSystemIdleTimer)
    {
        if (NULL == SetThreadExecutionState(ES_CONTINUOUS))
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("SetThreadExecutionState() failed"));
        }
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return 0;
}


//*********************************************************************************
//* Name:   IsSendJobReadyForDeleting()
//* Author: Ronen Barenboim
//* Date:   April 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Determines if an outgoing job is ready for deleting.
//*     A job is ready for deleting when all of the recipients
//*     are in the canceled state or or in the completed state.
//* PARAMETERS:
//*     [IN] PJOB_QUEUE lpRecipientJob
//*
//* RETURN VALUE:
//*     TRUE
//*         If the job is ready for deleting.
//*     FALSE
//*         If the job is not ready for deleting.
//*********************************************************************************
BOOL IsSendJobReadyForDeleting(PJOB_QUEUE lpRecipientJob)
{
    DEBUG_FUNCTION_NAME(TEXT("IsSendJobReadyForDeleting"));
    Assert (lpRecipientJob);
    Assert (lpRecipientJob->JobType == JT_SEND);

    PJOB_QUEUE lpParentJob = lpRecipientJob->lpParentJob;
    Assert(lpParentJob); // must have a parent job
    Assert(lpParentJob->dwRecipientJobsCount>0);
    Assert(lpParentJob->dwCompletedRecipientJobsCount +
           lpParentJob->dwCanceledRecipientJobsCount +
           lpParentJob->dwFailedRecipientJobsCount
           <= lpParentJob->dwRecipientJobsCount);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("[JobId: %ld] [Total Rec = %ld] [Canceled Rec = %ld] [Completed Rec = %ld] [Failed Rec = %ld] [RefCount = %ld]"),
        lpParentJob->JobId,
        lpParentJob->dwRecipientJobsCount,
        lpParentJob->dwCanceledRecipientJobsCount,
        lpParentJob->dwCompletedRecipientJobsCount,
        lpParentJob->dwFailedRecipientJobsCount,
        lpParentJob->RefCount);


    if ( (lpParentJob->dwCompletedRecipientJobsCount +
          lpParentJob->dwCanceledRecipientJobsCount  +
          lpParentJob->dwFailedRecipientJobsCount) == lpParentJob->dwRecipientJobsCount )
    {
        return TRUE;
    }
    return FALSE;
}


BOOL FreeJobEntry(PJOB_ENTRY lpJobEntry , BOOL bDestroy)
{
    DEBUG_FUNCTION_NAME(TEXT("FreeJobEntry"));
    Assert(lpJobEntry);
    DWORD ec = ERROR_SUCCESS;
    DWORD dwJobID = lpJobEntry->lpJobQueueEntry ? lpJobEntry->lpJobQueueEntry->JobId : 0xffffffff; // 0xffffffff for invalid job ID

    EnterCriticalSection(&g_CsJob);

    //
    // Remove the job from the EFSPJobGroup it is in.
    //
    if (lpJobEntry->lpJobQueueEntry && lpJobEntry->lpJobQueueEntry->lpEFSPJobGroup)
    {
        if (!EFSPJobGroup_RemoveRecipient(
                lpJobEntry->lpJobQueueEntry->lpEFSPJobGroup,
                lpJobEntry->lpJobQueueEntry,
                TRUE        // Commit to file
                ))
        {
            DebugPrintEx( DEBUG_MSG,
                      TEXT("[Job Id: %ld] EFSPJobGroup_RemoveRecipient() failed (ec: %ld)"),
                      dwJobID,
                      GetLastError()
                      );
            ASSERT_FALSE;
        }
    }
    //
    // Since CreateJobEntry() called OpenTapiLine() for TAPI lines
    // we need to close it here.
    // Note that the line might alrady be released since ReleaseJob()
    // releases the line but does not free the job entry.
    //
    if (!lpJobEntry->Released)
    {
        if (lpJobEntry->LineInfo->State != FPS_NOT_FAX_CALL) {
            DebugPrintEx( DEBUG_MSG,
                      TEXT("[Job Id: %ld] Before Releasing tapi line hCall=0x%08X hLine=0x%08X"),
                      dwJobID,
                      lpJobEntry->CallHandle,
                      lpJobEntry->LineInfo->hLine
                      );

            ReleaseTapiLine( lpJobEntry->LineInfo, lpJobEntry->CallHandle );
            lpJobEntry->CallHandle = 0;
            lpJobEntry->Released = TRUE;
        }
    }

    //
    // Remove the job from the running job list
    //
    RemoveEntryList( &lpJobEntry->ListEntry );

    if (lpJobEntry->hCallHandleEvent )
    {
        if (!CloseHandle(lpJobEntry->hCallHandleEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle( JobEntry->hCallHandleEvent ) failed. (ec: %ld)"),
                GetLastError());
            Assert(FALSE);
        }
    }

    //
    // Cut the link between the line and the job
    //
    EnterCriticalSection( &g_CsLine );
    lpJobEntry->LineInfo->JobEntry = NULL;
    LeaveCriticalSection( &g_CsLine );


    //
    // Remove the FSP job from the jobs map.
    //
    ec = RemoveFspJob(lpJobEntry->LineInfo->Provider->hJobMap,
                              (HANDLE)lpJobEntry->InstanceData);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[Job Id: %ld] RemoveFspJob() failed (ec: %ld)"),
            dwJobID,
            ec);
        Assert(FALSE);
    }

    if (!FreeFSPIJobStatus(&lpJobEntry->FSPIJobStatus, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[Job Id: %ld] FreeFSPIJobStatus() failed (ec: %ld)"),
            dwJobID,
            GetLastError);
    }
    if (lpJobEntry->lpJobQueueEntry &&
        !FreePermanentMessageId(&lpJobEntry->lpJobQueueEntry->EFSPPermanentMessageId, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[Job Id: %ld] FreePermanentMessageId() failed (ec: %ld)"),
            dwJobID,
            GetLastError);
    }

    MemFree(lpJobEntry->lpwstrJobTsid);
    lpJobEntry->lpwstrJobTsid = NULL;

    if (bDestroy)
    {
        MemFree(lpJobEntry);
    }

    LeaveCriticalSection(&g_CsJob);

    return TRUE;
}


BOOL
EndJob(
    IN PJOB_ENTRY JobEntry
    )

/*++

Routine Description:

    This fuction calls the device provider's EndJob function.

Arguments:

    None.

Return Value:

    Error code.

--*/

{
    BOOL rVal = TRUE;
    PJOB_INFO_1 JobInfo = NULL;
    DEBUG_FUNCTION_NAME(TEXT("End Job"));
    Assert(JobEntry);
    DWORD dwJobID = JobEntry->lpJobQueueEntry ? JobEntry->lpJobQueueEntry->JobId : 0xffffffff; // 0xffffffff for invalid job ID


    EnterCriticalSection( &g_CsJob );

    if (!FindJobByJob( JobEntry ))
    {
        //
        // if we get here then it means we hit a race
        // condition where the FaxSendThread called EndJob
        // at the same time that a client app did.
        //
        DebugPrintEx(DEBUG_WRN,TEXT("EndJob() could not find the Job"), dwJobID);
        LeaveCriticalSection( &g_CsJob );
        return ERROR_SUCCESS;
    }


    if (JobEntry->bFSPJobInProgress)
    {
        //
        // If FaxDevEndJob was not yet called for the job then do it now.
        // ( The case in which the line is already released occcurs in a
        //   receive job where we first ReleaseJob() to release the line but
        //   continue to do the inbound routing and only then call EndJob()).
        //

        __try
        {
            DebugPrintEx( DEBUG_MSG,
                          TEXT("[Job Id: %ld] Legacy FSP job is in progress. Calling FaxDevEndJob()"),
                          dwJobID);

            rVal = JobEntry->LineInfo->Provider->FaxDevEndJob(
                (HANDLE) JobEntry->InstanceData
                );
            if (!rVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("[Job Id: %ld] FaxDevEndJob() failed"),
                    dwJobID);
            }
            else
            {
                DebugPrintEx( DEBUG_MSG,
                          TEXT("[Job Id: %ld] FaxDevEndJob() succeeded."),
                          dwJobID);
                JobEntry->bFSPJobInProgress = FALSE;
            }


        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            rVal = FALSE;
            DebugPrintEx( DEBUG_MSG,
                        TEXT("[Job Id: %ld] FaxDevEndJob() crashed, ec=0x%08x"),
                        dwJobID,
                        GetExceptionCode());

        }

    }
    else
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job Id: %ld] FaxDevEndJob() NOT CALLED since legacy FSP job is not in progress."),
            dwJobID);
    }


    if (FreeJobEntry(JobEntry, TRUE))
    {
        JobEntry = NULL;
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to free a job entry (%x)."),
            JobEntry);
        ASSERT_FALSE;
    }

    //
    // There could have been a request to change the port status while we were handling this job.
    // We allow the caller to modify a few of these requests to succeed, like the ring count for instance.
    // While we still have the job critical section, let's make sure that we commit any requested changes to the
    // registry.  This should be a fairly quick operation.
    //

    LeaveCriticalSection( &g_CsJob );


    return rVal;
}

//*********************************************************************************
//* Name:   ReleaseJob()
//* Author: Ronen Barenboim
//* Date:   April 18, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Calls the FSP to end the specified job (FaxDevEndJob()).
//*     Releases the line that was assigned to the job.
//*     NOTE: The job itself is NOT DELETED and is NOT remvoed from the running
//*           job list !!!
//*
//* PARAMETERS:
//*     [IN/OUT]    PJOB_ENTRY JobEntry
//*         A pointer to the JOB_ENTRY to be ended.
//* RETURN VALUE:
//* REMARKS:
//* If the function is successful then:
//*     JobEntry->Released = TRUE
//*     JobEntry->hLine = 0
//*     JobEntry->CallHandle = 0
//*********************************************************************************
BOOL
ReleaseJob(
    IN PJOB_ENTRY JobEntry
    )
{
    BOOL rVal = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("ReleaseJob"));
    Assert(JobEntry);
    Assert(JobEntry->lpJobQueueEntry);

    if (!FindJobByJob( JobEntry )) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("[JobId: %ld] was not found in the running job list."),
            JobEntry->lpJobQueueEntry->JobId);
        return TRUE;
    }

    EnterCriticalSection( &g_CsJob );

    Assert(JobEntry->LineInfo);
    Assert(JobEntry->LineInfo->Provider);
    Assert(JobEntry->bFSPJobInProgress);

    __try {

        rVal = JobEntry->LineInfo->Provider->FaxDevEndJob(
            (HANDLE) JobEntry->InstanceData
            );
        if (!rVal) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] FaxDevEndJob() failed (ec: 0x%0X)"),
                JobEntry->lpJobQueueEntry->JobId,
                GetLastError());
        }
        else
        {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("[Job Id: %ld] FaxDevEndJob() succeeded."),
                JobEntry->lpJobQueueEntry->JobId);
            JobEntry->bFSPJobInProgress = FALSE;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] FaxDevEndJob() crashed, ec=0x%08x"),
            JobEntry->lpJobQueueEntry->JobId,
            GetExceptionCode() );

        rVal = FALSE;
    }

    if (JobEntry->LineInfo->State != FPS_NOT_FAX_CALL)
    {
        if( !ReleaseTapiLine( JobEntry->LineInfo, JobEntry->CallHandle ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReleaseTapiLine() failed "));
        }
        JobEntry->CallHandle = 0;
    }
    else
    {
        //
        // FSP_NOT_FAX_CALL indicates a received call that was handed off to RAS.
        // In this case we do not want to mark the line as released since it is in
        // use by RAS. We will use TAPI evens that indicate the line was released to update
        // the line info.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId: %ld] A call is being handed off to RAS. Line 0x%08X not marked as released."),
            JobEntry->lpJobQueueEntry->JobId,
            JobEntry->LineInfo->hLine);
    }

    JobEntry->Released = TRUE;
    //
    // Cut the link between the line and the job
    //
    EnterCriticalSection( &g_CsLine );
    JobEntry->LineInfo->JobEntry = NULL;
    LeaveCriticalSection( &g_CsLine );

    LeaveCriticalSection( &g_CsJob );

    return rVal;
}



//*********************************************************************************
//* Name:   SendDocument()
//* Author: Ronen Barenboim
//* Date:   March 21, 1999
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*     lpJobEntry
//*         A pointer to a JOB_ENTRY structure that was created using StartJob().
//*     FileName
//*         The path to the TIFF containing the TIFF to send
//*
//* RETURN VALUE:
//*
//*********************************************************************************
DWORD
SendDocument(
    PJOB_ENTRY  lpJobEntry,
    LPTSTR      FileName
    )
{
    PFAX_SEND_ITEM FaxSendItem;
    DWORD ThreadId;
    HANDLE hThread;
    PJOB_QUEUE lpJobQueue;
    DWORD nRes;
    DWORD ec = ERROR_SUCCESS;
    BOOL bUseDeviceTsid;
    WCHAR       wcZero = L'\0';

    STRING_PAIR pairs[8];

    DEBUG_FUNCTION_NAME(TEXT("SendDocument"));

    Assert(lpJobEntry);

    lpJobQueue=lpJobEntry->lpJobQueueEntry;
    Assert(lpJobQueue &&
           JS_INPROGRESS == lpJobQueue->JobStatus);

    FaxSendItem = (PFAX_SEND_ITEM) MemAlloc(sizeof(FAX_SEND_ITEM));
    if (!FaxSendItem)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    //
    // Pack all the thread parameters into a FAX_SEND_ITEM structure.
    //
    pairs[0].lptstrSrc = lpJobEntry->DialablePhoneNumber; // Use the job entry phone number since it is alrady translated
    pairs[0].lpptstrDst = &FaxSendItem->PhoneNumber;
    pairs[1].lptstrSrc = lpJobQueue->RecipientProfile.lptstrName;
    pairs[1].lpptstrDst = &FaxSendItem->RecipientName;
    pairs[2].lptstrSrc = lpJobQueue->SenderProfile.lptstrName;
    pairs[2].lpptstrDst = &FaxSendItem->SenderName;
    pairs[3].lptstrSrc = lpJobQueue->SenderProfile.lptstrDepartment;
    pairs[3].lpptstrDst = &FaxSendItem->SenderDept;
    pairs[4].lptstrSrc = lpJobQueue->SenderProfile.lptstrCompany;
    pairs[4].lpptstrDst = &FaxSendItem->SenderCompany;
    pairs[5].lptstrSrc = lpJobQueue->SenderProfile.lptstrBillingCode;
    pairs[5].lpptstrDst = &FaxSendItem->BillingCode;
    pairs[6].lptstrSrc = lpJobQueue->JobParamsEx.lptstrDocumentName;
    pairs[6].lpptstrDst = &FaxSendItem->DocumentName;
    pairs[7].lptstrSrc = NULL;
    pairs[7].lpptstrDst = &FaxSendItem->Tsid;

    FaxSendItem->JobEntry = lpJobEntry;
    FaxSendItem->FileName = NULL; // Set by FaxSendThread

    EnterCriticalSection (&g_CsConfig);
    bUseDeviceTsid = g_fFaxUseDeviceTsid;
    LeaveCriticalSection (&g_CsConfig);

    if (!bUseDeviceTsid)
    {
    // Check Sender Tsid
        if  ( lpJobQueue->SenderProfile.lptstrTSID &&
            (lpJobQueue->SenderProfile.lptstrTSID[0] != wcZero))
        {
           pairs[7].lptstrSrc        = lpJobQueue->SenderProfile.lptstrTSID;
        }
        else
        {
        // Use Fax number
            if  ( lpJobQueue->SenderProfile.lptstrFaxNumber &&
                (lpJobQueue->SenderProfile.lptstrFaxNumber[0] != wcZero))
            {
                pairs[7].lptstrSrc      = lpJobQueue->SenderProfile.lptstrFaxNumber;
            }
        }
    }
    else
    {
        // Use device Tsid
        pairs[7].lptstrSrc     = lpJobEntry->LineInfo->Tsid;
    }

    nRes=MultiStringDup(pairs, sizeof(pairs)/sizeof(STRING_PAIR));
    if (nRes!=0) {
        DWORD ec=GetLastError();
        // MultiStringDup takes care of freeing the memory for the pairs for which the copy succeeded
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MultiStringDup failed to copy string with index %d. (ec: %ld)"),
            nRes-1,
            ec);
        goto Error;
    }

    EnterCriticalSection (&g_CsJob);
    lpJobEntry->lpwstrJobTsid = StringDup (FaxSendItem->Tsid);
    LeaveCriticalSection (&g_CsJob);
    if (NULL != FaxSendItem->Tsid && NULL == lpJobEntry->lpwstrJobTsid)
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("StringDup failed (ec: 0x%0X)"),ec);
        goto Error;
    }

    hThread = CreateThreadAndRefCount(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) FaxSendThread,
        (LPVOID) FaxSendItem,
        0,
        &ThreadId
        );

    if (!hThread)
    {
        ec=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("CreateThreadAndRefCount for FaxSendThread failed (ec: 0x%0X)"),ec);
        goto Error;
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,TEXT("FaxSendThread thread created for job id %d (thread id: 0x%0x)"),lpJobQueue->JobId,ThreadId);
    }

    CloseHandle( hThread );

    Assert (ERROR_SUCCESS == ec);
    goto Exit;

Error:
    Assert (ERROR_SUCCESS != ec);

    if ( FaxSendItem )
    {
        MemFree( FaxSendItem->FileName );
        MemFree( FaxSendItem->PhoneNumber );
        MemFree( FaxSendItem->Tsid );
        MemFree( FaxSendItem->RecipientName );
        MemFree( FaxSendItem->SenderName );
        MemFree( FaxSendItem->SenderDept );
        MemFree( FaxSendItem->SenderCompany );
        MemFree( FaxSendItem->BillingCode );
        MemFree( FaxSendItem->DocumentName );
        MemFree( FaxSendItem );
    }

    if (0 == lpJobQueue->dwLastJobExtendedStatus)
    {
        //
        // Job was never really executed - this is a fatal error
        //
        lpJobQueue->dwLastJobExtendedStatus = FSPI_ES_FATAL_ERROR;
    }
    if (!MarkJobAsExpired(lpJobQueue))
    {
        DEBUG_ERR,
        TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
        lpJobQueue->JobId,
        GetLastError();
    }


    EndJob(lpJobEntry);
    lpJobQueue->JobEntry = NULL;

Exit:
     return ec;

}


DWORD
FaxStatusThread(
    LPVOID UnUsed
    )

/*++

Routine Description:

    This fuction runs asychronously as a separate thread to
    query the status of all outstanding fax jobs.  The status
    is updated in the JOB_ENTRY structure and the print job
    is updated with a explanitory string.

Arguments:

    UnUsed          - UnUsed pointer

Return Value:

    Always zero.

--*/

{
    PJOB_ENTRY JobEntry;
    PFAX_DEV_STATUS FaxStatus;
    BOOL Rval;
    DWORD Bytes;
    ULONG_PTR CompletionKey;
    DWORD dwEventId;

    DEBUG_FUNCTION_NAME(TEXT("FaxStatusThread"));

    while( TRUE )
    {
        Rval = GetQueuedCompletionStatus(
            g_StatusCompletionPortHandle,
            &Bytes,
            &CompletionKey,
            (LPOVERLAPPED*) &FaxStatus,
            INFINITE
            );
        if (!Rval)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("GetQueuedCompletionStatus() failed, ec=0x%08x"), GetLastError() );
            continue;
        }

        if (SERVICE_SHUT_DOWN_KEY == CompletionKey)
        {
            //
            // Service is shutting down
            //
            DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Service is shutting down"));
            //
            //  Notify all FaxStatusThreads to terminate
            //
            if (!PostQueuedCompletionStatus( g_StatusCompletionPortHandle,
                                             0,
                                             SERVICE_SHUT_DOWN_KEY,
                                             (LPOVERLAPPED) NULL))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - FaxStatusThread). (ec: %ld)"),
                    GetLastError());
            }
            break;
        }

        if (CompletionKey == FSPI_JOB_STATUS_MSG_KEY)
        {
            //
            // This is FSPI_JOB_STATUS message posted by FaxDeviceProviderCallbackEx()
            //
            ASSERT_FALSE; // We dont support EFSP

            LPFSPI_JOB_STATUS_MSG lpJobStatusMsg;
            lpJobStatusMsg = (LPFSPI_JOB_STATUS_MSG)FaxStatus;
            if (!HandleFSPIJobStatusMessage(lpJobStatusMsg))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("HandleFSPIJobStatusMessage() failed (ec: %ld)"),
                    GetLastError());
            }
            FreeFSPIJobStatusMsg(lpJobStatusMsg, TRUE);
            continue;
        }


        if (CompletionKey == EVENT_COMPLETION_KEY)
        {
            //
            // The event was submitted using CreateFaxEvent this is an event on which we need
            // to notify to all our registered RPC clients. The overlapped data (FaxStatus) points to
            // a FAX_EVENT structure and NOT to FAX_STATUS structure.
            //
            // Let each registered client know about the fax event
            //
            PLIST_ENTRY Next;
            PFAX_CLIENT_DATA ClientData;
            PFAX_EVENT FaxEvent = (PFAX_EVENT) FaxStatus;

            EnterCriticalSection( &g_CsClients );

            Next = g_ClientsListHead.Flink;
            if (Next)
            {
                while ((ULONG_PTR)Next != (ULONG_PTR)&g_ClientsListHead)
                {
                    DWORD i;

                    ClientData = CONTAINING_RECORD( Next, FAX_CLIENT_DATA, ListEntry );
                    DebugPrintEx(DEBUG_MSG,TEXT("%d: Current : %08x\t Handle : %08x\t Next : %08x  Head: %08x : "),
                               GetTickCount(),
                               (ULONG_PTR)Next,
                               ClientData->FaxClientHandle,
                               (ULONG_PTR)ClientData->ListEntry.Flink,
                               (ULONG_PTR)&g_ClientsListHead );
                    Next = ClientData->ListEntry.Flink;

                    //
                    // only send the started message once to each client
                    //
                    if ((FaxEvent->EventId == FEI_FAXSVC_STARTED) && ClientData->StartedMsg)
                    {
                        continue; // next client
                    }

                    Assert (ClientData->FaxClientHandle);
                    for(i = 0; i < 10; i++)
                    {
                        __try
                        {
                            Rval = FAX_ClientEventQueue( ClientData->FaxClientHandle, *FaxEvent );
                            if (Rval)
                            {
                                DebugPrintEx(DEBUG_WRN, TEXT("FAX_ClientEventQueue() failed, ec=0x%08x"), Rval );
                                continue;
                            }
                            else
                            {
                                ClientData->StartedMsg = (FaxEvent->EventId == FEI_FAXSVC_STARTED) ?
                                                         TRUE :
                                                         ClientData->StartedMsg;
                                break;
                            }
                        }

                        __except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            DebugPrintEx(DEBUG_ERR, TEXT("FAX_ClientEventQueue() crashed: 0x%08x"), GetExceptionCode() );
                        }

                        Sleep( 1000 );

                    }
                } // end while
            }

            LeaveCriticalSection( &g_CsClients );

            MemFree( FaxEvent );
            FaxStatus = NULL;

            continue;
        }

        //
        // (else we're dealing with a status update from an FSP)
        //

        BOOL fBadComletionKey = TRUE;
        PLINE_INFO pLineInfo = (PLINE_INFO)CompletionKey;

        __try
        {
            fBadComletionKey = pLineInfo->Signature != LINE_SIGNATURE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // Do nothing, fBadComletionKey is already set to TRUE.
            //
            DebugPrintEx(DEBUG_WRN,
                         TEXT("Exception occured while referencing the ")
                         TEXT("completion key as a pointer to a LINE_INFO ")
                         TEXT("structure. Exception = 0x%08x"),
                         GetExceptionCode());
        }

        if (fBadComletionKey)
        {
            DebugPrintEx(DEBUG_WRN,
                         TEXT("Bad completion key: 0x%08x"),
                         CompletionKey);
            continue;
        }

        BOOL fBadFaxStatus = TRUE;

        __try
        {
            fBadFaxStatus = FaxStatus->SizeOfStruct != sizeof(FAX_DEV_STATUS);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // Do nothing, fBadFaxStatus is already set to TRUE.
            //
            DebugPrintEx(DEBUG_WRN,
                         TEXT("Exception occured while referencing ")
                         TEXT("FAX_DEV_STATUS. Exception = 0x%08x"),
                         GetExceptionCode());
        }

        if (fBadFaxStatus)
        {
            DebugPrintEx(DEBUG_WRN,
                         TEXT("Bad FAX_DEV_STATUS: 0x%08x"),
                         FaxStatus);
            continue;
        }

        EnterCriticalSection( &g_CsJob );
        JobEntry = pLineInfo->JobEntry;
        if (!JobEntry)
        {
            //
            // The FSP reported a status on a LineInfo for which the running
            // job no longer exists.
            //
            //
            // Free the completion packet memory
            //
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("Provider [%s] reported a status packet that was processed after the job entry was already released.\n")
                TEXT("StatusId : 0x%08x\n")
                TEXT("Line: %s\n")
                TEXT("Packet address: %p\n")
                TEXT("Heap: %p"),
                pLineInfo->Provider->ProviderName,
                FaxStatus->StatusId,
                pLineInfo->DeviceName,
                FaxStatus,
                pLineInfo->Provider->HeapHandle);

            if (!HeapFree(pLineInfo->Provider->HeapHandle, 0, FaxStatus ))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to free orphan device status (ec: %ld)"),
                    GetLastError());
                //
                // Nothing else we can do but report it in debug mode
                //
            }
            FaxStatus = NULL;
            LeaveCriticalSection( &g_CsJob );
            continue;
        }

        __try
        {
                /*
                        *****
                        NTRAID#EdgeBugs-12680-2001/05/14-t-nicali

                               What if in the meantime another job is executing on the
                               same line. In this case ->JobEntry will point to ANOTHER job !!!
                               The solution should be to provide as a completion key the
                               JobEntry and not the LineInfo !!!

                        *****
                */
            Assert (JobEntry->lpJobQueueEntry);

            if (TRUE == JobEntry->fStopUpdateStatus)
            {
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("JobId: %ld. fStopUpdateStatus was set. Not updating status"),
                    JobEntry->lpJobQueueEntry->JobId,
                    JobEntry->lpJobQueueEntry->JobStatus);

                if (!HeapFree(pLineInfo->Provider->HeapHandle, 0, FaxStatus ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to free orphan device status (ec: %ld)"),
                        GetLastError());
                    //
                    // Nothing else we can do but report it in debug mode
                    //
                }
                FaxStatus = NULL;
                LeaveCriticalSection (&g_CsJob);
                continue;
            }

            FreeFSPIJobStatus(&JobEntry->FSPIJobStatus, FALSE);
            memset(&JobEntry->FSPIJobStatus, 0, sizeof(FSPI_JOB_STATUS));
            JobEntry->FSPIJobStatus.dwSizeOfStruct  = sizeof(FSPI_JOB_STATUS);

            //
            // This is done for backward compatability with W2K Fax API.
            // GetJobData() and FAX_GetDeviceStatus() will use this value to return
            // the job status for legacy jobs.
            //
            JobEntry->LineInfo->State = FaxStatus->StatusId;

            BOOL bPrivateStatusCode;

            LegacyJobStatusToStatus(
                FaxStatus->StatusId,
                &JobEntry->FSPIJobStatus.dwJobStatus,
                &JobEntry->FSPIJobStatus.dwExtendedStatus,
                &bPrivateStatusCode);

            if (bPrivateStatusCode)
            {
                JobEntry->FSPIJobStatus.fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE;
            }


            JobEntry->FSPIJobStatus.dwExtendedStatusStringId = FaxStatus->StringId;

            JobEntry->FSPIJobStatus.dwPageCount = FaxStatus->PageCount;
            JobEntry->FSPIJobStatus.fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_PAGECOUNT;

            if (FaxStatus->CSI)
            {
                JobEntry->FSPIJobStatus.lpwstrRemoteStationId = StringDup( FaxStatus->CSI );
                if (!JobEntry->FSPIJobStatus.lpwstrRemoteStationId  )
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup( FaxStatus->CSI ) failed (ec: %ld)"),
                        GetLastError());
                }
            }

            if (FaxStatus->CallerId)
            {
                JobEntry->FSPIJobStatus.lpwstrCallerId = StringDup( FaxStatus->CallerId );
                if (!JobEntry->FSPIJobStatus.lpwstrCallerId )
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup( FaxStatus.CallerId ) failed (ec: %ld)"),
                        GetLastError());
                }
            }

            if (FaxStatus->RoutingInfo)
            {
                JobEntry->FSPIJobStatus.lpwstrRoutingInfo = StringDup( FaxStatus->RoutingInfo );
                if (!JobEntry->FSPIJobStatus.lpwstrRoutingInfo  )
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup( FaxStatus.RoutingInfo ) failed (ec: %ld)"),
                        GetLastError());
                }
            }

            dwEventId = MapFSPIJobStatusToEventId(&JobEntry->FSPIJobStatus);
            //
            // Note: W2K Fax did issue notifications with EventId == 0 whenever an
            // FSP reported proprietry status code. To keep backward compatability
            // we keep up this behaviour although it might be regarded as a bug
            //

            if ( !CreateFaxEvent( JobEntry->LineInfo->PermanentLineID, dwEventId, JobEntry->lpJobQueueEntry->JobId ) )
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateFaxEvent failed. (ec: %ld)"),
                    GetLastError());
            }

            EnterCriticalSection (&g_CsQueue);
            DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                             JobEntry->lpJobQueueEntry
                                           );
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                    JobEntry->lpJobQueueEntry->UniqueId,
                    dwRes);
            }
            LeaveCriticalSection (&g_CsQueue);
            HeapFree( JobEntry->LineInfo->Provider->HeapHandle, 0, FaxStatus );
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            DebugPrintEx(DEBUG_WRN,
                         TEXT("An exception occured while processing a fax ")
                         TEXT("device status event. Exception = 0x%08x"),
                         GetExceptionCode());
        }
        LeaveCriticalSection( &g_CsJob );
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return 0;
}



BOOL
InitializeJobManager(
    PREG_FAX_SERVICE FaxReg
    )

/*++

Routine Description:

    This fuction initializes the thread pool and
    FAX service queues.

Arguments:

    ThreadHint  - Number of threads to create in the initial pool.

Return Value:

    Thread return value.

--*/

{

    BOOL bRet;

    DEBUG_FUNCTION_NAME(TEXT("InitializeJobManager"));

    if (!g_csEFSPJobGroups.InitializeAndSpinCount())
    {
        USES_DWORD_2_STR;
        DWORD ec = GetLastError();

        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
                DWORD2DECIMAL(ec)
               );

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxCriticalSection::InitializeAndSpinCount(&g_csEFSPJobGroups) failed: err = %d"),
            ec);
        return FALSE;
    }

    SetRetryValues( FaxReg ); // Can not fail.

    if (GetFileAttributes( g_wszFaxQueueDir ) == 0xffffffff) {
            DebugPrintEx(
            DEBUG_WRN,
            TEXT("Queue dir [%s] does not exist. Attempting to create."),
            g_wszFaxQueueDir);
        if (!MakeDirectory( g_wszFaxQueueDir )) {

             USES_DWORD_2_STR;
             DWORD ec = GetLastError();
             FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                2,
                MSG_FAX_QUEUE_DIR_CREATION_FAILED,
                g_wszFaxQueueDir,
                DWORD2DECIMAL(ec)
               );
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("MakeDirectory failed for Queue dir [%s] (ec: %ld)"),
                g_wszFaxQueueDir,
               ec);
            goto Error;
        }
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Queue dir [%s] created."),
            g_wszFaxQueueDir);
    }

    g_StatusCompletionPortHandle = CreateIoCompletionPort(
        INVALID_HANDLE_VALUE,
        NULL,
        0,
        MAX_STATUS_THREADS
        );
    if (!g_StatusCompletionPortHandle)
    {
        USES_DWORD_2_STR;
        DWORD ec = GetLastError();

        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
                DWORD2DECIMAL(ec)
               );
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to create StatusCompletionPort (ec: %ld)"), GetLastError() );
        goto Error;
    }


    bRet = TRUE;
    goto Exit;
Error:
    bRet = FALSE;
Exit:

    return bRet;
}

VOID
SetRetryValues(
    PREG_FAX_SERVICE FaxReg
    )
{
    Assert(FaxReg);
    DEBUG_FUNCTION_NAME(TEXT("SetRetryValues"));

    EnterCriticalSection (&g_CsConfig);

    g_dwFaxSendRetries          = FaxReg->Retries;
    g_dwFaxSendRetryDelay       = (INT) FaxReg->RetryDelay;
    g_dwFaxDirtyDays            = FaxReg->DirtyDays;
    g_dwNextJobId               = FaxReg->NextJobNumber;
    g_dwQueueState              = FaxReg->dwQueueState;
    g_fFaxUseDeviceTsid        = FaxReg->UseDeviceTsid;
    g_fFaxUseBranding          = FaxReg->Branding;
    g_fServerCp                = FaxReg->ServerCp;
    g_StartCheapTime          = FaxReg->StartCheapTime;
    g_StopCheapTime           = FaxReg->StopCheapTime;

    LeaveCriticalSection (&g_CsConfig);
    return;
}

LPTSTR
ExtractFaxTag(
    LPTSTR      pTagKeyword,
    LPTSTR      pTaggedStr,
    INT        *pcch
    )

/*++

Routine Description:

    Find the value of for the specified tag in a tagged string.

Arguments:

    pTagKeyword - specifies the interested tag keyword
    pTaggedStr - points to the tagged string to be searched
    pcch - returns the length of the specified tag value (if found)

Return Value:

    Points to the value for the specified tag.
    NULL if the specified tag is not found

NOTE:

    Tagged strings have the following form:
        <tag>value<tag>value

    The format of tags is defined as:
        <$FAXTAG$ tag-name>

    There is exactly one space between the tag keyword and the tag name.
    Characters in a tag are case-sensitive.

--*/

{
    LPTSTR  pValue;

    Assert(pTagKeyword);
    Assert(pTaggedStr);
    Assert(pcch);

    if (pValue = _tcsstr(pTaggedStr, pTagKeyword)) {

        pValue += _tcslen(pTagKeyword);

        if (pTaggedStr = _tcsstr(pValue, FAXTAG_PREFIX))
            *pcch = (INT)(pTaggedStr - pValue);
        else
            *pcch = _tcslen(pValue);
    }

    return pValue;
}

BOOL
FillMsTagInfo(
    LPTSTR FaxFileName,
     const JOB_QUEUE * lpcJobQueue
    )

/*++

Routine Description:

    Add Ms Tiff Tags to a sent fax. Wraps TiffAddMsTags...

Arguments:

    FaxFileName - Name of the file to archive
    SendTime    - time the fax was sent
    FaxStatus   - job status
    FaxSend     - FAX_SEND structure for sent fax, includes CSID.

Return Value:

    TRUE    - The tags were added.
    FALSE   - The tags were not added.

--*/
{
    BOOL success = FALSE;
    MS_TAG_INFO MsTagInfo = {0};
    WCHAR       wcZero = L'\0';
    PJOB_ENTRY lpJobEntry;
    LPCFSPI_JOB_STATUS lpcFSPIJobStatus;
    DEBUG_FUNCTION_NAME(TEXT("FillMsTagInfo"));

    Assert (lpcJobQueue);
    Assert (lpcJobQueue->lpParentJob);
    lpJobEntry = lpcJobQueue->JobEntry;
    Assert(lpJobEntry);
    lpcFSPIJobStatus = &lpJobEntry->FSPIJobStatus;

    if (lpcJobQueue->RecipientProfile.lptstrName && (lpcJobQueue->RecipientProfile.lptstrName[0] != wcZero) ) {
       MsTagInfo.RecipName     = lpcJobQueue->RecipientProfile.lptstrName;
    }

    if (lpcJobQueue->RecipientProfile.lptstrFaxNumber && (lpcJobQueue->RecipientProfile.lptstrFaxNumber[0] != wcZero) ) {
       MsTagInfo.RecipNumber   = lpcJobQueue->RecipientProfile.lptstrFaxNumber;
    }

    if (lpcJobQueue->SenderProfile.lptstrName && (lpcJobQueue->SenderProfile.lptstrName[0] != wcZero) ) {
       MsTagInfo.SenderName    = lpcJobQueue->SenderProfile.lptstrName;
    }

    if (lpcFSPIJobStatus->lpwstrRoutingInfo && (lpcFSPIJobStatus->lpwstrRoutingInfo[0] != wcZero) ) {
       MsTagInfo.Routing       = lpcFSPIJobStatus->lpwstrRoutingInfo;
    }

    if (lpcFSPIJobStatus->lpwstrRemoteStationId && (lpcFSPIJobStatus->lpwstrRemoteStationId[0] != wcZero) ) {
       MsTagInfo.Csid          = lpcFSPIJobStatus->lpwstrRemoteStationId;
    }

    if (lpJobEntry->lpwstrJobTsid && (lpJobEntry->lpwstrJobTsid[0] != wcZero) ) {
       MsTagInfo.Tsid      = lpJobEntry->lpwstrJobTsid;
    }

    if (!GetRealFaxTimeAsFileTime (lpJobEntry, FAX_TIME_TYPE_START, (FILETIME*)&MsTagInfo.StartTime))
    {
        MsTagInfo.StartTime = 0;
        DebugPrintEx(DEBUG_ERR,TEXT("GetRealFaxTimeAsFileTime (Start time)  Failed (ec: %ld)"), GetLastError() );
    }

    if (!GetRealFaxTimeAsFileTime (lpJobEntry, FAX_TIME_TYPE_END, (FILETIME*)&MsTagInfo.EndTime))
    {
        MsTagInfo.EndTime = 0;
        DebugPrintEx(DEBUG_ERR,TEXT("GetRealFaxTimeAsFileTime (Eend time) Failed (ec: %ld)"), GetLastError() );
    }

    MsTagInfo.SubmissionTime = lpcJobQueue->lpParentJob->SubmissionTime;
    MsTagInfo.OriginalScheduledTime  = lpcJobQueue->lpParentJob->OriginalScheduleTime;
    MsTagInfo.Type           = JT_SEND;


    if (lpJobEntry->LineInfo->DeviceName && (lpJobEntry->LineInfo->DeviceName[0] != wcZero) )
    {
       MsTagInfo.Port       = lpJobEntry->LineInfo->DeviceName;
    }


    MsTagInfo.Pages         = lpcJobQueue->PageCount;
    MsTagInfo.Retries       = lpcJobQueue->SendRetries;

    if (lpcJobQueue->RecipientProfile.lptstrCompany && (lpcJobQueue->RecipientProfile.lptstrCompany[0] != wcZero) ) {
       MsTagInfo.RecipCompany = lpcJobQueue->RecipientProfile.lptstrCompany;
    }

    if (lpcJobQueue->RecipientProfile.lptstrStreetAddress && (lpcJobQueue->RecipientProfile.lptstrStreetAddress[0] != wcZero) ) {
       MsTagInfo.RecipStreet = lpcJobQueue->RecipientProfile.lptstrStreetAddress;
    }

    if (lpcJobQueue->RecipientProfile.lptstrCity && (lpcJobQueue->RecipientProfile.lptstrCity[0] != wcZero) ) {
       MsTagInfo.RecipCity = lpcJobQueue->RecipientProfile.lptstrCity;
    }

    if (lpcJobQueue->RecipientProfile.lptstrState && (lpcJobQueue->RecipientProfile.lptstrState[0] != wcZero) ) {
       MsTagInfo.RecipState = lpcJobQueue->RecipientProfile.lptstrState;
    }

    if (lpcJobQueue->RecipientProfile.lptstrZip && (lpcJobQueue->RecipientProfile.lptstrZip[0] != wcZero) ) {
       MsTagInfo.RecipZip = lpcJobQueue->RecipientProfile.lptstrZip;
    }

    if (lpcJobQueue->RecipientProfile.lptstrCountry && (lpcJobQueue->RecipientProfile.lptstrCountry[0] != wcZero) ) {
       MsTagInfo.RecipCountry = lpcJobQueue->RecipientProfile.lptstrCountry;
    }

    if (lpcJobQueue->RecipientProfile.lptstrTitle && (lpcJobQueue->RecipientProfile.lptstrTitle[0] != wcZero) ) {
       MsTagInfo.RecipTitle = lpcJobQueue->RecipientProfile.lptstrTitle;
    }

    if (lpcJobQueue->RecipientProfile.lptstrDepartment && (lpcJobQueue->RecipientProfile.lptstrDepartment[0] != wcZero) ) {
       MsTagInfo.RecipDepartment = lpcJobQueue->RecipientProfile.lptstrDepartment;
    }

    if (lpcJobQueue->RecipientProfile.lptstrOfficeLocation && (lpcJobQueue->RecipientProfile.lptstrOfficeLocation[0] != wcZero) ) {
       MsTagInfo.RecipOfficeLocation = lpcJobQueue->RecipientProfile.lptstrOfficeLocation;
    }

    if (lpcJobQueue->RecipientProfile.lptstrHomePhone && (lpcJobQueue->RecipientProfile.lptstrHomePhone[0] != wcZero) ) {
       MsTagInfo.RecipHomePhone = lpcJobQueue->RecipientProfile.lptstrHomePhone;
    }

    if (lpcJobQueue->RecipientProfile.lptstrOfficePhone && (lpcJobQueue->RecipientProfile.lptstrOfficePhone[0] != wcZero) ) {
       MsTagInfo.RecipOfficePhone = lpcJobQueue->RecipientProfile.lptstrOfficePhone;
    }

    if (lpcJobQueue->RecipientProfile.lptstrEmail && (lpcJobQueue->RecipientProfile.lptstrEmail[0] != wcZero) ) {
       MsTagInfo.RecipEMail = lpcJobQueue->RecipientProfile.lptstrEmail;
    }

    if (lpcJobQueue->SenderProfile.lptstrFaxNumber && (lpcJobQueue->SenderProfile.lptstrFaxNumber[0] != wcZero) ) {
       MsTagInfo.SenderNumber   = lpcJobQueue->SenderProfile.lptstrFaxNumber;
    }

    if (lpcJobQueue->SenderProfile.lptstrCompany && (lpcJobQueue->SenderProfile.lptstrCompany[0] != wcZero) ) {
       MsTagInfo.SenderCompany = lpcJobQueue->SenderProfile.lptstrCompany;
    }

    if (lpcJobQueue->SenderProfile.lptstrStreetAddress && (lpcJobQueue->SenderProfile.lptstrStreetAddress[0] != wcZero) ) {
       MsTagInfo.SenderStreet = lpcJobQueue->SenderProfile.lptstrStreetAddress;
    }

    if (lpcJobQueue->SenderProfile.lptstrCity && (lpcJobQueue->SenderProfile.lptstrCity[0] != wcZero) ) {
       MsTagInfo.SenderCity = lpcJobQueue->SenderProfile.lptstrCity;
    }

    if (lpcJobQueue->SenderProfile.lptstrState && (lpcJobQueue->SenderProfile.lptstrState[0] != wcZero) ) {
       MsTagInfo.SenderState = lpcJobQueue->SenderProfile.lptstrState;
    }

    if (lpcJobQueue->SenderProfile.lptstrZip && (lpcJobQueue->SenderProfile.lptstrZip[0] != wcZero) ) {
       MsTagInfo.SenderZip = lpcJobQueue->SenderProfile.lptstrZip;
    }

    if (lpcJobQueue->SenderProfile.lptstrCountry && (lpcJobQueue->SenderProfile.lptstrCountry[0] != wcZero) ) {
       MsTagInfo.SenderCountry = lpcJobQueue->SenderProfile.lptstrCountry;
    }

    if (lpcJobQueue->SenderProfile.lptstrTitle && (lpcJobQueue->SenderProfile.lptstrTitle[0] != wcZero) ) {
       MsTagInfo.SenderTitle = lpcJobQueue->SenderProfile.lptstrTitle;
    }

    if (lpcJobQueue->SenderProfile.lptstrDepartment && (lpcJobQueue->SenderProfile.lptstrDepartment[0] != wcZero) ) {
       MsTagInfo.SenderDepartment = lpcJobQueue->SenderProfile.lptstrDepartment;
    }

    if (lpcJobQueue->SenderProfile.lptstrOfficeLocation && (lpcJobQueue->SenderProfile.lptstrOfficeLocation[0] != wcZero) ) {
       MsTagInfo.SenderOfficeLocation = lpcJobQueue->SenderProfile.lptstrOfficeLocation;
    }

    if (lpcJobQueue->SenderProfile.lptstrHomePhone && (lpcJobQueue->SenderProfile.lptstrHomePhone[0] != wcZero) ) {
       MsTagInfo.SenderHomePhone = lpcJobQueue->SenderProfile.lptstrHomePhone;
    }

    if (lpcJobQueue->SenderProfile.lptstrOfficePhone && (lpcJobQueue->SenderProfile.lptstrOfficePhone[0] != wcZero) ) {
       MsTagInfo.SenderOfficePhone = lpcJobQueue->SenderProfile.lptstrOfficePhone;
    }

    if (lpcJobQueue->SenderProfile.lptstrEmail && (lpcJobQueue->SenderProfile.lptstrEmail[0] != wcZero) ) {
       MsTagInfo.SenderEMail = lpcJobQueue->SenderProfile.lptstrEmail;
    }

    if (lpcJobQueue->SenderProfile.lptstrBillingCode && (lpcJobQueue->SenderProfile.lptstrBillingCode[0] != wcZero) ) {
       MsTagInfo.SenderBilling = lpcJobQueue->SenderProfile.lptstrBillingCode;
    }

    if (lpcJobQueue->JobParamsEx.lptstrDocumentName && (lpcJobQueue->JobParamsEx.lptstrDocumentName[0] != wcZero) ) {
       MsTagInfo.Document   = lpcJobQueue->JobParamsEx.lptstrDocumentName;
    }

    if (lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject && (lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject[0] != wcZero) ) {
       MsTagInfo.Subject   = lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject;
    }

    if (lpcJobQueue->lpParentJob->UserName && (lpcJobQueue->lpParentJob->UserName[0] != wcZero) ) {
       MsTagInfo.SenderUserName = lpcJobQueue->lpParentJob->UserName;
    }

    if (lpcJobQueue->SenderProfile.lptstrTSID && (lpcJobQueue->SenderProfile.lptstrTSID[0] != wcZero) ) {
       MsTagInfo.SenderTsid = lpcJobQueue->SenderProfile.lptstrTSID;
    }

    MsTagInfo.dwStatus          = JS_COMPLETED; // We archive only succesfully sent faxes
    MsTagInfo.dwlBroadcastId    = lpcJobQueue->lpParentJob->UniqueId;
    MsTagInfo.Priority          = lpcJobQueue->lpParentJob->JobParamsEx.Priority;

    success = TiffAddMsTags( FaxFileName, &MsTagInfo, TRUE );
    if (!success)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("TiffAddMsTags failed, ec = %ld"),
                      GetLastError ());
    }
    if(!AddNTFSStorageProperties( FaxFileName, &MsTagInfo , TRUE ))
    {
        if (ERROR_OPEN_FAILED != GetLastError ())
        {
            //
            // If AddNTFSStorageProperties fails with ERROR_OPEN_FAIL then the archive
            // folder is not on an NTFS 5 partition.
            // This is ok - NTFS properties are a backup mechanism but not a must
            //
            DebugPrintEx( DEBUG_ERR,
                          TEXT("AddNTFSStorageProperties failed, ec = %ld"),
                          GetLastError ());
            success = FALSE;
        }
        else
        {
            DebugPrintEx( DEBUG_WRN,
                          TEXT("AddNTFSStorageProperties failed with ERROR_OPEN_FAIL. Probably not an NTFS 5 partition"));
        }
    }
    return success;
}   // FillMsTagInfo



//*********************************************************************************
//* Name:   ArchiveOutboundJob()
//* Author: Ronen Barenboim
//* Date:   June 03, 1999
//*********************************************************************************
//* DESCRIPTION:
//*    Archive a tiff file that has been sent by copying the file to an archive
//*    directory. Also adds the MSTags to the new file generated at the
//*    archive (not to the source file).
//*
//* PARAMETERS:
//*     [IN ]       const JOB_QUEUE * lpcJobQueue
//*         Pointer to the recipient job which is to be archived.
//*
//* RETURN VALUE:
//*     TRUE if the opeation succeeded.
//*     FALSE if the operation failed.
//*********************************************************************************
BOOL
ArchiveOutboundJob(
    const JOB_QUEUE * lpcJobQueue
    )
{
    BOOL        rVal = FALSE;
    WCHAR       ArchiveFileName[MAX_PATH] = {0};
    LPWSTR      lpwszUserSid = NULL;
    DWORD       ec = ERROR_SUCCESS;
    WCHAR       wszArchiveFolder[MAX_PATH];
    DEBUG_FUNCTION_NAME(TEXT("ArchiveOutboundJob"));

    Assert(lpcJobQueue);

    //
    // be sure that the dir exists
    //
    EnterCriticalSection (&g_CsConfig);
    lstrcpyn (  wszArchiveFolder,
                g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder,
                MAX_PATH);
    LeaveCriticalSection (&g_CsConfig);
    if (!MakeDirectory( wszArchiveFolder ))
    {
        USES_DWORD_2_STR;
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MakeDirectory() [%s] failed (ec: %ld)"),
            wszArchiveFolder,
            ec);
        FaxLog(
                FAXLOG_CATEGORY_OUTBOUND,
                FAXLOG_LEVEL_MIN,
                2,
                MSG_FAX_ARCHIVE_CREATE_FAILED,
                wszArchiveFolder,
                DWORD2DECIMAL(ec)
            );
        goto Error;
    }

    //
    // get the user sid string
    //
    if (!ConvertSidToStringSid(lpcJobQueue->lpParentJob->UserSid, &lpwszUserSid))
    {
       ec = GetLastError();
       DebugPrintEx(
           DEBUG_ERR,
           TEXT("ConvertSidToStringSid() failed (ec: %ld)"),
           ec);
       goto Error;
    }


    //
    // get the file name
    //
    if (GenerateUniqueArchiveFileName(  wszArchiveFolder,
                                        ArchiveFileName,
                                        lpcJobQueue->UniqueId,
                                        lpwszUserSid)) {
        rVal = TRUE;
    } else {
        USES_DWORD_2_STR;
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to generate unique name for archive file at dir [%s] (ec: %ld)"),
            wszArchiveFolder,
            ec);
        FaxLog(
               FAXLOG_CATEGORY_OUTBOUND,
               FAXLOG_LEVEL_MIN,
               1,
               MSG_FAX_ARCHIVE_CREATE_FILE_FAILED,
               DWORD2DECIMAL(ec)
        );
        goto Error;
    }

    if (rVal) {

        Assert(lpcJobQueue->FileName);

        rVal = CopyFile( lpcJobQueue->FileName, ArchiveFileName, FALSE );
        if (!rVal) {
            USES_DWORD_2_STR;
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CopyFile [%s] to [%s] failed. (ec: %ld)"),
                lpcJobQueue->FileName,
                ArchiveFileName,
                ec);
            FaxLog(
               FAXLOG_CATEGORY_OUTBOUND,
               FAXLOG_LEVEL_MIN,
               1,
               MSG_FAX_ARCHIVE_CREATE_FILE_FAILED,
               DWORD2DECIMAL(ec)
            );

            if (!DeleteFile(ArchiveFileName))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("DeleteFile [%s] failed. (ec: %ld)"),
                    ArchiveFileName,
                    GetLastError());
            }
            goto Error;
        }
    }

    if (rVal)
    {
        DWORD dwRes;
        HANDLE hFind;
        WIN32_FIND_DATA FindFileData;

        if (!FillMsTagInfo( ArchiveFileName,
                            lpcJobQueue
                            ))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to add MS TIFF tags to archived file %s. (ec: %ld)"),
                ArchiveFileName,
                dwRes);
            FaxLog(
                FAXLOG_CATEGORY_OUTBOUND,
                FAXLOG_LEVEL_MIN,
                2,
                MSG_FAX_ARCHIVE_NO_TAGS,
                ArchiveFileName,
                GetLastErrorText(dwRes)
            );
        }

        dwRes = CreateArchiveEvent (lpcJobQueue->UniqueId,
                                    FAX_EVENT_TYPE_OUT_ARCHIVE,
                                    FAX_JOB_EVENT_TYPE_ADDED,
                                    lpcJobQueue->lpParentJob->UserSid);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_*_ARCHIVE) failed (ec: %lc)"),
                dwRes);
        }

        hFind = FindFirstFile( ArchiveFileName, &FindFileData);
        if (INVALID_HANDLE_VALUE == hFind)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindFirstFile failed (ec: %lc), File %s"),
                GetLastError(),
                ArchiveFileName);
        }
        else
        {
            // Update the archive size - for quota management
            EnterCriticalSection (&g_CsConfig);
            if (FAX_ARCHIVE_FOLDER_INVALID_SIZE != g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].dwlArchiveSize)
            {
                g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].dwlArchiveSize += (MAKELONGLONG(FindFileData.nFileSizeLow ,FindFileData.nFileSizeHigh));
            }
            LeaveCriticalSection (&g_CsConfig);
            Assert (FindFileData.nFileSizeLow);

            if (!FindClose(hFind))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FindClose failed (ec: %lc)"),
                    GetLastError());
            }
        }

        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_SENT_ARCHIVE_SUCCESS,
            lpcJobQueue->FileName,
            ArchiveFileName
            );
    }

    Assert( ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert( ERROR_SUCCESS != ec);
    FaxLog(
           FAXLOG_CATEGORY_OUTBOUND,
           FAXLOG_LEVEL_MIN,
           3,
           MSG_FAX_ARCHIVE_FAILED,
           lpcJobQueue->FileName,
           wszArchiveFolder,
           GetLastErrorText(GetLastError())
    );
Exit:

    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }

    if (lpwszUserSid != NULL)
    {
        LocalFree (lpwszUserSid);
    }

    return (ERROR_SUCCESS == ec);
}


PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )

/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = (PBYTE)MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    MemFree(pJobInfo);
    return NULL;
}


BOOL UpdatePerfCounters(const JOB_QUEUE * lpcJobQueue)
{

    SYSTEMTIME SystemTime ;
    DWORD Seconds ;
    HANDLE FileHandle ;
    DWORD Bytes = 0 ; /// Compute #bytes in the file FaxSend.FileName and stick it here!
    const JOB_ENTRY  * lpcJobEntry;

    DEBUG_FUNCTION_NAME(TEXT("UpdatePerfCounters"));

    Assert(lpcJobQueue);
    lpcJobEntry = lpcJobQueue->JobEntry;
    Assert(lpcJobEntry);

    FileHandle = CreateFile(
        lpcJobEntry->lpJobQueueEntry->FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if(FileHandle != INVALID_HANDLE_VALUE){
        Bytes = GetFileSize( FileHandle, NULL );
        CloseHandle( FileHandle );
    }

    if (!FileTimeToSystemTime(
        (FILETIME*)&lpcJobEntry->ElapsedTime,
        &SystemTime
        ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToSystemTime failed (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
        memset(&SystemTime,0,sizeof(SYSTEMTIME));
    }


    Seconds = (DWORD)( SystemTime.wSecond + 60 * ( SystemTime.wMinute + 60 * SystemTime.wHour ));
    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFaxes );
    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->TotalFaxes );

    InterlockedExchangeAdd( (PLONG)&g_pFaxPerfCounters->OutboundPages, (LONG)lpcJobEntry->FSPIJobStatus.dwPageCount );
    InterlockedExchangeAdd( (PLONG)&g_pFaxPerfCounters->TotalPages, (LONG)lpcJobEntry->FSPIJobStatus.dwPageCount  );

    EnterCriticalSection( &g_CsPerfCounters );

    g_dwOutboundSeconds += Seconds;
    g_dwTotalSeconds += Seconds;
    g_pFaxPerfCounters->OutboundMinutes = g_dwOutboundSeconds / 60 ;
    g_pFaxPerfCounters->TotalMinutes = g_dwTotalSeconds / 60 ;
    g_pFaxPerfCounters->OutboundBytes += Bytes;
    g_pFaxPerfCounters->TotalBytes += Bytes;

    LeaveCriticalSection( &g_CsPerfCounters );
    return TRUE;


}


BOOL MarkJobAsExpired(PJOB_QUEUE lpJobQueue)
{
    FILETIME CurrentFileTime;
    LARGE_INTEGER NewTime;
    DWORD dwMaxRetries;
    BOOL rVal = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("MarkJobAsExpired"));

    Assert(lpJobQueue);
    Assert( JT_SEND == lpJobQueue->JobType ||
            JT_ROUTING == lpJobQueue->JobType );

    EnterCriticalSection(&g_CsQueue);
    lpJobQueue->JobStatus = JS_RETRIES_EXCEEDED;
    EnterCriticalSection (&g_CsConfig);
    dwMaxRetries = g_dwFaxSendRetries;
    LeaveCriticalSection (&g_CsConfig);
    lpJobQueue->SendRetries = dwMaxRetries + 1;
    //
    // Set the job's ScheduleTime field to the time it totaly failed.
    // (current time).
    //
    GetSystemTimeAsFileTime( &CurrentFileTime ); //Can not fail (Win32 SDK)
    NewTime.LowPart  = CurrentFileTime.dwLowDateTime;
    NewTime.HighPart = CurrentFileTime.dwHighDateTime;
    lpJobQueue->ScheduleTime = NewTime.QuadPart;

    if (!CommitQueueEntry(lpJobQueue))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CommitQueueEntry() for recipien job %s has failed. (ec: %ld)"),
            lpJobQueue->FileName,
            GetLastError());
        rVal = FALSE;
    }

    if (JT_SEND == lpJobQueue->JobType)
    {
        Assert (lpJobQueue->lpParentJob);

        lpJobQueue->lpParentJob->dwFailedRecipientJobsCount+=1;
        //
        // The parent job keeps the schedule of the last recipient job that failed.
        // The job retention policy for the parent will be based on that
        // schedule.
        lpJobQueue->lpParentJob->ScheduleTime = lpJobQueue->ScheduleTime;
        if (!CommitQueueEntry(lpJobQueue->lpParentJob))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CommitQueueEntry() for parent job %s has failed. (ec: %ld)"),
                lpJobQueue->lpParentJob->FileName,
                GetLastError());
            rVal = FALSE;
        }
    }

    LeaveCriticalSection(&g_CsQueue);
    return rVal;
}



//*********************************************************************************
//* Name:   StartFaxDevSendEx()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Finds all the sibling jobs of the specific recipient job that are destined
//*     to the specified line and starts the execution of all these recipients
//*     on this line using FaxDevSendEx() (Extended FSPI).
//* PARAMETERS:
//*     [IN ]   PJOB_QUEUE lpJobQueue
//*         The "Anchor" recipient job. The function will attempt to find other
//*         siblings of the Anchor job which are destined to the same line.
//*         The resulting job group will be sent for execution using FaxDevSendEx().
//*
//*     [IN ]    PLINE_INFO pLineInfo
//*         The line on which the Anchor job should execute. The code will group
//*         together the Anchor siblings which are destined to the same line.
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured. In this case no job will start executing and
//*         the function will cleanup all the resources it allocaed.
//*         It will also return the specified line to the pool of free lines.
//*         To get extended error information call GetLastError().
//*********************************************************************************
BOOL StartFaxDevSendEx(PJOB_QUEUE lpAnchorJob, PLINE_INFO lpLineInfo)
{
    PLIST_ENTRY lpNext;
    PJOB_QUEUE lpParentJob;                             // The parent job of the Anchor recipient.
    LPFSPI_PERSONAL_PROFILE lpRecipientProfiles = NULL; // This array holds the recipient information array used as
                                                        // input parameter to FaxDevSendEx()

    LPFSPI_MESSAGE_ID lpRecipientMessageIds  = NULL;    // This array holds the message id structures array used as
                                                        // output parameter to FaxDevSendEx()
    FSPI_MESSAGE_ID ParentMessageId;                    // The parent message id returned by FaxDevSendEx()
    LPFSPI_MESSAGE_ID lpParentMessageId = NULL;         // Points to the parent message id if it is used.
                                                        // NULL in case of an EFSP that does not support job reestablishment.
    PHANDLE lpRecipientJobHandles = NULL;               // This array holds the recipient job handles array used as
                                                        // output parameter to FaxDevSendEx()
    HANDLE hParent;                                     // The parent job handle returned by FaxDevSendEx()
    UINT dwRecipient;                                   // Used as recipient index trhougout the code
    FSPI_COVERPAGE_INFO FSPICoverPage;                  // The cover page information sent to FaxDevSendEx()
    FSPI_PERSONAL_PROFILE FSPISenderInfo;               // The Sender information sent to FaxDevSendEx()
    DWORD ec = 0;                                       // The last error code reported on return from this function.
    DWORD dwRecipientCount = 0;
    SYSTEMTIME  tmSendTime;                             // The scheduled time of the anchor job in SYSTEMTIME (UTC) format.

    LPEFSP_JOB_GROUP lpJobGroup = NULL;
    BOOL bFaxDevSendExCalled = FALSE;                   // TRUE if FaxDevSendEx() was successfuly called. Used during cleanup.
    BOOL bBranding = FALSE;                             // TRUE if the server is configured to brand outgoing faxes. Passed to FaxDevSendEx
    DEBUG_FUNCTION_NAME(TEXT("StartFaxDevSendEx"));

    Assert(lpAnchorJob);
    Assert(lpLineInfo);
    Assert(lpLineInfo->Provider);

    EnterCriticalSectionJobAndQueue;
    EnterCriticalSection(&g_csEFSPJobGroups);


    //
    // Find the parent job of the Anchor recipient
    //
    lpParentJob = lpAnchorJob->lpParentJob;
    Assert(lpParentJob);
    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Anchor Job: Id: %ld Name:%s Number:%s"),
        lpAnchorJob->JobId,
        lpAnchorJob->RecipientProfile.lptstrName,
        lpAnchorJob->RecipientProfile.lptstrFaxNumber);
    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Anchor Line: Name: %s PermanentId: 0x%08X"),
        lpLineInfo->DeviceName,
        lpLineInfo->PermanentLineID);


    memset(&ParentMessageId,0,sizeof(FSPI_MESSAGE_ID));

    lpJobGroup = EFSPJobGroup_Create(lpLineInfo);
    if (!lpJobGroup)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EFSPJobGroup_Create() failed (ec: %ld)"),
            ec);
        goto Error;
    }

    //
    // Add the group to the group list
    //
    InsertTailList( &g_EFSPJobGroupsHead, &lpJobGroup->ListEntry );


    if (lpLineInfo->Provider->dwCapabilities & FSPI_CAP_BROADCAST)
    {
        //
        // Find all the siblings which are destined to the same line and group them together
        // with the Anchor recipient in the RecipientsGroupHead list.
        // dwRecipientCount will hold the number of recipients placed in the group (including the
        // Anchor recipient).
        //
        if (!CreateRecipientGroup(lpAnchorJob, lpLineInfo, lpJobGroup))
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateRecipientGroup() failed (ec: %ld)"),
                GetLastError());
            goto Error;
        }
    }
    else
    {

        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Anchor Line [%s] does not support broadcast. Executing Anchor Job seperately."),
            lpLineInfo->DeviceName);

        if (!EFSPJobGroup_AddRecipient(lpJobGroup, lpAnchorJob, FALSE)) // Don't commit we'll save later
        {
            ec =  GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSPJobGroup_AddRecipient() for anchor job (JobId: %ld) failed. (ec: %ld)"),
                lpAnchorJob->JobId,
                ec);
            goto Error;
        }
    }
    Assert(lpJobGroup->dwRecipientJobs >= 1); // At least the Anchor recipient must be there.

    EFSPJobGroup_DbgDump(lpJobGroup); // DEBUG only

    dwRecipientCount =  lpJobGroup->dwRecipientJobs;



    if (lpLineInfo->Provider->dwMaxMessageIdSize > 0)
    {
        //
        // The EFSP supports job reestablishment
        //

        //
        // Allocate and initialize the recipients permanent message ids array
        //
        if (!CreateFSPIRecipientMessageIdsArray(
                &lpRecipientMessageIds,
                dwRecipientCount,
                lpLineInfo->Provider->dwMaxMessageIdSize))
        {
            lpRecipientMessageIds = NULL;
            ec =  GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("AllocateRecipientsMessageId() failed. (ec: %ld)"),
                GetLastError());
            goto Error;
        }
        Assert(lpRecipientMessageIds);
        //
        // Allocate the parent permanent message id
        //
        ParentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
        ParentMessageId.dwIdSize = lpLineInfo->Provider->dwMaxMessageIdSize;
        if (lpLineInfo->Provider->dwMaxMessageIdSize)
        {
            ParentMessageId.lpbId = (LPBYTE)MemAlloc(ParentMessageId.dwIdSize);
            if (!ParentMessageId.lpbId)
            {
                ec= GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to allocate permanent message id buffer for parent job. MaxMessageIdSize: %ld. (ec: %ld)"),
                    lpLineInfo->Provider->dwMaxMessageIdSize,
                    GetLastError());
                goto Error;
            }
        }
        else
        {
            ParentMessageId.lpbId = NULL;
        }
        lpParentMessageId = &ParentMessageId;
    }
    else
    {
        lpRecipientMessageIds = NULL;
        lpParentMessageId = NULL;
    }

    //
    // Allocate the FSP recipient job handles array
    //

    lpRecipientJobHandles = (PHANDLE)MemAlloc( dwRecipientCount * sizeof (HANDLE));
    if (!lpRecipientJobHandles)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate recipient job handles array (RecipientCount: %ld) (ec: %ld)"),
            dwRecipientCount,
            GetLastError());
        goto Error;
    }

    //
    // Allocate and initialize the recipients profile array.
    // Note: This allocates lpRecipientProfiles array which need to be freed.
    // However it does not allocate any member of FSPI_PERSONAL_PROFILE but just
    // set them to point to the corresponding strings in the recipient job.
    //
    if (!CreateFSPIRecipientProfilesArray(
            &lpRecipientProfiles,
            dwRecipientCount,
            &lpJobGroup->RecipientJobs))
    {
        lpRecipientProfiles = NULL;
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateFSPIRecipientProfilesArray failed.(RecipientCount: %ld)(ec: %ld)"),
            dwRecipientCount,
            GetLastError());
        goto Error;
    }

    //
    // Convert the cover page information to FSPI compatible structure. DOES NOT ALLOCATE MEMORY.
    //
    if (!FaxCoverPageToFSPICoverPage(&FSPICoverPage,
                                     &lpParentJob->CoverPageEx,
                                     lpParentJob->PageCount))
    {
        //
        // Note: FaxCoverPageToFSPICoverPage only copies pointers. It does not allocate memeory !!!
        //
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxCoverPageToFSPICoverPage() failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    //
    // Convert the sender profile to FSPI compatible structure. DOES NOT ALLOCATE MEMORY.
    //

    if (!FaxPersonalProfileToFSPIPersonalProfile(&FSPISenderInfo, &lpParentJob->SenderProfile))
    {
        //
        // Note: FaxCoverPageToFSPICoverPage only copies pointers. It does not allocate memeory !!!
        //
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxPersonalProfileToFSPIPersonalProfile() failed for sender profile (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    //
    // Convert the Anchor job time back to SYSTEMTIME
    //
    if (!FileTimeToSystemTime((FILETIME*) &lpAnchorJob->ScheduleTime, &tmSendTime))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to convert anchor job filetime to systemtime (filetime: %ld) (ec: %ld)"),
            lpAnchorJob->ScheduleTime,
            ec);
        goto Error;
    }

    EnterCriticalSection (&g_CsConfig);
    bBranding = g_fFaxUseBranding;
    LeaveCriticalSection (&g_CsConfig);

    __try
    {
        HRESULT hr;
        Assert(lpLineInfo->Provider);
        Assert(lpLineInfo->Provider->FaxDevSendEx);
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Calling FaxDevSendEx()..."));

        hr = lpLineInfo->Provider->FaxDevSendEx(
                lpLineInfo->hLine,
                lpLineInfo->TapiPermanentLineId,
                lpParentJob->FileName,
                &FSPICoverPage,
                bBranding,
                tmSendTime,
                &FSPISenderInfo,
                dwRecipientCount,
                lpRecipientProfiles,
                lpRecipientMessageIds,
                lpRecipientJobHandles,
                lpParentMessageId,
                &hParent);
        if (FAILED(hr))
        {
            switch (hr)
            {
                case FSPI_E_INVALID_JOB_HANDLE:
                case FSPI_E_INVALID_MESSAGE_ID:
                case FSPI_E_INVALID_COVER_PAGE:
                    ec = ERROR_INVALID_PARAMETER;
                    break;
                case FSPI_E_NOMEM:
                    ec = ERROR_OUTOFMEMORY;
                    break;
                case FSPI_E_FAILED:
                    ec = ERROR_GEN_FAILURE;
                    break;
                default:
                    ec = ERROR_GEN_FAILURE;
                    break;
            }
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevSendEx() FAILED (HRESULT: 0x%08X)"),
                hr);
            goto Error;
        }
        else
        {
            bFaxDevSendExCalled = TRUE;
        }

    }
    __except ( EXCEPTION_EXECUTE_HANDLER)
    {
        ec = ERROR_INVALID_FUNCTION;
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevSendEx() * CRASHED * (Excpetion: %ld)"),
                GetExceptionCode());
        goto Error;
    }

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("FaxDevSendEx() succeeded."));

    //
    // Validate that the job handles are valid
    //

    if (!ValidateEFSPJobHandles(lpRecipientJobHandles, dwRecipientCount))
    {
        ec = GetLastError();
        if (ERROR_SUCCESS != ec)
        {
            //
            // The function failed.
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ValidateEFSPJobHandles() failed because of an error (ec: %ld)"),
                ec);
                goto Error;
        }
        else
        {
            //
            // The function reported invalid handles array
            //
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevSendEx() returned job handles are invalid."));
            goto Error;
        }
    }

    if (lpRecipientMessageIds)
    {
        //
        // Validate that the permanent message ids are valid
        //
        if (!ValidateEFSPPermanentMessageIds(
                lpRecipientMessageIds,
                dwRecipientCount,
                lpLineInfo->Provider->dwMaxMessageIdSize))
        {
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevSendEx() returned permanent ids are invalid."));
            goto Error;
        }
    }

    //
    // Put the message ids and job handles back into the recipient jobs
    //
    dwRecipient = 0;
    lpNext = lpJobGroup->RecipientJobs.Flink;
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpJobGroup->RecipientJobs)
    {
        PJOB_ENTRY lpJobEntry;
        PJOB_QUEUE_PTR lpRecipientsGroupMember;
        lpRecipientsGroupMember = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpNext->Flink;
        Assert(dwRecipient < dwRecipientCount);

        //
        // Create a job entry for each recipient job
        //

        //
        //  If EFSP set USE_DIALABLE_ADDRESS, then translate the number for it
        //
        lpJobEntry = CreateJobEntry(
                        lpRecipientsGroupMember->lpJob,
                        lpLineInfo,
                        (lpLineInfo->Provider->dwCapabilities & FSPI_CAP_USE_DIALABLE_ADDRESS),
                        FALSE); //  need to support handoff
        if (!lpJobEntry)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateJobEntry() failed for recipient JobId: %ld (ec: %ld)"),
                lpRecipientsGroupMember->lpJob->JobId,
                GetLastError());
            goto Error;
        }

        InsertTailList( &g_JobListHead, &lpJobEntry->ListEntry );

        lpJobEntry->bFSPJobInProgress = TRUE;


        //
        //  must check that the job handle is valid (not 0)
        //
        lpRecipientsGroupMember->lpJob->JobEntry = lpJobEntry;
        //
        // Save the EFSP recipient job handle
        //
        lpJobEntry->InstanceData = lpRecipientJobHandles[dwRecipient];
        //
        // Associate the job entry with the FSP job handle
        //
        ec = AddFspJob(lpLineInfo->Provider->hJobMap,
                       (HANDLE) lpJobEntry->InstanceData,
                       lpJobEntry);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("[Job: %ld] AddFspJob failed (ec: %ld)"),
                         lpJobEntry->lpJobQueueEntry->JobId,
                         ec);
            goto Error;
        }

        if (lpRecipientMessageIds)
        {
            //
            // Copy the permanent message id into the recipient job. Make sure to copy
            // only the used bytes of the permanent message id buffer.
            //
            if (!FreePermanentMessageId(&lpRecipientsGroupMember->lpJob->EFSPPermanentMessageId, FALSE))
            {

                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FreePermanentMessageId() for recipint JobId: %ld has failed (ec: %ld)"),
                    lpRecipientsGroupMember->lpJob->JobId,
                    GetLastError());
            }

            if (!CopyPermanentMessageId(
                    &lpRecipientsGroupMember->lpJob->EFSPPermanentMessageId,
                    &lpRecipientMessageIds[dwRecipient]))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CopyMessagePermanentId() of recipient message permanent id failed for recipient JobId: %ld(ec: %ld)"),
                    lpRecipientsGroupMember->lpJob->JobId,
                    GetLastError());
                goto Error;
            }

            //
            // Set the job to the in progress state
            //
            lpRecipientsGroupMember->lpJob->JobStatus = JS_INPROGRESS;

            //
            // Commit the recipient job changes (new permanent id) and JobStatus to disk.
            //
            if (!CommitQueueEntry(lpRecipientsGroupMember->lpJob))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CommitQueueEntry() for recipient JobId: %ld failed. (ec: %ld)"),
                    lpRecipientsGroupMember->lpJob->JobId,
                    ec);
                goto Error;
            }
        }

        //
        // Set the job to the in progress state
        //
        lpRecipientsGroupMember->lpJob->JobStatus = JS_INPROGRESS;

        if (lpParentMessageId && lpParentMessageId->dwIdSize)
        {
            //
            // Copy the parent permanent message id into the EFSPJobGroup if it is not empty
            // (it might be that the EFSP support recipient message ids but does not support parent message
            //  ids. In this case it returns size of 0 in the parent message id).
            if (!EFSPJobGroup_SetParentId(lpJobGroup, &ParentMessageId))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CopyMessagePermanentId() of parent message id failed for recipient JobId: %ld(ec: %ld)"),
                    lpRecipientsGroupMember->lpJob->JobId,
                    GetLastError());
                goto Error;
            }
        }
        //
        // Save the EFSP parent job handle into the EFSPJobGroup;
        //
        lpJobGroup->hFSPIParent= hParent;


        dwRecipient++;

    }

    if (lpLineInfo->Provider->dwMaxMessageIdSize > 0)
    {
        //
        // No point in saving the group if no permanent ids.
        //
        if (!EFSPJobGroup_Save(lpJobGroup)) // Create if it does not exist
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSPJobGroup_Save() failed (ec: %ld)"),
                ec);
            goto Error;
        }
    }

    Assert( 0 == ec);
    //
    // dwRecipient new sending jobs were just added to line lpLineInfo. Update counter
    //
    (VOID) UpdateDeviceJobsCounter ( lpLineInfo,    // Device to update
                                     TRUE,          // Sending
                                     dwRecipient,   // Number of new jobs
                                     TRUE);         // Enable events

    goto Exit;
Error:
    Assert( 0 != ec);

    //
    // Free the line we got hold of
    // (we can call this function even if the line is already released with no harm)
    // The line must be freed even if we did not get to the stage where a job
    // entry was created for the anchor job (i.e. bFaxDevSendExCalled is FALSE).
    // This is so since we got hold of it when calling StartFaxDevSendEx.
    // In case we did create job entries ReleaseTapiLine() will be called for each job
    // as part of TerminateMultipleFSPJobs() which calls EndJob() for each job.
    // Since it is not harmful to release a line twice nothing will go wrong.
    //
    if (!ReleaseTapiLine(lpLineInfo, NULL))  //  for handoff job we need to free the call handle
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ReleaseTapiLine() failed (ec: %ld)"),
            GetLastError());
    }

    if (bFaxDevSendExCalled)
    {
        Assert(dwRecipientCount);

        //
        // Call Abort and EndJob for all the returned FSP job handles
        //
        if (!TerminateMultipleFSPJobs(lpRecipientJobHandles, dwRecipientCount, lpLineInfo))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("TerminateMultipleFSPJobs() failed (ec: %ld)"),
                GetLastError());
        }

        //
        // End all the run time jobs we created.
        // Free the permanent id buffer.
        //
    }

    if (!EFSPJobGroup_ExecutionFailureCleanup(lpJobGroup))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EFSPJobGroup_ExecutionFailureCleanup() failed (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

    if (lpJobGroup)
    {
        //
        // Remove the EFSP group from the group list. Must be done
        // before freeing the group.
        //
        RemoveEntryList(&lpJobGroup->ListEntry);
    }

    //
    // Free the recipient group
    //
    if (!EFSPJobGroup_Free(lpJobGroup, TRUE)) // Destroy
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EFSPJobGroup_Free() failed (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

Exit:

    if (lpParentMessageId)
    {
        //
        // Free the parent message id buffer
        //
        MemFree(ParentMessageId.lpbId);
    }

    //
    // Free the recipient message ids array
    //
    if (lpRecipientMessageIds)
    {
        if (!FreeFSPIRecipientMessageIdsArray(lpRecipientMessageIds, dwRecipientCount))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FreeRecipientMessageIds() failed (ec: %ld)"),
                GetLastError());
            Assert(FALSE);
        }
    }


    //
    // Free the recipient job handles array
    //
    MemFree(lpRecipientJobHandles);

    LeaveCriticalSection(&g_csEFSPJobGroups);
    LeaveCriticalSectionJobAndQueue;

    if (ec)
    {
        SetLastError(ec);
    }
    return (0 == ec);
}   // StartFaxDevSendEx




//*********************************************************************************
//* Name:   CreateJobEntry()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates and initializes a new JOB_ENTRY.
//*     Opens the line the job is to be executed on (if it is a TAPI line)
//*     and creates the attachement between the line and the job.
//* PARAMETERS:
//*     [IN/OUT]    PJOB_QUEUE lpJobQueue
//*         For outgoing jobs this points to the JOB_QUEUE of the outgoing job.
//*         for receive job this should be set to NULL.
//*     [IN/OUT]     LINE_INFO * lpLineInfo
//*         A pointer to the LINE_INFO information of the line on which the job
//*         is to be executed.
//*     [IN ]    BOOL bTranslateNumber
//*         TRUE if the recipient number needs to be translated into dilable
//*         string (needed for legacy FaxDevSend() where the number must be
//*         dilable and not canonical).
//*     [IN ]    BOOL bHandoffJob
//*         TRUE if this is a handoff job. (Valid for send operations only).
//* RETURN VALUE:
//*
//*********************************************************************************
PJOB_ENTRY CreateJobEntry(
    PJOB_QUEUE lpJobQueue,
    LINE_INFO * lpLineInfo,
    BOOL bTranslateNumber,
    BOOL bHandoffJob)
{
    BOOL Failure = TRUE;
    PJOB_ENTRY JobEntry = NULL;
    DWORD rc  = ERROR_SUCCESS;;

    DEBUG_FUNCTION_NAME(TEXT("CreateJobEntry"));
    Assert(!(bHandoffJob && !lpJobQueue));
    Assert(!(lpJobQueue && lpJobQueue->JobType != JT_SEND));
    Assert(!(bTranslateNumber && !lpJobQueue));
    Assert (lpLineInfo);

    JobEntry = (PJOB_ENTRY) MemAlloc( sizeof(JOB_ENTRY) );
    if (!JobEntry)
    {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,_T("Failed to allocated memory for JOB_ENTRY."));
        goto exit;
    }

    memset(JobEntry, 0, sizeof(JOB_ENTRY));

    if (lpJobQueue)
    {
        if (! _tcslen(lpJobQueue->tczDialableRecipientFaxNumber))
        {
            //
            //  The Fax Number was not compound, make translation as before
            //
            if (bTranslateNumber)
            {
                rc = TranslateCanonicalNumber(lpJobQueue->RecipientProfile.lptstrFaxNumber,
                                              lpLineInfo->DeviceId,
                                              JobEntry->DialablePhoneNumber,
                                              JobEntry->DisplayablePhoneNumber);
                if (ERROR_SUCCESS != rc)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("TranslateCanonicalNumber() faield for number: %s (ec: %ld)"),
                        lpJobQueue->RecipientProfile.lptstrFaxNumber,
                        rc);
                    goto exit;
                }
            }
            else
            {
                _tcsncpy(JobEntry->DialablePhoneNumber, lpJobQueue->RecipientProfile.lptstrFaxNumber, SIZEOF_PHONENO );
                JobEntry->DialablePhoneNumber[SIZEOF_PHONENO - 1] = '\0';
                _tcsncpy(JobEntry->DisplayablePhoneNumber, lpJobQueue->RecipientProfile.lptstrFaxNumber, SIZEOF_PHONENO );
                JobEntry->DisplayablePhoneNumber[SIZEOF_PHONENO - 1] = '\0';
            }
        }
        else
        {
            //
            //  The Fax Number was compound, no translation needed
            //  Take Dialable from JobQueue and Displayable from Recipient's PersonalProfile's FaxNumber
            //
            _tcsncpy(JobEntry->DialablePhoneNumber, lpJobQueue->tczDialableRecipientFaxNumber, SIZEOF_PHONENO );
            _tcsncpy(JobEntry->DisplayablePhoneNumber, lpJobQueue->RecipientProfile.lptstrFaxNumber, (SIZEOF_PHONENO - 1));
            JobEntry->DisplayablePhoneNumber[SIZEOF_PHONENO - 1] = '\0';
        }
    }
    else
    {
        //
        //  lpJobQueue is NULL
        //
        _tcscpy(JobEntry->DialablePhoneNumber,TEXT(""));
        _tcscpy(JobEntry->DisplayablePhoneNumber,TEXT(""));
    }

    JobEntry->CallHandle = 0;
    JobEntry->InstanceData = 0;
    JobEntry->LineInfo = lpLineInfo;
    JobEntry->SendIdx = -1;
    JobEntry->Released = FALSE;
    JobEntry->lpJobQueueEntry = lpJobQueue;
    JobEntry->HandoffJob = bHandoffJob;
    JobEntry->bFSPJobInProgress = FALSE;
    memset(&JobEntry->FSPIJobStatus,0,sizeof(FSPI_JOB_STATUS));
    JobEntry->FSPIJobStatus.dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);
    JobEntry->FSPIJobStatus.dwJobStatus = FSPI_JS_UNKNOWN;
    JobEntry->hCallHandleEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (!JobEntry->hCallHandleEvent)
    {
        rc=GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateEvent for JobEntry->hCallHandleEvent failed. (ec: %ld)"),
            GetLastError());
        goto exit;
    }

    GetSystemTimeAsFileTime( (FILETIME*) &JobEntry->StartTime );

    EnterCriticalSection (&g_CsLine);
    if (!(lpLineInfo->Flags & FPF_VIRTUAL) && (!lpLineInfo->hLine))
    {
        if (!OpenTapiLine( lpLineInfo ))
        {
            rc = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenTapiLine failed. (ec: %ld)"),
                rc);
            LeaveCriticalSection (&g_CsLine);
            goto exit;
        }
    }

    //
    // Attach the job to the line selected to service it.
    // This is done only if the line is not a FSPI_CAP_MULTISEND device.
    //
    if (! (lpLineInfo->Provider->dwCapabilities & FSPI_CAP_MULTISEND) )
    {
        lpLineInfo->JobEntry = JobEntry;
    }
    else
    {
        //
        // Multi send devices can run multiple jobs at once so there is no point holding a pointer to a single
        // job running on the device.
        //
        lpLineInfo->JobEntry = NULL;

    }
    LeaveCriticalSection (&g_CsLine);


    Failure = FALSE;


exit:
    if (Failure)
    {
        // Failure is initialized to TRUE
        if (JobEntry)
        {
            if (JobEntry->hCallHandleEvent)
            {
                CloseHandle (JobEntry->hCallHandleEvent);
            }
            MemFree( JobEntry );
        }
        JobEntry = NULL;
    }
    if (ERROR_SUCCESS != rc)
    {
        SetLastError(rc);
    }
    return JobEntry;
}   // CreateJobEntry


//*********************************************************************************
//* Name:   TranslateCanonicalNumber()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Translates a canonical number to a dilable + displayable number.
//*
//* PARAMETERS:
//*     [IN ]   LPTSTR lptstrFaxNumber
//*         The canonical number to translate.
//*
//*     [IN ]   DWORD dwDeviceID
//*         The device ID.
//*
//*     [OUT]   LPTSTR lptstrDialableAddress
//*         Buffer to receive the dialable translated address.
//*         Buffer size must be at least SIZEOF_PHONENO characters long.
//*         The return string will never exceed SIZEOF_PHONENO characters.
//*
//*     [OUT]   LPTSTR lptstrDisplayableAddress
//*         Buffer to receive the displayable translated address.
//*         Buffer size must be at least SIZEOF_PHONENO characters long.
//*         The return string will never exceed SIZEOF_PHONENO characters.

//* RETURN VALUE:
//*     On success the function returns a  pointer to a newly allocated string
//*     that contains the dilable number.
//*     On failure it returns NULL. Call GetLastError() to get extended error
//*     information (TAPI ERROR).
//*********************************************************************************
static
DWORD
TranslateCanonicalNumber(
    LPTSTR lptstrCanonicalFaxNumber,
    DWORD  dwDeviceID,
    LPTSTR lptstrDialableAddress,
    LPTSTR lptstrDisplayableAddress
)
{
    DWORD ec = ERROR_SUCCESS;
    LPLINETRANSLATEOUTPUT LineTranslateOutput = NULL;

    DEBUG_FUNCTION_NAME(TEXT("TranslateCanonicalNumber"));
    Assert(lptstrCanonicalFaxNumber && lptstrDialableAddress && lptstrDisplayableAddress);

    ec = MyLineTranslateAddress( lptstrCanonicalFaxNumber, dwDeviceID, &LineTranslateOutput );
    if (ERROR_SUCCESS == ec)
    {
        LPTSTR lptstrTranslateBuffer;
        //
        // Copy displayable string
		// TAPI returns credit card numbers in the displayable string.
		// return the input canonical number as the displayable string.
        //       
        _tcsncpy (lptstrDisplayableAddress, lptstrCanonicalFaxNumber, SIZEOF_PHONENO);
        lptstrDisplayableAddress[SIZEOF_PHONENO-1] = '\0';
        //
        // Copy dialable string
        //
        Assert (LineTranslateOutput->dwDialableStringSize > 0);
        lptstrTranslateBuffer=(LPTSTR)((LPBYTE)LineTranslateOutput + LineTranslateOutput->dwDialableStringOffset);
        _tcsncpy (lptstrDialableAddress, lptstrTranslateBuffer, SIZEOF_PHONENO);
        lptstrDialableAddress[SIZEOF_PHONENO-1] = '\0';
    }
    else
    {
        // ec is a Tapi ERROR
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("MyLineTranslateAddress() failed for fax number: [%s] (ec: %ld)"),
                lptstrCanonicalFaxNumber,
                ec);
        goto Exit;
    }

    Assert (ERROR_SUCCESS == ec);

Exit:
    MemFree( LineTranslateOutput );
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }
    return ec;
}   // TranslateCanonicalNumber

//*********************************************************************************
//* Name:   CreateRecipientGroup()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     locates all the sibilings of the anchor job which are destined to the same
//*     line as the anchor job and are ready for execution and adds them to
//*     the specified recipient group.
//*
//* PARAMETERS:
//*     [IN ]       const PJOB_QUEUE lpcAnchorJob
//*         The Anchor job whose siblings are to be grouped
//*     [IN ]       const PLINE_INFO lpcLineInfo
//*         The line to which the anchor job is destined
//*     [IN/OUT]        LIST_ENTRY * lpRecipientsGroup
//*         The recipient group to which the recipients should be added.
//*     [OUT]       LPDWORD dwRecipientCount
//*         The number of recipients added to the group. This is valid
//*         only if the function completed successfully.
//* RETURN VALUE:
//*     TRUE
//*         If the operation completed successfully.
//*     FALSE
//*         If the operation failed. Call GetLastError() for extended error
//*         information.
//*         When the function fails no recipient job will be added to the group.
//* REMARKS:
//*     g_CsQueue, g_CsJob and g_csEFSPJobGroups should be locked before calling
//*     this function.
//*********************************************************************************
BOOL CreateRecipientGroup(
    const PJOB_QUEUE lpcAnchorJob,
    const PLINE_INFO lpcLineInfo,
    LPEFSP_JOB_GROUP lpJobGroup)
{
    PLIST_ENTRY lpNext;
    PJOB_QUEUE lpParentJob;
    DWORD ec = 0;

    DEBUG_FUNCTION_NAME(TEXT("CreateRecipientGroup"));
    Assert(lpcAnchorJob);
    Assert(lpJobGroup);
    Assert(lpcLineInfo);
    lpParentJob = lpcAnchorJob->lpParentJob;
    Assert(lpParentJob);

    //
    // Go over the recipients in the anchor recipient parent and
    // add them to the recipient group if they are destined to the same
    // line and are ready for execution.

    //
    //  Add the anchor recipient.
    //
    if (!EFSPJobGroup_AddRecipient(lpJobGroup, lpcAnchorJob, FALSE)) // don't commit
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EFSPJobGroup_AddRecipient() failed for recipient job id: %ld (ec: %ld)"),
            lpcAnchorJob->JobId,
            ec);
        goto Error;
    }

    lpNext = lpParentJob->RecipientJobs.Flink;
    Assert(lpNext);
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpParentJob->RecipientJobs)
    {
        PJOB_QUEUE lpNextJob;
        PLINE_INFO lpLine;
        PJOB_QUEUE_PTR lpJobQueuePtr;

        lpJobQueuePtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNextJob=lpJobQueuePtr->lpJob;
        Assert(lpNextJob);
        lpNext = lpJobQueuePtr->ListEntry.Flink;

        //
        // Skip the anchor job - already added to the group
        //
        if (lpNextJob->JobId == lpcAnchorJob->JobId)
        {
            Assert (lpNextJob == lpcAnchorJob);
            continue;
        }

        if (!IsRecipientJobReadyForExecution(lpNextJob, lpcAnchorJob->ScheduleTime))
        {
            //
            // sibling job is not ready for execution.
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Recipient JobId: %ld FaxNumber: %s is NOT ready for execution."),
                lpNextJob->JobId,
                lpNextJob->RecipientProfile.lptstrFaxNumber);
            continue;
        } else
        {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Recipient JobId: %ld FaxNumber: %s is READY for execution."),
                lpNextJob->JobId,
                lpNextJob->RecipientProfile.lptstrFaxNumber);
        }
        //
        // Get the destination line for this job
        //
        lpLine = GetLineForSendOperation(
                    lpNextJob,
                    USE_SERVER_DEVICE,
                    TRUE, // Query only do not capture the line
                    TRUE  // Ignore line state.
                 );

        if (!lpLine)
        {
            ec = GetLastError();
            if (ERROR_NOT_FOUND == ec)
            {
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("No line found for for recipient JobId: %ld (FaxNumber: %s)"),
                    lpNextJob->JobId,
                    lpNextJob->RecipientProfile.lptstrFaxNumber);
                //
                // goto next recipient
                //
                continue;
            }
            else
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("GetLineForSendOperation() failed (ec: %ld)"),
                    ec);
                goto Error;
            }
        }

        //
        // Check if this is the same device as the line the original job is assigned to
        //
        if (lpLine->PermanentLineID != lpcLineInfo->PermanentLineID)
        {
            //
            // goto next recipient
            //
            continue;
        }
        Assert (lpLine == lpcLineInfo);

        //
        // The recipient is destined to the same line.
        // Add the job to the recipients group.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Adding Recipient JobId: %ld FaxNumber: %s to recipient group."),
            lpNextJob->JobId,
            lpNextJob->RecipientProfile.lptstrFaxNumber);

        if (!EFSPJobGroup_AddRecipient(lpJobGroup, lpNextJob, FALSE)) // don't commit
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSPJobGroup_AddRecipient() failed for recipient job id: %ld (ec: %ld)"),
                lpNextJob->JobId,
                ec);
            goto Error;
        }
    }
    Assert (0 == ec);
    goto Exit;

Error:
    Assert (0 != ec);

    //
    // Remove the recipient jobs we added
    //
    if (!EFSPJobGroup_RemoveAllRecipients(lpJobGroup, FALSE)) // don't commit
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EFSPJobGroup_RemoveAllRecipients() failed. (ec: %ld)"),
            GetLastError());
    }
Exit:
    if (0 != ec)
    {
        SetLastError(ec);
    }
    return (0 == ec);
}

//*********************************************************************************
//* Name:   FreeFSPIRecipientGroupJobs()
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     End the resources consumed by a recipient group.
//*         - Releases the reference count on the job.
//*         - Sets the job state to JS_RETRIES_EXCEEDED.
//*         - Calls FreeJobEntry() for each job.
//*         -
//* PARAMETERS:
//*     [IN/OUT]    LIST_ENTRY * lpRecipientsGroup
//*         Pointer to the head of a recipient group list.
//* RETURN VALUE:
//*     TRUE
//*         If the operation completed successfully.
//*     FALSE
//*         If the operation failed. Call GetLastError() for exteneded error
//*         information.
//*********************************************************************************
BOOL FreeFSPIRecipientGroupJobs(LIST_ENTRY * lpRecipientsGroup)
{
    LIST_ENTRY * lpNext;

    DEBUG_FUNCTION_NAME(TEXT("FreeRecipientGroup"));

    Assert(lpRecipientsGroup);

    lpNext = lpRecipientsGroup->Flink;
    Assert(lpNext);

    while ((ULONG_PTR)lpNext != (ULONG_PTR)lpRecipientsGroup) {
        PJOB_QUEUE_PTR lpGroupJobPtr;
        lpGroupJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpGroupJobPtr->ListEntry.Flink;
        //
        // we no longer use the job queue entry (we are protected by a CS when this is called).
        //

        Assert( ( 0 == lpGroupJobPtr->lpJob->RefCount ) || ( 0 == lpGroupJobPtr->lpJob->RefCount ) );

        lpGroupJobPtr->lpJob->RefCount = 0;
        //
        // Put the job into final error state.
        //
        // We need to define a state for FATAL_ERRORS
        //

        if (!FreePermanentMessageId(&lpGroupJobPtr->lpJob->EFSPPermanentMessageId, FALSE))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FreePermanentMessageId() during error cleanup for [JobId: %ld] has failed (ec: %ld)"),
                lpGroupJobPtr->lpJob->JobId,
                GetLastError());
        }

        //
        // set the job state to expired and commit job and parent.
        //
        if (0 == lpGroupJobPtr->lpJob->dwLastJobExtendedStatus)
        {
            //
            // Job was never really executed - this is a fatal error
            //
            lpGroupJobPtr->lpJob->dwLastJobExtendedStatus = FSPI_ES_FATAL_ERROR;
        }
        if (!MarkJobAsExpired(lpGroupJobPtr->lpJob))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
                lpGroupJobPtr->lpJob->JobId,
                GetLastError());
        }



        if (lpGroupJobPtr->lpJob->JobEntry)
        {
            lpGroupJobPtr->lpJob->JobEntry->Released = TRUE;

            if (!FreeJobEntry(lpGroupJobPtr->lpJob->JobEntry, TRUE))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("EndJob() failed for JobId: %ld (ec: %ld)"),
                    lpGroupJobPtr->lpJob->JobId,
                    GetLastError());
                Assert(FALSE);
            }
            else
            {
                lpGroupJobPtr->lpJob->JobEntry = NULL;
            }
        }
    }
    return TRUE;
}

//*********************************************************************************
//* Name:   FreeRecipientGroup()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Remove all the recipient group memebers from the list and
//*     fress the memory occupied by each member.
//*     (Note the members are of type JOB_GROUP_PTR and contain
//*      only pointers to the actual jobs. The jobs themselves
//*      are not freed).
//* PARAMETERS:
//*     [IN ]   LIST_ENTRY * lpRecipientsGroup
//*         The recipient group memeber to free.
//* RETURN VALUE:
//*     TRUE
//*********************************************************************************
BOOL FreeRecipientGroup(LIST_ENTRY * lpRecipientsGroup)
{
    LIST_ENTRY * lpNext;
    DEBUG_FUNCTION_NAME(TEXT("FreeRecipientGroup"));

    Assert(lpRecipientsGroup);

    //
    // Free all the group members
    //
    lpNext = lpRecipientsGroup->Flink;
    Assert(lpNext);
    while ((ULONG_PTR)lpNext != (ULONG_PTR)lpRecipientsGroup) {
        PJOB_QUEUE_PTR lpGroupJobPtr;
        lpGroupJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpGroupJobPtr->ListEntry.Flink;
        RemoveEntryList(&lpGroupJobPtr->ListEntry);
        MemFree(lpGroupJobPtr);
    }
    return TRUE;
}



//*********************************************************************************
//* Name:   CreateFSPIRecipientMessageIdsArray()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Allocates and initializes the permanent message id (FSPI_MESSAGE_ID) array
//*     required for a call to FaxDevSendEx().
//* PARAMETERS:
//*     [OUT]   LPFSPI_MESSAGE_ID * lppRecipientMessageIds
//*         The address of a pointer to a FSPI_MESSAGE_ID array. The function
//*         will allocate this array and return its address in this pointer.
//*     [IN ]   DWORD dwRecipientCount
//*         The number of recipient message ids to be placed in the array.
//*     [IN ]   DWORD dwMessageIdSize
//*         The size of each message id buffer. This can be 0 to inidicate
//*         no message id buffer.
//* RETURN VALUE:
//*     TRUE
//*         If the array was successfully created/
//*     FALSE
//*         If the array creation failed. Call GetLastError() to get extended
//*         error information.
//*         On failure the array is completely deallocated by the function.
//*********************************************************************************
BOOL CreateFSPIRecipientMessageIdsArray(
        LPFSPI_MESSAGE_ID * lppRecipientMessageIds,
        DWORD dwRecipientCount,
        DWORD dwMessageIdSize)
{

    DWORD dwRecipient;
    DWORD ec = 0;
    LPFSPI_MESSAGE_ID lpRecipientMessageIds;

    DEBUG_FUNCTION_NAME(TEXT("AllocateRecipientsMessageId"));
    Assert(lppRecipientMessageIds);
    Assert(dwRecipientCount >= 1);

    //
    // Allocate the permanent message id structures array.
    //
    lpRecipientMessageIds = (LPFSPI_MESSAGE_ID) MemAlloc( dwRecipientCount * sizeof (FSPI_MESSAGE_ID));
    if (!lpRecipientMessageIds)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate permanent message id structures array. RecipientCount: %ld (ec: %ld)"),
            dwRecipientCount,
            GetLastError());
        goto Error;
    }
    //
    // We must nullify the array (specifically FSPI_MESSAGE_ID.lpbId) so we will know
    // which id as alloocated and which was not (for cleanup).
    //
    memset(lpRecipientMessageIds, 0, dwRecipientCount * sizeof (FSPI_MESSAGE_ID));

    for (dwRecipient = 0; dwRecipient < dwRecipientCount; dwRecipient++)
    {
        lpRecipientMessageIds[dwRecipient].dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
        lpRecipientMessageIds[dwRecipient].dwIdSize = dwMessageIdSize;
        if (dwMessageIdSize)
        {
            Assert(lpRecipientMessageIds[dwRecipient].dwIdSize > 0);
            lpRecipientMessageIds[dwRecipient].lpbId = (LPBYTE)MemAlloc(lpRecipientMessageIds[dwRecipient].dwIdSize);
            if (!lpRecipientMessageIds[dwRecipient].lpbId)
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to allocate permanent message id buffer for recipient #%ld. MaxMessageIdSize: %ld. (ec: %ld)"),
                    dwRecipient,
                    dwMessageIdSize,
                    ec);
                goto Error;
            }
        }
        else
        {
            lpRecipientMessageIds[dwRecipient].lpbId = NULL;
        }
    }

    goto Exit;

Error:
    Assert (0 != ec);
    //
    // Free the message ids array
    //
    if (lpRecipientMessageIds)
    {
        //
        // Free the already allocated id buffers an the id array itself.
        //
        if (!FreeFSPIRecipientMessageIdsArray(lpRecipientMessageIds, dwRecipientCount))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FreeRecipientMessageIds() failed (ec: %ld)"),
                GetLastError());
            Assert(FALSE);
        }
        lpRecipientMessageIds = NULL;
    }

Exit:
    *lppRecipientMessageIds = lpRecipientMessageIds;
    if (ec)
    {
        SetLastError(ec);
    }
    return (0 == ec);
}


//*********************************************************************************
//* Name:   FreeFSPIRecipientMessageIdsArray()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Traverses the input recipient message id structures (FSPI_MESSAGE_ID) array
//*     and frees the id buffer for each entry. On completion it deallocates
//*     the array itself.
//*     Note: It assumes that unallocated id pointers are set to NULL !!!
//*
//* PARAMETERS:
//*     [IN ]   LPFSPI_MESSAGE_ID lpRecipientMessageIds
//*         The message id structures array to be freed.
//*         For each member FSPI_MESSAGE_ID.lpbId must be set by the caller to
//*         NULL to indicate unallocated id buffer !!!
//*
//*     [IN ]    DWORD dwRecipientCount
//*         The number of recipient message ids in the array.
//* RETURN VALUE:
//*     TRUE
//*********************************************************************************
BOOL FreeFSPIRecipientMessageIdsArray(
        LPFSPI_MESSAGE_ID lpRecipientMessageIds,
        DWORD dwRecipientCount
     )
{
    DWORD dwRecipient;
    DEBUG_FUNCTION_NAME(TEXT("FreeFSPIRecipientMessageIdsArray"));
    Assert(lpRecipientMessageIds);
    //
    // Free the already allocated message ids
    //
    for (dwRecipient = 0;dwRecipient < dwRecipientCount; dwRecipient++)
    {
        MemFree(lpRecipientMessageIds[dwRecipient].lpbId);
        lpRecipientMessageIds[dwRecipient].dwIdSize = 0;
    }
    MemFree(lpRecipientMessageIds);
    return TRUE;
}


//*********************************************************************************
//* Name:   CopyPermanentMessageId()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Copies the content ofa a permanent message id (EFSP).
//* PARAMETERS:
//*     [OUT]   LPFSPI_MESSAGE_ID lpMessageIdDst
//*         A pointer to a FSPI_MESSAGE_ID structure into which to copy.
//*     [IN ]    LPCFSPI_MESSAGE_ID lpcMessageIdSrc
//*         A pointer to the FSPI_MESSAGE_ID structure of source message id.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the copy operation succeeded.
//*     FALSE
//*         If the copy operation failed. Call GetLastError() to get extended error information.
//*********************************************************************************
BOOL CopyPermanentMessageId(LPFSPI_MESSAGE_ID lpMessageIdDst, LPCFSPI_MESSAGE_ID lpcMessageIdSrc)
{
    DWORD ec = 0;

    DEBUG_FUNCTION_NAME(TEXT("CopyMessagePermanentId"));

    Assert(lpMessageIdDst);
    Assert(lpcMessageIdSrc);

    lpMessageIdDst->dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
    lpMessageIdDst->dwIdSize = lpcMessageIdSrc->dwIdSize;
    if (lpcMessageIdSrc->dwIdSize)
    {
        lpMessageIdDst->lpbId = (LPBYTE)MemAlloc(lpcMessageIdSrc->dwIdSize);
        if (!lpMessageIdDst->lpbId)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for destination permanent message buffer.(ec: %ld)"),
                ec);
            goto Error;
        }
        memcpy(lpMessageIdDst->lpbId,
               lpcMessageIdSrc->lpbId,
               lpcMessageIdSrc->dwIdSize);
    }
    else
    {
        lpMessageIdDst->lpbId = NULL;
    }
    Assert (0 == ec);
    goto Exit;
Error:
    Assert( 0 != ec);
Exit:
    if (ec)
    {
        SetLastError(ec);
    }
    return (0 == ec);

}


//*********************************************************************************
//* Name:   FreePermanentMessageId()
//* Author: Ronen Barenboim
//* Date:   June 07, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Frees a FSPI permanent id structure.
//* PARAMETERS:
//*     [IN]    LPFSPI_MESSAGE_ID * lppMessageId
//*         The address of a FSPI_MESSAGE_ID structure to free.
//*     [IN ]    BOOL bDestroy
//*         True if the structure itseld need to be freed. FALSE if only its
//*         content need to be freed.
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If the operation failed. Call GetLastError() for extended error
//*         information.
//* REMARKS:
//*     On success:
//*         FSPI_MESSAGE_ID.lpbId will be set to NULL.
//*         FSPI_MESSAGE_ID.dwIdSize will be set to 0.
//*         if bDestroy == TRUE then (*lppMessageId) will be set to NULL.
//*********************************************************************************
BOOL FreePermanentMessageId(LPFSPI_MESSAGE_ID lpMessageId, BOOL bDestroy)
{

    if (!lpMessageId)
    {
        return TRUE;
    }
    Assert(lpMessageId);
    Assert( !(( NULL == lpMessageId->lpbId ) && (lpMessageId->dwIdSize != 0) ));
    MemFree(lpMessageId->lpbId);
    lpMessageId->lpbId = NULL;
    lpMessageId->dwIdSize = 0;
    if (bDestroy)
    {
        MemFree(lpMessageId);
    }
    return TRUE;
}


//*********************************************************************************
//* Name:   FaxPersonalProfileToFSPIPersonalProfile()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Converts a FAX_PERSONAL_PROFILE structure to a FSPI_PERSONAL_PROFILE
//*     structure.
//* PARAMETERS:
//*     [OUT]   LPFSPI_PERSONAL_PROFILE lpDst
//*         Pointer to the target FSPI_PERSONAL_PROFILE structure.
//*     [IN ]   LPCFAX_PERSONAL_PROFILE lpcSrc
//*         Pointer to the source FAX_PERSONAL_PROFILE structure.
//*
//* RETURN VALUE:
//*     TRUE
//*
//* REMARKS:
//*     The function does not allocate any memory. It just sets the target
//*     structure string pointers to point to the relevant source structure
//*     string pointers.
//*********************************************************************************
BOOL FaxPersonalProfileToFSPIPersonalProfile(LPFSPI_PERSONAL_PROFILE lpDst, LPCFAX_PERSONAL_PROFILE lpcSrc)
{
    DEBUG_FUNCTION_NAME(TEXT("FaxPersonalProfileToFSPIPersonalProfile"));

    Assert(lpDst);
    Assert(lpcSrc);
    lpDst->dwSizeOfStruct = sizeof(FSPI_PERSONAL_PROFILE);
    lpDst->lpwstrName           = lpcSrc->lptstrName;
    lpDst->lpwstrFaxNumber      = lpcSrc->lptstrFaxNumber;
    lpDst->lpwstrCompany        = lpcSrc->lptstrCompany;
    lpDst->lpwstrStreetAddress  = lpcSrc->lptstrStreetAddress;
    lpDst->lpwstrCity           = lpcSrc->lptstrCity;
    lpDst->lpwstrState          = lpcSrc->lptstrState;
    lpDst->lpwstrZip            = lpcSrc->lptstrZip;
    lpDst->lpwstrCountry        = lpcSrc->lptstrCountry;
    lpDst->lpwstrTitle          = lpcSrc->lptstrTitle;
    lpDst->lpwstrDepartment     = lpcSrc->lptstrDepartment;
    lpDst->lpwstrOfficeLocation = lpcSrc->lptstrOfficeLocation;
    lpDst->lpwstrHomePhone      = lpcSrc->lptstrHomePhone;
    lpDst->lpwstrOfficePhone    = lpcSrc->lptstrOfficePhone;
    lpDst->lpwstrEmail          = lpcSrc->lptstrEmail;
    lpDst->lpwstrBillingCode    = lpcSrc->lptstrBillingCode;
    lpDst->lpwstrTSID           = lpcSrc->lptstrTSID;
    return TRUE;

}


//*********************************************************************************
//* Name:   FaxCoverPageToFSPICoverPage()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Converts a FAX_COVERPAGE_INFO_EXW structure to a FSPI_COVERPAGE_INFO
//*     structure.
//* PARAMETERS:
//*     [OUT]   LPFSPI_COVERPAGE_INFO lpDst
//*         Pointer to the target FSPI_COVERPAGE_INFO structure.
//*     [IN ]    LPCFAX_COVERPAGE_INFO_EXW lpcSrc
//*         Pointer to the source FAX_COVERPAGE_INFO_EXW structure.
//*     [IN]    DWORD dwPageCount
//*         The number of pages in this job.
//*
//* RETURN VALUE:
//*     TRUE
//*
//* REMARKS:
//*     The function does not allocate any memory. It just sets the target
//*     structure string pointers to point to the relevant source structure
//*     string pointers.
//*********************************************************************************
BOOL
FaxCoverPageToFSPICoverPage(
    LPFSPI_COVERPAGE_INFO lpDst,
    LPCFAX_COVERPAGE_INFO_EXW lpcSrc,
    DWORD dwPageCount)
{
    DEBUG_FUNCTION_NAME(TEXT("FaxCoverPageToFSPICoverPage"));
    Assert(lpDst);
    Assert(lpcSrc);

    lpDst->dwSizeOfStruct = sizeof(FSPI_COVERPAGE_INFO);
    lpDst->dwCoverPageFormat = lpcSrc->dwCoverPageFormat;
    lpDst->lpwstrCoverPageFileName = lpcSrc->lptstrCoverPageFileName;
    lpDst->lpwstrNote = lpcSrc->lptstrNote;
    lpDst->lpwstrSubject = lpcSrc->lptstrSubject;
    lpDst->dwNumberOfPages = dwPageCount;
    return TRUE;
}

//*********************************************************************************
//* Name:   CreateFSPIRecipientProfilesArray()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates an array of FSPI_PERSONAL_PROFILE structures with the recipient
//*     information in the specified recipient group.
//*
//* PARAMETERS:
//*     [OUT]       LPFSPI_PERSONAL_PROFILE * lppRecipientProfiles
//*         The address of a pointer to a FSPI_PERSONAL_PROFILE array. The function
//*         will allocated this array and return its address in this pointer.
//*     [IN ]       DWORD dwRecipientCount
//*         The number of recipients in the recipient group.
//*     [IN ]       const LIST_ENTRY * lpcRecipientsGroup
//*         A recipient group for which the recipient profiles array should be
//*         created.
//* RETURN VALUE:
//*     TRUE
//*         On succesfull creation.
//*     FALSE
//*         If the creation failed. Call GetLastError() for extended error info.
//*         The function takes care of cleaning up any parital results.
//*********************************************************************************
BOOL CreateFSPIRecipientProfilesArray(
    LPFSPI_PERSONAL_PROFILE * lppRecipientProfiles,
    DWORD dwRecipientCount,
    const LIST_ENTRY * lpcRecipientsGroup
    )
{
    const LIST_ENTRY * lpNext;
    LPFSPI_PERSONAL_PROFILE lpRecipientProfiles = NULL;
    DWORD dwRecipient;
    DWORD ec = 0;

    DEBUG_FUNCTION_NAME(TEXT("CreateFSPIRecipientProfilesArray"));
    Assert(lppRecipientProfiles);
    Assert(lpcRecipientsGroup);
    Assert(dwRecipientCount > 0);

    //
    // Allocate the recipient profile array
    //
    lpRecipientProfiles = (LPFSPI_PERSONAL_PROFILE) MemAlloc(dwRecipientCount * sizeof(FSPI_PERSONAL_PROFILE));
    if (!lpRecipientProfiles)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate memory for recipient profiles array (RecipientCount: %ld)(ec: %ld)"),
            dwRecipientCount,
            ec);
        goto Error;
    }

    //
    // Populate the recipient infromation array with recipient information. Does NOT allocate any memeory in
    // the process. (Just copies string pointers).
    //
    dwRecipient = 0;
    lpNext = lpcRecipientsGroup->Flink;
    while ((ULONG_PTR)lpNext != (ULONG_PTR)lpcRecipientsGroup) {
        PJOB_QUEUE_PTR lpRecipientsGroupMember;
        lpRecipientsGroupMember = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpNext->Flink;
        Assert(dwRecipient < dwRecipientCount);
        if (!FaxPersonalProfileToFSPIPersonalProfile(
                &lpRecipientProfiles[dwRecipient],
                (LPCFAX_PERSONAL_PROFILEW)&lpRecipientsGroupMember->lpJob->RecipientProfile))
        {
            //
            // Note: FaxPersonalProfileToFSPIPersonalProfile only copies pointers. It does not allocate memeory !!!
            //
            ec= GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxPersonalProfileToFSPIPersonalProfile() failed for recipient( Name: %s Number: %s)(ec: %ld)"),
                lpRecipientsGroupMember->lpJob->JobId,
                lpRecipientsGroupMember->lpJob->RecipientProfile.lptstrName,
                lpRecipientsGroupMember->lpJob->RecipientProfile.lptstrFaxNumber,
                ec);
            goto Error;
        }
        dwRecipient++;
    }
    *lppRecipientProfiles = lpRecipientProfiles;
    Assert (0 == ec);
    goto Exit;
Error:
    *lppRecipientProfiles = NULL;
    Assert( 0 != ec);
    MemFree(lpRecipientProfiles);

Exit:
    if (ec)
    {
        SetLastError(ec);
    }

    return ( 0 == ec);
}




//*********************************************************************************
//* Name:   HandleCompletedSendJob()
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Handles the completion of a recipient job. Called when a recipient job
//*     has reaced a JS_COMPLETED state.
//*
//*     IMPORTANT- This call can be blocking. Calling thread MUST NOT hold any critical section
//*
//*     - Marks the job as completed (JS_COMPLETED).
//*     - Archives the sent file if required.
//*     - Sends a positive receipt
//*     - Removes the parent job if required.
//*
//* PARAMETERS:
//*     [IN ]   PJOB_ENTRY lpJobEntry
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation completed successfully.
//*     FALSE
//*         If the operation failed. Call GetLastError() for extended errror
//*         information.
//*********************************************************************************
BOOL HandleCompletedSendJob(PJOB_ENTRY lpJobEntry)
{
    PJOB_QUEUE lpJobQueue = NULL;
    DWORD ec = 0;
    BOOL fCOMInitiliazed = FALSE;
    HRESULT hr;

    BOOL bArchiveSentItems;
    DWORD dwRes;

    DEBUG_FUNCTION_NAME(TEXT("HandleCompletedSendJob)"));

    EnterCriticalSection ( &g_CsJob );

    EnterCriticalSection (&g_CsConfig);
    bArchiveSentItems = g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].bUseArchive;
    LeaveCriticalSection (&g_CsConfig);

    Assert(lpJobEntry);
    lpJobQueue = lpJobEntry->lpJobQueueEntry;
    Assert(lpJobQueue);
    Assert(JT_SEND == lpJobQueue->JobType);
    Assert(FSPI_JS_COMPLETED == lpJobEntry->FSPIJobStatus.dwJobStatus);

    //
    // Update end time in JOB_ENTRY
    //
    GetSystemTimeAsFileTime( (FILETIME*) &lpJobEntry->EndTime );
    //
    // Update elapsed time in JOB_ENTRY
    //
    Assert (lpJobEntry->EndTime >= lpJobEntry->StartTime);
    lpJobEntry->ElapsedTime = lpJobEntry->EndTime - lpJobEntry->StartTime;
    //
    // We generate a full tiff for each recipient
    // so we will have something to put in the send archive.
    //

    if (!lpJobQueue->FileName)
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId: %ld] Generating body for recipient job."),
            lpJobQueue->JobId
            );

        if (!CreateTiffFileForJob(lpJobQueue))
        {
            USES_DWORD_2_STR;
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] CreateTiffFileForJob failed. (ec: %ld)"),
                lpJobQueue->JobId,
                dwRes);

            FaxLog(
               FAXLOG_CATEGORY_OUTBOUND,
               FAXLOG_LEVEL_MIN,
               1,
               MSG_FAX_TIFF_CREATE_FAILED_NO_ARCHIVE,
           g_wszFaxQueueDir,
               DWORD2DECIMAL(dwRes)
            );
        }
    }

    // Needed for Archiving
    hr = CoInitialize (NULL);
    if (FAILED (hr))
    {
        WCHAR       wszArchiveFolder[MAX_PATH];
        EnterCriticalSection (&g_CsConfig);
        lstrcpyn (  wszArchiveFolder,
                    g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder,
                    MAX_PATH);
        LeaveCriticalSection (&g_CsConfig);

        DebugPrintEx( DEBUG_ERR,
                      TEXT("CoInitilaize failed, err %ld"),
                      hr);
        USES_DWORD_2_STR;
        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MIN,
            3,
            MSG_FAX_ARCHIVE_FAILED,
            lpJobQueue->FileName,
            wszArchiveFolder,
            DWORD2DECIMAL(hr)
        );
    }
    else
    {
        fCOMInitiliazed = TRUE;
    }

    if (lpJobQueue->FileName) //might be null if we failed to generate a TIFF
    {
        //
        // Archive the file (also adds MS Tags to the tiff at the archive directory)
        //
        if (bArchiveSentItems && fCOMInitiliazed)
        {
            if (!ArchiveOutboundJob(lpJobQueue))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("JobId: %ld] ArchiveOutboundJob() failed (ec: %ld)"),
                    lpJobQueue->JobId,
                    GetLastError());
                //
                // The event log entry is generated by the function itself
                //
            }
        }
    }
    //
    // Log the succesful send to the event log
    //
    EnterCriticalSection (&g_CsOutboundActivityLogging);
    if (INVALID_HANDLE_VALUE == g_hOutboxActivityLogFile)
    {
        DebugPrintEx(DEBUG_ERR,
                  TEXT("Logging not initialized"));
    }
    else
    {
        if (!LogOutboundActivity(lpJobQueue))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("Logging outbound activity failed"));
        }
    }
    LeaveCriticalSection (&g_CsOutboundActivityLogging);

    if (fCOMInitiliazed == TRUE)
    {
        CoUninitialize ();
    }

    FaxLogSend(lpJobQueue,  FALSE);

    //
    // Increment counters for Performance Monitor
    //
    if (g_pFaxPerfCounters)
    {

         if (!UpdatePerfCounters(lpJobQueue))
         {
             DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("[JobId: %ld] UpdatePerfCounters() failed. (ec: %ld)"),
                 lpJobQueue->JobId,
                 GetLastError());
            Assert(FALSE);
         }
    }

    EnterCriticalSection ( &g_CsQueue );
    //
    // Mark the job as completed (new client API)
    //
    lpJobQueue->JobStatus = JS_COMPLETED;
    //
    // Save the last extended status before ending this job
    //
    lpJobQueue->dwLastJobExtendedStatus = lpJobQueue->JobEntry->FSPIJobStatus.dwExtendedStatus;
    lstrcpy (lpJobQueue->ExStatusString, lpJobQueue->JobEntry->ExStatusString);

    if (!UpdatePersistentJobStatus(lpJobQueue))
    {
         DebugPrintEx(
             DEBUG_ERR,
             TEXT("Failed to update persistent job status to 0x%08x"),
             lpJobQueue->JobStatus);
         Assert(FALSE);
    }

    lpJobQueue->lpParentJob->dwCompletedRecipientJobsCount+=1;

    //
    // Create Fax EventEx
    //
    dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS, lpJobQueue );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
            lpJobQueue->UniqueId,
            dwRes);
    }

    //
    // We will send the receipt once we are out of all critical sections because this call can be blocking.
    // just increase the preview refernce count so the job will not be deleted.
    //
    IncreaseJobRefCount (lpJobQueue, TRUE); // TRUE - preview
    //
    // Copy receipt information from JobEntry.
    //
    lpJobQueue->StartTime           = lpJobQueue->JobEntry->StartTime;
    lpJobQueue->EndTime             = lpJobQueue->JobEntry->EndTime;


    //
    // EndJob() must be called BEFORE we remove the parent job (and recipients)
    //
    lpJobQueue->JobEntry->LineInfo->State = FPS_AVAILABLE;
    //
    // We just completed a send job on the device - update counter.
    //
    (VOID) UpdateDeviceJobsCounter (lpJobQueue->JobEntry->LineInfo,   // Device to update
                                    TRUE,                             // Sending
                                    -1,                               // Number of new jobs (-1 = decrease by one)
                                    TRUE);                            // Enable events

    if (!EndJob( lpJobQueue->JobEntry ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EndJob Failed. (ec: %ld)"),
            GetLastError());
    }

    lpJobQueue->JobEntry = NULL;
    DecreaseJobRefCount (lpJobQueue, TRUE);  // This will mark it as JS_DELETING if needed
    //
    // Notify the queue that a device is now available.
    //
    if (!SetEvent( g_hJobQueueEvent ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
            GetLastError());

        g_ScanQueueAfterTimeout = TRUE;
    }
    LeaveCriticalSection ( &g_CsQueue );
    LeaveCriticalSection ( &g_CsJob );

    //
    // Now send the receipt
    //
    if (!SendJobReceipt (TRUE, lpJobQueue, lpJobQueue->FileName))
    {
        ec = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] SendJobReceipt failed. (ec: %ld)"),
            lpJobQueue->JobId,
            ec
            );
    }
    EnterCriticalSection (&g_CsQueue);
    DecreaseJobRefCount (lpJobQueue, TRUE, TRUE, TRUE);  // last TRUE for Preview ref count.
    LeaveCriticalSection (&g_CsQueue);
    return TRUE;
}   // HandleCompletedSendJob


//*********************************************************************************
//* Name:   HandleFailedSendJob()
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Handles the post failure operations of a send job.
//*
//*     IMPORTANT- This call can be blocking. Calling thread MUST NOT hold any critical section
//*
//* PARAMETERS:
//*     [IN ]   PJOB_ENTRY lpJobEntry
//*         The job that failed. It must be in FSPI_JS_ABORTED or FSPI_JS_FAILED
//*         state.
//* RETURN VALUE:
//*     TRUE
//*         If the operation completed successfully.
//*     FALSE
//*         If the operation failed. Call GetLastError() for extended errror
//*         information.
//*********************************************************************************
BOOL HandleFailedSendJob(PJOB_ENTRY lpJobEntry)
{
    PJOB_QUEUE lpJobQueue;
    BOOL bRetrying = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("HandleFailedSendJob"));
    DWORD dwRes;
    TCHAR tszJobTiffFile[MAX_PATH] = {0};    // Deleted after receipt is sent
    BOOL fAddRetryDelay = TRUE;

    EnterCriticalSection ( &g_CsJob );
    EnterCriticalSection ( &g_CsQueue );

    Assert(lpJobEntry);
    lpJobQueue = lpJobEntry->lpJobQueueEntry;
    Assert(lpJobQueue);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Failed Job: %ld"),
        lpJobQueue->JobId);

    Assert( FSPI_JS_ABORTED == lpJobEntry->FSPIJobStatus.dwJobStatus ||
            FSPI_JS_FAILED == lpJobEntry->FSPIJobStatus.dwJobStatus ||
            FSPI_JS_FAILED_NO_RETRY == lpJobEntry->FSPIJobStatus.dwJobStatus ||
            FSPI_JS_DELETED == lpJobEntry->FSPIJobStatus.dwJobStatus ||
            FSPI_JS_SYSTEM_ABORT == lpJobEntry->FSPIJobStatus.dwJobStatus);
    //
    // Do not cache rendered tiff files
    //
    if (lpJobQueue->FileName)
    {
        //
        // We simply store the file name to delete and delete it later
        // since we might need it for receipt attachment.
        //
        _tcsncpy (tszJobTiffFile,
                  lpJobQueue->FileName,
                  sizeof (tszJobTiffFile) / sizeof (tszJobTiffFile[0]));
        MemFree (lpJobQueue->FileName);
        lpJobQueue->FileName = NULL;
    }
    //
    // Update end time in JOB_ENTRY
    //
    GetSystemTimeAsFileTime( (FILETIME*) &lpJobEntry->EndTime );

    //
    // Update elapsed time in JOB_ENTRY
    //
    Assert (lpJobEntry->EndTime >= lpJobEntry->StartTime);
    lpJobEntry->ElapsedTime = lpJobEntry->EndTime - lpJobEntry->StartTime;
    if ( FSPI_JS_ABORTED == lpJobEntry->FSPIJobStatus.dwJobStatus)
    {
        //
        // The FSP reported the job was aborted.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job Id: %ld] EFSP reported that job was aborted."),
            lpJobQueue->JobId);
        //
        // The event log about a canceled job will be reported at the end of this if..else block.
        //
        lpJobEntry->Aborting = 1;
        bRetrying = FALSE;  // Do not retry on cancel
    }
    else if ( FSPI_JS_FAILED == lpJobEntry->FSPIJobStatus.dwJobStatus)
    {
        switch (lpJobEntry->FSPIJobStatus.dwExtendedStatus)
        {
            case FSPI_ES_LINE_UNAVAILABLE:
                //
                // this is the glare condition. Someone snatched the line before the FSP
                // had a chance to grab it.
                // We will try again but will not increase the retry count.
                //
                EnterCriticalSection (&g_CsLine);
                //
                // Check if the line was busy or closed
                //
                if (!(lpJobEntry->LineInfo->Flags & FPF_VIRTUAL))
                {
                    //
                    // Tapi line
                    //
                    if (NULL == lpJobEntry->LineInfo->hLine)
                    {
                        //
                        // Tapi worker thread got LINE_CLOSE
                        //
                        fAddRetryDelay = FALSE;
                    }
                }
                LeaveCriticalSection (&g_CsLine);

                bRetrying = TRUE;
                if (g_pFaxPerfCounters)
                {
                    //
                    // Increase the 'Outbound failed connections' counter.
                    //
                    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFailedConnections );
                }
                //
                // Don't increase the retry count since this is not really a failure.
                //
                break;

            case FSPI_ES_NO_ANSWER:
            case FSPI_ES_NO_DIAL_TONE:
            case FSPI_ES_DISCONNECTED:
            case FSPI_ES_BUSY:
            case FSPI_ES_NOT_FAX_CALL:
                //
                // For these error codes we need to retry
                //
                bRetrying = CheckForJobRetry(lpJobQueue);
                if (g_pFaxPerfCounters)
                {
                    //
                    // Increase the 'Outbound failed connections' counter.
                    //
                    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFailedConnections );
                }
                break;

            case FSPI_ES_FATAL_ERROR:
                //
                // For these error codes we need to retry
                //
                bRetrying = CheckForJobRetry(lpJobQueue);
                if (g_pFaxPerfCounters)
                {
                    //
                    // Increase the 'Outbound failed transmissions' counter.
                    //
                    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFailedXmit );
                }
                break;
            case FSPI_ES_BAD_ADDRESS:
            case FSPI_ES_CALL_DELAYED:
            case FSPI_ES_CALL_BLACKLISTED:
                //
                // No retry for these error codes
                //
                bRetrying = FALSE;
                if (g_pFaxPerfCounters)
                {
                    //
                    // Increase the 'Outbound failed connections' counter.
                    //
                    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFailedConnections );
                }
                break;
            default:
                //
                // Our default for extension codes
                // is to retry.
                //
                bRetrying = CheckForJobRetry(lpJobQueue);
                if (g_pFaxPerfCounters)
                {
                    //
                    // Increase the 'Outbound failed transmissions' counter.
                    //
                    InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->OutboundFailedXmit );
                }
                break;
        }

    }
    else if ( FSPI_JS_FAILED_NO_RETRY == lpJobEntry->FSPIJobStatus.dwJobStatus )
    {
        //
        // The FSP indicated that there is no point in retrying this job.
        //
        bRetrying = FALSE;
    }
    else if ( FSPI_JS_DELETED == lpJobEntry->FSPIJobStatus.dwJobStatus )
    {
        //
        // This is the case where the job can not be reestablished
        // we treat it as a failure with no retry.
        bRetrying = FALSE;
    }
    else if ( FSPI_JS_SYSTEM_ABORT == lpJobEntry->FSPIJobStatus.dwJobStatus )
    {
        //
        // T30 reported FaxDevShutDown() was called.
        // Don't increase the retry count since this is not really a failure.
        //
        bRetrying = TRUE;
        fAddRetryDelay = FALSE;
    }

    FaxLogSend(
        lpJobQueue,
        bRetrying
        );

    if (!bRetrying)
    {
        EnterCriticalSection (&g_CsOutboundActivityLogging);
        if (INVALID_HANDLE_VALUE == g_hOutboxActivityLogFile)
        {
            DebugPrintEx(DEBUG_ERR,
                      TEXT("Logging not initialized"));
        }
        else
        {
            if (!LogOutboundActivity(lpJobQueue))
            {
                DebugPrintEx(DEBUG_ERR, TEXT("Logging outbound activity failed"));
            }
        }
        LeaveCriticalSection (&g_CsOutboundActivityLogging);
    }

    //
    // Save the last extended status before ending this job
    //
    lpJobQueue->dwLastJobExtendedStatus = lpJobEntry->FSPIJobStatus.dwExtendedStatus;
    lstrcpy (lpJobQueue->ExStatusString, lpJobQueue->JobEntry->ExStatusString);

    if (!bRetrying && !lpJobEntry->Aborting)
    {
        //
        // If we do not handle an abort request (in this case we do not want
        // to count it as a failure since it will be counted as Canceled) and we decided
        // not to retry then we need to mark the job as expired.
        //
        if (0 == lpJobQueue->dwLastJobExtendedStatus)
        {
            //
            // Job was never really executed - this is a fatal error
            //
            lpJobQueue->dwLastJobExtendedStatus = FSPI_ES_FATAL_ERROR;
            lstrcpy (lpJobQueue->ExStatusString, TEXT(""));
        }
        if (!MarkJobAsExpired(lpJobQueue))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError());
        }
    }

    if (lpJobEntry->Aborting )
    {
        //
        // An abort operation is in progress for this job.
        // No point in retrying.
        // Just mark the job as canceled and see if we can remove the parent job yet.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId: %ld] lpJobEntry->Aborting is ON."));

         lpJobQueue->JobStatus = JS_CANCELED;
         if (!UpdatePersistentJobStatus(lpJobQueue)) {
             DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Failed to update persistent job status to 0x%08x"),
                 lpJobQueue->JobStatus);
             Assert(FALSE);
         }
         lpJobQueue->lpParentJob->dwCanceledRecipientJobsCount+=1;
         bRetrying = FALSE;


    }
    else if (lpJobEntry->HandoffJob)
    {
        //
        // Handoff jobs in error are not retried
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] Handoff Job has failed and is now deleted."),
            lpJobQueue->JobId);
        bRetrying = FALSE;
    }

    if (!bRetrying)
    {
        //
        // Job reached final failure state - send negative receipt
        // We will send the receipt once we are out of all critical sections because this call can be blocking.
        // just increase the preview refernce count so the job will not be deleted.
        //
        IncreaseJobRefCount (lpJobQueue, TRUE); // TRUE - preview
        //
        // Copy receipt information from JobEntry.
        //
        lpJobQueue->StartTime           = lpJobQueue->JobEntry->StartTime;
        lpJobQueue->EndTime             = lpJobQueue->JobEntry->EndTime;
    }
    else
    {
        //
        // Job marked for retry. Do not delete it. Reschedule it.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId: %ld] Set for retry (JS_RETRYING). Retry Count = %ld)"),
            lpJobQueue->JobId,
            lpJobQueue->SendRetries);

        lpJobQueue->JobStatus = JS_RETRYING;
        lpJobQueue->JobEntry = NULL;
        if (TRUE == fAddRetryDelay)
        {
            //
            // Send failure - Reschedule
            //
            RescheduleJobQueueEntry( lpJobQueue );
        }
        else
        {
            //
            // FaxDevShutDown() was called, or We lost the line, Do not add retry delay
            //
            if (!CommitQueueEntry(lpJobQueue))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CommitQueueEntry() for recipien job %s has failed. (ec: %ld)"),
                    lpJobQueue->FileName,
                    GetLastError());
            }
        }
    }

    //
    // Notify clients on status change
    //
    dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS, lpJobQueue);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
            lpJobQueue->UniqueId,
            dwRes);
    }
    //
    // EndJob() must be called BEFORE we remove the parent job (and recipients)
    //
    lpJobEntry->LineInfo->State = FPS_AVAILABLE;
    //
    // We just completed a send job on the device - update counter.
    //
    (VOID) UpdateDeviceJobsCounter ( lpJobEntry->LineInfo,             // Device to update
                                     TRUE,                             // Sending
                                     -1,                               // Number of new jobs (-1 = decrease by one)
                                     TRUE);                            // Enable events

    if (!EndJob( lpJobEntry ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EndJob Failed. (ec: %ld)"),
            GetLastError());
    }

    lpJobQueue->JobEntry = NULL;

    if (JS_CANCELED == lpJobQueue->JobStatus)
    {

        DWORD dwJobId;

        dwJobId = lpJobQueue->JobId;

        // Job was canceled - decrease reference count
        DecreaseJobRefCount (lpJobQueue, TRUE);  // This will mark it as JS_DELETING if needed
         //
         // We need to send the legacy W2K FEI_DELETING notification.
         //
         if (!CreateFaxEvent(0, FEI_DELETED, dwJobId))
        {

            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFaxEvent() failed. Event: 0x%08X JobId: %ld DeviceId:  (ec: %ld)"),
                FEI_DELETED,
                lpJobQueue->JobId,
                0,
                GetLastError());
        }
    }

    //
    // Notify the queue that a device is now available.
    //
    if (!SetEvent( g_hJobQueueEvent ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
            GetLastError());

        g_ScanQueueAfterTimeout = TRUE;
    }

    LeaveCriticalSection ( &g_CsQueue );
    LeaveCriticalSection ( &g_CsJob );

    //
    // Now, send the receipt
    //
    if (!bRetrying)
    {
        //
        // Job reached final failure state - send negative receipt
        //
        if (!SendJobReceipt (FALSE, lpJobQueue, tszJobTiffFile))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] SendJobReceipt failed. (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError ());
        }
        EnterCriticalSection (&g_CsQueue);
        DecreaseJobRefCount (lpJobQueue, TRUE, TRUE, TRUE);  // last TRUE for Preview ref count.
        LeaveCriticalSection (&g_CsQueue);
    }

    if (lstrlen (tszJobTiffFile))
    {
        //
        // Now we can safely delete the job's TIFF file
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("Deleting per recipient body file %s"),
                     tszJobTiffFile);
        if (!DeleteFile( tszJobTiffFile ))
        {
            DebugPrintEx(DEBUG_MSG,
                         TEXT("Failed to delete per recipient body file %s (ec: %ld)"),
                         tszJobTiffFile,
                         GetLastError());
            Assert(FALSE);
        }
    }
    return TRUE;
}   // HandleFailedSendJob


//*********************************************************************************
//* Name:   StartReceiveJob()
//* Author: Ronen Barenboim
//* Date:   June 02, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Starts a receive job on the specified device.
//* PARAMETERS:
//*     [IN ]       DWORD DeviceId
//*         The permanent line id (not TAPI) of the device on which the fax is
//*         to be received.
//*
//* RETURN VALUE:
//*
//*********************************************************************************
PJOB_ENTRY
StartReceiveJob(
    DWORD DeviceId
    )

{
    BOOL Failure = TRUE;
    PJOB_ENTRY JobEntry = NULL;
    PLINE_INFO LineInfo;
    BOOL bRes = FALSE;

    DWORD rc = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("StartRecieveJob"));

    LineInfo = GetTapiLineForFaxOperation(
                    DeviceId,
                    JT_RECEIVE,
                    NULL,
                    FALSE,  // NO handoff
                    FALSE,  // Don't just query - get hold of line
                    FALSE   // Ignore when using a specific device id.
                    );

    if (!LineInfo)
    {
        //
        // Could not find a line to send the fax on.
        //
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Failed to find a line to send the fax on. (ec: %ld)"),
            rc);
        goto exit;
    }

    JobEntry = CreateJobEntry(NULL, LineInfo, FALSE, FALSE);
    if (!JobEntry)
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create JobEntry. (ec: %ld)"),
            rc);
        goto exit;
    }

    __try
    {
        //
        // Call the FSP associated with the line to start a fax job. Note that at this
        // point it is not known if the job is send or receive.
        //
        bRes = LineInfo->Provider->FaxDevStartJob(
                LineInfo->hLine,
                LineInfo->DeviceId,
                (PHANDLE) &JobEntry->InstanceData, // JOB_ENTRY.InstanceData is where the FSP will place its
                                                   // job handle (fax handle).
                g_StatusCompletionPortHandle,
                (ULONG_PTR) LineInfo ); // Note that the completion key provided to the FSP is the LineInfo
                                        // pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        rc = ERROR_INVALID_FUNCTION;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxDevStartJob() on DeviceId: 0x%08X * CRASHED * (Exception: %ld)."),
            DeviceId,
            GetExceptionCode());
        goto exit;
    }

    if (!bRes)
    {
        rc = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("FaxDevStartJob failed (ec: %ld)"),GetLastError());
        goto exit;
    }

    //
    // Associate the job entry with the FSP job handle
    //
    rc = AddFspJob(LineInfo->Provider->hJobMap,
                   (HANDLE) JobEntry->InstanceData,
                   JobEntry);
    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("[Job: %ld] AddFspJob failed (ec: %ld)"),
                     JobEntry->lpJobQueueEntry->JobId,
                     rc);
        goto exit;
    }
    //
    // Add the new JOB_ENTRY to the job list.
    //

    EnterCriticalSection( &g_CsJob );
    JobEntry->bFSPJobInProgress =  TRUE;
    InsertTailList( &g_JobListHead, &JobEntry->ListEntry );
    LeaveCriticalSection( &g_CsJob );
    Failure = FALSE;




    //
    // Attach the job to the line selected to service it.
    //
    LineInfo->JobEntry = JobEntry;

exit:
    if (Failure)
    { // Failure is initialized to TRUE
        if (LineInfo)
        {
            ReleaseTapiLine( LineInfo,  0 );
        }

        if (JobEntry)
        {
            EndJob(JobEntry);
        }
        JobEntry = NULL;
    }
    if (ERROR_SUCCESS != rc)
    {
        SetLastError(rc);

        FaxLog(FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            0,
            MSG_FAX_RECEIVE_FAILED);

    }
    return JobEntry;
}


//*********************************************************************************
//* Name:   StartRoutingJob()
//* Author: Mooly Beery (MoolyB)
//* Date:   July 20, 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Starts a routing operation. Must lock g_CsJob and g_CsQueue.
//* PARAMETERS:
//*     [IN/OUT ]   PJOB_QUEUE lpJobQueueEntry
//*         A pointer to the job for which the routing operation is to be
//*         performed.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If the operation failed. Call GetLastError() to get extended error
//*         information.
//*
//*********************************************************************************
BOOL
StartRoutingJob(
    PJOB_QUEUE lpJobQueueEntry
    )
{
    DWORD ec = ERROR_SUCCESS;
    HANDLE hThread = NULL;
    DWORD ThreadId;

    DEBUG_FUNCTION_NAME(TEXT("StartRoutingJob"));

    //
    // We mark the job as IN_PROGRESS so it can not be deleted or routed simultaneously
    //
    lpJobQueueEntry->JobStatus = JS_INPROGRESS;

    hThread = CreateThreadAndRefCount(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) FaxRouteThread,
                            (LPVOID) lpJobQueueEntry,
                            0,
                            &ThreadId
                            );

    if (hThread == NULL)
    {
        ec = GetLastError();
        DebugPrintEx(   DEBUG_ERR,
                        _T("CreateThreadAndRefCount for FaxRouteThread failed (ec: 0x%0X)"),
                        ec);

        if (!MarkJobAsExpired(lpJobQueueEntry))
        {
            DEBUG_ERR,
            TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
            lpJobQueueEntry->JobId,
            GetLastError();
        }

        SetLastError(ec);
        return FALSE;
    }

    DebugPrintEx(   DEBUG_MSG,
                    _T("FaxRouteThread thread created for job id %d ")
                    _T("(thread id: 0x%0x)"),
                    lpJobQueueEntry->JobId,
                    ThreadId);

    CloseHandle( hThread );

    //
    // Create Fax EventEx
    //
    DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                     lpJobQueueEntry);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(   DEBUG_ERR,
                        _T("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) ")
                        _T("failed for job id %ld (ec: %ld)"),
                        lpJobQueueEntry->JobId,
                        dwRes);
    }
    return TRUE;
}

//*********************************************************************************
//* Name:   StartSendJob()
//* Author: Ronen Barenboim
//* Date:   June 02, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Starts a send operation on a legacy of Extened FSP device.
//* PARAMETERS:
//*     [IN/OUT ]   PJOB_QUEUE lpJobQueueEntry
//*         A pointer to the recipient job for which the send operation is to be
//*         performed. For extended sends this is the Anchor recipient.
//*
//*     [IN/OUT]    PLINE_INFO lpLineInfo
//*         A pointer to the line on which the send operatin is to be performed.
//*     [IN]        BOOL bHandoff
//*         TRUE if the operation is a handoff job.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If the operation failed. Call GetLastError() to get extended error
//*         information.
//*
//*********************************************************************************
BOOL
StartSendJob(
    PJOB_QUEUE lpJobQueueEntry,
    PLINE_INFO lpLineInfo,
    BOOL bHandoff
    )
{
    DWORD rc = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("StartSendJob"));

    Assert(lpJobQueueEntry);
    Assert(JT_SEND == lpJobQueueEntry->JobType);
    Assert(lpLineInfo);

    if (FSPI_API_VERSION_1 == lpLineInfo->Provider->dwAPIVersion)
    {
        if (!StartLegacySendJob(lpJobQueueEntry,lpLineInfo,bHandoff))
        {
            rc = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StartLegacySendJob() failed for JobId: %ld (ec: %ld)"),
                lpJobQueueEntry->JobId,
                GetLastError());
            goto exit;
        }
    }
    else if (FSPI_API_VERSION_2 == lpLineInfo->Provider->dwAPIVersion)
    {
        if (!StartFaxDevSendEx(lpJobQueueEntry, lpLineInfo))
        {
            rc = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StartFaxDevSendEx() failed for JobId: %ld (ec: %ld)"),
                lpJobQueueEntry->JobId,
                rc);
            goto exit;
        }
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Unsupported FSPI version (0x%08X) for line : %s "),
            lpLineInfo->Provider->dwAPIVersion,
            lpLineInfo->DeviceName);
        Assert(FALSE);
        goto exit;
    }


exit:

    if (ERROR_SUCCESS != rc) {
        SetLastError(rc);

        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MIN,
            7,
            MSG_FAX_SEND_FAILED,
            lpJobQueueEntry->SenderProfile.lptstrName,
            lpJobQueueEntry->SenderProfile.lptstrBillingCode,
            lpJobQueueEntry->SenderProfile.lptstrCompany,
            lpJobQueueEntry->SenderProfile.lptstrDepartment,
            lpJobQueueEntry->RecipientProfile.lptstrName,
            lpJobQueueEntry->RecipientProfile.lptstrFaxNumber,
            lpLineInfo->DeviceName);

    }
    return (0 == rc);

}




//*********************************************************************************
//* Name:   StartLegacySendJob()
//* Author: Ronen Barenboim
//* Date:   June 02, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Starts the operation of sending a fax on a legacy FSP device.
//*         - creates the JOB_ENTRY
//*         - calls FaxDevStartJob()
//*         - calls SendDocument() to actually send the document
//*         - calls EndJob() if anything goes wrong.
//*
//* PARAMETERS:
//*     [XXX]       PJOB_QUEUE lpJobQueue
//*         A pointer to the recipient job for the send operation is to be started.
//*     [XXX]       PLINE_INFO lpLineInfo
//*         A pointer to the LINE_INFO of the line on which the fax is to be sent.
//*
//*     [XXX]       BOOL bHandoff
//*         TRUE if the fax is to be sent on a line acquired via handoff ( used
//*         for callback on existing call functionality).
//*
//* RETURN VALUE:
//*     TRUE if the operation succeeded.
//*     FALSE if it failed. Call GetLastError() to get extended error information.
//*
//*********************************************************************************
PJOB_ENTRY StartLegacySendJob(
    PJOB_QUEUE lpJobQueue,
    PLINE_INFO lpLineInfo,
    BOOL bHandoff)
{

    PJOB_ENTRY lpJobEntry = NULL;
    DWORD rc = 0;
    DWORD dwRes;


    DEBUG_FUNCTION_NAME(TEXT("StartLegacySendJob"));
    Assert(JT_SEND == lpJobQueue->JobType);
    Assert(FSPI_API_VERSION_1 == lpLineInfo->Provider->dwAPIVersion);

    lpJobEntry = CreateJobEntry(lpJobQueue, lpLineInfo, TRUE, bHandoff);
    if (!lpJobEntry)
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create JobEntry for JobId: %ld. (ec: %ld)"),
            lpJobQueue->JobId,
            rc);
        goto Error;
    }
    lpJobQueue->JobStatus = JS_INPROGRESS;
    //
    // Add the new JOB_ENTRY to the job list.
    //
    EnterCriticalSection( &g_CsJob );
    InsertTailList( &g_JobListHead, &lpJobEntry->ListEntry );
    LeaveCriticalSection( &g_CsJob );

    //
    // Attach the job to the line selected to service it.
    //
    lpLineInfo->JobEntry = lpJobEntry;
    lpJobQueue->JobEntry = lpJobEntry;


    __try
    {
        //
        // Call the FSP associated with the line to start a fax job. Note that at this
        // point it is not known if the job is send or receive.
        //
        if (lpLineInfo->Provider->FaxDevStartJob(
                lpLineInfo->hLine,
                lpLineInfo->DeviceId,
                (PHANDLE) &lpJobEntry->InstanceData, // JOB_ENTRY.InstanceData is where the FSP will place its
                                                   // job handle (fax handle).
                g_StatusCompletionPortHandle,
                (ULONG_PTR) lpLineInfo )) // Note that the completion key provided to the FSP is the LineInfo
                                        // pointer. When the FSP reports status it uses this key thus allowing
                                        // us to know to which line the status belongs.
        {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("FaxDevStartJob() Successfuly called for JobId: %ld)"),
                lpJobQueue->JobId);
            lpJobEntry->bFSPJobInProgress = TRUE;
            //
            // Associate the job entry with the FSP job handle
            //
            rc = AddFspJob(lpLineInfo->Provider->hJobMap,
                           (HANDLE) lpJobEntry->InstanceData,
                           lpJobEntry);
            if (ERROR_SUCCESS != rc)
            {
                DebugPrintEx(DEBUG_ERR,
                             TEXT("[Job: %ld] AddFspJob failed (ec: %ld)"),
                             lpJobEntry->lpJobQueueEntry->JobId,
                             rc);
                goto Error;
            }

        }
        else
        {
            rc = GetLastError();
            DebugPrintEx(DEBUG_ERR,TEXT("FaxDevStartJob() failed (ec: %ld)"),rc);
            if (0 == rc)
            {
                //
                // FSP failed to report last error so we set our own.
                //
                DebugPrintEx(DEBUG_ERR,TEXT("FaxDevStartJob() failed but reported 0 for last error"));
                rc = ERROR_GEN_FAILURE;
            }
            goto Error;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        rc = ERROR_INVALID_FUNCTION;
        DebugPrintEx(DEBUG_ERR,TEXT("Exception 0x%08x occured while calling FaxDevStartJob."),GetExceptionCode());
        goto Error;
    }

    //
    // start the send job
    //
    rc = SendDocument(
        lpJobEntry,
        lpJobQueue->FileName
        );


    if (rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SendDocument failed for JobId: %ld (ec: %ld)"),
            lpJobQueue->JobId,
            rc);
        goto Error;
    }

    Assert (0 == rc);
    goto Exit;
Error:
    Assert( 0 != rc);
    if (lpJobEntry)
    {
        if (!EndJob(lpJobEntry))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EndJob() failed for JobId: %ld (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError());
        }
        lpJobEntry = NULL;
        lpJobQueue->JobEntry = NULL;
    }
    else
    {
        //
        // Release the line
        //
        if (!ReleaseTapiLine(lpLineInfo, NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReleaseTapiLine() failed (ec: %ld)"),
                GetLastError());
        }
    }

    //
    // set the job into the retries exceeded state
    //
    if (0 == lpJobQueue->dwLastJobExtendedStatus)
    {
        //
        // Job was never really executed - this is a fatal error
        //
        lpJobQueue->dwLastJobExtendedStatus = FSPI_ES_FATAL_ERROR;
    }
    if (!MarkJobAsExpired(lpJobQueue))
    {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError());
    }

    //
    // Notify clients on status change
    //
    dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS, lpJobQueue);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
            lpJobQueue->UniqueId,
            dwRes);
    }

Exit:
    if (rc)
    {
        SetLastError(rc);
    }
    return lpJobEntry;
}



//*********************************************************************************
//* Name:   HandleFSPIJobStatusMessage()
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     This function handles a FSPI_JOB_STATUS message by updating the job status
//*     and taking the required additional action (like terminating a completed
//*     job).
//*     It is called from FaxStatusThread() when the completion port is posted
//*     with a FSPI_JOB_STATUS_KEY packet.
//*
//* PARAMETERS:
//*     [IN ]   LPCFSPI_JOB_STATUS_MSG lpcMsg
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If error occured during the message handling. Call GetLastError() for
//*         extended error information.
//*         If the message is for a job entry that no longer exists (this can
//*         happen if the job was removed before we had a chance to handle the
//*         status message) the last error code will be ERROR_NOT_FOUND.
//*********************************************************************************
BOOL HandleFSPIJobStatusMessage(LPCFSPI_JOB_STATUS_MSG lpcMsg)
{
    PJOB_ENTRY lpJobEntry;
    LPCFSPI_JOB_STATUS lpcFSPJobStatus;
    DWORD ec = 0;

    DEBUG_FUNCTION_NAME(TEXT("HandleFSPIJobStatusMessage"));
    Assert(lpcMsg);
    Assert(lpcMsg->lpJobEntry);
    Assert(lpcMsg->lpFSPIJobStatus);

    lpJobEntry = lpcMsg->lpJobEntry;
    lpcFSPJobStatus = lpcMsg->lpFSPIJobStatus;

    EnterCriticalSection( &g_CsJob );

    if (!FindJobByJob( lpJobEntry ))
    {
        ec = ERROR_NOT_FOUND;
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("HandleFSPIJobStatusMessage() could not find the Job"));
        goto Exit;
    }


    if (!UpdateJobStatus(lpJobEntry, lpcFSPJobStatus, TRUE)) // TRUE - Send event to the clients
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("UpdateJobStatus() failed for JobId: %ld (Provider GUID: %s hFSPJob = 0x%08X) (ec: %ld)"),
            lpJobEntry->lpJobQueueEntry->JobId,
            lpJobEntry->LineInfo->Provider->szGUID,
            lpJobEntry->InstanceData,
            GetLastError());
        goto Exit;

    }

    //
    // Take care of completed and failed jobs.
    //
    if (!HanldeFSPIJobStatusChange(lpJobEntry))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("HanldeFSPIJobStatusChange() failed for JobId: %ld (Provider GUID: %s hFSPJob = 0x%08X) (ec: %ld)"),
            lpJobEntry->lpJobQueueEntry->JobId,
            lpJobEntry->LineInfo->Provider->szGUID,
            lpJobEntry->InstanceData,
            GetLastError());
        goto Exit;
    }

Exit:
    LeaveCriticalSection ( &g_CsJob );
    DebugPrintEx(
        DEBUG_MSG,
        TEXT("^^^^^^^^^  Exiting  ^^^^^^^^^^^"));

    if (ec)
    {
        SetLastError(ec);
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}



//*********************************************************************************
//* Name:   ValidateFSPIJobStatus()
//* Author: Ronen Barenboim
//* Date:   August 1, 20000
//*********************************************************************************
//* DESCRIPTION:
//*     Validates the FSPI_JOB_STATUS structure making sure it has the right
//*     FSPI_JS_ code and FSPI_ES code.
//*     If the FSPI_JS is not calid it just fails.
//*     If the FSPI_JS is valid but the FSPI_ES is not it will set the extended
//*     status code to 0 and return TRUE.
//*
//* PARAMETERS:
//*     [IN ]   LPFSPI_JOB_STATUS lpFSPIJobStatus
//*
//* RETURN VALUE:
//*     TRUE
//*         If the status structure has a valid FSPI_JS status.
//*     FALSE
//*         If the status structure has an invalid FSPI_JS status.
//* COMMENTS:
//*     The function will not try to fix the extended status code if it is
//*     a propreitary status code (legacy or new)
//*********************************************************************************
BOOL
ValidateFSPIJobStatus(LPFSPI_JOB_STATUS lpFSPIJobStatus)
{
   DEBUG_FUNCTION_NAME(TEXT("ValidFSPIJobStatus"));

    if (lpFSPIJobStatus->dwJobStatus < FSPI_JS_UNKNOWN ||
        lpFSPIJobStatus->dwJobStatus > FSPI_JS_DELETED)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("FSPIJobStatus.dwJobStatus (0x%08X) not in valid range !!!"),
            lpFSPIJobStatus->dwJobStatus);
        //
        // Don't ASSERT this can happen when an EFSP has a bug.
        //
        return FALSE;
    }

    //
    // Validate the FSPI_ES_* status and fix it if it is wrong
    //

    if (lpFSPIJobStatus->dwExtendedStatus >= FSPI_ES_PROPRIETARY)
    {
        //
        // Proprietary code - nothing to validate
        //
        return TRUE;
    }

    if (lpFSPIJobStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE)
    {
        //
        // Legacy FSP proprietary code - nothing to validate
        //
        return TRUE;
    }


    switch (lpFSPIJobStatus->dwJobStatus)
    {
        case FSPI_JS_UNKNOWN:
            if (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_DISCONNECTED)
            {
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("FSPI_ES code 0x%08X is invalid for FSPI_JS_UNKNOWN !!!"),
                    lpFSPIJobStatus->dwExtendedStatus);

                lpFSPIJobStatus->dwExtendedStatus = 0;
            }
            break;
        case FSPI_JS_INPROGRESS:
            if (
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_INITIALIZING)   &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_DIALING)        &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_TRANSMITTING)   &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_ANSWERED)       &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_RECEIVING))
            {

                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("FSPI_ES code 0x%08X is invalid for FSPI_JS_INPROGRESS !!!"),
                    lpFSPIJobStatus->dwExtendedStatus);
                lpFSPIJobStatus->dwExtendedStatus = 0;
            }
            break;
        case FSPI_JS_RETRY:
        case FSPI_JS_FAILED_NO_RETRY:
        case FSPI_JS_FAILED:
        case FSPI_JS_COMPLETED:
            if (
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_BUSY)                 &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_NO_ANSWER)            &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_BAD_ADDRESS)          &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_NO_DIAL_TONE)         &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_DISCONNECTED)         &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_CALL_DELAYED)         &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_CALL_BLACKLISTED)     &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_NOT_FAX_CALL)         &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_LINE_UNAVAILABLE)     &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_FATAL_ERROR)          &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_CALL_COMPLETED)       &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_CALL_ABORTED)         &&
                (lpFSPIJobStatus->dwExtendedStatus != FSPI_ES_PARTIALLY_RECEIVED))
            {
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("FSPI_ES code 0x%08X is invalid for FSPI_JS_RETRY/FAILED/NORETRY !!!"),
                    lpFSPIJobStatus->dwExtendedStatus);
                lpFSPIJobStatus->dwExtendedStatus = 0;
            }
            break;
        default:
            //
            // Some other state with a non proprietry status code. This is not valid.
            //

            DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("FSPI_ES code 0x%08X is invalid for other FSPI_JS status. Propreitary expected !!!"),
                    lpFSPIJobStatus->dwExtendedStatus);
            lpFSPIJobStatus->dwExtendedStatus = 0;
            break;

    }
    return TRUE;
}


//*********************************************************************************
//* Name:   UpdateJobStatus()
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Updated the FSPI job status kept in the job entry.
//*     Generates legacy API event and new events as required.
//* PARAMETERS:
//*     [OUT]           PJOB_ENTRY lpJobEntry
//*         The job entry whose FSPI status is to be udpated.
//*
//*     [IN]            LPCFSPI_JOB_STATUS lpcFSPJobStatus
//*         The new FSPI job status.
//*     [IN]            BOOL fSendEventEx
//*         TRUE if extended event is needed
//*
//* RETURN VALUE:
//*     TRUE if the operation succeeded.
//*     FALSE if the operation failed. Call GetLastError() to get extended error
//*     information.
//* Remarks:
//*     The function fress the last FSPI job status held in the job entry
//*     (if any).
//*********************************************************************************
BOOL UpdateJobStatus(
        PJOB_ENTRY lpJobEntry,
        LPCFSPI_JOB_STATUS lpcFSPJobStatus,
        BOOL fSendEventEx)
{
    DWORD ec = 0;
    DWORD dwEventId;
    DWORD Size = 0;

    DEBUG_FUNCTION_NAME(TEXT("UpdateJobStatus"));

    Assert(lpJobEntry);
    Assert(lpcFSPJobStatus);
    Assert (lpJobEntry->lpJobQueueEntry);

    EnterCriticalSection( &g_CsJob );

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("dwJobStatus: 0x%08X dwExtendedStatus: 0x%08X"),
        lpcFSPJobStatus->dwJobStatus,
        lpcFSPJobStatus->dwExtendedStatus
        );

    if (TRUE == lpJobEntry->fStopUpdateStatus)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("JobId: %ld. fStopUpdateStatus was set. Not updating status"),
            lpJobEntry->lpJobQueueEntry->JobId,
            lpJobEntry->lpJobQueueEntry->JobStatus);
        LeaveCriticalSection (&g_CsJob);
        return TRUE;
    }

    //
    // Verify that the job status is valid. If the FSPI_JS_*
    // is not valid then just discard it.
    // Otherwise check the FSPI_ES_* status and correct it if it
    // is invalid.
    //
    if (!ValidateFSPIJobStatus((LPFSPI_JOB_STATUS)lpcFSPJobStatus))
    {
        //
        // Make sure this is not Microsoft T30 private status code
        //
        if (!(FSPI_JS_SYSTEM_ABORT == lpcFSPJobStatus->dwJobStatus &&
              lpJobEntry->LineInfo->Provider->FaxDevShutdown))
        {
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("Invalid status reported for JobId: %ld by FSP: %s. dwJobStatus: 0x%08X dwExtendedStatus: 0x%08X"),
                lpJobEntry->lpJobQueueEntry->JobId,
                lpJobEntry->LineInfo->Provider->FriendlyName,
                lpcFSPJobStatus->dwJobStatus,
                lpcFSPJobStatus->dwExtendedStatus);
            return FALSE;
        }
    }

    //
    // Map the FSPI job status to an FEI_* event (0 if not event matches the status)
    //
    dwEventId = MapFSPIJobStatusToEventId(lpcFSPJobStatus);

    //
    // Note: W2K Fax did issue notifications with EventId == 0 whenever an
    // FSP reported proprietry status code. To keep backward compatability
    // we keep up this behaviour although it might be regarded as a bug
    //

    if (!CreateFaxEvent( lpJobEntry->LineInfo->PermanentLineID, dwEventId, lpJobEntry->lpJobQueueEntry->JobId ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateFaxEvent() failed. Event: 0x%08X JobId: %ld DeviceId:  (ec: %ld)"),
            dwEventId,
            lpJobEntry->lpJobQueueEntry->JobId,
            lpJobEntry->LineInfo->PermanentLineID,
            GetLastError());
        Assert(FALSE);
    }

    lpJobEntry->FSPIJobStatus.dwJobStatus = lpcFSPJobStatus->dwJobStatus;
    lpJobEntry->FSPIJobStatus.dwExtendedStatus = lpcFSPJobStatus->dwExtendedStatus;
    lpJobEntry->FSPIJobStatus.dwExtendedStatusStringId = lpcFSPJobStatus->dwExtendedStatusStringId;

    if (lpcFSPJobStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_PAGECOUNT)
    {
        lpJobEntry->FSPIJobStatus.dwPageCount = lpcFSPJobStatus->dwPageCount;
        lpJobEntry->FSPIJobStatus.fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_PAGECOUNT;
    }

    if (lpcFSPJobStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_TRANSMISSION_START)
    {
        lpJobEntry->FSPIJobStatus.tmTransmissionStart = lpcFSPJobStatus->tmTransmissionStart;
        lpJobEntry->FSPIJobStatus.fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_TRANSMISSION_START;
    }

    if (lpcFSPJobStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_TRANSMISSION_END)
    {
        lpJobEntry->FSPIJobStatus.tmTransmissionEnd = lpcFSPJobStatus->tmTransmissionEnd;
        lpJobEntry->FSPIJobStatus.fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_TRANSMISSION_END;
    }

    // Use try/except to catch invalid pointers provided by the EFSP
    if (NULL != lpcFSPJobStatus->lpwstrRemoteStationId)
    {
        __try
        {
            if (!ReplaceStringWithCopy(&lpJobEntry->FSPIJobStatus.lpwstrRemoteStationId,
                                       lpcFSPJobStatus->lpwstrRemoteStationId))
            {
                DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReplaceStringWithCopy() failed.  (ec: %ld)"),
                GetLastError());
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReplaceStringWithCopy crashed with error %ld"),
                GetExceptionCode());
        }
    }

    if (NULL != lpcFSPJobStatus->lpwstrCallerId)
    {
        __try
        {
            if (!ReplaceStringWithCopy(&lpJobEntry->FSPIJobStatus.lpwstrCallerId,
                                       lpcFSPJobStatus->lpwstrCallerId))
            {
                DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReplaceStringWithCopy() failed.  (ec: %ld)"),
                GetLastError());
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReplaceStringWithCopy crashed with error %ld"),
                GetExceptionCode());
        }
    }

    if (NULL != lpcFSPJobStatus->lpwstrRoutingInfo)
    {
        __try
        {
            if (!ReplaceStringWithCopy(&lpJobEntry->FSPIJobStatus.lpwstrRoutingInfo,
                                       lpcFSPJobStatus->lpwstrRoutingInfo))
            {
                DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReplaceStringWithCopy() failed.  (ec: %ld)"),
                GetLastError());
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReplaceStringWithCopy crashed with error %ld"),
                GetExceptionCode());
        }
    }

    wcscpy (lpJobEntry->ExStatusString, TEXT(""));
    //
    // Get extended status string
    //
    Assert (lpJobEntry->LineInfo != NULL)

    if (lpJobEntry->FSPIJobStatus.dwExtendedStatusStringId != 0)
    {
        Assert (lpJobEntry->FSPIJobStatus.dwExtendedStatus != 0);
        Size = LoadString (lpJobEntry->LineInfo->Provider->hModule,
                           lpJobEntry->FSPIJobStatus.dwExtendedStatusStringId,
                           lpJobEntry->ExStatusString,
                           sizeof(lpJobEntry->ExStatusString)/sizeof(WCHAR));
        if (Size == 0)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to load extended status string (ec: %ld) stringid : %ld, Provider: %s"),
                ec,
                lpJobEntry->FSPIJobStatus.dwExtendedStatusStringId,
                lpJobEntry->LineInfo->Provider->ImageName);
            goto Error;
        }
    }

    //
    // Send extended event
    //
    if (TRUE == fSendEventEx)
    {
        EnterCriticalSection (&g_CsQueue);
        DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                         lpJobEntry->lpJobQueueEntry);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                lpJobEntry->lpJobQueueEntry->UniqueId,
                dwRes);
        }
        LeaveCriticalSection (&g_CsQueue);
    }

    Assert (0 == ec);
    goto Exit;

Error:
    Assert( ec !=0 );
Exit:
    LeaveCriticalSection( &g_CsJob );
    if (ec)
    {
        SetLastError(ec);
    }
    return (0 == ec);
}




//*********************************************************************************
//* Name:   CheckForJobRetry
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Checks if a recipient job should be retried.
//*     Increments the retry count and marks the job as expired if it passed
//*     the retry limit.
//* PARAMETERS:
//*     [IN/OUT]    PJOB_QUEUE lpJobQueue
//*         A pointer to the JOB_QUEUE structure of the recipient job.
//* RETURN VALUE:
//*     TRUE if the job is to be retried.
//*     FALSE if it is not to be retried.
//*********************************************************************************
BOOL CheckForJobRetry (PJOB_QUEUE lpJobQueue)
{

    PJOB_ENTRY lpJobEntry;
    DWORD dwMaxRetries;
    DEBUG_FUNCTION_NAME(TEXT("CheckForJobRetry"));
    Assert(lpJobQueue);
    lpJobEntry = lpJobQueue->JobEntry;
    Assert(lpJobEntry);
    //
    // Increase the retry count and check if we exceeded maximum retries.
    //
    EnterCriticalSection (&g_CsConfig);
    dwMaxRetries = g_dwFaxSendRetries;
    LeaveCriticalSection (&g_CsConfig);
    if (FSPI_CAP_AUTO_RETRY & lpJobEntry->LineInfo->Provider->dwCapabilities)
    {
        //
        // The EFSP supports AUTO RETRY we are not suppose to add further retries
        // Set the retry values to the maximum retries value + 1 so we will not
        // retry it.
        //
        lpJobQueue->SendRetries = dwMaxRetries + 1;
    }
    else
    {
        lpJobQueue->SendRetries++;
    }
    if (lpJobQueue->SendRetries <= dwMaxRetries)
    {
        return TRUE;
    }
    else
    {
        //
        // retries exceeded report that the job is not to be retried
        return FALSE;
    }
}



//*********************************************************************************
//* Name:   FindJobEntryByRecipientNumber()
//* Author: Ronen Barenboim
//* Date:   June 01, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Finds the first running job that is destined to a certain number.
//*
//* PARAMETERS:
//*     [IN ]   LPTSTR lptstrNumber
//*         The number to match. This must be in canonical form.
//*
//* RETURN VALUE:
//*     A pointer to the JOB_ENTRY in the g_JobListHead list that is destined to
//*     the specified number.
//*     If no such job is found the return value is NULL.
//*********************************************************************************
PJOB_ENTRY FindJobEntryByRecipientNumber(LPCWSTR lpcwstrNumber)
{

    PLIST_ENTRY lpNext;
    PJOB_ENTRY lpJobEntry;
    DEBUG_FUNCTION_NAME(TEXT("FindJobEntryByRecipientNumber"));
    Assert(lpcwstrNumber);
    lpNext = g_JobListHead.Flink;
    Assert(lpNext);
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&g_JobListHead) {
        lpJobEntry = CONTAINING_RECORD( lpNext, JOB_ENTRY, ListEntry );
        lpNext = lpJobEntry->ListEntry.Flink;
        if (JT_SEND == lpJobEntry->lpJobQueueEntry->JobType)
        {
            if (!_wcsicmp(lpJobEntry->lpJobQueueEntry->RecipientProfile.lptstrFaxNumber, lpcwstrNumber))
            {
                return lpJobEntry;
            }
        }
    }
    return NULL;
}



//*********************************************************************************
//* Name:   TerminateMultipleFSPJobs()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Calls FaxDevAbort() followed by FaxDevEndJob() for each of the
//*     EFSP job handles in the provided array.
//*
//* PARAMETERS:
//*     [IN]        PHANDLE lpRecipientJobHandles
//*         Pointer to an array of EFSP job handles.
//*
//*     [IN]        DWORD dwRecipientCount
//*         The number of handles in the array.
//*
//*     [IN]        PLINE_INFO lpLineInfo
//*         Pointer to the LINE_INFO of the line on which the jobs execute.
//*
//* RETURN VALUE:
//*     TRUE
//*         If all the jobs were terminated successfully.
//*
//*     FALSE
//*         If at least one of the jobs was not terminated successfully.
//* REMARKS:
//*     The function will attempt to terminate ALL the jobs even if some
//*     fail to terminate.
//*********************************************************************************
BOOL
TerminateMultipleFSPJobs(
    PHANDLE lpRecipientJobHandles,
    DWORD dwRecipientCount,
    PLINE_INFO lpLineInfo)
{
    DWORD nRecp;
    BOOL bAllSucceeded = TRUE;
    BOOL bRes;

    DEBUG_FUNCTION_NAME(TEXT("TerminateMultipleFSPJobs"));
    Assert(lpRecipientJobHandles);
    Assert(dwRecipientCount > 0);
    Assert(lpLineInfo);

    for (nRecp=0; nRecp < dwRecipientCount; nRecp++)
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Calling FaxDevAbortOperation() for  Provider: [%s] LineName: [%s] LineId: [%ld]"),
            lpLineInfo->Provider->FriendlyName,
            lpLineInfo->DeviceName,
            lpLineInfo->TapiPermanentLineId);
#if DBG
        if (0 == lpRecipientJobHandles[nRecp])
        {
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("Calling FaxDevAbortOperation with a job handle == 0 (invalid)."));

        }
#endif
        __try
        {
            Assert(lpLineInfo->Provider->FaxDevAbortOperation);
            bRes = lpLineInfo->Provider->FaxDevAbortOperation(lpRecipientJobHandles[nRecp]);
            if (!bRes)
            {
                bAllSucceeded = FALSE;
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxDevAbortOperation() failed. Job Handle: 0x%08X (ec: %ld)"),
                    lpRecipientJobHandles[nRecp],
                    GetLastError());

            }
            else
            {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("FaxDevAbortOperation() succeeded."));
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            bAllSucceeded = FALSE;
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxDevAbortOperation() * CRASHED *. (Exception Code: %ld)"),
                    GetExceptionCode());

        }

        //
        // Now end the job
        //

        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Calling FaxDevEndJob() for  Provider: [%s] LineName: [%s] LineId: [%ld]"),
            lpLineInfo->Provider->FriendlyName,
            lpLineInfo->DeviceName,
            lpLineInfo->TapiPermanentLineId);

#if DBG
        if (0 == lpRecipientJobHandles[nRecp])
        {
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("Calling FaxDevEndJob() with a job handle == 0 (invalid)."));

        }
#endif
        __try
        {
            Assert(lpLineInfo->Provider->FaxDevEndJob);
            bRes = lpLineInfo->Provider->FaxDevEndJob(lpRecipientJobHandles[nRecp]);
            if (!bRes)
            {
                bAllSucceeded = FALSE;
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxDevEndJob() failed. Job Handle: 0x%08X (ec: %ld)"),
                    lpRecipientJobHandles[nRecp],
                    GetLastError());
            }
            else
            {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("FaxDevEndJob() succeeded."));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            bAllSucceeded = FALSE;
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxDevEndJob() * CRASHED *. (Exception Code: %ld)"),
                    GetExceptionCode());

        }
    }
    return bAllSucceeded;

}



//*********************************************************************************
//* Name:   EFSPJobGroup_Create()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates and initializes a EFSP job group.
//* PARAMETERS:
//*     [IN ]    const LINE_INFO * lpLineInfo
//*         The line on which this job group is to execute.
//* RETURN VALUE:
//*     On success the funtion returns a pointer to a newly allocated
//*     EFSP_JOB_GRPUP structure.
//*     On failure it returns NULL.
//*********************************************************************************
LPEFSP_JOB_GROUP EFSPJobGroup_Create( const LINE_INFO * lpLineInfo)
{
    LPEFSP_JOB_GROUP lpGroup = NULL;
    DWORD ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_Create"));

    Assert(lpLineInfo);
    Assert(FSPI_API_VERSION_2 == lpLineInfo->Provider->dwAPIVersion); // must be extended EFSP line

    lpGroup = (LPEFSP_JOB_GROUP) MemAlloc(sizeof(EFSP_JOB_GROUP));
    if (!lpGroup)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate EFSP_JOB_GROUP. (ec: %ld)"),
            ec);
        goto Error;
    }

    memset(lpGroup, 0, sizeof(EFSP_JOB_GROUP));
    //
    // Attach to the line
    //
    lpGroup->lpLineInfo = (PLINE_INFO)lpLineInfo;
    //
    // Initialize the member list
    //
    InitializeListHead(&lpGroup->RecipientJobs);
    //
    // Initialize the parent permanent id
    //
    memset(&lpGroup->FSPIParentPermanentId, 0, sizeof(FSPI_MESSAGE_ID));
    lpGroup->FSPIParentPermanentId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
    //
    // On creation we have no associated file. We will create it on the first save.
    //
    lpGroup->lptstrPersistFile = NULL;

    Assert( ERROR_SUCCESS == ec);
    Assert( NULL != lpGroup);
    goto Exit;
Error:
    MemFree(lpGroup);
    lpGroup = NULL;
    Assert( ERROR_SUCCESS != ec);

Exit:
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }
    return lpGroup;

}


//*********************************************************************************
//* Name:   EFSPJobGroup_AddRecipient()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Add a recipient job to the group.
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         Pointer to the group.
//*     [IN ]    PJOB_QUEUE lpRecipient
//*         Pointer to the recipient job to add to the group.
//*     [IN ]   BOOL bCommit.
//*         TRUE if the persistent file should be update (if it exists) after the
//*         removal. If FALSE the persisten file is not updated. This is used
//*         to optimize the operation of removing all the recipients.

//* RETURN VALUE:
//*     TRUE
//*         On success.
//*     FALSE
//*         On failure. Call GetLastError() to get extended error information.
//*********************************************************************************
BOOL EFSPJobGroup_AddRecipient(LPEFSP_JOB_GROUP lpGroup, PJOB_QUEUE lpRecipient, BOOL bCommit)
{
    PJOB_QUEUE_PTR lpRecipientPtr = NULL;
    DWORD ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_AddRecipient"));

    Assert(lpGroup);
    Assert(lpRecipient);


    EnterCriticalSectionJobAndQueue;
    EnterCriticalSection(&g_csEFSPJobGroups);

    lpRecipientPtr = (PJOB_QUEUE_PTR) MemAlloc(sizeof(JOB_QUEUE_PTR));
    if (!lpRecipientPtr)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocated JOB_QUEUE_PTR. (ec: %ld)"),
            ec);
        goto Error;
    }
    lpRecipientPtr->lpJob = lpRecipient;

    //
    // Link the recipient job back to the group.
    //
    lpRecipient->lpEFSPJobGroup = lpGroup;
    //
    // Line the recipient job to the group element that points to it.
    //
    lpRecipient->lpEFSPJobGroupElement = lpRecipientPtr;
    //
    // Add it to the recipient list.
    //
    InsertTailList(&lpGroup->RecipientJobs, &lpRecipientPtr->ListEntry);
    (lpGroup->dwRecipientJobs)++;

    if (bCommit)
    {
            //
            // Update the persitent file with the new list of recipient jobs
            if (!EFSPJobGroup_Save(lpGroup))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("EFSPJobGroup_Save() failed for EFSP Job Group persist file: [%s] (ec: %ld)."),
                    lpGroup->lptstrPersistFile,
                    ec);
                ASSERT_FALSE;
                goto Error;
            }
    }
    Assert( ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert( ERROR_SUCCESS != ec);
Exit:
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }

    LeaveCriticalSection(&g_csEFSPJobGroups);
    LeaveCriticalSectionJobAndQueue;


    return (ERROR_SUCCESS == ec);
}



//*********************************************************************************
//* Name:   EFSPJobGroup_RemoveRecipient()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Removes a recipient job from the EFSP job group.
//*
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         The group from whic the recipient job is to be removed.
//*     [IN ]   PJOB_QUEUE lpRecipient
//*         The recipient job to be removed.
//*     [IN ]   BOOL bCommit.
//*         TRUE if the persistent file should be update (if it exists) after the
//*         removal. If FALSE the persisten file is not updated. This is used
//*         to optimize the operation of removing all the recipients.
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//*
//* REMARKS:
//*     The function cleanus the association between the recipient job and the
//*     group including the release of the permanent message id.
//*
//*********************************************************************************
BOOL EFSPJobGroup_RemoveRecipient(LPEFSP_JOB_GROUP lpGroup, PJOB_QUEUE lpRecipient, BOOL bCommit)
{
    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_RemoveRecipient"));
    DWORD ec = ERROR_SUCCESS;

    EnterCriticalSectionJobAndQueue;
    EnterCriticalSection(&g_csEFSPJobGroups);

    PJOB_QUEUE_PTR lpGroupJobPtr = NULL;

    Assert(lpGroup);
    Assert(lpRecipient);
    Assert(lpRecipient->lpEFSPJobGroup == lpGroup);
    Assert(lpRecipient->lpEFSPJobGroupElement->lpJob == lpRecipient);
    Assert(lpGroup->dwRecipientJobs > 0);

    lpGroupJobPtr = lpRecipient->lpEFSPJobGroupElement;

    Assert(lpGroupJobPtr);
    Assert(lpGroupJobPtr->lpJob);

    //
    // Decrement the number of recipients in the group
    //
    (lpGroup->dwRecipientJobs)--;

    //
    // Remove the recipient job from the group members list
    //
    RemoveEntryList(&lpGroupJobPtr->ListEntry);
    lpGroupJobPtr->ListEntry.Flink = NULL;
    lpGroupJobPtr->ListEntry.Blink = NULL;

    //
    // Free the recipient job permanent id
    //
    if (!FreePermanentMessageId(&lpGroupJobPtr->lpJob->EFSPPermanentMessageId, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FreePermanentMessageId() failed for recipient job %ld (ec: %ld)"),
            lpGroupJobPtr->lpJob->JobId,
            GetLastError());
        ASSERT_FALSE;
    }

    //
    // Break the back link from the recipient job to the job group
    //
    lpGroupJobPtr->lpJob->lpEFSPJobGroup = NULL;
    lpGroupJobPtr->lpJob->lpEFSPJobGroupElement = NULL;

    //
    // Commit the recipient job changes (new permanent id) to disk.
    //
    if (!CommitQueueEntry(lpGroupJobPtr->lpJob))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CommitQueueEntry() for recipient JobId: %ld failed. (ec: %ld)"),
            lpGroupJobPtr->lpJob->JobId,
            ec);
    }

    //
    // Free the job group item structure itself (the one that holds the pointer to the recipient job)
    //
    MemFree(lpGroupJobPtr);

    if (bCommit && lpGroup->lptstrPersistFile)
    {
        //
        // Note that the above condition means we will NOT create a persistent file
        // for a group because of a RemoveRecipient operation.
        //

        if (0 == lpGroup->dwRecipientJobs )
        {
            //
            // The group is empty. We need to delete the file.
            //

            DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("EFSP Job Group is empty deleting persist file [%s]."),
                    lpGroup->lptstrPersistFile);
            if (!DeleteFile(lpGroup->lptstrPersistFile))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to delete EFSP Job Group persist file: [%s] (ec: %ld)."),
                    lpGroup->lptstrPersistFile,
                    GetLastError());
                ASSERT_FALSE;
            }
            goto Exit;
        }
        else
        {
            //
            // Update the persitent file with the new list of recipient jobs

            if (!EFSPJobGroup_Save(lpGroup))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("EFSPJobGroup_Save() failed for EFSP Job Group persist file: [%s] (ec: %ld)."),
                    lpGroup->lptstrPersistFile,
                    ec);
                ASSERT_FALSE;
                goto Error;
            }

        }
    }
    Assert( ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert( ERROR_SUCCESS != ec);
Exit:

    LeaveCriticalSection(&g_csEFSPJobGroups);
    LeaveCriticalSectionJobAndQueue;

    return (ERROR_SUCCESS == ec);
}


//*********************************************************************************
//* Name:   EFSPJobGroup_SetParentId()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Set the EFSP parent permanent id to the group.
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         A pointer to the group in which the parent permanent id is to be set.
//*
//*     [IN ]    LPCFSPI_MESSAGE_ID lpcMessageId
//*         A pointer to the parent permanent id to be set.
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If it failed. Call GetLastError() for extended error information.
//*********************************************************************************
BOOL EFSPJobGroup_SetParentId(LPEFSP_JOB_GROUP lpGroup, LPCFSPI_MESSAGE_ID lpcMessageId)
{
    DWORD ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_SetParentId"));

    Assert(lpGroup);
    Assert(lpcMessageId);

    EnterCriticalSection(&g_csEFSPJobGroups);

    FreePermanentMessageId(&lpGroup->FSPIParentPermanentId, FALSE);
    if (!CopyPermanentMessageId(&lpGroup->FSPIParentPermanentId,lpcMessageId))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CopyPermanentMessageId() failed. (ec: %ld)"),
            ec);
        goto Error;
    }
    Assert( ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert( ERROR_SUCCESS != ec);
Exit:
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }

    LeaveCriticalSection(&g_csEFSPJobGroups);

    return (ERROR_SUCCESS == ec);
}


//*********************************************************************************
//* Name:   EFSPJobGroup_DeleteFile()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Erases the persistent file associated with the group.
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         The group whose persistent file is to be deleted.
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded or there is no file to delete.
//*     FALSE
//*         If the file could not be deleted. Call GetLastError() for extended
//*         error information.
//*********************************************************************************
BOOL EFSPJobGroup_DeleteFile(LPCEFSP_JOB_GROUP lpcGroup)
{
    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_DeleteFile"));
    Assert(lpcGroup);
    if (lpcGroup->lptstrPersistFile)
    {
        if (!DeleteFile(lpcGroup->lptstrPersistFile))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to delete EFSP job group persistence file : [%s] (ec: %ld)"),
                lpcGroup->lptstrPersistFile,
                GetLastError());
            return FALSE;
        }
    }
    return TRUE;
}


//*********************************************************************************
//* Name:   EFSPJobGroup_RemoveAllRecipients()
//* Author: Ronen Barenboim
//* Date:   June 15, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Remove all the recipients associated with the job group.
//*     DOES not free anything else.
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         The group whose recipients are to be freed.
//*     [IN ]    BOOL bCommit
//*         TRUE if the change should be comitted to file.
//* RETURN VALUE:
//*     TRUE
//*         If the operation completed successfuly.
//*     FALSE
//*         If the operation failed. Call GetLastError() for extended error
//*         information.
//*********************************************************************************
BOOL EFSPJobGroup_RemoveAllRecipients(LPEFSP_JOB_GROUP lpGroup, BOOL bCommit)
{
    LIST_ENTRY * lpNext = NULL;
    DWORD ec = ERROR_SUCCESS;


    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_RemoveAllRecipients"));
    if (!lpGroup)
    {
        return TRUE;
    }
    EnterCriticalSectionJobAndQueue;

    lpNext = lpGroup->RecipientJobs.Flink;
    Assert(lpNext);
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpGroup->RecipientJobs)
    {
        PJOB_QUEUE_PTR lpGroupJobPtr;
        lpGroupJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpGroupJobPtr->ListEntry.Flink;
        //
        // Remove the next recipient from the group. This frees the memory
        // and updates the persisten file at each step.

        if (!EFSPJobGroup_RemoveRecipient(
                        lpGroup,
                        lpGroupJobPtr->lpJob,
                        FALSE
                        ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSPJobGroup_RemoveRecipient() failed for JobId: %ld (ec: %ld)"),
                lpGroupJobPtr->lpJob->JobId,
                GetLastError());
            ASSERT_FALSE;
        }
    }

    if (bCommit)
    {
        if (!EFSPJobGroup_Save(lpGroup))
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSPJobGroup_Save() failed for EFSP job group %s(ec: %ld)"),
                lpGroup->lptstrPersistFile,
                ec);
            goto Error;

        }
    }

    Assert (ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert (ERROR_SUCCESS != ec);
Exit:
    LeaveCriticalSectionJobAndQueue;
    return (ERROR_SUCCESS == ec);
}



//*********************************************************************************
//* Name:   EFSPJobGroup_Free()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Frees all the resources the group consumes in memory and removes
//*     its persistent file. The group shold NOT be part of the group list
//*     when this function is called.
//*
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         The group to be destroied.
//*     [XXX]    BOOL bDestroy
//*         TRUE if the memory pointer by the previous parameter should be freed
//*         as well.
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If it failed. Call GetLastError() for extended error information.
//*********************************************************************************
BOOL EFSPJobGroup_Free(LPEFSP_JOB_GROUP lpGroup, BOOL bDestroy)
{
    LIST_ENTRY * lpNext = NULL;
    DWORD ec = ERROR_SUCCESS;


    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_Free"));
    if (!lpGroup)
    {
        return TRUE;
    }
    EnterCriticalSectionJobAndQueue;
    EnterCriticalSection(&g_csEFSPJobGroups);

    lpNext = lpGroup->RecipientJobs.Flink;
    Assert(lpNext);
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpGroup->RecipientJobs)
    {
        PJOB_QUEUE_PTR lpGroupJobPtr;
        lpGroupJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpGroupJobPtr->ListEntry.Flink;
        //
        // Remove the next recipient from the group. This frees the memory
        // and updates the persisten file at each step.

        if (!EFSPJobGroup_RemoveRecipient(
                        lpGroup,
                        lpGroupJobPtr->lpJob,
                        FALSE                   // Don't update the persisten file (optimization)
                        ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSPJobGroup_RemoveRecipient() failed for JobId: %ld (ec: %ld)"),
                lpGroupJobPtr->lpJob->JobId,
                GetLastError());
            ASSERT_FALSE;
        }
    }

    //
    // Free the parent permanent id.
    //

    if (!FreePermanentMessageId(&lpGroup->FSPIParentPermanentId, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FreePermanentMessageId() failed for parent permanent id. (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    //
    //Delete the persistent file (does nothing if the group is not persisted yet).
    //

    if (!EFSPJobGroup_DeleteFile(lpGroup))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EFSPJobGroup_DeleteFile() failed. (ec: %ld)"),
            GetLastError());
        ASSERT_FALSE;
    }

    //
    // Free the persistence file name memory
    //
    MemFree(lpGroup->lptstrPersistFile);


    if (bDestroy)
    {
        MemFree(lpGroup);
    }
    Assert( ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert( ERROR_SUCCESS != ec);
Exit:
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }

    LeaveCriticalSection(&g_csEFSPJobGroups);
    LeaveCriticalSectionJobAndQueue;

    return (ERROR_SUCCESS == ec);

}


//*********************************************************************************
//* Name:   EFSPJobGroup_IsPersistent()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Reports TRUE if the group was alrady persisted to a file.
//* PARAMETERS:
//*     [IN ]   LPCEFSP_JOB_GROUP lpcGroup
//*         The group for which the persistency state is to be determined.
//* RETURN VALUE:
//*     TRUE
//*         If the group was already persisted to a file.
//*     FALSE
//*         If it was not yet persisted to a file.
//*********************************************************************************
BOOL EFSPJobGroup_IsPersistent(LPCEFSP_JOB_GROUP lpcGroup)
{

    return (NULL != lpcGroup->lptstrPersistFile);
}

#if DBG
//*********************************************************************************
//* Name:   EFSPJobGroup_Dump()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Dumps the content of an EFSP job group.
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         A pointer to the group to dump.
//* RETURN VALUE:
//*     TRUE
//*         Allways.
//*     FALSE
//*         Never.
//*********************************************************************************
BOOL EFSPJobGroup_Dump(LPEFSP_JOB_GROUP lpGroup)
{
    LIST_ENTRY * lpNext = NULL;
    DWORD nRecp = 0;
    Assert(lpGroup);

    EnterCriticalSection( &g_csEFSPJobGroups);

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_Dump"));
    DebugPrintEx(
        DEBUG_MSG,
        TEXT("EFSP Job Group on line: %s"),
        lpGroup->lpLineInfo->DeviceName);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Recipint Count: %ld"),
        lpGroup->dwRecipientJobs);


    lpNext = lpGroup->RecipientJobs.Flink;
    Assert(lpNext);
    nRecp = 0;
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpGroup->RecipientJobs)
    {
        PJOB_QUEUE_PTR lpGroupJobPtr;
        lpGroupJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpGroupJobPtr->ListEntry.Flink;
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Recipient %ld.  JobId: %ld Recipient Number: %s"),
            nRecp,
            lpGroupJobPtr->lpJob->JobId,
            lpGroupJobPtr->lpJob->RecipientProfile.lptstrFaxNumber);
        nRecp++;
    }
    LeaveCriticalSection( &g_csEFSPJobGroups);

    return TRUE;

}
#endif



//*********************************************************************************
//* Name:   EFSPJobGroup_Serialize()
//* Author: Ronen Barenboim
//* Date:   June 07, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Returns a buffer with a serialization of EFSPJobGroup. The buffer contains
//*     a filled EFSP_JOB_GROUP_SERIALIZED structure which is followed by the
//*     unique job id of each recipient job in the group (excpet for the first one
//*     which is already contained in the structure itself).
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         The group job for which the buffer is to be generated.
//*
//*     [IN ]    LPBYTE lpBuffer
//*         A pointer to a caller allocated buffer where the function will place
//*         the serialized content of the job group.
//*         If this pointer is NULL the function will not serialize into the
//*         buffer but provide the required buffer size in the DWORD pointer to by
//*         the lpdwBufferSize parameter.
//*
//*     [IN/OUT] LPDWORD lpdwBufferSize
//*         If lpBuffer is not NULL this is a pointer to a DWORD that contains
//*         the size of the serialization buffer. On return itt will be set to the
//*         actual size used.
//*
//*         If lpBuffer is NULL this is a pointer to a DWORD that will receive
//*         the required buffer size.
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If the serialization buffer is not larger enough.
//*********************************************************************************
BOOL EFSPJobGroup_Serialize(LPEFSP_JOB_GROUP lpGroup, LPBYTE lpBuffer, LPDWORD lpdwBufferSize)
{
    LIST_ENTRY * lpNext = NULL;
    LPEFSP_JOB_GROUP_SERIALIZED lpSerGroup = NULL;
    DWORD dwSerSize = 0;
    DWORD nRecp = 0;
    ULONG_PTR ulptrOffset;
    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_Serialize"));
    Assert(lpGroup);
    Assert(lpdwBufferSize);
    Assert( lpGroup->dwRecipientJobs >=1 );

    dwSerSize = sizeof(EFSP_JOB_GROUP_SERIALIZED) +
                lpGroup->FSPIParentPermanentId.dwIdSize +
                (lpGroup->dwRecipientJobs-1)*sizeof(DWORDLONG);// -1 because the structure already has space for one uniqueid.



    Assert(dwSerSize >= sizeof(EFSP_JOB_GROUP_SERIALIZED));
    if (!lpBuffer)
    {
        //
        // just return the required size
        //
        (*lpdwBufferSize) = dwSerSize;
        return TRUE;

    }

    if ((*lpdwBufferSize) >= dwSerSize)
    {
        //
        // Buffer size is sufficient. Fill the buffer.
        //
        lpSerGroup = (LPEFSP_JOB_GROUP_SERIALIZED)lpBuffer;
        memset(lpSerGroup, 0, sizeof(EFSP_JOB_GROUP_SERIALIZED));
        lpSerGroup->dwPermanentLineId = lpGroup->lpLineInfo->PermanentLineID;
        lpSerGroup->dwRecipientJobsCount = lpGroup->dwRecipientJobs;
        memcpy(&lpSerGroup->dwSignature, EFSP_JOB_GROUP_SERIALIZATION_SIGNATURE, sizeof(DWORD));


        //
        // Serialize the recipient job unique ids
        //

        lpNext = lpGroup->RecipientJobs.Flink;
        Assert(lpNext);
        nRecp = 0;
        while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpGroup->RecipientJobs)
        {
            PJOB_QUEUE_PTR lpGroupJobPtr = NULL;
            lpGroupJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
            lpNext = lpGroupJobPtr->ListEntry.Flink;
            Assert(nRecp < lpSerGroup->dwRecipientJobsCount);
            lpSerGroup->dwlRecipientJobs[nRecp] = lpGroupJobPtr->lpJob->UniqueId;
            nRecp++;
        }
        Assert(nRecp != 0);
        //
        // Serialize the permanent message id
        //
        if (lpGroup->FSPIParentPermanentId.lpbId)
        {
            ulptrOffset = (LPBYTE)&(lpSerGroup->dwlRecipientJobs[nRecp]) - (LPBYTE)lpSerGroup;

            lpSerGroup->FSPIParentPermanentId.dwIdSize =  lpGroup->FSPIParentPermanentId.dwIdSize;
            lpSerGroup->FSPIParentPermanentId.lpbId = (LPBYTE)ulptrOffset;
            memcpy(&(lpSerGroup->dwlRecipientJobs[nRecp]), lpGroup->FSPIParentPermanentId.lpbId, lpGroup->FSPIParentPermanentId.dwIdSize);
        }

        //
        // Report the actually used size.
        //
        *lpdwBufferSize = dwSerSize;
        return TRUE;
    }
    else
    {
        //
        // Buffer size is sufficient. Report the required size.
        //
        *lpdwBufferSize = dwSerSize;
        return FALSE;
    }
}




//*********************************************************************************
//* Name:   EFSPJobGroup_Unserialize()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Constructs a EFSP_JOB_GROUP form its serialization buffer.
//* PARAMETERS:
//*     [IN ]   LPBYTE lpBuffer
//*         A pointer to the serialization buffer.
//*
//*     [IN ]   DWOR dwBufferSize;
//*         The size of the serialization buffer.
//*
//* RETURN VALUE:
//*         TRUE if the operation succeeded.
//*         FALSE if it failed. Call GetLastError() for extended error information.
//*********************************************************************************
LPEFSP_JOB_GROUP EFSPJobGroup_Unserialize(LPBYTE lpBuffer, DWORD dwBufferSize)
{

    LPEFSP_JOB_GROUP_SERIALIZED lpSerGroup;
    DWORD nRecp = 0;
    LPEFSP_JOB_GROUP lpGroup = NULL;
    DWORD ec = ERROR_SUCCESS;
    FSPI_MESSAGE_ID TempId;
    DWORD dwRequiredBufferSize = 0;

    Assert(lpBuffer);

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_Unserialize"));

    EnterCriticalSectionJobAndQueue;
    EnterCriticalSection(&g_csEFSPJobGroups);


    lpSerGroup = (LPEFSP_JOB_GROUP_SERIALIZED)lpBuffer;



    if (memcmp(&lpSerGroup->dwSignature, EFSP_JOB_GROUP_SERIALIZATION_SIGNATURE, sizeof(DWORD)))
    {
        ec = ERROR_INVALID_DATA;
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Invalid structure signature 0x%08X"),
            lpSerGroup->dwSignature);
        goto Error;
    }

    if (dwBufferSize < sizeof(EFSP_JOB_GROUP_SERIALIZED))
    {
        ec = ERROR_INVALID_DATA;
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Invalid structure size (%ld) ( < sizeof(EFSP_JOB_GROUP) )"),
            dwBufferSize);
        goto Error;
    }

    dwRequiredBufferSize =
                sizeof(EFSP_JOB_GROUP_SERIALIZED) +
                lpSerGroup->FSPIParentPermanentId.dwIdSize +
                (lpSerGroup->dwRecipientJobsCount-1)*sizeof(DWORDLONG);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("JobCount: %ld , Parent Permanent Id Size: %ld, Required Buffer Size: %ld, Serialization Buffer Size: %ld)"),
        lpSerGroup->dwlRecipientJobs,
        lpSerGroup->FSPIParentPermanentId.dwIdSize,
        dwRequiredBufferSize,
        dwBufferSize);

    if ( dwRequiredBufferSize > dwBufferSize)
    {
        ec = ERROR_INVALID_DATA;
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Buffer size is smaller than that required by the serialized group information."));
        goto Error;
    }

    lpGroup = (LPEFSP_JOB_GROUP)MemAlloc(sizeof(EFSP_JOB_GROUP));
    if (!lpGroup)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Failed to allocate EFSP_JOB_GROUP (ec: %ld)"),
            ec);
        goto Error;
    }




    memset(lpGroup, 0, sizeof(EFSP_JOB_GROUP));
    InitializeListHead(&lpGroup->RecipientJobs);

    lpGroup->lpLineInfo = GetTapiLineFromDeviceId(lpSerGroup->dwPermanentLineId,FALSE);
    if (!lpGroup->lpLineInfo)
    {
        ec = ERROR_NOT_FOUND;
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Failed to find a line matching line id : 0x%08X"),
            lpSerGroup->dwPermanentLineId);
        goto Error;
    }



    //
    // Add the recipient jobs to the group based on thier persisted unique ids.
    //
    for (nRecp = 0; nRecp < lpSerGroup->dwRecipientJobsCount; nRecp++)
    {
        PJOB_QUEUE lpRecipientJob = NULL;

        Assert(lpSerGroup->dwlRecipientJobs[nRecp]);
        lpRecipientJob = FindJobQueueEntryByUniqueId(lpSerGroup->dwlRecipientJobs[nRecp]);
        if (!lpRecipientJob)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to find recipient job with UniqueId: 0x%016I64X for group item: %ld (ec: %ld)"),
                lpSerGroup->dwlRecipientJobs[nRecp],
                nRecp,
                ec);
            goto Error;
        }
        Assert(JT_SEND == lpRecipientJob->JobType); // Must be a recipient job

        //
        // Add the recipient job to the group
        //
        if ((JS_COMPLETED != lpRecipientJob->JobStatus) &&
            (JS_CANCELED != lpRecipientJob->JobStatus) &&
            (JS_RETRIES_EXCEEDED != lpRecipientJob->JobStatus))
        {

            if (!EFSPJobGroup_AddRecipient(lpGroup,lpRecipientJob, FALSE)) // no point to commit during unserialization
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to add recipient to the group. JobId: %ld UniqueId: 0x%016I64X (ec: %ld)"),
                    lpRecipientJob->JobId,
                    lpSerGroup->dwlRecipientJobs[nRecp],
                    ec);
                goto Error;
            }
        }
    }

    if (!lpGroup->dwRecipientJobs)
    {
        //
        // All the recipient jobs are comlpleted/failed/canceled
        // We treat this as an error since the group should be
        // deleted in this case.
        // Note that we will not reestablish for the parent job
        // if all the recipient jobs are done.
        //
        ec = ERROR_INVALID_DATA;
        goto Error;
    }

    //
    // Unserialize the parent permanent message id
    //
    if (lpSerGroup->FSPIParentPermanentId.dwIdSize)
    {
        Assert(lpSerGroup->FSPIParentPermanentId.lpbId);
        TempId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
        TempId.dwIdSize = lpSerGroup->FSPIParentPermanentId.dwIdSize;
        TempId.lpbId = (LPBYTE)(lpSerGroup) + (ULONG_PTR)(lpSerGroup->FSPIParentPermanentId.lpbId);
        if (!CopyPermanentMessageId(&lpGroup->FSPIParentPermanentId, &TempId))
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CopyPermanentMessageId() failed(). (ec: %ld)"),
                ec);
            goto Error;
        }
    }


    Assert( ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert( ERROR_SUCCESS != ec);


    if (!EFSPJobGroup_Free(lpGroup, TRUE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EFSPJobGroup_Free() failed. (ec: %ld)"),
            GetLastError());
        ASSERT_FALSE;
    }

    lpGroup = NULL;
Exit:
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }

    LeaveCriticalSection(&g_csEFSPJobGroups);
    LeaveCriticalSectionJobAndQueue;

    return lpGroup;
}


//*********************************************************************************
//* Name:   EFSPJobGroup_Load()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Loada a EFSP job group file and constructs an EFSP_JOB_GROUP from it.
//* PARAMETERS:
//*     [IN ]   LPCTSTR lpctstrFileName
//*         The full path to the file.
//* RETURN VALUE:
//*     If successfull it returns a pointer to a newly allocated EFSP_JOB_GROUP.
//*     On failure it returns NULL. Call GetLastError() for extended error
//*     information.
//*********************************************************************************
LPEFSP_JOB_GROUP EFSPJobGroup_Load(LPCTSTR lpctstrFileName)
{

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD ec = ERROR_SUCCESS;
    LPBYTE lpBuffer = NULL;
    LPEFSP_JOB_GROUP lpGroup = NULL;
    DWORD dwSize = 0;
    DWORD dwReadSize = 0;

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_Load"));

    Assert(lpctstrFileName);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Loading EFSP job group from file : [%s]"),
        lpctstrFileName);

     hFile = CreateFile(
        lpctstrFileName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to open file %s for reading. (ec: %ld)"),
            lpctstrFileName,
            ec);
        goto Error;
    }
    //
    // See if we did not stumble on some funky file which is smaller than the
    // minimum file size.
    //
    dwSize = GetFileSize( hFile, NULL );
    if (0xFFFFFFFF == dwSize)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("GetFileSize() failed (ec: %ld)"),
            ec);
        goto Error;
    }
    if (dwSize < sizeof(EFSP_JOB_GROUP_SERIALIZED)) {
        ec = ERROR_INVALID_DATA;
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("EFSP Job Group file %s size is %ld which is smaller than the sizeof(EFSP_JOB_GROUP_SERIALIZED).Deleting file."),
            lpctstrFileName,
            dwSize);
        goto Error;
    }

    //
    // Allocate the required buffer to read the entire file into memory.
    //

    Assert(dwSize > 0);
    lpBuffer = (LPBYTE)MemAlloc(dwSize);
    if (!lpBuffer)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocated read buffer of size %ld. (ec: %ld)"),
            dwSize,
            ec);
        goto Error;

    }
    //
    // Read the file content according to the reported file size.
    //
    if (!ReadFile( hFile, lpBuffer, dwSize, &dwReadSize, NULL )) {
        ec = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read %ld bytes from EFSP job group file %s. %ld bytes read. (ec: %ld)"),
                      dwSize,
                      dwReadSize,
                      lpctstrFileName,
                      ec);
        goto Error;
    }

    Assert(dwSize == dwReadSize);

    //
    // Unserialize the buffer into a EFSP job group
    //
    Assert(lpBuffer);
    lpGroup = EFSPJobGroup_Unserialize(lpBuffer, dwSize);
    if (!lpGroup)
    {
        ec = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed unserialze EFSP job group from buffer read from file : [%s] (ec: %ld)"),
                      lpctstrFileName,
                      ec);
        goto Error;
    }
    //
    // Set the persistent file name (it is not part of the serialized data).
    //
    lpGroup->lptstrPersistFile = StringDup(lpctstrFileName);
    if (!lpGroup->lptstrPersistFile)
    {
        ec = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                      TEXT("StringDup() of persistence file name failed (ec: %ld)"),
                      ec);
        goto Error;
    }

    Assert( ERROR_SUCCESS == ec);
    goto Exit;


Error:
    Assert( ERROR_SUCCESS != ec);



    MemFree(lpBuffer);
    lpBuffer = NULL;
    if (!EFSPJobGroup_Free(lpGroup, TRUE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EFSPJobGroup_Free() failed (ec: %ld)"),
            GetLastError());
    }
    lpGroup = NULL;
Exit:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }

    MemFree(lpBuffer);

    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }

    return lpGroup;
}



//*********************************************************************************
//* Name:   EFSPJobGroup_Save()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Saves an EFSP job group to a persistent file. Creates the file if it does
//*     not already exists.
//* PARAMETERS:
//*     [XXX]   LPEFSP_JOB_GROUP lpGroup
//*
//*     [XXX]    BOOL bCreate
//*
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//*
//*********************************************************************************
BOOL EFSPJobGroup_Save(LPEFSP_JOB_GROUP lpGroup)
{

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD ec = ERROR_SUCCESS;
    LPBYTE lpBuffer = NULL;
    DWORD dwActualWriteSize = 0;
    DWORD dwRequiredSize = 0;
    TCHAR TempFile[MAX_PATH] = TEXT("");

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_Save"));


    if (!lpGroup->lptstrPersistFile)
    {
        //
        // If we don't already have a persistent file associated with this group then
        // create it know.
        //

        //
        // Generate a persistence file for the group
        //
         if (!GenerateUniqueFileName( g_wszFaxQueueDir, JOB_GROUP_FILE_EXTENSION, TempFile, sizeof(TempFile)/sizeof(WCHAR) ))
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GenerateUniqueFileName() failed while generate unique file for EFSP job group (ec: %ld)."),
                ec);
            goto Error;
        }

         lpGroup->lptstrPersistFile = StringDup(TempFile);
         if (! lpGroup->lptstrPersistFile )
         {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StringDup() failed while duplicating unique file name for EFSP job group (ec: %ld)."),
                ec);
            goto Error;
         }

    }


    Assert(lpGroup->lptstrPersistFile);


    hFile = CreateFile(
        lpGroup->lptstrPersistFile,
        GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
        NULL
        );
    if (INVALID_HANDLE_VALUE == hFile ) {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to open file %s for write operation. (ec: %ld)"),
            lpGroup->lptstrPersistFile,
            ec);
        goto Error;
    }


    //
    // Calculate the required buffer size
    //
    if (!EFSPJobGroup_Serialize(lpGroup, NULL, &dwRequiredSize))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to get the serialization buffer size. (ec: %ld)"),
            ec);
        goto Error;
    }

    //
    // Allocate the required buffer size
    //
    Assert (dwRequiredSize >= sizeof(EFSP_JOB_GROUP_SERIALIZED));
    lpBuffer = (LPBYTE)MemAlloc(dwRequiredSize);
    if (!lpBuffer)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate serialization buffer of size: %ld. (ec: %ld)"),
            dwRequiredSize,
            ec);
        goto Error;
    }

    //
    // Serialize the group into the allocated buffer
    //
    if (!EFSPJobGroup_Serialize(lpGroup, lpBuffer, &dwRequiredSize))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to sertialize EFSP job group (Buffer size: %ld). (ec: %ld)"),
            dwRequiredSize,
            ec);
        goto Error;
    }

    //
    // Write the serialized buffer into the file
    //

    //
    // Write the buffer to the disk file
    //
    if (!WriteFile( hFile, lpBuffer, dwRequiredSize, &dwActualWriteSize, NULL )) {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to write serialization buffer into file %s (ec: %ld)."),
            lpGroup->lptstrPersistFile,
            ec);
        goto Error;

    }
    Assert( dwRequiredSize == dwActualWriteSize);


    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Successfuly persisted EFSP job group to file %s"),
        lpGroup->lptstrPersistFile);


    Assert( ERROR_SUCCESS == ec);
    goto Exit;

Error:
    Assert( ERROR_SUCCESS != ec);
    if (TempFile[0])
    {
        //
        // We generated a new file but did not succeed in writing to it.
        // Delete it.
        //
        lpGroup->lptstrPersistFile = NULL;
        if (!DeleteFile(TempFile))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to delete persistence file %s (ec: %ld)"),
                TempFile,
                GetLastError());
        }
    } else
    {
        //
        // If we failed writing to an existing file we do not delete the file.
        //
    }

Exit:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }

    MemFree(lpBuffer);

    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }

    return ( ERROR_SUCCESS == ec);
}



//*********************************************************************************
//* Name:   EFSPJobGroup_Validate()
//* Author: Ronen Barenboim
//* Date:   June 15, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Validates a job group. Checks that all the recipients it points
//*     too contain a valid permanent id.
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         The group to validate.
//* RETURN VALUE:
//*     TRUE
//*         If the group is valid.
//*     FALSE
//*         If the group is invalid.
//*********************************************************************************
BOOL EFSPJobGroup_Validate(LPEFSP_JOB_GROUP lpGroup)
{

    DWORD ec = ERROR_SUCCESS;
    DWORD dwRecp = 0;

    LIST_ENTRY * lpNext = NULL;

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_Validate"));

    Assert(lpGroup);
    Assert(lpGroup->dwRecipientJobs > 0);
    Assert(lpGroup->lpLineInfo);


    EnterCriticalSectionJobAndQueue;

    lpNext = lpGroup->RecipientJobs.Flink;
    Assert(lpNext);
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpGroup->RecipientJobs)
    {
        Assert(dwRecp < lpGroup->dwRecipientJobs);
        PJOB_QUEUE_PTR lpGroupJobPtr = NULL;
        PJOB_QUEUE lpRecipientJob;
        lpGroupJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpRecipientJob = lpGroupJobPtr->lpJob;

        lpNext = lpGroupJobPtr->ListEntry.Flink;

        //
        // Make sure that the recipient job actually has the permanent id.
        //
        if (0 == lpRecipientJob->EFSPPermanentMessageId.dwIdSize)
        {
            ec = ERROR_INVALID_DATA;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("The EFSP Job Group contains a job (JobId: %ld) without a permanent id. Invalid group."),
                lpRecipientJob->JobId);
            goto Error;
        }
        dwRecp++;
    }
    Assert( ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert( ERROR_SUCCESS != ec);
Exit:
    LeaveCriticalSectionJobAndQueue;

    return (ERROR_SUCCESS == ec);
}


//*********************************************************************************
//* Name:   EFSPJobGroup_Reestablish()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Reestablishes the job context for each member of the job group.
//*     The function calls FaxDevReestablishJobContext() with information on all
//*     the group members and then creates the JOB_ENTRY structure for each job.
//*
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//* REMARKS:
//*     To asure mutual exclusion on the group itself one should lock
//*     g_csEFSPJobGroups before calling this function.
//*********************************************************************************
BOOL EFSPJobGroup_Reestablish(LPEFSP_JOB_GROUP lpGroup)
{

    LPFSPI_MESSAGE_ID lpRecipientMessageId = NULL;
    PHANDLE lphRecipientJobs = NULL;
    HRESULT hr = S_OK;
    BOOL bFaxDevReestablishJobContextCalled = FALSE;
    DWORD ec = ERROR_SUCCESS;
    DWORD dwRecipient = 0;
    LIST_ENTRY * lpNext = NULL;
    PLINE_INFO lpActualLine = NULL;

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_Reestablish"));

    Assert(lpGroup);
    Assert(lpGroup->dwRecipientJobs > 0);
    Assert(lpGroup->lpLineInfo);


    EnterCriticalSectionJobAndQueue;


    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Reestablishing job group [%s] on EFSP [%s] line [%s]"),
        lpGroup->lptstrPersistFile,
        lpGroup->lpLineInfo->Provider->FriendlyName,
        lpGroup->lpLineInfo->DeviceName);
    //
    // Get hold of the line on which the reestablish is to commence
    //
    lpActualLine = GetTapiLineForFaxOperation(
                        lpGroup->lpLineInfo->PermanentLineID,
                        JT_SEND,
                        TEXT(""),   // No number
                        FALSE,      // Not a handoff job
                        FALSE,      // not just a query
                        FALSE       // Do not ignore line state.
                        );
    if (!lpActualLine)
    {
        //
        // The line is not available for use - THIS SHOULD NEVER happen.
        // Fail the reestablish process.
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to get hold of line %s. THIS SHOULD NEVER HAPPEN."),
            lpGroup->lpLineInfo->DeviceName);
        ASSERT_FALSE;
        ec = GetLastError();
        goto Error;
    }

    //
    // Create the permanent message id array used as an input parameter
    // to FaxDevReestablishJobContext().
    //
    lpRecipientMessageId = EFSPJobGroup_CreateMessageIdsArray(lpGroup);
    //
    // Note: This allocates the array but does NOT allocate memory for each id.
    // DO NOT USE FreeFSPIRecipientMessageIdsArray() to clean it !!!
    // Just free the array pointer !!!
    //
    if (!lpRecipientMessageId)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EFSPJobGroup_CreateMessageIdsArray() failed (ec: %ld)"),
            ec);
        goto Error;
    }

    //
    // Create the output array of recipient job handles
    //
    lphRecipientJobs = (PHANDLE) MemAlloc(lpGroup->dwRecipientJobs * sizeof(HANDLE));
    if (!lphRecipientJobs)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate job handles array (size: %ld) (ec: %ld)"),
            lpGroup->dwRecipientJobs * sizeof(HANDLE),
            ec);
        goto Error;
    }


    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Calling FaxDevReestablishJobContext()..."));

    __try
    {
        //
        // Call FaxDevReestablishJobContext
        //
        Assert(lpGroup->lpLineInfo->Provider->FaxDevReestablishJobContext);
        hr = lpGroup->lpLineInfo->Provider->FaxDevReestablishJobContext(
                lpGroup->lpLineInfo->hLine,
                lpGroup->lpLineInfo->TapiPermanentLineId,
                &lpGroup->FSPIParentPermanentId,
                &lpGroup->hFSPIParent,
                lpGroup->dwRecipientJobs,
                lpRecipientMessageId,
                lphRecipientJobs);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxDevReestablishJobContext * CRASHED * (Exception Code: 0x%08X)"),
            GetExceptionCode());
        ec = ERROR_INVALID_FUNCTION;
        goto Error;
    }

    if (FAILED(hr))
    {
        //
        // FaxDevReestablishJobContext() failed. We need to handle the error code.
        //
        switch (hr)
        {
            case FSPI_E_INVALID_MESSAGE_ID:
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("EFSP reported FSPI_E_INVALID_MESSAGE_ID"));
                ec = ERROR_INVALID_DATA;
                break;
            case FSPI_E_FAILED:
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("EFSP reported FSPI_E_FAILED"));
                ec = ERROR_GEN_FAILURE;
                break;
            default:
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("EFSP reported unsupported error code (hr = 0x%08X)"),
                    hr);
                ASSERT_FALSE;
                ec = ERROR_GEN_FAILURE;
                break;
        }
        goto Error;
    }

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("FaxDevReestablishJobContext() completed successfully..."));

    //
    // Mark the fact that we successfully called FaxDevReestablishJobContext()
    // we will use it to determine if we need to call End/Abort job if an
    // error occurs later on.
    //
    bFaxDevReestablishJobContextCalled = TRUE;

    //
    // Validate that the returned job handles are all unique and not NULL.
    //

    if (!ValidateEFSPJobHandles(lphRecipientJobs, lpGroup->dwRecipientJobs))
    {
        ec = GetLastError();
        if (ERROR_SUCCESS != ec)
        {
            //
            // The function failed.
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ValidateEFSPJobHandles() failed because of an error (ec: %ld)"),
                ec);
                goto Error;
        }
        else
        {
            //
            // The function reported invalid handles array
            //
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("The EFSP returned invalid job handles.."));
            goto Error;

            //
            // Note: although the handles are not valid we will call FaxDevEndJob()
            //       and FaxDevAbort() with these job handles as part of the cleanup.
            //       hopefully the EFSP will be able to cleanup at least part of the mess.
            //       If it crashes we will catch this.
            //
        }

    }

    //
    // The reestablish process succeeded and the job handles are valid. We need to create job entries for all
    // the reestablish jobs.
    //

    //
    // Go over the recipient jobs in the group. For each recipient job:
    //   - Increase the job reference count
    //   - Set job status to JS_INPROGRESS
    //   - Create a JOB_ENTRY and add it to the running job list
    //   - store the returned EFSP job handle in the job entry and marks it as running an FSP job
    //   - Associate the EFSP job handle with the job intry in the FSP job map.
    dwRecipient = 0;
    lpNext = lpGroup->RecipientJobs.Flink;
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpGroup->RecipientJobs)
    {
        PJOB_ENTRY lpJobEntry;
        PJOB_QUEUE_PTR lpRecipientsGroupMember;
        lpRecipientsGroupMember = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpNext->Flink;
        Assert(dwRecipient < lpGroup->dwRecipientJobs);

        //
        // Set the job to the in progress state
        //
        lpRecipientsGroupMember->lpJob->JobStatus = JS_INPROGRESS;
        //
        // Create a job entry for each recipient job
        //

        //
        //  If EFSP set USE_DIALABLE_ADDRESS, then translate the number for it
        //

        lpJobEntry = CreateJobEntry(
                        lpRecipientsGroupMember->lpJob,
                        lpGroup->lpLineInfo,
                        (lpGroup->lpLineInfo->Provider->dwCapabilities & FSPI_CAP_USE_DIALABLE_ADDRESS),
                        FALSE // No handoff job at reestablish
                     );

        if (!lpJobEntry)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateJobEntry() failed for recipient JobId: %ld (ec: %ld)"),
                lpRecipientsGroupMember->lpJob->JobId,
                GetLastError());
            goto Error;
        }
        //
        // Add the JOB_ENTRY to the list of running jobs
        //
        InsertTailList( &g_JobListHead, &lpJobEntry->ListEntry );

        //
        // The EFSP is running a job for this job entry.
        //
        lpJobEntry->bFSPJobInProgress = TRUE;

        //
        // Link the job entry to the recipient job.
        //
        lpRecipientsGroupMember->lpJob->JobEntry = lpJobEntry;
        //
        // Save the EFSP recipient job handle in the job entry
        //
        lpJobEntry->InstanceData = lphRecipientJobs[dwRecipient];
        //
        // Associate the job entry with the FSP job handle
        //
        ec = AddFspJob(lpGroup->lpLineInfo->Provider->hJobMap,
                       (HANDLE) lpJobEntry->InstanceData,
                       lpJobEntry);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("[Job: %ld] AddFspJob failed (ec: %ld)"),
                         lpJobEntry->lpJobQueueEntry->JobId,
                         ec);
            goto Error;
        }
        dwRecipient++;
    }


    Assert( 0 == ec);
    //
    // Successfully added dwRecipient new sending jobs on a device. Update counter.
    // NOTICE: we're not sending events here because the RPC is not up yet.
    //
    (VOID) UpdateDeviceJobsCounter ( lpGroup->lpLineInfo,   // Device to update
                                     TRUE,                  // Sending
                                     dwRecipient,           // Number of new jobs
                                     FALSE);                // Disable events

    goto Exit;


Error:
    Assert( 0 != ec);

    //
    // Free the line we got hold of
    // (we can call this function even if the line is already released with no harm)
    // The line must be freed even if we did not get to the stage where a job
    // entry was created.
    // In case we did create job entries ReleaseTapiLine() will be called for each job
    // as part of TerminateMultipleFSPJobs() which calls EndJob() for each job.
    // Since it is not harmful to release a line twice nothing will go wrong.
    //

    if (lpActualLine)
    {
        if (!ReleaseTapiLine(lpActualLine, NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReleaseTapiLine() failed (ec: %ld)"),
                GetLastError());
        }

    }

    //
    // Call Abort and EndJob for all the returned FSP job handles
    //
    if (bFaxDevReestablishJobContextCalled)
    {
        if (!TerminateMultipleFSPJobs(lphRecipientJobs, lpGroup->dwRecipientJobs,lpGroup->lpLineInfo))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("TerminateMultipleFSPJobs() failed (ec: %ld)"),
                GetLastError());
        }

        //
        // Clean up all the run time jobs we created so far and set the recipient
        // job state to a JS_RETRIES_EXCEEDED state. The new job state is commited
        // to file.
        //
        if (!EFSPJobGroup_ExecutionFailureCleanup(lpGroup))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSPJobGroup_ExecutionFailureCleanup() failed (ec: %ld)"),
                GetLastError());
            ASSERT_FALSE;
        }

    }


Exit:

    //
    // Free the recipient message ids array
    //
    MemFree(lpRecipientMessageId);

    //
    // Free the recipient job handles array
    //
    MemFree(lphRecipientJobs);

    LeaveCriticalSectionJobAndQueue;


    if (ec)
    {
        SetLastError(ec);
    }
    return (0 == ec);
}
//*********************************************************************************
//* Name:   EFSPJobGroup_CreateMessageIdsArray()
//* Author: Ronen Barenboim
//* Date:   June 10, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a FSPI message id array for the recipients in the group.
//*     The array elements points to the permanent ids in the recipient jobs
//*     (no memory allocation for each id).
//* PARAMETERS:
//*     [IN ]   LPCEFSP_JOB_GROUP lpcGroup
//*         Pointer to the group for which the message id array will be created.
//* RETURN VALUE:
//*     On success the function returns a pointer to the newly allocated message
//*     id array.
//*     On failure it returns NULL. Call GetLastError() to get extended error
//*     information.
//*********************************************************************************
LPFSPI_MESSAGE_ID EFSPJobGroup_CreateMessageIdsArray(LPCEFSP_JOB_GROUP lpcGroup)
{
    LIST_ENTRY * lpNext = NULL;
    DWORD ec = ERROR_SUCCESS;
    LPFSPI_MESSAGE_ID lpIdsArray =NULL;
    DWORD dwRecp = 0;

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_CreateMessageIdsArray"));

    lpIdsArray = (LPFSPI_MESSAGE_ID) MemAlloc(lpcGroup->dwRecipientJobs * sizeof(FSPI_MESSAGE_ID));
    if (!lpIdsArray)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate message id array (size: %ld) (ec: %ld)"),
            lpcGroup->dwRecipientJobs * sizeof(FSPI_MESSAGE_ID),
            ec);
        goto Error;
    }


    lpNext = lpcGroup->RecipientJobs.Flink;
    Assert(lpNext);

    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpcGroup->RecipientJobs)
    {
        PJOB_QUEUE_PTR lpGroupJobPtr = NULL;

        lpGroupJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpGroupJobPtr->ListEntry.Flink;
        Assert(lpGroupJobPtr);
        Assert(dwRecp < lpcGroup->dwRecipientJobs);
        lpIdsArray[dwRecp].dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
        lpIdsArray[dwRecp].dwIdSize = lpGroupJobPtr->lpJob->EFSPPermanentMessageId.dwIdSize;
        lpIdsArray[dwRecp].lpbId = lpGroupJobPtr->lpJob->EFSPPermanentMessageId.lpbId;
        Assert(lpIdsArray[dwRecp].dwIdSize);
        Assert(lpIdsArray[dwRecp].lpbId);
        dwRecp++;
    }

    Assert( ERROR_SUCCESS == ec );
    goto Exit;
Error:
    Assert( ERROR_SUCCESS != ec );
    MemFree(lpIdsArray);
    lpIdsArray = NULL;
Exit:
    if ( ERROR_SUCCESS != ec )
    {
        SetLastError(ec);
    }
    return ( lpIdsArray );

}


//*********************************************************************************
//* Name:   ReestablishEFSPJobGroups()
//* Author: Ronen Barenboim
//* Date:   June 15, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Reestablish the jobs in all the EFSP job groups in the g_EFSPJobGroupsHead
//*     list.
//* PARAMETERS:
//*     NONE
//* RETURN VALUE:
//*     TRUE
//*         If all the groups were reestablished successfully.
//*     FALSE
//*         If at least one group failed to reestablish. Note that the function
//*         will continue to reestablish other groups if a group fails.
//*********************************************************************************
BOOL ReestablishEFSPJobGroups()
{

    LIST_ENTRY * lpNext = NULL;
    BOOL bAllSucceeded = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("ReestablishEFSPJobGroups"));

    EnterCriticalSectionJobAndQueue;
    EnterCriticalSection(&g_csEFSPJobGroups);

    if (!LoadEFSPJobGroups())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("At least one EFSP Job Group failed to load."));
    }

    //
    // Go over the loaded groups and reestablish
    //

    lpNext = g_EFSPJobGroupsHead.Flink;
    Assert(lpNext);
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&g_EFSPJobGroupsHead)
    {
        LPEFSP_JOB_GROUP lpGroup = NULL;
        lpGroup = CONTAINING_RECORD( lpNext, EFSP_JOB_GROUP, ListEntry );
        lpNext = lpNext->Flink;
        Assert(lpGroup);
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Reestablishing group persisted at %s"),
            lpGroup->lptstrPersistFile);

        if (!EFSPJobGroup_Reestablish(lpGroup))
        {
            Assert(lpGroup->lptstrPersistFile);
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSPJobGroup_Reestablish() failed (ec: %ld)"),
                lpGroup->lptstrPersistFile,
                GetLastError());
            //
            // Cleanup after reestablish failure
            //
            if (!EFSPJobGroup_HandleReestablishFailure(lpGroup))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("EFSPJobGroup_HandleReestablishFailure failed. (ec: %ld)"),
                    GetLastError());
                ASSERT_FALSE;
            }

            bAllSucceeded = FALSE;
            continue;
        }
    }

    LeaveCriticalSection(&g_csEFSPJobGroups);
    LeaveCriticalSectionJobAndQueue;

    return bAllSucceeded;

}



//*********************************************************************************
//* Name:   EFSPJobGroup_HandleReestablishFailure()
//* Author: Ronen Barenboim
//* Date:   June 13, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Handles the case in which the jobs in the group could not be reestablished.
//*     It moves the member jobs into the retries exceeded state and
//*     frees the permanent message ids stored in them.
//*     It persists the jobs to disk with the new state and without the permanent
//*     message id.
//*
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         The job group for which the reestablish operation failed.
//* RETURN VALUE:
//*
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If it failed. Call GetLastError() for extended error information.
//*********************************************************************************
BOOL EFSPJobGroup_HandleReestablishFailure(LPEFSP_JOB_GROUP lpGroup)
{
    LIST_ENTRY * lpNext = NULL;

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_HandleReestablishFailure"));
    Assert(lpGroup);

    lpNext = lpGroup->RecipientJobs.Flink;
    Assert(lpNext);
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpGroup->RecipientJobs)
    {
        PJOB_QUEUE_PTR lpGroupJobPtr = NULL;

        lpGroupJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpGroupJobPtr->ListEntry.Flink;
        Assert(lpGroupJobPtr);

        //
        // Free the permanent message id of the attached job
        //
        if (!FreePermanentMessageId(&lpGroupJobPtr->lpJob->EFSPPermanentMessageId, FALSE))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] FreePermanentMessageId failed (ec: %ld)"),
                lpGroupJobPtr->lpJob->JobId,
                GetLastError());
            ASSERT_FALSE;
        }

        //
        // Need to define a job status for reeastablish jobs that failed.
        //
        //
        //
        // retries exceeded, mark job as expired, (also commits the job queue entry back to disk
        // so it is saved WITHOUT the permanent id)
        //
        if (0 == lpGroupJobPtr->lpJob->dwLastJobExtendedStatus)
        {
            //
            // Job was never really executed - this is a fatal error
            //
            lpGroupJobPtr->lpJob->dwLastJobExtendedStatus = FSPI_ES_FATAL_ERROR;
        }
        if (!MarkJobAsExpired(lpGroupJobPtr->lpJob))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
                lpGroupJobPtr->lpJob->JobId,
                GetLastError());
        }
    }
    return TRUE;
}

//*********************************************************************************
//* Name:   EFSPJobGroup_ExecutionFailureCleanup()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Cleans up the recipient jobs in the job group after the execution
//*     of these jobs failed. This works either for reestablish failure or send.
//*     The following cleanup actions are taken:
//*         - The reference count on the job is set to 0.
//*         - The job entry associated with the recipient job is freed, if it exists.
//*         - The recipient job is put in JS_RETRIES_EXCEEDED status and a check is
//*           done to see if it can already be archived.
//* NOTE: it DOES NOT FREE the PERMANENT ID in the recipient job.
//* PARAMETERS:
//*     [IN ]   LPEFSP_JOB_GROUP lpGroup
//*         The job group for which the cleanup is to be performed.
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//*
//*********************************************************************************
BOOL EFSPJobGroup_ExecutionFailureCleanup(LPEFSP_JOB_GROUP lpGroup)
{
    LIST_ENTRY * lpNext = NULL;

    DEBUG_FUNCTION_NAME(TEXT("EFSPJobGroup_HandleReestablishFailure"));
    Assert(lpGroup);

    EnterCriticalSectionJobAndQueue;

    lpNext = lpGroup->RecipientJobs.Flink;
    Assert(lpNext);
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpGroup->RecipientJobs)
    {
        PJOB_QUEUE_PTR lpGroupJobPtr = NULL;

        lpGroupJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        lpNext = lpGroupJobPtr->ListEntry.Flink;
        Assert(lpGroupJobPtr);

        //
        // If we already created a job entry for the recipient job
        // we need to free it.
        //
        if (lpGroupJobPtr->lpJob->JobEntry)
        {
            lpGroupJobPtr->lpJob->JobEntry->Released = TRUE;

            if (!FreeJobEntry(lpGroupJobPtr->lpJob->JobEntry, TRUE))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("EndJob() failed for JobId: %ld (ec: %ld)"),
                    lpGroupJobPtr->lpJob->JobId,
                    GetLastError());
                Assert(FALSE);
            }
            else
            {
                lpGroupJobPtr->lpJob->JobEntry = NULL;
            }
        }

        //
        // Put the job into final error state.
        //
        // We need to define a state for FATAL_ERRORS
        //
        //
        // Note that MarkJobAsExpired() commits to file the job and its parent.
        //
        if (0 == lpGroupJobPtr->lpJob->dwLastJobExtendedStatus)
        {
            //
            // Job was never really executed - this is a fatal error
            //
            lpGroupJobPtr->lpJob->dwLastJobExtendedStatus = FSPI_ES_FATAL_ERROR;
        }
        if (!MarkJobAsExpired(lpGroupJobPtr->lpJob))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
                lpGroupJobPtr->lpJob->JobId,
                GetLastError());
        }
    }

    LeaveCriticalSectionJobAndQueue;

    return TRUE;
}




//*********************************************************************************
//* Name:   LoadEFSPJobGroups()
//* Author: Ronen Barenboim
//* Date:   June 15, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Loads all the EFSP Job Groups from the queue directory and places them
//*     in the g_EFSPJobGroupsHead list.
//* PARAMETERS:
//*     NONE
//* RETURN VALUE:
//*     TRUE
//*         If all the EFSP job groups were loaded successfuly.
//*     FALSE
//*         If at least one job group failed to load. The function will continue
//*         with the loading process even if one or more groups have failed
//*         to load.
//*********************************************************************************
BOOL LoadEFSPJobGroups()
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    WCHAR szFileName[MAX_PATH]; // The name of the current parent file.
    BOOL bAnyFailed;
    LPEFSP_JOB_GROUP lpGroup;

    DEBUG_FUNCTION_NAME(TEXT("LoadEFSPJobGroups"));
    //
    // Scan all the files with .FSP extension.
    // For each file call EFSPJobGroup_Load to restore
    // the job group.
    //
    bAnyFailed=FALSE;

    wsprintf( szFileName, TEXT("%s\\*.") JOB_GROUP_FILE_EXTENSION , g_wszFaxQueueDir );
    hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // We did not find any matching file
        //

        DebugPrintEx(
            DEBUG_MSG,
            TEXT("No EFSP job group files found at queue dir %s"),
            g_wszFaxQueueDir);
        return TRUE;
    }
    do {
        wsprintf( szFileName, TEXT("%s\\%s"), g_wszFaxQueueDir, FindData.cFileName );
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Loading EFSP job group from file %s"),
            szFileName);
        lpGroup = EFSPJobGroup_Load(szFileName);

        if (!lpGroup)
        {
            DWORD ec;
            ec = GetLastError();
            //
            // Until we incorporate smarter handling of load failure
            // we delete each group that fails to load.
            // This is not full proof yet but it minimizes the risk
            // of getting into incosistencies like having to FSP job groups
            // (created at different sessions) that are suppose to run on
            // the same line.
            DebugPrintEx(
                   DEBUG_MSG,
                   TEXT("EFSP Job File [%s] failed to load. Deleting !"),
                   szFileName);

            if (!DeleteFile( szFileName ))
            {
                DebugPrintEx( DEBUG_ERR,
                    TEXT("Failed to delete corrupted EFSP job group file %s (ec: %ld)."),
                    szFileName,
                    GetLastError());
                ASSERT_FALSE;
            }

            bAnyFailed=TRUE;
        }
        else
        {
            //
            // Add the group to the group list
            //
            if (!EFSPJobGroup_Validate(lpGroup))
            {
                //
                // The group is not valid (although it loaded)
                // Delete it.
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("EFSP Job File [%s] is not valid . Deleting !"),
                    szFileName);

                if (!DeleteFile( szFileName ))
                {
                    DebugPrintEx( DEBUG_ERR,
                        TEXT("Failed to delete corrupted EFSP job group file %s (ec: %ld)."),
                        szFileName,
                        GetLastError());
                    ASSERT_FALSE;
                }

                bAnyFailed=TRUE;
            }
            else
            {
                //
                // The group is ok.
                //
                InsertTailList( &g_EFSPJobGroupsHead, &lpGroup->ListEntry );
                EFSPJobGroup_DbgDump(lpGroup);
            }
        }
    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose failed (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

    return bAnyFailed ? FALSE : TRUE;
}




//*********************************************************************************
//* Name:   ValidateFSPJobHandles()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Validates if an array of job handles contains valid EFSP job handles
//*     as they should be returned by the EFSP.
//*
//* PARAMETERS:
//*     [IN ]   const HANDLE * lpchJobs
//*         Pointer to an array of HANDLE elements containing the job handles.
//*
//*     [IN ]    DWORD dwJobCount
//*         The number of job handles in the array.
//*
//* RETURN VALUE:
//*     TRUE
//*         If all the handles are unique and none of them is NULL.
//*     FALSE
//*         If any of the handles is NULL or if any handle is not unique or an error occured.
//*         Use GetLastError() to determine if an error occured. If it reports ERROR_SUCCESS
//*         then the function reports an invalid handle array. Otherwise the function
//*         met an error during its execution.
//* REMARKS:
//*     The uniquenes check is done in nlog(n) complexity using a STL set.
//*********************************************************************************
BOOL ValidateEFSPJobHandles(const HANDLE * lpchJobs, DWORD dwJobCount)
{

    set<HANDLE> HandleSet;                      // A set (unique elements) of handles. We put the handles
                                                // in it check if they are indeed unique.
    pair<set<HANDLE>::iterator, bool> pair;

    DWORD dwJob;

    DEBUG_FUNCTION_NAME(TEXT("ValidateFSPJobHandles"));

    Assert(lpchJobs);
    Assert(dwJobCount > 0);

    for (dwJob = 0; dwJob < dwJobCount; dwJob++)
    {
        if (NULL == lpchJobs[dwJob])
        {
            //
            // Found a NULL handle.
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("NULL EFSP job handle found at job handle index : %ld"),
                dwJob);
            SetLastError(ERROR_SUCCESS);
            return FALSE;
        }

        //
        // check for uniqueness
        //

        try
        {
            pair = HandleSet.insert(lpchJobs[dwJob]);
        }
        catch(...)
        {
            //
            // set::insert failed because of memory shortage
            //
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        if (false == pair.second)
        {
            //
            // Element already exists in the set. I.e. we have duplicate handles
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Duplicate EFSP job handle (0x%08X) found at job handle index : %ld"),
                lpchJobs[dwJob],
                dwJob);
            SetLastError(ERROR_SUCCESS);
            return FALSE;

        }
    }
    return TRUE;
}



//*********************************************************************************
//* Name:   ValidateEFSPPermanentMessageIds()
//* Author: Ronen Barenboim
//* Date:   June 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Validates an array of FSPI_MESSAGE_ID structures that were received from
//*     and EFSP. It checks for:
//*         - Valid structure size
//*         - valid id size (not 0 and not bigger than the max id size)
//*         - non null id pointer
//* PARAMETERS:
//*     [IN ]   LPCFSPI_MESSAGE_ID lpcMessageIds
//*         Pointer to an array of FSPI_MESSAGE_ID structures to validate.
//*     [IN ]    DWORD dwMsgIdCount
//*         The number of elements in the array.
//*     [IN]     DWORD dwMaxIdSize
//*         The maximum allowed id size (used for id size validation)
//* RETURN VALUE:
//*     TRUE
//*         If all the message ids are valid.
//*     FALSE
//*         If an invalid id was found.
//*********************************************************************************
BOOL ValidateEFSPPermanentMessageIds(LPCFSPI_MESSAGE_ID lpcMessageIds, DWORD dwMsgIdCount, DWORD dwMaxIdSize)
{

    DWORD dwMsgId;

    DEBUG_FUNCTION_NAME(TEXT("ValidateEFSPPermanentMessageIds"));

    Assert(lpcMessageIds);
    Assert(dwMsgIdCount);
    Assert(dwMaxIdSize);

    for (dwMsgId = 0; dwMsgId < dwMsgIdCount; dwMsgId++)
    {

        //
        // Check for mismatch in the structure size
        //
        if (lpcMessageIds[dwMsgId].dwSizeOfStruct != sizeof(FSPI_MESSAGE_ID))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSP Message id at index %ld has invalid dwSizeOfStruct %ld"),
                dwMsgId,
                lpcMessageIds[dwMsgId].dwSizeOfStruct);

            return FALSE;
        }
        //
        // Check for reported size which is larger then the maximum size
        //
        if (lpcMessageIds[dwMsgId].dwIdSize > dwMaxIdSize)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSP Message id at index %ld has size (%ld) which is larger than the max id size (%ld)"),
                dwMsgId,
                lpcMessageIds[dwMsgId].dwIdSize,
                dwMaxIdSize);
            return FALSE;
        }

        //
        // Check for zero size ids
        //

        if (0 == lpcMessageIds[dwMsgId].dwIdSize)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSP Message id at index %ld has size of zero"),
                dwMsgId);
            return FALSE;
        }

        //
        // Check for NULL lpbid pointers
        //

        if (NULL == lpcMessageIds[dwMsgId].lpbId)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EFSP Message id at index %ld has null id buffer pointer"),
                dwMsgId);
            return FALSE;
        }


    }

    return TRUE;
}



BOOL CreateJobQueueThread(void)
{
    HANDLE hThread = NULL;
    DWORD ThreadId;
    DWORD ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("CreateJobQueueThread"));

    hThread = CreateThreadAndRefCount(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) JobQueueThread,
        NULL,
        0,
        &ThreadId
        );
    if (!hThread) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create JobQueueThread (ec: %ld)."),
            GetLastError());
        goto Error;
    }
    Assert( ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert (ERROR_SUCCESS != ec);
    //
    // We don't close the already created threads. (They are terminated on process exit).
    //
Exit:
    //
    // Close the thread handles we no longer need them
    //
    if (!CloseHandle(hThread))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to close thread handle [handle = 0x%08X] (ec=0x%08x)."),
            hThread,
            GetLastError());
    }

    if (ec)
    {
        SetLastError(ec);
    }
    return (ERROR_SUCCESS == ec);
}

BOOL CreateStatusThreads(void)
{
    int i;
    DWORD ThreadId;
    DWORD ec = ERROR_SUCCESS;
    HANDLE hStatusThreads[MAX_STATUS_THREADS];

    DEBUG_FUNCTION_NAME(TEXT("CreateStatusThreads"));

    memset(hStatusThreads, 0, sizeof(HANDLE)*MAX_STATUS_THREADS);

    for (i=0; i<MAX_STATUS_THREADS; i++) {
        hStatusThreads[i] = CreateThreadAndRefCount(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) FaxStatusThread,
            NULL,
            0,
            &ThreadId
            );

        if (!hStatusThreads[i]) {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to create status thread %d (CreateThreadAndRefCount)(ec=0x%08x)."),
                i,
                ec);
            goto Error;
        }
    }

    Assert (ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert (ERROR_SUCCESS != ec);
Exit:
    //
    // Close the thread handles we no longer need them
    //
    for (i=0; i<MAX_STATUS_THREADS; i++)
    {
        if (!CloseHandle(hStatusThreads[i]))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to close thread handle at index %ld [handle = 0x%08X] (ec=0x%08x)."),
                i,
                hStatusThreads[i],
                GetLastError());
        }
    }
    if (ec)
    {
        SetLastError(ec);
    }
    return (ERROR_SUCCESS == ec);
}

static
BOOL
SendJobReceipt (
    BOOL              bPositive,
    JOB_QUEUE *       lpJobQueue,
    LPCTSTR           lpctstrAttachment
)
/*++

Routine name : SendJobReceipt

Routine description:

    Determines if a receipts should be send and calls SendReceipt accordingly

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    bPositive         [in]     - Did current job ended successfully?
    lpJobQueue        [in]     - Pointer to recipient job that just ended
    lpctstrAttachment [in]     - Job TIFF file to attach (in case of single recipient job only)

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    BOOL bSingleJobReceipt = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("SendJobReceipt)"));

    if (lpJobQueue->lpParentJob->dwRecipientJobsCount > 1)
    {
        //
        // Broadcast case
        //
        if (lpJobQueue->JobParamsEx.dwReceiptDeliveryType & DRT_GRP_PARENT)
        {
            //
            // Broadcast receipt grouping is requested
            //
            if (IsSendJobReadyForDeleting (lpJobQueue))
            {
                //
                // This is the last job in the broadcast, it's time to send a broadcast receipt
                //

                //
                // As receipt sending is async, there still might be a chance that more than one recipient jobs will reach this point
                // We must verify that only one receipt is sent per broadcast job
                //
                EnterCriticalSection (&g_CsQueue);
                if (FALSE == lpJobQueue->lpParentJob->fReceiptSent)
                {
                    PJOB_QUEUE pParentJob = lpJobQueue->lpParentJob;
                    BOOL bPositiveBroadcast =
                    (pParentJob->dwCompletedRecipientJobsCount == pParentJob->dwRecipientJobsCount) ?
                    TRUE : FALSE;

                    //
                    //  set the flag so we will not send duplicate receipts for broadcast
                    //
                    lpJobQueue->lpParentJob->fReceiptSent = TRUE;

                    //
                    // Leave g_CsQueue so we will not block the service
                    //
                    LeaveCriticalSection (&g_CsQueue);

                    if (!SendReceipt(bPositiveBroadcast,
                                     TRUE,
                                     pParentJob,
                                     pParentJob->FileName))
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("[Job Id: %ld] Failed to send broadcast receipt. (ec: %ld)"),
                            lpJobQueue->JobId,
                            GetLastError());
                        return FALSE;
                    }
                }
                else
                {
                    //
                    // More than one job reached this point when the broadcast jo was ready for deleting.
                    // Only on  receipt is sent
                    //
                    LeaveCriticalSection (&g_CsQueue);
                }
            }
            else
            {
                //
                // More jobs are still not finished, do not send receipt
                //
            }
        }
        else
        {
            //
            // This is a recipient part of a broadcast but the user was
            // asking for a receipt for every recipient.
            //
            bSingleJobReceipt = TRUE;
        }
    }
    else
    {
        //
        // This is not a broadcast case
        //
        bSingleJobReceipt = TRUE;
    }
    if (bSingleJobReceipt)
    {
        //
        // Send receipt for this job only
        //
        if (!SendReceipt(bPositive, FALSE, lpJobQueue, lpctstrAttachment))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("[Job Id: %ld] Failed to send POSITIVE receipt. (ec: %ld)"),
                lpJobQueue->JobId,
                GetLastError());
            return FALSE;
        }
    }
    return TRUE;
}   // SendJobReceipt

VOID
UpdateDeviceJobsCounter (
    PLINE_INFO      pLine,
    BOOL            bSend,
    int             iInc,
    BOOL            bNotify
)
/*++

Routine name : UpdateDeviceJobsCounter

Routine description:

    Updates the send or receive jobs counter of a device

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    pLine                         [in]     - Device pointer
    bSend                         [in]     - Send counter (FALSE = Receive counter)
    iInc                          [in]     - Increase jobs count (negative means decrease)
    decrease                      [in]     - Allow events (FAX_EVENT_TYPE_DEVICE_STATUS)

Return Value:

    None.

--*/
{
    DWORD dwOldCount;
    DWORD dwNewCount;
    DEBUG_FUNCTION_NAME(TEXT("UpdateDeviceJobsCounter)"));

    Assert (pLine);
    if (!iInc)
    {
        //
        // No change
        //
        ASSERT_FALSE;
        return;
    }
    EnterCriticalSection (&g_CsLine);
    dwOldCount = bSend ? pLine->dwSendingJobsCount : pLine->dwReceivingJobsCount;
    if (0 > iInc)
    {
        //
        // Decrease case
        //
        if ((int)dwOldCount + iInc < 0)
        {
            //
            // Weird - should never happen
            //
            ASSERT_FALSE;
            iInc = -(int)dwOldCount;
        }
    }
    dwNewCount = (DWORD)((int)dwOldCount + iInc);
    if (bSend)
    {
        pLine->dwSendingJobsCount = dwNewCount;
    }
    else
    {
        pLine->dwReceivingJobsCount = dwNewCount;
    }
    LeaveCriticalSection (&g_CsLine);
    if (bNotify && ((0 == dwNewCount) || (0 == dwOldCount)))
    {
        //
        // State change
        //
        DWORD ec = CreateDeviceEvent (pLine, FALSE);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateDeviceEvent() (ec: %lc)"),
                ec);
        }
    }
}   // UpdateDeviceJobsCounter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\resource.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file contains all manafest contants for TIFFVIEW's resources.

Author:

    Wesley Witt (wesw) 27-June-1995

Environment:

    User Mode

--*/


//
// icons
//
#define IDI_APPICON                     501

#define IDS_DIALING                     601
#define IDS_SENDING                     602
#define IDS_RECEIVING                   603
#define IDS_COMPLETED                   604
#define IDS_HANDLED                     605
#define IDS_LINE_UNAVAILABLE            606
#define IDS_BUSY                        607
#define IDS_NO_ANSWER                   608
#define IDS_BAD_ADDRESS                 609
#define IDS_NO_DIAL_TONE                610
#define IDS_DISCONNECTED                611
#define IDS_FATAL_ERROR                 612
#define IDS_NOT_FAX_CALL                613
#define IDS_CALL_DELAYED                614
#define IDS_CALL_BLACKLISTED            615
#define IDS_UNAVAILABLE                 616
#define IDS_AVAILABLE                   617
#define IDS_ABORTING                    618
#define IDS_ROUTING                     619
#define IDS_INITIALIZING                620
#define IDS_SENDFAILED                  621
#define IDS_SENDRETRY                   622
#define IDS_BLANKSTR                    623
#define IDS_ROUTERETRY                  624
#define IDS_DR_SUBJECT                  625
#define IDS_DR_FILENAME                 626
#define IDS_NDR_SUBJECT                 627
#define IDS_NDR_FILENAME                628
#define IDS_SERVICE_NAME                630
#define IDS_CALL_COMPLETED				631
#define IDS_CALL_ABORTED				632
#define IDS_ANSWERED                    633
#define IDS_NO_MAPI_LOGON               634
#define IDS_DEFAULT                     635
#define IDS_FAX_LOG_CATEGORY_INIT_TERM  637
#define IDS_FAX_LOG_CATEGORY_OUTBOUND   638
#define IDS_FAX_LOG_CATEGORY_INBOUND    639
#define IDS_FAX_LOG_CATEGORY_UNKNOWN    640
#define IDS_SET_CONFIG                  641
#define IDS_PARTIALLY_RECEIVED          643
#define IDS_FAILED_RECEIVE              644
#define IDS_FAILED_SEND                 645
#define IDS_CANCELED                    647

#define IDS_RECEIPT_RECIPIENT_NUMBER        648
#define IDS_RECEIPT_RECIPIENT_NUMBER_WIDTH  649
#define IDS_RECEIPT_RECIPIENT_NAME          650
#define IDS_RECEIPT_RECIPIENT_NAME_WIDTH    651
#define IDS_RECEIPT_START_TIME              652
#define IDS_RECEIPT_START_TIME_WIDTH        653
#define IDS_RECEIPT_END_TIME                654
#define IDS_RECEIPT_END_TIME_WIDTH          655
#define IDS_RECEIPT_RETRIES                 656
#define IDS_RECEIPT_RETRIES_WIDTH           657
#define IDS_RECEIPT_LAST_ERROR              658
#define IDS_RECEIPT_LAST_ERROR_WIDTH        659

#define IDS_COMPLETED_RECP_LIST_HEADER      660
#define IDS_FAILED_RECP_LIST_HEADER         661
#define IDS_JOB_CANCELED_BY_USER            662

#define IDS_RECEIPT_NO_CP_ATTACH            665
#define IDS_RECEIPT_NO_CP_AND_BODY_ATTACH   666
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\queue.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    This module implements the jobqueue

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/
#include <malloc.h>
#include "faxsvc.h"
#pragma hdrstop

typedef enum
{
    JT_SEND__JS_INVALID,
    JT_SEND__JS_PENDING,
    JT_SEND__JS_INPROGRESS,
    JT_SEND__JS_DELETING,
    JT_SEND__JS_RETRYING,
    JT_SEND__JS_RETRIES_EXCEEDED,
    JT_SEND__JS_COMPLETED,
    JT_SEND__JS_CANCELED,
    JT_SEND__JS_CANCELING,
    JT_SEND__JS_ROUTING,
    JT_SEND__JS_FAILED,
    JT_ROUTING__JS_INVALID,
    JT_ROUTING__JS_PENDING,
    JT_ROUTING__JS_INPROGRESS,
    JT_ROUTING__JS_DELETING,
    JT_ROUTING__JS_RETRYING,
    JT_ROUTING__JS_RETRIES_EXCEEDED,
    JT_ROUTING__JS_COMPLETED,
    JT_ROUTING__JS_CANCELED,
    JT_ROUTING__JS_CANCELING,
    JT_ROUTING__JS_ROUTING,
    JT_ROUTING__JS_FAILED,
    JT_RECEIVE__JS_INVALID,
    JT_RECEIVE__JS_PENDING,
    JT_RECEIVE__JS_INPROGRESS,
    JT_RECEIVE__JS_DELETING,
    JT_RECEIVE__JS_RETRYING,
    JT_RECEIVE__JS_RETRIES_EXCEEDED,
    JT_RECEIVE__JS_COMPLETED,
    JT_RECEIVE__JS_CANCELED,
    JT_RECEIVE__JS_CANCELING,
    JT_RECEIVE__JS_ROUTING,
    JT_RECEIVE__JS_FAILED,
    JOB_TYPE__JOBSTATUS_COUNT
} FAX_ENUM_JOB_TYPE__JOB_STATUS;

typedef enum
{
    NO_CHANGE                   = 0x0000,
    QUEUED_INC                  = 0x0001,
    QUEUED_DEC                  = 0x0002,
    OUTGOING_INC                = 0x0004,   // Can be delegated outgoing or outgoing
    OUTGOING_DEC                = 0x0008,   // Can be delegated outgoing or outgoing
    INCOMING_INC                = 0x0010,
    INCOMING_DEC                = 0x0020,
    ROUTING_INC                 = 0x0040,
    ROUTING_DEC                 = 0x0080,
    Q_EFSP_ONLY                 = 0x0100,  // Allowed for queueing EFSP only
    INVALID_CHANGE              = 0x0200
} FAX_ENUM_ACTIVITY_COUNTERS;



//
//  The following table consists of all posible JobType_JobStaus changes and the effect on Server Activity counters.
//  The rows entry is the old Job_Type_JobStatus.
//  The columns entry is the new Job_Type_JobStatus.

static WORD const gsc_JobType_JobStatusTable[JOB_TYPE__JOBSTATUS_COUNT][JOB_TYPE__JOBSTATUS_COUNT] =
{
//                                     JT_SEND__JS_INVALID  |       JT_SEND__JS_PENDING  |       JT_SEND__JS_INPROGRESS  |       JT_SEND__JS_DELETING  |       JT_SEND__JS_RETRYING  |       JT_SEND__JS_RETRIES_EXCEEDED  |       JT_SEND__JS_COMPLETED |       JT_SEND__JS_CANCELED  |       JT_SEND__JS_CANCELING  |       JT_SEND__JS_ROUTING  |       JT_SEND__JS_FAILED   |   JT_ROUTING__JS_INVALID  |  JT_ROUTING__JS_PENDING  |  JT_ROUTING__JS_INPROGRESS  |  JT_ROUTING__JS_DELETING  |  JT_ROUTING__JS_RETRYING  |  JT_ROUTING__JS_RETRIES_EXCEEDED  |  JT_ROUTING__JS_COMPLETED |  JT_ROUTING__JS_CANCELED  |  JT_ROUTING__JS_CANCELING  |  JT_ROUTING__JS_ROUTING  |  JT_ROUTING__JS_FAILED   |   JT_RECEIVE__JS_INVALID  |  JT_RECEIVE__JS_PENDING  |  JT_RECEIVE__JS_INPROGRESS  |  JT_RECEIVE__JS_DELETING  |  JT_RECEIVE__JS_RETRYING  |  JT_RECEIVE__JS_RETRIES_EXCEEDED  |  JT_RECEIVE__JS_COMPLETED |  JT_RECEIVE__JS_CANCELED  |  JT_RECEIVE__JS_CANCELING  |  JT_RECEIVE__JS_ROUTING |   JT_RECEIVE__JS_FAILED
//
/* JT_SEND__JS_INVALID             */{ NO_CHANGE,                   QUEUED_INC,                  Q_EFSP_ONLY | OUTGOING_INC,     INVALID_CHANGE,               QUEUED_INC,                   NO_CHANGE,                            NO_CHANGE,                    NO_CHANGE,                    INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_PENDING             */{ QUEUED_DEC,                  NO_CHANGE,                   QUEUED_DEC | OUTGOING_INC,      INVALID_CHANGE,               INVALID_CHANGE,               QUEUED_DEC,                           INVALID_CHANGE,               QUEUED_DEC,                   INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_INPROGRESS          */{ INVALID_CHANGE,              INVALID_CHANGE,              NO_CHANGE,                      INVALID_CHANGE,               QUEUED_INC | OUTGOING_DEC,    OUTGOING_DEC,                         OUTGOING_DEC,                 OUTGOING_DEC,                 NO_CHANGE,                     INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_DELETING            */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 NO_CHANGE,                    INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_RETRYING            */{ QUEUED_DEC,                  INVALID_CHANGE,              QUEUED_DEC | OUTGOING_INC,      INVALID_CHANGE,               NO_CHANGE,                    QUEUED_DEC,                           INVALID_CHANGE,               QUEUED_DEC,                   INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_RETRIES_EXCEEDED    */{ NO_CHANGE,                   QUEUED_INC,                  INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               NO_CHANGE,                            INVALID_CHANGE,               NO_CHANGE,                    INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_COMPLETED           */{ NO_CHANGE,                   INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       NO_CHANGE,                    INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_CANCELED            */{ NO_CHANGE,                   INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               NO_CHANGE,                    INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_CANCELING           */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       OUTGOING_DEC,                 OUTGOING_DEC,                 NO_CHANGE,                     INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_ROUTING,            */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                NO_CHANGE,                   INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_SEND__JS_FAILED,             */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              NO_CHANGE,               INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_INVALID          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          NO_CHANGE,                 INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             ROUTING_INC,                NO_CHANGE,                          INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_PENDING          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            NO_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_INPROGRESS       */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            NO_CHANGE,                    ROUTING_DEC,                NO_CHANGE,                  ROUTING_DEC,                        INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_DELETING         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          NO_CHANGE,                 INVALID_CHANGE,            INVALID_CHANGE,               NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_RETRYING         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            NO_CHANGE,                    ROUTING_DEC,                NO_CHANGE,                  ROUTING_DEC,                        INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_RETRIES_EXCEEDED */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               NO_CHANGE,                  INVALID_CHANGE,             NO_CHANGE,                          INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_COMPLETED        */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_CANCELED         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             NO_CHANGE,                  INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_CANCELING        */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             NO_CHANGE,                   INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_ROUTING          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              NO_CHANGE,                 INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_ROUTING__JS_FAILED           */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            NO_CHANGE,                  INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_INVALID          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             NO_CHANGE,                 INVALID_CHANGE,            INCOMING_INC,                 INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_PENDING          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            NO_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_INPROGRESS       */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            NO_CHANGE,                    INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             NO_CHANGE,                   NO_CHANGE,                 INCOMING_DEC           },

/* JT_RECEIVE__JS_DELETING         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             NO_CHANGE,                 INVALID_CHANGE,            INVALID_CHANGE,               NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_RETRYING         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             NO_CHANGE,                  INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_RETRIES_EXCEEDED */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             NO_CHANGE,                          INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_COMPLETED        */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INCOMING_DEC,               INVALID_CHANGE,             INVALID_CHANGE,                     NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_CANCELED         */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             NO_CHANGE,                  INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE         },

/* JT_RECEIVE__JS_CANCELING        */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INCOMING_DEC,               NO_CHANGE,                   NO_CHANGE,                 INVALID_CHANGE         },

/* JT_RECEIVE__JS_ROUTING          */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INCOMING_DEC,               ROUTING_INC | INCOMING_DEC, INCOMING_DEC,                       INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              NO_CHANGE,                 INVALID_CHANGE         },

/* JT_RECEIVE__JS_FAILED           */{ INVALID_CHANGE,              INVALID_CHANGE,              INVALID_CHANGE,                 INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                       INVALID_CHANGE,               INVALID_CHANGE,               INVALID_CHANGE,                INVALID_CHANGE,              INVALID_CHANGE,          INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            INVALID_CHANGE,             INVALID_CHANGE,            INVALID_CHANGE,            INVALID_CHANGE,               NO_CHANGE,                  INVALID_CHANGE,             INVALID_CHANGE,                     INVALID_CHANGE,             INVALID_CHANGE,             INVALID_CHANGE,              INVALID_CHANGE,            NO_CHANGE              }
};

static
FAX_ENUM_JOB_TYPE__JOB_STATUS
GetJobType_JobStatusIndex (
    DWORD dwJobType,
    DWORD dwJobStatus
    );


LIST_ENTRY          g_QueueListHead;

CFaxCriticalSection  g_CsQueue;
DWORD               g_dwQueueCount;     // Count of jobs (both parent and non-parent) in the queue. Protected by g_CsQueue
HANDLE              g_hQueueTimer;
HANDLE              g_hJobQueueEvent;
DWORD               g_dwQueueState;
BOOL                g_ScanQueueAfterTimeout; // The JobQueueThread checks this if waked up after JOB_QUEUE_TIMEOUT.
                                                     // If it is TRUE - g_hQueueTimer or g_hJobQueueEvent were not set - Scan the queue.
#define JOB_QUEUE_TIMEOUT       1000 * 60 * 10 //10 minutes
DWORD               g_dwReceiveDevicesCount;    // Count of devices that are receive-enabled. Protected by g_CsLine.
BOOL                g_bServiceCanSuicide;    // Can the service commit suicide on idle activity?
                                                    // Initially TRUE. Can be set to false if the service is launched
                                                    // with SERVICE_ALWAYS_RUNS command line parameter.
BOOL                g_bDelaySuicideAttempt;         // If TRUE, the service initially waits
                                                    // before checking if it can commit suicide.
                                                    // Initially FALSE, can be set to true if the service is launched
                                                    // with SERVICE_DELAY_SUICIDE command line parameter.


static BOOL InsertQueueEntryByPriorityAndSchedule (PJOB_QUEUE lpJobQueue);






void
FreeServiceQueue(
    void
    )
{
    PLIST_ENTRY pNext;
    PJOB_QUEUE lpQueueEntry;


    pNext = g_QueueListHead.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_QueueListHead)
    {
        lpQueueEntry = CONTAINING_RECORD( pNext, JOB_QUEUE, ListEntry );
        pNext = lpQueueEntry->ListEntry.Flink;
        RemoveEntryList(&lpQueueEntry->ListEntry);

        //
        // Free the job queue entry
        //
        if (JT_BROADCAST == lpQueueEntry->JobType)
        {
            FreeParentQueueEntry(lpQueueEntry, TRUE);
        }
        else if (JT_SEND == lpQueueEntry->JobType)
        {
            FreeRecipientQueueEntry(lpQueueEntry, TRUE);
        }
        else if (JT_ROUTING == lpQueueEntry->JobType)
        {
            FreeReceiveQueueEntry(lpQueueEntry, TRUE);
        }
        else
        {
            ASSERT_FALSE;
        }
    }
    return;
}



VOID
SafeIncIdleCounter (
    LPDWORD lpdwCounter
)
/*++

Routine name : SafeIncIdleCounter

Routine description:

    Safely increases a global counter that is used for idle service detection

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    lpdwCounter                   [in]     - Pointer to global counter

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("SafeIncIdleCounter"));

    Assert (lpdwCounter);
    DWORD dwNewValue = (DWORD)InterlockedIncrement ((LPLONG)lpdwCounter);
    DebugPrintEx(DEBUG_MSG,
                 TEXT("Increasing %s count from %ld to %ld"),
                 (lpdwCounter == &g_dwQueueCount)          ? TEXT("queue") :
                 (lpdwCounter == &g_dwReceiveDevicesCount) ? TEXT("receive devices") :
                 (lpdwCounter == &g_dwConnectionCount)     ? TEXT("RPC connections") :
                 TEXT("unknown"),
                 dwNewValue-1,
                 dwNewValue);
}   // SafeIncIdleCounter

VOID
SafeDecIdleCounter (
    LPDWORD lpdwCounter
)
/*++

Routine name : SafeDecIdleCounter

Routine description:

    Safely decreases a global counter that is used for idle service detection.
    If the counter reaches zero, the idle timer is re-started.

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    lpdwCounter                   [in]     - Pointer to global counter

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("SafeDecIdleCounter"));

    Assert (lpdwCounter);
    DWORD dwNewValue = (DWORD)InterlockedDecrement ((LPLONG)lpdwCounter);
    if ((DWORD)((long)-1) == dwNewValue)
    {
        //
        // Negative decrease
        //
        ASSERT_FALSE;
        dwNewValue = (DWORD)InterlockedIncrement ((LPLONG)lpdwCounter);
    }
    DebugPrintEx(DEBUG_MSG,
                 TEXT("Deccreasing %s count from %ld to %ld"),
                 (lpdwCounter == &g_dwQueueCount)          ? TEXT("queue") :
                 (lpdwCounter == &g_dwReceiveDevicesCount) ? TEXT("receive devices") :
                 (lpdwCounter == &g_dwConnectionCount)     ? TEXT("RPC connections") :
                 TEXT("unknown"),
                 dwNewValue+1,
                 dwNewValue);

}   // SafeDecIdleCounter


BOOL
ServiceShouldDie(
    VOID
    )
/*++

Routine name : ServiceShouldDie

Routine description:

    Checks to see if the service should die due to inactivity

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    None.

Return Value:

    TRUE if service should die now, FALSE otherwise.

Note:

    The following should happen (concurrently) for the service to die:
        * No devices set to receive
        * No active RPC connections
        * The local fax printer (if exists) is not shared
        * No jobs in the queue

--*/
{
    DWORD dw;
    BOOL bLocalFaxPrinterShared;
    DEBUG_FUNCTION_NAME(TEXT("ServiceShouldDie"));

    if (!g_bServiceCanSuicide)
    {
        //
        // We can never die voluntarily
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("Service is not allowed to suicide - service is kept alive"));
        return FALSE;
    }

    dw = InterlockedCompareExchange ( (PLONG)&g_dwManualAnswerDeviceId, -1, -1 );
    if (dw)
    {
        //
        // We have a device set for manual answering - let's check if it's here at all
        //
        PLINE_INFO pLine;

        EnterCriticalSection( &g_CsLine );
        pLine = GetTapiLineFromDeviceId (dw, FALSE);
        LeaveCriticalSection( &g_CsLine );
        if (pLine)
        {
            //
            // There's a valid device set to manual answering
            //
            DebugPrintEx(DEBUG_MSG,
                         TEXT("There's a valid device (id = %ld) set to manual answering - service is kept alive"),
                         dw);
            return FALSE;
        }
    }

    dw = InterlockedCompareExchange ( (PLONG)&g_dwConnectionCount, -1, -1 );
    if (dw > 0)
    {
        //
        // There are active RPC connections - server can't shutdown
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("There are %ld active RPC connections - service is kept alive"),
                     dw);
        return FALSE;
    }
    dw = InterlockedCompareExchange ( (PLONG)&g_dwReceiveDevicesCount, -1, -1 );
    if (dw > 0)
    {
        //
        // There are devices set to receive - server can't shutdown
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("There are %ld devices set to receive - service is kept alive"),
                     dw);
        return FALSE;
    }
    dw = InterlockedCompareExchange ( (PLONG)&g_dwQueueCount, -1, -1 );
    if (dw > 0)
    {
        //
        // There are jobs in the queue - server can't shutdown
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("There are %ld jobs in the queue - service is kept alive"),
                     dw);
        return FALSE;
    }
    dw = IsLocalFaxPrinterShared (&bLocalFaxPrinterShared);
    if (ERROR_SUCCESS != dw)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Call to IsLocalFaxPrinterShared failed with %ld"),
                     dw);
        //
        // Can't determine - assume it's shared and don't die
        //
        return FALSE;
    }
    if (bLocalFaxPrinterShared)
    {
        //
        // The fax printer is shared - server can't shutdown
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("The fax printer is shared - service is kept alive"));
        return FALSE;
    }
    //
    // Service should die now
    //
    return TRUE;
}   // ServiceShouldDie


#if DBG

/*
 *	Note: This function must be called from withing g_CsQueue Critical Section
 */
void PrintJobQueue(LPCTSTR lptstrStr, const LIST_ENTRY * lpQueueHead)
{
    PLIST_ENTRY lpNext;
    PJOB_QUEUE lpQueueEntry;
    DEBUG_FUNCTION_NAME(TEXT("PrintJobQueue"));
    Assert(lptstrStr);
    Assert(lpQueueHead);

    DebugPrintEx(DEBUG_MSG,TEXT("Queue Dump (%s)"),lptstrStr);

    lpNext = lpQueueHead->Flink;
    if ((ULONG_PTR)lpNext == (ULONG_PTR)lpQueueHead)
    {
        DebugPrint(( TEXT("Queue empty") ));
    } else
    {
        while ((ULONG_PTR)lpNext != (ULONG_PTR)lpQueueHead)
        {
            lpQueueEntry = CONTAINING_RECORD( lpNext, JOB_QUEUE, ListEntry );
            switch (lpQueueEntry->JobType)
            {
                case JT_BROADCAST:
                    {
                        DumpParentJob(lpQueueEntry);
                    }
                    break;
                case JT_RECEIVE:
                    {
                        DumpReceiveJob(lpQueueEntry);
                    }
                case JT_ROUTING:
                    break;
                default:
                    {
                    }
            }
            lpNext = lpQueueEntry->ListEntry.Flink;
        }
    }
}

#endif


BOOL CleanupReestablishOrphans( const LIST_ENTRY * lpQueueHead);




/******************************************************************************
* Name: StartJobQueueTimer
* Author:
*******************************************************************************
DESCRIPTION:
    Sets the job queue timer (g_hQueueTimer) so it will send an event and wake up
    the queue thread in a time which is right for executing the next job in
    the queue. If it fails , it sets g_ScanQueueAfterTimeout to TRUE, if it succeeds it sets it to FALSE;


PARAMETERS:
   NONE.

RETURN VALUE:
    BOOL.

REMARKS:
    NONE.
*******************************************************************************/
BOOL
StartJobQueueTimer(
    VOID
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE QueueEntry;
    SYSTEMTIME CurrentTime;
    LARGE_INTEGER DueTime;
    LARGE_INTEGER MinDueTime;
    DWORD dwQueueState;
    BOOL bFound = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("StartJobQueueTimer"));

    if (TRUE == g_bServiceIsDown)
    {
        //
        // Server is shutting down
        //
        g_ScanQueueAfterTimeout = FALSE;
        return TRUE;
    }

    MinDueTime.QuadPart = (LONGLONG)(0x7fffffffffffffff); // Max 64 bit signed int.
    DueTime.QuadPart = -(LONGLONG)(SecToNano( 1 ));  // 1 sec from now.

    EnterCriticalSection( &g_CsQueue );
    DebugPrintEx(DEBUG_MSG,TEXT("Past g_CsQueue"));
    if ((ULONG_PTR) g_QueueListHead.Flink == (ULONG_PTR) &g_QueueListHead)
    {
        //
        // empty list, cancel the timer
        //
        if (!CancelWaitableTimer( g_hQueueTimer ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CancelWaitableTimer for g_hQueueTimer failed. (ec: %ld)"),
                GetLastError());
        }

        DebugPrintEx(DEBUG_MSG,TEXT("Queue is empty. Queue Timer disabled."));
        g_ScanQueueAfterTimeout = FALSE;
        LeaveCriticalSection( &g_CsQueue );
        return TRUE ;
    }

    EnterCriticalSection (&g_CsConfig);
    dwQueueState = g_dwQueueState;
    LeaveCriticalSection (&g_CsConfig);
    if (dwQueueState & FAX_OUTBOX_PAUSED)
    {
        if (!CancelWaitableTimer( g_hQueueTimer ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CancelWaitableTimer for g_hQueueTimer failed. (ec: %ld)"),
                GetLastError());
        }
        DebugPrintEx(DEBUG_MSG,TEXT("Queue is paused. Disabling queue timer."));
        g_ScanQueueAfterTimeout = FALSE;
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    PrintJobQueue( TEXT("StartJobQueueTimer"), &g_QueueListHead );

    //
    // Find the next job in the queue who is in turn for execution.
    //
    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
    {
        DWORD dwJobStatus;
        QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = QueueEntry->ListEntry.Flink;

        if (QueueEntry->JobType != JT_SEND &&  QueueEntry->JobType != JT_ROUTING )
        {
            //
            // No job other then recipient or routing job gets shceduled for execution
            //
            continue;
        }

        if (QueueEntry->JobStatus & JS_PAUSED)
        {
            //
            // Job is being paused - ignore it
            //
            continue;
        }

        if (QueueEntry->JobStatus & JS_NOLINE)
        {
            //
            // Job does not have free line - ignore it
            //
            continue;
        }

        //
        // Remove all the job status modifier bits.
        //
        dwJobStatus = RemoveJobStatusModifiers(QueueEntry->JobStatus);

        if ((dwJobStatus != JS_PENDING) && (dwJobStatus != JS_RETRYING))
        {
            //
            // Job is not in a waiting and ready state.
            //
            continue;
        }
        bFound = TRUE;

        //
        // OK. Job is in PENDING or RETRYING state.
        //
        switch (QueueEntry->JobParamsEx.dwScheduleAction)
        {
            case JSA_NOW:
                DueTime.QuadPart = -(LONGLONG)(SecToNano( 1 ));
                break;

            case JSA_SPECIFIC_TIME:
                DueTime.QuadPart = QueueEntry->ScheduleTime;
                break;

            case JSA_DISCOUNT_PERIOD:
                GetSystemTime( &CurrentTime ); // Can't fail according to Win32 SDK
                if (!SetDiscountTime( &CurrentTime ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("SetDiscountTime() failed. (ec: %ld)"));
                    g_ScanQueueAfterTimeout = TRUE;
                    LeaveCriticalSection(&g_CsQueue);
                    return FALSE;
                }

                if (!SystemTimeToFileTime( &CurrentTime, (LPFILETIME)&QueueEntry->ScheduleTime ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("SystemTimeToFileTime() failed. (ec: %ld)"));
                    g_ScanQueueAfterTimeout = TRUE;
                    LeaveCriticalSection(&g_CsQueue);
                    return FALSE;
                }

                if (!SystemTimeToFileTime( &CurrentTime, (LPFILETIME)&DueTime.QuadPart ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("SystemTimeToFileTime() failed. (ec: %ld)"));
                    g_ScanQueueAfterTimeout = TRUE;
                    LeaveCriticalSection(&g_CsQueue);
                    return FALSE;
                }
                break;
        }

        if (DueTime.QuadPart < MinDueTime.QuadPart)
        {
            MinDueTime.QuadPart = DueTime.QuadPart;
        }
    }

    if (TRUE == bFound)
    {
        // send a handoff job immediately
        if (QueueEntry->DeviceId)
        {
            MinDueTime.QuadPart = -(LONGLONG)(SecToNano( 1 ));
        }

        //
        // Set the job queue timer so it will wake up the queue thread
        // when it is time to execute the next job in the queue.
        //
        if (!SetWaitableTimer( g_hQueueTimer, &MinDueTime, 0, NULL, NULL, FALSE ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetWaitableTimer for g_hQueueTimer failed (ec: %ld)"),
                GetLastError());
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection( &g_CsQueue );
            return FALSE;
        }


        #ifdef DBG
        {
            TCHAR szTime[256] = {0};
            DebugDateTime(MinDueTime.QuadPart,szTime);
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Setting queue timer to wake up at %s for JobId: %ld , Job Status: 0x%08X"),
                szTime,
                QueueEntry->JobId,
                QueueEntry->JobStatus );
        }
        #endif

        g_ScanQueueAfterTimeout = FALSE;
        LeaveCriticalSection( &g_CsQueue );
    }
    else
    {
        //
        // The queue was not empty, yet no jobs found.
        //
        g_ScanQueueAfterTimeout = TRUE;
        LeaveCriticalSection( &g_CsQueue );
    }
    return TRUE;
}




int
__cdecl
QueueCompare(
    const void *arg1,
    const void *arg2
    )
{
    if (((PQUEUE_SORT)arg1)->Priority < ((PQUEUE_SORT)arg2)->Priority)
    {
        return 1;
    }
    if (((PQUEUE_SORT)arg1)->Priority > ((PQUEUE_SORT)arg2)->Priority)
    {
        return -1;
    }

    //
    // Equal priority, Compare scheduled time.
    //

    if (((PQUEUE_SORT)arg1)->ScheduleTime < ((PQUEUE_SORT)arg2)->ScheduleTime)
    {
        return -1;
    }
    if (((PQUEUE_SORT)arg1)->ScheduleTime > ((PQUEUE_SORT)arg2)->ScheduleTime)
    {
        return 1;
    }
    return 0;
}


BOOL
SortJobQueue(
    VOID
    )
/*++

Routine Description:

    Sorts the job queue list, ostensibly because the discount rate time has changed.

Arguments:

    none.

Return Value:

    BOOL

--*/
{
    DWORDLONG DiscountTime;
    SYSTEMTIME CurrentTime;
    PLIST_ENTRY Next;
    PJOB_QUEUE QueueEntry;
    DWORD JobCount=0, i = 0;
    BOOL SortNeeded = FALSE;
    PQUEUE_SORT QueueSort;
    DEBUG_FUNCTION_NAME(TEXT("SortJobQueue"));

    GetSystemTime( &CurrentTime );
    SetDiscountTime( &CurrentTime );
    if (!SystemTimeToFileTime( &CurrentTime, (LPFILETIME)&DiscountTime ))
    {
        return FALSE;
    }


    EnterCriticalSection( &g_CsQueue );

    Next = g_QueueListHead.Flink;

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
    {
        QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = QueueEntry->ListEntry.Flink;
        JobCount++;
        if (!SortNeeded && QueueEntry->JobParamsEx.dwScheduleAction != JSA_NOW)
        {
            SortNeeded = TRUE;
        }
    }

    //
    // optimization...if there are no jobs, or if there aren't any jobs with a
    // schedule time then we don't need to sort anything
    //
    if (!SortNeeded)
    {
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    Assert( JobCount != 0 );

    QueueSort = (PQUEUE_SORT)MemAlloc (JobCount * sizeof(QUEUE_SORT));
    if (!QueueSort)
    {
        LeaveCriticalSection( &g_CsQueue );
        return FALSE;
    }

    Next = g_QueueListHead.Flink;

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
    {
        QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = QueueEntry->ListEntry.Flink;


        QueueSort[i].Priority       = QueueEntry->JobParamsEx.Priority;
        QueueSort[i].ScheduleTime   = QueueEntry->ScheduleTime;
        QueueSort[i].QueueEntry     = QueueEntry;

        if (QueueEntry->JobParamsEx.dwScheduleAction == JSA_DISCOUNT_PERIOD)
        {
            QueueEntry->ScheduleTime = DiscountTime;
        }

        i += 1;
    }

    Assert (i == JobCount);

    qsort(
    (PVOID)QueueSort,
    (int)JobCount,
    sizeof(QUEUE_SORT),
    QueueCompare
    );

    InitializeListHead(&g_QueueListHead);

    for (i = 0; i < JobCount; i++)
    {
        QueueSort[i].QueueEntry->ListEntry.Flink = QueueSort[i].QueueEntry->ListEntry.Blink = NULL;
        InsertTailList( &g_QueueListHead, &QueueSort[i].QueueEntry->ListEntry );

        if ( QueueSort[i].QueueEntry->JobParamsEx.dwScheduleAction == JSA_DISCOUNT_PERIOD)
        {
            //
            // update jobs status schedualed to discount time
            //
            DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                         QueueSort[i].QueueEntry );
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                    QueueSort[i].QueueEntry->UniqueId,
                    dwRes);
            }
        }

    }

    MemFree( QueueSort );

    LeaveCriticalSection( &g_CsQueue );
    return TRUE;
}


BOOL
PauseServerQueue(
    VOID
    )
{
    BOOL bRetVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("PauseServerQueue"));

    EnterCriticalSection( &g_CsQueue );
    EnterCriticalSection (&g_CsConfig);
    if (g_dwQueueState & FAX_OUTBOX_PAUSED)
    {
        goto exit;
    }

    if (!CancelWaitableTimer(g_hQueueTimer))
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("CancelWaitableTimer failed. ec: %ld"),
                      GetLastError());
        //
        // For optimization only - the queue will be paused
        //
    }
    g_dwQueueState |= FAX_OUTBOX_PAUSED;

    Assert (TRUE == bRetVal);

exit:
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection( &g_CsQueue );
    return bRetVal;
}


BOOL
ResumeServerQueue(
    VOID
    )
{
    BOOL bRetVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("ResumeServerQueue"));

    EnterCriticalSection( &g_CsQueue );
    EnterCriticalSection (&g_CsConfig);
    if (!(g_dwQueueState & FAX_OUTBOX_PAUSED))
    {
        goto exit;
    }

    g_dwQueueState &= ~FAX_OUTBOX_PAUSED;  // This must be set before calling StartJobQueueTimer()
    if (!StartJobQueueTimer())
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("StartJobQueueTimer failed. ec: %ld"),
                      GetLastError());
    }
    Assert (TRUE == bRetVal);

exit:
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection( &g_CsQueue );
    return bRetVal;
}


void FixupPersonalProfile(LPBYTE lpBuffer, PFAX_PERSONAL_PROFILE  lpProfile)
{
    Assert(lpBuffer);
    Assert(lpProfile);

    FixupString(lpBuffer, lpProfile->lptstrName);
    FixupString(lpBuffer, lpProfile->lptstrFaxNumber);
    FixupString(lpBuffer, lpProfile->lptstrCompany);
    FixupString(lpBuffer, lpProfile->lptstrStreetAddress);
    FixupString(lpBuffer, lpProfile->lptstrCity);
    FixupString(lpBuffer, lpProfile->lptstrState);
    FixupString(lpBuffer, lpProfile->lptstrZip);
    FixupString(lpBuffer, lpProfile->lptstrCountry);
    FixupString(lpBuffer, lpProfile->lptstrTitle);
    FixupString(lpBuffer, lpProfile->lptstrDepartment);
    FixupString(lpBuffer, lpProfile->lptstrOfficeLocation);
    FixupString(lpBuffer, lpProfile->lptstrHomePhone);
    FixupString(lpBuffer, lpProfile->lptstrOfficePhone);
    FixupString(lpBuffer, lpProfile->lptstrEmail);
    FixupString(lpBuffer, lpProfile->lptstrBillingCode);
    FixupString(lpBuffer, lpProfile->lptstrTSID);
}


//*********************************************************************************
//* Name:   ReadJobQueueFile() [IQR]
//* Author: Ronen Barenboim
//* Date:   12-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Reads a JOB_QUEUE_FILE structure back into memory for the designated
//*     file. This function is used for all types of persisted jobs.
//* PARAMETERS:
//*     IN LPCWSTR lpcwstrFileName
//*         The full path to the file from which the JOB_QUEUE_FILE is to be read.
//*
//*     OUT PJOB_QUEUE_FILE * lppJobQueueFile
//*         The address of a pointer to JOB_QUEUE_FILE structure where the address
//*         to the newly allocated JOB_QUEUE_FILE structure will be placed.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL ReadJobQueueFile(
    IN LPCWSTR lpcwstrFileName,
    OUT PJOB_QUEUE_FILE * lppJobQueueFile
    )
{
    HANDLE hFile=INVALID_HANDLE_VALUE;
    DWORD dwSize;                       // The size of the file
    DWORD dwReadSize;                   // The number of bytes actually read from the file
    PJOB_QUEUE_FILE lpJobQueueFile=NULL;

    Assert(lpcwstrFileName);
    Assert(lppJobQueueFile);

    DEBUG_FUNCTION_NAME(TEXT("ReadJobQueueFile"));

    hFile = CreateFile(
        lpcwstrFileName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to open file %s for reading. (ec: %ld)"),
                      lpcwstrFileName,
                      GetLastError());
        goto Error;
    }
    //
    // See if we did not stumble on some funky file which is smaller than the
    // minimum file size.
    //

    /*

        *****

            NTRAID#EdgeBugs-12674-2001/05/14-t-nicali: We should add a file signature at the begining of JOB_QUEUE_FILE

        *****

    */
    dwSize = GetFileSize( hFile, NULL );
    if (dwSize < sizeof(JOB_QUEUE_FILE) ) {
        DebugPrintEx( DEBUG_WRN,
                      TEXT("Job file %s size is %ld which is smaller than sizeof(JOB_QUEUE_FILE).Deleting file."),
                      lpcwstrFileName,
                      dwSize);
       //
       // we've got some funky downlevel file, let's skip it rather than choke on it.
       //
       CloseHandle( hFile ); // must close it to delete the file
       hFile = INVALID_HANDLE_VALUE; // so we won't attempt to close it again on exit
       if (!DeleteFile( lpcwstrFileName )) {
           DebugPrintEx( DEBUG_ERR,
                         TEXT("Failed to delete invalid job file %s (ec: %ld)"),
                         lpcwstrFileName,
                         GetLastError());

       }
       goto Error;
    }

    lpJobQueueFile = (PJOB_QUEUE_FILE) MemAlloc( dwSize );
    if (!lpJobQueueFile) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to allocate JOB_QUEUE_FILE (%ld bytes) (ec: %ld)"),
                      dwSize,
                      GetLastError());
        goto Error;

    }

    if (!ReadFile( hFile, lpJobQueueFile, dwSize, &dwReadSize, NULL )) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to read %ld bytes from QFE file %s. %ld bytes read. (ec: %ld)"),
                      dwSize,
                      dwReadSize,
                      lpcwstrFileName,
                      GetLastError());
        goto Error;
    }
    Assert(dwSize == dwReadSize);
    goto Exit;
Error:
    MemFree( lpJobQueueFile );
    lpJobQueueFile = NULL;

Exit:
    if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle( hFile );
    }
    *lppJobQueueFile = lpJobQueueFile;
    return (lpJobQueueFile != NULL);

}



//*********************************************************************************
//* Name:   FixupJobQueueFile()[IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Prepares a JOB_QUEUE_FILE structure so it can be used to add a job to the
//*     queue.
//*     The function fixes all the fields that contain offsets to strings
//*     to contain pointers (by adding the offset to the start of the structure address).
//*     It also sets JOB_QUEUE_FILE.JOB_PARAMS_EX.tmSchedule time so it mataches
//*     JOB_QUEUE_FILE.dwSchedule
//* PARAMETERS:
//*     lpJobQueuFile [IN/OUT]
//*         Pointer to a JOB_QUEUE_FILE structure that should be fixed.
//* RETURN VALUE:
//*     TRUE on success. FALSE on failure. Use GetLastError() to get extended
//*     error information.
//*********************************************************************************
BOOL FixupJobQueueFile(
    IN OUT PJOB_QUEUE_FILE lpJobQueueFile
    )
{
    DEBUG_FUNCTION_NAME(TEXT("FixupJobQueueFile"));

    FixupString(lpJobQueueFile, lpJobQueueFile->QueueFileName);
    FixupString(lpJobQueueFile, lpJobQueueFile->FileName);
    FixupString(lpJobQueueFile, lpJobQueueFile->JobParamsEx.lptstrReceiptDeliveryAddress);
    FixupString(lpJobQueueFile, lpJobQueueFile->JobParamsEx.lptstrDocumentName);
    FixupString(lpJobQueueFile, lpJobQueueFile->CoverPageEx.lptstrCoverPageFileName);
    FixupString(lpJobQueueFile, lpJobQueueFile->CoverPageEx.lptstrNote);
    FixupString(lpJobQueueFile, lpJobQueueFile->CoverPageEx.lptstrSubject);
    FixupPersonalProfile((LPBYTE)lpJobQueueFile, &lpJobQueueFile->SenderProfile);
    FixupString((LPBYTE)lpJobQueueFile, lpJobQueueFile->UserName);
    FixupPersonalProfile((LPBYTE)lpJobQueueFile, &lpJobQueueFile->RecipientProfile);

    lpJobQueueFile->UserSid = ((lpJobQueueFile->UserSid) ? (PSID) ((LPBYTE)(lpJobQueueFile) + (ULONG_PTR)lpJobQueueFile->UserSid) : 0);


    //
    // Convert the job scheduled time from file time to system time.
    // This is necessary since AddJobX functions expect JobParamsEx to
    // contain the scheduled time as system time and not file time.
    //

#if DBG
        TCHAR szSchedule[256] = {0};
        DebugDateTime(lpJobQueueFile->ScheduleTime,szSchedule);
        DebugPrint((TEXT("Schedule: %s (FILETIME: 0x%08X"),szSchedule,lpJobQueueFile->ScheduleTime));
#endif
    if (!FileTimeToSystemTime( (LPFILETIME)&lpJobQueueFile->ScheduleTime, &lpJobQueueFile->JobParamsEx.tmSchedule))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToSystemTime failed (ec: %ld)"),
            GetLastError());
        return FALSE;
    }
    return TRUE;

}

//********************************************************************************
//* Name: DeleteQueueFiles()
//* Author: Oded Sacher
//* Date:   Jan 26, 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Deletes all unneeded files in the queue
//* PARAMETERS:
//*     [IN] LPCWSTR lpcwstrFileExt - The extension of the files to be deleted from the queue.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If all the files were deleted successfully.
//*     FALSE
//*         If the function failed at deleting at least one of the preview files.
//*********************************************************************************
BOOL
DeleteQueueFiles( LPCWSTR lpcwstrFileExt )
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    WCHAR szFileName[MAX_PATH]; // The name of the current parent file.
    BOOL bAnyFailed = FALSE;

    Assert (lpcwstrFileExt);

    DEBUG_FUNCTION_NAME(TEXT("DeleteQueueFiles"));
    //
    // Scan all the files with lpcwstrFileExt postfix.
    // Delete each file
    //

    wsprintf( szFileName, TEXT("%s\\*.%s"), g_wszFaxQueueDir, lpcwstrFileExt );
    hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // No preview files found at queue dir
        //
        DebugPrintEx( DEBUG_WRN,
                      TEXT("No *.%s files found at queue dir %s"),
                      lpcwstrFileExt,
                      g_wszFaxQueueDir);
        return TRUE;
    }
    do {
        wsprintf( szFileName, TEXT("%s\\%s"), g_wszFaxQueueDir, FindData.cFileName );
        DebugPrintEx( DEBUG_MSG,
                      TEXT("Deleting file %s"),
                      szFileName);
        if (!DeleteFile (szFileName)) {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("DeleteFile() failed for %s (ec: %ld)"),
                      szFileName,
                      GetLastError());
            bAnyFailed=TRUE;
        }
    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose faield (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

    return bAnyFailed ? FALSE : TRUE;
}



//*********************************************************************************
//* Name:   RestoreParentJob()[IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores a parent job and places it back in the queue given
//*     a full path to the queue file where it is persisted.
//* PARAMETERS:
//*     lpcwstrFileName [IN]
//*         A pointer to the full path of the persisted file.
//* RETURN VALUE:
//*     TRUE
//*         If the restore operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL RestoreParentJob(
    IN LPCWSTR lpcwstrFileName
    )
{
    PJOB_QUEUE_FILE lpJobQueueFile = NULL;
    PJOB_QUEUE lpParentJob = NULL;
    BOOL bRet;

    DEBUG_FUNCTION_NAME(TEXT("RestoreParentJob"));
    Assert(lpcwstrFileName);

    //
    // Read the job into memory and fix it up to contain pointers again
    // If successful the function allocates a JOB_QUEUE_FILE (+ data) .
    //
    if (!ReadJobQueueFile(lpcwstrFileName,&lpJobQueueFile)) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("ReadJobQueueFile() failed. (ec: %ld)"),
                      GetLastError());
        //
        // An event log will be issued by JobQueueThread
        //
        goto Error;
    }
    Assert(lpJobQueueFile);

    if (!FixupJobQueueFile(lpJobQueueFile)) {
        goto Error;
    }

    //
    // Add the parent job to the queue
    //
    lpParentJob=AddParentJob(
                    &g_QueueListHead,
                    lpJobQueueFile->FileName,
                    &lpJobQueueFile->SenderProfile,
                    &lpJobQueueFile->JobParamsEx,
                    &lpJobQueueFile->CoverPageEx,
                    lpJobQueueFile->UserName,
                    lpJobQueueFile->UserSid,
                    NULL,   // Do not render coverpage of first recipient. We already have the correct FileSize.
                    FALSE   // Do not create queue file (we already have one)
                    );
    if (!lpParentJob) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("AddParentJob() failed for PARENT file %s. (ec: %ld)"),
                      lpcwstrFileName,
                      GetLastError());
        goto Error;
    }

    //
    // Set the job state to fit the saved state
    //
    lpParentJob->PageCount = lpJobQueueFile->PageCount;
    lpParentJob->FileSize = lpJobQueueFile->FileSize;
    lpParentJob->QueueFileName = StringDup( lpcwstrFileName );
    lpParentJob->StartTime = lpJobQueueFile->StartTime;
    lpParentJob->EndTime = lpJobQueueFile->EndTime;
    lpParentJob->dwLastJobExtendedStatus = lpJobQueueFile->dwLastJobExtendedStatus;
    lstrcpy (lpParentJob->ExStatusString, lpJobQueueFile->ExStatusString);
    lpParentJob->UniqueId = lpJobQueueFile->UniqueId;
    lpParentJob->SubmissionTime = lpJobQueueFile->SubmissionTime;
    lpParentJob->OriginalScheduleTime = lpJobQueueFile->OriginalScheduleTime;

    bRet = TRUE;
    goto Exit;
Error:
    bRet = FALSE;
Exit:
    MemFree(lpJobQueueFile);
    return bRet;
}


//********************************************************************************
//* Name: RestoreParentJobs()[IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores all the parent jobs in the queue directory and puts them
//*     back into the queue. It DOES NOT restore the recipient jobs.
//* PARAMETERS:
//*     None.
//* RETURN VALUE:
//*     TRUE
//*         If all the parent jobs were restored successfully.
//*     FALSE
//*         If the function failed at restoring at least one of the parent jobs.
//*********************************************************************************
BOOL
RestoreParentJobs( VOID )
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    WCHAR szFileName[MAX_PATH]; // The name of the current parent file.
    BOOL bAnyFailed;

    DEBUG_FUNCTION_NAME(TEXT("RestoreParentJobs"));
    //
    // Scan all the files with .FQP postfix.
    // For each file call RestoreParentJob() to restore
    // the parent job.
    //
    bAnyFailed = FALSE;

    wsprintf( szFileName, TEXT("%s\\*.FQP"), g_wszFaxQueueDir ); // *.FQP files are parent jobs
    hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // No parent jobs found at queue dir
        //
        DebugPrintEx( DEBUG_WRN,
                      TEXT("No parent jobs found at queue dir %s"),
                      g_wszFaxQueueDir);
        return TRUE;
    }
    do {
        wsprintf( szFileName, TEXT("%s\\%s"), g_wszFaxQueueDir, FindData.cFileName );
        DebugPrintEx( DEBUG_MSG,
                      TEXT("Restoring parent job from file %s"),
                      szFileName);
        if (!RestoreParentJob(szFileName)) {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("RestoreParentJob() failed for %s (ec: %ld)"),
                      szFileName,
                      GetLastError());
            bAnyFailed=TRUE;
        }
    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose faield (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

    return bAnyFailed ? FALSE : TRUE;
}


//*********************************************************************************
//* Name:   RestoreRecipientJob()[IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores a recipient job and places it back in the queue given
//*     a full path to the queue file where it is persisted.
//* PARAMETERS:
//*     lpcwstrFileName [IN]
//*         A pointer to the full path of the persisted file.
//* RETURN VALUE:
//*     TRUE
//*         If the restore operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL RestoreRecipientJob(LPCWSTR lpcwstrFileName)
{
    PJOB_QUEUE_FILE lpJobQueueFile = NULL;
    PJOB_QUEUE lpRecpJob = NULL;
    PJOB_QUEUE lpParentJob = NULL;
    DWORD dwJobStatus;
    BOOL bRet;

    DEBUG_FUNCTION_NAME(TEXT("RestoreRecipientJob"));
    Assert(lpcwstrFileName);

    //
    // Read the job into memory and fix it up to contain pointers again
    // The function allocates memeory to hold the file contents in memory.
    //
    if (!ReadJobQueueFile(lpcwstrFileName,&lpJobQueueFile)) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("ReadJobQueueFile() failed. (ec: %ld)"),
                      GetLastError());
        //
        // An event log will be issued by JobQueueThread
        //
        goto Error;
    }
    Assert(lpJobQueueFile);

    if (!FixupJobQueueFile(lpJobQueueFile)) {
        goto Error;
    }

    //
    // Locate the parent job by its unique id.
    //

    lpParentJob = FindJobQueueEntryByUniqueId( lpJobQueueFile->dwlParentJobUniqueId );
    if (!lpParentJob) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to locate parent job with UniqueId: 0x%016I64X for RECIPIENT job 0x%016I64X )"),
            lpJobQueueFile->dwlParentJobUniqueId,
            lpJobQueueFile->UniqueId
            );

        //
        // This recipient job is an orphan. Delete it.
        //
        if (!DeleteFile(lpcwstrFileName)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to delete orphan recipient job %s (ec: %ld)"),
                lpcwstrFileName, GetLastError()
                );
        }
    goto Error;
    }

    //
    // Restore the previous job status unless it is JS_INPROGRESS
    //
    if ((lpJobQueueFile->EFSPPermanentMessageId.dwIdSize == 0) &&
        (JS_INPROGRESS ==  lpJobQueueFile->JobStatus))
    {
        if (0 == lpJobQueueFile->SendRetries)
        {
            dwJobStatus = JS_PENDING;
        }
        else
        {
            dwJobStatus = JS_RETRYING;
        }
    }
    else
    {
        dwJobStatus = lpJobQueueFile->JobStatus;
    }

    //
    // Add the recipient job to the queue
    //
    lpRecpJob=AddRecipientJob(
                    &g_QueueListHead,
                    lpParentJob,
                    &lpJobQueueFile->RecipientProfile,
                    FALSE, // do not commit to disk
                    dwJobStatus
                    );

    if (!lpRecpJob) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("AddRecipientJob() failed for RECIPIENT file %s. (ec: %ld)"),
                      lpcwstrFileName,
                      GetLastError());
        goto Error;
    }

    //
    // Restore last extended status
    //
    lpRecpJob->dwLastJobExtendedStatus = lpJobQueueFile->dwLastJobExtendedStatus;
    lstrcpy (lpRecpJob->ExStatusString, lpJobQueueFile->ExStatusString);
    lstrcpy (lpRecpJob->tczDialableRecipientFaxNumber, lpJobQueueFile->tczDialableRecipientFaxNumber);

    lpRecpJob->QueueFileName = StringDup( lpcwstrFileName );
    if (lpcwstrFileName && !lpRecpJob->QueueFileName) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lpRecpJob->QueueFileName StringDup failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpRecpJob->UniqueId = lpJobQueueFile->UniqueId;
    MemFree(lpRecpJob->FileName); // need to free the one we copy from the parent as default
    lpRecpJob->FileName=StringDup(lpJobQueueFile->FileName);
    if (lpJobQueueFile->FileName && !lpRecpJob->FileName) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lpRecpJob->FileName StringDup failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpRecpJob->SendRetries = lpJobQueueFile->SendRetries;

    Assert( !(JS_INPROGRESS & lpRecpJob->JobStatus)); // Jobs are not persisted as in progress

    if (lpRecpJob->JobStatus & JS_CANCELED) {
        lpRecpJob->lpParentJob->dwCanceledRecipientJobsCount+=1;
    } else
    if (lpRecpJob->JobStatus & JS_COMPLETED) {
        lpRecpJob->lpParentJob->dwCompletedRecipientJobsCount+=1;
    } else
    if (lpRecpJob->JobStatus & JS_RETRIES_EXCEEDED) {
        lpRecpJob->lpParentJob->dwFailedRecipientJobsCount+=1;
    }

    //
    // Restore the permanent message id
    //
    if (lpJobQueueFile->EFSPPermanentMessageId.dwIdSize)
    {
        Assert(lpJobQueueFile->EFSPPermanentMessageId.lpbId);
        lpRecpJob->EFSPPermanentMessageId.dwSizeOfStruct = sizeof(FSPI_MESSAGE_ID);
        lpRecpJob->EFSPPermanentMessageId.dwIdSize = lpJobQueueFile->EFSPPermanentMessageId.dwIdSize;
        lpRecpJob->EFSPPermanentMessageId.lpbId = (LPBYTE)MemAlloc(lpRecpJob->EFSPPermanentMessageId.dwIdSize);
        if (!lpRecpJob->EFSPPermanentMessageId.lpbId)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for permanent EFSP message id (size: %ld) (ec: %ld)"),
                lpRecpJob->EFSPPermanentMessageId.dwIdSize,
                GetLastError());
            goto Error;
        }
        memcpy( lpRecpJob->EFSPPermanentMessageId.lpbId,
                (LPBYTE)lpJobQueueFile + (ULONG_PTR)(lpJobQueueFile->EFSPPermanentMessageId.lpbId),
                lpRecpJob->EFSPPermanentMessageId.dwIdSize);
    }

    lpRecpJob->StartTime = lpJobQueueFile->StartTime;
    lpRecpJob->EndTime = lpJobQueueFile->EndTime;

    //
    //  Override the Parent's Schedule Time & Action
    //
    lpRecpJob->JobParamsEx.dwScheduleAction = lpJobQueueFile->JobParamsEx.dwScheduleAction;
    lpRecpJob->ScheduleTime = lpJobQueueFile->ScheduleTime;

    bRet = TRUE;
    goto Exit;
Error:
    bRet = FALSE;
Exit:
    MemFree(lpJobQueueFile);
    return bRet;

}


//********************************************************************************
//* Name: RestoreRecipientJobs() [IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores all the recipient jobs and their relationships with their parent
//*     jobs.
//* PARAMETERS:
//*     None.
//* RETURN VALUE:
//*     TRUE
//*         If all the recipient jobs were restored successfully.
//*     FALSE
//*         If the function failed at restoring at least one of the recipient jobs.
//*********************************************************************************
BOOL
RestoreRecipientJobs( VOID )
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    WCHAR szFileName[MAX_PATH]; // The name of the current parent file.
    BOOL bAnyFailed;


    DEBUG_FUNCTION_NAME(TEXT("RestoreRecipientJobs"));
    //
    // Scan all the files with .FQP postfix.
    // For each file call RestoreParentJob() to restore
    // the parent job.
    //
    bAnyFailed=FALSE;

    wsprintf( szFileName, TEXT("%s\\*.FQE"), g_wszFaxQueueDir ); // *.FQE files are recipient jobs
    hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // succeed at doing nothing
        //
        DebugPrintEx( DEBUG_WRN,
                      TEXT("No recipient jobs found at queue dir %s"),
                      g_wszFaxQueueDir);
        return TRUE;
    }
    do {
        wsprintf( szFileName, TEXT("%s\\%s"), g_wszFaxQueueDir, FindData.cFileName );
        DebugPrintEx( DEBUG_MSG,
                      TEXT("Restoring recipient job from file %s"),
                      szFileName);
        if (!RestoreRecipientJob(szFileName)) {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("RestoreRecipientJob() failed for %s (ec: %ld)"),
                      szFileName,
                      GetLastError());
            bAnyFailed=TRUE;
        }
    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose faield (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

    return bAnyFailed ? FALSE : TRUE;
}



//*********************************************************************************
//* Name:   RestoreReceiveJob() [IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores a receive job and places it back in the queue given
//*     a full path to the queue file where it is persisted.
//* PARAMETERS:
//*     lpcwstrFileName [IN]
//*         A pointer to the full path of the persisted file.
//* RETURN VALUE:
//*     TRUE
//*         If the restore operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL RestoreReceiveJob(LPCWSTR lpcwstrFileName)
{
    PJOB_QUEUE_FILE lpJobQueueFile = NULL;
    PJOB_QUEUE lpJobQueue = NULL;
    BOOL bRet;
    DWORD i;
    PGUID Guid;
    LPTSTR FaxRouteFileName;
    PFAX_ROUTE_FILE FaxRouteFile;
    WCHAR FullPathName[MAX_PATH];
    LPWSTR fnp;


    DEBUG_FUNCTION_NAME(TEXT("RestoreReceiveJob"));
    Assert(lpcwstrFileName);

    //
    // Read the job into memory and fix it up to contain pointers again
    // The function allocates memeory to hold the file contents in memory.
    //

    if (!ReadJobQueueFile(lpcwstrFileName,&lpJobQueueFile))
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("ReadJobQueueFile() failed. (ec: %ld)"),
                      GetLastError());
        //
        // An event log will be issued by JobQueueThread
        //
        goto Error;
    }
    Assert(lpJobQueueFile);

    if (!FixupJobQueueFile(lpJobQueueFile))
    {
        goto Error;
    }

    Assert (JS_RETRYING == lpJobQueueFile->JobStatus ||
            JS_RETRIES_EXCEEDED == lpJobQueueFile->JobStatus);


    //
    // Add the receive job to the queue
    //
    lpJobQueue=AddReceiveJobQueueEntry(
        lpJobQueueFile->FileName,
        NULL,
        JT_ROUTING,
        lpJobQueueFile->UniqueId
        );

    if (!lpJobQueue)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("AddReceiveJobQueueEntry() failed for RECEIVE file %s. (ec: %ld)"),
                      lpcwstrFileName,
                      GetLastError());
        goto Error;
    }

    if (JS_RETRIES_EXCEEDED == lpJobQueueFile->JobStatus)
    {
        lpJobQueue->JobStatus = JS_RETRIES_EXCEEDED;
    }

    lpJobQueue->QueueFileName = StringDup( lpcwstrFileName );
    if (lpcwstrFileName && !lpJobQueue->QueueFileName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpJobQueue->UniqueId = lpJobQueueFile->UniqueId;
    lpJobQueue->FileName = StringDup(lpJobQueueFile->FileName);
    if (lpJobQueueFile->FileName && !lpJobQueue->FileName ) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }
    lpJobQueue->SendRetries     = lpJobQueueFile->SendRetries; // Routing retries
    lpJobQueue->FileSize        = lpJobQueueFile->FileSize;
    lpJobQueue->PageCount       =   lpJobQueueFile->PageCount;
    lpJobQueue->StartTime       = lpJobQueueFile->StartTime;
    lpJobQueue->EndTime         = lpJobQueueFile->EndTime;
    lpJobQueue->ScheduleTime    = lpJobQueueFile->ScheduleTime;

    lpJobQueue->CountFailureInfo = lpJobQueueFile->CountFailureInfo;
    if (lpJobQueue->CountFailureInfo)
    {
        //
        // Allocate array of  ROUTE_FAILURE_INFO
        //
        lpJobQueue->pRouteFailureInfo = (PROUTE_FAILURE_INFO)MemAlloc(sizeof(ROUTE_FAILURE_INFO) * lpJobQueue->CountFailureInfo);
        if (NULL == lpJobQueue->pRouteFailureInfo)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate ROUTE_FAILURE_INFO")
                );
            goto Error;
        }
        ZeroMemory(lpJobQueue->pRouteFailureInfo, sizeof(ROUTE_FAILURE_INFO) * lpJobQueue->CountFailureInfo);

        CopyMemory(
            lpJobQueue->pRouteFailureInfo,
            (LPBYTE)lpJobQueueFile + (ULONG_PTR)lpJobQueueFile->pRouteFailureInfo,
            sizeof(ROUTE_FAILURE_INFO) * lpJobQueue->CountFailureInfo
            );
    }

    //
    // handle the failure data.
    //
    for (i = 0; i < lpJobQueue->CountFailureInfo; i++)
    {
        if (lpJobQueue->pRouteFailureInfo[i].FailureSize)
        {
            ULONG_PTR ulpOffset = (ULONG_PTR)lpJobQueue->pRouteFailureInfo[i].FailureData;
            lpJobQueue->pRouteFailureInfo[i].FailureData = MemAlloc(lpJobQueue->pRouteFailureInfo[i].FailureSize);

            if (lpJobQueue->pRouteFailureInfo[i].FailureData)
            {
               CopyMemory(
                lpJobQueue->pRouteFailureInfo[i].FailureData,
                (LPBYTE) lpJobQueueFile + ulpOffset,
                lpJobQueue->pRouteFailureInfo[i].FailureSize
                );

            }
            else
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to allocate FailureData (%ld bytes) (ec: %ld)"),
                    lpJobQueueFile->pRouteFailureInfo[i].FailureSize,
                    GetLastError()
                    );
                goto Error;
            }
        }
        else
        {
            lpJobQueue->pRouteFailureInfo[i].FailureData = NULL;
        }
    }

    if (lpJobQueueFile->FaxRoute)
    {
        PFAX_ROUTE pSerializedFaxRoute = (PFAX_ROUTE)(((LPBYTE)lpJobQueueFile + (ULONG_PTR)lpJobQueueFile->FaxRoute));

        lpJobQueue->FaxRoute = DeSerializeFaxRoute( pSerializedFaxRoute );
        if (lpJobQueue->FaxRoute)
        {
            lpJobQueue->FaxRoute->JobId = lpJobQueue->JobId;
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeSerializeFaxRoute() failed (ec: %ld)"),
                i,
                lpJobQueueFile->FaxRouteSize,
                GetLastError()
                );
            goto Error;
        }
    }

    Guid = (PGUID) (((LPBYTE) lpJobQueueFile) + lpJobQueueFile->FaxRouteFileGuid);
    FaxRouteFileName = (LPTSTR) (((LPBYTE) lpJobQueueFile) + lpJobQueueFile->FaxRouteFiles);
    for (i = 0; i < lpJobQueueFile->CountFaxRouteFiles; i++)
    {
        if (GetFullPathName( FaxRouteFileName, sizeof(FullPathName)/sizeof(WCHAR), FullPathName, &fnp ))
        {
            FaxRouteFile = (PFAX_ROUTE_FILE) MemAlloc( sizeof(FAX_ROUTE_FILE) );
            if (FaxRouteFile)
            {
                ZeroMemory (FaxRouteFile,  sizeof(FAX_ROUTE_FILE));
                FaxRouteFile->FileName = StringDup( FullPathName );
                if (FaxRouteFile->FileName)
                {
                    CopyMemory( &FaxRouteFile->Guid, &Guid, sizeof(GUID) );
                    InsertTailList( &lpJobQueue->FaxRouteFiles, &FaxRouteFile->ListEntry );
                    lpJobQueue->CountFaxRouteFiles += 1;
                }
                else
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StringDup failed (ec: %ld)"),
                        GetLastError()
                        );
                    goto Error;
                }
            }
            else
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to allocate FaxRouteFile for file %s (%ld bytes) (ec: %ld)"),
                    FaxRouteFileName,
                    sizeof(FAX_ROUTE_FILE),
                    GetLastError()
                    );
                goto Error;
            }
        }
        Guid++;
        while(*FaxRouteFileName++); // skip to next file name
    }

    bRet = TRUE;
    goto Exit;
Error:
    if (lpJobQueue)
    {
        EnterCriticalSection (&g_CsQueue);
        DecreaseJobRefCount( lpJobQueue, FALSE );      // don't notify
        LeaveCriticalSection (&g_CsQueue);
    }
    bRet = FALSE;
Exit:
    MemFree(lpJobQueueFile);
    return bRet;
}


//********************************************************************************
//* Name: RestoreReceiveJobs()[IQR]
//* Author: Ronen Barenboim
//* Date:   April 12, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Restores all the recipient jobs and thier relationships with thier parent
//*     jobs.
//* PARAMETERS:
//*     None.
//* RETURN VALUE:
//*     TRUE
//*         If all the recipient jobs were restored successfully.
//*     FALSE
//*         If the function failed at restoring at least one of the recipient jobs.
//*********************************************************************************
BOOL
RestoreReceiveJobs( VOID )
{
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    WCHAR szFileName[MAX_PATH]; // The name of the current parent file.
    BOOL bAnyFailed;


    DEBUG_FUNCTION_NAME(TEXT("RestoreReceiveJobs"));
    //
    // Scan all the files with .FQE postfix.
    // For each file call RestoreReParentJob() to restore
    // the parent job.
    //
    bAnyFailed=FALSE;

    wsprintf( szFileName, TEXT("%s\\*.FQR"), g_wszFaxQueueDir ); // *.FQR files are receive jobs
    hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // succeed at doing nothing
        //
        DebugPrintEx( DEBUG_WRN,
                      TEXT("No receive jobs found at queue dir %s"),
                      g_wszFaxQueueDir);
        return TRUE;
    }
    do {
        wsprintf( szFileName, TEXT("%s\\%s"), g_wszFaxQueueDir, FindData.cFileName );
        DebugPrintEx( DEBUG_MSG,
                      TEXT("Restoring receive job from file %s"),
                      szFileName);
        if (!RestoreReceiveJob(szFileName)) {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("RestoreReceiveJob() failed for %s (ec: %ld)"),
                      szFileName,
                      GetLastError());
            bAnyFailed=TRUE;
        }
    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose faield (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }


    return bAnyFailed ? FALSE : TRUE;
}



//*********************************************************************************
//* Name:   RemoveRecipientlessParents()[IQR]
//* Author: Ronen Barenboim
//* Date:   12-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Removes from the job queue any parent jobs which do not have
//*     any recipients.
//* PARAMETERS:
//*     [IN]    const LIST_ENTRY * lpQueueHead
//*         Pointer to the head of the job queue list in which the removal
//*         should be performed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void RemoveRecipientlessParents(
    const LIST_ENTRY * lpQueueHead
    )
{
    PLIST_ENTRY lpNext;
    PJOB_QUEUE lpQueueEntry;
    DEBUG_FUNCTION_NAME(TEXT("RemoveRecipientlessParents"));

    Assert(lpQueueHead);

    lpNext = lpQueueHead->Flink;
    if ((ULONG_PTR)lpNext == (ULONG_PTR)lpQueueHead)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Queue empty"));
    }

    while ((ULONG_PTR)lpNext != (ULONG_PTR)lpQueueHead)
    {
        lpQueueEntry = CONTAINING_RECORD( lpNext, JOB_QUEUE, ListEntry );
        lpNext = lpQueueEntry->ListEntry.Flink;
        if (JT_BROADCAST == lpQueueEntry->JobType)
        {
            if (0 == lpQueueEntry->dwRecipientJobsCount)
            {
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("Parent job %ld (UniqueId: 0x%016I64X) has no recipients. Deleting."),
                    lpQueueEntry->JobId,
                    lpQueueEntry->UniqueId
                    );
                RemoveParentJob (lpQueueEntry, FALSE,FALSE); // do not notify, do not remove recipients
            }
        }
    }
}


//*********************************************************************************
//* Name:   RemoveCompletedOrCanceledJobs()[IQR]
//* Author: Oded Sacher
//* Date:   27-Jan-2000
//*********************************************************************************
//* DESCRIPTION:
//*     Removes from the job queue any job that is completed or cancelled.
//* PARAMETERS:
//*     [IN]    const LIST_ENTRY * lpQueueHead
//*         Pointer to the head of the job queue list in which the removal
//*         should be performed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void RemoveCompletedOrCanceledJobs(
    const LIST_ENTRY * lpQueueHead
    )
{
    PLIST_ENTRY lpNext;
    PJOB_QUEUE lpQueueEntry;
    DEBUG_FUNCTION_NAME(TEXT("RemoveCompletedOrCanceledJobs"));

    Assert(lpQueueHead);

    BOOL bFound = TRUE;
    while (bFound)
    {
        lpNext = lpQueueHead->Flink;
        if ((ULONG_PTR)lpNext == (ULONG_PTR)lpQueueHead)
        {
            // empty queue
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("Queue empty"));
                return;
        }
        bFound = FALSE;
        while ((ULONG_PTR)lpNext != (ULONG_PTR)lpQueueHead)
        {
            lpQueueEntry = CONTAINING_RECORD( lpNext, JOB_QUEUE, ListEntry );
            if (JT_SEND == lpQueueEntry->JobType && lpQueueEntry->RefCount != 0) // we did not decrease ref count for this job yet
            {
                Assert (lpQueueEntry->lpParentJob);
                Assert (1 == lpQueueEntry->RefCount);
                if ( lpQueueEntry->JobStatus == JS_COMPLETED || lpQueueEntry->JobStatus == JS_CANCELED )
                {
                    //
                    //  Recipient job is completed or canceled - decrease its ref count
                    //
                    DebugPrintEx(
                        DEBUG_WRN,
                        TEXT("Recipient job %ld (UniqueId: 0x%016I64X) is completed or canceled. decrease reference count."),
                        lpQueueEntry->JobId,
                        lpQueueEntry->UniqueId
                        );

                    DecreaseJobRefCount (lpQueueEntry,
                                         FALSE     // // Do not notify
                                         );
                    bFound = TRUE;
                    break; // out of inner while - start search from the begining of the list  because jobs might be removed
                }
            }
            lpNext = lpQueueEntry->ListEntry.Flink;
        }  // end of inner while
    }  // end of outer while
    return;
}   // RemoveCompletedOrCanceledJobs



BOOL CleanupReestablishOrphans(
    const LIST_ENTRY * lpQueueHead
    )
{
   PLIST_ENTRY lpNext;
   PJOB_QUEUE lpQueueEntry;
   DEBUG_FUNCTION_NAME(TEXT("CleanupReestablishOrphans"));

   Assert(lpQueueHead);

   lpNext = lpQueueHead->Flink;
    if ((ULONG_PTR)lpNext == (ULONG_PTR)lpQueueHead)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Queue empty"));
        return TRUE;
    }

    while ((ULONG_PTR)lpNext != (ULONG_PTR)lpQueueHead)
    {
        lpQueueEntry = CONTAINING_RECORD( lpNext, JOB_QUEUE, ListEntry );
        lpNext = lpQueueEntry->ListEntry.Flink;
        if (JT_SEND == lpQueueEntry->JobType)
        {
            if (!lpQueueEntry->JobEntry && lpQueueEntry->EFSPPermanentMessageId.dwIdSize)
            {
                //
                // This is a recipent job that was intended for reestablish but was not
                // reestablished.

                //
                // Free the EFSP permanent id stored in it.
                //
                if (!FreePermanentMessageId(&lpQueueEntry->EFSPPermanentMessageId, FALSE))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("FreePermanentMessageId() failed (JobId: %ld) (ec: %ld)"),
                        lpQueueEntry->JobId);
                    ASSERT_FALSE;
                }

                //
                // Mark it as expired and commit it to disk.
                //
                // We need to define a new job state for reestablish failure jobs
                //

                if (0 == lpQueueEntry->dwLastJobExtendedStatus)
                {
                    //
                    // Job was never really executed - this is a fatal error
                    //
                    lpQueueEntry->dwLastJobExtendedStatus = FSPI_ES_FATAL_ERROR;
                }
                if (!MarkJobAsExpired(lpQueueEntry))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("[JobId: %ld] MarkJobAsExpired failed (ec: %ld)"),
                        lpQueueEntry->JobId,
                        GetLastError());
                }
            }
        }
    }
    return TRUE;
}

//*********************************************************************************
//* Name:   RestoreFaxQueue() [IQR]
//* Author: Ronen Barenboim
//* Date:   13-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Restores all the jobs in the queue directory back into the job queue.
//*     Deletes all preview files "*.PRV" , and recipient tiff files "*.FRT".
//* PARAMETERS:
//*     VOID
//*
//* RETURN VALUE:
//*     TRUE
//*         If the restore operation completed succesfully for all the jobs.
//*     FALSE
//*         If the restore operation failed for any job.
//*********************************************************************************
BOOL RestoreFaxQueue(VOID)
{
    BOOL bAllParentsRestored = FALSE;
    BOOL bAllRecpRestored = FALSE;
    BOOL bAllRoutingRestored = FALSE;
    BOOL bAllPreviewFilesDeleted = FALSE;
    BOOL bAllRecipientTiffFilesDeleted = FALSE;
    BOOL bAllTempFilesDeleted = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("RestoreFaxQueue"));

    bAllPreviewFilesDeleted = DeleteQueueFiles(TEXT("PRV"));
    if (!bAllPreviewFilesDeleted) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("At least one preview file was not deleted.")
            );
    }

    bAllRecipientTiffFilesDeleted = DeleteQueueFiles(TEXT("FRT"));
    if (!bAllPreviewFilesDeleted) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("At least one recipient tiff  file was not deleted.")
            );
    }

    bAllTempFilesDeleted = DeleteQueueFiles(TEXT("tmp"));
    if (!bAllTempFilesDeleted) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("At least one temp file was not deleted.")
            );
    }

    bAllParentsRestored=RestoreParentJobs();
    if (!bAllParentsRestored) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("At least one parent job was not restored.")
            );
    }

    bAllRecpRestored=RestoreRecipientJobs();
    if (!bAllRecpRestored) {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("At least one recipient job was not restored.")
            );
    }
    //
    // Get rid of any parent jobs without recipients
    //
    RemoveRecipientlessParents(&g_QueueListHead); // void return value

    //
    // Get rid of any job that is completed or canceled
    //
    RemoveCompletedOrCanceledJobs(&g_QueueListHead); // void return value

    //
    // Restore routing jobs
    //
    bAllRoutingRestored=RestoreReceiveJobs();

    PrintJobQueue( TEXT("RestoreFaxQueue"), &g_QueueListHead );

    if (!ReestablishEFSPJobGroups())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("At least one EFSP job groups failed to load.")
            );
    }

    //
    // Cleanu up recipient jobs that have a permanent message id
    // but were not restore. This can happen when the group job
    // they were placed in failed to load.
    //

    if (!CleanupReestablishOrphans(&g_QueueListHead))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CleanupReestablishOrphans() failed (ec: %ld).")
            );
    }

    if (!StartJobQueueTimer())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartJobQueueTimer failed. (ec: %ld)"),
            GetLastError());
    }

    return bAllParentsRestored && bAllRecpRestored && bAllRoutingRestored;

}




//*********************************************************************************
//* Name:   JobParamsExSerialize()
//* Author: Ronen Barenboim
//* Date:   11-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Takes a FAX_JOB_PARAM_EXW structure and serializes its data
//*     starting from a specific offset in a provided buffer.
//*     It returns a FAX_JOB_PARAM_EXW structure where memory
//*     addresses are replaced with the offsets where the variable data was placed.
//*     It updates the offset to reflect the size of the serialized variable data.
//*     Supports just recalculating the variable data size.
//* PARAMETERS:
//*
//*     [IN]    LPCFAX_JOB_PARAM_EXW lpJobParamsSrc
//*         The structure to serialize.
//*
//*     [OUT]   PFAX_JOB_PARAM_EXW lpJobParamsDst
//*         The "serialized" strucutre. Pointers in this structure
//*         will be replaced by offsets relevant to the serialize buffer
//*         start (based on the provided pupOffset)
//*
//*     [OUT]   LPBYTE lpbBuffer
//*         The buffer where varialbe length data should be placed.
//*         If this parameter is NULL the offset is increased to reflect the
//*         variable data size but the data is not copied to the buffer.
//*
//*     [IN/OUT] PULONG_PTR pupOffset
//*         The offset in the serialize buffer where variable data should be placed.
//*         On return it is increased by theh size of the variable length data.
//*
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void JobParamsExSerialize(  LPCFAX_JOB_PARAM_EXW lpJobParamsSrc,
                            PFAX_JOB_PARAM_EXW lpJobParamsDst,
                            LPBYTE lpbBuffer,
                            PULONG_PTR pupOffset
                         )
{
    Assert(lpJobParamsSrc);
    Assert(pupOffset);


    if (lpbBuffer) {
        CopyMemory(lpJobParamsDst,lpJobParamsSrc,sizeof(*lpJobParamsDst));
    }
    StoreString(
        lpJobParamsSrc->lptstrReceiptDeliveryAddress,
        (PULONG_PTR)&lpJobParamsDst->lptstrReceiptDeliveryAddress,
        lpbBuffer,
        pupOffset
    );

    StoreString(
        lpJobParamsSrc->lptstrDocumentName,
        (PULONG_PTR)&lpJobParamsDst->lptstrDocumentName,
        lpbBuffer,
        pupOffset
    );
}
//*********************************************************************************
//* Name:   CoverPageExSerialize()
//* Author: Ronen Barenboim
//* Date:   11-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Takes a FAX_COVERPAGE_INFO_EXW structure and serializes its data
//*     starting from a specific offset in a provided buffer.
//*     It returns a FAX_COVERPAGE_INFO_EXW structure where memory
//*     addresses are replaced with the offsets where the variable data was placed.
//*     It updates the offset to reflect the size of the serialized variable data.
//*     Supports just recalculating the variable data size.
//* PARAMETERS:
//*
//*     [IN]    LPCFAX_COVERPAGE_INFO_EXW lpCoverPageSrc
//*         The structure to serialize.
//*
//*     [OUT]   PFAX_COVERPAGE_INFO_EXW lpCoverPageDst
//*         The "serialized" strucutre. Pointers in this structure
//*         will be replaced by offsets relevant to the serialize buffer
//*         start (based on the provided pupOffset)
//*
//*     [OUT]   LPBYTE lpbBuffer
//*         The buffer where varialbe length data should be placed.
//*         If this parameter is NULL the offset is increased to reflect the
//*         variable data size but the data is not copied to the buffer.
//*
//*     [IN/OUT] PULONG_PTR pupOffset
//*         The offset in the serialize buffer where variable data should be placed.
//*         On return it is increased by theh size of the variable length data.
//*
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void CoverPageExSerialize(
    IN LPCFAX_COVERPAGE_INFO_EXW lpCoverPageSrc,
    OUT PFAX_COVERPAGE_INFO_EXW lpCoverPageDst,
    OUT LPBYTE lpbBuffer,
    IN OUT PULONG_PTR pupOffset
     )
{
    Assert(lpCoverPageSrc);
    Assert(pupOffset);

    if (lpbBuffer) {
        CopyMemory(lpCoverPageDst,lpCoverPageSrc,sizeof(*lpCoverPageDst));
    }

    StoreString(
        lpCoverPageSrc->lptstrCoverPageFileName,
        (PULONG_PTR)&lpCoverPageDst->lptstrCoverPageFileName,
        lpbBuffer,
        pupOffset
    );

    StoreString(
        lpCoverPageSrc->lptstrNote,
        (PULONG_PTR)&lpCoverPageDst->lptstrNote,
        lpbBuffer,
        pupOffset
    );

    StoreString(
        lpCoverPageSrc->lptstrSubject,
        (PULONG_PTR)&lpCoverPageDst->lptstrSubject,
        lpbBuffer,
        pupOffset
    );

}

//*********************************************************************************
//* Name:   PersonalProfileSerialize()
//* Author: Ronen Barenboim
//* Date:   11-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Takes a FAX_PERSONAL_PROFILEW structure and serializes its data
//*     starting from a specific offset in a provided buffer.
//*     It returns a FAX_PERSONAL_PROFILEW structure where memory
//*     addresses are replaced with the offsets where the variable data was placed.
//*     It updates the offset to reflect the size of the serialized variable data.
//*     Supports just recalculating the variable data size.
//* PARAMETERS:
//*
//*     [IN]    LPCFAX_PERSONAL_PROFILEW lpProfileSrc
//*         The structure to serialize.
//*
//*     [OUT]   PFAX_PERSONAL_PROFILE lpProfileDst
//*         The "serialized" strucutre. Pointers in this structure
//*         will be replaced by offsets relevant to the serialize buffer
//*         start (based on the provided pupOffset)
//*
//*     [OUT]   LPBYTE lpbBuffer
//*         The buffer where varialbe length data should be placed.
//*         If this parameter is NULL the offset is increased to reflect the
//*         variable data size but the data is not copied to the buffer.
//*
//*     [IN/OUT] ULONG_PTR pupOffset
//*         The offset in the serialize buffer where variable data should be placed.
//*         On return it is increased by theh size of the variable length data.
//*
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void PersonalProfileSerialize(
    IN LPCFAX_PERSONAL_PROFILEW lpProfileSrc,
    OUT PFAX_PERSONAL_PROFILE lpProfileDst,
    OUT LPBYTE lpbBuffer,
    IN OUT PULONG_PTR pupOffset
     )
{
    Assert(lpProfileSrc);
    Assert(pupOffset);
    if (lpbBuffer) {
        lpProfileDst->dwSizeOfStruct=sizeof(*lpProfileDst);
    }

    StoreString(
        lpProfileSrc->lptstrName,
        (PULONG_PTR)&lpProfileDst->lptstrName,
        lpbBuffer,
        pupOffset
    );

    StoreString(
        lpProfileSrc->lptstrFaxNumber,
        (PULONG_PTR)&lpProfileDst->lptstrFaxNumber,
        lpbBuffer,
        pupOffset
    );

    StoreString(
        lpProfileSrc->lptstrCompany,
        (PULONG_PTR)&lpProfileDst->lptstrCompany,
        lpbBuffer,
        pupOffset
    );

    StoreString(
        lpProfileSrc->lptstrStreetAddress,
        (PULONG_PTR)&lpProfileDst->lptstrStreetAddress,
        lpbBuffer,
        pupOffset
    );
    StoreString(
        lpProfileSrc->lptstrCity,
        (PULONG_PTR)&lpProfileDst->lptstrCity,
        lpbBuffer,
        pupOffset
    );
    StoreString(
        lpProfileSrc->lptstrState,
        (PULONG_PTR)&lpProfileDst->lptstrState,
        lpbBuffer,
        pupOffset
    );
    StoreString(
        lpProfileSrc->lptstrZip,
        (PULONG_PTR)&lpProfileDst->lptstrZip,
        lpbBuffer,
        pupOffset
    );
    StoreString(
        lpProfileSrc->lptstrCountry,
        (PULONG_PTR)&lpProfileDst->lptstrCountry,
        lpbBuffer,
        pupOffset
    );
    StoreString(
        lpProfileSrc->lptstrTitle,
        (PULONG_PTR)&lpProfileDst->lptstrTitle,
        lpbBuffer,
        pupOffset
    );
    StoreString(
        lpProfileSrc->lptstrDepartment,
        (PULONG_PTR)&lpProfileDst->lptstrDepartment,
        lpbBuffer,
        pupOffset
    );
    StoreString(
        lpProfileSrc->lptstrOfficeLocation,
        (PULONG_PTR)&lpProfileDst->lptstrOfficeLocation,
        lpbBuffer,
        pupOffset
    );

    StoreString(
        lpProfileSrc->lptstrHomePhone,
        (PULONG_PTR)&lpProfileDst->lptstrHomePhone,
        lpbBuffer,
        pupOffset
    );

    StoreString(
        lpProfileSrc->lptstrOfficePhone,
        (PULONG_PTR)&lpProfileDst->lptstrOfficePhone,
        lpbBuffer,
        pupOffset
    );
    StoreString(
        lpProfileSrc->lptstrEmail,
        (PULONG_PTR)&lpProfileDst->lptstrEmail,
        lpbBuffer,
        pupOffset
    );
    StoreString(
        lpProfileSrc->lptstrBillingCode,
        (PULONG_PTR)&lpProfileDst->lptstrBillingCode,
        lpbBuffer,
        pupOffset
    );

    StoreString(
        lpProfileSrc->lptstrTSID,
        (PULONG_PTR)&lpProfileDst->lptstrTSID,
        lpbBuffer,
        pupOffset
    );

}



//*********************************************************************************
//* Name:   SerializeRoutingInfo()
//* Author: Ronen Barenboim
//* Date:   13-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Serializes the routing information in a JOB_QUEUE structure
//*     into a JOB_QUEUE_FILE structure.
//*     The variable data is put in the provided buffer starting from the provided
//*     offset.
//*     The corresponding fields in JOB_QUEUE_FILE are set to the offsets where
//*     their corresponding variable data was placed.
//*     The offset is updated to follow the new varialbe data in the buffer.
//* PARAMETERS:
//*     [IN]   const JOB_QUEUE * lpcJobQueue
//*         A pointer to thhe JOB_QUEUE strucutre for which routing information
//*         is to be serialized.
//*
//*     [OUT]  PJOB_QUEUE_FILE lpJobQueueFile
//*         A pointer to the JOB_QUEUE_FILE structure where the serialized routing
//*         information is to be placed. The function assumes that the buffer
//*         pointed to by this pointer is large enough to hold all the variable
//*         size routing information starting from the specified offset.
//*
//*     [IN/OUT] PULONG_PTR pupOffset
//*         The offset from the start of the buffer pointet to by lpJobQueueFile
//*         where the variable data should be placed.
//*         On return this parameter is increased by the size of the variable data.
//*
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//*
//*********************************************************************************
BOOL SerializeRoutingInfo(
    IN const JOB_QUEUE * lpcJobQueue,
    OUT PJOB_QUEUE_FILE lpJobQueueFile,
    IN OUT PULONG_PTR      pupOffset
    )
{
    DWORD i;
    PFAX_ROUTE lpFaxRoute = NULL;
    DWORD RouteSize;
    PLIST_ENTRY Next;
    PFAX_ROUTE_FILE FaxRouteFile;
    ULONG_PTR ulptrOffset;
    ULONG_PTR ulptrFaxRouteInfoOffset;
    BOOL bRet;

    DEBUG_FUNCTION_NAME(TEXT("SerializeRoutingInfo"));

    Assert(lpcJobQueue);
    Assert(lpJobQueueFile);
    Assert(pupOffset);


    //
    // For a routing job we need to serialize the routing data including:
    //    FAX_ROUTE structure
    //    pRouteFailureInfo
    //    Fax route files array

    ulptrOffset=*pupOffset;

    lpJobQueueFile->CountFailureInfo = lpcJobQueue->CountFailureInfo;
    CopyMemory(
            (LPBYTE) lpJobQueueFile + ulptrOffset,
            lpcJobQueue->pRouteFailureInfo,
            sizeof(ROUTE_FAILURE_INFO) * lpcJobQueue->CountFailureInfo
        );
    ulptrFaxRouteInfoOffset = ulptrOffset;
    lpJobQueueFile->pRouteFailureInfo =  (PROUTE_FAILURE_INFO)((LPBYTE)lpJobQueueFile + ulptrFaxRouteInfoOffset);
    ulptrOffset += sizeof(ROUTE_FAILURE_INFO) * lpcJobQueue->CountFailureInfo;

    for (i = 0; i < lpcJobQueue->CountFailureInfo; i++)
    {
        lpJobQueueFile->pRouteFailureInfo[i].FailureData = (PVOID) ulptrOffset;

        //
        // protect ourselves since this comes from a routing extension that may be misbehaving
        //
        __try
        {
           CopyMemory(
               (LPBYTE) lpJobQueueFile + ulptrOffset,
               lpcJobQueue->pRouteFailureInfo[i].FailureData,
               lpcJobQueue->pRouteFailureInfo[i].FailureSize
               );
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("* CRASHED * during copy of FailureData at index %ld (ec: %ld )"),GetExceptionCode());
            bRet = FALSE;
            goto Exit;
        }

        ulptrOffset += lpcJobQueue->pRouteFailureInfo[i].FailureSize;
    }
    lpJobQueueFile->pRouteFailureInfo = (PROUTE_FAILURE_INFO)ulptrFaxRouteInfoOffset;

    //
    // Serialze FAX_ROUTE and place it in the bufrer
    //
    lpFaxRoute = SerializeFaxRoute( lpcJobQueue->FaxRoute, &RouteSize,FALSE );
    if (!lpFaxRoute)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("SerializeFaxRoute failed. (ec: %ld)"),GetLastError());
        bRet=FALSE;
        goto Exit;
    }

    lpJobQueueFile->FaxRoute = (PFAX_ROUTE) ulptrOffset;

    CopyMemory(
        (LPBYTE) lpJobQueueFile + ulptrOffset,
        lpFaxRoute,
        RouteSize
        );

    lpJobQueueFile->FaxRouteSize = RouteSize;

    ulptrOffset += RouteSize;


    lpJobQueueFile->CountFaxRouteFiles = 0;

    Next = lpcJobQueue->FaxRouteFiles.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&lpcJobQueue->FaxRouteFiles) {
        DWORD TmpSize;

        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;

        CopyMemory( (LPBYTE) lpJobQueueFile + ulptrOffset, (LPBYTE) &FaxRouteFile->Guid, sizeof(GUID) );

        if (lpJobQueueFile->CountFaxRouteFiles == 0) {
            lpJobQueueFile->FaxRouteFileGuid = (ULONG)ulptrOffset;
        }

        ulptrOffset += sizeof(GUID);

        TmpSize = StringSize( FaxRouteFile->FileName );

        CopyMemory( (LPBYTE) lpJobQueueFile + ulptrOffset, FaxRouteFile->FileName, TmpSize );

        if (lpJobQueueFile->CountFaxRouteFiles == 0) {
            lpJobQueueFile->FaxRouteFiles = (ULONG)ulptrOffset;
        }

        ulptrOffset += TmpSize;

        lpJobQueueFile->CountFaxRouteFiles++;
    }

    *pupOffset=ulptrOffset;
    bRet=TRUE;

Exit:
    MemFree(lpFaxRoute);
    return bRet;
}





//*********************************************************************************
//* Name:   CalcJobQueuePersistentSize()
//* Author: Ronen Barenboim
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Calculates the size of the VARIABLE size data in a JOB_QUEUE structure
//*     which is about to be serialized.
//* PARAMETERS:
//*     [IN] const PJOB_QUEUE  lpcJobQueue
//*         Pointer to the JOB_QUEUE structure for which the calculation is to
//*         be performed.
//*
//* RETURN VALUE:
//*     The size of the variable data in bytes.
//*     Does not include sizeof(JOB_QUEUE_FILE) !!!
//*
//*********************************************************************************
DWORD CalcJobQueuePersistentSize(
    IN const PJOB_QUEUE  lpcJobQueue
    )
{
    DWORD i;
    ULONG_PTR Size;
    PLIST_ENTRY Next;
    PFAX_ROUTE_FILE FaxRouteFile;
    DWORD RouteSize;
    DEBUG_FUNCTION_NAME(TEXT("CalcJobQueuePersistentSize"));
    Assert(lpcJobQueue);

    Size=0;

    Size += StringSize( lpcJobQueue->QueueFileName );

    if (lpcJobQueue->JobType == JT_BROADCAST ||
        lpcJobQueue->JobType == JT_ROUTING)
    {
        //
        // Persist file name only for parent and routing jobs
        //
        Size += StringSize( lpcJobQueue->FileName );
    }

    JobParamsExSerialize(&lpcJobQueue->JobParamsEx, NULL, NULL,&Size);
    CoverPageExSerialize(&lpcJobQueue->CoverPageEx, NULL, NULL,&Size);
    PersonalProfileSerialize(&lpcJobQueue->SenderProfile, NULL, NULL, &Size);
    Size += StringSize(lpcJobQueue->UserName);
    PersonalProfileSerialize(&lpcJobQueue->RecipientProfile, NULL, NULL, &Size);

    if (lpcJobQueue->UserSid != NULL)
    {
        // Sid must be valid (checked in CommitQueueEntry)
        Size += GetLengthSid( lpcJobQueue->UserSid );
    }


    for (i = 0; i < lpcJobQueue->CountFailureInfo; i++)
    {
        Size += lpcJobQueue->pRouteFailureInfo[i].FailureSize;
        Size += sizeof(ROUTE_FAILURE_INFO);
    }

    Next = lpcJobQueue->FaxRouteFiles.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&lpcJobQueue->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        Size += sizeof(GUID);
        Size += StringSize( FaxRouteFile->FileName );
    }

    if (lpcJobQueue->JobType == JT_ROUTING)
    {
        SerializeFaxRoute( lpcJobQueue->FaxRoute,
                                      &RouteSize,
                                      TRUE      //Just get the size
                                     );
        Size += RouteSize;
    }

    //
    // Save space for the permanent EFSP id if any.
    //
    if (lpcJobQueue->EFSPPermanentMessageId.dwIdSize)
    {
        Assert(lpcJobQueue->EFSPPermanentMessageId.lpbId);
        Size += lpcJobQueue->EFSPPermanentMessageId.dwIdSize; // for the variable size EFSP permanent id size.

    }
    else
    {
        Assert(!lpcJobQueue->EFSPPermanentMessageId.lpbId);
    }

    return Size;

}


//*********************************************************************************
//* Name:   BOOL CommitQueueEntry() [IQR]
//* Author: Ronen Barenboim
//* Date:   12-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Serializes a job to a file.
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE JobQueue
//*                 The job to serialize to file.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation completed successfuly.
//*     FALSE
//*         If the operation failed.
//*********************************************************************************
BOOL
CommitQueueEntry(
    PJOB_QUEUE JobQueue
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD Size = 0;
    PJOB_QUEUE_FILE JobQueueFile = NULL;
    ULONG_PTR Offset;
    BOOL rVal = TRUE;
    DWORD dwSidSize = 0;

    DEBUG_FUNCTION_NAME(TEXT("CommitQueueEntry"));

    Assert(JobQueue);
    Assert(JobQueue->QueueFileName);
    Assert(JobQueue->JobType != JT_RECEIVE);

    if (JobQueue->UserSid != NULL)
    {
        if (!IsValidSid (JobQueue->UserSid))
        {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] Does not have a valid SID."),
                      JobQueue->JobId);
            return FALSE;
        }
    }

    //
    // calculate the size required to hold the JOB_QUEUE_FILE structure
    // and all the variable length data.
    //
    Size = sizeof(JOB_QUEUE_FILE);
    Size += CalcJobQueuePersistentSize(JobQueue);

    JobQueueFile = (PJOB_QUEUE_FILE) MemAlloc(Size );

    if (!JobQueueFile)
    {
        return FALSE;
    }

    ZeroMemory( JobQueueFile, Size );
    Offset = sizeof(JOB_QUEUE_FILE);

    //
    // Intialize the JOB_QUEUE_FILE structure with non variable size data.
    //
    JobQueueFile->SizeOfStruct = sizeof(JOB_QUEUE_FILE);
    JobQueueFile->UniqueId = JobQueue->UniqueId;
    JobQueueFile->ScheduleTime = JobQueue->ScheduleTime;
    JobQueueFile->OriginalScheduleTime = JobQueue->OriginalScheduleTime;
    JobQueueFile->SubmissionTime = JobQueue->SubmissionTime;
    JobQueueFile->JobType = JobQueue->JobType;
    //JobQueueFile->QueueFileName = [OFFSET]
    //JobQueue->FileName = [OFFSET]
    JobQueueFile->JobStatus = JobQueue->JobStatus;

    JobQueueFile->dwLastJobExtendedStatus = JobQueue->dwLastJobExtendedStatus;
    lstrcpy (JobQueueFile->ExStatusString, JobQueue->ExStatusString);

    lstrcpy (JobQueueFile->tczDialableRecipientFaxNumber, JobQueue->tczDialableRecipientFaxNumber);

    JobQueueFile->PageCount = JobQueue->PageCount;
    //JobQueueFile->JobParamsEx = [OFFSET]
    //JobQueueFile->CoverPageEx = [OFFSET]
    JobQueueFile->dwRecipientJobsCount =JobQueue->dwRecipientJobsCount;
    //JobQueueFile->lpdwlRecipientJobIds = [OFFSET]
    //JobQueueFile->SenderProfile = [OFFSET]
    JobQueueFile->dwCanceledRecipientJobsCount = JobQueue->dwCanceledRecipientJobsCount;
    JobQueueFile->dwCompletedRecipientJobsCount = JobQueue->dwCompletedRecipientJobsCount;
    JobQueueFile->FileSize = JobQueue->FileSize;
    //JobQueueFile->UserName = [OFFSET]
    //JobQueueFile->RecipientProfile = [OFFSET]
    if (JT_SEND == JobQueue->JobType)
    {
        Assert(JobQueue->lpParentJob);
        JobQueueFile->dwlParentJobUniqueId = JobQueue->lpParentJob->UniqueId;
    }
    JobQueueFile->SendRetries = JobQueue->SendRetries;
    JobQueueFile->StartTime = JobQueue->StartTime;
    JobQueueFile->EndTime = JobQueue->EndTime;

    //
    //Serialize UserSid
    //
    if (JobQueue->UserSid != NULL)
    {
        dwSidSize = GetLengthSid( JobQueue->UserSid );
        JobQueueFile->UserSid = (LPBYTE)Offset;
        memcpy( (LPBYTE)JobQueueFile + Offset,
                JobQueue->UserSid,
                dwSidSize);
        Offset += dwSidSize;
    }


    //
    // Serialize the EFSP permanent message id
    //
    JobQueueFile->EFSPPermanentMessageId.dwIdSize = JobQueue->EFSPPermanentMessageId.dwIdSize;
    JobQueueFile->EFSPPermanentMessageId.lpbId = (LPBYTE)Offset;
    memcpy( (LPBYTE)JobQueueFile + Offset,
            JobQueue->EFSPPermanentMessageId.lpbId,
            JobQueueFile->EFSPPermanentMessageId.dwIdSize);

    Offset += JobQueueFile->EFSPPermanentMessageId.dwIdSize;
    //
    // Now serialize all the variable length data structures
    //
    StoreString(
        JobQueue->QueueFileName,
        (PULONG_PTR)&JobQueueFile->QueueFileName,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    if (JobQueue->JobType == JT_BROADCAST ||
        JobQueue->JobType == JT_ROUTING)
    {
        //
        // Persist file name only for parent and routing jobs
        //
        StoreString(
            JobQueue->FileName,
            (PULONG_PTR)&JobQueueFile->FileName,
            (LPBYTE)JobQueueFile,
            &Offset
            );
    }

    JobParamsExSerialize(
        &JobQueue->JobParamsEx,
        &JobQueueFile->JobParamsEx,
        (LPBYTE)JobQueueFile,
        &Offset );

    CoverPageExSerialize(
        &JobQueue->CoverPageEx,
        &JobQueueFile->CoverPageEx,
        (LPBYTE)JobQueueFile,
        &Offset );

    PersonalProfileSerialize(
        &JobQueue->SenderProfile,
        &JobQueueFile->SenderProfile,
        (LPBYTE)JobQueueFile,
        &Offset );

    StoreString(
        JobQueue->UserName,
        (PULONG_PTR)&JobQueueFile->UserName,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    PersonalProfileSerialize(
        &JobQueue->RecipientProfile,
        &JobQueueFile->RecipientProfile,
        (LPBYTE)JobQueueFile,
        &Offset );

    if (JobQueue->JobType == JT_ROUTING)
    {
        rVal = SerializeRoutingInfo(JobQueue,JobQueueFile,&Offset);
        //rVal=TRUE;
        if (!rVal)
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("[JobId: %ld] SerializeRoutingInfo failed. (ec: %ld)"),
                          JobQueue->JobId,
                          GetLastError());
            goto Exit;
        }
    }

    //
    // Make sure the offset we have is in sync with the buffer size we calculated
    //
    Assert(Offset == Size);

    hFile = CreateFile(
        JobQueue->QueueFileName,
        GENERIC_WRITE,
        0,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] Failed to open file %s for write operation."),
                      JobQueue->JobId,
                      JobQueue->QueueFileName);
        rVal = FALSE;
        goto Exit;
    }

    //
    // Write the buffer to the disk file
    //
    if (!WriteFile( hFile, JobQueueFile, Size, &Size, NULL ))
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] Failed to write queue entry buffer to file %s (ec: %ld). Deleting file."),
                      JobQueue->JobId,
                      JobQueue->QueueFileName,
                      GetLastError());
        if (!CloseHandle( hFile ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle() for file %s (Handle: 0x%08X) failed. (ec: %ld)"),
                JobQueueFile,
                hFile,
                GetLastError());
        }
        hFile = INVALID_HANDLE_VALUE;
        if (!DeleteFile( JobQueue->QueueFileName ))
        {
             DebugPrintEx( DEBUG_ERR,
                           TEXT("[JobId: %ld] Failed to delete file %s (ec: %ld)"),
                           JobQueue->JobId,
                           JobQueue->QueueFileName,
                           GetLastError());
        }
        rVal = FALSE;
    }
    else
    {
        DebugPrintEx( DEBUG_MSG,
                      TEXT("[JobId: %ld] Successfuly persisted to file %s"),
                      JobQueue->JobId,
                      JobQueue->QueueFileName);
    }


Exit:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle( hFile );
    }

    MemFree( JobQueueFile );
    return rVal;
}

/******************************************************************************
* Name: RescheduleJobQueueEntry
* Author:
*******************************************************************************
DESCRIPTION:
    Reschedules the execution of the specified job queue entry to the current
    time + send retry time.
    The job is removed from the queue in which it is currently located and placed
    in the FAX JOB QUEUE (g_QueueListHead).


PARAMETERS:
   JobQueue [IN/OUT]
        A pointer to a JOB_QUEUE structure holding the information for the
        job to be rescheduled.

RETURN VALUE:
    NONE.

REMARKS:
    Removes the specified job queue entry from its queue.
    Sets it scheduled time to the current time.
    Reinserts it back to the list.
    Commits it back to the SAME file it used to be in.
*******************************************************************************/
VOID
RescheduleJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    )
{
    FILETIME CurrentFileTime;
    LARGE_INTEGER NewTime;
    PLIST_ENTRY Next;
    DWORD dwRetryDelay;
    DEBUG_FUNCTION_NAME(TEXT("RescheduleJobQueueEntry"));

    EnterCriticalSection (&g_CsConfig);
    dwRetryDelay = g_dwFaxSendRetryDelay;
    LeaveCriticalSection (&g_CsConfig);

    EnterCriticalSection( &g_CsQueue );

    RemoveEntryList( &JobQueue->ListEntry );

    GetSystemTimeAsFileTime( &CurrentFileTime );

    NewTime.LowPart = CurrentFileTime.dwLowDateTime;
    NewTime.HighPart = CurrentFileTime.dwHighDateTime;

    NewTime.QuadPart += SecToNano( (DWORDLONG)(dwRetryDelay * 60) );

    JobQueue->ScheduleTime = NewTime.QuadPart;

    JobQueue->JobParamsEx.dwScheduleAction = JSA_SPECIFIC_TIME;

    //
    // insert the queue entry into the FAX JOB QUEUE list in a sorted order
    //
    QUEUE_SORT NewEntry;

    //
    // Set the new QUEUE_SORT structure
    //
    NewEntry.Priority       = JobQueue->JobParamsEx.Priority;
    NewEntry.ScheduleTime   = JobQueue->ScheduleTime;
    NewEntry.QueueEntry     = NULL;

    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
    {
        PJOB_QUEUE QueueEntry;
        QUEUE_SORT CurrEntry;

        QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = QueueEntry->ListEntry.Flink;

        //
        // Set the current QUEUE_SORT structure
        //
        CurrEntry.Priority       = QueueEntry->JobParamsEx.Priority;
        CurrEntry.ScheduleTime   = QueueEntry->ScheduleTime;
        CurrEntry.QueueEntry     = NULL;

        if (QueueCompare(&NewEntry, &CurrEntry) < 0)
        {
            //
            // This inserts the new item BEFORE the current item
            //
            InsertTailList( &QueueEntry->ListEntry, &JobQueue->ListEntry );
            Next = NULL;
            break;
        }
    }
    if ((ULONG_PTR)Next == (ULONG_PTR)&g_QueueListHead)
    {
        InsertTailList( &g_QueueListHead, &JobQueue->ListEntry );
    }
    //
    // Note that this commits the job queue entry back to the SAME file
    // in which it was in the job queue before moving to the reschedule list.
    // (since JobQueue->UniqueId has not changed).
    //
    if (!CommitQueueEntry(JobQueue))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CommitQueueEntry() for recipien job %s has failed. (ec: %ld)"),
            JobQueue->FileName,
            GetLastError());
    }

    DebugPrintDateTime( TEXT("Rescheduling JobId %d at"), JobQueue->JobId );

    if (!StartJobQueueTimer())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartJobQueueTimer (ec: %ld)"),
            GetLastError());
    }

    LeaveCriticalSection( &g_CsQueue );
}


BOOL
PauseJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    )
{

    DWORD dwJobStatus;

    DEBUG_FUNCTION_NAME(TEXT("PauseJobQueueEntry"));

    Assert (JS_DELETING != JobQueue->JobStatus);
    Assert(JobQueue->lpParentJob); // Must not be a parent job for now.

    if (!JobQueue->lpParentJob)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] Attempting to pause parent job [JobStatus: 0x%08X]"),
            JobQueue->JobId,
            JobQueue->JobStatus);
        SetLastError(ERROR_INVALID_OPERATION);
        return FALSE;
    }

    //
    // Check the job state modifiers to find out if the job is paused or being paused. If it is
    // then do nothing and return TRUE.
    //
    if (JobQueue->JobStatus & JS_PAUSED)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("[JobId: %ld] Attempting to pause an already paused job [JobStatus: 0x%08X]"),
            JobQueue->JobId,
            JobQueue->JobStatus);
        return TRUE;
    }

    //
    // The job is not paused or being paused. The only modifier that might still be on
    // is JS_NOLINE and we ALLOW to pause jobs in the JS_NOLINE state so it should have
    // no effect on the pause decision.
    //


    //
    // Get rid of all the job status modifier bits
    //
    dwJobStatus = RemoveJobStatusModifiers(JobQueue->JobStatus);


    if ( (JS_RETRYING == dwJobStatus) || (JS_PENDING == dwJobStatus) )
    {
        //
        // Job is in the retrying or pending state. These are the only states
        // in which we allow to pause a job.
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("[JobId: %ld] Pausing job [JobStatus: 0x%08X]"),
            JobQueue->JobId,
            JobQueue->JobStatus);

        EnterCriticalSection (&g_CsQueue);
        if (!CancelWaitableTimer( g_hQueueTimer ))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("CancelWaitableTimer failed (ec: %ld)"),
                 GetLastError());
        }
        //
        // Turn on the pause flag.
        //
        JobQueue->JobStatus |= JS_PAUSED;
        if (!UpdatePersistentJobStatus(JobQueue))
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Failed to update persistent job status to 0x%08x"),
                 JobQueue->JobStatus);
        }

        //
        // Create Fax event
        //
        Assert (NULL == JobQueue->JobEntry); // We assume we do not have job entry so we did not lock g_CsJob
        DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                         JobQueue );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                JobQueue->UniqueId,
                dwRes);
        }

        //
        // We need to recalculate when the wake up the queue thread since the job we just
        // paused may be the one that was scheduled to wakeup the queue thread.
        //
        if (!StartJobQueueTimer())
        {
            DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("StartJobQueueTimer failed (ec: %ld)"),
                 GetLastError());
        }
        LeaveCriticalSection (&g_CsQueue);
        return TRUE;
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] Can not be paused at this status [JobStatus: 0x%08X]"),
            JobQueue->JobId,
            JobQueue->JobStatus);
        SetLastError(ERROR_INVALID_OPERATION);
        return FALSE;
    }


}


BOOL
ResumeJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    )
{
    DEBUG_FUNCTION_NAME(TEXT("ResumeJobQueueEntry"));
    EnterCriticalSection (&g_CsQueue);
    Assert (JS_DELETING != JobQueue->JobStatus);

    if (!CancelWaitableTimer( g_hQueueTimer ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CancelWaitableTimer failed (ec: %ld)"),
            GetLastError());
    }

    JobQueue->JobStatus &= ~JS_PAUSED;
    if (JobQueue->JobStatus & JS_RETRIES_EXCEEDED)
    {
        //
        // This is a RESTART and not RESUME
        //
        JobQueue->JobStatus = JS_PENDING;
        JobQueue->dwLastJobExtendedStatus = 0;
        JobQueue->ExStatusString[0] = TEXT('\0');
        JobQueue->SendRetries = 0;
        Assert(JobQueue->lpParentJob);
        JobQueue->lpParentJob->dwFailedRecipientJobsCount -= 1;
        if (!CommitQueueEntry(JobQueue))
        {
             DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("CommitQueueEntry failed for job %ld"),
                 JobQueue->UniqueId);
        }
    }
    else
    {
        if (!UpdatePersistentJobStatus(JobQueue))
        {
             DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("Failed to update persistent job status to 0x%08x"),
                 JobQueue->JobStatus);
        }
    }

    //
    // Create Fax EventEx
    //
    Assert (NULL == JobQueue->JobEntry); // We assume we do not have job entry so we did not lock g_CsJob
    DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                     JobQueue
                                   );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
            JobQueue->UniqueId,
            dwRes);
    }


    //
    // Clear up the JS_NOLINE flag so the StartJobQueueTimer will not skip it.
    //
    JobQueue->JobStatus &= (0xFFFFFFFF ^ JS_NOLINE);
    if (!StartJobQueueTimer())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartJobQueueTimer failed (ec: %ld)"),
            GetLastError());
    }

    LeaveCriticalSection (&g_CsQueue);
    return TRUE;
}


PJOB_QUEUE
FindJobQueueEntryByJobQueueEntry(
    IN PJOB_QUEUE JobQueueEntry
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;


    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if ((ULONG_PTR)JobQueue == (ULONG_PTR)JobQueueEntry) {
            return JobQueue;
        }
    }

    return NULL;
}



PJOB_QUEUE
FindJobQueueEntry(
    DWORD JobId
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;


    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if (JobQueue->JobId == JobId) {
            return JobQueue;
        }
    }

    return NULL;
}

PJOB_QUEUE
FindJobQueueEntryByUniqueId(
    DWORDLONG UniqueId
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;


    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if (JobQueue->UniqueId == UniqueId) {
            return JobQueue;
        }
    }

    return NULL;
}

#define ONE_DAY_IN_100NS (24I64 * 60I64 * 60I64 * 1000I64 * 1000I64 * 10I64)

DWORD
JobQueueThread(
    LPVOID UnUsed
    )
{
    DWORDLONG DueTime;
    DWORDLONG ScheduledTime;
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;
    HANDLE Handles[3];
    HANDLE hLineMutex;
    WCHAR LineMutexName[64];
    DWORD WaitObject;
    DWORDLONG DirtyDays = 0;
    BOOL InitializationOk = TRUE;
    DWORD dwQueueState;
    DWORD dwDirtyDays;
    DWORD dwJobStatus;
    BOOL bUseDirtyDays = TRUE;

    DEBUG_FUNCTION_NAME(TEXT("JobQueueThread"));

    Assert (g_hQueueTimer && g_hJobQueueEvent && g_hServiceShutDownEvent);

    Handles[0] = g_hQueueTimer;
    Handles[1] = g_hJobQueueEvent;
    Handles[2] = g_hServiceShutDownEvent;

	EnterCriticalSectionJobAndQueue;

    InitializationOk = RestoreFaxQueue();
    if (!InitializationOk)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RestoreFaxQueue() failed (ec: %ld)"),
            GetLastError());
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                0,
                MSG_QUEUE_INIT_FAILED
              );
    }

    LeaveCriticalSectionJobAndQueue;

	//
    // sort the job queue just in case our discount time has changed for the restored jobs
    //
    if (!SortJobQueue())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SortJobQueue() failed (ec: %ld)"),
            GetLastError());
    }

    if (!g_bDelaySuicideAttempt)
    {
        //
        // Let's check for suicide conditions now (during service startup).
        // If we can suicide, we do it ASAP.
        //
        // NOTICE: this code assumes the JobQueueThread is the last thread
        // created during service statup.
        // RPC is not initialized yet and no RPC server will be available if we die now.
        //
        if (ServiceShouldDie ())
        {
            //
            // Service should die now
            //
            // NOTICE: We're now in JobQueueThread which is launched by FaxInitThread.
            //         FaxInitThread launches us and immediately returns (dies) and only then the main thread
            //         reports SERVICE_RUNNING to the SCM.
            //         There's a tricky timing probelm here: if we call EndFaxSvc right away, a race
            //         condition may prevent the main thread to report SERVICE_RUNNING and
            //         since EndFaxSvc reports SERVICE_STOP_PENDING to the SCM, the SCM will
            //         think a bad service startup occurred since it did not get SERVICE_RUNNING yet.
            //
            //         Bottom line: we need to wait till the SCM gets the SERVICE_RUNNING status
            //         from the main thread and ONLY THEN call EndFaxSvc.
            //
            //         The way we do this is by waiting for g_hFaxServerEvent to be set.
            //         This event notifies the readiness of the RPC server and it means
            //         FaxInitThread is dead and the SCM knowns we're safely running.
            //
            //         If something bad happened while the RPC was initialized, the main thread never
            //         sets g_hFaxServerEvent but calls EndFaxSvc - so the service is down anyway.
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Waiting for g_hFaxServerEvent before shutting down the service"));

            DWORD dwRes = WaitForSingleObject (g_hFaxServerEvent, INFINITE);
            if (WAIT_OBJECT_0 != dwRes)
            {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("WaitForSingleObject(g_hFaxServerEvent) failed with %ld (last error  =%ld)."),
                    dwRes,
                    GetLastError());
            }
            else
            {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Service is shutting down due to idle activity."));

                //
                // StopService() is blocking so we must decrease the thread count before calling StopService()
                //
                if (!DecreaseServiceThreadsCount())
                {
                    DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                            GetLastError());
                }
                StopService (NULL, FAX_SERVICE_NAME, TRUE);

                return 0;   // Quit this thread
            }
        }
    }

    while (TRUE)
    {
        WaitObject = WaitForMultipleObjects( 3, Handles, FALSE, JOB_QUEUE_TIMEOUT );
        if (WAIT_FAILED == WaitObject)
        {
            DebugPrintEx(DEBUG_ERR,
                _T("WaitForMultipleObjects failed (ec: %d)"),
                GetLastError());
        }

        if (WaitObject == WAIT_TIMEOUT)
        {
            //
            // Check if the service should suicide
            //
            if (ServiceShouldDie ())
            {
                //
                //  Service should die now
                //
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Service is shutting down due to idle activity."));
                //
                // StopService() is blocking so we must decrease the thread count before calling StopService()
                //
                if (!DecreaseServiceThreadsCount())
                {
                    DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                            GetLastError());
                }
                StopService (NULL, FAX_SERVICE_NAME, TRUE);
                return 0;   // Quit this thread
            }


            //
            // Check if the queue should be scanned
            //
            EnterCriticalSection( &g_CsQueue );
            if (FALSE == g_ScanQueueAfterTimeout)
            {
                //
                // Go back to sleep
                //
                LeaveCriticalSection( &g_CsQueue );
                continue;
            }
            //
            // g_hQueueTimer or g_hJobQueueEvent were not set - Scan the queue.
            //
            g_ScanQueueAfterTimeout = FALSE; // Reset the flag
            LeaveCriticalSection( &g_CsQueue );

            DebugPrintEx(
                DEBUG_WRN,
                _T("JobQueueThread waked up after timeout. g_hJobQueueEvent or")
                _T("g_hQueueTimer are not set properly. Scan the QUEUE"));
        }

        if (2 == (WaitObject - WAIT_OBJECT_0))
        {
            //
            // Server is shutting down - Stop scanning the queue
            //
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("Server is shutting down - Stop scanning the queue"));
            break;
        }


        //
        // Get Dirtydays data
        //
        EnterCriticalSection (&g_CsConfig);
        dwDirtyDays = g_dwFaxDirtyDays;
        LeaveCriticalSection (&g_CsConfig);

        DirtyDays = dwDirtyDays * ONE_DAY_IN_100NS;

        // if dwDirtyDays is 0
        // this means disable dirty days functionality
        //
        bUseDirtyDays = (BOOL)(dwDirtyDays>0);
        //
        // find the jobs that need servicing in the queue
        //

        EnterCriticalSection( &g_CsJob );
        EnterCriticalSection( &g_CsQueue );

        GetSystemTimeAsFileTime( (LPFILETIME)&DueTime );
        if (WaitObject - WAIT_OBJECT_0 == 2)
        {
            DebugPrintDateTime( TEXT("Semaphore signaled at "), DueTime );
        }
        else if (WaitObject - WAIT_OBJECT_0 == 1)
        {
            DebugPrintDateTime( TEXT("Timer signaled at "), DueTime );
        }

        PrintJobQueue( TEXT("JobQueueThread"), &g_QueueListHead );

        //
        // Go over the job queue list looking for jobs to execute
        //
        Next = g_QueueListHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
        {
            if (TRUE == g_bServiceIsDown)
            {
                //
                // Server is shutting down - Stop scanning the queue
                //
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("Server is shutting down - Stop scanning the queue"));
                break;
            }

            JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
            Next = JobQueue->ListEntry.Flink;
            if ((JobQueue->JobStatus & JS_PAUSED) || (JobQueue->JobType == JT_RECEIVE) ) {
                // Don't care about paused or receive jobs
                continue;
            }

            dwJobStatus = (JT_SEND == JobQueue->JobType) ?
                           JobQueue->lpParentJob->JobStatus : JobQueue->JobStatus;
            if (dwJobStatus == JS_DELETING)
            {
                //
                // Job is being deleted - skip it.
                //
                continue;
            }

            if (JobQueue->JobStatus & JS_RETRIES_EXCEEDED)
            {
                ScheduledTime = (JobQueue->JobType == JT_SEND) ? JobQueue->lpParentJob->ScheduleTime : JobQueue->ScheduleTime;
                //
                // Get rid of jobs that have reached maximum retries.
                //
                if ( bUseDirtyDays &&
                     (ScheduledTime + DirtyDays < DueTime) )
                {
                    DebugPrint((TEXT("Removing job from queue (JS_RETRIES_EXCEEDED)\n")));

                    switch (JobQueue->JobType)
                    {
                        case JT_ROUTING:
                            JobQueue->JobStatus = JS_DELETING; // Prevent from decreasing ref count again
                            DecreaseJobRefCount( JobQueue , TRUE);
                            break;

                        case JT_SEND:
                            if (IsSendJobReadyForDeleting (JobQueue))
                            {
                                //
                                // All the recipients are in final state
                                //
                                DebugPrintEx(
                                    DEBUG_MSG,
                                    TEXT("Parent JobId: %ld has expired (dirty days). Removing it and all its recipients."),
                                    JobQueue->JobId);
                                //
                                // Decrease ref count for all failed recipients (since we keep failed
                                // jobs in the queue the ref count on the was not decreased in
                                // HandleFailedSendJob().
                                // We must decrease it now to remove them and their parent.
                                //
                                PLIST_ENTRY NextRecipient;
                                PJOB_QUEUE_PTR pJobQueuePtr;
                                PJOB_QUEUE pParentJob = JobQueue->lpParentJob;
                                DWORD dwFailedRecipientsCount = 0;
                                DWORD dwFailedRecipients = pParentJob->dwFailedRecipientJobsCount;

                                NextRecipient = pParentJob->RecipientJobs.Flink;
                                while (dwFailedRecipients > dwFailedRecipientsCount  &&
                                       (ULONG_PTR)NextRecipient != (ULONG_PTR)&pParentJob->RecipientJobs)
                                {
                                    pJobQueuePtr = CONTAINING_RECORD( NextRecipient, JOB_QUEUE_PTR, ListEntry );
                                    Assert(pJobQueuePtr->lpJob);
                                    NextRecipient = pJobQueuePtr->ListEntry.Flink;

                                    if (JS_RETRIES_EXCEEDED == pJobQueuePtr->lpJob->JobStatus)
                                    {

                                        //
                                        // For legacy compatibility send a FEI_DELETED event
                                        // (it was not send when the job was failed since we keep failed jobs
                                        //  in the queue just like in W2K).
                                        //

                                        if (!CreateFaxEvent(0, FEI_DELETED, pJobQueuePtr->lpJob->JobId))
                                        {
                                            DebugPrintEx(
                                                DEBUG_ERR,
                                                TEXT("CreateFaxEvent failed. (ec: %ld)"),
                                                GetLastError());
                                        }

                                        //
                                        // This will also call RemoveParentJob and mark the broadcast job as JS_DELETEING
                                        //
                                        DecreaseJobRefCount( pJobQueuePtr->lpJob, TRUE);
                                        dwFailedRecipientsCount++;
                                    }
                                }
                                //
                                // Since we removed several jobs from the list, Next is not valid any more. reset to the list start.
                                //
                                Next = g_QueueListHead.Flink;
                            }

                            break;
                    } // end switch
                }
                continue;
            }

            //
            // if the queue is paused or the job is already in progress, don't send it again
            //
            EnterCriticalSection (&g_CsConfig);
            dwQueueState = g_dwQueueState;
            LeaveCriticalSection (&g_CsConfig);
            if ((dwQueueState & FAX_OUTBOX_PAUSED) ||
                ((JobQueue->JobStatus & JS_INPROGRESS) == JS_INPROGRESS) ||
                ((JobQueue->JobStatus & JS_COMPLETED) == JS_COMPLETED)
                )
            {
                continue;
            }

            if (JobQueue->JobStatus & JS_RETRIES_EXCEEDED)
            {
                continue;
            }

            if (JobQueue->JobStatus & JS_CANCELED) {
                //
                // Skip cancelled jobs
                //
                continue;
            }
            if (JobQueue->JobStatus & JS_CANCELING) {
                //
                // Skip cancelled jobs
                //
                continue;
            }

            if (JobQueue->JobType==JT_BROADCAST) {
                //
                // skip it
                //
                continue;
            }

            //
            // Check for routing jobs
            //
            if (JobQueue->JobType == JT_ROUTING)
            {
                //
                // Routing job detected
                //
                if (JobQueue->ScheduleTime != 0 && DueTime < JobQueue->ScheduleTime)
                {
                    //
                    // If its time has not yet arrived skip it.
                    //
                    continue;
                }

                // Time to route...
                if(!StartRoutingJob(JobQueue))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("[JobId: %ld] StartRoutingJob() failed (ec: %ld)"),
                        JobQueue->JobId,
                        GetLastError());
                }
                continue;
            }

            //
            // outbound job
            //
            if (JobQueue->DeviceId || JobQueue->ScheduleTime == 0 || DueTime >= JobQueue->ScheduleTime)
            {
                PLINE_INFO lpLineInfo;
                //
                // start the job (send job whose time has arrived or handoff job).
                //
                Assert(JT_SEND == JobQueue->JobType);
                if (JobQueue->DeviceId != 0)
                {
                    //
                    // we're doing a handoff job, create a mutex based on deviceId
                    //
                    BOOL fSendJobCreated = FALSE;
                    DebugPrint((TEXT("Creating a handoff job for device %d\n"), JobQueue->DeviceId));

                    wsprintf(LineMutexName, L"FaxLineHandoff%d", JobQueue->DeviceId);

                    hLineMutex = CreateMutex(NULL, TRUE, LineMutexName);

                    if (!hLineMutex)
                    {
                        DebugPrint((TEXT("CreateMutex failed, ec = %d\n"),GetLastError() ));
                        continue;
                    }
                    else
                    {
                        DWORD dwPermanentId = 0;
                        DWORD ec;

                        ec = g_pTAPIDevicesIdsMap->LookupUniqueId (JobQueue->DeviceId, &dwPermanentId);
                        if (ERROR_SUCCESS != ec)
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("LookupUniqueId() failed for device: %ld (ec: %ld)"),
                                JobQueue->DeviceId,
                                ec);
                        }
                        else
                        {
                            lpLineInfo = GetLineForSendOperation(
                                                JobQueue,
                                                dwPermanentId,
                                                FALSE, // Don't just query we want to get hold of the line
                                                FALSE  // since we use a specific device id this is ignored.
                                                );
                            if (!lpLineInfo)
                            {
                                DebugPrintEx(
                                    DEBUG_WRN,
                                    TEXT("[JobId: %ld] Handoff operation failed to get hold of line with permanent id: 0x%08X"),
                                    JobQueue->JobId,
                                    dwPermanentId);
                            }
                            else
                            {
                                if(!StartSendJob(JobQueue, lpLineInfo, TRUE))
                                {
                                    DebugPrintEx(
                                        DEBUG_ERR,
                                        TEXT("[JobId: %ld] StartSendJob() failed for handoff job (ec: %ld)"),
                                        JobQueue->JobId,
                                        GetLastError());
                                }
                                else
                                {
                                    //
                                    // Signal the client to handoff the line to the server
                                    // TapiWorkerThread will assign the offered line to the FaxSendThread that deals with this handoff job
                                    //
                                    DebugPrint((TEXT("Signalling line ownership mutex \"FaxLineHandoff%d\""), JobQueue->DeviceId));
                                    ReleaseMutex(hLineMutex);
                                    fSendJobCreated = TRUE; // FaxSendThread will delete the job.
                                }
                            }
                        }
                        CloseHandle(hLineMutex);
                        if (FALSE == fSendJobCreated)
                        {
                            //
                            // Delete the job
                            //
                            DecreaseJobRefCount(JobQueue, TRUE);
                        }
                    }
                }
                else
                {
                    DebugPrintEx(DEBUG_MSG,
                                 TEXT("Recipient Job : %ld is ready for execution. Job status is: 0x%0X."),
                                 JobQueue->JobId,
                                 JobQueue->JobStatus);


                    lpLineInfo = GetLineForSendOperation(
                                            JobQueue,
                                            USE_SERVER_DEVICE,
                                            FALSE, // Don't just query we want to get hold of the line
                                            FALSE // Don't ignore the line state. If it is busy we can't use it.
                                            );
                    if (!lpLineInfo)
                    {
                        DWORD ec = GetLastError();
                        if (ec == ERROR_NOT_FOUND)
                        {
                            DebugPrintEx(
                                DEBUG_WRN,
                                TEXT("Can not find a free line for JobId: %ld."),
                                JobQueue->JobId);
                            //
                            // Mark the fact that we have no line for this job.
                            //
                            JobQueue->JobStatus |= JS_NOLINE;
                        }
                        else
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("FindLineForSendOperation() failed for for JobId: %ld (ec: %ld)"),
                                JobQueue->JobId,
                                ec);
                            JobQueue->JobStatus |= JS_NOLINE;
                        }
                    }
                    else
                    {
                        //
                        // Clear up the JS_NOLINE flag if we were able to start the job.
                        // This is the point where a job which had no line comes back to life.
                        //
                        JobQueue->JobStatus &= (0xFFFFFFFF ^ JS_NOLINE);
                        if (!StartSendJob( JobQueue, lpLineInfo, FALSE))
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("StartSendJob() failed for JobId: %ld on Line: %s (ec: %ld)"),
                                JobQueue->JobId,
                                lpLineInfo->DeviceName,
                                GetLastError());
                        }
                    }

                }
            }
        }

        //
        // restart the timer
        //
        if (!StartJobQueueTimer())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StartJobQueueTimer failed (ec: %ld)"),
                GetLastError());
        }
        LeaveCriticalSection( &g_CsQueue );
        LeaveCriticalSection( &g_CsJob );
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return 0;
}


BOOL
SetDiscountTime(
   LPSYSTEMTIME CurrentTime
   )
/*++

Routine Description:

    Sets the passed in systemtime to a time inside the discount rate period.
    Some care must be taken here because the time passed in is in UTC time and the discount rate is
    for the current time zone.  Delineating a day must be done using the current time zone.  We convert the
    current time into the time zone specific time, run our time-setting algorithm, and then use an offset
    of the change in the time-zone specific time to set the passed in UTC time.

    Also, note that there are a few subtle subcases that depend on the order of the start and ending time
    for the discount period.

Arguments:

    CurrentTime - the current time of the job

Return Value:

    none. modifies CurrentTime.

--*/
{
   //              nano   microsec  millisec  sec      min    hours
   #define ONE_DAY 10I64 *1000I64*  1000I64 * 60I64 * 60I64 * 24I64
   LONGLONG Time, TzTimeBefore, TzTimeAfter,ftCurrent;
   SYSTEMTIME tzTime;
   FAX_TIME tmStartCheapTime;
   FAX_TIME tmStopCheapTime;

   DEBUG_FUNCTION_NAME(TEXT("SetDiscountTime"));

   //
   // convert our discount rates into UTC rates
   //

   if (!SystemTimeToTzSpecificLocalTime(NULL, CurrentTime, &tzTime)) {
       DebugPrintEx(
           DEBUG_ERR,
           TEXT("SystemTimeToTzSpecificLocalTime() failed. (ec: %ld)"),
           GetLastError());
      return FALSE;
   }

   if (!SystemTimeToFileTime(&tzTime, (FILETIME * )&TzTimeBefore)) {
       DebugPrintEx(
           DEBUG_ERR,
           TEXT("SystemTimeToFileTime() failed. (ec: %ld)"),
           GetLastError());
      return FALSE;
   }

   EnterCriticalSection (&g_CsConfig);
   tmStartCheapTime = g_StartCheapTime;
   tmStopCheapTime = g_StopCheapTime;
   LeaveCriticalSection (&g_CsConfig);

   //
   // there are 2 general cases with several subcases
   //

   //
   // case 1: discount start time is before discount stop time (don't overlap a day)
   //
   if ( tmStartCheapTime.Hour < tmStopCheapTime.Hour ||
        (tmStartCheapTime.Hour == tmStopCheapTime.Hour &&
         tmStartCheapTime.Minute < tmStopCheapTime.Minute ))
   {
      //
      // subcase 1: sometime before cheap time starts in the current day.
      //  just set it to the correct hour and minute today.
      //
      if ( tzTime.wHour < tmStartCheapTime.Hour ||
           (tzTime.wHour == tmStartCheapTime.Hour  &&
            tzTime.wMinute <= tmStartCheapTime.Minute) )
      {
         tzTime.wHour   =  tmStartCheapTime.Hour;
         tzTime.wMinute =  tmStartCheapTime.Minute;
         goto convert;
      }

      //
      // subcase 2: inside the current cheap time range
      // don't change anything, just send immediately
      if ( tzTime.wHour <  tmStopCheapTime.Hour ||
           (tzTime.wHour == tmStopCheapTime.Hour &&
            tzTime.wMinute <= tmStopCheapTime.Minute))
      {
         goto convert;
      }

      //
      // subcase 3: we've passed the cheap time range for today.
      //  Increment 1 day and set to the start of the cheap time period
      //
      if (!SystemTimeToFileTime(&tzTime, (FILETIME * )&Time))
      {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SystemTimeToFileTime() failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
      }

      Time += ONE_DAY;
      if (!FileTimeToSystemTime((FILETIME *)&Time, &tzTime)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FileTimeToSystemTime() failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
      }


      tzTime.wHour   = tmStartCheapTime.Hour;
      tzTime.wMinute = tmStartCheapTime.Minute;
      goto convert;

   } else {
      //
      // case 2: discount start time is after discount stop time (we overlap over midnight)
      //

      //
      // subcase 1: sometime aftert cheap time ended today, but before it starts later in the current day.
      //  set it to the start of the cheap time period today
      //
      if ( ( tzTime.wHour   > tmStopCheapTime.Hour ||
             (tzTime.wHour == tmStopCheapTime.Hour  &&
              tzTime.wMinute >= tmStopCheapTime.Minute) ) &&
           ( tzTime.wHour   < tmStartCheapTime.Hour ||
             (tzTime.wHour == tmStartCheapTime.Hour &&
              tzTime.wMinute <= tmStartCheapTime.Minute) ))
      {
         tzTime.wHour   =  tmStartCheapTime.Hour;
         tzTime.wMinute =  tmStartCheapTime.Minute;
         goto convert;
      }

      //
      // subcase 2: sometime after cheap time started today, but before midnight.
      // don't change anything, just send immediately
      if ( ( tzTime.wHour >= tmStartCheapTime.Hour ||
             (tzTime.wHour == tmStartCheapTime.Hour  &&
              tzTime.wMinute >= tmStartCheapTime.Minute) ))
      {
         goto convert;
      }

      //
      // subcase 3: somtime in next day before cheap time ends
      //  don't change anything, send immediately
      //
      if ( ( tzTime.wHour <= tmStopCheapTime.Hour ||
             (tzTime.wHour == tmStopCheapTime.Hour  &&
              tzTime.wMinute <= tmStopCheapTime.Minute) ))
      {
         goto convert;
      }

      //
      // subcase 4: we've passed the cheap time range for today.
      //  since start time comes after stop time, just set it to the start time later on today.

      tzTime.wHour   =  tmStartCheapTime.Hour;
      tzTime.wMinute =  tmStartCheapTime.Minute;
      goto convert;

   }

convert:

   if (!SystemTimeToFileTime(&tzTime, (FILETIME * )&TzTimeAfter)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SystemTimeToFileTime() failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
   }


   if (!SystemTimeToFileTime(CurrentTime, (FILETIME * )&ftCurrent)) {
       DebugPrintEx(
                DEBUG_ERR,
                TEXT("SystemTimeToFileTime() failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
    }


   ftCurrent += (TzTimeAfter - TzTimeBefore);

   if (!FileTimeToSystemTime((FILETIME *)&ftCurrent, CurrentTime)) {
       DebugPrintEx(
                DEBUG_ERR,
                TEXT("FileTimeToSystemTime() failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
    }


   return TRUE;

}


//*********************************
//* JOB_QUEUE_PTR list functions
//*********************************
void FreeJobQueuePtrList(PLIST_ENTRY lpListHead)
{
    PLIST_ENTRY lpNext;

    lpNext = lpListHead->Flink;
    while ((ULONG_PTR)lpNext != (ULONG_PTR)lpListHead) {
            PLIST_ENTRY lpTmp;

            lpTmp=lpNext;
            lpNext = lpNext->Flink;
            MemFree(lpTmp);
    }
}


//*********************************************************************************
//*                         Recipient Job Functions
//*********************************************************************************



//*********************************************************************************
//* Name:   AddRecipientJob()
//* Author: Ronen Barenboim
//* Date:   18-Mar-98
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*     [IN]     const PLIST_ENTRY lpcQueueHead
//*                 A pointer to the head entry of the queue to which to add the job.
//*
//*     [IN/OUT] PJOB_QUEUE lpParentJob
//*                 A pointer to the parent job of this recipient job.
//*
//*     [IN]     LPCFAX_PERSONAL_PROFILE lpcRecipientProfile
//*                 The personal information of the recipient.
//*                 When FaxNumber of the Recipient is compound, split it to :
//*                     Displayable ( put in Recipient's PersonalProfile ), and
//*                     Dialable ( put in RecipientJob's tczDialableRecipientFaxNumber ).
//*
//*     [IN]     BOOL bCreateQueueFile
//*                 If TRUE the new queue entry will be comitted to a disk file.
//*                 If FALSE it will not be comitted to a disk file. This is useful
//*                 when this function is used to restore the fax queue.
//*     [IN]     DWORD dwJobStatus  - the new job status - default value is JS_PENDING
//*
//* RETURN VALUE:
//*     On success the function returns a pointer to a newly created
//*     JOB_QUEUE structure.
//*     On failure it returns NULL.
//*********************************************************************************
PJOB_QUEUE
AddRecipientJob(
             IN const PLIST_ENTRY lpcQueueHead,
             IN OUT PJOB_QUEUE lpParentJob,
             IN LPCFAX_PERSONAL_PROFILE lpcRecipientProfile,
             IN BOOL bCreateQueueFile,
             IN DWORD dwJobStatus
            )

{
    PJOB_QUEUE lpJobQEntry;
    WCHAR QueueFileName[MAX_PATH];
    PJOB_QUEUE_PTR lpRecipientPtr;
    DWORD rc=ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("AddRecipientJob"));
    Assert(lpcQueueHead); // Must have a queue to add to
    Assert(lpParentJob);  // Must have a parent job
    Assert(lpcRecipientProfile); // Must have a recipient profile

    lpJobQEntry = new JOB_QUEUE;
    if (!lpJobQEntry)
    {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate memory for JOB_QUEUE structure. (ec: %ld)"),rc);
        goto Error;
    }

    ZeroMemory( lpJobQEntry, sizeof(JOB_QUEUE) );

    //
    // Notice - This (InitializeListHead) must be done regardles of the recipient type because the current code (for cleanup and persistence)
    // does not make a difference between the job types. I might change that in a while
    //
    InitializeListHead( &lpJobQEntry->FaxRouteFiles );
    InitializeListHead( &lpJobQEntry->RoutingDataOverride );

    if (!lpJobQEntry->CsFileList.Initialize() ||
        !lpJobQEntry->CsRoutingDataOverride.Initialize() ||
        !lpJobQEntry->CsPreview.Initialize())
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxCriticalSection::Initialize failed. (ec: %ld)"),
            rc);
        goto Error;
    }

    lpJobQEntry->JobId                     = InterlockedIncrement( (PLONG)&g_dwNextJobId );
    lpJobQEntry->JobType                   = JT_SEND;
    lpJobQEntry->JobStatus                 = dwJobStatus;
    //
    // Link back to parent job.
    //
    lpJobQEntry->lpParentJob=lpParentJob;
    //
    // We duplicate the relevant parent job parameters at each recipient (for consistency with legacy code).
    // It wastes some memory but it saves us the trouble of making a major change to the current code base.
    //
    lpJobQEntry->ScheduleTime=lpParentJob->ScheduleTime;
    lpJobQEntry->FileName = NULL;
    lpJobQEntry->FileSize=lpParentJob->FileSize;
    lpJobQEntry->PageCount=lpParentJob->PageCount;
    //
    // Copy job parameters from parent.
    //
    if (!CopyJobParamEx(&lpJobQEntry->JobParamsEx,&lpParentJob->JobParamsEx))
    {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("CopyJobParamEx failed. (ec: 0x%0X)"),rc);
        goto Error;
    }
    //
    // Copy Sender Profile from parent.
    //
    if (!CopyPersonalProfile(&lpJobQEntry->SenderProfile,&lpParentJob->SenderProfile))
    {
         rc=GetLastError();
         DebugPrintEx(DEBUG_ERR,TEXT("CopyJobParamEx failed. (ec: 0x%0X)"),rc);
         goto Error;
    }
    //
    // Set the recipient profile
    //
    if (!CopyPersonalProfile(&(lpJobQEntry->RecipientProfile),lpcRecipientProfile))
    {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy the sender personal profile (ec: 0x%0X)"),rc);
        goto Error;
    }

    //
    //  Set Dialable Fax Number of the Recipient
    //
    ZeroMemory(lpJobQEntry->tczDialableRecipientFaxNumber, SIZEOF_PHONENO * sizeof(TCHAR));

    if ( 0 == _tcsncmp(COMBINED_PREFIX, lpJobQEntry->RecipientProfile.lptstrFaxNumber, _tcslen(COMBINED_PREFIX)))
    {
        //
        //  Fax Number of the Recipient is Compound, so it contains the Dialable and the Displayable
        //  Extract Dialable to the JobQueue's DialableFaxNumber and
        //      put Displayable in the Recipient's Fax Number instead of the Compound
        //

        LPTSTR  lptstrStart = NULL;
        LPTSTR  lptstrEnd = NULL;
        DWORD   dwSize = 0;

        //
        //  Copy the Diable Fax Number to JobQueue.tczDialableRecipientFaxNumber
        //

        lptstrStart = (lpJobQEntry->RecipientProfile.lptstrFaxNumber) + _tcslen(COMBINED_PREFIX);

        lptstrEnd = _tcsstr(lptstrStart, COMBINED_SUFFIX);
        if (!lptstrEnd)
        {
            rc = ERROR_INVALID_PARAMETER;
            DebugPrintEx(DEBUG_ERR,
                _T("Wrong Compound Fax Number : %s"),
                lpJobQEntry->RecipientProfile.lptstrFaxNumber,
                rc);
            goto Error;
        }

        dwSize = lptstrEnd - lptstrStart;
        if (dwSize >= SIZEOF_PHONENO)
        {
            dwSize = SIZEOF_PHONENO - 1;
        }

        _tcsncpy (lpJobQEntry->tczDialableRecipientFaxNumber, lptstrStart, dwSize);

        //
        //  Replace Recipient's PersonalProfile's Compound Fax Number by the Displayable
        //

        lptstrStart = lptstrEnd + _tcslen(COMBINED_SUFFIX);

        dwSize = _tcslen(lptstrStart);
        lptstrEnd = LPTSTR(MemAlloc(sizeof(TCHAR) * (dwSize + 1)));
        if (!lptstrEnd)
        {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(DEBUG_ERR, _T("MemAlloc() failed"), rc);
            goto Error;
        }

        _tcscpy(lptstrEnd, lptstrStart);

        MemFree(lpJobQEntry->RecipientProfile.lptstrFaxNumber);
        lpJobQEntry->RecipientProfile.lptstrFaxNumber = lptstrEnd;
    }

    if (lpJobQEntry->JobParamsEx.hCall)
    {
        LPLINEDEVCAPS LineDevCaps;
        //
        // This is a handoff job.
        // In this case:
        //      JobParamsEx.hCall is the call handle on which we should call back
        //      JobParamsEx.dwReserved[2] is the device id of the call
        //      We need to get the permanent device id and store is in the job.
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("Adding a recipient handoff job. JobId = 0x%0X ; Call Handle = 0x%0X ; Device Id: 0x%0X \n"),
                     lpJobQEntry->JobId,
                     lpJobQEntry->JobParamsEx.hCall,
                     lpJobQEntry->JobParamsEx.dwReserved[2]);
        LineDevCaps = SmartLineGetDevCaps (g_hLineApp, (DWORD)lpJobQEntry->JobParamsEx.dwReserved[2], MAX_TAPI_API_VER);
        if (LineDevCaps)
        {
            // Store the permanent device id of the specified device in the job.
            lpJobQEntry->DeviceId = LineDevCaps->dwPermanentLineID;
            MemFree( LineDevCaps ) ;
        }
        else
        {
            rc=GetLastError();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("Failed to get permanent device id for device id: 0x%0x. (ec: 0x%X)."),
                         lpJobQEntry->JobParamsEx.dwReserved[2],
                         rc);
            goto Error;
        }
    }

    EnterCriticalSection( &g_CsQueue );
    if (bCreateQueueFile)
    {
        // Commit the job to the persistence file if it is not a handoff job.
        if (lpJobQEntry->DeviceId == 0)
        {
            // JOB_QUEUE::UniqueId holds the generated unique file name as 64 bit value.
            // composed as MAKELONGLONG( MAKELONG( FatDate, FatTime ), i ).
            lpJobQEntry->UniqueId=GenerateUniqueQueueFile(JT_SEND,  QueueFileName, sizeof(QueueFileName)/sizeof(WCHAR));
            if (0==lpJobQEntry->UniqueId)
            {
                // Failed to generate unique id
                rc=GetLastError();
                DebugPrintEx(DEBUG_ERR,TEXT("Failed to generate unique id for FQE file (ec: 0x%0X)"),rc);
                LeaveCriticalSection(&g_CsQueue);
                goto Error;
            }
            lpJobQEntry->QueueFileName = StringDup( QueueFileName );
            if (!CommitQueueEntry( lpJobQEntry))
            {
                rc=GetLastError();
                DebugPrintEx(DEBUG_ERR,TEXT("Failed to commit job queue entry to file %s (ec: %ld)"),QueueFileName,rc);
                LeaveCriticalSection(&g_CsQueue);
                goto Error;
            }
        }
    }
    //
    // Add the recipient job to the the queue
    //
    if (!InsertQueueEntryByPriorityAndSchedule(lpJobQEntry))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InsertQueueEntryByPriorityAndSchedule() failed (ec: %ld)."),
            rc);
        LeaveCriticalSection( &g_CsQueue );
        goto Error;
    }


    //
    // Add the recipient job to the recipient list at the parent job
    //
    lpRecipientPtr=(PJOB_QUEUE_PTR)MemAlloc(sizeof(JOB_QUEUE_PTR));
    if (!lpRecipientPtr)
    {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate memory for recipeint JOB_QUEUE_PTR structure. (ec: %ld)"),rc);
        LeaveCriticalSection(&g_CsQueue);
        goto Error;
    }
    lpRecipientPtr->lpJob=lpJobQEntry;
    InsertTailList(&lpParentJob->RecipientJobs,&(lpRecipientPtr->ListEntry));
    lpParentJob->dwRecipientJobsCount++;

    SafeIncIdleCounter(&g_dwQueueCount);
    SetFaxJobNumberRegistry( g_dwNextJobId );
    IncreaseJobRefCount (lpJobQEntry);
    Assert (lpJobQEntry->RefCount == 1);

    LeaveCriticalSection( &g_CsQueue );

    DebugPrintEx(DEBUG_MSG,TEXT("Added Recipient Job %d to Parent Job %d"), lpJobQEntry->JobId,lpJobQEntry->lpParentJob->JobId );


    Assert(ERROR_SUCCESS == rc);
    SetLastError(ERROR_SUCCESS);

    return lpJobQEntry;

Error:
    Assert(ERROR_SUCCESS != rc);
    if (lpJobQEntry)
    {
        FreeRecipientQueueEntry(lpJobQEntry,TRUE);
    }
    SetLastError(rc);
    return NULL;
}


#if DBG


//*********************************************************************************
//* Name:   DumpRecipientJob()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Dumps the content of a recipient job.
//* PARAMETERS:
//*     [IN]    const PJOB_QUEUE lpcRecipJob
//*         The recipient job to dump.
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void DumpRecipientJob(const PJOB_QUEUE lpcRecipJob)
{
    TCHAR szTime[256] = {0};
    Assert(lpcRecipJob);
    Assert(JT_SEND == lpcRecipJob->JobType);

    DebugDateTime(lpcRecipJob->ScheduleTime,szTime);
    DebugPrint((TEXT("\t*******************")));
    DebugPrint((TEXT("\tRecipient Job: %d"),lpcRecipJob->JobId));
    DebugPrint((TEXT("\t*******************")));
    DebugPrint((TEXT("\tUniqueId: 0x%016I64X"),lpcRecipJob->UniqueId));
    DebugPrint((TEXT("\tQueueFileName: %s"),lpcRecipJob->QueueFileName));
    DebugPrint((TEXT("\tParent Job Id: %d"),lpcRecipJob->lpParentJob->JobId));
    DebugPrint((TEXT("\tSchedule: %s"),szTime));
    DebugPrint((TEXT("\tRecipient Name: %s"),lpcRecipJob->RecipientProfile.lptstrName));
    DebugPrint((TEXT("\tRecipient Number: %s"),lpcRecipJob->RecipientProfile.lptstrFaxNumber));
    DebugPrint((TEXT("\tSend Retries: %d"),lpcRecipJob->SendRetries));
    DebugPrint((TEXT("\tJob Status: %d"),lpcRecipJob->JobStatus));
    DebugPrint((TEXT("\tRecipient Count: %d"),lpcRecipJob->JobStatus));
}
#endif

DWORD
GetMergedFileSize(
    LPCWSTR                         lpcwstrBodyFile,
    DWORD                           dwPageCount,
    LPCFAX_COVERPAGE_INFO_EX        lpcCoverPageInfo,
    LPCFAX_PERSONAL_PROFILEW        lpcSenderProfile,
    LPCFAX_PERSONAL_PROFILEW        lpcRecipientProfile
    )
{
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwFileSize = 0;
    DWORD dwBodyFileSize = 0;
    short Resolution = 0; // Default resolution
    WCHAR szCoverPageTiffFile[MAX_PATH] = {0};
    BOOL  bDeleteFile = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("GetMergedFileSize"));

    Assert (dwPageCount && lpcCoverPageInfo && lpcSenderProfile && lpcRecipientProfile);

    if (lpcwstrBodyFile)
    {
        if (!GetBodyTiffResolution(lpcwstrBodyFile, &Resolution))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetBodyTiffResolution() failed (ec: %ld)."),
                dwRes);
            goto exit;
        }
    }

    Assert (Resolution == 0 || Resolution == 98 || Resolution == 196);

    //
    // First create the cover page (This generates a file and returns its name).
    //
    if (!CreateCoverpageTiffFileEx(
                              Resolution,
                              dwPageCount,
                              lpcCoverPageInfo,
                              lpcRecipientProfile,
                              lpcSenderProfile,
                              TEXT("tmp"),
                              szCoverPageTiffFile))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateCoverpageTiffFileEx failed to render cover page template %s (ec : %ld)"),
                     lpcCoverPageInfo->lptstrCoverPageFileName,
                     dwRes);
        goto exit;
    }
    bDeleteFile = TRUE;

    if (0 == (dwFileSize = MyGetFileSize (szCoverPageTiffFile)))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("MyGetFileSize Failed (ec: %ld)"),
                     dwRes);
        goto exit;
    }

    if (lpcwstrBodyFile)
    {
        //
        // There is a body file specified so get its file size.
        //
        if (0 == (dwBodyFileSize = MyGetFileSize(lpcwstrBodyFile)))
        {
            dwRes = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("MyGetFileSize Failed (ec: %ld)"),
                         dwRes);
            goto exit;
        }
    }

    dwFileSize += dwBodyFileSize;
    Assert (dwFileSize);

exit:
    if (TRUE == bDeleteFile)
    {
        //
        // Get rid of the coverpage TIFF we generated.
        //
        if (!DeleteFile(szCoverPageTiffFile))
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT(" Failed to delete cover page TIFF file %ws. (ec: %ld)"),
                     szCoverPageTiffFile,
                     GetLastError());
        }
    }

    if (0 == dwFileSize)
    {
        Assert (ERROR_SUCCESS != dwRes);
        SetLastError(dwRes);
    }
    return dwFileSize;
}


//*********************************************************************************
//*                         Parent Job Functions
//*********************************************************************************

//*********************************************************************************
//* Name:   AddParentJob()
//* Author: Ronen Barenboim
//* Date:   March 18, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Adds a parent job (with no recipients) to the queue.
//*     After calling this function recipient should be added using
//*     AddRecipientJob()
//* PARAMETERS:
//*     lpcQueueHead
//*
//*     lpcwstrBodyFile
//*
//*     lpcSenderProfile
//*
//*     lpcJobParams
//*
//*     lpcCoverPageInfo
//*
//*     lpcwstrUserName
//*
//*     lpUserSid
//*
//*
//*     lpcRecipientProfile
//*
//* RETURN VALUE:
//*     A pointer to the added parent job. If the function fails it returns a NULL
//*     pointer.
//*********************************************************************************
PJOB_QUEUE AddParentJob(
             IN const PLIST_ENTRY lpcQueueHead,
             IN LPCWSTR lpcwstrBodyFile,
             IN LPCFAX_PERSONAL_PROFILE lpcSenderProfile,
             IN LPCFAX_JOB_PARAM_EXW  lpcJobParams,
             IN LPCFAX_COVERPAGE_INFO_EX  lpcCoverPageInfo,
             IN LPCWSTR lpcwstrUserName,
             IN PSID lpUserSid,
             IN LPCFAX_PERSONAL_PROFILEW lpcRecipientProfile,
             IN BOOL bCreateQueueFile
             )
{

    PJOB_QUEUE lpJobQEntry;
    WCHAR QueueFileName[MAX_PATH];
    HANDLE hTiff;
    TIFF_INFO TiffInfo;
    DWORD rc = ERROR_SUCCESS;
    DWORD Size = sizeof(JOB_QUEUE);
    DWORD dwSidSize = 0;
    DEBUG_FUNCTION_NAME(TEXT("AddParentJob"));

    Assert(lpcQueueHead);
    Assert(lpcSenderProfile);
    Assert(lpcJobParams);
    Assert(lpcwstrUserName);


    lpJobQEntry = new JOB_QUEUE;
    if (!lpJobQEntry) {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate memory for JOB_QUEUE structure. (ec: %ld)"),GetLastError());
        goto Error;
    }

    ZeroMemory( lpJobQEntry, Size );
    // The list heads must be initialized before any chance of error may occure. Otherwise
    // the cleanup code (which traverses these lists is undefined).
    InitializeListHead( &lpJobQEntry->FaxRouteFiles );
    InitializeListHead( &lpJobQEntry->RoutingDataOverride );
    InitializeListHead( &lpJobQEntry->RecipientJobs );

    if (!lpJobQEntry->CsRoutingDataOverride.Initialize() ||
        !lpJobQEntry->CsFileList.Initialize())
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxCriticalSection::Initialize failed. (ec: %ld)"),
            rc);
        goto Error;
    }

    lpJobQEntry->JobId                     = InterlockedIncrement( (PLONG)&g_dwNextJobId );
    lpJobQEntry->FileName                  = StringDup( lpcwstrBodyFile);
    if (lpcwstrBodyFile && !lpJobQEntry->FileName) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup( lpcwstrBodyFile) failed (ec: %ld)"),
            rc=GetLastError());
        goto Error;
    }

    lpJobQEntry->JobType                   = JT_BROADCAST;
    lpJobQEntry->UserName                  = StringDup( lpcwstrUserName );
    if (lpcwstrUserName  && !lpJobQEntry->UserName) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup( lpcwstrUserName ) failed (ec: %ld)"),
            rc=GetLastError());
        goto Error;
    }

    Assert(lpUserSid);
    if (!IsValidSid(lpUserSid))
    {
         rc = ERROR_INVALID_DATA;
         DebugPrintEx(
            DEBUG_ERR,
            TEXT("Not a valid SID"));
        goto Error;
    }
    dwSidSize = GetLengthSid(lpUserSid);

    lpJobQEntry->UserSid = (PSID)MemAlloc(dwSidSize);
    if (lpJobQEntry->UserSid == NULL)
    {
         rc = ERROR_NOT_ENOUGH_MEMORY;
         DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate SID buffer"));
        goto Error;

    }
    if (!CopySid(dwSidSize, lpJobQEntry->UserSid, lpUserSid))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CopySid Failed, Error : %ld"),
            rc = GetLastError()
            );
        goto Error;
    }


    if (!CopyJobParamEx( &lpJobQEntry->JobParamsEx,lpcJobParams)) {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("CopyJobParamEx failed. (ec: 0x%0X)"),GetLastError());
        goto Error;
    }
    lpJobQEntry->JobStatus                 = JS_PENDING;

    // Copy the sender profile
    if (!CopyPersonalProfile(&(lpJobQEntry->SenderProfile),lpcSenderProfile)) {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy the sender personal profile (ec: 0x%0X)"),GetLastError());
        goto Error;
    }

    // Copy the cover page info
    if (!CopyCoverPageInfoEx(&(lpJobQEntry->CoverPageEx),lpcCoverPageInfo)) {
        rc=GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy the cover page information (ec: 0x%0X)"),GetLastError());
        goto Error;
    }



    //
    // get the page count
    //
    if (lpcwstrBodyFile)
    {
        hTiff = TiffOpen( (LPWSTR) lpcwstrBodyFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
        if (hTiff)
        {
            lpJobQEntry->PageCount = TiffInfo.PageCount;
            TiffClose( hTiff );
        }
        else
        {
            rc=GetLastError();
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to open body file to get page count (ec: 0x%0X)"), rc);
            goto Error;
        }
    }
    if( lpJobQEntry->JobParamsEx.dwPageCount )
    {
        // user specifically asked to use JobParamsEx.dwPageCount in the job
        lpJobQEntry->PageCount = lpJobQEntry->JobParamsEx.dwPageCount;
    }

    //
    // Cover page counts as an extra page
    //
    if (lpcCoverPageInfo && lpcCoverPageInfo->lptstrCoverPageFileName) {
        lpJobQEntry->PageCount++;
    }

    //
    // Get the file size
    //
    if (NULL == lpcRecipientProfile)
    {
        //
        // We restore the job queue - the file size will be stored by RestoreParentJob()
        //
    }
    else
    {
        //
        // This is a new parent job
        //
        if (NULL == lpcCoverPageInfo->lptstrCoverPageFileName)
        {
            Assert (lpcwstrBodyFile);
            //
            // No coverpage - the file size is the body file size only
            //
            if (0 == (lpJobQEntry->FileSize = MyGetFileSize(lpcwstrBodyFile)))
            {
                rc = GetLastError();
                DebugPrintEx(DEBUG_ERR,
                             TEXT("MyGetFileSize Failed (ec: %ld)"),
                             rc);
                goto Error;
            }
        }
        else
        {
            lpJobQEntry->FileSize = GetMergedFileSize (lpcwstrBodyFile,
                                                       lpJobQEntry->PageCount,
                                                       lpcCoverPageInfo,
                                                       lpcSenderProfile,
                                                       lpcRecipientProfile
                                                       );
            if (0 == lpJobQEntry->FileSize)
            {
                rc = GetLastError();
                DebugPrintEx(DEBUG_ERR,
                             TEXT("GetMergedFileSize failed (ec: %ld)"),
                             rc);
                goto Error;
            }
        }
    }

    lpJobQEntry->DeliveryReportProfile = NULL;

    GetSystemTimeAsFileTime( (LPFILETIME)&lpJobQEntry->SubmissionTime);
    if (lpcJobParams->dwScheduleAction == JSA_SPECIFIC_TIME)
    {
        if (!SystemTimeToFileTime( &lpJobQEntry->JobParamsEx.tmSchedule, (FILETIME*) &lpJobQEntry->ScheduleTime)) {
            rc=GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SystemTimeToFileTime failed. (ec: %ld)"),
                rc);
        }
    }
    else if (lpcJobParams->dwScheduleAction == JSA_DISCOUNT_PERIOD)
        {
            SYSTEMTIME CurrentTime;
            GetSystemTime( &CurrentTime ); // Can not fail (see Win32 SDK)
            // find a time within the discount period to execute this job.
            if (!SetDiscountTime( &CurrentTime )) {
                rc=GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SetDiscountTime failed. (ec: %ld)"),
                    rc);
                goto Error;
            }

            if (!SystemTimeToFileTime( &CurrentTime, (LPFILETIME)&lpJobQEntry->ScheduleTime )){
                rc=GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SystemTimeToFileTime failed. (ec: %ld)"),
                    rc);
                goto Error;
            }
        }
        else
        {
            Assert (lpcJobParams->dwScheduleAction == JSA_NOW);
            lpJobQEntry->ScheduleTime = lpJobQEntry->SubmissionTime;
        }

    lpJobQEntry->OriginalScheduleTime = lpJobQEntry->ScheduleTime;

    EnterCriticalSection( &g_CsQueue );

    if (bCreateQueueFile) {
        // JOB_QUEUE::UniqueId holds the generated unique file name as 64 bit value.
        // composed as MAKELONGLONG( MAKELONG( FatDate, FatTime ), i ).
        lpJobQEntry->UniqueId = GenerateUniqueQueueFile(JT_BROADCAST, QueueFileName, sizeof(QueueFileName)/sizeof(WCHAR) );
        if (0==lpJobQEntry->UniqueId) {
            rc=GetLastError();
            // Failed to generate unique id
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to generate unique id for FQP file (ec: 0x%0X)"),GetLastError());
            LeaveCriticalSection( &g_CsQueue );
            goto Error;
        }
        lpJobQEntry->QueueFileName = StringDup( QueueFileName );
        if (!lpJobQEntry->QueueFileName) {
            rc=GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StringDup( QueueFileName ) failed (ec: %ld)"),
                GetLastError());
            LeaveCriticalSection( &g_CsQueue );
            goto Error;
        }

        if (!CommitQueueEntry( lpJobQEntry)) {
            rc=GetLastError();
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to commit job queue entry to file %s (ec: %ld)"),QueueFileName,GetLastError());
            LeaveCriticalSection( &g_CsQueue );
            goto Error;
        }
    }

     //Add the parent job to the tail of the queue
    InsertTailList( lpcQueueHead, &(lpJobQEntry->ListEntry) )
    SafeIncIdleCounter (&g_dwQueueCount);
    SetFaxJobNumberRegistry( g_dwNextJobId );

    LeaveCriticalSection( &g_CsQueue );

    DebugPrintEx(DEBUG_MSG,TEXT("Added Job with Id: %d"), lpJobQEntry->JobId );

    Assert (ERROR_SUCCESS == rc);
    return lpJobQEntry;

Error:
    Assert(ERROR_SUCCESS != rc);
    if (lpJobQEntry)
    {
        FreeParentQueueEntry(lpJobQEntry,TRUE);
    }
    SetLastError(rc);
    return NULL;
}



//*********************************************************************************
//* Name:   FreeParentQueueEntry()
//* Author: Ronen Barenboim
//* Date:   18-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the memory taken by the members of a JOB_QUEUE structure of type
//*     JT_BROADCAST.
//*     If requested frees the structure as well.
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE lpJobQueue
//*         The JOB_QUEUE structure whose fields memeory is to be freed.
//*     [IN]    BOOL bDestroy
//*         If TRUE the structure itself will be freed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void FreeParentQueueEntry(PJOB_QUEUE lpJobQueue,BOOL bDestroy)
{
    DEBUG_FUNCTION_NAME(TEXT("FreeParentQueueEntry"));
    Assert(lpJobQueue);
    Assert(JT_BROADCAST == lpJobQueue->JobType);

    // No need to check NULL pointers since free() ignores them.
    MemFree( (LPBYTE) lpJobQueue->FileName );
    MemFree( (LPBYTE) lpJobQueue->UserName );
    MemFree( (LPBYTE) lpJobQueue->UserSid  );
    MemFree( (LPBYTE) lpJobQueue->QueueFileName );
    FreeJobParamEx(&lpJobQueue->JobParamsEx,FALSE); // do not destroy
    FreePersonalProfile(&lpJobQueue->SenderProfile,FALSE);
    FreeCoverPageInfoEx(&lpJobQueue->CoverPageEx,FALSE);
    //
    // Free the recipient reference list
    //

    while ((ULONG_PTR)lpJobQueue->RecipientJobs.Flink!=(ULONG_PTR)&lpJobQueue->RecipientJobs.Flink) {

          PJOB_QUEUE_PTR lpJobQueuePtr;

          lpJobQueuePtr = CONTAINING_RECORD( lpJobQueue->RecipientJobs.Flink, JOB_QUEUE_PTR, ListEntry );
          RemoveEntryList( &lpJobQueuePtr->ListEntry); // removes it from the list but does not deallocate its memory
          MemFree(lpJobQueuePtr); // free the memory occupied by the job reference
          lpJobQueue->dwRecipientJobsCount--;
    }
    Assert(lpJobQueue->dwRecipientJobsCount==0);

    if (bDestroy) {
        delete lpJobQueue;
    }

}

//*********************************************************************************
//* Name:   FreeRecipientQueueEntry()
//* Author: Oded Sacher
//* Date:   25-Dec- 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the memory taken by the members of a JOB_QUEUE structure of type
//*     JT_RECIPIENT.
//*     If requested frees the structure as well.
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE lpJobQueue
//*         The JOB_QUEUE structure whose fields memeory is to be freed.
//*     [IN]    BOOL bDestroy
//*         If TRUE the structure itself will be freed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void FreeRecipientQueueEntry(PJOB_QUEUE lpJobQueue,BOOL bDestroy)
{
    DEBUG_FUNCTION_NAME(TEXT("FreeRecipientQueueEntry"));

    DebugPrintEx(DEBUG_MSG,TEXT("Freeing lpJobQueue.JobParams...") );
    FreeJobParamEx(&lpJobQueue->JobParamsEx,FALSE);
    DebugPrintEx(DEBUG_MSG,TEXT("Freeing SenderProfile...") );
    FreePersonalProfile(&lpJobQueue->SenderProfile,FALSE);
    DebugPrintEx(DEBUG_MSG,TEXT("Freeing RecipientProfile...") );
    FreePersonalProfile(&lpJobQueue->RecipientProfile,FALSE);

    MemFree( (LPBYTE) lpJobQueue->FileName );
    MemFree( (LPBYTE) lpJobQueue->UserName );
    MemFree( (LPBYTE) lpJobQueue->QueueFileName );
    MemFree( (LPBYTE) lpJobQueue->PreviewFileName );
    //
    // Free the EFSP Permanent id
    //
    if (!FreePermanentMessageId(&lpJobQueue->EFSPPermanentMessageId, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[Job: %ld] FreePermanentMessageId() failed (ec: %ld)"),
            lpJobQueue->JobId,
            GetLastError());
    }

    if (bDestroy)
    {
        delete lpJobQueue;
    }

}

#if DBG

//*********************************************************************************
//* Name:   DumpParentJob()
//* Author: Ronen Barenboim
//* Date:   18-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Dumps a parent job and its recipients.
//* PARAMETERS:
//*     [IN]    const PJOB_QUEUE lpcParentJob
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void DumpParentJob(const PJOB_QUEUE lpcParentJob)
{
   PLIST_ENTRY lpNext;
   PJOB_QUEUE_PTR lpRecipientJobPtr;
   PJOB_QUEUE lpRecipientJob;

   Assert(lpcParentJob);
   Assert(JT_BROADCAST == lpcParentJob->JobType );

   DebugPrint((TEXT("===============================")));
   DebugPrint((TEXT("=====  Parent Job: %d"),lpcParentJob->JobId));
   DebugPrint((TEXT("===============================")));
   DebugPrint((TEXT("JobParamsEx")));
   DumpJobParamsEx(&lpcParentJob->JobParamsEx);
   DebugPrint((TEXT("CoverPageEx")));
   DumpCoverPageEx(&lpcParentJob->CoverPageEx);
   DebugPrint((TEXT("UserName: %s"),lpcParentJob->UserName));
   DebugPrint((TEXT("FileSize: %ld"),lpcParentJob->FileSize));
   DebugPrint((TEXT("PageCount: %ld"),lpcParentJob->PageCount));
   DebugPrint((TEXT("UniqueId: 0x%016I64X"),lpcParentJob->UniqueId));
   DebugPrint((TEXT("QueueFileName: %s"),lpcParentJob->QueueFileName));

   DebugPrint((TEXT("Recipient Count: %ld"),lpcParentJob->dwRecipientJobsCount));
   DebugPrint((TEXT("Completed Recipients: %ld"),lpcParentJob->dwCompletedRecipientJobsCount));
   DebugPrint((TEXT("Canceled Recipients: %ld"),lpcParentJob->dwCanceledRecipientJobsCount));
   DebugPrint((TEXT("Recipient List: ")));



   lpNext = lpcParentJob->RecipientJobs.Flink;
   if ((ULONG_PTR)lpNext == (ULONG_PTR)&lpcParentJob->RecipientJobs) {
        DebugPrint(( TEXT("No recipients.") ));
   } else {
        while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpcParentJob->RecipientJobs) {
            lpRecipientJobPtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
            lpRecipientJob=lpRecipientJobPtr->lpJob;
            DumpRecipientJob(lpRecipientJob);
            lpNext = lpRecipientJobPtr->ListEntry.Flink;
        }
   }

}
#endif

//*********************************************************************************
//*                         Receive Job Functions
//*********************************************************************************

//*********************************************************************************
//* Name:   AddReceiveJobQueueEntry()
//* Author: Ronen Barenboim
//* Date:   12-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*     [IN]    LPCTSTR FileName
//*         The full path to the file into which the receive document will
//*         be placed.
//*     [IN]    IN PJOB_ENTRY JobEntry
//*         The run time job entry for the receive job (generated with StartJob())
//*
//*     [IN]    IN DWORD JobType // can be JT_RECEIVE or JT_ROUTING
//*         The type of the receive job.
//*
//*     [IN]    IN DWORDLONG dwlUniqueJobID The jon unique ID
//*
//* RETURN VALUE:
//*
//*********************************************************************************
PJOB_QUEUE
AddReceiveJobQueueEntry(
    IN LPCTSTR FileName,
    IN PJOB_ENTRY JobEntry,
    IN DWORD JobType, // can be JT_RECEIVE or JT_ROUTING
    IN DWORDLONG dwlUniqueJobID
    )
{

    PJOB_QUEUE JobQueue;
    DWORD rc = ERROR_SUCCESS;
    DWORD Size = sizeof(JOB_QUEUE);
    DEBUG_FUNCTION_NAME(TEXT("AddReceiveJobQueueEntry"));

    Assert(FileName);
    Assert(JT_RECEIVE == JobType ||
           JT_ROUTING == JobType);

    LPTSTR TempFileName = _tcsrchr( FileName, '\\' ) + 1;

    JobQueue = new JOB_QUEUE;
    if (!JobQueue)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate memory for JOB_QUEUE structure. (ec: %ld)"),GetLastError());
        rc = ERROR_OUTOFMEMORY;
        goto Error;
    }

    ZeroMemory( JobQueue, Size );

    if (!JobQueue->CsFileList.Initialize() ||
        !JobQueue->CsRoutingDataOverride.Initialize() ||
        !JobQueue->CsPreview.Initialize())
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxCriticalSection::Initialize failed. (ec: %ld)"),
            rc);
        goto Error;
    }

    JobQueue->UniqueId = dwlUniqueJobID;
    JobQueue->FileName                  = StringDup( FileName );
    if ( FileName && !JobQueue->FileName )
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup( FileName ) failed. (ec: %ld)"),
            rc);
        goto Error;
    }

    JobQueue->JobId                     = InterlockedIncrement( (PLONG)&g_dwNextJobId );
    JobQueue->JobType                   = JobType;
    // In case of receive the JOB_QUEUE.UserName is the fax service name.
    JobQueue->UserName                  = StringDup( GetString( IDS_SERVICE_NAME ) );
    if (!JobQueue->UserName)
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup failed (ec: %ld)"),
            rc);
        goto Error;
    }

    if (JobType == JT_RECEIVE)
    {
        JobQueue->JobStatus              = JS_INPROGRESS;
    }
    else
    {
        // JT_ROUTING
        JobQueue->JobStatus              = JS_RETRYING;
    }


    JobQueue->JobEntry                  = JobEntry;
    JobQueue->JobParamsEx.dwScheduleAction = JSA_NOW;        // For the queue sort
    JobQueue->JobParamsEx.Priority = FAX_PRIORITY_TYPE_HIGH; // For the queue sort - Routing jobs do not use devices.
                                                             // Give them the highest priority

    // In case of receive the JOB_QUEUE.DocumentName is the temporary receive file name.
    JobQueue->JobParamsEx.lptstrDocumentName    = StringDup( TempFileName );
    if (!JobQueue->JobParamsEx.lptstrDocumentName && TempFileName)
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup failed (ec: %ld)"),
            rc);
            goto Error;
    }

    // link the running job back to the queued job unless it is
    // a routing job which does not have a running job entry.
    if (JobType == JT_RECEIVE)
    {
        Assert(JobQueue->JobEntry);
        JobQueue->JobEntry->lpJobQueueEntry = JobQueue;
    }

    InitializeListHead( &JobQueue->FaxRouteFiles );
    InitializeListHead( &JobQueue->RoutingDataOverride );

    SafeIncIdleCounter (&g_dwQueueCount);
    //
    // Don't persist to queue file
    //
    IncreaseJobRefCount (JobQueue);
    Assert (JobQueue->RefCount == 1);

    Assert (ERROR_SUCCESS == rc);

    EnterCriticalSection( &g_CsQueue );
    SetFaxJobNumberRegistry( g_dwNextJobId );
    // Add the new job to the queue.
    InsertHeadList( &g_QueueListHead, &JobQueue->ListEntry );
    LeaveCriticalSection( &g_CsQueue );
    return JobQueue;

Error:
    Assert (ERROR_SUCCESS != rc);

    if (NULL != JobQueue)
    {
        FreeReceiveQueueEntry(JobQueue, TRUE);
    }
    SetLastError (rc);
    return NULL;
}


//*********************************************************************************
//* Name:   FreeReceiveQueueEntry()
//* Author: Ronen Barenboim
//* Date:   12-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the memory occupied by the feilds of a
//*     JT_RECEIVE/JT_FAIL_RECEIVE/JT_ROUTING JOB_QUEUE structure.
//*     Fress the entire structure if required.
//*     DOES NOT FREE any other resource (files, handles, etc.)
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE lpJobQueue
//*         The structure to free.
//*     [IN]    BOOL bDestroy
//*         TRUE if the structure itself need to be freed.
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void FreeReceiveQueueEntry(
    PJOB_QUEUE lpJobQueue,
    BOOL bDestroy
    )

{
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    PROUTING_DATA_OVERRIDE  RoutingDataOverride;
    DWORD i;

    DEBUG_FUNCTION_NAME(TEXT("FreeReceiveQueueEntry"));
    Assert(lpJobQueue);


    DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue.JobParams...") );
    FreeJobParamEx(&lpJobQueue->JobParamsEx,FALSE);
    MemFree( (LPBYTE) lpJobQueue->FileName );
    MemFree( (LPBYTE) lpJobQueue->UserName );
    MemFree( (LPBYTE) lpJobQueue->QueueFileName );
    MemFree( (LPBYTE) lpJobQueue->PreviewFileName );

    if (lpJobQueue->FaxRoute) {
        PFAX_ROUTE FaxRoute = lpJobQueue->FaxRoute;
        DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue.FaxRoute...") );
        MemFree( (LPBYTE) FaxRoute->Csid );
        MemFree( (LPBYTE) FaxRoute->Tsid );
        MemFree( (LPBYTE) FaxRoute->CallerId );
        MemFree( (LPBYTE) FaxRoute->ReceiverName );
        MemFree( (LPBYTE) FaxRoute->ReceiverNumber );
        MemFree( (LPBYTE) FaxRoute->RoutingInfo );
    MemFree( (LPBYTE) FaxRoute->DeviceName );
        MemFree( (LPBYTE) FaxRoute->RoutingInfoData );
        MemFree( (LPBYTE) FaxRoute );
    }

    //
    // walk the file list and remove any files
    //

    DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue.FaxRouteFiles...") );
    Next = lpJobQueue->FaxRouteFiles.Flink;
    if (Next != NULL) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&lpJobQueue->FaxRouteFiles) {
            FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
            Next = FaxRouteFile->ListEntry.Flink;
            MemFree( FaxRouteFile->FileName );
            MemFree( FaxRouteFile );
        }
    }

    //
    // walk the routing data override list and free all memory
    //
    DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue.RoutingDataOverride...") );
    Next = lpJobQueue->RoutingDataOverride.Flink;
    if (Next != NULL) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&lpJobQueue->RoutingDataOverride) {
            RoutingDataOverride = CONTAINING_RECORD( Next, ROUTING_DATA_OVERRIDE, ListEntry );
            Next = RoutingDataOverride->ListEntry.Flink;
            MemFree( RoutingDataOverride->RoutingData );
            MemFree( RoutingDataOverride );
        }
    }

    //
    // free any routing failure data
    //
    for (i =0; i<lpJobQueue->CountFailureInfo; i++)
    {
        DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue.RouteFailureInfo...") );
        if ( lpJobQueue->pRouteFailureInfo[i].FailureData )
        {
            MemFree(lpJobQueue->pRouteFailureInfo[i].FailureData);
        }
    }
    MemFree (lpJobQueue->pRouteFailureInfo);

    if (bDestroy) {
            DebugPrintEx(DEBUG_MSG, TEXT("Freeing JobQueue") );
            delete lpJobQueue;
    }



}

#if DBG
//*********************************************************************************
//* Name:   DumpReceiveJob()
//* Author: Ronen Barenboim
//* Date:   14-Apt-99
//*********************************************************************************
//* DESCRIPTION:
//*     Debug dumps a receive job.
//* PARAMETERS:
//*     [IN]    const PJOB_QUEUE lpcJob
//*         The receive job to dump.
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void DumpReceiveJob(const PJOB_QUEUE lpcJob)
{
    TCHAR szTime[256] = {0};

    Assert(lpcJob);
    Assert( (JT_RECEIVE == lpcJob->JobType) );

    DebugDateTime(lpcJob->ScheduleTime,szTime);
    DebugPrint((TEXT("===============================")));
    if (JT_RECEIVE == lpcJob->JobType) {
        DebugPrint((TEXT("=====  Receive Job: %d"),lpcJob->JobId));
    } else {
        DebugPrint((TEXT("=====  Fail Receive Job: %d"),lpcJob->JobId));
    }
    DebugPrint((TEXT("===============================")));
    DebugPrint((TEXT("UserName: %s"),lpcJob->UserName));
    DebugPrint((TEXT("UniqueId: 0x%016I64X"),lpcJob->UniqueId));
    DebugPrint((TEXT("QueueFileName: %s"),lpcJob->QueueFileName));
    DebugPrint((TEXT("Schedule: %s"),szTime));
    DebugPrint((TEXT("Status: %ld"),lpcJob->JobStatus));
    if (lpcJob->JobEntry)
    {
        DebugPrint((TEXT("FSP Queue Status: 0x%08X"), lpcJob->JobEntry->FSPIJobStatus.dwJobStatus));
        DebugPrint((TEXT("FSP Extended Status: 0x%08X"), lpcJob->JobEntry->FSPIJobStatus.dwExtendedStatus));
    }
}
#endif

//*********************************************************************************
//*                 Client API Structures Management
//*********************************************************************************


//*********************************************************************************
//* Name:   FreeJobParamEx()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the members of a FAX_JOB_PARAM_EXW structure and can be instructed
//*     to free the structure itself.
//* PARAMETERS:
//*     [IN]    PFAX_JOB_PARAM_EXW lpJobParamEx
//*         A pointer to the structure to free.
//*
//*     [IN]    BOOL bDestroy
//*         TRUE if the structure itself need to be freed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void FreeJobParamEx(
        IN PFAX_JOB_PARAM_EXW lpJobParamEx,
        IN BOOL bDestroy
    )
{
    Assert(lpJobParamEx);
    MemFree(lpJobParamEx->lptstrReceiptDeliveryAddress);
    MemFree(lpJobParamEx->lptstrDocumentName);
    if (bDestroy) {
        MemFree(lpJobParamEx);
    }

}

//*********************************************************************************
//* Name:   CopyJobParamEx()
//* Author: Ronen Barenboim
//* Date:   18-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a duplicate of the specified FAX_JOB_PARAM_EXW structure into
//      an already allocated destination structure.
//* PARAMETERS:
//*     [OUT] PFAX_JOB_PARAM_EXW lpDst
//*         A pointer to the destination structure.
//*
//*     [IN]  LPCFAX_JOB_PARAM_EXW lpcSrc
//*         A pointer to the source structure.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL CopyJobParamEx(
    OUT PFAX_JOB_PARAM_EXW lpDst,
    IN LPCFAX_JOB_PARAM_EXW lpcSrc
    )
{
   STRING_PAIR pairs[] =
   {
        { lpcSrc->lptstrReceiptDeliveryAddress, &lpDst->lptstrReceiptDeliveryAddress},
        { lpcSrc->lptstrDocumentName, &lpDst->lptstrDocumentName},
   };
   int nRes;

   DEBUG_FUNCTION_NAME(TEXT("CopyJobParamEx"));

    Assert(lpDst);
    Assert(lpcSrc);

    memcpy(lpDst,lpcSrc,sizeof(FAX_JOB_PARAM_EXW));
    nRes=MultiStringDup(pairs, sizeof(pairs)/sizeof(STRING_PAIR));
    if (nRes!=0) {
        // MultiStringDup takes care of freeing the memory for the pairs for which the copy succeeded
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy string with index %d"),nRes-1);
        return FALSE;
    }
    return TRUE;

}


//*********************************************************************************
//* Name:   CopyCoverPageInfoEx()
//* Author: Ronen Barenboim
//* Date:   14-Apr-99
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a duplicate of the specified FAX_COVERPAGE_INFO_EXW structure into
//      an already allocated destination structure.
//* PARAMETERS:
//*     [OUT] PFAX_COVERPAGE_INFO_EXW lpDst
//*         A pointer to the destination structure.
//*
//*     [IN]  LPCFAX_COVERPAGE_INFO_EXW lpcSrc
//*         A pointer to the source structure.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL CopyCoverPageInfoEx(
        OUT PFAX_COVERPAGE_INFO_EXW lpDst,
        IN LPCFAX_COVERPAGE_INFO_EXW lpcSrc
        )
{
   STRING_PAIR pairs[] =
   {
        { lpcSrc->lptstrCoverPageFileName, &lpDst->lptstrCoverPageFileName},
        { lpcSrc->lptstrNote, &lpDst->lptstrNote},
        { lpcSrc->lptstrSubject, &lpDst->lptstrSubject}
   };
   int nRes;

   DEBUG_FUNCTION_NAME(TEXT("CopyCoverPageInfoEx"));

    Assert(lpDst);
    Assert(lpcSrc);

    memcpy(lpDst,lpcSrc,sizeof(FAX_COVERPAGE_INFO_EXW));
    nRes=MultiStringDup(pairs, sizeof(pairs)/sizeof(STRING_PAIR));
    if (nRes!=0) {
        // MultiStringDup takes care of freeing the memory for the pairs for which the copy succeeded
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy string with index %d"),nRes-1);
        return FALSE;
    }
    return TRUE;
}


//*********************************************************************************
//* Name:   FreeCoverPageInfoEx()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the members of a FAX_COVERPAGE_INFO_EXW structure and can be instructed
//*     to free the structure itself.
//* PARAMETERS:
//*     [IN]    PFAX_COVERPAGE_INFO_EXW lpJobParamEx
//*         A pointer to the structure to free.
//*
//*     [IN]    BOOL bDestroy
//*         TRUE if the structure itself need to be freed.
//*
//* RETURN VALUE:
//*     NONE
//*********************************************************************************
void FreeCoverPageInfoEx(
        IN PFAX_COVERPAGE_INFO_EXW lpCoverpage,
        IN BOOL bDestroy
    )
{
    Assert(lpCoverpage);
    MemFree(lpCoverpage->lptstrCoverPageFileName);
    MemFree(lpCoverpage->lptstrNote);
    MemFree(lpCoverpage->lptstrSubject);
    if (bDestroy) {
        MemFree(lpCoverpage);
    }
}



//**************************************
//* Outboung Routing Stub
//**************************************





//*********************************************************************************
//* Name:   RemoveParentJob()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Removes a parent job from the queue. Can remove recipients as well.
//*     The caller can determine if a client notification (FEI event) will be
//*     generated for the removal.
//*     If the job reference count is not 0 - its status changes to JS_DELETING
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE lpJobToRemove
//*                 The job to be removed.
//*
//*     [IN]    BOOL bRemoveRecipients
//*                 TRUE if the recipients should be removed as well.
//*
//*     [IN]    BOOL bNotify
//*                 TRUE if a FEI_DELETED event should be generated/
//*
//* RETURN VALUE:
//*     TRUE
//*         The removal succeeded. The job is not in the queue.
//*         it might be that some job resources (files) were not removed.
//*     FALSE
//*         The removal failed. The job is still in the queue.
//*********************************************************************************
BOOL RemoveParentJob(
    PJOB_QUEUE lpJobToRemove,
    BOOL bRemoveRecipients,
    BOOL bNotify
    )
{
    PJOB_QUEUE lpJobQueue;
    DEBUG_FUNCTION_NAME(TEXT("RemoveParentJob"));

    Assert(lpJobToRemove);
    Assert(JT_BROADCAST ==lpJobToRemove->JobType);

    EnterCriticalSection( &g_CsQueue );
    //
    // Make sure it is still there. It might been deleted
    // by another thread by the time we get to execute.
    //
    lpJobQueue = FindJobQueueEntryByJobQueueEntry( lpJobToRemove );

    if (lpJobQueue == NULL) {
        DebugPrintEx(   DEBUG_WRN,
                        TEXT("Job %d (address: 0x%08X )was not found in job queue. No op."),
                        lpJobToRemove->JobId,
                        lpJobToRemove);
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    if (lpJobQueue->RefCount > 0)
    {
        DebugPrintEx(   DEBUG_WRN,
                        TEXT("Job %ld Ref count %ld - not removing."),
                        lpJobQueue->JobId,
                        lpJobQueue->RefCount);
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }


    if (lpJobQueue->PrevRefCount > 0)
    {
        // The job can not be removed
        // We should mark it as JS_DELETING.
        //
        // A user is using the job Tiff - Do not delete, Mark it as JS_DELETEING
        //
        lpJobQueue->JobStatus = JS_DELETING;
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    DebugPrintEx(DEBUG_MSG,TEXT("Removing parent job %ld"),lpJobQueue->JobId);

    //
    // No point in scheduling new jobs before we get rid of the recipients
    //
    if (!CancelWaitableTimer( g_hQueueTimer ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CancelWaitableTimer failed. (ec: %ld)"),
            GetLastError());
    }

    RemoveEntryList( &lpJobQueue->ListEntry );

    //
    // From this point we continue with the delete operation even if error occur since
    // the parent job is already out of the queue.
    //


    //
    // Remove all recipients
    //
    if (bRemoveRecipients) {
        DebugPrintEx(DEBUG_MSG,TEXT("[Job: %ld] Removing recipient jobs."),lpJobQueue->JobId);
        //
        // remove the recipients. send a delete notification for each recipient.
        //
        if (!RemoveParentRecipients(lpJobQueue, TRUE)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RemoveParentRecipients failed. (ec: %ld)"),
                GetLastError());
            Assert(FALSE);
        }
    }

    //
    // Get rid of the persistence file if any.
    //
    if (lpJobQueue->QueueFileName) {
        DebugPrintEx(DEBUG_MSG,TEXT("[Job: %ld] Deleting QueueFileName %s\n"), lpJobQueue->JobId, lpJobQueue->QueueFileName );
        if (!DeleteFile( lpJobQueue->QueueFileName )) {
           DebugPrintEx(DEBUG_ERR,TEXT("[Job: %ld] Failed to delete QueueFileName %s  (ec: %ld)\n"), lpJobQueue->JobId, lpJobQueue->QueueFileName,GetLastError() );
           Assert(FALSE);
        }
    }


    //
    // Get rid of the body file. Recipient jobs will get rid of body files that they
    // have created (for legacy FSPs).
    //
    if (lpJobQueue->FileName) {
        DebugPrintEx(DEBUG_MSG,TEXT("[Job: %ld] Deleting body file %s\n"), lpJobQueue->JobId, lpJobQueue->FileName);
        if (!DeleteFile(lpJobQueue->FileName)) {
            DebugPrintEx(DEBUG_ERR,TEXT("[Job: %ld] Failed to delete body file %s  (ec: %ld)\n"), lpJobQueue->JobId, lpJobQueue->FileName, GetLastError() );
            Assert(FALSE);
        }
    }

    //
    // Get rid of the cover page template file if it is not a server based
    // cover page.

    if (lpJobQueue->CoverPageEx.lptstrCoverPageFileName &&
        !lpJobQueue->CoverPageEx.bServerBased) {
            DebugPrintEx(DEBUG_MSG,TEXT("[Job: %ld] Deleting personal Cover page template file %s\n"), lpJobQueue->JobId, lpJobQueue->CoverPageEx.lptstrCoverPageFileName );
            if (!DeleteFile(lpJobQueue->CoverPageEx.lptstrCoverPageFileName)) {
                DebugPrintEx( DEBUG_ERR,
                              TEXT("[Job: %ld] Failed to delete personal Cover page template file %s  (ec: %ld)\n"), lpJobQueue->JobId,
                              lpJobQueue->CoverPageEx.lptstrCoverPageFileName,GetLastError() );
                Assert(FALSE);
            }
    }

    //
    // One less job in the queue (not counting recipient jobs)
    //
    SafeDecIdleCounter (&g_dwQueueCount);

    if (bNotify)
    {
        if (!CreateFaxEvent(0, FEI_DELETED, lpJobQueue->JobId))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFaxEvent failed. (ec: %ld)"),
                GetLastError());
        }
    }

    FreeParentQueueEntry(lpJobQueue,TRUE); // Free the memory occupied by the entry itself

    //
    // We are back in business. Time to figure out when to wake up JobQueueThread.
    //
    if (!StartJobQueueTimer())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartJobQueueTimer failed. (ec: %ld)"),
            GetLastError());
    }

    LeaveCriticalSection( &g_CsQueue );

    return TRUE;
}


//*********************************************************************************
//* Name:   RemoveParentRecipients()
//* Author: Ronen Barenboim
//* Date:   18-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Removes the recipient jobs that belong to a specific parent job.
//* PARAMETERS:
//*     [OUT]   PJOB_QUEUE lpParentJob
//*         The parent job whose recipients are to be removed.
//*     [IN]    IN BOOL bNotify
//*         TRUE if a FEI_DELETED notification should be generated for
//*         each recipient.
//*
//* RETURN VALUE:
//*     TRUE
//*         All the recipients were removed from the queue.
//*     FALSE
//*         None of the recipient was removed from the queue.
//*********************************************************************************
BOOL RemoveParentRecipients(
        OUT PJOB_QUEUE lpParentJob,
        IN BOOL bNotify
     )
{
    PLIST_ENTRY lpNext;
    PJOB_QUEUE_PTR lpJobQueuePtr;
    PJOB_QUEUE lpFoundRecpRef=NULL;

    DEBUG_FUNCTION_NAME(TEXT("RemoveParentRecipients"));

    Assert(lpParentJob);

    lpNext = lpParentJob->RecipientJobs.Flink;
    while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpParentJob->RecipientJobs) {
        lpJobQueuePtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        Assert(lpJobQueuePtr->lpJob);
        lpNext = lpJobQueuePtr->ListEntry.Flink;
        if (!RemoveRecipientJob(lpJobQueuePtr->lpJob,
                           bNotify,
                           FALSE // Do not recalc queue timer after each removal
                           ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RemoveRecipientJob failed for recipient: %ld (ec: %ld)"),
                lpJobQueuePtr->lpJob->JobId,
                GetLastError());
            Assert(FALSE); // Should never happen. If it does we just continue to remove the other recipients.
        }

    }
    return TRUE;

}


//*********************************************************************************
//* Name:   RemoveRecipientJob()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*
//* PARAMETERS:
//*     [IN]    PJOB_QUEUE lpJobToRemove
//*         The job to be removed.
//*     [IN]    BOOL bNotify
//*         TRUE if to generate a FEI_DELETED event after the removal.
//*     [IN]    BOOL bRecalcQueueTimer
//*         TRUE if the queue timer need to be recalculated (and enabled)
//*         after the removal.
//*         when many recipients jobs are removed this is not desired since
//*         an about to be removed recipient might be scheduled.
//*
//* RETURN VALUE:
//*     TRUE
//*         The function allways succeeds. The only errors that can occur
//*         are files which can not be deleted in this case the function just
//*         go on with the removal operation.
//*     FALSE
//*
//*********************************************************************************
BOOL RemoveRecipientJob(
        IN PJOB_QUEUE lpJobToRemove,
        IN BOOL bNotify,
        IN BOOL bRecalcQueueTimer)
{
    PJOB_QUEUE lpJobQueue;

    DEBUG_FUNCTION_NAME(TEXT("RemoveRecipientJob"));

    Assert(lpJobToRemove);

    Assert(JT_SEND == lpJobToRemove->JobType);

    Assert(lpJobToRemove->lpParentJob);
    DebugPrintEx( DEBUG_MSG,
                  TEXT("Starting remove of JobId: %ld"),lpJobToRemove->JobId);

    EnterCriticalSection( &g_CsQueue );
    //
    // Make sure it is still there. It might been deleted
    // by another thread by the time we get to execute.
    //
    lpJobQueue = FindJobQueueEntryByJobQueueEntry( lpJobToRemove );
    if (lpJobQueue == NULL) {
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    if (lpJobQueue->RefCount == 0)  {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[JobId :%ld] Reference count is zero. Deleting."),
            lpJobQueue->JobId);

        RemoveEntryList( &lpJobQueue->ListEntry );

        if (!CancelWaitableTimer( g_hQueueTimer )) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CancelWaitableTimer() failed. (ec: %ld)"),
                GetLastError());
        }

        if (bRecalcQueueTimer) {
            if (!StartJobQueueTimer()) {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StartJobQueueTimer() failed. (ec: %ld)"),
                    GetLastError());
            }
        }

        if (lpJobQueue->QueueFileName) {
            DebugPrintEx(   DEBUG_MSG,
                            TEXT("[Job: %ld] Deleting QueueFileName %s"),
                            lpJobQueue->JobId,
                            lpJobQueue->QueueFileName );
            if (!DeleteFile( lpJobQueue->QueueFileName )) {
                DebugPrintEx(   DEBUG_MSG,
                                TEXT("[Job: %ld] Failed to delete QueueFileName %s (ec: %ld)"),
                                lpJobQueue->JobId,
                                lpJobQueue->QueueFileName,
                                GetLastError());
            }
        }

        if (lpJobQueue->PreviewFileName) {
            DebugPrintEx(   DEBUG_MSG,
                            TEXT("[Job: %ld] Deleting PreviewFileName %s"),
                            lpJobQueue->JobId,
                            lpJobQueue->PreviewFileName );
            if (!DeleteFile( lpJobQueue->PreviewFileName )) {
                DebugPrintEx(   DEBUG_MSG,
                                TEXT("[Job: %ld] Failed to delete QueueFileName %s (ec: %ld)"),
                                lpJobQueue->JobId,
                                lpJobQueue->PreviewFileName,
                                GetLastError());
                Assert(FALSE);
            }
        }

        if (lpJobQueue->FileName) {
            DebugPrintEx(   DEBUG_MSG,
                            TEXT("[Job: %ld] Deleting per recipient body file %s"),
                            lpJobQueue->JobId,
                            lpJobQueue->FileName);
            if (!DeleteFile( lpJobQueue->FileName )) {
                DebugPrintEx(   DEBUG_MSG,
                                TEXT("[Job: %ld] Failed to delete per recipient body file %s (ec: %ld)"),
                                lpJobQueue->JobId,
                                lpJobQueue->FileName,
                                GetLastError());
                Assert(FALSE);
            }
        }

        SafeDecIdleCounter (&g_dwQueueCount);
        //
        // Now remove the reference to the job from its parent job
        //
        if (!RemoveParentRecipientRef(lpJobQueue->lpParentJob,lpJobQueue))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RemoveParentRecipientRef failed (Parent Id: %ld RecipientId: %ld)"),
                lpJobQueue->lpParentJob->JobId,
                lpJobQueue->JobId);
            Assert(FALSE);
        }

        if ( TRUE == bNotify)
        {
            //
            //  Crete FAX_EVENT_EX for each recipient job.
            //
            DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_REMOVED,
                                             lpJobToRemove
                                            );
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_RENOVED) failed for job id %ld (ec: %lc)"),
                    lpJobToRemove->UniqueId,
                    dwRes);
            }
        }

        FreeRecipientQueueEntry (lpJobQueue, TRUE);
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId :%ld] Reference count is %ld. NOT REMOVING"),
            lpJobQueue->JobId,
            lpJobQueue->RefCount);
        Assert(lpJobQueue->RefCount == 0); // Assert FALSE
    }
    LeaveCriticalSection( &g_CsQueue );
    return TRUE;

}


//*********************************************************************************
//* Name:   RemoveParentRecipientRef()
//* Author: Ronen Barenboim
//* Date:   ?? ????? 14 ????? 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Removes a reference entry from the list of recipient references
//      in a parent job.
//* PARAMETERS:
//*     [IN/OUT]    IN OUT PJOB_QUEUE lpParentJob
//*         The parent job.
//*     [IN]        IN const PJOB_QUEUE lpcRecpJob
//*         The recipient job whose reference is to be removed from the parent job.
//*
//* RETURN VALUE:
//*     TRUE
//*         If successful.
//*     FALSE
//*         otherwise.
//*********************************************************************************
BOOL RemoveParentRecipientRef(
    IN OUT PJOB_QUEUE lpParentJob,
    IN const PJOB_QUEUE lpcRecpJob
    )
{

    PJOB_QUEUE_PTR lpJobPtr;
    DEBUG_FUNCTION_NAME(TEXT("RemoveParentRecipientRef"));
    Assert(lpParentJob);
    Assert(lpcRecpJob);

    lpJobPtr=FindRecipientRefByJobId(lpParentJob,lpcRecpJob->JobId);
    if (!lpJobPtr) {
        DebugPrintEx(DEBUG_ERR,TEXT("Recipient job 0x%X not found in job 0x%X"),lpcRecpJob->JobId,lpParentJob->JobId);
        Assert(FALSE);
        return FALSE;
    }
    Assert(lpJobPtr->lpJob==lpcRecpJob);
    RemoveEntryList(&lpJobPtr->ListEntry); // does not free the struct memory !
    MemFree(lpJobPtr);
    lpParentJob->dwRecipientJobsCount--;
    return TRUE;
}


//*********************************************************************************
//* Name:   FindRecipientRefByJobId()
//* Author: Ronen Barenboim
//* Date:   18-Mar-99
//*********************************************************************************
//* DESCRIPTION:
//*     Returns a pointer to the refernce entry that holds the reference
//*     to the specified job.
//* PARAMETERS:
//*     [IN]        PJOB_QUEUE lpParentJob
//*         The parent job in which the recipient reference is to located.
//*     [IN]        DWORD dwJobId
//*         The job id of the job whose reference is to be located in the parent.
//*
//* RETURN VALUE:
//*
//*********************************************************************************
PJOB_QUEUE_PTR FindRecipientRefByJobId(
    PJOB_QUEUE lpParentJob,
    DWORD dwJobId
    )
{

    PLIST_ENTRY lpNext;
    PJOB_QUEUE_PTR lpJobQueuePtr;
    PJOB_QUEUE_PTR lpFoundRecpRef=NULL;
    Assert(lpParentJob);

    lpNext = lpParentJob->RecipientJobs.Flink;

    while ((ULONG_PTR)lpNext != (ULONG_PTR)lpParentJob) {
        lpJobQueuePtr = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
        Assert(lpJobQueuePtr->lpJob);
        if (lpJobQueuePtr->lpJob->JobId == dwJobId) {
            lpFoundRecpRef=lpJobQueuePtr;
            break;
        }
        lpNext = lpJobQueuePtr->ListEntry.Flink;
    }
    return lpFoundRecpRef;
}



//*********************************************************************************
//* Name:   RemoveReceiveJob()
//* Author: Ronen Barenboim
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Removes a receive job from the queue.
//* PARAMETERS:
//*     [OUT]       PJOB_QUEUE lpJobToRemove
//*         A pointer to the job to remove.
//*     [IN]        BOOL bNotify
//*         TRUE if to generate a FEI_DELETED event after the removal.
//* RETURN VALUE:
//*     TRUE
//*         If successful.
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL RemoveReceiveJob(
    PJOB_QUEUE lpJobToRemove,
    BOOL bNotify
    )
{
    PJOB_QUEUE JobQueue, JobQueueBroadcast = NULL;
    BOOL RemoveMasterBroadcast = FALSE;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    DWORD JobId;

    DEBUG_FUNCTION_NAME(TEXT("RemoveReceiveJob"));

    Assert(lpJobToRemove);

    EnterCriticalSection( &g_CsQueue );

    //
    // need to make sure that the job queue entry we want to remove
    // is still in the list of job queue entries
    //
    JobQueue = FindJobQueueEntryByJobQueueEntry( lpJobToRemove );

    if (JobQueue == NULL) {
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }

    if (JobQueue->PrevRefCount > 0)
    {
        Assert (JT_ROUTING == JobQueue->JobType);

        JobQueue->JobStatus = JS_DELETING;
        LeaveCriticalSection( &g_CsQueue );
        return TRUE;
    }


    JobId = JobQueue->JobId;
    if (JobQueue->RefCount == 0)    {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("[JobId :%ld] Reference count is zero. Removing Receive Job."),
                JobId);


        RemoveEntryList( &JobQueue->ListEntry );
        if (!CancelWaitableTimer( g_hQueueTimer )) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CancelWaitableTimer failed. (ec: %ld)"),
                GetLastError());

        }
        if (!StartJobQueueTimer()) {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StartJobQueueTimer failed. (ec: %ld)"),
                    GetLastError());
        }


        if (JobQueue->FileName) {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Deleting receive file %s"),
                JobQueue->FileName);
            if (!DeleteFile(JobQueue->FileName)) {
                DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to delete receive file %s (ec: %ld)"),
                JobQueue->FileName,
                GetLastError());
                Assert(FALSE);
            }
        }

        if (JT_ROUTING == JobQueue->JobType)
        {
            //
            // Delete the Queue File if it exists
            //
            if (JobQueue->QueueFileName) {
                DebugPrintEx(DEBUG_MSG,TEXT("Deleting QueueFileName %s\n"), JobQueue->QueueFileName );
                if (!DeleteFile( JobQueue->QueueFileName )) {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to delete QueueFileName %s. (ec: %ld)"),
                        JobQueue->QueueFileName,
                        GetLastError());
                    Assert(FALSE);
                }
            }

            //
            // Delete the Preview File if it exists
            //
            if (JobQueue->PreviewFileName) {
                DebugPrintEx(   DEBUG_MSG,
                                TEXT("[Job: %ld] Deleting PreviewFileName %s"),
                                JobQueue->JobId,
                                JobQueue->PreviewFileName );
                if (!DeleteFile( JobQueue->PreviewFileName )) {
                    DebugPrintEx(   DEBUG_MSG,
                                    TEXT("[Job: %ld] Failed to delete QueueFileName %s (ec: %ld)"),
                                    JobQueue->JobId,
                                    JobQueue->PreviewFileName,
                                    GetLastError());
                    Assert(FALSE);
                }
            }

            //
            // Note that the first entry in the route file list is allways the recieved
            // file in case of a JT_ROUTING job.
            // This file deletion is done previously based on the bRemoveReceiveFile parameter.
            // We need to skip the first entry in the file list so we do not attempt to delete
            // it again.
            //

            DebugPrintEx(DEBUG_MSG, TEXT("Deleting JobQueue.FaxRouteFiles..."));
            Next = JobQueue->FaxRouteFiles.Flink;
            if (Next) {
                //
                // Set Next to point to the second file in the route file list.
                //
                Next=Next->Flink;
            }
            if (Next != NULL) {
                while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueue->FaxRouteFiles) {
                    FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
                    Next = FaxRouteFile->ListEntry.Flink;
                    DebugPrintEx(DEBUG_MSG, TEXT("Deleting route file: %s"),FaxRouteFile->FileName );
                    if (!DeleteFile( FaxRouteFile->FileName )) {
                        DebugPrintEx(DEBUG_ERR, TEXT("Failed to delete route file %s. (ec: %ld)"),FaxRouteFile->FileName,GetLastError());
                        Assert(FALSE);
                    }
                }
            }
        }

        //
        //  Crete FAX_EVENT_EX
        //
        if (bNotify)
        {
            DWORD dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_REMOVED,
                                             lpJobToRemove
                                           );
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_REMOVED) failed for job id %ld (ec: %lc)"),
                    lpJobToRemove->UniqueId,
                    dwRes);
            }
        }

        //
        // Free memory
        //
        FreeReceiveQueueEntry(JobQueue,TRUE);

        if (bNotify) {
            if (!CreateFaxEvent(0, FEI_DELETED, JobId)) {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateFaxEvent failed. (ec: %ld)"),
                    GetLastError());
            }
        }

        SafeDecIdleCounter (&g_dwQueueCount);
    }
    else
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("[JobId :%ld] Reference count is %ld. NOT REMOVING."),
                JobId);
        Assert (JobQueue->RefCount == 0); //Assert(FALSE);
    }
    LeaveCriticalSection( &g_CsQueue );
    return TRUE;
}




//*********************************************************************************
//* Name:   UpdatePersistentJobStatus()
//* Author: Ronen Barenboim
//* Date:   April 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Updated the JobStatus field in a job queue file.
//* PARAMETERS:
//*     [IN]    const PJOB_QUEUE lpJobQueue
//*         The job whose job status is to be updated in the file.
//* RETURN VALUE:
//*     TRUE
//*         The operation succeeded/
//*     FALSE
//*         Otherwise.
//*********************************************************************************
BOOL UpdatePersistentJobStatus(const PJOB_QUEUE lpJobQueue)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL bRet = FALSE;
    DWORD dwActSize;
    DWORD dwSeekPos;

    DEBUG_FUNCTION_NAME(TEXT("UpdatePersistentJobStatus"));

    Assert(lpJobQueue);
    Assert(lpJobQueue->QueueFileName);

    DWORD dwJobStatus = lpJobQueue->JobStatus;

    //
    // Open the queue file for random access writing
    //
    hFile = CreateFile(
        lpJobQueue->QueueFileName,
        GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL|FILE_FLAG_RANDOM_ACCESS,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to open file %s for reading. (ec: %ld)"),
                      lpJobQueue->QueueFileName,
                      GetLastError());
        goto Error;
    }


    //
    // seek to the JobStatus location in the file
    //
    dwSeekPos=SetFilePointer(
        hFile,
        offsetof(JOB_QUEUE_FILE, JobStatus),
        0,
        FILE_BEGIN);
    if (INVALID_SET_FILE_POINTER == dwSeekPos) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to seek to JobStatus location %ld in file %s. (ec: %ld)"),
                      offsetof(JOB_QUEUE_FILE, JobStatus),
                      lpJobQueue->QueueFileName,
                      GetLastError());
        goto Error;
    }

    //
    // Write the current job status
    //
    if (!WriteFile(
            hFile,
            &dwJobStatus,
            sizeof(dwJobStatus),
            &dwActSize,
            NULL)) {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] Failed to update JobStatus in file %s (ec: %ld)"),
                      lpJobQueue->JobId,
                      lpJobQueue->QueueFileName,
                      GetLastError());
        goto Error;
    };


    bRet=TRUE;
    goto Exit;
Error:
    bRet=FALSE;
Exit:
    if (INVALID_HANDLE_VALUE != hFile) {
        CloseHandle(hFile);
    }
    return bRet;

}



//*********************************************************************************
//* Name:   IsRecipientJobReadyForExecution()
//* Author: Ronen Barenboim
//* Date:   May 31, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Reports if a recipient send job is ready for execution.
//* PARAMETERS:
//*     [IN ]   PJOB_QUEUE lpcJobQueue
//*         The recipient job in question.
//*
//*     [IN ]    DWORDLONG dwlDueTime
//*         The time to use to determine if the job execution time has
//*         already passed.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the job is ready for execution.
//*     FALSE
//*         If the job is not yet ready for execution.
//* COMMENTS:
//*     Handoff jobs are allways reported as ready
//*     (unless they are paused or being cancled).
//*********************************************************************************
BOOL IsRecipientJobReadyForExecution(
    const PJOB_QUEUE lpcJobQueue,
    DWORDLONG dwlDueTime)
{
    DEBUG_FUNCTION_NAME(TEXT("IsRecipientJobReadyForExecution"));
    Assert(lpcJobQueue);
    Assert(JT_SEND == lpcJobQueue->JobType);


    if (lpcJobQueue->JobStatus & ( JS_PAUSED | JS_CANCELING))
    {
        //
        // Job is paused or in the process of being canceled (These are job status modifiers
        // so they need to be checked using a bit mask).
        //
        return FALSE;
    }
    else
    {

        //
        // Note: if the JS_NOLINE flag is on the job is NOT READY for execution.
        // The following "if" statement uses full comparision (not bitwise) with the
        // JS_PENDING and JS_RETRYING to make sure that if the JS_NOLINE flag is on
        // the job will not be considered ready for execution.
        //
        if ( ( JS_PENDING == lpcJobQueue->JobStatus  ) ||
             ( JS_RETRYING == lpcJobQueue->JobStatus ))
        {
            //
            // job is pending (retrying is another form of pending). Check if its
            // time has arrived or it is a handoff job.
            if (lpcJobQueue->DeviceId)
            {
                //
                // The job is a handoff job. They are allways ready.
                //
                return TRUE;
            }
            else
            {
                if (dwlDueTime >= lpcJobQueue->ScheduleTime)
                {
                    //
                    // The job time has already passed. It is ready for execution.
                    //
                    return TRUE;
                }
                else
                {
                    //
                    // The job time has not arrived yet.
                    //
                    return FALSE;
                }
            }
        }
        else
        {
            //
            // Job is not pending (initially or in the retrying state).
            //
            return FALSE;
        }
    }
    Assert(FALSE);
}




//*********************************************************************************
//* Name:   InsertQueueEntryByPriorityAndSchedule()
//* Author: Ronen Barenboim
//* Date:   June 15, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Inserts the new queue entry to the queue list based on jo priority and schedule.
//*     The queue list is ordered by ascending shcedule order.
//*     This function puts the new entry in the right place in the list based
//*     on its priority and schedule.
//* PARAMETERS:
//*     [in ]   PJOB_QUEUE lpJobQueue
//*         Pointer to the job queue entry to insert into the queue list.
//* RETURN VALUE:
//*     TRUE if the operation succeeded.
//*     FALSE if it failed. Call GetLastError() for extended error information.
//*********************************************************************************
BOOL InsertQueueEntryByPriorityAndSchedule (PJOB_QUEUE lpJobQueue)
{
    LIST_ENTRY * lpNext = NULL;
    DEBUG_FUNCTION_NAME(TEXT("InsertQueueEntryByPriorityAndSchedule"));
    Assert(lpJobQueue && lpJobQueue->JobType == JT_SEND);

    if ( ((ULONG_PTR) g_QueueListHead.Flink == (ULONG_PTR)&g_QueueListHead) ||
         (lpJobQueue->DeviceId != 0))
    {
        //
        // just put it at the head of the list
        //
        InsertHeadList( &g_QueueListHead, &lpJobQueue->ListEntry );
    }
    else
    {
        //
        // insert the queue entry into the list in a sorted order
        //
        QUEUE_SORT NewEntry;

        //
        // Set the new QUEUE_SORT structure
        //
        NewEntry.Priority       = lpJobQueue->JobParamsEx.Priority;
        NewEntry.ScheduleTime   = lpJobQueue->ScheduleTime;
        NewEntry.QueueEntry     = NULL;

        lpNext = g_QueueListHead.Flink;
        while ((ULONG_PTR)lpNext != (ULONG_PTR)&g_QueueListHead)
        {
            PJOB_QUEUE lpQueueEntry;
            QUEUE_SORT CurrEntry;

            lpQueueEntry = CONTAINING_RECORD( lpNext, JOB_QUEUE, ListEntry );
            lpNext = lpQueueEntry->ListEntry.Flink;

            //
            // Set the current QUEUE_SORT structure
            //
            CurrEntry.Priority       = lpQueueEntry->JobParamsEx.Priority;
            CurrEntry.ScheduleTime   = lpQueueEntry->ScheduleTime;
            CurrEntry.QueueEntry     = NULL;

            if (QueueCompare(&NewEntry, &CurrEntry) < 0)
            {
                //
                // This inserts the new item BEFORE the current item
                //
                InsertTailList( &lpQueueEntry->ListEntry, &lpJobQueue->ListEntry );
                lpNext = NULL;
                break;
            }
        }
        if ((ULONG_PTR)lpNext == (ULONG_PTR)&g_QueueListHead)
        {
            //
            // No entry with earlier time just put it at the end of the queue
            //
            InsertTailList( &g_QueueListHead, &lpJobQueue->ListEntry );
        }
    }
    return TRUE;
}



//*********************************************************************************
//* Name:   RemoveJobStatusModifiers()
//* Author: Ronen Barenboim
//* Date:   June 22, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Returns the job status after stripping the status modifier bits.
//*
//* PARAMETERS:
//*     [IN ]   DWORD dwJobStatus
//*         The status code to strip the job status modifier bits from.
//* RETURN VALUE:
//*     The job status code after the modifier bits were set to 0.
//*********************************************************************************
DWORD RemoveJobStatusModifiers(DWORD dwJobStatus)
{
    dwJobStatus &= ~(JS_PAUSED | JS_NOLINE);
    return dwJobStatus;
}


BOOL UserOwnsJob(
    IN const PJOB_QUEUE lpcJobQueue,
    IN const PSID lpcUserSid
    )
{
    DWORD ulRet = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("UserOwnsJob"));

    if (lpcJobQueue->JobType == JT_SEND)
    {
        Assert (lpcJobQueue->lpParentJob->UserSid != NULL);
        Assert (lpcUserSid);

        if (!EqualSid (lpcUserSid, lpcJobQueue->lpParentJob->UserSid) )
        {
            //
            // dwlMessageId is not a valid queued recipient job Id.
            //
            DebugPrintEx(DEBUG_WRN,TEXT("EqualSid failed ,Access denied (ec: %ld)"), GetLastError());
            return FALSE;
        }
    }
    else
    {
        Assert (lpcJobQueue->JobType == JT_RECEIVE ||
                lpcJobQueue->JobType == JT_ROUTING );

        return FALSE;
    }
    return TRUE;
}


void
DecreaseJobRefCount (
    PJOB_QUEUE pJobQueue,
    BOOL bNotify,
    BOOL bRemoveRecipientJobs, // Default value TRUE
    BOOL bPreview              // Default value FALSE
    )
/*++

Routine name : DecreaseJobRefCount

Routine description:

    Decreases the job reference count.
    Updates parent job refernce count.
    Removes the job if reference count reaches 0.
    Must be called inside critical section g_CsQueue

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    pJobQueue               [in] -  Pointer to the job queue.
    bNotify                 [in] -  Flag that indicates to notify the clients of job removal.
    bRemoveRecipientJobs    [in] -  Flag that indicates to remove all the recipients of a broadcast job.
    bPreview                [in] -  Flag that indicates to decrease preview ref count.

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("DecreaseJobRefCount"));

    Assert (pJobQueue->JobType == JT_ROUTING ||
            pJobQueue->JobType == JT_RECEIVE ||
            pJobQueue->JobType == JT_SEND);

    if (TRUE == bPreview)
    {
        Assert (pJobQueue->PrevRefCount);
        pJobQueue->PrevRefCount -= 1;
    }
    else
    {
        Assert (pJobQueue->RefCount);
        pJobQueue->RefCount -= 1;
    }

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("[Job: %ld] job reference count = %ld, PrevRefCount = %ld."),
        pJobQueue->JobId,
        pJobQueue->RefCount,
        pJobQueue->PrevRefCount);


    if (pJobQueue->JobType == JT_SEND)
    {
        Assert (pJobQueue->lpParentJob);

        if (TRUE == bPreview)
        {
            pJobQueue->lpParentJob->PrevRefCount -= 1;
        }
        else
        {
            pJobQueue->lpParentJob->RefCount -= 1;
        }

        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] Parent job reference count = %ld, Parent job PrevRefCount = %ld."),
            pJobQueue->lpParentJob->JobId,
            pJobQueue->lpParentJob->RefCount,
            pJobQueue->lpParentJob->PrevRefCount);
    }

    if (0 != pJobQueue->RefCount)
    {
        return;
    }

    //
    // Remove Job queue entry
    //
    if (JT_RECEIVE == pJobQueue->JobType ||
        JT_ROUTING == pJobQueue->JobType)
    {
        // receive job
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] Job is ready for deleting."),
            pJobQueue->JobId);
        RemoveReceiveJob (pJobQueue, bNotify);
        return;
    }

    //
    // recipient job
    //
    if (IsSendJobReadyForDeleting(pJobQueue))
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] Parent job is ready for deleting."),
            pJobQueue->lpParentJob->JobId);
        RemoveParentJob(pJobQueue->lpParentJob,
            bRemoveRecipientJobs, // Remove recipient jobs
            bNotify // Notify
            );
    }
    return;
} // DecreaseJobRefCount


void
IncreaseJobRefCount (
    PJOB_QUEUE pJobQueue,
    BOOL bPreview              // Default value FALSE
    )
/*++

Routine name : IncreaseJobRefCount

Routine description:

    Increases the job reference count. Updates the parent job refernce count.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    pJobQueue           [in] - Pointer to the job queue.
    bPreview            [in] -  Flag that indicates to increase preview ref count.

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("IncreaseJobRefCount"));

    Assert (pJobQueue);
    Assert (pJobQueue->JobType == JT_ROUTING ||
            pJobQueue->JobType == JT_RECEIVE ||
            pJobQueue->JobType == JT_SEND);

    if (JT_RECEIVE == pJobQueue->JobType ||
        JT_ROUTING == pJobQueue->JobType)
    {
        // receive job
        if (TRUE == bPreview)
        {
            Assert (JT_ROUTING == pJobQueue->JobType);
            pJobQueue->PrevRefCount += 1;
        }
        else
        {
            pJobQueue->RefCount += 1;
        }
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] job reference count = %ld."),
            pJobQueue->JobId,
            pJobQueue->RefCount);
        return;
    }

    //
    // send job
    //
    Assert (pJobQueue->lpParentJob);

    if (TRUE == bPreview)
    {
        pJobQueue->PrevRefCount += 1;
        pJobQueue->lpParentJob->PrevRefCount += 1;
    }
    else
    {
        pJobQueue->RefCount += 1;
        pJobQueue->lpParentJob->RefCount += 1;
    }

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("[Job: %ld] job reference count = %ld, PrevRefCount = %ld."),
        pJobQueue->JobId,
        pJobQueue->RefCount,
        pJobQueue->PrevRefCount);

    DebugPrintEx(
            DEBUG_MSG,
            TEXT("[Job: %ld] Parent job reference count = %ld, , Parent job PrevRefCount = %ld."),
            pJobQueue->lpParentJob->JobId,
            pJobQueue->lpParentJob->RefCount,
            pJobQueue->lpParentJob->RefCount);
    return;
} // IncreaseJobRefCount


JOB_QUEUE::~JOB_QUEUE()
{
    if (JT_BROADCAST == JobType)
    {
        return;
    }

    JobStatus = JS_INVALID;
    return;
}

void JOB_QUEUE::PutStatus(DWORD dwStatus)
/*++

Routine name : JOB_QUEUE::PutStatus

Routine description:

    Controls all status changes of a job in queue (JobStatus is a virtual property in JOB_QUEUE)

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    dwStatus            [in] - The new status to be assigened to the job

Return Value:

    None.

--*/
{
    DWORD dwOldStatus = RemoveJobStatusModifiers(m_dwJobStatus);
    DWORD dwNewStatus = RemoveJobStatusModifiers(dwStatus);
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("JOB_QUEUE::PutStatus"));
    m_dwJobStatus = dwStatus;

    if (JT_BROADCAST == JobType)
    {
        return;
    }

    FAX_ENUM_JOB_TYPE__JOB_STATUS OldJobType_JobStatusIndex = GetJobType_JobStatusIndex (JobType, dwOldStatus);
    FAX_ENUM_JOB_TYPE__JOB_STATUS NewJobType_JobStatusIndex = GetJobType_JobStatusIndex (JobType, dwNewStatus);
    WORD wAction = gsc_JobType_JobStatusTable[OldJobType_JobStatusIndex][NewJobType_JobStatusIndex];

    Assert (wAction != INVALID_CHANGE);

    if (EFSPPermanentMessageId.dwIdSize == 0)
    {
        // Non queueing EFSP
        Assert (!(wAction & Q_EFSP_ONLY));
    }

    if (wAction == NO_CHANGE)
    {
        return;
    }

    //
    // Update Server Activity counters
    //
    EnterCriticalSection (&g_CsActivity);
    if (wAction & QUEUED_INC)
    {
        Assert (!(wAction & QUEUED_DEC));
        g_ServerActivity.dwQueuedMessages++;
    }

    if (wAction & QUEUED_DEC)
    {
        Assert (g_ServerActivity.dwQueuedMessages);
        Assert (!(wAction & QUEUED_INC));
        g_ServerActivity.dwQueuedMessages--;
    }

    if (wAction & OUTGOING_INC)
    {
        Assert (!(wAction & OUTGOING_DEC));
        if (EFSPPermanentMessageId.dwIdSize == 0)
        {
            // Non queueing EFSP
            g_ServerActivity.dwOutgoingMessages++;
        }
        else
        {
            // Queueing EFSP
            g_ServerActivity.dwDelegatedOutgoingMessages++;
        }
    }

    if (wAction & OUTGOING_DEC)
    {
        Assert (!(wAction & OUTGOING_INC));
        if (EFSPPermanentMessageId.dwIdSize == 0)
        {
            // Non queueing EFSP
            Assert (g_ServerActivity.dwOutgoingMessages);
            g_ServerActivity.dwOutgoingMessages--;
        }
        else
        {
            // Queueing EFSP
            Assert (g_ServerActivity.dwDelegatedOutgoingMessages);
            g_ServerActivity.dwDelegatedOutgoingMessages--;
        }
    }

    if (wAction & INCOMING_INC)
    {
        Assert (!(wAction & INCOMING_DEC));
        g_ServerActivity.dwIncomingMessages++;
    }

    if (wAction & INCOMING_DEC)
    {
        Assert (g_ServerActivity.dwIncomingMessages);
        Assert (!(wAction & INCOMING_INC));
        g_ServerActivity.dwIncomingMessages--;
    }

    if (wAction & ROUTING_INC)
    {
        Assert (!(wAction & ROUTING_DEC));
        g_ServerActivity.dwRoutingMessages++;
    }

    if (wAction & ROUTING_DEC)
    {
        Assert (g_ServerActivity.dwRoutingMessages);
        Assert (!(wAction & ROUTING_INC));
        g_ServerActivity.dwRoutingMessages--;
    }

    //
    // Create FaxEventEx
    //
    dwRes = CreateActivityEvent ();
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateActivityEvent failed (ec: %lc)"),
            dwRes);
    }
    LeaveCriticalSection (&g_CsActivity);
    return;
}


FAX_ENUM_JOB_TYPE__JOB_STATUS
GetJobType_JobStatusIndex (
    DWORD dwJobType,
    DWORD dwJobStatus
    )
/*++

Routine name : GetJobType_JobStatusIndex

Routine description:

    Returns an Index (Row or Column) in the global JobType_JobStatus table.

Author:

    Oded Sacher (OdedS),    Mar, 2000

Arguments:

    dwJobType           [in ] - JT_SEND, JT_RECEIVE or JT_ROUTING.
    dwJobStatus         [in ] - One of JS_ defines without modifiers.

Return Value:

    Global JobType_JobStatus Table Index

--*/
{
    FAX_ENUM_JOB_TYPE__JOB_STATUS Index = JOB_TYPE__JOBSTATUS_COUNT;

    switch (dwJobStatus)
    {
        case JS_INVALID:
            Index = JT_SEND__JS_INVALID;
            break;
        case JS_PENDING:
            Index = JT_SEND__JS_PENDING;
            break;
        case JS_INPROGRESS:
            Index = JT_SEND__JS_INPROGRESS;
            break;
        case JS_DELETING:
            Index = JT_SEND__JS_DELETING;
            break;
        case JS_RETRYING:
            Index = JT_SEND__JS_RETRYING;
            break;
        case JS_RETRIES_EXCEEDED:
            Index = JT_SEND__JS_RETRIES_EXCEEDED;
            break;
        case JS_COMPLETED:
            Index = JT_SEND__JS_COMPLETED;
            break;
        case JS_CANCELED:
            Index = JT_SEND__JS_CANCELED;
            break;
        case JS_CANCELING:
            Index = JT_SEND__JS_CANCELING;
            break;
        case JS_ROUTING:
            Index = JT_SEND__JS_ROUTING;
            break;
        case JS_FAILED:
            Index = JT_SEND__JS_FAILED;
            break;
        default:
            ASSERT_FALSE;
    }

    switch (dwJobType)
    {
        case JT_SEND:
            break;
        case JT_ROUTING:
            Index =  (FAX_ENUM_JOB_TYPE__JOB_STATUS)((DWORD)Index +(DWORD)JT_ROUTING__JS_INVALID);
            break;
        case JT_RECEIVE:
            Index =  (FAX_ENUM_JOB_TYPE__JOB_STATUS)((DWORD)Index +(DWORD)JT_RECEIVE__JS_INVALID);
            break;
        default:
            ASSERT_FALSE;
    }

    Assert (Index >= 0 && Index <JOB_TYPE__JOBSTATUS_COUNT);

    return Index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\mapi.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mapi.c

Abstract:

    This file implements wrappers for all mapi apis.
    The wrappers are necessary because mapi does not
    implement unicode and this code must be non-unicode.

Author:

    Wesley Witt (wesw) 13-Sept-1996

Revision History:

--*/

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <mapiwin.h>
#include <mapix.h>
#include <mapiutil.h>
#include <stdio.h>

#include "profinfo.h"
#include "faxutil.h"



typedef ULONG (STDAPIVCALLTYPE*ULRELEASE)(LPVOID);
typedef VOID  (STDAPIVCALLTYPE*FREEPADRLIST)(LPADRLIST);
typedef ULONG (STDAPIVCALLTYPE*HRQUERYALLROWS)(LPMAPITABLE,LPSPropTagArray,LPSRestriction,LPSSortOrderSet,LONG,LPSRowSet*);
typedef SCODE (STDAPIVCALLTYPE*SCDUPPROPSET)(int, LPSPropValue,LPALLOCATEBUFFER, LPSPropValue*);



static LPMAPIINITIALIZE     MapiInitialize;
static LPMAPIUNINITIALIZE   MapiUnInitialize;
static LPMAPILOGONEX        MapiLogonEx;
static LPMAPIFREEBUFFER     MapiFreeBuffer;
static LPMAPIALLOCATEBUFFER MapiAllocateBuffer;
static LPMAPIADMINPROFILES  MapiAdminProfiles;
static ULRELEASE            pUlRelease;
static FREEPADRLIST         pFreePadrlist;
static HRQUERYALLROWS       pHrQueryAllRows;
static SCDUPPROPSET         pScDupPropset;


static MAPIINIT_0           MapiInit;

extern "C" BOOL  MapiIsInitialized = FALSE;

extern "C" DWORD ServiceDebug;


extern "C"
LPSTR
UnicodeStringToAnsiString(
    LPWSTR UnicodeString
    );

extern "C"
VOID
FreeString(
    LPVOID String
    );


extern "C"
BOOL
InitializeMapi(
    VOID
    )

/*++

Routine Description:

    Initializes MAPI.

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if not

--*/

{

    HMODULE MapiMod = NULL;
    HRESULT Result;

    //
    // load the mapi dll
    //

    MapiMod = LoadLibrary( "mapi32.dll" );
    if (!MapiMod) {
        return FALSE;
    }

    //
    // get the addresses of the mapi functions that we need
    //

    MapiInitialize = (LPMAPIINITIALIZE) GetProcAddress( MapiMod, "MAPIInitialize" );
    MapiUnInitialize = (LPMAPIUNINITIALIZE) GetProcAddress( MapiMod, "MAPIUninitialize" );
    MapiLogonEx = (LPMAPILOGONEX) GetProcAddress( MapiMod, "MAPILogonEx" );
    MapiFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress( MapiMod, "MAPIFreeBuffer" );
    MapiAllocateBuffer = (LPMAPIALLOCATEBUFFER) GetProcAddress( MapiMod, "MAPIAllocateBuffer" );
    MapiAdminProfiles = (LPMAPIADMINPROFILES) GetProcAddress( MapiMod, "MAPIAdminProfiles" );
    pUlRelease = (ULRELEASE) GetProcAddress( MapiMod, "UlRelease@4" );
    pFreePadrlist = (FREEPADRLIST) GetProcAddress( MapiMod, "FreePadrlist@4" );
    pHrQueryAllRows = (HRQUERYALLROWS) GetProcAddress( MapiMod, "HrQueryAllRows@24" );
    pScDupPropset = (SCDUPPROPSET) GetProcAddress( MapiMod, "ScDupPropset@16" );

    if ((!MapiInitialize) || (!MapiUnInitialize) ||
        (!MapiLogonEx) || (!MapiAllocateBuffer) ||
        (!MapiFreeBuffer) || (!MapiAdminProfiles) ||
        (!pUlRelease) || (!pFreePadrlist) ||
        (!pHrQueryAllRows) || (!pScDupPropset)) {
        return FALSE;
    }

    MapiInit.ulFlags = MAPI_MULTITHREAD_NOTIFICATIONS;

    if (!ServiceDebug) {
        MapiInit.ulFlags |= MAPI_NT_SERVICE;
    }

    Result = MapiInitialize(&MapiInit);

    if (Result != S_OK) {
        return FALSE;
    }

    return MapiIsInitialized = TRUE;
}


VOID
FreeProws(
    LPSRowSet prows
    )

/*++

Routine Description:

    Destroy SRowSet structure.  Copied from MAPI.

Arguments:

    hFile      - Pointer to SRowSet

Return value:

    NONE

--*/

{
    ULONG irow;

    if (!prows) {
        return;
    }

    for (irow = 0; irow < prows->cRows; ++irow) {
        MapiFreeBuffer(prows->aRow[irow].lpProps);
    }

    MapiFreeBuffer( prows );
}


HRESULT
HrMAPIFindInbox(
    IN LPMDB lpMdb,
    OUT ULONG *lpcbeid,
    OUT LPENTRYID *lppeid
    )

/*++

Routine Description:

    Find IPM inbox folder.  Copied from Exchange SDK.

Arguments:

    lpMdb            - pointer to message store
    lpcbeid          - count of bytes in entry ID
    lppeid           - entry ID of IPM inbox

Return value:

    HRESULT (see MAPI docs)

--*/

{
    HRESULT hr = NOERROR;
    SCODE sc = 0;


    *lpcbeid = 0;
    *lppeid  = NULL;

    //
    // Get the entry ID of the Inbox from the message store
    //
    hr = lpMdb->GetReceiveFolder(
        NULL,
        0,
        lpcbeid,
        lppeid,
        NULL
        );

    return hr;
}

HRESULT
HrMAPIFindOutbox(
    IN LPMDB lpMdb,
    OUT ULONG *lpcbeid,
    OUT LPENTRYID *lppeid
    )
/*++

Routine Description:

    Find IPM outbox folder.  Copied from Exchange SDK.

Arguments:

    lpMdb            - pointer to message store
    lpcbeid          - count of bytes in entry ID
    lppeid           - entry ID of IPM inbox

Return value:

    HRESULT (see MAPI docs)

--*/
{
    HRESULT       hr          = NOERROR;
    SCODE         sc          = 0;
    ULONG         cValues     = 0;
    LPSPropValue  lpPropValue = NULL;
    ULONG         cbeid       = 0;
    SPropTagArray rgPropTag   = { 1, { PR_IPM_OUTBOX_ENTRYID } };


    *lpcbeid = 0;
    *lppeid  = NULL;

    //
    // Get the outbox entry ID property.
    //
    hr = lpMdb->GetProps(
        &rgPropTag,
        0,
        &cValues,
        &lpPropValue
        );

    if (hr == MAPI_W_ERRORS_RETURNED) {
        goto cleanup;
    }

    if (FAILED(hr)) {
        lpPropValue = NULL;
        goto cleanup;
    }

    //
    // Check to make sure we got the right property.
    //
    if (lpPropValue->ulPropTag != PR_IPM_OUTBOX_ENTRYID) {
        goto cleanup;
    }

    cbeid = lpPropValue->Value.bin.cb;

    sc = MapiAllocateBuffer( cbeid, (void **)lppeid );

    if(FAILED(sc)) {
        goto cleanup;
    }

    //
    // Copy outbox Entry ID
    //
    CopyMemory(
        *lppeid,
        lpPropValue->Value.bin.lpb,
        cbeid
        );

    *lpcbeid = cbeid;

cleanup:

    MapiFreeBuffer( lpPropValue );

    return hr;
}


HRESULT
HrMAPIFindDefaultMsgStore(
    IN LPMAPISESSION lplhSession,
    OUT ULONG *lpcbeid,
    OUT LPENTRYID *lppeid
    )

/*++

Routine Description:

    Get the entry ID of the default message store.  Copied from Exchange SDK.

Arguments:

       lplhSession      - session pointer
       lpcbeid          - count of bytes in entry ID
       lppeid           - entry ID default store

Return value:

    HRESULT (see MAPI docs)

--*/

{
    HRESULT     hr      = NOERROR;
    SCODE       sc      = 0;
    LPMAPITABLE lpTable = NULL;
    LPSRowSet   lpRows  = NULL;
    LPENTRYID   lpeid   = NULL;
    ULONG       cbeid   = 0;
    ULONG       cRows   = 0;
    ULONG       i       = 0;

    SizedSPropTagArray(2, rgPropTagArray) =
    {
        2,
        {
            PR_DEFAULT_STORE,
            PR_ENTRYID
        }
    };

    //
    // Get the list of available message stores from MAPI
    //
    hr = lplhSession->GetMsgStoresTable( 0, &lpTable );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Get the row count for the message recipient table
    //
    hr = lpTable->GetRowCount( 0, &cRows );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Set the columns to return
    //
    hr = lpTable->SetColumns( (LPSPropTagArray)&rgPropTagArray, 0 );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Go to the beginning of the recipient table for the envelope
    //
    hr = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Read all the rows of the table
    //
    hr = lpTable->QueryRows( cRows, 0, &lpRows );
    if (SUCCEEDED(hr) && (lpRows != NULL) && (lpRows->cRows == 0)) {
        FreeProws( lpRows );
        hr = MAPI_E_NOT_FOUND;
    }

    if (FAILED(hr) || (lpRows == NULL)) {
        goto cleanup;
    }

    for (i = 0; i < cRows; i++) {
        if(lpRows->aRow[i].lpProps[0].Value.b == TRUE) {
            cbeid = lpRows->aRow[i].lpProps[1].Value.bin.cb;

            sc = MapiAllocateBuffer( cbeid, (void **)&lpeid );

            if(FAILED(sc)) {
                cbeid = 0;
                lpeid = NULL;
                goto cleanup;
            }

            //
            // Copy entry ID of message store
            //
            CopyMemory(
                lpeid,
                lpRows->aRow[i].lpProps[1].Value.bin.lpb,
                cbeid
                );

            break;
        }
    }

cleanup:

    if(!lpRows) {
        FreeProws( lpRows );
    }

    lpTable->Release();

    *lpcbeid = cbeid;
    *lppeid = lpeid;

    return hr;
}


HRESULT
HrMAPIWriteFileToStream(
    IN HANDLE hFile,
    OUT LPSTREAM lpStream
    )

/*++

Routine Description:

    Write file to a stream given a stream pointer.  Copied from Exchange SDK.

Arguments:

       hFile      - Handle to file
       lpStream   - Pointer to stream

Return value:

    HRESULT (see MAPI docs)

--*/
{
    HRESULT hr              = NOERROR;
    DWORD   cBytesRead      = 0;
    ULONG   cBytesWritten   = 0;
    BYTE    byteBuffer[128] = {0};
    BOOL    fReadOk         = FALSE;

    for(;;) {
        fReadOk = ReadFile(
            hFile,
            byteBuffer,
            sizeof(byteBuffer),
            &cBytesRead,
            NULL
            );

        if (!fReadOk) {
            break;
        }

        if (!cBytesRead) {
            hr = NOERROR;
            break;
        }

        hr = lpStream->Write(
            byteBuffer,
            cBytesRead,
            &cBytesWritten
            );
        if (FAILED(hr)) {
            break;
        }

        if(cBytesWritten != cBytesRead) {
            break;
        }
    }

    return hr;
}


extern "C"
VOID
DoMapiLogon(
    PPROFILE_INFO ProfileInfo
    )
{
    HRESULT HResult = 0;
    FLAGS MAPILogonFlags = MAPI_NEW_SESSION | MAPI_EXTENDED | MAPI_NO_MAIL;
    LPSTR ProfileName;
    LPMAPISESSION Session = NULL;


    if (!MapiIsInitialized) {
        ProfileInfo->Session = NULL;
        SetEvent( ProfileInfo->EventHandle );
        return;

    }

    if (!ServiceDebug) {
        MAPILogonFlags |= MAPI_NT_SERVICE;
    }

    if (ProfileInfo->UseMail) {
        MAPILogonFlags &= ~MAPI_NO_MAIL;
    }

    if (ProfileInfo->ProfileName[0] == 0) {
        MAPILogonFlags |= MAPI_USE_DEFAULT;
    }

    ProfileName = UnicodeStringToAnsiString( ProfileInfo->ProfileName );

    __try {
        HResult = MapiLogonEx(
            0,
            ProfileName,
            NULL,
            MAPILogonFlags,
            &Session
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        HResult = GetExceptionCode();
    }

    if (HR_FAILED(HResult)) {
        SetLastError( HResult );
        ProfileInfo->Session = NULL;
    } else {
        InitializeCriticalSection( &ProfileInfo->CsSession );
        ProfileInfo->Session = Session;
    }

    FreeString( ProfileName );

    SetEvent( ProfileInfo->EventHandle );
}


extern "C"
BOOL
DoMapiLogoff(
    LPMAPISESSION Session
    )
{
    HRESULT HResult = Session->Logoff( 0, 0, 0 );
    if (HR_FAILED(HResult)) {
        return FALSE;
    }
    return TRUE;
}


extern "C"
BOOL
StoreMapiMessage(
    LPMAPISESSION   Session,
    LPWSTR          MsgSenderNameW,
    LPWSTR          MsgSubjectW,
    LPWSTR          MsgBodyW,
    LPWSTR          MsgAttachmentFileNameW,
    LPWSTR          MsgAttachmentTitleW,
    DWORD           MsgImportance,
    LPFILETIME      MsgTime,
    PULONG          ResultCode
    )

/*++

Routine Description:

    Mails a TIFF file to the inbox in the specified profile.

Arguments:

    TiffFileName            - Name of TIFF file to mail
    ProfileName             - Profile name to use
    ResultCode              - The result of the failed API call

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPATTACH            Attach = NULL;
    ULONG               AttachmentNum;
    CHAR                FileExt[_MAX_EXT];
    CHAR                FileName[MAX_PATH];
    HRESULT             HResult = 0;
    LPMAPIFOLDER        Inbox = NULL;
    LPMESSAGE           Message = NULL;
    LPSTR               MsgAttachmentFileName = NULL;
    LPSTR               MsgAttachmentTitle = NULL;
    LPSTR               MsgBody = NULL;
    LPSTR               MsgSenderName = NULL;
    LPSTR               MsgSubject = NULL;
    DWORD               RenderingPosition = 0;
    LPMDB               Store = NULL;
    LPSTREAM            Stream = NULL;
    ULONG               cbInEntryID = 0;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    LPENTRYID           lpInEntryID = NULL;
    LPSPropProblemArray lppProblems;
    ULONG               lpulObjType;
    SPropValue          spvAttachProps[5] = { 0 };
    SPropValue          spvMsgProps[9] = { 0 };
    FILETIME            CurrentTime;


    _try {

        //
        // get the time if the caller wants us to
        //

        if (!MsgTime) {
            MsgTime = &CurrentTime;
            GetSystemTimeAsFileTime( MsgTime );
        }

        //
        // find the default message store
        //

        HResult = HrMAPIFindDefaultMsgStore( Session, &cbInEntryID, &lpInEntryID );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // open the message store
        //

        HResult = Session->OpenMsgStore(
            0,
            cbInEntryID,
            lpInEntryID,
            NULL,
            MDB_NO_DIALOG | MDB_WRITE,
            &Store
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer( lpInEntryID );

        //
        // find the inbox
        //

        HResult= HrMAPIFindInbox( Store, &cbInEntryID, &lpInEntryID );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // open the inbox
        //

        HResult = Session->OpenEntry(
            cbInEntryID,
            lpInEntryID,
            NULL,
            MAPI_MODIFY,
            &lpulObjType,
            (LPUNKNOWN *) &Inbox
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Create a message
        //

        HResult = Inbox->CreateMessage(
            NULL,
            0,
            &Message
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        //
        // convert all of the strings to ansi strings
        //

        MsgSenderName = UnicodeStringToAnsiString( MsgSenderNameW );
        MsgSubject = UnicodeStringToAnsiString( MsgSubjectW );
        MsgBody = UnicodeStringToAnsiString( MsgBodyW );
        MsgAttachmentFileName = UnicodeStringToAnsiString( MsgAttachmentFileNameW );
        MsgAttachmentTitle = UnicodeStringToAnsiString( MsgAttachmentTitleW );

        //
        // Fill in message properties and set them
        //

        spvMsgProps[0].ulPropTag     = PR_SENDER_NAME;
        spvMsgProps[1].ulPropTag     = PR_SENT_REPRESENTING_NAME;
        spvMsgProps[2].ulPropTag     = PR_SUBJECT;
        spvMsgProps[3].ulPropTag     = PR_MESSAGE_CLASS;
        spvMsgProps[4].ulPropTag     = PR_BODY;
        spvMsgProps[5].ulPropTag     = PR_MESSAGE_DELIVERY_TIME;
        spvMsgProps[6].ulPropTag     = PR_CLIENT_SUBMIT_TIME;
        spvMsgProps[7].ulPropTag     = PR_MESSAGE_FLAGS;
        spvMsgProps[8].ulPropTag     = PR_IMPORTANCE;
        spvMsgProps[0].Value.lpszA   = MsgSenderName;
        spvMsgProps[1].Value.lpszA   = MsgSenderName;
        spvMsgProps[2].Value.lpszA   = MsgSubject;
        spvMsgProps[3].Value.lpszA   = "IPM.Note";
        spvMsgProps[4].Value.lpszA   = MsgBody;
        spvMsgProps[5].Value.ft      = *MsgTime;
        spvMsgProps[6].Value.ft      = *MsgTime;
        spvMsgProps[7].Value.ul      = 0;
        spvMsgProps[8].Value.ul      = MsgImportance;

        HResult = Message->SetProps(
            sizeof(spvMsgProps)/sizeof(SPropValue),
            (LPSPropValue) spvMsgProps,
            &lppProblems
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer( lppProblems );

        if (MsgAttachmentFileName) {

            //
            // Create an attachment
            //

            HResult = Message->CreateAttach(
                NULL,
                0,
                &AttachmentNum,
                &Attach
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            _splitpath( MsgAttachmentFileName, NULL, NULL, FileName, FileExt );
            strcat( FileName, FileExt );

            //
            // Fill in attachment properties and set them
            //

            if (!MsgAttachmentTitle) {
                MsgAttachmentTitle = FileName;
            }

            RenderingPosition = strlen(MsgBody);

            spvAttachProps[0].ulPropTag     = PR_RENDERING_POSITION;
            spvAttachProps[1].ulPropTag     = PR_ATTACH_METHOD;
            spvAttachProps[2].ulPropTag     = PR_ATTACH_LONG_FILENAME;
            spvAttachProps[3].ulPropTag     = PR_DISPLAY_NAME;
            spvAttachProps[4].ulPropTag     = PR_ATTACH_EXTENSION;
            spvAttachProps[0].Value.ul      = RenderingPosition;
            spvAttachProps[1].Value.ul      = ATTACH_BY_VALUE;
            spvAttachProps[2].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[3].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[4].Value.lpszA   = FileExt;

            HResult = Attach->SetProps(
                sizeof(spvAttachProps)/sizeof(SPropValue),
                (LPSPropValue) spvAttachProps,
                &lppProblems
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            MapiFreeBuffer( lppProblems );

            //
            // Attach a data property to the attachment
            //

            HResult = Attach->OpenProperty(
                PR_ATTACH_DATA_BIN,
                &IID_IStream,
                0,
                MAPI_CREATE | MAPI_MODIFY,
                (LPUNKNOWN *) &Stream
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            //
            // open the message attachment file
            //

            hFile = CreateFile(
                MsgAttachmentFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
            if (hFile == INVALID_HANDLE_VALUE) {
                _leave;
            }

            //
            // Write the file to the data property
            //

            HResult = HrMAPIWriteFileToStream( hFile, Stream );
            if (HR_FAILED(HResult)) {
                _leave;
            }
        }

        //
        // Save the changes and logoff
        //

        HResult = Attach->SaveChanges(
            FORCE_SAVE
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        HResult = Message->SaveChanges(
            FORCE_SAVE
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

    }
    _finally {

        MapiFreeBuffer( lpInEntryID );

        if (Store) {
            Store->Release();
        }
        if (Inbox) {
            Inbox->Release();
        }
        if (Message) {
            Message->Release();
        }
        if (Attach) {
            Attach->Release();
        }
        if (Stream) {
            Stream->Release();
        }

        FreeString( MsgSenderName );
        FreeString( MsgSubject );
        FreeString( MsgBody );
        FreeString( MsgAttachmentFileName );
        if (MsgAttachmentTitleW && MsgAttachmentTitle) {
            FreeString( MsgAttachmentTitle );
        }

        CloseHandle( hFile );

    }

    *ResultCode = HResult;
    return HResult == 0;
}

extern "C"
LONG
GetMapiProfiles(
    LPWSTR *OutBuffer,
    LPDWORD OutBufferSize
    )
{
    HMODULE MapiMod = NULL;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    LPPROFADMIN lpProfAdmin;
    DWORD i;
    HRESULT hr;
    DWORD Count;
    LPWSTR Buffer;
    DWORD BytesNeeded;
    DWORD Offset = 0;


    if (!MapiIsInitialized) {
        return MAPI_E_NO_SUPPORT;
    }

    if (hr = MapiAdminProfiles( 0, &lpProfAdmin )) {
        return hr;
    }

    //
    // get the mapi table object
    //

    if (hr = lpProfAdmin->GetProfileTable( 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (hr = pmt->QueryRows( 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles and put the name
    // of each profile in the combo box
    //

    BytesNeeded = 0;

    for (i=0; i<prws->cRows; i++) {

        pval = prws->aRow[i].lpProps;


        Count = MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            pval[0].Value.lpszA,
            -1,
            NULL,
            0
            );

        if (Count == 0) {

            hr = GetLastError();

            goto exit;

        } else {

            BytesNeeded += Count * sizeof(WCHAR);

        }
    }

    BytesNeeded += sizeof(UNICODE_NULL);

    Buffer = (LPWSTR) MemAlloc( BytesNeeded );
    if (Buffer == NULL) {
        hr = ERROR_INSUFFICIENT_BUFFER;
        goto exit;
    }

    for (i=0; i<prws->cRows; i++) {

        pval = prws->aRow[i].lpProps;

        Count = MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            pval[0].Value.lpszA,
            -1,
            &Buffer[Offset],
            BytesNeeded - (Offset * sizeof(WCHAR))
            );

        if (Count == 0) {

            hr = GetLastError();

            goto exit;

        } else {

            Offset += Count;
        }

    }

    Buffer[Offset] = 0;

    *OutBuffer = Buffer;
    *OutBufferSize = BytesNeeded;

    hr = ERROR_SUCCESS;

exit:
    FreeProws( prws );

    if (pmt) {
        pmt->Release();
    }

    if (lpProfAdmin) {
        lpProfAdmin->Release();
    }

    return hr;
}

extern "C"
BOOL
GetDefaultMapiProfile(
    LPWSTR ProfileName
    )
{
    BOOL rVal = FALSE;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    LPPROFADMIN lpProfAdmin;
    DWORD i;
    DWORD j;

    if (!MapiIsInitialized) {
        goto exit;
    }

    if (MapiAdminProfiles( 0, &lpProfAdmin )) {
        goto exit;
    }

    //
    // get the mapi profile table object
    //

    if (lpProfAdmin->GetProfileTable( 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->QueryRows( 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles looking for the default profile
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        for (j = 0; j < 2; j++) {
            if (pval[j].ulPropTag == PR_DEFAULT_PROFILE && pval[j].Value.b) {
                //
                // this is the default profile
                //
                MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    pval[0].Value.lpszA,
                    -1,
                    ProfileName,
                    (cchProfileNameMax + 1) * sizeof(WCHAR)
                    );
                rVal = TRUE;
                break;
            }
        }
    }

exit:
    FreeProws( prws );

    if (pmt) {
        pmt->Release();
    }

    return rVal;
}


#define IADDRTYPE  0
#define IEMAILADDR 1
#define IMAPIRECIP 2
#define IPROXYADDR 3
#define PR_EMS_AB_CONTAINERID  PROP_TAG(PT_LONG, 0xFFFD)
#define PR_EMS_AB_PROXY_ADDRESSES_A PROP_TAG(PT_MV_STRING8, 0x800F)
#define MUIDEMSAB {0xDC, 0xA7, 0x40, 0xC8, 0xC0, 0x42, 0x10, 0x1A, 0xB4, 0xB9, 0x08, 0x00, 0x2B, 0x2F, 0xE1, 0x82}
#define CbNewFlagList(_cflag) (offsetof(FlagList,ulFlag) + (_cflag)*sizeof(ULONG))


HRESULT
HrMAPICreateSizedAddressList(        // RETURNS: return code
    IN ULONG cEntries,               // count of entries in address list
    OUT LPADRLIST *lppAdrList        // pointer to address list pointer
    )
{
    HRESULT         hr              = NOERROR;
    SCODE           sc              = 0;
    ULONG           cBytes          = 0;


    *lppAdrList = NULL;

    cBytes = CbNewADRLIST(cEntries);

    sc = MapiAllocateBuffer(cBytes, (PVOID*) lppAdrList);
    if(FAILED(sc))
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Initialize ADRLIST structure
    ZeroMemory(*lppAdrList, cBytes);

    (*lppAdrList)->cEntries = cEntries;

cleanup:

    return hr;
}


HRESULT
HrMAPISetAddressList(                // RETURNS: return code
    IN ULONG iEntry,                 // index of address list entry
    IN ULONG cProps,                 // count of values in address list entry
    IN LPSPropValue lpPropValues,    // pointer to address list entry
    IN OUT LPADRLIST lpAdrList       // pointer to address list pointer
    )
{
    HRESULT         hr              = NOERROR;
    SCODE           sc              = 0;
    LPSPropValue    lpNewPropValues = NULL;
    ULONG           cBytes          = 0;


    if(iEntry >= lpAdrList->cEntries)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    sc = pScDupPropset(
        cProps,
        lpPropValues,
        MapiAllocateBuffer,
        &lpNewPropValues
        );

    if(FAILED(sc))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    if(lpAdrList->aEntries[iEntry].rgPropVals != NULL)
    {
        MapiFreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
    }

    lpAdrList->aEntries[iEntry].cValues = cProps;
    lpAdrList->aEntries[iEntry].rgPropVals = lpNewPropValues;

cleanup:

    return hr;
}


HRESULT
HrCheckForTypeA(                // RETURNS: return code
    IN  LPCSTR lpszAddrType,    // pointer to address type
    IN  LPCSTR lpszProxy,       // pointer to proxy address
    OUT LPSTR * lppszAddress    // pointer to address pointer
    )
{
    HRESULT hr              = E_FAIL;
    LPCSTR  lpszProxyAddr   = NULL;
    ULONG   cbAddress       = 0;
    SCODE   sc              = 0;
    ULONG   cchProxy        = 0;
    ULONG   cchProxyType    = 0;


    // Initialize output parameter

    *lppszAddress = NULL;

    // find the ':' separator.

    cchProxy     = lstrlenA(lpszProxy);
    cchProxyType = strcspn(lpszProxy, ":");

    if((cchProxyType == 0) || (cchProxyType >= cchProxy))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    hr = MAPI_E_NOT_FOUND;

    // does the address type match?
    if((cchProxyType == (ULONG)lstrlenA(lpszAddrType)) &&
       (_strnicmp(lpszProxy, lpszAddrType, cchProxyType) == 0))
    {
        // specified address type found
        lpszProxyAddr = lpszProxy + cchProxyType + 1;

        cbAddress = strlen(lpszProxyAddr);

        // make a buffer to hold it.
        sc = MapiAllocateBuffer(cbAddress, (void **)lppszAddress);

        if(FAILED(sc))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(*lppszAddress, lpszProxyAddr, cbAddress);

            hr = NOERROR;
        }
    }

cleanup:

    return hr;
}


HRESULT
HrFindExchangeGlobalAddressList(
    IN  LPADRBOOK  lpAdrBook,
    OUT ULONG      *lpcbeid,
    OUT LPENTRYID  *lppeid
    )
{
    HRESULT         hr                  = NOERROR;
    ULONG           ulObjType           = 0;
    ULONG           i                   = 0;
    LPMAPIPROP      lpRootContainer     = NULL;
    LPMAPIPROP      lpContainer         = NULL;
    LPMAPITABLE     lpContainerTable    = NULL;
    LPSRowSet       lpRows              = NULL;
    ULONG           cbContainerEntryId  = 0;
    LPENTRYID       lpContainerEntryId  = NULL;
    LPSPropValue    lpCurrProp          = NULL;
    SRestriction    SRestrictAnd[2]     = {0};
    SRestriction    SRestrictGAL        = {0};
    SPropValue      SPropID             = {0};
    SPropValue      SPropProvider       = {0};
    BYTE            muid[]              = MUIDEMSAB;

    SizedSPropTagArray(1, rgPropTags) =
    {
        1,
        {
            PR_ENTRYID,
        }
    };


    *lpcbeid = 0;
    *lppeid  = NULL;

    // Open the root container of the address book
    hr = lpAdrBook->OpenEntry(
        0,
        NULL,
        NULL,
        MAPI_DEFERRED_ERRORS,
        &ulObjType,
        (LPUNKNOWN FAR *)&lpRootContainer
        );

    if(FAILED(hr))
    {
        goto cleanup;
    }

    if(ulObjType != MAPI_ABCONT)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the hierarchy table of the root container
    hr = ((LPABCONT)lpRootContainer)->GetHierarchyTable(
        MAPI_DEFERRED_ERRORS|CONVENIENT_DEPTH,
        &lpContainerTable
        );

    if(FAILED(hr))
    {
        goto cleanup;
    }

    // Restrict the table to the global address list (GAL)
    // ---------------------------------------------------

    // Initialize provider restriction to only Exchange providers

    SRestrictAnd[0].rt                          = RES_PROPERTY;
    SRestrictAnd[0].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[0].res.resProperty.ulPropTag   = PR_AB_PROVIDER_ID;
    SPropProvider.ulPropTag                     = PR_AB_PROVIDER_ID;

    SPropProvider.Value.bin.cb                  = 16;
    SPropProvider.Value.bin.lpb                 = (LPBYTE)muid;
    SRestrictAnd[0].res.resProperty.lpProp      = &SPropProvider;

    // Initialize container ID restriction to only GAL container

    SRestrictAnd[1].rt                          = RES_PROPERTY;
    SRestrictAnd[1].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[1].res.resProperty.ulPropTag   = PR_EMS_AB_CONTAINERID;
    SPropID.ulPropTag                           = PR_EMS_AB_CONTAINERID;
    SPropID.Value.l                             = 0;
    SRestrictAnd[1].res.resProperty.lpProp      = &SPropID;

    // Initialize AND restriction

    SRestrictGAL.rt                             = RES_AND;
    SRestrictGAL.res.resAnd.cRes                = 2;
    SRestrictGAL.res.resAnd.lpRes               = &SRestrictAnd[0];

    // Restrict the table to the GAL - only a single row should remain

    // Get the row corresponding to the GAL

        //
        //  Query all the rows
        //

        hr = pHrQueryAllRows(
            lpContainerTable,
                (LPSPropTagArray)&rgPropTags,
                &SRestrictGAL,
                NULL,
                0,
                &lpRows
                );

    if(FAILED(hr) || (lpRows == NULL) || (lpRows->cRows != 1))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the entry ID for the GAL

    lpCurrProp = &(lpRows->aRow[0].lpProps[0]);

    if(lpCurrProp->ulPropTag == PR_ENTRYID)
    {
        cbContainerEntryId = lpCurrProp->Value.bin.cb;
        lpContainerEntryId = (LPENTRYID)lpCurrProp->Value.bin.lpb;
    }
    else
    {
        hr = E_FAIL;
        goto cleanup;
    }

    hr = MapiAllocateBuffer( cbContainerEntryId, (LPVOID *)lppeid );

    if(FAILED(hr))
    {
        *lpcbeid = 0;
        *lppeid = NULL;
    }
    else
    {
        CopyMemory(
            *lppeid,
            lpContainerEntryId,
            cbContainerEntryId);

        *lpcbeid = cbContainerEntryId;
    }

cleanup:

    pUlRelease(lpRootContainer);
    pUlRelease(lpContainerTable);
    pUlRelease(lpContainer);
    FreeProws( lpRows );

    if(FAILED(hr)) {
        MapiFreeBuffer( *lppeid );
        *lpcbeid = 0;
        *lppeid = NULL;
    }

    return hr;
}


HRESULT
HrGWResolveProxy(
    IN  LPADRBOOK   lpAdrBook,      // pointer to address book
    IN  ULONG       cbeid,          // count of bytes in the entry ID
    IN  LPENTRYID   lpeid,          // pointer to the entry ID
    IN  LPCSTR      lpszAddrType,   // pointer to the address type
    OUT BOOL        *lpfMapiRecip,  // MAPI recipient
    OUT LPSTR       *lppszAddress   // pointer to the address pointer
    )
{
    HRESULT         hr              = E_FAIL;
    HRESULT         hrT             = 0;
    SCODE           sc              = 0;
    ULONG           i               = 0;
    ULONG           cbAddress       = 0;
    ULONG           cProxy          = 0;
    LPSPropValue    lpProps         = NULL;
    LPADRLIST       lpAdrList       = NULL;
    SPropValue      prop[2]         = {0};

    SizedSPropTagArray(4, rgPropTags) =
    {
        4,
        {
            PR_ADDRTYPE_A,
            PR_EMAIL_ADDRESS_A,
            PR_SEND_RICH_INFO,
            PR_EMS_AB_PROXY_ADDRESSES_A
        }
    };


    // Initialize output parameters

    *lpfMapiRecip = FALSE;
    *lppszAddress = NULL;

    hr = HrMAPICreateSizedAddressList(1, &lpAdrList);

    if(FAILED(hr))
    {
        goto cleanup;
    }

    prop[0].ulPropTag       = PR_ENTRYID;
    prop[0].Value.bin.cb    = cbeid;
    prop[0].Value.bin.lpb   = (LPBYTE)lpeid;
    prop[1].ulPropTag       = PR_RECIPIENT_TYPE;
    prop[1].Value.ul        = MAPI_TO;

    hr = HrMAPISetAddressList(
        0,
        2,
        prop,
        lpAdrList
        );

    if(FAILED(hr))
    {
        goto cleanup;
    }

    hrT = lpAdrBook->PrepareRecips(
        0,
        (LPSPropTagArray)&rgPropTags,
        lpAdrList
        );

    if(FAILED(hrT))
    {
        goto cleanup;
    }

    lpProps = lpAdrList->aEntries[0].rgPropVals;

    //
    //  Hack:  detect the case where prepare recips doesn't work correctly.
    //      This happens when trying to look up a recipient that is in
    //      a replicated directory but not in the local directory.
    //
    if (lpAdrList->aEntries[0].cValues == 3)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // If the given address type matches the PR_ADDRTYPE value,
    // return the PR_EMAIL_ADDRESS value

    if((PROP_TYPE(lpProps[IADDRTYPE].ulPropTag) != PT_ERROR) &&
       (PROP_TYPE(lpProps[IEMAILADDR].ulPropTag) != PT_ERROR) &&
       (_strcmpi(lpProps[IADDRTYPE].Value.lpszA, lpszAddrType) == 0))
    {
        cbAddress = strlen(lpProps[IEMAILADDR].Value.lpszA);

        sc = MapiAllocateBuffer(cbAddress, (void **)lppszAddress);

        if(FAILED(sc))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(*lppszAddress, lpProps[IEMAILADDR].Value.lpszW, cbAddress);
            hr = NOERROR;
        }

        goto cleanup;
    }

    // Search for a PR_EMS_AB_PROXY_ADDRESSES of the given type if present.

    else if(PROP_TYPE(lpProps[IPROXYADDR].ulPropTag) != PT_ERROR)
    {
        // count of proxy addresses
        cProxy = lpAdrList->aEntries[0].rgPropVals[IPROXYADDR].Value.MVszA.cValues;

        for(i = 0; i < cProxy; i++)
        {
            hr = HrCheckForTypeA(
                lpszAddrType,
                lpProps[IPROXYADDR].Value.MVszA.lppszA[i],
                lppszAddress
                );

            if(hr == MAPI_E_NOT_FOUND)
            {
                continue;
            }
            else if(FAILED(hr))
            {
                goto cleanup;
            }
            else
            {
                //
                // Found a matching proxy address.
                //

                goto cleanup;
            }
        }
    }
    else
    {
        hr = E_FAIL;
        goto cleanup;
    }

cleanup:

    if(SUCCEEDED(hr))
    {
        *lpfMapiRecip = lpAdrList->aEntries[0].rgPropVals[IMAPIRECIP].Value.b;
    }

    pFreePadrlist(lpAdrList);

    return hr;
}


HRESULT
HrGWResolveAddress(
    IN LPABCONT lpGalABCont,        // pointer to GAL container
    IN LPCSTR lpszAddress,          // pointer to proxy address
    OUT BOOL *lpfMapiRecip,         // MAPI recipient
    OUT ULONG *lpcbEntryID,         // count of bytes in entry ID
    OUT LPENTRYID *lppEntryID,      // pointer to entry ID
    OUT LPADRLIST *lpAdrList        // address list
    )
{
    HRESULT     hr          = NOERROR;
    HRESULT     hrT         = 0;
    SCODE       sc          = 0;
    LPFlagList  lpFlagList  = NULL;
    SPropValue  prop[2]     = {0};
    ULONG       cbEntryID   = 0;
    LPENTRYID   lpEntryID   = NULL;

    static const SizedSPropTagArray(2, rgPropTags) =
    { 2,
        {
            PR_ENTRYID,
            PR_SEND_RICH_INFO
        }
    };

    *lpfMapiRecip = FALSE;
    *lpcbEntryID  = 0;
    *lppEntryID   = NULL;
    *lpAdrList    = NULL;

    sc = MapiAllocateBuffer( CbNewFlagList(1), (LPVOID*)&lpFlagList);

    if(FAILED(sc))
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    lpFlagList->cFlags    = 1;
    lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

    hr = HrMAPICreateSizedAddressList(
        1,
        lpAdrList
        );
    if(FAILED(hr)) {
        goto cleanup;
    }

    prop[0].ulPropTag = PR_DISPLAY_NAME_A;
    prop[0].Value.lpszA = (LPSTR)lpszAddress;
    prop[1].ulPropTag = PR_RECIPIENT_TYPE;
    prop[1].Value.ul = MAPI_TO;

    hr = HrMAPISetAddressList(
        0,
        2,
        prop,
        *lpAdrList
        );
    if(FAILED(hr)) {
        goto cleanup;
    }

    hrT = lpGalABCont->ResolveNames(
        (LPSPropTagArray)&rgPropTags,
        0,
        *lpAdrList,
        lpFlagList
        );

    if(lpFlagList->ulFlag[0] != MAPI_RESOLVED)
    {
        if(lpFlagList->ulFlag[0] == MAPI_AMBIGUOUS)
        {
            hrT = MAPI_E_AMBIGUOUS_RECIP;
        }
        else
        {
            hrT = MAPI_E_NOT_FOUND;
        }
    }

    if(FAILED(hrT))
    {
        if(hrT == MAPI_E_NOT_FOUND)
        {
            hr = MAPI_E_NOT_FOUND;
        }
        else
        {
            hr = E_FAIL;
        }

        goto cleanup;
    }

    cbEntryID = (*lpAdrList)->aEntries[0].rgPropVals[0].Value.bin.cb;
    lpEntryID = (LPENTRYID)(*lpAdrList)->aEntries[0].rgPropVals[0].Value.bin.lpb;

    sc = MapiAllocateBuffer( cbEntryID, (LPVOID*)lppEntryID);

    if(FAILED(sc))
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    CopyMemory(*lppEntryID, lpEntryID, cbEntryID);
    *lpcbEntryID  = cbEntryID;
    *lpfMapiRecip = (*lpAdrList)->aEntries[0].rgPropVals[1].Value.b;

cleanup:

    MapiFreeBuffer(lpFlagList);

    return hr;
}


extern "C"
BOOL
MailMapiMessage(
    LPMAPISESSION   Session,
    LPWSTR          RecipientNameW,
    LPWSTR          MsgSubjectW,
    LPWSTR          MsgBodyW,
    LPWSTR          MsgAttachmentFileNameW,
    LPWSTR          MsgAttachmentTitleW,
    DWORD           MsgImportance,
    PULONG          ResultCode
    )

/*++

Routine Description:

    Mails a TIFF file to the addressbook recipient in the specified profile.

Arguments:

    TiffFileName            - Name of TIFF file to mail
    ProfileName             - Profile name to use
    ResultCode              - The result of the failed API call

Return Value:

    TRUE for success, FALSE on error

--*/

{
    ULONG               cbInEntryID = 0;
    LPENTRYID           lpInEntryID = NULL;
    LPMDB               Store       = NULL;
    ULONG               lpulObjType;
    LPMAPIFOLDER        Inbox       = NULL;
    LPMAPIFOLDER        Outbox      = NULL;
    LPMESSAGE           Message     = NULL;
    LPATTACH            Attach      = NULL;
    LPSTREAM            Stream      = NULL;
    ULONG               AttachmentNum;
    HRESULT             HResult     = 0;
    LPSTR               MsgAttachmentFileName = NULL;
    LPSTR               MsgAttachmentTitle = NULL;
    LPSTR               MsgBody = NULL;
    LPSTR               MsgSubject = NULL;
    LPSTR               BodyStrA = NULL;
    LPSTR               SubjectStrA = NULL;
    LPSTR               SenderStrA = NULL;
    LPSTR               LongFileNameA = NULL;
    LPSTR               RecipientName = NULL;
    DWORD               RenderingPosition = 0;
    LPADRBOOK           AddrBook;
    LPADRLIST           lpAddrList = NULL;
    ULONG               ulFlags = LOGOFF_PURGE;
    LPSPropProblemArray lppProblems;
    ULONG               cbGalEid = 0;
    LPENTRYID           lpGalEid = NULL;
    LPSTR               lpszProxyAddr = NULL;
    BOOL                fMapiRecip = FALSE;
    ULONG               ulObjType = 0;
    LPABCONT            lpGalABCont = NULL;
    ULONG               cbEntryID = 0;
    LPENTRYID           lpEntryID = NULL;
    SPropValue          spvAttachProps[5] = { 0 };
    SPropValue          spvMsgProps[5] = { 0 };
    CHAR                FileExt[_MAX_EXT];
    CHAR                FileName[MAX_PATH];
    HANDLE              hFile = INVALID_HANDLE_VALUE;


    _try {

        //
        // convert all of the strings to ansi strings
        //

        RecipientName = UnicodeStringToAnsiString( RecipientNameW );
        MsgSubject = UnicodeStringToAnsiString( MsgSubjectW );
        MsgBody = UnicodeStringToAnsiString( MsgBodyW );
        MsgAttachmentFileName = UnicodeStringToAnsiString( MsgAttachmentFileNameW );
        MsgAttachmentTitle = UnicodeStringToAnsiString( MsgAttachmentTitleW );


        HResult = Session->OpenAddressBook(
            0,
            NULL,
            AB_NO_DIALOG,
            &AddrBook
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = HrFindExchangeGlobalAddressList(
            AddrBook,
            &cbGalEid,
            &lpGalEid
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = AddrBook->OpenEntry(
            cbGalEid,
            lpGalEid,
            NULL,
            MAPI_DEFERRED_ERRORS,
            &ulObjType,
            (LPUNKNOWN FAR *)&lpGalABCont
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = HrGWResolveAddress(
            lpGalABCont,
            RecipientName,
            &fMapiRecip,
            &cbEntryID,
            &lpEntryID,
            &lpAddrList
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Find the default message store
        //
        HResult = HrMAPIFindDefaultMsgStore(
            Session,
            &cbInEntryID,
            &lpInEntryID
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Open it
        //
        HResult = Session->OpenMsgStore(
            (ULONG)0,
            cbInEntryID,
            lpInEntryID,
            NULL,
            MDB_NO_DIALOG | MDB_WRITE,
            &Store
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer(lpInEntryID);

        //
        // Find the outbox
        //
        HResult= HrMAPIFindOutbox(
            Store,
            &cbInEntryID,
            &lpInEntryID
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Open it
        //
        HResult = Store->OpenEntry(
            cbInEntryID,
            lpInEntryID,
            NULL,
            MAPI_MODIFY | MAPI_DEFERRED_ERRORS,
            &lpulObjType,
            (LPUNKNOWN *) &Outbox
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Create a message
        //
        HResult = Outbox->CreateMessage(
            NULL,
            0,
            &Message
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = Message->ModifyRecipients(
            0,
            lpAddrList
            );

        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Fill in message properties and set them
        //

        spvMsgProps[0].ulPropTag     = PR_SUBJECT;
        spvMsgProps[1].ulPropTag     = PR_MESSAGE_CLASS;
        spvMsgProps[2].ulPropTag     = PR_BODY;
        spvMsgProps[3].ulPropTag     = PR_IMPORTANCE;
        spvMsgProps[4].ulPropTag     = PR_DELETE_AFTER_SUBMIT;

        spvMsgProps[0].Value.lpszA   = MsgSubject;
        spvMsgProps[1].Value.lpszA   = "IPM.Note";
        spvMsgProps[2].Value.lpszA   = MsgBody;
        spvMsgProps[3].Value.ul      = MsgImportance;
        spvMsgProps[4].Value.ul      = TRUE;

        HResult = Message->SetProps(
            sizeof(spvMsgProps)/sizeof(SPropValue),
            (LPSPropValue) spvMsgProps,
            &lppProblems
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer( lppProblems );

        if (MsgAttachmentFileName) {

            //
            // Create an attachment
            //

            HResult = Message->CreateAttach(
                NULL,
                0,
                &AttachmentNum,
                &Attach
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            _splitpath( MsgAttachmentFileName, NULL, NULL, FileName, FileExt );
            strcat( FileName, FileExt );

            //
            // Fill in attachment properties and set them
            //

            if (!MsgAttachmentTitle) {
                MsgAttachmentTitle = FileName;
            }

            RenderingPosition = strlen(MsgBody);

            spvAttachProps[0].ulPropTag     = PR_RENDERING_POSITION;
            spvAttachProps[1].ulPropTag     = PR_ATTACH_METHOD;
            spvAttachProps[2].ulPropTag     = PR_ATTACH_LONG_FILENAME;
            spvAttachProps[3].ulPropTag     = PR_DISPLAY_NAME;
            spvAttachProps[4].ulPropTag     = PR_ATTACH_EXTENSION;

            spvAttachProps[0].Value.ul      = RenderingPosition;
            spvAttachProps[1].Value.ul      = ATTACH_BY_VALUE;
            spvAttachProps[2].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[3].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[4].Value.lpszA   = FileExt;

            HResult = Attach->SetProps(
                sizeof(spvAttachProps)/sizeof(SPropValue),
                (LPSPropValue) spvAttachProps,
                &lppProblems
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            MapiFreeBuffer( lppProblems );

            //
            // Attach a data property to the attachment
            //

            HResult = Attach->OpenProperty(
                PR_ATTACH_DATA_BIN,
                &IID_IStream,
                0,
                MAPI_CREATE | MAPI_MODIFY,
                (LPUNKNOWN *) &Stream
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            //
            // open the message attachment file
            //

            hFile = CreateFile(
                MsgAttachmentFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
            if (hFile == INVALID_HANDLE_VALUE) {
                _leave;
            }

            //
            // Write the file to the data property
            //

            HResult = HrMAPIWriteFileToStream( hFile, Stream );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            HResult = Attach->SaveChanges(
                FORCE_SAVE
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }
        }

        //
        // mail the message
        //
        HResult = Message->SubmitMessage(
            0
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = Store->StoreLogoff(
            &ulFlags
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

    }
    _finally {

        if (Store) {
            Store->Release();
        }
        if (Inbox) {
            Inbox->Release();
        }
        if (Message) {
            Message->Release();
        }
        if (Attach) {
            Attach->Release();
        }
        if (Stream) {
            Stream->Release();
        }
        if (AddrBook) {
            AddrBook->Release();
        }
        if (lpAddrList) {
            pFreePadrlist( lpAddrList );
        }

        if (lpEntryID) {
            MapiFreeBuffer( lpEntryID );
        }
        if (lpszProxyAddr) {
            MapiFreeBuffer( lpszProxyAddr );
        }
        if (lpInEntryID) {
            MapiFreeBuffer( lpInEntryID );
        }

        FreeString( MsgSubject );
        FreeString( MsgBody );
        FreeString( MsgAttachmentFileName );
        if (MsgAttachmentTitleW && MsgAttachmentTitle) {
            FreeString( MsgAttachmentTitle );
        }

        CloseHandle( hFile );
        goto exit;
    }
exit:
    *ResultCode = HResult;
    return HResult == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\routegroup.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    OutRoute.cpp

Abstract:

    This file provides implementation of the service
    outbound routing.

Author:

    Oded Sacher (OdedS)  Nov, 1999

Revision History:

--*/

#include "faxsvc.h"

BOOL
EnumOutboundRoutingGroupsCB(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID pContext
    );


inline
BOOL
IsDeviceInstalled (DWORD dwDeviceId)
{
    // Make sure to lock g_CsLine
    return (GetTapiLineFromDeviceId (dwDeviceId, FALSE)) ? TRUE : FALSE;
}

/************************************
*                                   *
*             Globals               *
*                                   *
************************************/

COutboundRoutingGroupsMap* g_pGroupsMap; // Map of group name to list of device IDs


/***********************************
*                                  *
*  COutboundRoutingGroup  Methodes *
*                                  *
***********************************/
DWORD
COutboundRoutingGroup::Load(HKEY hGroupKey, LPCWSTR lpcwstrGroupName)
/*++

Routine name : COutboundRoutingGroup::Load

Routine description:

    Loads an outboundrouting group's settings from the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hGroupKey           [in] - Handle to the opened registry key
    lpcwstrGroupName    [in] - Group name

Return Value:

    Standard Win32 error code

--*/
{
    LPBYTE lpBuffer = NULL;
    DWORD dwRes;
	DWORD dwType;
	DWORD dwSize=0;
	DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::Load"));

    Assert (hGroupKey);

    dwRes = RegQueryValueEx(
        hGroupKey,
        REGVAL_ROUTING_GROUP_DEVICES,
        NULL,
        &dwType,
        NULL,
        &dwSize
        );

    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegQueryValueEx  failed with %ld"),
            dwRes);
        goto exit;
    }
    if (REG_BINARY != dwType)
    {
        //
        // We expect only binary data here
        //
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading devices list, not a binary type"));
        dwRes = ERROR_BADDB;    // The configuration registry database is corrupt.
        goto exit;
    }

    if (0 != dwSize)
    {
        //
        // Allocate required buffer
        //
        lpBuffer = (LPBYTE) MemAlloc( dwSize );
        if (!lpBuffer)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate group devices buffer"));
            goto exit;
        }
        //
        // Read the data
        //
        dwRes = RegQueryValueEx(
            hGroupKey,
            REGVAL_ROUTING_GROUP_DEVICES,
            NULL,
            &dwType,
            lpBuffer,
            &dwSize
            );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegQueryValueEx failed with %ld"),
                dwRes);
            goto exit;
        }

        LPDWORD lpdwDevices = (LPDWORD)lpBuffer;
        DWORD dwNumDevices = dwSize/sizeof(DWORD);
        BOOL fDeviceInstalled = TRUE;

        for (i = 0; i < dwNumDevices; i++)
        {
            if (IsDeviceInstalled(lpdwDevices[i]))
            {
                //
                // Add the device only if it is installed
                //
                dwRes = AddDevice (lpdwDevices[i]);
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("COutboundRoutingGroup::AddDevice failed with %ld"),
                        dwRes);
                    goto exit;
                }
            }
            else
            {
                fDeviceInstalled = FALSE;
            }
        }

        if (FALSE == fDeviceInstalled)
        {
            //
            // Save the new configuration
            //
            DWORD ec = Save(hGroupKey);
            if (ERROR_SUCCESS != ec)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingGroup::Save failed with %ld"),
                    ec);
            }

            FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MED,
            1,
            MSG_BAD_OUTBOUND_ROUTING_GROUP_CONFIGURATION,
            lpcwstrGroupName
            );
        }
    }
    Assert (ERROR_SUCCESS == dwRes);

exit:
    MemFree (lpBuffer);
    return dwRes;
}


DWORD
COutboundRoutingGroup::GetStatus (FAX_ENUM_GROUP_STATUS* lpStatus) const
/*++

Routine name : COutboundRoutingGroup::GetStatus

Routine description:

    Retrieves the group status. Caller must lock g_CsConfig

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpStatus     [out] - Pointer to a FAX_ENUM_GROUP_STATUS to recieve the group status



Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::GetStatus"));
    DWORD dwNumDevices;

    Assert (lpStatus);

    try
    {
        if ((dwNumDevices = m_DeviceList.size()) == 0)
        {
            //
            // Empty group
            //
            *lpStatus = FAX_GROUP_STATUS_EMPTY;

        }
        else
        {
            //
            // We remove invalid devices from groups - All devices are valid.
            //
            *lpStatus = FAX_GROUP_STATUS_ALL_DEV_VALID;
        }
        return ERROR_SUCCESS;
    }

    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }
}  // GetStatus

DWORD
COutboundRoutingGroup::Save(HKEY hGroupKey) const
/*++

Routine name : COutboundRoutingGroup::Save

Routine description:

    Saves an outbound routing group to the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hGroupKey           [in] - Handle to the opened group registry key

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::Save"));
    DWORD   dwRes = ERROR_SUCCESS;
    LPDWORD lpdwDevices = NULL;
    DWORD dwNumDevices = 0;

    Assert (hGroupKey);

    dwRes = SerializeDevices (&lpdwDevices, &dwNumDevices);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingGroup::EnumDevices failed , ec %ld"), dwRes);
        goto exit;
    }

    if (!SetRegistryBinary( hGroupKey,
                            REGVAL_ROUTING_GROUP_DEVICES,
                            (LPBYTE) lpdwDevices,
                            dwNumDevices * sizeof(DWORD)))
    {
        dwRes = GetLastError();
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("SetRegistryBinary failed , ec %ld"), dwRes);
        goto exit;
    }

    Assert (dwRes == ERROR_SUCCESS);

exit:
    MemFree (lpdwDevices);
    return dwRes;
}


DWORD
COutboundRoutingGroup::SerializeDevices (LPDWORD* lppDevices, LPDWORD lpdwNumDevices, BOOL bAllocate) const
/*++

Routine name : COutboundRoutingGroup::SerializeDevices

Routine description:

    Serializes all group devices to an array. The caller must call MemFree to deallocate memory if bAllocate is TRUE.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lppDevices          [out] - Pointer to recieve the pointer to the allocated devices buffer.
                                If this parameter is NULL, lpdwNumDevices will return the numner of devices in the list.
    lpdwNumDevices      [out] - Pointer to a DWORD to recieve the number of devices in the buffer
    bAllocate           [in]  - Flag to indicate if the function should allocate the memory.

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::SerializeDevices"));
    DWORD   dwRes = ERROR_SUCCESS;
    GROUP_DEVICES::iterator it;
    DWORD dwCount = 0;

    Assert (lpdwNumDevices);

    if (NULL == lppDevices )
    {
        try
        {
            *lpdwNumDevices = m_DeviceList.size();
            return ERROR_SUCCESS;
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("list caused exception (%S)"),
                ex.what());
            return ERROR_GEN_FAILURE;
        }
    }

    if (bAllocate == TRUE)
    {
        *lppDevices = NULL;
    }

    try
    {
        dwCount = m_DeviceList.size();
        if (0 == dwCount)
        {
            *lppDevices = NULL;
            *lpdwNumDevices = 0;
            return dwRes;
        }

        if (TRUE == bAllocate)
        {
            *lppDevices = (LPDWORD) MemAlloc(dwCount * sizeof(DWORD));
            if (*lppDevices == NULL)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Cannot allocate devices buffer"));
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }

        dwCount = 0;
        for (it = m_DeviceList.begin(); it != m_DeviceList.end(); it++)
        {
            (*lppDevices)[dwCount++] = *it;
        }

        if (0 == dwCount)
        {
            *lppDevices = NULL;
        }
        *lpdwNumDevices = dwCount;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        if (bAllocate == TRUE)
        {
            MemFree (*lppDevices);
        }
        *lppDevices = NULL;
        *lpdwNumDevices = 0;
    }
    return dwRes;
}


BOOL
COutboundRoutingGroup::IsDeviceInGroup (DWORD dwDevice) const
/*++

Routine name : COutboundRoutingGroup::IsDeviceInGroup

Routine description:

    Check if device is in the group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwDevice            [in] - Permanent device ID

Return Value:

    BOOL. If the function fails, Call GetLastError for detailed info.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::IsDeviceInGroup"));
    GROUP_DEVICES::iterator location;
    BOOL bFound = FALSE;

    Assert (dwDevice);

    try
    {
        location = find(m_DeviceList.begin(), m_DeviceList.end(), dwDevice);
        if (location != m_DeviceList.end())
        {
            bFound = TRUE;
        }
        SetLastError (ERROR_SUCCESS);
        return bFound;

    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }
}

DWORD
COutboundRoutingGroup::AddDevice (DWORD dwDevice)
/*++

Routine name : COutboundRoutingGroup::AddDevice

Routine description:

    Adds a new device to group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwDevice            [in    ] - Permanent device ID

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::AddDevice"));
    GROUP_DEVICES::iterator it;
    DWORD dwRes;

    Assert (dwDevice);

    if (IsDeviceInGroup(dwDevice))
    {
        return ERROR_SUCCESS;
    }
    else
    {
        dwRes = GetLastError();
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRoutingGroup::IsDeviceInList failed, error %ld"),
                dwRes);
            return dwRes;
        }
    }

    //
    // Device not in list - Add it
    //
    try
    {
        if (!IsDeviceInstalled(dwDevice))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Device id: %ld is not installed."),
                dwDevice);
            return ERROR_BAD_UNIT;
        }
        m_DeviceList.push_back (dwDevice);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }

    return ERROR_SUCCESS;
}

DWORD
COutboundRoutingGroup::DelDevice (DWORD dwDevice)
/*++

Routine name : COutboundRoutingGroup::DelDevice

Routine description:

    Deletes a device from the group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwDevice            [in    ] - Permanent device ID

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::DelDevice"));
    GROUP_DEVICES::iterator location;
    BOOL bFound = FALSE;

    Assert (dwDevice);

    try
    {
        location = find(m_DeviceList.begin(), m_DeviceList.end(), dwDevice);
        if (location == m_DeviceList.end())
        {
            return ERROR_SUCCESS;
        }

        m_DeviceList.erase (location);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }
    return ERROR_SUCCESS;
}



DWORD
COutboundRoutingGroup::SetDevices (LPDWORD lpdwDevices, DWORD dwNumDevices, BOOL fAllDevicesGroup)
/*++

Routine name : COutboundRoutingGroup::SetDevices

Routine description:

    Sets a new device list to the group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpdwDevices         [in] - Pointer to a list of devices
    dwNumDevices        [in] - Number of devices in the list
    fAllDevicesGroup    [in] - TRUE if <All Devices> group.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::SetDevices"));

    dwRes = ValidateDevices( lpdwDevices, dwNumDevices, fAllDevicesGroup);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingGroup::ValidateDevices failed , ec %ld"), dwRes);
        return dwRes;
    }

    try
    {
        m_DeviceList.erase (m_DeviceList.begin(), m_DeviceList.end());

        for (DWORD i = 0; i < dwNumDevices; i++)
        {
         m_DeviceList.push_back (lpdwDevices[i]);
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
    }

    return dwRes;
}

DWORD
COutboundRoutingGroup::ValidateDevices (const LPDWORD lpdwDevices, DWORD dwNumDevices, BOOL fAllDevicesGroup) const
/*++

Routine name : COutboundRoutingGroup::ValidateDevices

Routine description:

    Validates a list of devices (No duplicates, All devices installed)

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpdwDevices         [in    ] - Pointer to alist of devices
    dwNumDevices            [in    ] - Number of devices in the list

Return Value:

    Standard Win32 error code

--*/
{
    set<DWORD> ValidationSet;
    pair < set<DWORD>::iterator, bool> p;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::ValidateDevices"));

    try
    {
        if (TRUE == fAllDevicesGroup)
        {
            //
            // <All Devices> group - validate that we do not miss or add a device.
            //
            if (m_DeviceList.size() != dwNumDevices)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("<All Devices> group contains diffrent number of devices, (old group - %ld, new group - %ld)"),
                    m_DeviceList.size(),
                    dwNumDevices);
                return FAX_ERR_BAD_GROUP_CONFIGURATION;
            }
        }

        for (DWORD i = 0; i < dwNumDevices; i++)
        {
            p = ValidationSet.insert(lpdwDevices[i]);
            if (p.second == FALSE)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Duplicate device IDs, ID = %ld"),
                    lpdwDevices[i]);
                return FAX_ERR_BAD_GROUP_CONFIGURATION;
            }


            if (!IsDeviceInstalled (lpdwDevices[i]))
            {
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Device ID %ld, is not installed"),
                        lpdwDevices[i]);
                return ERROR_BAD_UNIT;
            }
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("set caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }
    return ERROR_SUCCESS;
}


#if DBG
void COutboundRoutingGroup::Dump () const
{
    GROUP_DEVICES::iterator it;
    WCHAR Buffer[128] = {0};
    DWORD dwBufferSize = sizeof (Buffer)/ sizeof (Buffer[0]);

    for (it = m_DeviceList.begin(); it != m_DeviceList.end(); it++)
    {
        _snwprintf (Buffer, dwBufferSize - 1, TEXT("\tDevice ID = %ld \n"), *it);
        OutputDebugString (Buffer);
    }
    return;
}
#endif


DWORD
COutboundRoutingGroup::SetDeviceOrder (DWORD dwDevice, DWORD dwOrder)
/*++

Routine name : COutboundRoutingGroup::SetDeviceOrder

Routine description:

    Sest the order of a single device in a group of outbound routing devices.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwDevice        [in] - The device ID to be set
    dwOrder         [in] - The device new order

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroup::SetDeviceOrder"));
    GROUP_DEVICES::iterator it;
    DWORD i = 1;

    Assert (dwDevice);

    try
    {
        // Check if dwOrder is bigger than number of devices in the list
        if (dwOrder > m_DeviceList.size())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Device ID %ld, is not found in group"),
                dwDevice);
            return FAX_ERR_BAD_GROUP_CONFIGURATION;
        }

        it = find(m_DeviceList.begin(), m_DeviceList.end(), dwDevice);
        if (it == m_DeviceList.end())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Device ID %ld, is not found in group"),
                dwDevice);
            return FAX_ERR_BAD_GROUP_CONFIGURATION;
        }

        m_DeviceList.erase (it);

        for (i = 1, it = m_DeviceList.begin(); i < dwOrder; i++, it++)
        {
            ;
        }

        m_DeviceList.insert (it, dwDevice);
        return ERROR_SUCCESS;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("list caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }

}

/****************************************
*                                       *
*  COutboundRoutingGroupsMap  Methodes  *
*                                       *
****************************************/

DWORD
COutboundRoutingGroupsMap::Load ()
/*++

Routine name : COutboundRoutingGroupsMap::Load

Routine description:

    Loads all outbound routing groups from the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::Load"));
    DWORD   dwRes = ERROR_SUCCESS;
    HKEY    hGroupskey = NULL;
    DWORD dwCount = 0;

    hGroupskey = OpenRegistryKey( HKEY_LOCAL_MACHINE,
                                  REGKEY_FAX_OUTBOUND_ROUTING,
                                  FALSE,
                                  KEY_ALL_ACCESS );
    if (NULL == hGroupskey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey, error  %ld"),
            dwRes);
        return dwRes;
    }

    dwCount = EnumerateRegistryKeys( hGroupskey,
                                     REGKEY_OUTBOUND_ROUTING_GROUPS,
                                     TRUE,  // We might want to change values
                                     EnumOutboundRoutingGroupsCB,
                                     &dwRes
                                    );

    if (dwRes != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EnumerateRegistryKeys failed, error  %ld"),
            dwRes);
    }

    RegCloseKey (hGroupskey);
    return dwRes;
}


DWORD
COutboundRoutingGroupsMap::AddGroup (LPCWSTR lpcwstrGroupName, PCGROUP pCGroup)
/*++

Routine name : COutboundRoutingGroupsMap::AddGroup

Routine description:

    Add a new group to the global groups map

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpcwstrGroupName            [      ] - Group name
    pCGroup         [      ] - Pointer to a group object

Return Value:

    Standard Win32 error code
--*/
{
    GROUPS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::AddGroup"));
    pair <GROUPS_MAP::iterator, bool> p;

    Assert (pCGroup && lpcwstrGroupName);

    try
    {
        wstring wstrGroupName(lpcwstrGroupName);

        //
        // Add new map entry
        //
        p = m_GroupsMap.insert (GROUPS_MAP::value_type(wstrGroupName, *pCGroup));

        //
        // See if entry exists in map
        //
        if (p.second == FALSE)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Group %S is allready in the group map"), lpcwstrGroupName);
            dwRes = ERROR_DUP_NAME;
            goto exit;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
    }

exit:
    return dwRes;

}


DWORD
COutboundRoutingGroupsMap::DelGroup (LPCWSTR lpcwstrGroupName)
/*++

Routine name : COutboundRoutingGroupsMap::DelGroup

Routine description:

    Deletes a group from the global groups map

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpcwstrGroupName            [      ] - The group name

Return Value:

    Standard Win32 error code

--*/
{
    GROUPS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::DelGroup"));

    try
    {
        wstring wstrGroupName(lpcwstrGroupName);

        //
        // See if entry exists in map
        //
        if((it = m_GroupsMap.find(wstrGroupName)) == m_GroupsMap.end())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Group %S not is not in the group map"), lpcwstrGroupName);
            dwRes = FAX_ERR_GROUP_NOT_FOUND;
            goto exit;
        }

        //
        // Delete the map entry
        //
        m_GroupsMap.erase (it);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }
    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
}

PCGROUP
COutboundRoutingGroupsMap::FindGroup ( LPCWSTR lpcwstrGroupName ) const
/*++

Routine name : COutboundRoutingGroupsMap::FindGroup

Routine description:

    Returns a pointer to a group object specified by its name

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpcwstrGroupName            [in    ] - The group name

Return Value:

    Pointer to the found group object. If it is null the group was not found

--*/
{
    GROUPS_MAP::iterator it;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::FindGroup"));

    try
    {
        wstring wstrGroupName(lpcwstrGroupName);

        //
        // See if entry exists in map
        //
        if((it = m_GroupsMap.find(wstrGroupName)) == m_GroupsMap.end())
        {
            SetLastError (FAX_ERR_GROUP_NOT_FOUND);
            return NULL;
        }
        return &((*it).second);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        return NULL;
    }
}

#if DBG
void COutboundRoutingGroupsMap::Dump () const
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::Dump"));
    GROUPS_MAP::iterator it;
    WCHAR Buffer [512] = {0};
    DWORD dwBufferSize = sizeof (Buffer)/ sizeof (Buffer[0]);

    try
    {   _snwprintf (Buffer, dwBufferSize - 1, TEXT("DUMP - Outbound routing groups\n"));
        OutputDebugString (Buffer);

        for (it = m_GroupsMap.begin(); it != m_GroupsMap.end(); it++)
        {
            _snwprintf (Buffer, dwBufferSize - 1, TEXT("Group Name - %s\n"), ((*it).first).c_str());
            OutputDebugString (Buffer);
            ((*it).second).Dump();
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
    }
    return;
}
#endif


DWORD
COutboundRoutingGroupsMap::SerializeGroups (
    PFAX_OUTBOUND_ROUTING_GROUPW*       ppGroups,
    LPDWORD                             lpdwNumGroups,
    LPDWORD                             lpdwBufferSize) const
{
    GROUPS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::SerializeGroups"));
    DWORD dwSize = 0;
    DWORD dwNumDevices;
    DWORD dwCount = 0;
    LPCWSTR lpcwstrGroupName;
    PCGROUP pCGroup;

    Assert (ppGroups && lpdwNumGroups && lpdwBufferSize);

    *ppGroups = NULL;
    *lpdwNumGroups = 0;

    try
    {
        // Calculate buffer size
        for (it = m_GroupsMap.begin(); it != m_GroupsMap.end(); it++)
        {
            lpcwstrGroupName = ((*it).first).c_str();
            pCGroup = &((*it).second);

            dwSize += sizeof (FAX_OUTBOUND_ROUTING_GROUPW);
            dwSize += StringSizeW(lpcwstrGroupName);
            dwRes = pCGroup->SerializeDevices(NULL, &dwNumDevices);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingGroup::SerializeDevices failed,  error %ld"),
                    dwRes);
                goto exit;
            }
            dwSize += dwNumDevices * sizeof(DWORD);
            dwCount ++;
        }

        // Allocate buffer
        *ppGroups = (PFAX_OUTBOUND_ROUTING_GROUPW) MemAlloc (dwSize);
        if (NULL == *ppGroups)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Cannot allocate groups buffer"));
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        DWORD_PTR dwOffset = dwCount * sizeof (FAX_OUTBOUND_ROUTING_GROUPW);
        dwCount = 0;

        // Fill buffer with serialized info
        for (it = m_GroupsMap.begin(); it != m_GroupsMap.end(); it++)
        {
            lpcwstrGroupName = ((*it).first).c_str();
            pCGroup = &((*it).second);
            LPDWORD lpdwDevices;

            (*ppGroups)[dwCount].dwSizeOfStruct = sizeof (FAX_OUTBOUND_ROUTING_GROUPW);
            dwRes = pCGroup->GetStatus(&(*ppGroups)[dwCount].Status);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingGroup::GetStatus failed,  error %ld"),
                    dwRes);
                goto exit;
            }

            StoreString (lpcwstrGroupName,
                         (PULONG_PTR)&(*ppGroups)[dwCount].lpctstrGroupName,
                         (LPBYTE)*ppGroups,
                         &dwOffset);

            lpdwDevices = (LPDWORD)((LPBYTE)*ppGroups + dwOffset);

            dwRes = pCGroup->SerializeDevices(&lpdwDevices,
                                              &dwNumDevices,
                                              FALSE); // Do not allocate
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingGroup::SerializeDevices failed,  error %ld"),
                    dwRes);
                goto exit;
            }

            if (dwNumDevices != 0)
            {
                (*ppGroups)[dwCount].lpdwDevices = (LPDWORD)dwOffset;
                dwOffset +=  dwNumDevices * sizeof(DWORD);
            }
            else
            {
                (*ppGroups)[dwCount].lpdwDevices = NULL;
            }

            (*ppGroups)[dwCount].dwNumDevices = dwNumDevices;
            dwCount++;
        }

    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    *lpdwNumGroups = dwCount;
    *lpdwBufferSize = dwSize;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        MemFree (*ppGroups);
    }
    return dwRes;
}

BOOL
COutboundRoutingGroupsMap::UpdateAllDevicesGroup (void)
/*++

Routine name : COutboundRoutingGroupsMap::UpdateAllDevicesGroup

Routine description:

    Updates <All devices> group with installed devices

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    BOOL

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    PLIST_ENTRY Next;
    PLINE_INFO pLineInfo;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::UpdateAllDevicesGroup"));
    HKEY hGroupKey = NULL;
    LPDWORD lpdwDevices = NULL;
    DWORD dwNumDevices = 0;
    DWORD i;
    PCGROUP pCGroup;

    pCGroup = FindGroup (ROUTING_GROUP_ALL_DEVICESW);
    if (NULL == pCGroup)
    {
        dwRes = GetLastError();
        if (FAX_ERR_GROUP_NOT_FOUND != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingGroupsMap::FindGroup failed , ec %ld"), dwRes);
            return FALSE;
        }

        COutboundRoutingGroup CGroup;
        dwRes = AddGroup (ROUTING_GROUP_ALL_DEVICESW, &CGroup);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingGroup::AddGroup failed , ec %ld"), dwRes);
            SetLastError (dwRes);
            return FALSE;
        }

        pCGroup = FindGroup (ROUTING_GROUP_ALL_DEVICESW);
        if (NULL == pCGroup)
        {
            dwRes = GetLastError();
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingGroupsMap::FindGroup failed , ec %ld"), dwRes);
            return FALSE;
        }
    }

    dwRes = pCGroup->SerializeDevices (&lpdwDevices, &dwNumDevices);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingGroup::EnumDevices failed , ec %ld"), dwRes);
        SetLastError (dwRes);
        return FALSE;
    }

    EnterCriticalSection( &g_CsLine );
    Next = g_TapiLinesListHead.Flink;
    Assert (Next);

    //
    // Remove unavailable devices from the group
    //
    for (i = 0; i < dwNumDevices; i++)
    {
        if (IsDeviceInstalled (lpdwDevices[i]))
        {
            continue;
        }

        //
        // Device is not installed - remove it
        //
        dwRes = pCGroup->DelDevice (lpdwDevices[i]);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingGroup::DelDevice failed , ec %ld"), dwRes);
            goto exit;
        }
    }

    //
    // Add missing devices from TapiLinesList list
    //
    Next = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;
        Assert (Next && pLineInfo->PermanentLineID);

        dwRes = pCGroup->AddDevice (pLineInfo->PermanentLineID);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRoutingGroup::AddDevice failed, error %ld"),
                dwRes);
            goto exit;
        }
    }

    //
    // Save changes
    //
    hGroupKey = OpenOutboundGroupKey( ROUTING_GROUP_ALL_DEVICESW, TRUE, KEY_ALL_ACCESS );
    if (NULL == hGroupKey)
    {
      dwRes = GetLastError ();
      DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't create group key, OpenRegistryKey failed  : %ld"),
          dwRes);
      goto exit;
    }

    dwRes = pCGroup->Save (hGroupKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Save failed, Group name - %s,  failed with %ld"),
            ROUTING_GROUP_ALL_DEVICES,
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    MemFree (lpdwDevices);
    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }

    LeaveCriticalSection( &g_CsLine );
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
    }
    return (ERROR_SUCCESS == dwRes);
}


DWORD
COutboundRoutingGroupsMap::RemoveDevice (DWORD dwDeviceId)
/*++

Routine name : COutboundRoutingGroupsMap::RemoveDevice

Routine description:

    Deletes a device from all of the groups in the map

Author:

    Oded Sacher (OdedS),    Sep, 2000

Arguments:

    dwDeviceId            [in    ] - The device id to remove

Return Value:

    Standard Win32 error code

--*/
{
    GROUPS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hGroupKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingGroupsMap::RemoveDevice"));

    Assert (dwDeviceId);

    try
    {
        //
        // Delete the device from each group
        //
        for (it = m_GroupsMap.begin(); it != m_GroupsMap.end(); it++)
        {
            PCGROUP pCGroup = &((*it).second);
            LPCWSTR lpcwstrGroupName = ((*it).first).c_str();

            //
            // Open the group registry key
            //
            hGroupKey = OpenOutboundGroupKey( lpcwstrGroupName, FALSE, KEY_ALL_ACCESS );
            if (NULL == hGroupKey)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                  DEBUG_ERR,
                  TEXT("Can't open group key, OpenOutboundGroupKey failed  : %ld"),
                  dwRes);
                goto exit;
            }

            dwRes = pCGroup->DelDevice (dwDeviceId);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                  DEBUG_ERR,
                  TEXT("COutboundRoutingGroup::DelDevice failed  : %ld"),
                  dwRes);
                goto exit;
            }

            dwRes = pCGroup->Save(hGroupKey);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                  DEBUG_ERR,
                  TEXT("COutboundRoutingGroup::Save failed  : %ld"),
                  dwRes);
                goto exit;
            }

            RegCloseKey (hGroupKey);
            hGroupKey = NULL;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:

    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }
    return dwRes;
} // RemoveDevice



/************************************
*                                   *
*             Registry              *
*                                   *
************************************/
BOOL
EnumOutboundRoutingGroupsCB(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID pContext
    )
{
    DEBUG_FUNCTION_NAME(TEXT("EnumOutboundRoutingGroupsCB"));
    DWORD dwRes;
    COutboundRoutingGroup CGroup;
    BOOL bGroupDeleted = FALSE;

    if (!SubKeyName)
    {
        return TRUE;
    }

    if ((_wcsicmp (SubKeyName, ROUTING_GROUP_ALL_DEVICESW) != 0) &&
        IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs. Do not load group information.
        //
        return TRUE;
    }

    //
    // Add group
    //
    dwRes = CGroup.Load (hSubKey, SubKeyName);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Load failed, group name - %s, error %ld"),
            SubKeyName,
            dwRes);

        // Open Outbound Routing\Groups key
        HKEY hGroupsKey = OpenRegistryKey( HKEY_LOCAL_MACHINE,
                                           REGKEY_FAX_OUTBOUND_ROUTING_GROUPS,
                                           FALSE,
                                           KEY_ALL_ACCESS );
        if (NULL == hGroupsKey)
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenRegistryKey, error  %ld"),
                dwRes);
        }
        else
        {
            DWORD dwRetVal = RegDeleteKey (hGroupsKey, SubKeyName);
            if (ERROR_SUCCESS != dwRetVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("RegDeleteKey failed, Group name - %s,  error %ld"),
                    SubKeyName,
                    dwRetVal);
            }
            else
            {
                bGroupDeleted = TRUE;
            }
        }
        goto exit;
    }

    dwRes = g_pGroupsMap->AddGroup  (SubKeyName, &CGroup);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::AddGroup failed, group name - %s, error %ld"),
            SubKeyName,
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        if (bGroupDeleted == FALSE)
        {
            FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_OUTBOUND_ROUTING_GROUP_NOT_ADDED,
            SubKeyName
            );
        }
        else
        {
            FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_OUTBOUND_ROUTING_GROUP_NOT_LOADED,
                SubKeyName
                );
        }
    }
    *(LPDWORD)pContext = ERROR_SUCCESS; // Let the service start
    return TRUE; // Let the service start
}

/************************************
*                                   *
*         RPC handlers              *
*                                   *
************************************/

extern "C"
error_status_t
FAX_AddOutboundGroup (
    IN handle_t   hFaxHandle,
    IN LPCWSTR    lpwstrGroupName
    )
/*++

Routine name : FAX_AddOutboundGroup

Routine description:

    Adds a new Outbound routing group to the fax server

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - FaxServer handle
    lpwstrGroupName         [in    ] - The new group name

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_AddOutboundGroup"));
    HKEY hGroupKey = NULL;
    COutboundRoutingGroup CGroup;
    DWORD rVal;
    BOOL fAccess;

    Assert (lpwstrGroupName);

    if (_wcsicmp (lpwstrGroupName, ROUTING_GROUP_ALL_DEVICESW) == 0)
    {
        return ERROR_DUP_NAME;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    if (wcslen (lpwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        return ERROR_BUFFER_OVERFLOW;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsConfig); // Empty group, no need to lock g_CsLine

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before change"));
    g_pGroupsMap->Dump();
#endif

    hGroupKey = OpenOutboundGroupKey( lpwstrGroupName, TRUE, KEY_ALL_ACCESS );
    if (NULL == hGroupKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't create group key, OpenRegistryKey failed  : %ld"),
          dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    dwRes = g_pGroupsMap->AddGroup (lpwstrGroupName, &CGroup);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::AddGroup failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    dwRes = CGroup.Save (hGroupKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Save failed, Group name - %s,  failed with %ld"),
            lpwstrGroupName,
            dwRes);
        g_pGroupsMap->DelGroup (lpwstrGroupName);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before change"));
    g_pGroupsMap->Dump();
#endif

exit:
    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }
    LeaveCriticalSection (&g_CsConfig);

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);
}


extern "C"
error_status_t
FAX_SetOutboundGroup (
    IN handle_t                         hFaxHandle,
    IN PRPC_FAX_OUTBOUND_ROUTING_GROUPW pGroup
    )
/*++

Routine name : FAX_SetOutboundGroup

Routine description:

    Sets a new device list to an existing group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle      [in] - Fax server handle
    pGroup          [in] - Pointer to a PRPC_FAX_OUTBOUND_ROUTING_GROUPW contaning group info

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetOutboundGroup"));
    HKEY hGroupKey;
    PCGROUP pCGroup = NULL;
    COutboundRoutingGroup OldGroup;
    DWORD rVal;
    BOOL fAccess;
    BOOL fAllDevicesGroup = FALSE;

    Assert (pGroup);

    if (sizeof (FAX_OUTBOUND_ROUTING_GROUPW) != pGroup->dwSizeOfStruct)
    {
        //
        // Size mismatch
        //
       return ERROR_INVALID_PARAMETER;
    }

    if (!pGroup->lpwstrGroupName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (wcslen (pGroup->lpwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        return ERROR_BUFFER_OVERFLOW;
    }


    if (!pGroup->lpdwDevices && pGroup->dwNumDevices)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (_wcsicmp (pGroup->lpwstrGroupName, ROUTING_GROUP_ALL_DEVICESW) == 0)
    {
        //
        // If it is <All Devices> group we should validate that no device is missing,
        // and that the new group contains all installed devices.
        //
        fAllDevicesGroup = TRUE;
    }

    EnterCriticalSection (&g_CsLine);
    EnterCriticalSection (&g_CsConfig);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before change"));
    g_pGroupsMap->Dump();
#endif

    pCGroup = g_pGroupsMap->FindGroup (pGroup->lpwstrGroupName);
    if (!pCGroup)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::SetGroup failed, Group name - %s,  error %ld"),
            pGroup->lpwstrGroupName,
            dwRes);
        goto exit;
    }

    hGroupKey = OpenOutboundGroupKey( pGroup->lpwstrGroupName, FALSE, KEY_ALL_ACCESS );
    if (NULL == hGroupKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't create group key, OpenRegistryKey failed  : %ld"),
          dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    OldGroup = *pCGroup;

    dwRes = pCGroup->SetDevices (pGroup->lpdwDevices, pGroup->dwNumDevices, fAllDevicesGroup);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::SetDevices failed, Group name - %s,  failed with %ld"),
            pGroup->lpwstrGroupName,
            dwRes);
        goto exit;
    }

    dwRes = pCGroup->Save (hGroupKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Save failed, Group name - %s,  failed with %ld"),
            pGroup->lpwstrGroupName,
            dwRes);
        *pCGroup = OldGroup;
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before change"));
    g_pGroupsMap->Dump();
#endif

exit:
    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection (&g_CsLine);

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // We might find a line for a pending job. Wake up JobQueueThread
        //
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());

            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);
}


extern "C"
error_status_t
FAX_RemoveOutboundGroup (
    IN handle_t   hFaxHandle,
    IN LPCWSTR    lpwstrGroupName
    )
/*++

Routine name : FAX_RemoveOutboundGroup

Routine description:

    Removes an existing Outbound routing group from the fax server

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - FaxServer handle
    lpwstrGroupName         [in    ] - The group name

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_RemoveOutboundGroup"));
    HKEY hGroupsKey = NULL;
    DWORD rVal;
    BOOL fAccess;
    PCGROUP pCGroup = NULL;

    Assert (lpwstrGroupName);

    if (_wcsicmp (lpwstrGroupName, ROUTING_GROUP_ALL_DEVICESW) == 0)
    {
        return ERROR_INVALID_OPERATION;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    if (wcslen (lpwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        return ERROR_BUFFER_OVERFLOW;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsConfig);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before delete"));
    g_pGroupsMap->Dump();
#endif

    BOOL bGroupInRule;
    dwRes = g_pRulesMap->IsGroupInRuleDest(lpwstrGroupName, &bGroupInRule);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::IsGroupInRuleDest failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    if (TRUE == bGroupInRule)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Group is a rule destination, Can not be deleted, Group name - %s"),
            lpwstrGroupName);
        dwRes = FAX_ERR_GROUP_IN_USE;
        goto exit;
    }

    //
    // See if the group exists in the map
    //
    pCGroup = g_pGroupsMap->FindGroup (lpwstrGroupName);
    if (!pCGroup)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::SetGroup failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    // Open Outbound Routing\Groups key
    hGroupsKey = OpenRegistryKey( HKEY_LOCAL_MACHINE,
                                  REGKEY_FAX_OUTBOUND_ROUTING_GROUPS,
                                  FALSE,
                                  KEY_ALL_ACCESS );
    if (NULL == hGroupsKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey, error  %ld"),
            dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }


    // Delete the specified group key
    dwRes = RegDeleteKey (hGroupsKey, lpwstrGroupName);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegDeleteKey failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    // Delete the group from the memory
    dwRes = g_pGroupsMap->DelGroup (lpwstrGroupName);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::DelGroup failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -after delete"));
    g_pGroupsMap->Dump();
#endif

exit:
    if (NULL != hGroupsKey)
    {
        RegCloseKey (hGroupsKey);
    }
    LeaveCriticalSection (&g_CsConfig);

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);
} //FAX_RemoveOutboundGroup



error_status_t
FAX_EnumOutboundGroups (
    handle_t                             hFaxHandle,
    LPBYTE*                              ppBuffer,
    LPDWORD                              lpdwBufferSize,
    LPDWORD                              lpdwNumGroups
    )
/*++

Routine name : FAX_EnumOutboundGroups

Routine description:

    Enumurates all outbound routing groups

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - Fax server handle
    ppBuffer            [out   ] - Adress of a pointer to a buffer to be filled with info
    lpdwBufferSize          [in/out] - The buffer size
    lpdwNumGroups           [out   ] - Number of groups returned

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumOutboundGroups"));
    BOOL fAccess;

    Assert (lpdwNumGroups && lpdwNumGroups);    // ref pointer in idl
    if (!ppBuffer)                              // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    *ppBuffer = NULL;
    *lpdwNumGroups = 0;


    EnterCriticalSection (&g_CsConfig);

    dwRes = g_pGroupsMap->SerializeGroups ((PFAX_OUTBOUND_ROUTING_GROUPW*)ppBuffer,
                                         lpdwNumGroups,
                                         lpdwBufferSize);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::SerializeGroups failed, error %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);

}  //FAX_EnumOutboundGroups

error_status_t
FAX_SetDeviceOrderInGroup (
    handle_t           hFaxHandle,
    LPCWSTR            lpwstrGroupName,
    DWORD              dwDeviceId,
    DWORD              dwNewOrder
    )
/*++

Routine name : FAX_SetDeviceOrderInGroup

Routine description:

    Sets the order of the specified device in the group

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in] - Fax server handle
    lpwstrGroupName     [in] - The group name
    dwDeviceId          [in] - The device permanent ID
    dwNewOrder          [in] - The device new order

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetDeviceOrderInGroup"));
    HKEY hGroupKey = NULL;
    PCGROUP pCGroup = NULL;
    COutboundRoutingGroup OldGroup;
    DWORD rVal;
    BOOL fAccess;

    Assert (lpwstrGroupName);

    if (!dwDeviceId || !dwNewOrder)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (wcslen (lpwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsConfig);

    #if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -before changing order"));
    g_pGroupsMap->Dump();
#endif

    // Find the group in memory
    pCGroup = g_pGroupsMap->FindGroup (lpwstrGroupName);
    if (!pCGroup)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::FindGroup failed, Group name - %s,  error %ld"),
            lpwstrGroupName,
            dwRes);
        goto exit;
    }

    // Open the group registry key
    hGroupKey = OpenOutboundGroupKey( lpwstrGroupName, FALSE, KEY_ALL_ACCESS );
    if (NULL == hGroupKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't open group key, OpenOutboundGroupKey failed  : %ld"),
          dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    // Save a copy of the old group
    OldGroup = *pCGroup;

    // Cahnge the device order in the group
    dwRes = pCGroup->SetDeviceOrder(dwDeviceId, dwNewOrder);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::SetDeviceOrder failed, Group name - %s,\
                  Device Id %ld, new order %ld,   error %ld"),
            lpwstrGroupName,
            dwDeviceId,
            dwNewOrder,
            dwRes);
        goto exit;
    }

    // save changes to the registry
    dwRes = pCGroup->Save (hGroupKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Save failed, Group name - %s,  failed with %ld"),
            lpwstrGroupName,
            dwRes);
        // Rollback memory
        *pCGroup = OldGroup;
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing groups -after change"));
    g_pGroupsMap->Dump();
#endif

exit:
    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }
    LeaveCriticalSection (&g_CsConfig);

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);

}// FAX_SetDeviceOrderInGroup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\route.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    route.c

Abstract:

    This module implements the inbound routing rules.

Author:

    Wesley Witt (wesw) 1-Apr-1997

Revision History:

--*/

#include "faxsvc.h"
#include "tiff.h"
#pragma hdrstop

#include "..\faxroute\FaxRouteP.h"


extern DWORD FaxPrinters;

LIST_ENTRY g_lstRoutingExtensions;
LIST_ENTRY g_lstRoutingMethods;
DWORD g_dwCountRoutingMethods;
CFaxCriticalSection g_CsRouting;

LONG WINAPI
FaxRouteAddFile(
    IN DWORD JobId,
    IN LPCWSTR FileName,
    IN GUID *Guid
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    WCHAR FullPathName[MAX_PATH];
    LPWSTR fnp;
    DWORD Count;
    WCHAR RouteGuid[MAX_GUID_STRING_LEN];

    StringFromGUID2( *Guid, RouteGuid, MAX_GUID_STRING_LEN );

    if (!JobId || !Guid || !FileName) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return -1;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return -1;
    }

    if ((!IsEqualGUID(*Guid,gc_FaxSvcGuid)) && (!FindRoutingMethodByGuid(RouteGuid))) {
        SetLastError( ERROR_INVALID_DATA );
        return -1;
    }

    if (!GetFullPathName( FileName, sizeof(FullPathName)/sizeof(WCHAR), FullPathName, &fnp )) {
        return -1;
    }

    FaxRouteFile = (PFAX_ROUTE_FILE) MemAlloc( sizeof(FAX_ROUTE_FILE) );
    if (!FaxRouteFile) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return -1;
    }

    FaxRouteFile->FileName = StringDup( FullPathName );

    CopyMemory( &FaxRouteFile->Guid, Guid, sizeof(GUID) );

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    InsertTailList( &JobQueueEntry->FaxRouteFiles, &FaxRouteFile->ListEntry );

    LeaveCriticalSection( &JobQueueEntry->CsFileList );

    //
    // increment file count
    //
    EnterCriticalSection( &g_CsJob );
        EnterCriticalSection( &g_CsQueue );
            JobQueueEntry->CountFaxRouteFiles += 1;
            Count = JobQueueEntry->CountFaxRouteFiles;
        LeaveCriticalSection( &g_CsQueue );
    LeaveCriticalSection( &g_CsJob );



    return Count;
}


LONG WINAPI
FaxRouteDeleteFile(
    IN DWORD JobId,
    IN LPCWSTR FileName
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    LONG Index = 1;

    if (!FileName) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return -1;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return -1;
    }

    Next = JobQueueEntry->FaxRouteFiles.Flink;
    if (Next == &JobQueueEntry->FaxRouteFiles) {
        SetLastError( ERROR_NO_MORE_FILES );
        return -1;
    }

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueueEntry->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        if (_wcsicmp( FileName, FaxRouteFile->FileName ) == 0) {
            //
            // the initial file is read-only for all extensions
            //
            if (Index == 1) {
                SetLastError( ERROR_INVALID_DATA );
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                return -1;
            }

            //
            // remove from list, delete the file, cleanup memory
            //
            RemoveEntryList( &FaxRouteFile->ListEntry );
            DeleteFile( FaxRouteFile->FileName );
            MemFree ( FaxRouteFile->FileName ) ;
            MemFree ( FaxRouteFile );

            //
            // decrement file count
            //
            LeaveCriticalSection( &JobQueueEntry->CsFileList );
            EnterCriticalSection( &g_CsJob );
                EnterCriticalSection( &g_CsQueue );
                    JobQueueEntry->CountFaxRouteFiles -= 1;
                LeaveCriticalSection( &g_CsQueue );
            LeaveCriticalSection( &g_CsJob );

            return Index;
        }
        Index += 1;
    }

    LeaveCriticalSection( &JobQueueEntry->CsFileList );
    SetLastError( ERROR_FILE_NOT_FOUND );
    return -1;

}


BOOL WINAPI
FaxRouteGetFile(
    IN DWORD JobId,
    IN DWORD FileNumber,
    OUT LPWSTR FileNameBuffer,
    OUT LPDWORD RequiredSize
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    ULONG Index = 1;

    if (RequiredSize == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    if (JobQueueEntry->CountFaxRouteFiles < Index) {
        SetLastError( ERROR_INVALID_DATA );
    }

    Next = JobQueueEntry->FaxRouteFiles.Flink;
    //
    // make sure list isn't empty
    //
    if (Next == &JobQueueEntry->FaxRouteFiles) {
        SetLastError( ERROR_NO_MORE_FILES );
        return FALSE;
    }

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueueEntry->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        if (Index ==  FileNumber) {
            if (*RequiredSize < (wcslen(FaxRouteFile->FileName)+1)*sizeof(WCHAR)) {
                if (FileNameBuffer == NULL) {
                    *RequiredSize = (wcslen(FaxRouteFile->FileName) + 1)*sizeof(WCHAR);
                }
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                return FALSE;
            } else if (FileNameBuffer) {
                wcscpy( FileNameBuffer, FaxRouteFile->FileName );
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                return TRUE;
            } else {
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                SetLastError( ERROR_INVALID_PARAMETER );
                return TRUE;
            }
        }
        Index += 1;
    }

    LeaveCriticalSection( &JobQueueEntry->CsFileList );
    SetLastError( ERROR_NO_MORE_FILES );

    return FALSE;
}


BOOL WINAPI
FaxRouteEnumFiles(
    IN DWORD JobId,
    IN GUID *Guid,
    IN PFAXROUTEENUMFILE FileEnumerator,
    IN PVOID Context
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;

    if (!FileEnumerator) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    Next = JobQueueEntry->FaxRouteFiles.Flink;
    if (Next == &JobQueueEntry->FaxRouteFiles) {
        SetLastError( ERROR_NO_MORE_FILES );
        return FALSE;
    }

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueueEntry->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        if (!FileEnumerator( JobId, &FaxRouteFile->Guid, Guid, FaxRouteFile->FileName, Context )) {
            LeaveCriticalSection( &JobQueueEntry->CsFileList );
            return FALSE;
        }
    }

    LeaveCriticalSection( &JobQueueEntry->CsFileList );

    SetLastError( ERROR_NO_MORE_FILES );
    return TRUE;
}


PROUTING_METHOD
FindRoutingMethodByGuid(
    IN LPCWSTR RoutingGuidString
    )
{
    PLIST_ENTRY         pNextMethod;
    PROUTING_METHOD     pRoutingMethod;
    GUID                RoutingGuid;


    IIDFromString( (LPWSTR)RoutingGuidString, &RoutingGuid );

    EnterCriticalSection( &g_CsRouting );

    pNextMethod = g_lstRoutingMethods.Flink;
    if (pNextMethod == NULL)
    {
        LeaveCriticalSection( &g_CsRouting );
        return NULL;
    }

    while ((ULONG_PTR)pNextMethod != (ULONG_PTR)&g_lstRoutingMethods) {
        pRoutingMethod = CONTAINING_RECORD( pNextMethod, ROUTING_METHOD, ListEntryMethod );
        pNextMethod = pRoutingMethod->ListEntryMethod.Flink;
        if (IsEqualGUID( RoutingGuid, pRoutingMethod->Guid ))
        {
            LeaveCriticalSection( &g_CsRouting );
            return pRoutingMethod;
        }
    }

    LeaveCriticalSection( &g_CsRouting );
    return NULL;
}


DWORD
EnumerateRoutingMethods(
    IN PFAXROUTEMETHODENUM Enumerator,
    IN LPVOID Context
    )
{
    PLIST_ENTRY         pNextMethod;
    PROUTING_METHOD     pRoutingMethod;
    DWORD               dwCount = 0;

    EnterCriticalSection( &g_CsRouting );

    __try {

        pNextMethod = g_lstRoutingMethods.Flink;
        Assert(pNextMethod != NULL);

        while ((ULONG_PTR)pNextMethod != (ULONG_PTR)&g_lstRoutingMethods)
        {
            pRoutingMethod = CONTAINING_RECORD( pNextMethod, ROUTING_METHOD, ListEntryMethod );
            pNextMethod = pRoutingMethod->ListEntryMethod.Flink;
            if (!Enumerator( pRoutingMethod, Context ))
            {
                LeaveCriticalSection( &g_CsRouting );
                SetLastError(ERROR_INVALID_FUNCTION);
                return dwCount;
            }
            dwCount += 1;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrint(( TEXT("EnumerateRoutingMethods crashed, ec = %x\n"), GetExceptionCode() ));
        SetLastError(ERROR_INVALID_FUNCTION);
    }

    LeaveCriticalSection( &g_CsRouting );
    SetLastError(ERROR_SUCCESS);
    return dwCount;
}


BOOL
FaxRouteModifyRoutingData(
    DWORD JobId,
    LPCWSTR RoutingGuid,
    LPBYTE RoutingData,
    DWORD RoutingDataSize
    )
{
    PJOB_QUEUE JobQueueEntry = NULL;
    PROUTING_METHOD RoutingMethod = NULL;
    PROUTING_DATA_OVERRIDE RoutingDataOverride = NULL;


    if (JobId == 0 || RoutingGuid == NULL || RoutingData == NULL || RoutingDataSize == 0) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    RoutingMethod = FindRoutingMethodByGuid( RoutingGuid );
    if (RoutingMethod == NULL) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    RoutingDataOverride = (PROUTING_DATA_OVERRIDE) MemAlloc( sizeof(ROUTING_DATA_OVERRIDE) );
    if (RoutingDataOverride == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    RoutingDataOverride->RoutingData = (LPBYTE)MemAlloc( RoutingDataSize );
    if (RoutingDataOverride->RoutingData == NULL) {
        MemFree( RoutingDataOverride );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    RoutingDataOverride->RoutingDataSize = RoutingDataSize;
    RoutingDataOverride->RoutingMethod = RoutingMethod;

    CopyMemory( RoutingDataOverride->RoutingData, RoutingData, RoutingDataSize );

    EnterCriticalSection( &JobQueueEntry->CsRoutingDataOverride );
    InsertTailList( &JobQueueEntry->RoutingDataOverride, &RoutingDataOverride->ListEntry );
    LeaveCriticalSection( &JobQueueEntry->CsRoutingDataOverride );

    return TRUE;
}


int
__cdecl
MethodPriorityCompare(
    const void *arg1,
    const void *arg2
    )
{
    if (((PMETHOD_SORT)arg1)->Priority < ((PMETHOD_SORT)arg2)->Priority) {
        return -1;
    }
    if (((PMETHOD_SORT)arg1)->Priority > ((PMETHOD_SORT)arg2)->Priority) {
        return 1;
    }
    return 0;
}


BOOL
SortMethodPriorities(
    VOID
    )
{
    PLIST_ENTRY pNext;
    PROUTING_METHOD pRoutingMethod;
    PMETHOD_SORT pMethodSort;
    DWORD i;

    EnterCriticalSection( &g_CsRouting );

    pNext = g_lstRoutingMethods.Flink;
    if (pNext == NULL)
    {
        LeaveCriticalSection( &g_CsRouting );
        return FALSE;
    }

    pMethodSort = (PMETHOD_SORT) MemAlloc( g_dwCountRoutingMethods * sizeof(METHOD_SORT) );
    if (pMethodSort == NULL)
    {
        LeaveCriticalSection( &g_CsRouting );
        return FALSE;
    }

    i = 0;

    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_lstRoutingMethods)
    {
        pRoutingMethod = CONTAINING_RECORD( pNext, ROUTING_METHOD, ListEntryMethod );
        pNext = pRoutingMethod->ListEntryMethod.Flink;
        pMethodSort[i].Priority = pRoutingMethod->Priority;
        pMethodSort[i].RoutingMethod = pRoutingMethod;
        i += 1;
    }

    qsort(
        (PVOID)pMethodSort,
        (int)g_dwCountRoutingMethods,
        sizeof(METHOD_SORT),
        MethodPriorityCompare
        );

    InitializeListHead( &g_lstRoutingMethods );

    for (i=0; i<g_dwCountRoutingMethods; i++)
    {
        pMethodSort[i].RoutingMethod->Priority = i + 1;
        pMethodSort[i].RoutingMethod->ListEntryMethod.Flink = NULL;
        pMethodSort[i].RoutingMethod->ListEntryMethod.Blink = NULL;
        InsertTailList( &g_lstRoutingMethods, &pMethodSort[i].RoutingMethod->ListEntryMethod );
    }

    MemFree( pMethodSort );

    LeaveCriticalSection( &g_CsRouting );

    return TRUE;
}

BOOL
CommitMethodChanges(
    VOID
    )
/*++

Routine Description:

    sticks changes to routing into the registry

Arguments:

    NONE

Return Value:

    TRUE for success

--*/
{
    PLIST_ENTRY pNext;
    PROUTING_METHOD pRoutingMethod;
    TCHAR StrGuid[100];

    __try
    {
        EnterCriticalSection(&g_CsRouting);

        pNext = g_lstRoutingMethods.Flink;

        while ((UINT_PTR)pNext != (UINT_PTR)&g_lstRoutingMethods)
        {
            pRoutingMethod = CONTAINING_RECORD( pNext, ROUTING_METHOD , ListEntryMethod );
            pNext = pRoutingMethod->ListEntryMethod.Flink;

            StringFromGUID2( pRoutingMethod->Guid,
                             StrGuid,
                             sizeof(StrGuid)/sizeof(TCHAR)
                            );

            SetFaxRoutingInfo( pRoutingMethod->RoutingExtension->InternalName,
                               pRoutingMethod->InternalName,
                               StrGuid,
                               pRoutingMethod->Priority,
                               pRoutingMethod->FunctionName,
                               pRoutingMethod->FriendlyName
                            );
        }

        LeaveCriticalSection(&g_CsRouting);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        LeaveCriticalSection(&g_CsRouting);
    }
    return TRUE;
}

static
void
FreeRoutingMethod(
    PROUTING_METHOD pRoutingMethod
    )
{
    Assert (pRoutingMethod);

    MemFree(pRoutingMethod->FriendlyName);
    MemFree(pRoutingMethod->FunctionName);
    MemFree(pRoutingMethod->InternalName);
    MemFree(pRoutingMethod);
    return;
}

static
void
FreeRoutingExtension(
    PROUTING_EXTENSION  pRoutingExtension
    )
{
    DEBUG_FUNCTION_NAME(TEXT("FreeRoutingExtension"));

    Assert (pRoutingExtension);

    if (pRoutingExtension->hModule)
    {

        __try{
            FreeLibrary (pRoutingExtension->hModule);
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FreeLibrary() caused exception( %ld) "),
                GetExceptionCode()
            );
        }

    }

    if (pRoutingExtension->HeapHandle &&
        FALSE == pRoutingExtension->MicrosoftExtension)
    {
        HeapDestroy(pRoutingExtension->HeapHandle);
    }

    MemFree(pRoutingExtension);
    return;
}

void
FreeRoutingExtensions(
    void
    )
{
    PLIST_ENTRY         pNext;
    PROUTING_EXTENSION  pRoutingExtension;
    PROUTING_METHOD  pRoutingMethod;

    //
    // Free routing methods
    //
    pNext = g_lstRoutingMethods.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_lstRoutingMethods)
    {
        pRoutingMethod = CONTAINING_RECORD( pNext, ROUTING_METHOD, ListEntryMethod );
        pNext = pRoutingMethod->ListEntryMethod.Flink;
        RemoveEntryList(&pRoutingMethod->ListEntryMethod);
        FreeRoutingMethod(pRoutingMethod);
    }

    //
    // Free routing extensions
    //
    pNext = g_lstRoutingExtensions.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_lstRoutingExtensions)
    {
        pRoutingExtension = CONTAINING_RECORD( pNext, ROUTING_EXTENSION, ListEntry );
        pNext = pRoutingExtension->ListEntry.Flink;
        RemoveEntryList(&pRoutingExtension->ListEntry);
        FreeRoutingExtension(pRoutingExtension);
    }
    return;
}

BOOL
InitializeRouting(
    PREG_FAX_SERVICE pFaxReg
    )

/*++

Routine Description:

    Initializes routing

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    DWORD i,j;
    DWORD dwRes;
    BOOL bRes;
    PROUTING_EXTENSION pRoutingExtension;
    PROUTING_METHOD pRoutingMethod;
    FAX_ROUTE_CALLBACKROUTINES Callbacks;
    FAX_ROUTE_CALLBACKROUTINES_P Callbacks_private;
    HRESULT hr = NOERROR;
    PLIST_ENTRY ple;
    DEBUG_FUNCTION_NAME(TEXT("InitializeRouting"));

    Callbacks.SizeOfStruct              = sizeof(FAX_ROUTE_CALLBACKROUTINES);
    Callbacks.FaxRouteAddFile           = FaxRouteAddFile;
    Callbacks.FaxRouteDeleteFile        = FaxRouteDeleteFile;
    Callbacks.FaxRouteGetFile           = FaxRouteGetFile;
    Callbacks.FaxRouteEnumFiles         = FaxRouteEnumFiles;
    Callbacks.FaxRouteModifyRoutingData = FaxRouteModifyRoutingData;

    Callbacks_private.SizeOfStruct              = sizeof(FAX_ROUTE_CALLBACKROUTINES_P);
    Callbacks_private.FaxRouteAddFile           = FaxRouteAddFile;
    Callbacks_private.FaxRouteDeleteFile        = FaxRouteDeleteFile;
    Callbacks_private.FaxRouteGetFile           = FaxRouteGetFile;
    Callbacks_private.FaxRouteEnumFiles         = FaxRouteEnumFiles;
    Callbacks_private.FaxRouteModifyRoutingData = FaxRouteModifyRoutingData;
    Callbacks_private.GetRecieptsConfiguration  = GetRecieptsConfiguration;
    Callbacks_private.FreeRecieptsConfiguration = FreeRecieptsConfiguration;

    for (i = 0; i < pFaxReg->RoutingExtensionsCount; i++)
    {
        HMODULE hModule = NULL;
        WCHAR wszImageFileName[_MAX_FNAME] = {0};
        WCHAR wszImageFileExt[_MAX_EXT] = {0};

        pRoutingExtension = (PROUTING_EXTENSION) MemAlloc( sizeof(ROUTING_EXTENSION) );
        if (!pRoutingExtension)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Could not allocate memory for routing extension %s"),
                pFaxReg->RoutingExtensions[i].ImageName );
            goto InitializationFailed;
        }
        memset(pRoutingExtension, 0, sizeof(ROUTING_EXTENSION));
        InitializeListHead( &pRoutingExtension->RoutingMethods );
        //
        // Copy registry constant info
        //
        wcsncpy( pRoutingExtension->FriendlyName,
                 pFaxReg->RoutingExtensions[i].FriendlyName ?
                    pFaxReg->RoutingExtensions[i].FriendlyName : EMPTY_STRING ,
                 sizeof (pRoutingExtension->FriendlyName) / sizeof (TCHAR) );
        pRoutingExtension->FriendlyName[(sizeof (pRoutingExtension->FriendlyName) / sizeof (TCHAR)) - 1] = TEXT('\0');
        wcsncpy( pRoutingExtension->ImageName,
                 pFaxReg->RoutingExtensions[i].ImageName ?
                    pFaxReg->RoutingExtensions[i].ImageName : EMPTY_STRING,
                 sizeof (pRoutingExtension->ImageName) / sizeof (TCHAR) );
        pRoutingExtension->ImageName[(sizeof (pRoutingExtension->ImageName) / sizeof (TCHAR)) - 1] = TEXT('\0');
        wcsncpy( pRoutingExtension->InternalName,
                 pFaxReg->RoutingExtensions[i].InternalName ?
                    pFaxReg->RoutingExtensions[i].InternalName : EMPTY_STRING,
                 sizeof (pRoutingExtension->InternalName) / sizeof (TCHAR) );
        pRoutingExtension->InternalName[(sizeof (pRoutingExtension->InternalName) / sizeof (TCHAR)) - 1] = TEXT('\0');

        _wsplitpath( pRoutingExtension->ImageName, NULL, NULL, wszImageFileName, wszImageFileExt );
        if (_wcsicmp( wszImageFileName, FAX_ROUTE_MODULE_NAME ) == 0 &&
            _wcsicmp( wszImageFileExt, TEXT(".DLL") ) == 0)
        {
            pRoutingExtension->MicrosoftExtension = TRUE;
        }

        __try
        {
            hModule = LoadLibrary( pFaxReg->RoutingExtensions[i].ImageName );
            if (!hModule)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                        DEBUG_WRN,
                        TEXT("LoadLibrary() failed: [%s], ec=%d"),
                        pFaxReg->RoutingExtensions[i].ImageName,
                        dwRes);
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_LOAD;
                pRoutingExtension->dwLastError = dwRes;
                goto InitializationFailed;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
                dwRes = GetExceptionCode ();
                DebugPrintEx(
                        DEBUG_WRN,
                        TEXT("LoadLibrary() caused exception ( %ld) for provider's [%s] dll"),
                        dwRes,
                        pFaxReg->RoutingExtensions[i].ImageName
                        );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_LOAD;
                pRoutingExtension->dwLastError = dwRes;
                goto InitializationFailed;
        }

        pRoutingExtension->hModule = hModule;

        //
        // Retrieve the routing extension's version from the DLL
        //
        pRoutingExtension->Version.dwSizeOfStruct = sizeof (FAX_VERSION);
        dwRes = GetFileVersion ( pFaxReg->RoutingExtensions[i].ImageName,
                                 &pRoutingExtension->Version);
        if (ERROR_SUCCESS != dwRes)
        {
            //
            // If the routing extension's DLL does not have version data or the
            // version data is non-retrievable, we consider this a
            // warning (debug print) but carry on with the DLL's load.
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetFileVersion() failed: [%s] (ec: %ld)"),
                pFaxReg->RoutingExtensions[i].ImageName,
                dwRes);
        }

        pRoutingExtension->FaxRouteInitialize = (PFAXROUTEINITIALIZE) GetProcAddress(
            hModule,
            "FaxRouteInitialize"
            );

        pRoutingExtension->FaxRouteGetRoutingInfo = (PFAXROUTEGETROUTINGINFO) GetProcAddress(
            hModule,
            "FaxRouteGetRoutingInfo"
            );

        pRoutingExtension->FaxRouteSetRoutingInfo = (PFAXROUTESETROUTINGINFO) GetProcAddress(
            hModule,
            "FaxRouteSetRoutingInfo"
            );

        pRoutingExtension->FaxRouteDeviceEnable = (PFAXROUTEDEVICEENABLE) GetProcAddress(
            hModule,
            "FaxRouteDeviceEnable"
            );

        pRoutingExtension->FaxRouteDeviceChangeNotification = (PFAXROUTEDEVICECHANGENOTIFICATION) GetProcAddress(
            hModule,
            "FaxRouteDeviceChangeNotification"
            );

        if (pRoutingExtension->FaxRouteInitialize == NULL ||
            pRoutingExtension->FaxRouteGetRoutingInfo == NULL ||
            pRoutingExtension->FaxRouteSetRoutingInfo == NULL ||
            pRoutingExtension->FaxRouteDeviceChangeNotification == NULL ||
            pRoutingExtension->FaxRouteDeviceEnable == NULL)
        {
            //
            // the routing extension dll does not have a complete export list
            //
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Routing extension FAILED to initialized [%s], ec=%ld"),
                pFaxReg->RoutingExtensions[i].FriendlyName,
                dwRes);
            pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_LINK;
            pRoutingExtension->dwLastError = dwRes;
            goto InitializationFailed;
        }
        //
        // Link to the extension configuration and notification init functions
        //
        pRoutingExtension->pFaxExtInitializeConfig = (PFAX_EXT_INITIALIZE_CONFIG) GetProcAddress(
            hModule,
            "FaxExtInitializeConfig"
            );
        if (!pRoutingExtension->pFaxExtInitializeConfig)
        {
            //
            // Optional function
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("FaxExtInitializeConfig() not found for routing extension %s. This is not an error."),
                pRoutingExtension->FriendlyName);
        }
        //
        // create the routing extension's heap and add it to the list
        //
        pRoutingExtension->HeapHandle = pRoutingExtension->MicrosoftExtension ?
                                            GetProcessHeap() : HeapCreate( 0, 1024*100, 1024*1024*2 );
        if (!pRoutingExtension->HeapHandle)
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Can't create heap, ec=%ld"),
                dwRes);
            pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
            pRoutingExtension->dwLastError = dwRes;
            goto InitializationFailed;
        }
        //
        // We 1st call the RoutingExtension->pFaxExtInitializeConfig function (if exported)
        //
        if (pRoutingExtension->pFaxExtInitializeConfig)
        {
            __try
            {

                hr = pRoutingExtension->pFaxExtInitializeConfig(
                    FaxExtGetData,
                    FaxExtSetData,
                    FaxExtRegisterForEvents,
                    FaxExtUnregisterForEvents,
                    FaxExtFreeBuffer);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                DWORD ec = GetExceptionCode();

                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxExtInitializeConfig() caused exception (%ld) for extension [%s]"),
                    ec,
                    pRoutingExtension->FriendlyName );
                hr = HRESULT_FROM_WIN32 (ec);
            }
            if (FAILED(hr))
            {
                //
                // Failed to init ext. config.
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxExtInitializeConfig() failed (hr = 0x%08x) for extension [%s]"),
                    hr,
                    pRoutingExtension->FriendlyName );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_INIT;
                pRoutingExtension->dwLastError = hr;
                goto InitializationFailed;
            }
        }
        //
        // Next, call the initialization routing of the routing ext.
        //
        __try
        {
            if (pRoutingExtension->MicrosoftExtension)
            {
                //
                // Special hack - for the MS routing extension, pass the extra private structure which
                // contains a pointer to the service's g_CsConfig.
                //
                bRes = pRoutingExtension->FaxRouteInitialize( pRoutingExtension->HeapHandle, (PFAX_ROUTE_CALLBACKROUTINES)(&Callbacks_private) );
            }
            else
            {
                bRes = pRoutingExtension->FaxRouteInitialize( pRoutingExtension->HeapHandle, &Callbacks );
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            dwRes = GetExceptionCode();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("FaxRouteInitialize() faulted: 0x%08x"),
                         dwRes);
            SetLastError (dwRes);
            bRes = FALSE;
        }
        if (!bRes)
        {
            //
            // Either init faulted or failed
            //
            dwRes = GetLastError ();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("FaxRouteInitialize() failed / faulted: ec=%ld"),
                         dwRes);
            pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_INIT;
            pRoutingExtension->dwLastError = dwRes;
            goto InitializationFailed;
        }
        //
        // All initialization succeeded - proceed with routing methods.
        //
        for (j = 0; j < pFaxReg->RoutingExtensions[i].RoutingMethodsCount; j++)
        {
            LPSTR lpstrProcName = NULL;

            //
            // Send mail is not supported on desktop SKUs
            //
            if (0 == _wcsicmp(pFaxReg->RoutingExtensions[i].RoutingMethods[j].Guid, REGVAL_RM_EMAIL_GUID) &&
                TRUE == IsDesktopSKU())
            {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Email is not supported on desktop SKU."));
                continue;
            }

            pRoutingMethod = (PROUTING_METHOD) MemAlloc( sizeof(ROUTING_METHOD) );
            if (!pRoutingMethod)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Could not allocate memory for routing method %s"),
                    pFaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName);
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                pRoutingExtension->dwLastError = dwRes;
                goto InitializationFailed;
            }
            memset (pRoutingMethod, 0, sizeof (ROUTING_METHOD));

            pRoutingMethod->RoutingExtension = pRoutingExtension;

            pRoutingMethod->Priority = pFaxReg->RoutingExtensions[i].RoutingMethods[j].Priority;
            pRoutingMethod->FriendlyName =
                StringDup( pFaxReg->RoutingExtensions[i].RoutingMethods[j].FriendlyName ?
                               pFaxReg->RoutingExtensions[i].RoutingMethods[j].FriendlyName : EMPTY_STRING );
            if (!pRoutingMethod->FriendlyName)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Could not create routing function name [%s]"),
                    pFaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName);
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                pRoutingExtension->dwLastError = dwRes;
                goto MethodError;
            }

            pRoutingMethod->FunctionName =
                StringDup( pFaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName ?
                               pFaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName : EMPTY_STRING);
            if (!pRoutingMethod->FunctionName)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Could not create routing function name [%s]"),
                    pFaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                pRoutingExtension->dwLastError = dwRes;
                goto MethodError;
            }

            pRoutingMethod->InternalName =
                StringDup( pFaxReg->RoutingExtensions[i].RoutingMethods[j].InternalName ?
                               pFaxReg->RoutingExtensions[i].RoutingMethods[j].InternalName : EMPTY_STRING);
            if (!pRoutingMethod->InternalName)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Could not create routing internal name [%s]"),
                    pFaxReg->RoutingExtensions[i].RoutingMethods[j].InternalName );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                pRoutingExtension->dwLastError = dwRes;
                goto MethodError;
            }

            hr = IIDFromString( pFaxReg->RoutingExtensions[i].RoutingMethods[j].Guid, &pRoutingMethod->Guid );
            if (S_OK != hr)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Invalid GUID string [%s], hr = 0x%x"),
                    pFaxReg->RoutingExtensions[i].RoutingMethods[j].Guid,
                    hr );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_BAD_GUID;
                pRoutingExtension->dwLastError = hr;
                goto MethodError;
            }

            lpstrProcName = UnicodeStringToAnsiString( pRoutingMethod->FunctionName );
            if (!lpstrProcName)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Could not create routing function name [%s]"),
                    pRoutingMethod->FunctionName );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                pRoutingExtension->dwLastError = dwRes;
                goto MethodError;
            }

            pRoutingMethod->FaxRouteMethod = (PFAXROUTEMETHOD) GetProcAddress(
                hModule,
                lpstrProcName
                );
            if (!pRoutingMethod->FaxRouteMethod)
            {
                dwRes = GetLastError ();
                DebugPrintEx(DEBUG_ERR,
                             TEXT("Could not get function address [%S], ec=%ld"),
                             lpstrProcName,
                             dwRes
                            );
                pRoutingExtension->Status = FAX_PROVIDER_STATUS_CANT_LINK;
                pRoutingExtension->dwLastError = dwRes;
                goto MethodError;
            }
            MemFree( lpstrProcName );
            goto MethodOk;

MethodError:
            MemFree( pRoutingMethod->FriendlyName );
            MemFree( pRoutingMethod->FunctionName );
            MemFree( pRoutingMethod->InternalName );
            MemFree( pRoutingMethod );
            MemFree( lpstrProcName );
            goto InitializationFailed;

MethodOk:
            //
            // Success - add this routing method to the routing extension's list of methods
            //
            InsertTailList( &pRoutingExtension->RoutingMethods, &pRoutingMethod->ListEntry );
        }   // Loop of extension's routing methods
        //
        // Success while loading and initializing this extension
        //
        pRoutingExtension->Status = FAX_PROVIDER_STATUS_SUCCESS;
        pRoutingExtension->dwLastError = ERROR_SUCCESS;
        //
        // All methods successfully initialized.
        // Add all methods to global list of methods (and increase global counter)
        //
        ple = pRoutingExtension->RoutingMethods.Flink;
        while ((ULONG_PTR)ple != (ULONG_PTR)&pRoutingExtension->RoutingMethods)
        {
            pRoutingMethod = CONTAINING_RECORD( ple, ROUTING_METHOD, ListEntry );
            ple = ple->Flink;
            InsertTailList( &g_lstRoutingMethods, &pRoutingMethod->ListEntryMethod );
            g_dwCountRoutingMethods++;
        }
        goto next;

InitializationFailed:
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                2,
                MSG_ROUTE_INIT_FAILED,
                pFaxReg->RoutingExtensions[i].FriendlyName,
                pFaxReg->RoutingExtensions[i].ImageName
              );

        if (pRoutingExtension)
        {
            if (pRoutingExtension->hModule)
            {
                __try{
                    FreeLibrary (pRoutingExtension->hModule);
                }
                __except ( EXCEPTION_EXECUTE_HANDLER )
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("FreeLibrary() caused exception( %ld) "),
                        GetExceptionCode()
                    );
                }

                pRoutingExtension->hModule = NULL;
            }
            //
            // If we created a heap for the routing extension, destroy it
            //
            if ((pRoutingExtension->HeapHandle) &&
                (FALSE == pRoutingExtension->MicrosoftExtension))
            {
                HeapDestroy (pRoutingExtension->HeapHandle);
                pRoutingExtension->HeapHandle = NULL;
            }
            //
            // Clear the list of routing methods and free method structures.
            //
            ple = pRoutingExtension->RoutingMethods.Flink;
            while ((ULONG_PTR)ple != (ULONG_PTR)&pRoutingExtension->RoutingMethods)
            {
                pRoutingMethod = CONTAINING_RECORD(ple, ROUTING_METHOD, ListEntry);
                ple = ple->Flink;
                MemFree( pRoutingMethod->FriendlyName );
                MemFree( pRoutingMethod->FunctionName );
                MemFree( pRoutingMethod->InternalName );
                MemFree( pRoutingMethod );
            }
            //
            // Make the extension have an empty list of methods.
            //
            InitializeListHead( &pRoutingExtension->RoutingMethods );
        }

next:
        if (pRoutingExtension)
        {
            //
            // we have a routing extension object (successful or not), add it to the list
            //
            InsertTailList( &g_lstRoutingExtensions, &pRoutingExtension->ListEntry );
        }
    }

    SortMethodPriorities();

    if (0 == g_dwCountRoutingMethods)
    {
        //
        // No routing methods available
        //
        DebugPrintEx(DEBUG_WRN,
                     TEXT("No routing methods are available on the server !!!!"));
    }

    return TRUE;
}   // InitializeRouting

BOOL
FaxRoute(
    PJOB_QUEUE          JobQueueEntry,
    LPTSTR              TiffFileName,
    PFAX_ROUTE          FaxRoute,
    PROUTE_FAILURE_INFO *RouteFailureInfo,
    LPDWORD             RouteFailureCount
    )
/*++

Routine Description:

    Routes a FAX.



Arguments:

    JobQueueEntry           - the job queue entry for the job
    TiffFileName            - filename of the received fax
    FaxRoute                - struct describing received FAX
    RouteFailureInfo        - pointer to receive pointr to eceive buffer ROUTE_FAILURE_INFO structures
    RouteFailureCount       - receives the total number of route failures recorded

Return Value:

    TRUE
        if fax routing succeded ( some methods may still fail )
        check RouteFailureCount to see how many Routing Methods failed
    FALSE
        if the function itself failed ( MemAlloc etc. )

--*/

{
    PLIST_ENTRY             pNextMethod;
    PROUTING_METHOD         pRoutingMethod;
    DWORD                   FailureCount = 0;
    PROUTE_FAILURE_INFO     pRouteFailure;
    PLIST_ENTRY             pNextRoutingOverride;
    PROUTING_DATA_OVERRIDE  pRoutingDataOverride;
    BOOL                    RetVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("FaxRoute"));

    *RouteFailureInfo = NULL;
    *RouteFailureCount = 0;

    //
    // if the tiff file has been deleted ==> return
    //
    if (GetFileAttributes( TiffFileName ) == 0xffffffff)
    {
        return FALSE;
    }

    EnterCriticalSection( &g_CsRouting );

    pNextMethod = g_lstRoutingMethods.Flink;
    if (pNextMethod)
    {
        //
        // allocate memory to record the GUIDs of the failed routing methods
        //
        pRouteFailure = (PROUTE_FAILURE_INFO) MemAlloc( g_dwCountRoutingMethods * sizeof(ROUTE_FAILURE_INFO) );
        if (pRouteFailure == NULL)
        {
            RetVal = FALSE;
            goto Exit;
        }
        //
        // add the tiff file as the first file
        // in the file name list, the owner is the fax service
        //
        if (FaxRouteAddFile( FaxRoute->JobId, TiffFileName, const_cast<GUID*>(&gc_FaxSvcGuid) ) < 1)
        {
            RetVal = FALSE;
            goto Exit;
        }
        //
        // walk thru all of the routing methods and call them
        //
        while ((ULONG_PTR)pNextMethod != (ULONG_PTR)&g_lstRoutingMethods)
        {
            pRoutingMethod = CONTAINING_RECORD( pNextMethod, ROUTING_METHOD, ListEntryMethod );
            pNextMethod = pRoutingMethod->ListEntryMethod.Flink;

            FaxRoute->RoutingInfoData = NULL;
            FaxRoute->RoutingInfoDataSize = 0;

            EnterCriticalSection( &JobQueueEntry->CsRoutingDataOverride );

            pNextRoutingOverride = JobQueueEntry->RoutingDataOverride.Flink;
            if (pNextRoutingOverride != NULL)
            {
                while ((ULONG_PTR)pNextRoutingOverride != (ULONG_PTR)&JobQueueEntry->RoutingDataOverride)
                {
                    pRoutingDataOverride = CONTAINING_RECORD( pNextRoutingOverride, ROUTING_DATA_OVERRIDE, ListEntry );
                    pNextRoutingOverride = pRoutingDataOverride->ListEntry.Flink;
                    if (pRoutingDataOverride->RoutingMethod == pRoutingMethod)
                    {
                        FaxRoute->RoutingInfoData = (LPBYTE)MemAlloc(pRoutingDataOverride->RoutingDataSize);
                        if (NULL == FaxRoute->RoutingInfoData)
                        {
                            DebugPrintEx(DEBUG_ERR,
                                _T("MemAlloc Failed (ec: %ld)"),
                                GetLastError());
                            LeaveCriticalSection( &JobQueueEntry->CsRoutingDataOverride );
                            RetVal = FALSE;
                            goto Exit;
                         }
                         CopyMemory (FaxRoute->RoutingInfoData,
                                     pRoutingDataOverride->RoutingData,
                                     pRoutingDataOverride->RoutingDataSize);
                         FaxRoute->RoutingInfoDataSize = pRoutingDataOverride->RoutingDataSize;
                     }
                }
            }

            LeaveCriticalSection( &JobQueueEntry->CsRoutingDataOverride );

            __try
            {
                pRouteFailure[FailureCount].FailureData = NULL;
                pRouteFailure[FailureCount].FailureSize = 0;

                if (!pRoutingMethod->FaxRouteMethod(
                        FaxRoute,
                        &pRouteFailure[FailureCount].FailureData,
                        &pRouteFailure[FailureCount].FailureSize ))
                {
                    WCHAR TmpStr[20] = {0};
                    swprintf(TmpStr,TEXT("0x%016I64x"), JobQueueEntry->UniqueId);

                    FaxLog(FAXLOG_CATEGORY_INBOUND,
                        FAXLOG_LEVEL_MIN,
                        6,
                        MSG_FAX_ROUTE_METHOD_FAILED,
                        TmpStr,
                        JobQueueEntry->FaxRoute->DeviceName,
                        JobQueueEntry->FaxRoute->Tsid,
                        JobQueueEntry->FileName,
                        pRoutingMethod->RoutingExtension->FriendlyName,
                        pRoutingMethod->FriendlyName
                        );

                    StringFromGUID2(pRoutingMethod->Guid,
                        pRouteFailure[FailureCount].GuidString,
                        MAX_GUID_STRING_LEN);

                    //
                    // Allocate failure data using MemAlloc
                    //
                    if (pRouteFailure[FailureCount].FailureSize)
                    {
                        PVOID pOriginalFailureData = pRouteFailure[FailureCount].FailureData;
                        pRouteFailure[FailureCount].FailureData = MemAlloc (pRouteFailure[FailureCount].FailureSize);
                        if (pRouteFailure[FailureCount].FailureData)
                        {
                            CopyMemory (pRouteFailure[FailureCount].FailureData,
                                        pOriginalFailureData,
                                        pRouteFailure[FailureCount].FailureSize);
                        }
                        else
                        {
                            //
                            // Failed to allocate retry failure data - data will be lost.
                            //
                            DebugPrintEx(DEBUG_ERR,
                                _T("Failed to allocate failure date"));
                            RetVal = FALSE;
                            goto Exit;
                        }

                        if (!HeapFree(pRoutingMethod->RoutingExtension->HeapHandle, // handle to extension heap
                                      0,
                                      pOriginalFailureData
                                      ))
                        {
                            //
                            // Failed to free retry failure data from extension heap - data will be lost.
                            //
                            DebugPrintEx(DEBUG_ERR,
                                         _T("HeapFree Failed (ec: %ld)"),
                                         GetLastError());
                            RetVal = FALSE;
                            goto Exit;
                        }
                    }

                    if (0 == pRouteFailure[FailureCount].FailureSize ||
                        NULL == pRouteFailure[FailureCount].FailureData)
                    {
                        //
                        // Make sure failure data will not be freed
                        //
                        pRouteFailure[FailureCount].FailureData = NULL;
                        pRouteFailure[FailureCount].FailureSize = 0;
                    }

                    FailureCount++;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("FaxRouteProcess() faulted: 0x%08x"),
                    GetExceptionCode());

                StringFromGUID2(
                    pRoutingMethod->Guid,
                    pRouteFailure[FailureCount].GuidString,
                    MAX_GUID_STRING_LEN);

                pRouteFailure[FailureCount].FailureData = NULL;
                pRouteFailure[FailureCount].FailureSize = 0;
                FailureCount++;
            }
        }
    }

    Assert (RetVal == TRUE);

Exit:

    LeaveCriticalSection( &g_CsRouting );

    if (pRouteFailure && FailureCount == 0)
    {
        //
        // We do not delete the routed TIFF file here.
        // RemoveReceiveJob() will take care of that.
        //
        MemFree( pRouteFailure );
        pRouteFailure = NULL;
    }

    *RouteFailureInfo = pRouteFailure;
    *RouteFailureCount = FailureCount;

    return RetVal;
}


BOOL
LoadRouteInfo(
    IN  LPWSTR              RouteFileName,
    OUT PROUTE_INFO         *RouteInfo,
    OUT PROUTE_FAILURE_INFO *RouteFailure,
    OUT LPDWORD             RouteFailureCount
    )

/*++

Routine Description:

    Load routing information from a routing information file.

Arguments:

    RouteFileName - Name of routing information file.

Return value:

    Pointer to routing information structure if success.  NULL if fail.

--*/

{
#if 0
    HANDLE RouteHandle;
    PROUTE_INFO pRouteInfo = NULL;
    DWORD FileSize;
    DWORD BytesRead;
    LPBYTE Buffer;
    PROUTE_FAILURE_INFO pRouteFailure = NULL;
    DWORD pRouteFailureCount = 0;


    RouteHandle = CreateFile(
        RouteFileName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (RouteHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // the size of the file is the size of the structure
    //

    FileSize = GetFileSize( RouteHandle, NULL );
    if (FileSize == 0xffffffff) {
        CloseHandle( RouteHandle );
        return FALSE;
    }

    Buffer = MemAlloc( FileSize );
    pRouteInfo = (PROUTE_INFO) Buffer;
    if (Buffer == NULL) {
        CloseHandle( RouteHandle );
        return FALSE;
    }

    if (!ReadFile( RouteHandle, Buffer, FileSize, &BytesRead, NULL) || BytesRead != FileSize ) {
        CloseHandle( RouteHandle );
        return FALSE;
    }

    CloseHandle( RouteHandle );

    if (pRouteInfo->Signature != ROUTING_SIGNATURE) {
        CloseHandle( RouteHandle );
        return FALSE;
    }

    pRouteInfo->TiffFileName   = OffsetToString( pRouteInfo->TiffFileName,   Buffer );
    pRouteInfo->ReceiverName   = OffsetToString( pRouteInfo->ReceiverName,   Buffer );
    pRouteInfo->ReceiverNumber = OffsetToString( pRouteInfo->ReceiverNumber, Buffer );
    pRouteInfo->Csid           = OffsetToString( pRouteInfo->Csid,           Buffer );
    pRouteInfo->CallerId       = OffsetToString( pRouteInfo->CallerId,       Buffer );
    pRouteInfo->RoutingInfo    = OffsetToString( pRouteInfo->RoutingInfo,    Buffer );
    pRouteInfo->DeviceName     = OffsetToString( pRouteInfo->DeviceName,     Buffer );
    pRouteInfo->Tsid           = OffsetToString( pRouteInfo->Tsid,           Buffer );


    //
    // return the data
    //

    RouteInfo = pRouteInfo;

#endif
    return TRUE;
}


BOOL
FaxRouteRetry(
    PFAX_ROUTE          FaxRoute,
    PROUTE_FAILURE_INFO pRouteFailureInfo
    )
{
    PROUTING_METHOD         RoutingMethod;
    BOOL                    RetVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("FaxRouteRetry"));

    //
    // in this case, we've already retried this method and it succeeded.
    //
    if (!*pRouteFailureInfo->GuidString) {
       return TRUE;
    }

    RoutingMethod = FindRoutingMethodByGuid( pRouteFailureInfo->GuidString );

    if (RoutingMethod) {
        __try
        {
            PVOID pOriginalFailureData = NULL;
            PVOID pFailureData = pRouteFailureInfo->FailureData;
            //
            // Allocate failure data using the extension heap
            //
            if (pRouteFailureInfo->FailureSize)
            {
                pOriginalFailureData = HeapAlloc (RoutingMethod->RoutingExtension->HeapHandle,
                                                  HEAP_ZERO_MEMORY,
                                                  pRouteFailureInfo->FailureSize);
                if (!pOriginalFailureData)
                {
                    DebugPrintEx(
                                 DEBUG_ERR,
                                 TEXT("Failed to allocate failure date")
                                 );
                     return FALSE;
                }
                pRouteFailureInfo->FailureData = pOriginalFailureData;
                CopyMemory (pRouteFailureInfo->FailureData,
                            pFailureData,
                            pRouteFailureInfo->FailureSize);

            }
            else
            {
                Assert (NULL == pRouteFailureInfo->FailureData);
            }
            MemFree (pFailureData);

            if (!RoutingMethod->FaxRouteMethod(
                  FaxRoute,
                  &(pRouteFailureInfo->FailureData),
                  &(pRouteFailureInfo->FailureSize) ))
            {
                RetVal = FALSE;
                //
                // Allocate failure data using MemAlloc
                //
                if (pRouteFailureInfo->FailureSize)
                {
                    pOriginalFailureData = pRouteFailureInfo->FailureData;
                    pRouteFailureInfo->FailureData = MemAlloc (pRouteFailureInfo->FailureSize);
                    if (pRouteFailureInfo->FailureData)
                    {
                        CopyMemory (pRouteFailureInfo->FailureData,
                                    pOriginalFailureData,
                                    pRouteFailureInfo->FailureSize);
                    }
                    else
                    {
                        //
                        // Failed to allocate retry failure data - data will be lost.
                        //
                        DebugPrintEx(DEBUG_ERR,
                                     _T("Failed to allocate failure date"));
                        return FALSE;
                    }

                    if (!HeapFree(RoutingMethod->RoutingExtension->HeapHandle, // handle to extension heap
                                  0,
                                  pOriginalFailureData
                                  ))
                    {
                        //
                        // Failed to free retry failure data from extension heap - data will be lost.
                        //
                        DebugPrintEx(DEBUG_ERR,
                                     _T("HeapFree Failed (ec: %ld)"),
                                     GetLastError());
                        return FALSE;
                    }
                }
            }
            else
            {
             //
             // set the routing guid to zero so we don't try to route this guy again.  He is
             // deallocated when we delete the queue entry.
             //
             ZeroMemory(pRouteFailureInfo->GuidString, MAX_GUID_STRING_LEN*sizeof(WCHAR) );
            }

            if (0 == pRouteFailureInfo->FailureSize ||
                NULL == pRouteFailureInfo->FailureData ||
                TRUE == RetVal)
            {
                //
                // Make sure failure data will not be freed
                //
                pRouteFailureInfo->FailureData = NULL;
                pRouteFailureInfo->FailureSize = 0;
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

          DebugPrintEx(DEBUG_ERR,
              _T("FaxRouteProcess() faulted: 0x%08x"),
              GetExceptionCode());
          RetVal = FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    return RetVal;
}


PFAX_ROUTE
SerializeFaxRoute(
    PFAX_ROUTE FaxRoute,
    LPDWORD Size,
    BOOL bSizeOnly
    )
{
    DWORD ByteCount = sizeof(FAX_ROUTE);
    DWORD_PTR Offset;
    PFAX_ROUTE SerFaxRoute;             // the serialized version


    *Size = 0;

    // Add the size of the strings

    ByteCount += StringSize( FaxRoute->Csid );
    ByteCount += StringSize( FaxRoute->Tsid );
    ByteCount += StringSize( FaxRoute->CallerId );
    ByteCount += StringSize( FaxRoute->RoutingInfo );
    ByteCount += StringSize( FaxRoute->ReceiverName );
    ByteCount += StringSize( FaxRoute->ReceiverNumber );
    ByteCount += StringSize( FaxRoute->DeviceName );
    ByteCount += FaxRoute->RoutingInfoDataSize;

    if (bSizeOnly) {
        *Size = ByteCount;
        return NULL;
    }

    SerFaxRoute = (PFAX_ROUTE) MemAlloc( ByteCount );

    if (SerFaxRoute == NULL) {
        return NULL;
    }

    *Size = ByteCount;

    CopyMemory( (PVOID) SerFaxRoute, (PVOID) FaxRoute, sizeof(FAX_ROUTE) );

    Offset = sizeof( FAX_ROUTE );

    StoreString( FaxRoute->Csid, (PDWORD_PTR)&SerFaxRoute->Csid, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->Tsid, (PDWORD_PTR)&SerFaxRoute->Tsid, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->CallerId, (PDWORD_PTR)&SerFaxRoute->CallerId, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->RoutingInfo, (PDWORD_PTR)&SerFaxRoute->RoutingInfo, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->ReceiverName, (PDWORD_PTR)&SerFaxRoute->ReceiverName, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->ReceiverNumber, (PDWORD_PTR)&SerFaxRoute->ReceiverNumber, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->DeviceName, (PDWORD_PTR)&SerFaxRoute->DeviceName, (LPBYTE) SerFaxRoute, &Offset );

    SerFaxRoute->RoutingInfoData = (LPBYTE) Offset;
    Offset += FaxRoute->RoutingInfoDataSize;

    CopyMemory(
        (PVOID) ((LPBYTE) &SerFaxRoute + Offset),
        (PVOID) FaxRoute->RoutingInfoData,
        FaxRoute->RoutingInfoDataSize
        );

    return SerFaxRoute;
}

PFAX_ROUTE
DeSerializeFaxRoute(
    PFAX_ROUTE FaxRoute
    )
{
    PFAX_ROUTE NewFaxRoute = NULL;
    DEBUG_FUNCTION_NAME(TEXT("DeSerializeFaxRoute"));

    FixupString( FaxRoute, FaxRoute->Csid );
    FixupString( FaxRoute, FaxRoute->Tsid );
    FixupString( FaxRoute, FaxRoute->CallerId );
    FixupString( FaxRoute, FaxRoute->RoutingInfo );
    FixupString( FaxRoute, FaxRoute->ReceiverName );
    FixupString( FaxRoute, FaxRoute->DeviceName );
    FixupString( FaxRoute, FaxRoute->ReceiverNumber );

    FaxRoute->RoutingInfoData = (LPBYTE) FaxRoute + (ULONG_PTR) FaxRoute->RoutingInfoData;

    //
    // Make a copy where each item is individually malloced so it can be freed properly
    //
    NewFaxRoute = (PFAX_ROUTE)MemAlloc( sizeof( FAX_ROUTE ) );
    if (NULL == NewFaxRoute)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate FAX_ROUTE"));
        return NULL;
    }
    ZeroMemory (NewFaxRoute, sizeof( FAX_ROUTE ));

    NewFaxRoute->SizeOfStruct = sizeof( FAX_ROUTE );
    NewFaxRoute->JobId = FaxRoute->JobId;
    NewFaxRoute->ElapsedTime = FaxRoute->ElapsedTime;
    NewFaxRoute->ReceiveTime = FaxRoute->ReceiveTime;
    NewFaxRoute->PageCount = FaxRoute->PageCount;
    NewFaxRoute->DeviceId = FaxRoute->DeviceId;
    NewFaxRoute->RoutingInfoDataSize = FaxRoute->RoutingInfoDataSize;

    int nRes;
    STRING_PAIR pairs[] =
    {
        { (LPWSTR)FaxRoute->Csid, (LPWSTR*)&(NewFaxRoute->Csid)},
        { (LPWSTR)FaxRoute->Tsid, (LPWSTR*)&(NewFaxRoute->Tsid)},
        { (LPWSTR)FaxRoute->CallerId, (LPWSTR*)&(NewFaxRoute->CallerId)},
        { (LPWSTR)FaxRoute->RoutingInfo, (LPWSTR*)&(NewFaxRoute->RoutingInfo)},
        { (LPWSTR)FaxRoute->ReceiverName, (LPWSTR*)&(NewFaxRoute->ReceiverName)},
        { (LPWSTR)FaxRoute->DeviceName, (LPWSTR*)&(NewFaxRoute->DeviceName)},
        { (LPWSTR)FaxRoute->ReceiverNumber, (LPWSTR*)&(NewFaxRoute->ReceiverNumber)}
    };

    nRes = MultiStringDup(pairs, sizeof(pairs)/sizeof(STRING_PAIR));
    if (nRes != 0)
    {
        // MultiStringDup takes care of freeing the memory for the pairs for which the copy succeeded
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy string with index %d"), nRes-1);
        goto Error;
    }

    NewFaxRoute->RoutingInfoData = (LPBYTE)MemAlloc( FaxRoute->RoutingInfoDataSize );
    if (NULL == NewFaxRoute->RoutingInfoData)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate RoutingInfoData"));
        goto Error;
    }

    CopyMemory( NewFaxRoute->RoutingInfoData, FaxRoute->RoutingInfoData, FaxRoute->RoutingInfoDataSize );
    return NewFaxRoute;

Error:
    MemFree ((void*)NewFaxRoute->Csid);
    MemFree ((void*)NewFaxRoute->Tsid);
    MemFree ((void*)NewFaxRoute->CallerId);
    MemFree ((void*)NewFaxRoute->RoutingInfo);
    MemFree ((void*)NewFaxRoute->ReceiverName);
    MemFree ((void*)NewFaxRoute->DeviceName);
    MemFree ((void*)NewFaxRoute->ReceiverNumber);
    MemFree ((void*)NewFaxRoute->RoutingInfoData);
    MemFree ((void*)NewFaxRoute);
    return NULL;
}


extern "C"
DWORD
GetRecieptsConfiguration(
    PFAX_SERVER_RECEIPTS_CONFIGW* ppServerRecieptConfig
    )
/*++

Routine name : GetRecieptsConfiguration

Routine description:

    Private callback used by MS Routing Extension to get the server reciept configuration. Also used by the service SendReceipt()
    Used to get a copy of the receipts configuration.

Author:

    Oded Sacher (OdedS),    Mar, 2001

Arguments:

    ppServerRecieptConfig           [out] - Address to a pointer to a private server reciepts configuration struct.
                                            The caller should free the resources by calling FreeRecieptsConfiguration()

Return Value:

    Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("GetRecieptsConfiguration"));

    Assert (ppServerRecieptConfig);

    *ppServerRecieptConfig = (PFAX_SERVER_RECEIPTS_CONFIGW)MemAlloc(sizeof(FAX_SERVER_RECEIPTS_CONFIGW));
    if (NULL == *ppServerRecieptConfig)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory (*ppServerRecieptConfig, sizeof(FAX_SERVER_RECEIPTS_CONFIGW));

    EnterCriticalSection (&g_CsConfig);

    (*ppServerRecieptConfig)->dwSizeOfStruct = sizeof (FAX_SERVER_RECEIPTS_CONFIGW);
    (*ppServerRecieptConfig)->bIsToUseForMSRouteThroughEmailMethod = g_ReceiptsConfig.bIsToUseForMSRouteThroughEmailMethod;
    (*ppServerRecieptConfig)->dwSMTPPort = g_ReceiptsConfig.dwSMTPPort;
    (*ppServerRecieptConfig)->dwAllowedReceipts = g_ReceiptsConfig.dwAllowedReceipts;
    (*ppServerRecieptConfig)->SMTPAuthOption = g_ReceiptsConfig.SMTPAuthOption;
    (*ppServerRecieptConfig)->lptstrReserved = NULL;

    if (NULL != g_ReceiptsConfig.lptstrSMTPServer &&
        NULL == ((*ppServerRecieptConfig)->lptstrSMTPServer = StringDup(g_ReceiptsConfig.lptstrSMTPServer)))
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
        goto exit;
    }

    if (NULL != g_ReceiptsConfig.lptstrSMTPFrom &&
        NULL == ((*ppServerRecieptConfig)->lptstrSMTPFrom = StringDup(g_ReceiptsConfig.lptstrSMTPFrom)))
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
        goto exit;
    }

    if (NULL != g_ReceiptsConfig.lptstrSMTPUserName &&
        NULL == ((*ppServerRecieptConfig)->lptstrSMTPUserName = StringDup(g_ReceiptsConfig.lptstrSMTPUserName)))
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
        goto exit;
    }

    if (NULL != g_ReceiptsConfig.lptstrSMTPPassword &&
        NULL == ((*ppServerRecieptConfig)->lptstrSMTPPassword = StringDup(g_ReceiptsConfig.lptstrSMTPPassword)))
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed"));
        goto exit;
    }

    if (FAX_SMTP_AUTH_NTLM == g_ReceiptsConfig.SMTPAuthOption)
    {
        HANDLE hDupToken;

        if (NULL == g_ReceiptsConfig.hLoggedOnUser)
        {
            HANDLE hLoggedOnUserToken;
            WCHAR wszUser[CREDUI_MAX_USERNAME_LENGTH] = {0};
            WCHAR wszDomain[CREDUI_MAX_DOMAIN_TARGET_LENGTH] = {0};

            //
            // Parse user name into user name and domain
            //
            dwRes = CredUIParseUserName (g_ReceiptsConfig.lptstrSMTPUserName,
                                         wszUser,
                                         ARR_SIZE(wszUser),
                                         wszDomain,
                                         ARR_SIZE(wszDomain));
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CredUIParseUserName failed. (ec: %ld)"),
                    dwRes);
                goto exit;
            }

            //
            // We get the a logged on user token
            //
            if (!LogonUser (wszUser,
                            wszDomain,
                            g_ReceiptsConfig.lptstrSMTPPassword,
                            LOGON32_LOGON_NETWORK,
                            LOGON32_PROVIDER_DEFAULT,
                            &hLoggedOnUserToken))
            {
                dwRes = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("LogonUser failed. (ec: %ld)"),
                    dwRes);
                goto exit;
            }
            g_ReceiptsConfig.hLoggedOnUser = hLoggedOnUserToken;
        }

        //
        // Duplicate that Token
        //
        if (!DuplicateToken(g_ReceiptsConfig.hLoggedOnUser,
                              SecurityImpersonation,               // SECURITY_IMPERSONATION_LEVEL
                              &hDupToken))                         // Duplicate token
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DuplicateToken failed. (ec: %ld)"),
                dwRes);
            goto exit;
        }

        (*ppServerRecieptConfig)->hLoggedOnUser = hDupToken;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);

    if (ERROR_SUCCESS != dwRes)
    {
        FreeRecieptsConfiguration( *ppServerRecieptConfig, TRUE);
    }
    return dwRes;
}


extern "C"
void
FreeRecieptsConfiguration(
    PFAX_SERVER_RECEIPTS_CONFIGW pServerRecieptConfig,
    BOOL                         fDestroy
    )
/*++

Routine name : FreeRecieptsConfiguration

Routine description:

    Private callback used by MS Routing Extension to get the server reciept configuration.
    Used by the extension to decide on the authentication when sending mail.

Author:

    Oded Sacher (OdedS),    Mar, 2001

Arguments:

    pServerRecieptConfig            [in ] - Pointer to a private server reciepts configuration struct to be freed.
    fDestroy                        [in ] - TRUE if to free the struct as well

Return Value:

    Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FreeRecieptsConfiguration"));

    Assert (pServerRecieptConfig);

    MemFree(pServerRecieptConfig->lptstrSMTPServer);
    pServerRecieptConfig->lptstrSMTPServer = NULL;

    MemFree(pServerRecieptConfig->lptstrSMTPFrom);
    pServerRecieptConfig->lptstrSMTPFrom = NULL;

    MemFree(pServerRecieptConfig->lptstrSMTPUserName);
    pServerRecieptConfig->lptstrSMTPUserName = NULL;

    MemFree(pServerRecieptConfig->lptstrSMTPPassword);
    pServerRecieptConfig->lptstrSMTPPassword = NULL;

    if (NULL != pServerRecieptConfig->hLoggedOnUser )
    {
        if (!CloseHandle(pServerRecieptConfig->hLoggedOnUser))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle failed. (ec: %ld)"),
                GetLastError());
        }
        pServerRecieptConfig->hLoggedOnUser = NULL;
    }
    if (TRUE == fDestroy)
    {
        MemFree (pServerRecieptConfig);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\receive.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module handles the FAX receive case.

Author:

    Wesley Witt (wesw) 6-Mar-1996


Revision History:

--*/

#include "faxsvc.h"
#include "faxreg.h"
#pragma hdrstop

DWORD
FaxReceiveThread(
    PFAX_RECEIVE_ITEM FaxReceiveItem
    )

/*++

Routine Description:

    This function process a FAX send operation.  This runs
    asynchronously as a separate thread.  There is one
    thread for each outstanding FAX operation.

Arguments:

    FaxReceiveItem  - FAX receive packet

Return Value:

    Error code.

--*/

{
    WCHAR       ArchiveFileName[MAX_PATH];
    DWORD rVal = ERROR_SUCCESS;
    DWORD dwRes;
    PJOB_ENTRY JobEntry;
    DWORD JobId;
    PLINE_INFO LineInfo;
    PFAX_RECEIVE FaxReceive = NULL;
    DWORD ReceiveSize;
    BOOL Result;
    DWORDLONG ElapsedTime = 0;
    DWORDLONG ReceiveTime = 0;
    BOOL DoFaxRoute = FALSE;
    DWORD Attrib;
    DWORD RecoveredPages,TotalPages;
    MS_TAG_INFO MsTagInfo = {0};
    BOOL fReceiveNoFile = FALSE;
    BOOL ReceiveFailed = FALSE;
    PJOB_QUEUE JobQueue = NULL;
    BOOL bLineMarkedAsSending = FALSE;  // When we increase the sending count on the line, we use this flag to decrease at the end.
    BOOL DeviceCanSend = TRUE;  // TRUE if the device is free for send after the receive is completed.
                                // FALSE for handoff jobs and devices that are not send enabled.
                                // Its value determines if to notify the queue that a device was freed up.
    PJOB_QUEUE lpRecoverJob = NULL; // Pointer to a receive recover job if created.
    LPFSPI_JOB_STATUS pFaxStatus = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxReceiveThread"));
    DWORD ec;
    BOOL fCOMInitiliazed = FALSE;
    HRESULT hr;
    WCHAR wszArchiveFolder[MAX_PATH];
    FSPI_JOB_STATUS FakedFaxStatus = {0};
    BOOL bFakeStatus = FALSE;
    DWORD dwSttRes = ERROR_SUCCESS;
    WCHAR LastExStatusString[EX_STATUS_STRING_LEN] = {0}; // The last extended status string of this job (when it was active)
    DWORD dwLastJobExtendedStatus = 0;
    BOOL fSetSystemIdleTimer = TRUE;

    Assert(FaxReceiveItem);

    //
    // Don't let the system go to sleep in the middle of the fax transmission.
    //
    if (NULL == SetThreadExecutionState(ES_SYSTEM_REQUIRED | ES_CONTINUOUS))
    {
        fSetSystemIdleTimer = FALSE;
        DebugPrintEx(DEBUG_ERR,
            TEXT("SetThreadExecutionState() failed"));
    }

    //
    // Successfully created new receive job on line. Update counter
    //
    (VOID) UpdateDeviceJobsCounter ( FaxReceiveItem->LineInfo,  // Device to update
                                     FALSE,                     // Receiving
                                     1,                         // Number of new jobs
                                     TRUE);                     // Enable events
    bLineMarkedAsSending = TRUE;
    __try
    {

        LineInfo = FaxReceiveItem->LineInfo;
        Assert(LineInfo);
        JobEntry = FaxReceiveItem->JobEntry;
        Assert(JobEntry);

        //
        // Note: The receive job is not backed up by a file.
        // When we turn it into a routing job (JT_ROUTING) we will create a .FQE
        // file for it.

        JobQueue=JobEntry->lpJobQueueEntry;
        Assert(JobQueue);

        JobId = JobQueue->JobId;
        DebugPrintEx( DEBUG_MSG,
                  TEXT("[JobId: %ld] Start receive. hLine= 0x%0X hCall=0x%0X"),
                  JobId,
                  LineInfo->hLine,
                  FaxReceiveItem->hCall);

        //
        // allocate memory for the receive packet
        // this is a variable size packet based
        // on the size of the strings contained
        // withing the packet.
        //

        ReceiveSize = sizeof(FAX_RECEIVE) + FAXDEVRECEIVE_SIZE;
        FaxReceive = (PFAX_RECEIVE) MemAlloc( ReceiveSize );
        if (!FaxReceive)
        {
            TCHAR strTo[20+1]={0};
			TCHAR strDeviceName[MAX_PATH]={0};

			ReceiveFailed = TRUE;
			DebugPrintEx(DEBUG_ERR,TEXT("Failed to allocate memory for FAX_RECEIVE"));
            
			//
            // Fake job status;
            //
            bFakeStatus = TRUE;

			//
			//	Point to FakedFaxStatus on stack - all it's field are initialized to zero
			//
			pFaxStatus = &FakedFaxStatus;
			
			FakedFaxStatus.dwSizeOfStruct = sizeof (FakedFaxStatus);
            //
            // Fake general failure
            //
            pFaxStatus->dwJobStatus		 = FSPI_JS_FAILED;
            pFaxStatus->dwExtendedStatus = FSPI_ES_FATAL_ERROR;

			EnterCriticalSection (&g_CsLine);
			_tcsncpy(strTo,LineInfo->Csid,ARR_SIZE(strTo)-1);
			_tcsncpy(strDeviceName,LineInfo->DeviceName,ARR_SIZE(strDeviceName)-1);
			LeaveCriticalSection (&g_CsLine);

			FaxLog(
				FAXLOG_CATEGORY_INBOUND,
				FAXLOG_LEVEL_MIN,
				5,
				MSG_FAX_RECEIVE_FAILED_EX,
				NULL,
				NULL,
				strTo,
				NULL,
				strDeviceName
			 );
			
			
        }


		if (NULL != FaxReceive)
		{
			//
			// setup the receive packet
			//

			FaxReceive->SizeOfStruct    = ReceiveSize;

			//
			// copy filename into place
			//
			FaxReceive->FileName        = (LPTSTR) ((LPBYTE)FaxReceive + sizeof(FAX_RECEIVE));
			_tcscpy( FaxReceive->FileName, FaxReceiveItem->FileName );

			//
			// copy number into place right after filename
			//
			FaxReceive->ReceiverNumber  = (LPTSTR) ( (LPBYTE)FaxReceive->FileName +
								sizeof(TCHAR)*(_tcslen(FaxReceive->FileName) + 1));

			EnterCriticalSection (&g_CsLine);

			_tcscpy( FaxReceive->ReceiverNumber, LineInfo->Csid );
			//
			// copy device name into place right after number
			//
			FaxReceive->ReceiverName  = (LPTSTR) ( (LPBYTE)FaxReceive->ReceiverNumber +
								sizeof(TCHAR)*(_tcslen(FaxReceive->ReceiverNumber) + 1));
			_tcscpy( FaxReceive->ReceiverName, LineInfo->DeviceName );

			LeaveCriticalSection (&g_CsLine);

			FaxReceive->Reserved[0]     = 0;
			FaxReceive->Reserved[1]     = 0;
			FaxReceive->Reserved[2]     = 0;
			FaxReceive->Reserved[3]     = 0;

			Attrib = GetFileAttributes( g_wszFaxQueueDir );
			if (Attrib == 0xffffffff)
			{
				MakeDirectory( g_wszFaxQueueDir );
			}
			Attrib = GetFileAttributes( g_wszFaxQueueDir );
			if (Attrib == 0xffffffff)
			{
				USES_DWORD_2_STR;
				dwRes = GetLastError();

				FaxLog(
					FAXLOG_CATEGORY_INBOUND,
					FAXLOG_LEVEL_MIN,
					2,
					MSG_FAX_QUEUE_DIR_CREATION_FAILED,
					g_wszFaxQueueDir,
					DWORD2DECIMAL(dwRes)
					);
			}

			Attrib = GetFileAttributes( FaxReceive->FileName );
			if (Attrib == 0xffffffff)
			{
				USES_DWORD_2_STR;
				dwRes = GetLastError();

				FaxLog(
					FAXLOG_CATEGORY_INBOUND,
					FAXLOG_LEVEL_MIN,
					2,
					MSG_FAX_RECEIVE_NOFILE,
					FaxReceive->FileName,
					DWORD2DECIMAL(dwRes)
					);
				fReceiveNoFile = TRUE;
				DebugPrintEx(DEBUG_WRN,TEXT("[Job: %ld] FaxReceive - %s does not exist"), JobId, FaxReceive->FileName );

			}
			else
			{
				DebugPrintEx(DEBUG_MSG, TEXT("[Job: %ld] Starting FAX receive into %s"), JobId,FaxReceive->FileName );
			}

			//
			// do the actual receive
			//

			__try
			{

				Result = LineInfo->Provider->FaxDevReceive(
						(HANDLE) JobEntry->InstanceData,
						FaxReceiveItem->hCall,
						FaxReceive
						);

			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{

				Result = FALSE;
				DebugPrintEx(DEBUG_ERR, TEXT("[Job: %ld] FaxDevReceive() * CRASHED * . Exception code = 0x%08x"), JobId,GetExceptionCode() );
				ReceiveFailed = TRUE;
			}

			EnterCriticalSection (&g_CsJob);
			GetSystemTimeAsFileTime( (FILETIME*) &JobEntry->EndTime );
			ReceiveTime = JobEntry->StartTime;
			JobEntry->ElapsedTime = JobEntry->EndTime - JobEntry->StartTime;
			LeaveCriticalSection (&g_CsJob);

			//
			// Get the final status of the job.
			//
			dwSttRes = GetDevStatus((HANDLE)JobEntry->InstanceData,
										  LineInfo,
										  &pFaxStatus);
			if (dwSttRes != ERROR_SUCCESS)
			{
				DebugPrintEx(DEBUG_ERR,
							 TEXT("[Job: %ld] GetDevStatus failed - %d"),
							 JobId,
							 dwSttRes);
				//
				// Fake job status;
				//
				bFakeStatus = TRUE;
			}
			else if ((FSPI_JS_ABORTED         != pFaxStatus->dwJobStatus) &&
					 (FSPI_JS_COMPLETED       != pFaxStatus->dwJobStatus) &&
					 (FSPI_JS_FAILED          != pFaxStatus->dwJobStatus) &&
					 (FSPI_JS_SYSTEM_ABORT    != pFaxStatus->dwJobStatus) &&
					 (FSPI_JS_FAILED_NO_RETRY != pFaxStatus->dwJobStatus) &&
					 (FSPI_JS_DELETED         != pFaxStatus->dwJobStatus))
			{
				//
				// Status returned is unacceptable - fake one.
				//
				bFakeStatus = TRUE;
				DebugPrintEx(DEBUG_WRN,
							 TEXT("GetDevStatus return unacceptable status - %d. Faking the status"),
							 pFaxStatus->dwJobStatus);
        
				MemFree (pFaxStatus);
				pFaxStatus = NULL;
			}
			if (bFakeStatus)
			{
				//
				// Fake status code
				//
				pFaxStatus = &FakedFaxStatus;
				FakedFaxStatus.dwSizeOfStruct = sizeof (FakedFaxStatus);
				if (Result)
				{
					//
					// Fake success
					//
					pFaxStatus->dwJobStatus = FSPI_JS_COMPLETED;
				}
				else
				{
					//
					// Fake general failure
					//
					pFaxStatus->dwJobStatus = FSPI_JS_FAILED;
					pFaxStatus->dwExtendedStatus = FSPI_ES_FATAL_ERROR;
				}
			}

			if (!Result)
			{

				DebugPrintEx(DEBUG_ERR,
							 TEXT("[Job: %ld] FAX receive failed. FSP reported ")
							 TEXT("status: 0x%08X, extended status: 0x%08x"),
							 JobId,
							 pFaxStatus->dwJobStatus,
							 pFaxStatus->dwExtendedStatus);
				ReceiveFailed = TRUE;

				if (pFaxStatus->dwExtendedStatus == FSPI_ES_NOT_FAX_CALL)
				{
					DebugPrintEx(DEBUG_MSG,
								 TEXT("[Job: %ld] FSP reported that call is not ")
								 TEXT("a fax call. Handing off to RAS."),
								 JobId);
					if (HandoffCallToRas( LineInfo, FaxReceiveItem->hCall ))
					{
						FaxReceiveItem->hCall = 0;

						EnterCriticalSection (&g_CsLine);
						LineInfo->State = FPS_NOT_FAX_CALL;
						LeaveCriticalSection (&g_CsLine);
						//
						// In case of a handoff to RAS the device is still in use and can not send.
						// We do not want to notify the queue a device was freed.
						//
						DeviceCanSend = FALSE;
					}
					goto Exit;
				}
				if ( (pFaxStatus->dwExtendedStatus == FSPI_ES_FATAL_ERROR) &&
					 (!fReceiveNoFile) )
				{
					//
					// We have a partially received fax.
					// try to recover one or more pages of the received fax.
					//
					if (!TiffRecoverGoodPages(FaxReceive->FileName,&RecoveredPages,&TotalPages) )
					{
						//
						// couldn't recover any pages, just log an error and delete the received fax.
						//
						LPTSTR ToStr;
						TCHAR TotalCountStrBuf[64];

						if (pFaxStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_PAGECOUNT)
						{
							_ltot((LONG) pFaxStatus->dwPageCount, TotalCountStrBuf, 10);
						}
						else
						{
							_ltot((LONG) 0, TotalCountStrBuf, 10);
						}

						if ( (NULL == pFaxStatus->lpwstrRoutingInfo) ||
							 (pFaxStatus->lpwstrRoutingInfo[0] == TEXT('\0')) )
						{
							ToStr = FaxReceive->ReceiverNumber;
						}
						else
						{
							ToStr = pFaxStatus->lpwstrRoutingInfo;
						}


						FaxLog(
							   FAXLOG_CATEGORY_INBOUND,
							   FAXLOG_LEVEL_MIN,
							   5,
							   MSG_FAX_RECEIVE_FAILED_EX,
							   pFaxStatus->lpwstrRemoteStationId,
							   pFaxStatus->lpwstrCallerId,
							   ToStr,
							   TotalCountStrBuf,
							   JobEntry->LineInfo->DeviceName
							   );
					}
					else
					{
						//
						// recovered some pages, log a message and add to job queue
						//
						TCHAR RecoverCountStrBuf[64];
						TCHAR TotalCountStrBuf[64];
						TCHAR TimeStr[128];
						LPTSTR ToStr;

						FormatElapsedTimeStr(
							(FILETIME*)&JobEntry->ElapsedTime,
							TimeStr,
							sizeof(TimeStr)
							);

						_ltot((LONG) RecoveredPages, RecoverCountStrBuf, 10);
						_ltot((LONG) TotalPages, TotalCountStrBuf, 10);

						if ( (NULL == pFaxStatus->lpwstrRoutingInfo) ||
							 (pFaxStatus->lpwstrRoutingInfo[0] == TEXT('\0')) )
						{
							ToStr = FaxReceive->ReceiverNumber;
						}
						else
						{
							ToStr = pFaxStatus->lpwstrRoutingInfo;
						}
						FaxLog(
							   FAXLOG_CATEGORY_INBOUND,
							   FAXLOG_LEVEL_MIN,
							   8,
							   MSG_FAX_RECEIVE_FAIL_RECOVER,
							   FaxReceive->FileName,
							   pFaxStatus->lpwstrRemoteStationId,
							   pFaxStatus->lpwstrCallerId,
							   ToStr,
							   RecoverCountStrBuf,
							   TotalCountStrBuf,
							   TimeStr,
							   JobEntry->LineInfo->DeviceName
							  );

						// Partially received fax - change status and extended status
						pFaxStatus->dwJobStatus = FSPI_JS_COMPLETED;
						pFaxStatus->dwExtendedStatus = FSPI_ES_PARTIALLY_RECEIVED;
						DoFaxRoute = TRUE;
					}
				}

				if (pFaxStatus->dwJobStatus == FSPI_JS_ABORTED)
				{
					FaxLog(
						FAXLOG_CATEGORY_INBOUND,
						FAXLOG_LEVEL_MAX,
						0,
						MSG_FAX_RECEIVE_USER_ABORT
						);
				}
			}
			else
			{
				__try
				{
					TCHAR PageCountStrBuf[64];
					TCHAR TimeStr[128];
					LPTSTR ToStr;

					if (!TiffPostProcessFast( FaxReceive->FileName, NULL ))
					{
						DebugPrintEx(
							DEBUG_WRN,
							TEXT("[Job: %ld] failed to post process the TIFF file, FileName %s"),
							JobId,
							FaxReceive->FileName);
					}

					DebugPrintEx(
						DEBUG_MSG,
						TEXT("[Job: %ld] FAX receive succeeded"),
						JobId);

					FormatElapsedTimeStr(
						(FILETIME*)&JobEntry->ElapsedTime,
						TimeStr,
						sizeof(TimeStr)
						);

					_ltot((LONG) pFaxStatus->dwPageCount, PageCountStrBuf, 10);

					if ( (NULL == pFaxStatus->lpwstrRoutingInfo) ||
						 (pFaxStatus->lpwstrRoutingInfo[0] == TEXT('\0')) )
					{
						ToStr = FaxReceive->ReceiverNumber;
					}
					else
					{
						ToStr = pFaxStatus->lpwstrRoutingInfo;
					}
					FaxLog(
						FAXLOG_CATEGORY_INBOUND,
						FAXLOG_LEVEL_MAX,
						7,
						MSG_FAX_RECEIVE_SUCCESS,
						FaxReceive->FileName,
						pFaxStatus->lpwstrRemoteStationId,
						pFaxStatus->lpwstrCallerId,
						ToStr,
						PageCountStrBuf,
						TimeStr,
						JobEntry->LineInfo->DeviceName
						);

					ElapsedTime = JobEntry->ElapsedTime;
					DoFaxRoute = TRUE;
				}
				__except (EXCEPTION_EXECUTE_HANDLER)
				{
					DebugPrintEx(DEBUG_ERR, TEXT("[Job: %ld] failed to post process the TIFF file, ec=%x"), JobId, GetExceptionCode() );
					ReceiveFailed = TRUE;
				}
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{

		DebugPrintEx( DEBUG_ERR,TEXT("[Job: %ld] FAX receive failed due to exception in device provider, ec=0x%08x"), JobId,GetExceptionCode() );
		ReceiveFailed = TRUE;
	}

	if (g_pFaxPerfCounters && ReceiveFailed && LineInfo->State != FPS_NOT_FAX_CALL)
	{
		InterlockedIncrement( (PLONG)&g_pFaxPerfCounters->InboundFailedReceive );
	}


    //
    // Call FaxDevEndJob() and Release the receive device but do not delete the job.
    //
    if (!ReleaseJob( JobEntry ))
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[Job: %ld] FAX ReleaseJob failed , ec=0x%08x"),
                      JobId,
                      GetLastError());
    }
    //
    // We just successfully completed a receive job on the device - update counter.
    //
    (VOID) UpdateDeviceJobsCounter ( LineInfo,   // Device to update
                                     FALSE,      // Receiving
                                     -1,         // Number of new jobs (-1 = decrease by one)
                                     TRUE);      // Enable events
    bLineMarkedAsSending = FALSE;


    //
    // Update the FSPIJobStatus in the JobEntry
    //
    EnterCriticalSection (&g_CsJob); // Block FaxStatusThread
    if (!UpdateJobStatus(JobEntry, pFaxStatus, FALSE)) // FALSE - No extended event is needed
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("[JobId: %ld] UpdateJobStatus() failed (ec: %ld)."),
            JobEntry->lpJobQueueEntry->JobId,
            GetLastError());
    }
    JobEntry->fStopUpdateStatus = TRUE; // Stop FaxStatusThread from changing this status

    //
    // Save the last extended status
    //
    wcscpy (LastExStatusString, JobEntry->ExStatusString);
    dwLastJobExtendedStatus = pFaxStatus->dwExtendedStatus;
    LeaveCriticalSection (&g_CsJob);

    //
    // route the newly received fax
    //

    if (DoFaxRoute)
    {
        HANDLE hFind;
        WIN32_FIND_DATA FindFileData;
        DWORD Bytes = 0 ;
        BOOL fArchiveSuccess = FALSE;
        BOOL fArchiveInbox;

        //
        // Change JobStatus to JS_ROUTING - This means that the reception is completed succesfully/partially
        //
        EnterCriticalSectionJobAndQueue;
        JobQueue->JobStatus = JS_ROUTING;
        //
        // CreteFaxEventEx
        //
        dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                   JobQueue
                                 );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                JobQueue->UniqueId,
                dwRes);
        }
        LeaveCriticalSectionJobAndQueue;

        EnterCriticalSection (&g_CsConfig);
        lstrcpyn (  wszArchiveFolder,
                    g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder,
                    MAX_PATH);
        LeaveCriticalSection (&g_CsConfig);

        hr = CoInitialize (NULL);
        if (FAILED (hr))
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("CoInitilaize failed, err %ld"),
                          hr);
            USES_DWORD_2_STR;
            FaxLog(
                FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MIN,
                3,
                MSG_FAX_ARCHIVE_FAILED,
                JobQueue->FileName,
                wszArchiveFolder,
                DWORD2DECIMAL(hr)
            );
        }
        else
        {
            fCOMInitiliazed = TRUE;
        }

        EnterCriticalSection (&g_CsConfig);
        fArchiveInbox = g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].bUseArchive;
        LeaveCriticalSection (&g_CsConfig);


        if (fArchiveInbox)
        {
            //
            // Add the Microsoft Fax tags to the file
            // this is necessary ONLY when we archive the
            // file when doing a receive.  if we are not
            // routing the file then it is deleted, so
            // adding the tags is not necessary.
            //
            if (NULL != pFaxStatus->lpwstrRoutingInfo)
            {
                MsTagInfo.Routing       = pFaxStatus->lpwstrRoutingInfo;
            }

            if (NULL != pFaxStatus->lpwstrCallerId)
            {
                MsTagInfo.CallerId       = pFaxStatus->lpwstrCallerId;
            }

            if (NULL != pFaxStatus->lpwstrRemoteStationId)
            {
                MsTagInfo.Tsid       = pFaxStatus->lpwstrRemoteStationId;
            }

            if (pFaxStatus->fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_PAGECOUNT)
            {
                MsTagInfo.Pages       = pFaxStatus->dwPageCount;
            }

            MsTagInfo.Csid          = FaxReceive->ReceiverNumber;
            MsTagInfo.Port          = FaxReceive->ReceiverName;
            MsTagInfo.Type          = JT_RECEIVE;

            MsTagInfo.dwStatus          = JS_COMPLETED; // We archive only succesfull/Partially received faxes
            MsTagInfo.dwExtendedStatus  = pFaxStatus->dwExtendedStatus;

            if (!GetRealFaxTimeAsFileTime (JobEntry, FAX_TIME_TYPE_START, (FILETIME*)&MsTagInfo.StartTime))
            {
                MsTagInfo.StartTime = 0;
                DebugPrintEx(DEBUG_ERR,TEXT("GetRealFaxTimeAsFileTime (Start time)  Failed (ec: %ld)"), GetLastError() );
            }

            if (!GetRealFaxTimeAsFileTime (JobEntry, FAX_TIME_TYPE_END, (FILETIME*)&MsTagInfo.EndTime))
            {
                MsTagInfo.EndTime = 0;
                DebugPrintEx(DEBUG_ERR,TEXT("GetRealFaxTimeAsFileTime (Eend time) Failed (ec: %ld)"), GetLastError() );
            }
            //
            // Archive the file
            //
            if (!MakeDirectory( wszArchiveFolder ))
            {
                USES_DWORD_2_STR;
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("MakeDirectory() [%s] failed (ec: %ld)"),
                    wszArchiveFolder,
                    ec);
                FaxLog(
                        FAXLOG_CATEGORY_INBOUND,
                        FAXLOG_LEVEL_MIN,
                        2,
                        MSG_FAX_ARCHIVE_CREATE_FAILED,
                        wszArchiveFolder,
                        DWORD2DECIMAL(ec)
                    );
            }
            else
            {
                if (!GenerateUniqueArchiveFileName(  wszArchiveFolder,
                                                     ArchiveFileName,
                                                     JobQueue->UniqueId,
                                                     NULL))
                {
                    USES_DWORD_2_STR;
                    ec = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to generate unique name for archive file at dir [%s] (ec: %ld)"),
                        wszArchiveFolder,
                        ec);
                    FaxLog(
                           FAXLOG_CATEGORY_INBOUND,
                           FAXLOG_LEVEL_MIN,
                           1,
                           MSG_FAX_ARCHIVE_CREATE_FILE_FAILED,
                           DWORD2DECIMAL(ec)
                    );
                }
                else
                {
                    Assert(JobQueue->FileName);

                    if (!CopyFile( JobQueue->FileName, ArchiveFileName, FALSE ))
                    {
                        USES_DWORD_2_STR;
                        ec = GetLastError();
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CopyFile [%s] to [%s] failed. (ec: %ld)"),
                            JobQueue->FileName,
                            ArchiveFileName,
                            ec);
                        FaxLog(
                           FAXLOG_CATEGORY_INBOUND,
                           FAXLOG_LEVEL_MIN,
                           1,
                           MSG_FAX_ARCHIVE_CREATE_FILE_FAILED,
                           DWORD2DECIMAL(ec)
                        );

                        if (!DeleteFile(ArchiveFileName))
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("DeleteFile [%s] failed. (ec: %ld)"),
                                ArchiveFileName,
                                GetLastError());
                        }
                    }
                    else
                    {
                        BOOL bTagsEventLogged = FALSE;  // Did we issue event MSG_FAX_ARCHIVE_NO_TAGS?
                        //
                        // Store archive properties as TIFF tags (always)
                        //
                        if (!TiffAddMsTags( ArchiveFileName, &MsTagInfo, FALSE ))
                        {
                            USES_DWORD_2_STR;
                            ec = GetLastError ();
                            DebugPrintEx( DEBUG_ERR,
                                          TEXT("TiffAddMsTags failed, ec = %ld"),
                                          ec);
                            FaxLog(
                                FAXLOG_CATEGORY_INBOUND,
                                FAXLOG_LEVEL_MIN,
                                2,
                                MSG_FAX_ARCHIVE_NO_TAGS,
                                ArchiveFileName,
                                DWORD2DECIMAL(ec)
                            );
                            bTagsEventLogged = TRUE;
                        }
                        //
                        // Also attempt to persist inbound information using IPropertyStorage-NTFS File System
                        //
                        if (fCOMInitiliazed)
                        {
                            if (!AddNTFSStorageProperties ( ArchiveFileName, &MsTagInfo, FALSE ))
                            {
                                USES_DWORD_2_STR;
                                ec = GetLastError();
                                if (ERROR_OPEN_FAILED != ec)
                                {
                                    //
                                    // If AddNTFSStorageProperties fails with ERROR_OPEN_FAIL then the archive
                                    // folder is not on an NTFS 5 partition.
                                    // This is ok - NTFS properties are a backup mechanism but not a must
                                    //
                                    DebugPrintEx( DEBUG_ERR,
                                                  TEXT("AddNTFSStorageProperties failed, ec = %ld"),
                                                  ec);
                                    if (!bTagsEventLogged)
                                    {
                                        FaxLog(
                                            FAXLOG_CATEGORY_INBOUND,
                                            FAXLOG_LEVEL_MIN,
                                            2,
                                            MSG_FAX_ARCHIVE_NO_TAGS,
                                            ArchiveFileName,
                                            DWORD2DECIMAL(ec)
                                        );
                                        bTagsEventLogged = TRUE;
                                    }
                                }
                                else
                                {
                                    DebugPrintEx( DEBUG_WRN,
                                                  TEXT("AddNTFSStorageProperties failed with ERROR_OPEN_FAIL. Probably not an NTFS 5 partition"));
                                }
                            }
                        }
                        fArchiveSuccess = TRUE;
                    }
                }
            }

            if (fArchiveSuccess == FALSE)
            {
                USES_DWORD_2_STR;
                FaxLog(
                    FAXLOG_CATEGORY_INBOUND,
                    FAXLOG_LEVEL_MIN,
                    3,
                    MSG_FAX_ARCHIVE_FAILED,
                    JobQueue->FileName,
                    wszArchiveFolder,
                    DWORD2DECIMAL(ec)
                );
            }
            else
            {
                dwRes = CreateArchiveEvent (JobQueue->UniqueId,
                                            FAX_EVENT_TYPE_IN_ARCHIVE,
                                            FAX_JOB_EVENT_TYPE_ADDED,
                                            NULL);
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_*_ARCHIVE) failed (ec: %lc)"),
                        dwRes);
                }

                hFind = FindFirstFile( ArchiveFileName, &FindFileData);
                if (INVALID_HANDLE_VALUE == hFind)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("FindFirstFile failed (ec: %lc), File %s"),
                        GetLastError(),
                        ArchiveFileName);
                }
                else
                {
                    // Update the archive size - for quota management
                    EnterCriticalSection (&g_CsConfig);
                    if (FAX_ARCHIVE_FOLDER_INVALID_SIZE != g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].dwlArchiveSize)
                    {
                        g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].dwlArchiveSize += (MAKELONGLONG(FindFileData.nFileSizeLow ,FindFileData.nFileSizeHigh));
                    }
                    LeaveCriticalSection (&g_CsConfig);

                    if (!FindClose(hFind))
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("FindClose failed (ec: %lc)"),
                            GetLastError());
                    }
                }

                FaxLog(
                    FAXLOG_CATEGORY_INBOUND,
                    FAXLOG_LEVEL_MAX,
                    2,
                    MSG_FAX_RECEIVED_ARCHIVE_SUCCESS,
                    JobQueue->FileName,
                    ArchiveFileName
                );
            }
        }

        //
        // The fax receive operation was successful.
        //
        EnterCriticalSection (&g_CsQueue);
        JobQueue->PageCount = pFaxStatus->dwPageCount;

       // Get the file size
        hFind = FindFirstFile( FaxReceive->FileName, &FindFileData);
        if (INVALID_HANDLE_VALUE == hFind)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindFirstFile failed (ec: %lc), File %s"),
                GetLastError(),
                FaxReceive->FileName);
        }
        else
        {
            Bytes = FindFileData.nFileSizeLow;
            if (!FindClose(hFind))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FindClose failed (ec: %lc)"),
                    GetLastError());
            }
        }

        JobQueue->FileSize = Bytes;

        LeaveCriticalSection( &g_CsQueue );


        if (g_pFaxPerfCounters)
        {
            SYSTEMTIME SystemTime ;
            if (FileTimeToSystemTime( (FILETIME*)&ElapsedTime, &SystemTime ))
            {
                DWORD Seconds ;

                InterlockedIncrement( (LPLONG) &g_pFaxPerfCounters->InboundFaxes ) ;
                InterlockedIncrement( (LPLONG) &g_pFaxPerfCounters->TotalFaxes ) ;
                Seconds = (DWORD)( SystemTime.wSecond + 60 * ( SystemTime.wMinute + 60 * SystemTime.wHour ));
                InterlockedExchangeAdd( (PLONG)&g_pFaxPerfCounters->InboundPages, (LONG)pFaxStatus->dwPageCount );
                InterlockedExchangeAdd( (PLONG)&g_pFaxPerfCounters->TotalPages, (LONG)pFaxStatus->dwPageCount );

                EnterCriticalSection( &g_CsPerfCounters );

                g_dwInboundSeconds += Seconds;
                g_dwTotalSeconds += Seconds;
                g_pFaxPerfCounters->InboundMinutes = g_dwInboundSeconds/60 ;
                g_pFaxPerfCounters->TotalMinutes = g_dwTotalSeconds/60;
                g_pFaxPerfCounters->InboundBytes += Bytes;
                g_pFaxPerfCounters->TotalBytes += Bytes;

                LeaveCriticalSection( &g_CsPerfCounters );
            }
            else
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FileTimeToSystemTime failed (ec: %ld)"),
                    GetLastError());
            }
        }


        PFAX_ROUTE Route = (PFAX_ROUTE)MemAlloc( sizeof(FAX_ROUTE) );
        if (Route == NULL)
        {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("MemAlloc failed to allocate FAX_ROUTE (ec: %ld)"),
                    GetLastError());
            goto Exit;
        }

        BOOL RouteSucceeded;
        PROUTE_FAILURE_INFO RouteFailureInfo;
        DWORD CountFailureInfo;
        //
        // now setup the fax routing data structure
        //

        Route->SizeOfStruct    = sizeof(FAX_ROUTE);
        Route->JobId           = JobId;
        Route->ElapsedTime     = ElapsedTime;
        Route->ReceiveTime     = ReceiveTime;
        Route->PageCount       = pFaxStatus->dwPageCount;

        Route->Csid            = StringDup( LineInfo->Csid );
        if (LineInfo->Csid && !Route->Csid)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StringDup( LineInfo->Csid ) failed (ec: %ld)"),
                GetLastError());
        }

        if (NULL != pFaxStatus->lpwstrRemoteStationId)
        {
            Route->Tsid = StringDup( pFaxStatus->lpwstrRemoteStationId );
            if (!Route->Tsid)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StringDup( pFaxStatus->lpwstrRemoteStationId ) ")
                    TEXT("failed (ec: %ld)"),
                    GetLastError());
            }
        }
        if (NULL != pFaxStatus->lpwstrCallerId)
        {
            Route->CallerId = StringDup( pFaxStatus->lpwstrCallerId );
            if (!Route->CallerId)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StringDup( pFaxStatus->lpwstrCallerId  ) failed ")
                    TEXT("(ec: %ld)"),
                    GetLastError());
            }
        }
        Route->ReceiverName    = StringDup( FaxReceive->ReceiverName );
        if (FaxReceive->ReceiverName && !Route->ReceiverName)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StringDup( FaxReceive->ReceiverName  ) failed ")
                TEXT("(ec: %ld)"),
                GetLastError());
        }
        Route->ReceiverNumber  = StringDup( FaxReceive->ReceiverNumber );
        if (FaxReceive->ReceiverNumber && !Route->ReceiverNumber)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StringDup( FaxReceive->ReceiverNumber  ) failed ")
                TEXT("(ec: %ld)"),
                GetLastError());
        }
        Route->DeviceName      = StringDup(LineInfo->DeviceName);
        if (LineInfo->DeviceName && !Route->DeviceName)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StringDup( LineInfo->DeviceName  ) failed ")
                TEXT("(ec: %ld)"),
                GetLastError());
        }
        Route->DeviceId        = LineInfo->PermanentLineID;
        if (NULL != pFaxStatus->lpwstrRoutingInfo)
        {
            Route->RoutingInfo = StringDup( pFaxStatus->lpwstrRoutingInfo );
            if (!Route->RoutingInfo)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("StringDup( pFaxStatus->lpwstrRoutingInfo  ) ")
                    TEXT("failed (ec: %ld)"),
                    GetLastError());
            }
        }
        JobQueue->FaxRoute     = Route;

        RouteSucceeded = FaxRoute(
            JobQueue,
            FaxReceive->FileName,
            Route,
            &RouteFailureInfo,
            &CountFailureInfo
            );

        if ( RouteSucceeded && (CountFailureInfo == 0) )
        {
            DebugPrintEx(DEBUG_MSG,
                _T("[Job Id: %ld] Routing SUCCEEDED."),
                JobQueue->UniqueId);
        }
        else
        {
            DebugPrintEx(DEBUG_MSG,
                _T("[Job Id: %ld] Routing FAILED."),
                JobQueue->UniqueId);

            if (CountFailureInfo == 0)
            {
                //
                //  We failed in the FaxRoute() and did not checked any Routing Method
                //
                WCHAR TmpStr[20] = {0};

                swprintf(TmpStr,TEXT("0x%016I64x"), JobQueue->UniqueId);

                FaxLog(FAXLOG_CATEGORY_INBOUND,
                    FAXLOG_LEVEL_MIN,
                    3,
                    MSG_FAX_ROUTE_FAILED,
                    TmpStr,
                    Route->DeviceName,
                    Route->Tsid
                    );
            }
            else
            {
                //
                //  There are some routing methods failed
                //

                TCHAR QueueFileName[MAX_PATH];
                DWORDLONG dwlUniqueId;
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("[Job Id: %ld] Routing FAILED."));

                EnterCriticalSectionJobAndQueue;

                //
                // Now we turn the receive job to a routing (JT_ROUTING) job.
                // The receive job was not committed to file but the routing job must be.
                // So we create a FQR file for it.
                //
                dwlUniqueId = GenerateUniqueQueueFile( JT_ROUTING,
                                                       QueueFileName,
                                                       sizeof(QueueFileName)/sizeof(WCHAR) );
                if (!dwlUniqueId)
                {
                    //
                    // Failed to generate a unique id for the routing job.
                    // This is a critical error. Job will be lost when the service stops.
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("[JobId: %ld] Failed to generate unique id for routing job. (ec: %ld)"),
                        JobQueue->JobId,
                        GetLastError());
                    Assert ( JobQueue->QueueFileName == NULL );
                }
                else
                {
                    JobQueue->QueueFileName = StringDup( QueueFileName );
                    if (!JobQueue->QueueFileName)
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("[JobId: %ld] StringDup( QueueFileName) failed for routing job.  (ec: %ld)"),
                            JobQueue->JobId,
                            GetLastError());

                        if (!DeleteFile (QueueFileName))
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("DeleteFile.  (ec: %ld)"),
                                GetLastError());
                        }
                    }

                }

                JobQueue->CountFailureInfo = CountFailureInfo;
                JobQueue->pRouteFailureInfo = RouteFailureInfo;
                JobQueue->StartTime = JobEntry->StartTime;
                JobQueue->EndTime = JobEntry->EndTime;


                //
                // check if we are supposed to retry.
                //
                EnterCriticalSection (&g_CsConfig);
                DWORD dwMaxRetries = g_dwFaxSendRetries;
                LeaveCriticalSection (&g_CsConfig);

                if (0 == dwMaxRetries)
                {
                    JobQueue->JobStatus = JS_RETRIES_EXCEEDED;

                    WCHAR TmpStr[20] = {0};
                    swprintf(TmpStr,TEXT("0x%016I64x"), JobQueue->UniqueId);

                    FaxLog(FAXLOG_CATEGORY_INBOUND,
                        FAXLOG_LEVEL_MIN,
                        3,
                        MSG_FAX_ROUTE_FAILED,
                        TmpStr,
                        JobQueue->FaxRoute->DeviceName,
                        JobQueue->FaxRoute->Tsid
                        );
                }
                else
                {
                    JobQueue->JobStatus = JS_RETRYING;
                }

                //
                // A job changes its type from RECEIVING to ROUTING after the 1st routing failure.
                // This is a 2 stages change:
                // 1. JT_RECEIVE__JS_ROUTING -> JT_RECEIVE__JS_RETRYING/JS_RETRIES_EXCEEDED
                // 2. JT_RECEIVE__JS_RETRYING/JS_RETRIES_EXCEEDED -> JT_ROUTING__JS_RETRYING/JS_ROUTING_EXCEEDED
                //
                // The server activity counters g_ServerActivity are updated in the first change.
                //
                JobQueue->JobType = JT_ROUTING;

                if (JobQueue->JobStatus == JS_RETRIES_EXCEEDED)
                {
                    MarkJobAsExpired(JobQueue);
                }
                else
                {
                    JobQueue->SendRetries++;
                    RescheduleJobQueueEntry( JobQueue );  // This will also commit the job to a file
                }

                #if DEBUG
                WCHAR szSchedule[256] = {0};
                DebugDateTime(JobQueue->ScheduleTime,szSchedule);
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("[JobId: %ld] Transformed into JT_ROUTING job."),
                    JobQueue->JobId,
                    szSchedule);
                #endif //#if DEBUG

                //
                // CreteFaxEventEx
                //
                dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                           JobQueue
                                         );
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                        JobQueue->UniqueId,
                        dwRes);
                }
                LeaveCriticalSectionJobAndQueue;
            }
        }
    }

Exit:
    //
    // This code executes wether the receive operation succeeded or failed.
    // If the job suceeded we already removed the queue entry (if routing succeeded)
    // or transformed it into routing job (if routing failed).
    //
    if (bLineMarkedAsSending)
    {
        //
        // We got here after some error and the line counter for sending is still up by 1.
        // Decrease the counter now.
        //
        (VOID) UpdateDeviceJobsCounter ( LineInfo,   // Device to update
                                         FALSE,      // Receiving
                                         -1,         // Number of new jobs (-1 = decrease by one)
                                         TRUE);      // Enable events
    }

    EnterCriticalSectionJobAndQueue;
    Assert(JobQueue);

    //
    // Log Inbound Activity
    //
    EnterCriticalSection (&g_CsInboundActivityLogging);
    if (INVALID_HANDLE_VALUE == g_hOutboxActivityLogFile)
    {
        DebugPrintEx(DEBUG_ERR,
                  TEXT("Logging not initialized"));
    }
    else
    {
        if (!LogInboundActivity(JobQueue, pFaxStatus))
        {
            DebugPrintEx(DEBUG_ERR, TEXT("Logging inbound activity failed"));
        }
    }
    LeaveCriticalSection (&g_CsInboundActivityLogging);

    if (fCOMInitiliazed == TRUE)
    {
        CoUninitialize ();
    }

    EndJob( JobEntry);
    JobQueue->JobEntry = NULL;
    if (JobQueue->JobType == JT_RECEIVE)
    {
        //
        // Set the final receive job status
        //
        if (FALSE == DoFaxRoute)
        {
            if (FSPI_JS_ABORTED == pFaxStatus->dwJobStatus)
            {
                JobQueue->JobStatus = JS_CANCELED;
            }
            else
            {
                JobQueue->JobStatus = JS_FAILED;
            }
            wcscpy (JobQueue->ExStatusString, LastExStatusString);
            JobQueue->dwLastJobExtendedStatus = dwLastJobExtendedStatus;

            //
            // CreteFaxEventEx
            //
            dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                       JobQueue
                                     );
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                    JobQueue->UniqueId,
                    dwRes);
            }
        }

        //
        // we remove the job unless it was turned into a routing job
        //
        JobQueue->JobStatus = JS_DELETING;
        DecreaseJobRefCount (JobQueue, TRUE); // TRUE means notify
    }
    LeaveCriticalSectionJobAndQueue;

    //
    // clean up and exit
    //

    MemFree( FaxReceiveItem->FileName );
    MemFree( FaxReceiveItem );
    MemFree( FaxReceive );
    if (!bFakeStatus)
    {
        MemFree( pFaxStatus );
        pFaxStatus = NULL;
    }
    else
    {
        //
        // This is a faked job status - pointing to a structure on the stack.
        //
    }
    //
    // signal our queue if we now have a send capable device available.
    // (DeviceCanSend will be false if we did a RAS handoff, since the device is still in use
    //
    if (TRUE == DeviceCanSend)
    {
        // Not a handoff job - check if the device is send enabled
        EnterCriticalSection (&g_CsLine);
        DeviceCanSend = ((LineInfo->Flags & FPF_SEND) == FPF_SEND);
        LeaveCriticalSection (&g_CsLine);
    }
    if (DeviceCanSend)
    {

        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());

            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    //
    // Let the system go back to sleep. Set the system idle timer.
    //
    if (TRUE == fSetSystemIdleTimer)
    {
        if (NULL == SetThreadExecutionState(ES_CONTINUOUS))
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("SetThreadExecutionState() failed"));
        }
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return rVal;
}   // FaxReceiveThread


DWORD
StartFaxReceive(
    PJOB_ENTRY      JobEntry,
    HCALL           hCall,
    PLINE_INFO      LineInfo,
    LPTSTR          FileName,
    DWORD           FileNameSize
    )

/*++

Routine Description:

    This function start a FAX receive operation by creating
    a thread that calls the appropriate device provider.

Arguments:

    JobEntry        - Newly allocated job
    hCall           - Call handle
    LineInfo        - LINE_INFO pointer
    FileName        - Receive file name
    FileNameSize    - File name size

Return Value:

    Error code.

--*/

{
    PFAX_RECEIVE_ITEM FaxReceiveItem = NULL;
    DWORD rVal = ERROR_SUCCESS;
    HANDLE hThread;
    DWORD ThreadId;
    PJOB_QUEUE lpRecvJobQEntry=NULL;
    DWORDLONG   UniqueJobId;
    DWORD dwRes;

    DEBUG_FUNCTION_NAME(TEXT("StartFaxReceive"));

    //
    // generate a filename for the received fax
    //
    UniqueJobId = GenerateUniqueQueueFile( JT_RECEIVE, FileName, FileNameSize );
    if (UniqueJobId == 0) {
        rVal=GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GenerateUniqueQueueFile for receive file has failed. (ec: %ld) "),
            GetLastError());
        goto Error;
    }


    //
    // allocate the fax receive structure
    //

    FaxReceiveItem =(PFAX_RECEIVE_ITEM) MemAlloc( sizeof(FAX_RECEIVE_ITEM) );
    if (!FaxReceiveItem)
    {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    //
    // setup the fax receive values
    //
    FaxReceiveItem->hCall      = hCall;
    FaxReceiveItem->LineInfo   = LineInfo;
    FaxReceiveItem->JobEntry   = JobEntry;
    FaxReceiveItem->FileName   = StringDup( FileName );
    if (! FaxReceiveItem->FileName )
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StringDup( FileName ) failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpRecvJobQEntry =AddReceiveJobQueueEntry(FaxReceiveItem->FileName,JobEntry,JT_RECEIVE, UniqueJobId);
    if (!lpRecvJobQEntry)
    {
         rVal = ERROR_NOT_ENOUGH_MEMORY;
         goto Error;
    }
    JobEntry->CallHandle       = hCall;
    LineInfo->State            = FPS_INITIALIZING;
    //
    //  Crete FAX_EVENT_EX.
    //
    dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_ADDED,
                               lpRecvJobQEntry
                             );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_ADDED) failed for job id %ld (ec: %lc)"),
            UniqueJobId,
            dwRes);
    }


    //
    // start the receive operation
    //
    //
    // Note:
    // If FAX_ABORT happens here (no g_CsQueue protection) the job is alrady is JS_INPROGRESS state so FaxDevAbortOperation() is called.
    // The recieve thread will catch it when it calls FaxDevReceive() (it will get back an error indicating a user abort).
    // FaxReceiveThread() will then cleanup the job and remove it from the queue.
    //
    hThread = CreateThreadAndRefCount(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) FaxReceiveThread,
        (LPVOID) FaxReceiveItem,
        0,
        &ThreadId
        );

    if (!hThread)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create FaxReceiveThread (CreateThreadAndRefCount) (ec: %ld)"),
            GetLastError());
        MemFree( FaxReceiveItem );
        rVal = GetLastError();
        goto Error;
    }
    else
    {
        CloseHandle( hThread );
    }
    goto exit;

Error:

    //
    // EndJob() must be called before RemoveReceiveJob() !!!
    //
    EndJob(JobEntry);

    if (lpRecvJobQEntry)
    {
        lpRecvJobQEntry->JobEntry = NULL;
        DecreaseJobRefCount (lpRecvJobQEntry, FALSE); // do not notify the clients
        //
        // Note that this does not free the running job entry.
        //
    }

    if (FaxReceiveItem) {
        MemFree(FaxReceiveItem);
        MemFree(FaxReceiveItem->FileName);
    }

    FaxLog(
        FAXLOG_CATEGORY_INBOUND,
        FAXLOG_LEVEL_MIN,
        0,
        MSG_FAX_RECEIVE_FAILED
        );

exit:

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\receipts.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Receipts.cpp

Abstract:

    Implementation of the fax DR/NDR mechanism

Author:

    Eran Yariv (EranY)  Feb, 2000

Revision History:

--*/

#include "faxsvc.h"
#include "lmcons.h" // Required by lmmsg.h
#include "lmmsg.h"  // Exports NetMessageBufferSend

//
// Static functions:
//
static
BOOL
TimeToString(
    const FILETIME *pft,
    wstring &wstr
) throw (exception);

static
BOOL
PrepareReceiptSubject (
    BOOL             bPositive,
    BOOL             bBroadcast,
    const JOB_QUEUE *lpcJobQueue,
    LPWSTR          * pwstrSubject
);

static
BOOL
GetNumericResourceValue (
    int iResourceId,
    DWORD &dwValue
);

static
BOOL
AddRecipientLine (
    const JOB_QUEUE *lpcJobQueue,
    BOOL             bDisplayError,
    wstring         &wstrLine
) throw (exception);

static
BOOL
PrepareReceiptBody(
    BOOL              bPositive,
    BOOL             bBroadcast,
    const JOB_QUEUE * lpcJobQueue,
    LPCWSTR           lpcwstrSubject,
    BOOL              bAttachment,
    LPWSTR          * ppwstrBody
) throw (exception);

static
BOOL
PrepareReceiptErrorString (
    const JOB_QUEUE *lpcJobQueue,
    wstring         &wstrError
) throw (exception);


//
// Implementations
//


BOOL
TimeToString(
    const FILETIME *pft,
    wstring &wstr
) throw (exception)
/*++

Routine name : TimeToString

Routine description:

    Converts a FILETIME to a string, according to system's locale.

    This function may throw STL exceptions in case of string errors.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    pft         [in]     - Pointer to FILETIME
    wstr        [out]    - Reference to output time string.

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("TimeToString"));
    Assert (pft);

    FILETIME    tmLocalTime;
    SYSTEMTIME  tmSystemTime;
    LPWSTR      lpwstrTime;
    int         iRequiredBufSize;

    //
    // Convert time from UTC to local time zone
    //
    if (!FileTimeToLocalFileTime( pft, &tmLocalTime ))
    {
        ec=GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToLocalFileTime failed. (ec: %ld)"),
            ec);
        goto exit;
    }
    if (!FileTimeToSystemTime( &tmLocalTime, &tmSystemTime ))
    {
        ec=GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToSystemTime failed. (ec: %ld)"),
            ec);
        goto exit;
    }
    //
    // Find required string size
    //
    iRequiredBufSize = FaxTimeFormat(
       LOCALE_SYSTEM_DEFAULT,
       LOCALE_NOUSEROVERRIDE,
       &tmSystemTime,
       NULL,
       NULL,
       0
       );

    Assert (iRequiredBufSize);
    //
    // Allocate string buffer
    //
    WCHAR wszTime[256];
    lpwstrTime = wszTime;
    if (iRequiredBufSize > sizeof (wszTime) / sizeof (wszTime[0]))
    {
        //
        // The static buffer is not enough, allocate one from the heap
        //
        lpwstrTime = (LPWSTR) MemAlloc (iRequiredBufSize);
        if (!lpwstrTime)
        {
            ec=GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("MemAlloc failed. (ec: %ld)"),
                ec);
            goto exit;
        }
    }
    //
    // Format time into result string
    //
    if (!FaxTimeFormat(
       LOCALE_SYSTEM_DEFAULT,
       LOCALE_NOUSEROVERRIDE,
       &tmSystemTime,
       NULL,
       lpwstrTime,
       iRequiredBufSize
       ))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxTimeFormat failed. (ec: %ld)"),
            ec);
        goto exit;
    }

    wstr = lpwstrTime;
    Assert (ERROR_SUCCESS == ec);

exit:
    if ((lpwstrTime != wszTime) && (NULL != lpwstrTime))
    {
        //
        // Memory successfully allocated from the heap
        //
        MemFree ((LPVOID)lpwstrTime);
    }
    if (ERROR_SUCCESS != ec)
    {
        SetLastError (ec);
        return FALSE;
    }
    return TRUE;
}   // TimeToString

BOOL
PrepareReceiptSubject (
    BOOL             bPositive,
    BOOL             bBroadcast,
    const JOB_QUEUE *lpcJobQueue,
    LPWSTR          * pwstrSubject
)
/*++

Routine name : PrepareReceiptSubject

Routine description:

    Prepares the receipts subject line to be sent out via mail or a message box

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    bPositive      [in]  - Did the job(s) complete successfully?
    bBroadcast     [in]  - Is this the a broadcast job?
    lpcJobQueue    [in]  - Pointer to job (or broadcast parent job)
    pwstrSubject   [out] - Pointer to subject line string.
                           The string is allocated by this function.
                           If the function succeeded, the caller must call LocalFree() to
                           deallocate it.

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("PrepareReceiptSubject"));

    Assert (lpcJobQueue && pwstrSubject);

    DWORD dwMsgCount;
    LPDWORD MsgPtr[4] = {0};
    int nMsgStr;

    try
    {
        wstring wstrSubject = TEXT("");
        wstring wstrError;

        if (lpcJobQueue->CoverPageEx.lptstrSubject)
        {
            //
            // Job has a subject
            //
            wstrSubject = lpcJobQueue->CoverPageEx.lptstrSubject;
            wstrSubject.append (TEXT(" "));
        }
        else if (lpcJobQueue->lpParentJob && lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject)
        {
            //
            // Parent job has a subject
            //
            wstrSubject = lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject;
            wstrSubject.append (TEXT(" "));
        }
        if (!bBroadcast)
        {
            //
            // Compose subject for single recipient job
            //
            MsgPtr[0] = (LPDWORD)(LPCTSTR)wstrSubject.c_str();
            MsgPtr[1] = (LPDWORD)lpcJobQueue->RecipientProfile.lptstrName;
            MsgPtr[2] = (LPDWORD)lpcJobQueue->RecipientProfile.lptstrFaxNumber;

            if (bPositive)
            {
                //
                // Success line
                // "Fax <subject> was successfully sent to <name> at <number>"
                //
                if (!MsgPtr[1])
                {
                    //
                    //  Name is not mandatory parameter
                    //
                    nMsgStr = MSG_DR_SINGLE_SUBJECT_NONAME;
                }
                else
                {
                    nMsgStr = MSG_DR_SINGLE_SUBJECT;
                }
            }
            else
            {
                //
                // Failure line
                // "Fax <subject> failed to send to <name> at <number> (<last error>)."
                //
                //
                // Get error string
                //
                if (!PrepareReceiptErrorString (lpcJobQueue, wstrError))
                {
                    ec = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("PrepareReceiptErrorString failed. (ec: %ld)"),
                        ec);
                    return FALSE;
                }
                MsgPtr[3] = (LPDWORD)wstrError.c_str();

                if (!MsgPtr[1])
                {
                    //
                    //  Name is not mandatory parameter
                    //
                    nMsgStr = MSG_NDR_SINGLE_SUBJECT_NONAME;
                }
                else
                {
                    nMsgStr = MSG_NDR_SINGLE_SUBJECT;
                }
            }
        }
        else
        {
            //
            // Broadcast case
            //
            Assert (JT_BROADCAST == lpcJobQueue->JobType);
            Assert (lpcJobQueue->RecipientJobs.Flink);
            if (bPositive)
            {
                //
                // Compose subject for a broadcast job - success
                // "Fax <subject> successfully sent to <first name> and all other recipients"
                //
                nMsgStr = MSG_DR_BROADCAST_SUBJECT;

                MsgPtr[0] = (LPDWORD)(LPCTSTR)wstrSubject.c_str();

                PLIST_ENTRY lpNext = lpcJobQueue->RecipientJobs.Flink;
                Assert (lpNext);
                PJOB_QUEUE_PTR lpRecipientsGroupMember;
                lpRecipientsGroupMember = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
                Assert (lpRecipientsGroupMember);
                PJOB_QUEUE pFirstRecipient = lpRecipientsGroupMember->lpJob;
                Assert (pFirstRecipient);

                MsgPtr[1] = (LPDWORD)pFirstRecipient->RecipientProfile.lptstrName;
                if (!MsgPtr[1])
                {
                    //
                    //  Name is not mandatory parameter
                    //
                    MsgPtr[1] = (LPDWORD)pFirstRecipient->RecipientProfile.lptstrFaxNumber;
                }
            }
            else
            {
                //
                // Compose subject for a broadcast job - failure
                // "Fax <subject> was not successfully sent to <x> recipients. Canceled: <y> recipient(s).  Failed: <z> recipient(s)"
                //
                nMsgStr = MSG_NDR_BROADCAST_SUBJECT;

                MsgPtr[0] = (LPDWORD)(LPCTSTR)wstrSubject.c_str();
                Assert (lpcJobQueue->dwRecipientJobsCount ==
                        (lpcJobQueue->dwCanceledRecipientJobsCount +
                         lpcJobQueue->dwCompletedRecipientJobsCount +
                         lpcJobQueue->dwFailedRecipientJobsCount));
                MsgPtr[1] = (LPDWORD) ULongToPtr(lpcJobQueue->dwRecipientJobsCount);
                MsgPtr[2] = (LPDWORD) ULongToPtr(lpcJobQueue->dwCanceledRecipientJobsCount);
                MsgPtr[3] = (LPDWORD) ULongToPtr(lpcJobQueue->dwFailedRecipientJobsCount);
            }
        }
        //
        // Format the subject buffer (system allocates it)
        //
        dwMsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE   |
            FORMAT_MESSAGE_ARGUMENT_ARRAY |
            FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL,
            nMsgStr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            (LPTSTR)pwstrSubject,
            0,
            (va_list *) MsgPtr
            );
        if (!dwMsgCount)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FormatMessage failed. (ec: %ld)"),
                ec);
            return FALSE;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }

    Assert (ERROR_SUCCESS == ec);
    return TRUE;
}   // PrepareReceiptSubject

BOOL
GetNumericResourceValue (
    int iResourceId,
    DWORD &dwValue
)
/*++

Routine name : GetNumericResourceValue

Routine description:

    Reads a string resource and converts to a numeric value

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    iResourceId    [in]     - String resource id
    dwValue        [out]    - Numeric value

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("GetNumericResourceValue"));

    if (1 != swscanf (GetString (iResourceId), TEXT("%ld"), &dwValue))
    {
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }
    return TRUE;
}   // GetNumericResourceValue

BOOL
AddRecipientLine (
    const JOB_QUEUE *lpcJobQueue,
    BOOL             bDisplayError,
    wstring         &wstrLine
) throw (exception)
/*++

Routine name : AddRecipientLine

Routine description:

    Appends a recipient table line to a string

    This function may throw STL exceptions in case of string errors.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lpcJobQueue     [in]  - Recipient job.
                            If NULL, the table header lines (2 lines) are appended to the string.
    bDisplayError   [in]  - TRUE if 'last error' column is to be displayed
    wstrLine        [out] - String to append to

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("AddRecipientLine"));

    DWORD dwRecNameWidth;
    DWORD dwRecNumberWidth;
    DWORD dwStartTimeWidth;
    DWORD dwEndTimeWidth;
    DWORD dwRetriesWidth;
    DWORD dwErrorWidth;

    wstring wstrError;

    if (!GetNumericResourceValue (IDS_RECEIPT_RECIPIENT_NAME_WIDTH, dwRecNameWidth) ||
        !GetNumericResourceValue (IDS_RECEIPT_RECIPIENT_NUMBER_WIDTH, dwRecNumberWidth) ||
        !GetNumericResourceValue (IDS_RECEIPT_START_TIME_WIDTH, dwStartTimeWidth) ||
        !GetNumericResourceValue (IDS_RECEIPT_END_TIME_WIDTH, dwEndTimeWidth) ||
        !GetNumericResourceValue (IDS_RECEIPT_RETRIES_WIDTH, dwRetriesWidth) ||
        !GetNumericResourceValue (IDS_RECEIPT_LAST_ERROR_WIDTH, dwErrorWidth))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetNumericResourceValue failed. (ec: %ld)"),
            ec);
        return FALSE;
    }
    Assert (dwRecNameWidth && dwRecNumberWidth && dwStartTimeWidth && dwEndTimeWidth && dwRetriesWidth && dwErrorWidth);
    if (!lpcJobQueue)
    {
        //
        // Special case - prepare header for table
        //
        WCHAR wszLine[1024];
        LPCWSTR lpcwstrFormat;

        if (bDisplayError)
        {
            wstrLine.append (GetString (IDS_FAILED_RECP_LIST_HEADER));
            lpcwstrFormat = TEXT("\n%-*s %-*s %-*s %-*s %-*s %-*s");
        }
        else
        {
            wstrLine.append (GetString (IDS_COMPLETED_RECP_LIST_HEADER));
            lpcwstrFormat = TEXT("\n%-*s %-*s %-*s %-*s %-*s");
        }
        if (0 > _snwprintf (wszLine,
                            sizeof (wszLine) / sizeof (wszLine[0]),
                            lpcwstrFormat,
                            dwRecNameWidth,
                            wstring(GetString (IDS_RECEIPT_RECIPIENT_NAME)).substr(0, dwRecNameWidth-1).c_str(),
                            dwRecNumberWidth,
                            wstring(GetString (IDS_RECEIPT_RECIPIENT_NUMBER)).substr(0, dwRecNumberWidth-1).c_str(),
                            dwStartTimeWidth,
                            wstring(GetString (IDS_RECEIPT_START_TIME)).substr(0, dwStartTimeWidth-1).c_str(),
                            dwEndTimeWidth,
                            wstring(GetString (IDS_RECEIPT_END_TIME)).substr(0, dwEndTimeWidth-1).c_str(),
                            dwRetriesWidth,
                            wstring(GetString (IDS_RECEIPT_RETRIES)).substr(0, dwRetriesWidth-1).c_str(),
                            dwErrorWidth,
                            wstring(GetString (IDS_RECEIPT_LAST_ERROR)).substr(0, dwErrorWidth-1).c_str()))
        {
            ec = ERROR_BUFFER_OVERFLOW;
            SetLastError (ec);
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("_snwprintf failed. (ec: %ld)"),
                ec);
            return FALSE;
        }
        wstrLine.append (wszLine);
        //
        // Print seperator line
        //
        WCHAR wszSeperator[] =
            TEXT("--------------------------------------------------------------------------------------------------------");
        if (0 > _snwprintf (wszLine,
                            sizeof (wszLine) / sizeof (wszLine[0]),
                            lpcwstrFormat,
                            dwRecNameWidth,
                            wstring(wszSeperator).substr(0, dwRecNameWidth-1).c_str(),
                            dwRecNumberWidth,
                            wstring(wszSeperator).substr(0, dwRecNumberWidth-1).c_str(),
                            dwStartTimeWidth,
                            wstring(wszSeperator).substr(0, dwStartTimeWidth-1).c_str(),
                            dwEndTimeWidth,
                            wstring(wszSeperator).substr(0, dwEndTimeWidth-1).c_str(),
                            dwRetriesWidth,
                            wstring(wszSeperator).substr(0, dwRetriesWidth-1).c_str(),
                            dwErrorWidth,
                            wstring(wszSeperator).substr(0, dwErrorWidth-1).c_str()))
        {
            ec = ERROR_BUFFER_OVERFLOW;
            SetLastError (ec);
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("_snwprintf failed. (ec: %ld)"),
                ec);
            return FALSE;
        }
        wstrLine.append (wszLine);
        wstrLine.append (TEXT("\n"));
    }
    else
    {
        //
        // Prepare recipient line
        //
        WCHAR wszLine[1024];
        LPCWSTR lpcwstrFormat;
        wstring wstrStartTime;
        wstring wstrEndTime;

        if (!TimeToString ((FILETIME*) &lpcJobQueue->StartTime, wstrStartTime) ||
            !TimeToString ((FILETIME*) &lpcJobQueue->EndTime,   wstrEndTime))
        {
            //
            // Some error while converting time to string
            //
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("TimeToString failed (ec=%ld)"),
                ec);
            return FALSE;
        }

        if (bDisplayError)
        {
            lpcwstrFormat = TEXT("%-*s %-*s %-*s %-*s %*d %-*s");
            if (!PrepareReceiptErrorString (lpcJobQueue, wstrError))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PrepareReceiptErrorString failed. (ec: %ld)"),
                    ec);
                return FALSE;
            }
        }
        else
        {
            lpcwstrFormat = TEXT("%-*s %-*s %-*s %-*s %*d");
        }
        if (0 > _snwprintf (wszLine,
                            sizeof (wszLine) / sizeof (wszLine[0]),
                            lpcwstrFormat,
                            dwRecNameWidth,
                            wstring(lpcJobQueue->RecipientProfile.lptstrName ?
                                    lpcJobQueue->RecipientProfile.lptstrName : EMPTY_STRING
                                   ).substr(0, dwRecNameWidth-1).c_str(),
                            dwRecNumberWidth,
                            wstring(lpcJobQueue->RecipientProfile.lptstrFaxNumber ?
                                    lpcJobQueue->RecipientProfile.lptstrFaxNumber : EMPTY_STRING
                                   ).substr(0, dwRecNumberWidth-1).c_str(),
                            dwStartTimeWidth,
                            wstrStartTime.substr(0, dwStartTimeWidth-1).c_str(),
                            dwEndTimeWidth,
                            wstrEndTime.substr(0, dwEndTimeWidth-1).c_str(),
                            dwRetriesWidth,
                            lpcJobQueue->SendRetries,
                            dwErrorWidth,
                            wstrError.substr(0, dwErrorWidth-1).c_str()))
        {
            ec = ERROR_BUFFER_OVERFLOW;
            SetLastError (ec);
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("_snwprintf failed. (ec: %ld)"),
                ec);
            return FALSE;
        }
        wstrLine.append (wszLine);
        wstrLine.append (TEXT("\n"));
    }
    return TRUE;
}   // AddRecipientLine


BOOL
PrepareReceiptErrorString (
    const JOB_QUEUE *lpcJobQueue,
    wstring         &wstrError
) throw (exception)
/*++

Routine name : PrepareReceiptErrorString

Routine description:

    Creates an error string for a failed job queue entry

    This function may throw STL exceptions in case of string errors.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lpcJobQueue  [in]     - Pointer to failed job queue entry
    wstrError    [out]    - String output

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    TCHAR szErrorDescription[MAX_PATH] = {0};

    DEBUG_FUNCTION_NAME(TEXT("PrepareReceiptErrorString"));

    Assert (lpcJobQueue);

    //
    // Clear the string
    //
    wstrError = TEXT("");

    Assert( (JS_RETRIES_EXCEEDED == const_cast<PJOB_QUEUE>(lpcJobQueue)->JobStatus) ||
            (JS_CANCELED == const_cast<PJOB_QUEUE>(lpcJobQueue)->JobStatus) );

    if (JS_CANCELED == const_cast<PJOB_QUEUE>(lpcJobQueue)->JobStatus)
    {
        if (!LoadString(
            GetModuleHandle(NULL),
            IDS_JOB_CANCELED_BY_USER,
            szErrorDescription,
            sizeof(szErrorDescription)/sizeof(TCHAR)
            ))
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to load string"));
            return FALSE;
        }

        wstrError = szErrorDescription;
        return TRUE;
    }

    if (lpcJobQueue->ExStatusString[0] != L'\0')
    {
        //
        // FSPI provided extended status string
        //
        wstrError = lpcJobQueue->ExStatusString;
    }
    else
    {
        //
        // FSP provided extended status code
        //
        DWORD dwExStatus = MapFSPIJobExtendedStatusToJS_EX(lpcJobQueue->dwLastJobExtendedStatus);

        struct _ExStatusStringsMapEntry
        {
            DWORD dwExStatusCode;
            DWORD dwStringResourceId;
        } ExStatusStringsMap [] =
        {
            {JS_EX_DISCONNECTED,            FPS_DISCONNECTED          },
            {JS_EX_INITIALIZING,            FPS_INITIALIZING          },
            {JS_EX_DIALING,                 FPS_DIALING               },
            {JS_EX_TRANSMITTING,            FPS_SENDING               },
            {JS_EX_ANSWERED,                FPS_ANSWERED              },
            {JS_EX_RECEIVING,               FPS_RECEIVING             },
            {JS_EX_LINE_UNAVAILABLE,        FPS_UNAVAILABLE           },
            {JS_EX_BUSY,                    FPS_BUSY                  },
            {JS_EX_NO_ANSWER,               FPS_NO_ANSWER             },
            {JS_EX_BAD_ADDRESS,             FPS_BAD_ADDRESS           },
            {JS_EX_NO_DIAL_TONE,            FPS_NO_DIAL_TONE          },
            {JS_EX_FATAL_ERROR,             FPS_FATAL_ERROR           },
            {JS_EX_CALL_DELAYED,            FPS_CALL_DELAYED          },
            {JS_EX_CALL_BLACKLISTED,        FPS_CALL_BLACKLISTED      },
            {JS_EX_NOT_FAX_CALL,            FPS_NOT_FAX_CALL          },
            {JS_EX_PARTIALLY_RECEIVED,      IDS_PARTIALLY_RECEIVED    },
            {JS_EX_HANDLED,                 FPS_HANDLED               },
            {JS_EX_CALL_COMPLETED,          IDS_CALL_COMPLETED        },
            {JS_EX_CALL_ABORTED,            IDS_CALL_ABORTED          }
        };

        LPTSTR lptstrString = NULL;
        for (DWORD dwIndex = 0; dwIndex < sizeof (ExStatusStringsMap) / sizeof (_ExStatusStringsMapEntry); dwIndex++)
        {
            if (ExStatusStringsMap[dwIndex].dwExStatusCode == dwExStatus)
            {
                lptstrString = GetString (ExStatusStringsMap[dwIndex].dwStringResourceId);
                break;
            }
        }
        if (lptstrString)
        {
            wstrError = lptstrString;
        }
    }
    return TRUE;
}   // PrepareReceiptErrorString

BOOL
PrepareReceiptBody(
    BOOL              bPositive,
    BOOL              bBroadcast,
    const JOB_QUEUE * lpcJobQueue,
    LPCWSTR           lpcwstrSubject,
    BOOL              bAttachment,
    LPWSTR          * ppwstrBody
) throw (exception)
/*++

Routine name : PrepareReceiptBody

Routine description:

    Prepares the receipts body to be sent out via mail

    This function may throw STL exceptions in case of string errors.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    bPositive      [in]  - Did the job(s) complete successfully?
    bBroadcast     [in]  - Is this a broadcast job
    lpcJobQueue    [in]  - Pointer to job (or broadcast parent job)
    lpcwstrSubject [in]  - Subject line (as retrieved from call to PrepareReceiptSubject()).
    bAttachment    [in]  - Should the reciept body contain attachment?
    ppwstrBody     [out] - Pointer to receipt body string.
                           The string is allocated by this function.
                           If the function succeeded, the caller must call LocalFree() to
                           deallocate it.

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("PrepareReceiptBody"));

    Assert (lpcJobQueue && ppwstrBody);

    DWORD dwMsgCount;
    LPDWORD MsgPtr[8];
    int nMsgStr;
    wstring wstrDateTime[3];    // Submit time, start time, end time.

    //
    // Get name of server
    //
    WCHAR wszServerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwServerNameSize = sizeof (wszServerName) / sizeof (WCHAR);
    if (!GetComputerName (wszServerName, &dwServerNameSize))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetComputerName failed. (ec: %ld)"),
            ec);
        goto exit;
    }

    if (!bBroadcast)
    {
        //
        // Compose body for single recipient job
        //
        wstring wstrError;
        if (!TimeToString ((FILETIME*) &lpcJobQueue->lpParentJob->SubmissionTime, wstrDateTime[0]) ||
            !TimeToString ((FILETIME*) &lpcJobQueue->StartTime, wstrDateTime[1]) ||
            !TimeToString ((FILETIME*) &lpcJobQueue->EndTime,   wstrDateTime[2]))
        {
            //
            // Some error while converting time to string
            //
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("TimeToString failed (ec=%ld)"),
                ec);
            goto exit;
        }
        if (bPositive)
        {
            //
            // Success case: "
            //      <Subject line again>
            //      Fax submitted: <date and time>
            //      To server: <server name>
            //      Transmission started: <data and time>
            //      Transmission end: <data and time>
            //      Number of retries: <retries>
            //      Number of pages: <pages>"
            //
            nMsgStr = MSG_DR_SINGLE_BODY;

            MsgPtr[0] = (LPDWORD)lpcwstrSubject;
            MsgPtr[1] = (LPDWORD)(LPCTSTR)(wstrDateTime[0].c_str());
            MsgPtr[2] = (LPDWORD)wszServerName;
            MsgPtr[3] = (LPDWORD)(LPCTSTR)(wstrDateTime[1].c_str());
            MsgPtr[4] = (LPDWORD)(LPCTSTR)(wstrDateTime[2].c_str());
            MsgPtr[5] = (LPDWORD)ULongToPtr(lpcJobQueue->SendRetries);
            MsgPtr[6] = (LPDWORD)ULongToPtr(lpcJobQueue->PageCount);
        }
        else
        {
            //
            // Failure case: "
            //      <Subject line again>
            //      Fax submitted: <date and time>
            //      To server: <server name>
            //      Transmission started: <data and time>
            //      Transmission end: <data and time>
            //      Number of retries: <retries>
            //      Number of pages: <pages>
            //      Last error: <last error description>
            //
            nMsgStr = MSG_NDR_SINGLE_BODY;
            if (!PrepareReceiptErrorString (lpcJobQueue, wstrError))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PrepareReceiptErrorString failed. (ec: %ld)"),
                    ec);
                goto exit;
            }
            MsgPtr[0] = (LPDWORD)lpcwstrSubject;
            MsgPtr[1] = (LPDWORD)(LPCTSTR)(wstrDateTime[0].c_str());
            MsgPtr[2] = (LPDWORD)wszServerName;
            MsgPtr[3] = (LPDWORD)(LPCTSTR)(wstrDateTime[1].c_str());
            MsgPtr[4] = (LPDWORD)(LPCTSTR)(wstrDateTime[2].c_str());
            MsgPtr[5] = (LPDWORD)ULongToPtr(lpcJobQueue->SendRetries);
            MsgPtr[6] = (LPDWORD)ULongToPtr(lpcJobQueue->PageCount);
            MsgPtr[7] = (LPDWORD)wstrError.c_str();
        }
        //
        // Single recipient is an easy case
        // Format the body string now (system allocates it)
        //
        dwMsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE   |
            FORMAT_MESSAGE_ARGUMENT_ARRAY |
            FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL,
            nMsgStr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            (LPTSTR)ppwstrBody,
            0,
            (va_list *) MsgPtr
            );
        if (!dwMsgCount)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FormatMessage failed. (ec: %ld)"),
                ec);
            goto exit;
        }
    }
    else
    {
        //
        // Broadcast body case
        //
        wstring wstrBody;
        LPWSTR lpwstrStaticPart = NULL;
        //
        // Start with the body's static part
        //
        if (!TimeToString ((FILETIME*) &lpcJobQueue->SubmissionTime, wstrDateTime[0]))
        {
            //
            // Some error while converting time to string
            //
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("TimeToString failed (ec=%ld)"),
                ec);
            goto exit;
        }
        if (bPositive)
        {
            //
            // Success case: "
            //      <Subject line again>
            //      Fax submitted: <date and time>
            //      To server: <server name>
            //      Number of pages: <pages>
            //
            //      Recipient name Recipient number Started Ended Retries
            //      -------------- ---------------- ------- ----- -------
            //      < ----     data for each recipient goes here    ---->"
            //
            nMsgStr = MSG_DR_BROADCAST_BODY;

            MsgPtr[0] = (LPDWORD)lpcwstrSubject;
            MsgPtr[1] = (LPDWORD)(wstrDateTime[0].c_str());
            MsgPtr[2] = (LPDWORD)wszServerName;
            MsgPtr[3] = (LPDWORD)ULongToPtr(lpcJobQueue->PageCount);
        }
        else
        {
            //
            // Failure case: "
            //      <Subject line again>
            //      Fax submitted: <date and time>
            //      To server: <server name>
            //      Number of pages: <pages>
            //
            //      The fax was successfully sent to the following recipients:
            //      Recipient name Recipient number Started Ended Retries
            //      -------------- ---------------- ------- ----- --------
            //      < ----------  data for each recipient goes here  ---->"

            //      The fax failed to the following recipients:
            //      Recipient name Recipient number Started Ended Retries  Last error
            //      -------------- ---------------- ------- ----- -------- ----------
            //      < ----------     data for each recipient goes here    ---------->"
            //
            nMsgStr = MSG_NDR_BROADCAST_BODY;

            MsgPtr[0] = (LPDWORD)lpcwstrSubject;
            MsgPtr[1] = (LPDWORD)(wstrDateTime[0].c_str());
            MsgPtr[2] = (LPDWORD)wszServerName;
            MsgPtr[3] = (LPDWORD)ULongToPtr(lpcJobQueue->PageCount);
        }
        //
        // Start by formatting the static header (system allocates it)
        //
        dwMsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE   |
            FORMAT_MESSAGE_ARGUMENT_ARRAY |
            FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL,
            nMsgStr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            (LPTSTR)&lpwstrStaticPart,
            0,
            (va_list *) MsgPtr
            );
        if (!dwMsgCount)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FormatMessage failed. (ec: %ld)"),
                ec);
            goto exit;
        }
        //
        // Add static header to result string
        //
        try
        {
            wstrBody = lpwstrStaticPart;
        }
        catch (exception &e)
        {
            LocalFree ((HLOCAL)lpwstrStaticPart);
            throw e;
        }
        //
        // Free static header
        //
        LocalFree ((HLOCAL)lpwstrStaticPart);
        //
        // Start appending table(s) to static body part
        //
        if (lpcJobQueue->dwCompletedRecipientJobsCount)
        {
            //
            // Do the recipients lists now (successful recipients)
            //
            if (!AddRecipientLine (NULL, FALSE, wstrBody))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("AddRecipientLine (NULL) failed. (ec: %ld)"),
                    ec);
                goto exit;
            }

            PLIST_ENTRY lpNext = lpcJobQueue->RecipientJobs.Flink;
            Assert (lpNext);
            while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpcJobQueue->RecipientJobs)
            {
                PJOB_QUEUE_PTR lpRecipientsGroupMember;
                lpRecipientsGroupMember = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
                Assert (lpRecipientsGroupMember);
                PJOB_QUEUE pRecipient = lpRecipientsGroupMember->lpJob;
                Assert (pRecipient);
                if (JS_COMPLETED == pRecipient->JobStatus)
                {
                    //
                    // Job successfully completed
                    //
                    if (!AddRecipientLine (pRecipient, FALSE, wstrBody))
                    {
                        ec = GetLastError();
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("AddRecipientLine failed. (ec: %ld)"),
                            ec);
                        goto exit;
                    }
                }
                lpNext = lpRecipientsGroupMember->ListEntry.Flink;
            }
            wstrBody.append (TEXT("\n"));
        }
        if (lpcJobQueue->dwFailedRecipientJobsCount)
        {
            //
            // Append negative recipient list
            //
            Assert (!bPositive);
            if (!AddRecipientLine (NULL, TRUE, wstrBody))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("AddRecipientLine (NULL) failed. (ec: %ld)"),
                    ec);
                goto exit;
            }

            PLIST_ENTRY lpNext = lpcJobQueue->RecipientJobs.Flink;
            Assert (lpNext);
            while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpcJobQueue->RecipientJobs)
            {
                PJOB_QUEUE_PTR lpRecipientsGroupMember;
                lpRecipientsGroupMember = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
                Assert (lpRecipientsGroupMember);
                PJOB_QUEUE pRecipient = lpRecipientsGroupMember->lpJob;
                Assert (pRecipient);
                if (JS_RETRIES_EXCEEDED == pRecipient->JobStatus)
                {
                    //
                    // Job is in failure (JS_RETRIES_EXCEEDED)
                    //
                    if (!AddRecipientLine (pRecipient, TRUE, wstrBody))
                    {
                        ec = GetLastError();
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("AddRecipientLine failed. (ec: %ld)"),
                            ec);
                        goto exit;
                    }
                }
                lpNext = lpRecipientsGroupMember->ListEntry.Flink;
            }
        }

        //
        //  Check if an attachment was requested
        //
        if (bAttachment &&
            lpcJobQueue->CoverPageEx.lptstrCoverPageFileName)
        {
            //
            // Add remark explaining there is no cover page attachments
            //
            wstrBody.append (TEXT("\n\n"));
            if (!lpcJobQueue->FileName)
            {
                //
                // No attachment at all
                //
                wstrBody.append (GetString (IDS_RECEIPT_NO_CP_AND_BODY_ATTACH));
            }
            else
            {
                //
                // Attachment contains body file only
                //
                wstrBody.append (GetString (IDS_RECEIPT_NO_CP_ATTACH));
            }
            wstrBody.append (TEXT("\n"));
        }

        //
        // Allocate return buffer
        //
        DWORD dwBufSize = sizeof (WCHAR) * (wstrBody.size() + 1);
        *ppwstrBody = (LPTSTR)LocalAlloc (LMEM_FIXED, dwBufSize);
        if (NULL == *ppwstrBody)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LocalAlloc failed. (ec: %ld)"),
                ec);
            goto exit;
        }
        lstrcpy (*ppwstrBody, wstrBody.c_str());
    }   // End of broadcast case

exit:
    if (ERROR_SUCCESS != ec)
    {
        SetLastError (ec);
        return FALSE;
    }
    return TRUE;
}   // PrepareReceiptBody


BOOL
SendReceipt(
    BOOL bPositive,
    BOOL bBroadcast,
    const JOB_QUEUE * lpcJobQueue,
    LPCTSTR           lpctstrTIFF
)
/*++

Routine name : SendReceipt

Routine description:

    Sends a receipt of a fax delivery / non-delivery

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    bPositive      [in]  - Did the job(s) complete successfully?
    bBroadcast     [in]  - Is this a broadcast job
    lpcJobQueue    [in]  - Pointer to job (or broadcast parent job)
    lpctstrTIFF    [in]  - TIFF file to attach to receipt (optional, may be NULL)

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("SendReceipt"));
    DWORD ec = ERROR_SUCCESS;
    PFAX_SERVER_RECEIPTS_CONFIGW pServerRecieptConfig = NULL;

    Assert(lpcJobQueue);

    LPWSTR lpwstrSubject = NULL;
    LPWSTR lpwstrBody = NULL;

    //
    // Remove modifiers - leave only the receipt type
    //
    DWORD dwDeliveryType = lpcJobQueue->JobParamsEx.dwReceiptDeliveryType & ~DRT_MODIFIERS;

    if (DRT_NONE == dwDeliveryType)
    {
        //
        // No receipt requested
        //
        return TRUE;
    }

    //
    // Get server receipts configuration
    //
    ec = GetRecieptsConfiguration (&pServerRecieptConfig);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetRecieptsConfiguration failed. (ec: %ld)"),
            ec);
        SetLastError(ec);
        return FALSE;
    }

    if (!(dwDeliveryType & pServerRecieptConfig->dwAllowedReceipts))
    {
        //
        // Receipt type is NOT currently supported by the server.
        // This may happen if the supported receipt types has changed since the job
        // was submitted.
        //
        DebugPrintEx(DEBUG_ERR,
                    TEXT("dwDeliveryType not supported by the server (%ld)"),
                    dwDeliveryType);
        ec = ERROR_UNSUPPORTED_TYPE;
        goto exit;
    }

    if (!PrepareReceiptSubject (bPositive, bBroadcast, lpcJobQueue, &lpwstrSubject))
    {
        ec = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PrepareReceiptSubject failed. (ec: %ld)"),
            ec);
        goto exit;
    }

    if (DRT_EMAIL & dwDeliveryType)
    {
        //
        // For mail receipts, we create a message body.
        //
        try
        {
            if (!PrepareReceiptBody (bPositive,
                                     bBroadcast,
                                     lpcJobQueue,
                                     lpwstrSubject,
                                     (lpcJobQueue->JobParamsEx.dwReceiptDeliveryType & DRT_ATTACH_FAX),
                                     &lpwstrBody))
            {
                ec = GetLastError ();
            }
        }
        catch (exception &ex)
        {
            ec = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PrepareReceiptBody caused exception (%S)"),
                ex.what());
        }
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PrepareReceiptBody failed. (ec: %ld)"),
                ec);
            goto exit;
        }
    }

    switch (dwDeliveryType)
    {
       case DRT_EMAIL:
            {
                HRESULT hr;
                if (!((lpcJobQueue->JobParamsEx.dwReceiptDeliveryType) & DRT_ATTACH_FAX))
                {
                    //
                    // do not attach tiff file
                    //
                    lpctstrTIFF = NULL;
                }
                hr = SendMail (
                    pServerRecieptConfig->lptstrSMTPFrom,                            // From
                    lpcJobQueue->JobParamsEx.lptstrReceiptDeliveryAddress,      // To
                    lpwstrSubject,                                              // Subject
                    lpwstrBody,                                                 // Body
                    lpctstrTIFF,                                                // Attachment
                    GetString ( bPositive ? IDS_DR_FILENAME:IDS_NDR_FILENAME ), // Attachment description
                    pServerRecieptConfig->lptstrSMTPServer,                          // SMTP server
                    pServerRecieptConfig->dwSMTPPort,                                // SMTP port
                    (pServerRecieptConfig->SMTPAuthOption == FAX_SMTP_AUTH_ANONYMOUS) ?
                        CDO_AUTH_ANONYMOUS : (pServerRecieptConfig->SMTPAuthOption == FAX_SMTP_AUTH_BASIC) ?
                        CDO_AUTH_BASIC : CDO_AUTH_NTLM,                         // Authentication type
                    pServerRecieptConfig->lptstrSMTPUserName,                        // User name
                    pServerRecieptConfig->lptstrSMTPPassword,                        // Password
                    pServerRecieptConfig->hLoggedOnUser);                            // Logged on user token
                if (FAILED(hr))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("SendMail failed. (hr: 0x%08x)"),
                        hr);
                    ec = (DWORD)hr;
                    goto exit;
                }
            }
            break;
        case DRT_MSGBOX:
            //
            // TODO: Test if we need to convert lpwstrSubject to ANSII
            //
            ec = NetMessageBufferSend (
                    NULL,                                                   // Send from this machine
                    lpcJobQueue->JobParamsEx.lptstrReceiptDeliveryAddress,  // Computer to send to
                    NULL,                                                   // Sending computer name
                    (LPBYTE)lpwstrSubject,                                  // Buffer
                    (lstrlen (lpwstrSubject) + 1) * sizeof (WCHAR));        // Buffer size
            if (ERROR_SUCCESS != ec)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("NetMessageBufferSend failed. (ec: %ld)"),
                    ec);
                goto exit;
            }
            break;

        default:
            ASSERT_FALSE;
            break;
    }
    Assert( ERROR_SUCCESS == ec);

exit:
    if (lpwstrSubject)
    {
        LocalFree ((HLOCAL)lpwstrSubject);
    }
    if (lpwstrBody)
    {
        LocalFree ((HLOCAL)lpwstrBody);
    }
    if (ERROR_SUCCESS != ec)
    {
        wstring wstrSubmissionTime;
        SetLastError (ec);

        //
        //  Find Subject of the Fax Message
        //
        LPCWSTR  lpcwstrFaxSubject;

        if (lpcJobQueue->CoverPageEx.lptstrSubject)
        {
            lpcwstrFaxSubject = lpcJobQueue->CoverPageEx.lptstrSubject;
        }
        else if (lpcJobQueue->lpParentJob && lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject)
        {
            lpcwstrFaxSubject = lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject;
        }
        else
        {
            lpcwstrFaxSubject = L"";
        }

        //
        //  Find Submission Time
        //
        LPCWSTR lpcwstrTime = NULL;

        try
        {
            if (!TimeToString ((lpcJobQueue->lpParentJob) ?
                                   ((FILETIME*) &lpcJobQueue->lpParentJob->SubmissionTime) :
                                   ((FILETIME*) &lpcJobQueue->SubmissionTime),
                               wstrSubmissionTime))
            {
                //
                // Some error while converting time to string
                //
                DebugPrintEx(DEBUG_ERR,
                    TEXT("TimeToString failed (ec=%ld)"),
                    GetLastError ());

                lpcwstrTime = L"";
            }
            else
            {
                lpcwstrTime = wstrSubmissionTime.c_str();
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("TimeToString caused exception (%S)"),
                ex.what());

            lpcwstrTime = L"";
        }

        USES_DWORD_2_STR;

        switch (dwDeliveryType)
        {
        case DRT_EMAIL:

            FaxLog(FAXLOG_CATEGORY_OUTBOUND,
                FAXLOG_LEVEL_MIN,
                7,
                ((bPositive) ? MSG_FAX_OK_EMAIL_RECEIPT_FAILED : MSG_FAX_ERR_EMAIL_RECEIPT_FAILED),
                DWORD2HEX(ec),                                          //  error code
                ((lpcJobQueue->lpParentJob) ? lpcJobQueue->lpParentJob->UserName :
                                              lpcJobQueue->UserName),   //  sender user name
                lpcJobQueue->SenderProfile.lptstrName,                  //  sender name
                lpcwstrTime,                                            //  submitted on
                lpcwstrFaxSubject,                                      //  subject
                lpcJobQueue->RecipientProfile.lptstrName,               //  recipient name
                lpcJobQueue->RecipientProfile.lptstrFaxNumber           //  recipient number
                );
            break;

        case DRT_MSGBOX:

            FaxLog(FAXLOG_CATEGORY_OUTBOUND,
                FAXLOG_LEVEL_MIN,
                7,
                ((bPositive) ? MSG_OK_MSGBOX_RECEIPT_FAILED : MSG_ERR_MSGBOX_RECEIPT_FAILED),
                DWORD2HEX(ec),                                          //  error code
                ((lpcJobQueue->lpParentJob) ? lpcJobQueue->lpParentJob->UserName :
                                              lpcJobQueue->UserName),   //  sender user name
                lpcJobQueue->SenderProfile.lptstrName,                  //  sender name
                lpcwstrTime,                                            //  submitted on
                lpcwstrFaxSubject,                                      //  subject
                lpcJobQueue->RecipientProfile.lptstrName,               //  recipient name
                lpcJobQueue->RecipientProfile.lptstrFaxNumber           //  recipient number
                );
            break;

        default:
            ASSERT_FALSE;
            break;
        }
    }

    if (NULL != pServerRecieptConfig)
    {
        FreeRecieptsConfiguration (pServerRecieptConfig, TRUE);
    }
    return (ERROR_SUCCESS == ec);
}   // SendReceipt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\routegroup.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RouteGroup.h

Abstract:

    This file provides declaration of the service
    outbound routing groups.

Author:

    Oded Sacher (OdedS)  Nov, 1999

Revision History:

--*/

#ifndef _OUT_ROUTE_GROUP_H
#define _OUT_ROUTE_GROUP_H

#include <map>
#include <list>
#include <string>
#include <algorithm>
#include <set>
using namespace std;
#pragma hdrstop

#pragma warning (disable : 4786)    // identifier was truncated to '255' characters in the debug information
// This pragma does not work KB ID: Q167355

/************************************
*                                   *
*      wstrCaseInsensitiveLess      *
*                                   *
************************************/
class wstrCaseInsensitiveLess
{
  public:
    bool operator()(const wstring X, wstring Y) const
    {
        LPCWSTR lpcwstrX = X.c_str();
        LPCWSTR lpcwstrY = Y.c_str();

        if (_wcsicmp(lpcwstrX,lpcwstrY) < 0)
        {
            return true;
        }

        return false;
    }
};


typedef list<DWORD> GROUP_DEVICES, *PGROUP_DEVICES;

/************************************
*                                   *
*         COutboundRoutingGroup     *
*                                   *
************************************/
class COutboundRoutingGroup
{
public:
    COutboundRoutingGroup () {}
    ~COutboundRoutingGroup () {}

    COutboundRoutingGroup (const COutboundRoutingGroup& rhs)
        : m_DeviceList(rhs.m_DeviceList) {}
    COutboundRoutingGroup& operator= (const COutboundRoutingGroup& rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        m_DeviceList = rhs.m_DeviceList;
        return *this;
    }

    DWORD Load(HKEY hGroupKey, LPCWSTR lpcwstrGroupName);
    DWORD SetDevices (const LPDWORD lpdwDevices, DWORD dwNumDevices, BOOL fAllDevicesGroup);
    DWORD SerializeDevices (LPDWORD* lppDevices, LPDWORD lpdwNumDevices, BOOL bAllocate = TRUE) const;
    DWORD Save(HKEY hGroupKey) const;
    DWORD AddDevice (DWORD dwDevice);
    DWORD DelDevice (DWORD dwDevice);
    DWORD SetDeviceOrder (DWORD dwDevice, DWORD dwOrder);
    DWORD GetStatus (FAX_ENUM_GROUP_STATUS* lpStatus) const;

#if DBG
    void Dump () const;
#endif

private:
    BOOL IsDeviceInGroup (DWORD dwDevice) const;
    DWORD ValidateDevices (const LPDWORD lpdwDevices, DWORD dwNumDevices, BOOL fAllDevicesGroup) const;

    GROUP_DEVICES           m_DeviceList;
};  // COutboundRoutingGroup


/************************************
*                                   *
*     COutboundRoutingGroupsMap     *
*                                   *
************************************/

typedef COutboundRoutingGroup  *PCGROUP;
typedef map<wstring, COutboundRoutingGroup, wstrCaseInsensitiveLess>  GROUPS_MAP, *PGROUPS_MAP;

//
// The CGroupMap class maps between group name and a list of device ID's
//
class COutboundRoutingGroupsMap
{
public:
    COutboundRoutingGroupsMap () {}
    ~COutboundRoutingGroupsMap () {}

    DWORD Load ();
    DWORD AddGroup (LPCWSTR lpcwstrGroupName, PCGROUP pCGroup);
    DWORD DelGroup (LPCWSTR lpcwstrGroupName);
    DWORD SerializeGroups (PFAX_OUTBOUND_ROUTING_GROUPW* ppGroups,
                           LPDWORD lpdwNumGroups,
                           LPDWORD lpdwBufferSize) const;
    PCGROUP FindGroup (LPCWSTR lpcwstrGroupName) const;
    BOOL UpdateAllDevicesGroup (void);
    DWORD RemoveDevice (DWORD dwDeviceId);


#if DBG
    void Dump () const;
#endif

private:
    GROUPS_MAP   m_GroupsMap;
};  // COutboundRoutingGroupsMap



/************************************
*                                   *
*         Externes                  *
*                                   *
************************************/

extern COutboundRoutingGroupsMap* g_pGroupsMap;       // Map of group name to list of device IDs
//
//  IMPORTANT - No locking mechanism - USE g_CsConfig to serialize calls to g_pGroupsMap
//


/************************************
*                                   *
*         Functions                 *
*                                   *
************************************/


BOOL
IsDeviceInstalled (DWORD dwDeviceId);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\svccon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsvc.c

Abstract:

    This module contains the windows code for the
    FAX service debug window.

Author:

    Wesley Witt (wesw) 28-Feb-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop




int
DebugService(
    VOID
    )

/*++

Routine Description:

    Starts the service in debug mode.  In this mode the FAX service
    runs as a regular WIN32 process.  This is implemented as an aid
    to debugging the service.

Arguments:

    argc        - argument count
    argv        - argument array

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    ServiceDebug = TRUE;
    ConsoleDebugOutput = TRUE;
    return ServiceStart();
}


VOID
ConsoleDebugPrint(
    LPTSTR buf
    )
{
    if (ConsoleDebugOutput) {
        _tprintf( TEXT("%s\n"), buf );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\routerule.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RouteRule.cpp

Abstract:

    This file provides implementation of the service
    outbound routing rules.

Author:

    Oded Sacher (OdedS)  Dec, 1999

Revision History:

--*/

#include "faxsvc.h"

BOOL
EnumOutboundRoutingRulesCB(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID pContext
    );


/************************************
*                                   *
*             Globals               *
*                                   *
************************************/

COutboundRulesMap* g_pRulesMap; // Map of dialing location to rule


/***********************************
*                                  *
*  CDialingLocation  Methodes      *
*                                  *
***********************************/

bool
CDialingLocation::operator < ( const CDialingLocation &other ) const
/*++

Routine name : operator <

Class: CDialingLocation

Routine description:

    Compares myself with another Dialing location key

Author:

    Oded Sacher (Odeds), Dec, 1999

Arguments:

    other           [in] - Other key

Return Value:

    true only is i'm less than the other key

--*/
{
    if (m_dwCountryCode < other.m_dwCountryCode)
    {
        return true;
    }
    if (m_dwCountryCode > other.m_dwCountryCode)
    {
        return false;
    }
    //
    // Equal country code , comapre area code
    //
    if (m_dwAreaCode < other.m_dwAreaCode)
    {
        return true;
    }
    return false;
}   // CDialingLocation::operator <




BOOL
CDialingLocation::IsValid () const
/*++

Routine name : CDialingLocation::IsValid

Routine description:

    Validates a dialing location object

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    BOOL

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CDialingLocation::IsValid"));

    if (m_dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY &&
        m_dwAreaCode != ROUTING_RULE_AREA_CODE_ANY)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Not a valid Country and Area code combination"));
        return FALSE;
    }
    return TRUE;
} // CDialingLocation::IsValidDialingLocation


LPCWSTR
CDialingLocation::GetCountryName () const
/*++

Routine name : CDialingLocation::GetCountryName

Routine description:

    Returns a pointer to the country name specifies by its country dialing code  (based on TAPI).
    The caller must  call MemFree() to deallocate memory.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    Pointer to the country name.
    If this is NULL the function failed, call GetLastError() for more info.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CDialingLocation::GetCountryName"));

    LPLINECOUNTRYLIST           lpCountryList = NULL;
    LPLINECOUNTRYENTRY          lpEntry = NULL;
    DWORD                       dwIndex;

    //
    // Get the cached all countries list.
    //
    if (!(lpCountryList = GetCountryList()))
    {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    lpEntry = (LPLINECOUNTRYENTRY)  // init array of entries
        ((PBYTE) lpCountryList + lpCountryList->dwCountryListOffset);

    for (dwIndex=0; dwIndex < lpCountryList->dwNumCountries; dwIndex++)
    {
        if (lpEntry[dwIndex].dwCountryCode == m_dwCountryCode)
        {
            //
            // Matching country code - copy Country name.
            //
            if (lpEntry[dwIndex].dwCountryNameSize && lpEntry[dwIndex].dwCountryNameOffset)
            {
                return StringDup ((LPWSTR) ((LPBYTE)lpCountryList + lpEntry[dwIndex].dwCountryNameOffset));
            }
        }
    }
    SetLastError (ERROR_NOT_FOUND);

exit:
    return NULL;
}  // CDialingLocation::GetCountryName


/*************************************
*                                    *
* COutboundRoutingRule Methodes      *
*                                    *
*************************************/

DWORD
COutboundRoutingRule::Init (CDialingLocation DialingLocation, wstring wstrGroupName)
/*++

Routine name : COutboundRoutingRule::Init

Routine description:

    Initialize an OutboundRoutingRule object

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    DialingLocation         [in    ] - Dialing location object to use as the rule's dialing location
    wstrGroupName           [in    ] - The group name to use as the rule's destination group

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::Init"));

    try
    {
        m_wstrGroupName = wstrGroupName;
        m_bUseGroup = TRUE;
        m_DialingLocation = DialingLocation;
        return ERROR_SUCCESS;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }
}

DWORD
COutboundRoutingRule::Save(HKEY hRuleKey) const
/*++

Routine name : COutboundRoutingRule::Save

Routine description:

    Saves an outbound routing rule value to the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hRuleKey           [in] - Handle to the opened rule registry key

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::Save"));
    DWORD   dwRes = ERROR_SUCCESS;

    Assert (hRuleKey);

    // Save country code
    if (!SetRegistryDword( hRuleKey,
                           REGVAL_ROUTING_RULE_COUNTRY_CODE,
                           m_DialingLocation.GetCountryCode()))
    {
        dwRes = GetLastError();
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("SetRegistryDword failed , ec %ld"), dwRes);
        goto exit;
    }

    // Save area code
    if (!SetRegistryDword( hRuleKey,
                           REGVAL_ROUTING_RULE_AREA_CODE,
                           m_DialingLocation.GetAreaCode()))
    {
        dwRes = GetLastError();
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("SetRegistryDword failed , ec %ld"), dwRes);
        goto exit;
    }

    // // Save boolen flag whether to use group
    if (!SetRegistryDword( hRuleKey,
                           REGVAL_ROUTING_RULE_USE_GROUP,
                           m_bUseGroup ? TRUE : FALSE))
    {
        dwRes = GetLastError();
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("SetRegistryDword failed , ec %ld"), dwRes);
        goto exit;
    }

    if (FALSE == m_bUseGroup)
    {
        // Save the device ID as the rule destination
        if (!SetRegistryDword( hRuleKey,
                               REGVAL_ROUTING_RULE_DEVICE_ID,
                               m_dwDevice))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("SetRegistryDword failed , ec %ld"), dwRes);
            goto exit;
        }
    }
    else
    {
        // Save the group name as the rule destination
        try
        {
            if (!SetRegistryString( hRuleKey,
                                    REGVAL_ROUTING_RULE_GROUP_NAME,
                                    m_wstrGroupName.c_str()))
            {
                dwRes = GetLastError();
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("SetRegistryDword failed , ec %ld"), dwRes);
                goto exit;
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            dwRes = ERROR_GEN_FAILURE;
            goto exit;
        }
    }

    Assert (dwRes == ERROR_SUCCESS);

exit:
    return dwRes;
}  // COutboundRoutingRule::Save


DWORD
COutboundRoutingRule::Load(HKEY hRuleKey)
/*++

Routine name : COutboundRoutingRule::Load

Routine description:

    Loads an outboundrouting rule value settings from the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hRuleKey           [in] - Handle to the opened registry key

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes, dwType, dwSize;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::Load"));
    DWORD dwCountryCode = 0;
    DWORD dwAreaCode = 0;

    Assert (hRuleKey);


    // Read the boolen flag whether to use group
    dwRes = GetRegistryDwordEx (hRuleKey,
                                REGVAL_ROUTING_RULE_USE_GROUP,
                                (LPDWORD)&m_bUseGroup);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading UseGroup - GetRegistryDwordEx failed with %ld"),
            dwRes);
        goto exit;
    }

    if (FALSE == m_bUseGroup)
    {
        // read the device ID as the rule destination
        dwRes = GetRegistryDwordEx (hRuleKey,
                                REGVAL_ROUTING_RULE_DEVICE_ID,
                                &m_dwDevice);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error reading device ID - GetRegistryDwordEx failed with %ld"),
                dwRes);
            goto exit;
        }

        if (0 == m_dwDevice)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid device ID"));
            dwRes = ERROR_BADDB;
            goto exit;
        }
    }
    else
    {
        // Read the group name as the rule destination
        WCHAR wszGroupName[MAX_ROUTING_GROUP_NAME];

        dwRes = RegQueryValueEx(
            hRuleKey,
            REGVAL_ROUTING_RULE_GROUP_NAME,
            NULL,
            &dwType,
            NULL,
            &dwSize
            );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegQueryValueEx failed with %ld"),
                dwRes);
            goto exit;
        }

        if (REG_SZ != dwType || dwSize > MAX_ROUTING_GROUP_NAME)
        {
            // We expect only string data here
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error reading group name"));
            dwRes = ERROR_BADDB;    // The configuration registry database is corrupt.
            goto exit;
        }

        dwRes = RegQueryValueEx(
            hRuleKey,
            REGVAL_ROUTING_RULE_GROUP_NAME,
            NULL,
            &dwType,
            (LPBYTE)&wszGroupName,
            &dwSize
            );
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegQueryValueEx failed with %ld"),
                dwRes);
            goto exit;
        }

        // Validate that the group exist
        PCGROUP pCGroup = g_pGroupsMap->FindGroup (wszGroupName);
        if (NULL == pCGroup)
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRoutingGropsMap::FindGroup, with error - %ld"),
                dwRes);
            goto exit;
        }

        try
        {
            m_wstrGroupName = wszGroupName;
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            dwRes = ERROR_GEN_FAILURE;
            goto exit;
        }
    }

    // Read the country code
    dwRes = GetRegistryDwordEx (hRuleKey,
                                REGVAL_ROUTING_RULE_COUNTRY_CODE,
                                &dwCountryCode);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading Country code - GetRegistryDwordEx failed with %ld"),
            dwRes);
        goto exit;
    }

    // Read the area code
    dwRes = GetRegistryDwordEx (hRuleKey,
                                REGVAL_ROUTING_RULE_AREA_CODE,
                                &dwAreaCode);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading Area code - GetRegistryDwordEx failed with %ld"),
            dwRes);
        goto exit;
    }

    //
    // Create the DialingLocation object
    //
    m_DialingLocation =  CDialingLocation (dwCountryCode, dwAreaCode);
    if (!m_DialingLocation.IsValid())
    {
        dwRes = ERROR_INVALID_PARAMETER;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsValidDialingLocation failed"));
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
}  //  COutboundRoutingRule::Load


DWORD
COutboundRoutingRule::GetStatus (FAX_ENUM_RULE_STATUS* lpdwStatus) const
/*++

Routine name : COutboundRoutingRule::GetStatus

Routine description:

    Reports the rule's status. Can be one of FAX_ENUM_RULE_STATUS.
    Enter Critical Section (g_CsLine , g_CsConfig) before calling this function.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpdwStatus          [out   ] - Gets the rule's status on return

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::GetStatus"));
    FAX_ENUM_RULE_STATUS dwRuleStatus = FAX_RULE_STATUS_VALID;
    DWORD dwRes = ERROR_SUCCESS;
    PCGROUP pCGroup;

    if (TRUE == m_bUseGroup)
    {
        // Find the rule's destination group in the goups map
        try
        {
            pCGroup = g_pGroupsMap->FindGroup (m_wstrGroupName.c_str());
            if (NULL == pCGroup)
            {
                dwRes = GetLastError();
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("COutboundRoutingGroupsMap::FindGroup failed , ec %ld"), dwRes);
                goto exit;
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            dwRes = ERROR_GEN_FAILURE;
            goto exit;
        }

        //  Get the group's status.
        FAX_ENUM_GROUP_STATUS GroupStatus;
        dwRes = pCGroup->GetStatus(&GroupStatus);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingGroup::GetStatus failed , ec %ld"), dwRes);
            goto exit;
        }

        switch (GroupStatus)
        {
            case FAX_GROUP_STATUS_SOME_DEV_NOT_VALID:
                dwRuleStatus = FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID;
                break;

            case FAX_GROUP_STATUS_ALL_DEV_NOT_VALID:
                dwRuleStatus = FAX_RULE_STATUS_ALL_GROUP_DEV_NOT_VALID;
                break;

            case FAX_GROUP_STATUS_EMPTY:
                dwRuleStatus = FAX_RULE_STATUS_EMPTY_GROUP;
                break;

            default:
                Assert (FAX_GROUP_STATUS_ALL_DEV_VALID == GroupStatus);
       }

    }
    else
    {
        // A device is the rule's destination
        if (!IsDeviceInstalled (m_dwDevice))
        {
            // Device not installed
            dwRuleStatus =  FAX_RULE_STATUS_BAD_DEVICE;
        }
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS == dwRes)
    {
        *lpdwStatus = dwRuleStatus;
    }
    return dwRes;
}  //  COutboundRoutingRule::GetStatus


DWORD
COutboundRoutingRule::GetDeviceList (LPDWORD* lppdwDevices, LPDWORD lpdwNumDevices) const
/*++

Routine name : COutboundRoutingRule::GetDeviceList

Routine description:

    Returns an ordered device list, which are the rule's destination devices.
    The caller must call MemFree() to deallocate the memory.
    Enter Critical Section (g_CsConfig) before calling this function.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lppdwDevices            [out   ] - Pointer to pointer to a DWORD buffer to recieve the devices list.
    lpdwNumDevices          [out   ] - Pointer to a DWORD to recieve the number of devices returned

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::GetDeviceList"));
    DWORD dwRes = ERROR_SUCCESS;
    PCGROUP pCGroup;

    Assert (lppdwDevices && lpdwNumDevices);

    *lppdwDevices = NULL;
    *lpdwNumDevices = 0;

    if (TRUE == m_bUseGroup)
    {
        // A group is the rule's destination
        try
        {
            pCGroup = g_pGroupsMap->FindGroup (m_wstrGroupName.c_str());
            if (NULL == pCGroup)
            {
                dwRes = GetLastError();
                Assert (FAX_ERR_GROUP_NOT_FOUND != dwRes);

                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("COutboundRoutingGroupsMap::FindGroup failed , ec %ld"), dwRes);
                goto exit;
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            dwRes = ERROR_GEN_FAILURE;
            goto exit;
        }

        // Get the group's device list
        dwRes = pCGroup->SerializeDevices (lppdwDevices, lpdwNumDevices);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRoutingGroup::SerializeDevices failed with %ld"),
                dwRes);
            goto exit;
        }
    }
    else
    {
        // A single device
        *lppdwDevices = (LPDWORD) MemAlloc(sizeof(DWORD));
        if (*lppdwDevices == NULL)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Cannot allocate devices buffer"));
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        *(*lppdwDevices) = m_dwDevice;
        *lpdwNumDevices = 1;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
}  //  COutboundRoutingRule::GetDeviceList


DWORD
COutboundRoutingRule::Serialize (LPBYTE lpBuffer,
                                 PFAX_OUTBOUND_ROUTING_RULEW pFaxRule,
                                 PULONG_PTR pupOffset) const
/*++

Routine name : COutboundRoutingRule::Serialize

Routine description:

    Serializes a rule's info based on FAX_OUTBOUND_ROUTING_RULEW structure.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpBuffer            [in] - Pointer to a pre-allocated buffer. If this parameter is NULL lpdwOffset will get the required buffer size.
    pFaxRule            [in] - Pointer to a specific FAX_OUTBOUND_ROUTING_RULEW structure in the buffer
    pupOffset           [in/out] - Offset from the begining of the buffer where variable length info is stored

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::Serialize"));
    DWORD dwRes = ERROR_SUCCESS;
    const CDialingLocation DialingLocation = GetDialingLocation();
    LPCWSTR lpcwstrCountryName = NULL;
    LPCWSTR lpwstrGroupName;

    Assert (pupOffset);
    if (ROUTING_RULE_COUNTRY_CODE_ANY != DialingLocation.GetCountryCode())
    {
        // Get the country name
        lpcwstrCountryName = DialingLocation.GetCountryName();
        if (NULL == lpcwstrCountryName)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingRule::GetCountryName failed , ec %ld"), GetLastError());
        }
    }

    try
    {
        lpwstrGroupName = m_bUseGroup ? m_wstrGroupName.c_str() : NULL;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
        MemFree ((void*)lpcwstrCountryName);
        return ERROR_GEN_FAILURE;
    }

    StoreString (lpcwstrCountryName,
                 (PULONG_PTR)&(pFaxRule->lpctstrCountryName),
                 lpBuffer,
                 pupOffset);

    if (TRUE == m_bUseGroup)
    {
        StoreString (lpwstrGroupName,
                     (PULONG_PTR)&((pFaxRule->Destination).lpcstrGroupName),
                     lpBuffer,
                     pupOffset);
    }

    if (NULL != lpBuffer)
    {
        // Write the data
        Assert (pFaxRule);

        if (FALSE == m_bUseGroup)
        {
            Assert (m_dwDevice);
            (pFaxRule->Destination).dwDeviceId = m_dwDevice;
        }
        pFaxRule->dwSizeOfStruct = sizeof (FAX_OUTBOUND_ROUTING_RULEW);
        pFaxRule->dwAreaCode = DialingLocation.GetAreaCode();
        pFaxRule->dwCountryCode = DialingLocation.GetCountryCode();
        pFaxRule->bUseGroup = m_bUseGroup;
        dwRes = GetStatus (&(pFaxRule->Status));
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingRule::GetStatus failed , ec %ld"), dwRes);
        }
    }

    MemFree ((void*)lpcwstrCountryName);
    return dwRes;
}  // COutboundRoutingRule::Serialize


LPCWSTR
COutboundRoutingRule::GetGroupName () const
/*++

Routine name : COutboundRoutingRule::GetGroupName

Routine description:

    Returns the group name if the rule's destination is a group.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    The group name. If it is NULL call GetLastError() for more info.
    If it is ERROR_SUCCESS the rule's destination is single device.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::GetGroupName"));
    try
    {
        SetLastError (ERROR_SUCCESS);
        if (TRUE == m_bUseGroup)
        {
            return m_wstrGroupName.c_str();
        }
        return NULL;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        return NULL;
    }
}  // GetGroupName




#if DBG
void COutboundRoutingRule::Dump () const
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoutingRule::Dump"));
    WCHAR Buffer[512] = {0};
    DWORD dwBufferSize = sizeof (Buffer)/ sizeof (Buffer[0]);

    try
    {
        if (TRUE == m_bUseGroup)
        {
            _snwprintf (Buffer, dwBufferSize -1, TEXT("\tCountry Code - %ld,\tArea Code - %ld,\tGroup name - %s"),
                        m_DialingLocation.GetCountryCode(),
                        m_DialingLocation.GetAreaCode(),
                        m_wstrGroupName.c_str());
        }
        else
        {
            _snwprintf (Buffer, dwBufferSize -1, TEXT("\tCountry Code - %ld,\tArea Code - %ld,\tDevice ID - %ld"),
                        m_DialingLocation.GetCountryCode(),
                        m_DialingLocation.GetAreaCode(),
                        m_dwDevice);
        }
        OutputDebugString (Buffer);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
    }
    return;
}
#endif  // #if DBG

/***********************************
*                                  *
*  COutboundRulesMap  Methodes     *
*                                  *
***********************************/

DWORD
COutboundRulesMap::Load ()
/*++

Routine name : COutboundRulesMap::Load

Routine description:

    Loads all outbound routing rules from the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::Load"));
    DWORD   dwRes = ERROR_SUCCESS;
    HKEY    hRuleskey = NULL;
    DWORD dwCount = 0;

    hRuleskey = OpenRegistryKey(  HKEY_LOCAL_MACHINE,
                                  REGKEY_FAX_OUTBOUND_ROUTING,
                                  FALSE,
                                  KEY_ALL_ACCESS );
    if (NULL == hRuleskey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey, error  %ld"),
            dwRes);
        return dwRes;
    }

    dwCount = EnumerateRegistryKeys( hRuleskey,
                                     REGKEY_OUTBOUND_ROUTING_RULES,
                                     FALSE,
                                     EnumOutboundRoutingRulesCB,
                                     &dwRes
                                    );

    if (dwRes != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("EnumerateRegistryKeys failed, error  %ld"),
            dwRes);
    }

    RegCloseKey (hRuleskey);
    return dwRes;
}  // COutboundRulesMap::Load


DWORD
COutboundRulesMap::AddRule (COutboundRoutingRule& Rule)
/*++

Routine name : COutboundRulesMap::AddRule

Routine description:

    Adds a new rule to the global map

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    Rule            [in    ] - A reference to the new rule object

Return Value:

    Standard Win32 error code

--*/
{
    RULES_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRoulesMap::AddRule"));
    pair <RULES_MAP::iterator, bool> p;

    try
    {
        //
        // Add new map entry
        //
        p = m_RulesMap.insert (RULES_MAP::value_type(Rule.GetDialingLocation(), Rule));

        //
        // See if entry exists in map
        //
        if (p.second == FALSE)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Rule allready in the rules map"));
            dwRes = ERROR_DUP_NAME;
            goto exit;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
}  // COutboundRulesMap::AddRule



DWORD
COutboundRulesMap::DelRule (CDialingLocation& DialingLocation)
/*++

Routine name : COutboundRulesMap::DelRule

Routine description:

    Deletes a group from the global rules map

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    DialingLocation            [in ] - Pointer to the dialing location key

Return Value:

    Standard Win32 error code

--*/
{
    RULES_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::DelRule"));

    try
    {
        //
        // See if entry exists in map
        //
        if((it = m_RulesMap.find(DialingLocation)) == m_RulesMap.end())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("rule is not in the rules map"));
            dwRes = FAX_ERR_RULE_NOT_FOUND;
            goto exit;
        }

        //
        // Delete the map entry
        //
        m_RulesMap.erase (it);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;

}  //  COutboundRulesMap::DelRule

PCRULE
COutboundRulesMap::FindRule (CDialingLocation& DialingLocation) const
/*++

Routine name : COutboundRulesMap::FindRule

Routine description:

    Returns a pointer to a rule object specified by its name

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    DialingLocation            [in] - The rule's dialing location

Return Value:

    Pointer to the found rule object. If it is null the rule was not found

--*/
{
    RULES_MAP::iterator it;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::FindRule"));

    try
    {
        //
        // See if entry exists in map
        //
        if((it = m_RulesMap.find(DialingLocation)) == m_RulesMap.end())
        {
            SetLastError (FAX_ERR_RULE_NOT_FOUND);
            return NULL;
        }
        return &((*it).second);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        return NULL;
    }
}  //  COutboundRulesMap::FindRule


DWORD
COutboundRulesMap::SerializeRules (PFAX_OUTBOUND_ROUTING_RULEW* ppRules,
                                   LPDWORD lpdwNumRules,
                                   LPDWORD lpdwBufferSize) const
/*++

Routine name : COutboundRulesMap::SerializeRules

Routine description:

    Serializes all the rules in the rules map.
    the caller must call MemFree() to deallocate memory.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    ppRules         [out   ] - Pointer to a pointer to recieve the FAX_OUTBOUND_ROUTING_RULEW buffer
    lpdwNumRules    [out   ] - Pointer to a DWORD to recieve the number of rules serialized
    lpdwBufferSize  [out   ] - Pointer to DWORD to recieve the size of the allocated buffer

Return Value:

    Standard Win32 error code

--*/
{
    RULES_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::SerializeRules"));
    DWORD_PTR dwSize = 0;
    DWORD dwCount = 0;
    PCRULE pCRule;

    Assert (ppRules && lpdwNumRules && lpdwBufferSize);

    *ppRules = NULL;
    *lpdwNumRules = 0;

    try
    {
        // Calculate buffer size
        for (it = m_RulesMap.begin(); it != m_RulesMap.end(); it++)
        {
            pCRule = &((*it).second);

            dwSize += sizeof (FAX_OUTBOUND_ROUTING_RULEW);
            dwRes = pCRule->Serialize (NULL, NULL, &dwSize);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingRule::Serialize failed with %ld"),
                    dwRes);
                goto exit;
            }
            dwCount ++;
        }

        // Allocate buffer
        *ppRules = (PFAX_OUTBOUND_ROUTING_RULEW) MemAlloc (dwSize);
        if (NULL == *ppRules)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Cannot allocate rules buffer"));
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        ZeroMemory(*ppRules, dwSize);

        DWORD_PTR dwOffset = dwCount * sizeof (FAX_OUTBOUND_ROUTING_RULEW);
        dwCount = 0;

        // Fill buffer with serialized info
        for (it = m_RulesMap.begin(); it != m_RulesMap.end(); it++)
        {
            pCRule = &((*it).second);

            (*ppRules)[dwCount].dwSizeOfStruct = DWORD(sizeof (FAX_OUTBOUND_ROUTING_RULEW));
            dwRes = pCRule->Serialize ((LPBYTE)*ppRules, &((*ppRules)[dwCount]), &dwOffset);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRoutingRule::Serialize failed with %ld"),
                    dwRes);
                goto exit;
            }
            dwCount++;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    *lpdwNumRules = dwCount;

    // until MIDL accepts [out, size_is(,__int64*)]
    *lpdwBufferSize = (DWORD)dwSize;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        MemFree (*ppRules);
    }
    return dwRes;
}  //  COutboundRulesMap::SerializeRules


BOOL
COutboundRulesMap::CreateDefaultRule (void)
/*++

Routine name : COutboundRulesMap::CreateDefaultRule

Routine description:

    Creates the default mandatory rule (All CountryCodes, All AreaCodes) if does not exist.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:


Return Value:

    BOOL , Call GetLastError () for more info

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::CreateDefaultRule"));
    PCRULE pCRule;
    CDialingLocation Dialinglocation (ROUTING_RULE_COUNTRY_CODE_ANY, ROUTING_RULE_AREA_CODE_ANY);
    FAX_ENUM_RULE_STATUS dwRuleStatus;
    HKEY hRuleKey = NULL;
    DWORD rVal;

    pCRule = FindRule (Dialinglocation);
    if (NULL != pCRule)
    {
        // Rule exist
        return TRUE;
    }
    dwRes = GetLastError();
    if (FAX_ERR_RULE_NOT_FOUND != dwRes)
    {
        // general failure
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRulesMap::FindRule failed , ec %ld"), dwRes);
        return FALSE;
    }
    dwRes = ERROR_SUCCESS;
    //
    // Rule does not exist - Create it
    //

    // Create the rule registry key
    hRuleKey = OpenOutboundRuleKey( ROUTING_RULE_COUNTRY_CODE_ANY, ROUTING_RULE_AREA_CODE_ANY, TRUE, KEY_ALL_ACCESS );
    if (NULL == hRuleKey)
    {
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't create rule key, OpenRegistryKey failed  : %ld"),
          GetLastError ());
        return FALSE;
    }

    COutboundRoutingRule Rule;
    try
    {
        wstring wstrGroupName (ROUTING_GROUP_ALL_DEVICES);
        dwRes = Rule.Init (Dialinglocation, wstrGroupName);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("COutboundRoutingRule::Init failed , ec %ld"), dwRes);
            goto exit;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    dwRes = AddRule (Rule);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingRule::AddRule failed , ec %ld"), dwRes);
        goto exit;
    }

    // Save the new rule to the registry
    dwRes = Rule.Save (hRuleKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRule::Save failed,  with %ld"),
            dwRes);
        g_pRulesMap->DelRule (Dialinglocation);
        goto exit;
    }

    rVal = Rule.GetStatus (&dwRuleStatus);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingRule::GetStatus failed , ec %ld"), rVal);
    }
    else
    {
        if (dwRuleStatus != FAX_RULE_STATUS_VALID &&
            dwRuleStatus != FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID)
        {
            // Can be if <All devices> is empty (The service has no devices).
            DebugPrintEx(
                   DEBUG_MSG,
                   TEXT("Bad default rule configuration, FAX_RULE_STATUS %ld"), dwRuleStatus);

            FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MED,
                2,
                MSG_BAD_OUTBOUND_ROUTING_RULE_CONFIGUTATION,
                TEXT("*"),
                TEXT("*")
                );
        }
    }

     Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hRuleKey)
    {
        RegCloseKey (hRuleKey);
    }

    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError(dwRes);
    }

    return (ERROR_SUCCESS == dwRes);
}  //  CreateDefaultRule

DWORD
COutboundRulesMap::IsGroupInRuleDest (LPCWSTR lpcwstrGroupName , BOOL* lpbGroupInRule) const
/*++

Routine name : COutboundRulesMap::IsGroupInRuleDest

Routine description:

    Checks if a specific group is a destination of one of the rules

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpcwstrGroupName            [in ] - Group name
    lpbGroupInRule              [out] - Pointer to a BOOL. Gets TRUE if the group is in rule, else FALSE

Return Value:

    Standard Win32 error code.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("COutboundRulesMap::IsGroupInRuleDest"));
    RULES_MAP::iterator it;

    Assert (lpbGroupInRule);
    try
    {
        for (it = m_RulesMap.begin(); it != m_RulesMap.end(); it++)
        {
            PCRULE pCRule = &((*it).second);
            LPCWSTR lpcwstrRuleGroupName = pCRule->GetGroupName();
            if (NULL == lpcwstrRuleGroupName)
            {
                dwRes = GetLastError();
                if (dwRes != ERROR_SUCCESS)
                {
                    DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("COutboundRoutingRule::GetGroupName failed , ec %ld"), dwRes);
                    return dwRes;
                }
                else
                {
                    // This rule uses a single device as its destination
                }
                continue;
            }

            if (wcscmp (lpcwstrGroupName, lpcwstrRuleGroupName) == 0)
            {
                *lpbGroupInRule = TRUE;
                return ERROR_SUCCESS;
            }
        }
        *lpbGroupInRule = FALSE;
        return ERROR_SUCCESS;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or wstring caused exception (%S)"),
            ex.what());
        return ERROR_GEN_FAILURE;
    }
}  //  IsGroupInRuleDest



#if DBG
void COutboundRulesMap::Dump () const
{
    RULES_MAP::iterator it;
    WCHAR Buffer[512] = {0};
    DWORD dwBufferSize = sizeof (Buffer)/ sizeof (Buffer[0]);

    _snwprintf (Buffer, dwBufferSize -1, TEXT("DUMP - Outbound routing rules\n"));
    OutputDebugString (Buffer);

    for (it = m_RulesMap.begin(); it != m_RulesMap.end(); it++)
    {
        ((*it).second).Dump();
        OutputDebugString (TEXT("\n"));
    }
    return;
}
#endif   // #if DBG


void
FaxLogOutboundRule (LPCWSTR  lpcwstrRuleName,
                    DWORD   dwMessageID)
{
    WCHAR wszRuleName[MAX_PATH] = {0};
    LPWSTR lpwstrCountryCode;
    LPWSTR lpwstrAreaCode;
    LPWSTR lpwstrDelim = NULL;
    DWORD dwLevel = FAXLOG_LEVEL_MIN;

    Assert (lpcwstrRuleName);
    Assert (dwMessageID == MSG_BAD_OUTBOUND_ROUTING_RULE_CONFIGUTATION ||
            dwMessageID == MSG_OUTBOUND_ROUTING_RULE_NOT_LOADED ||
            dwMessageID == MSG_OUTBOUND_ROUTING_RULE_NOT_ADDED);


    if (dwMessageID == MSG_BAD_OUTBOUND_ROUTING_RULE_CONFIGUTATION)
    {
        dwLevel = FAXLOG_LEVEL_MED;
    }

    wcscpy (wszRuleName, lpcwstrRuleName);
    lpwstrDelim = wcschr (wszRuleName, L':');
    if (NULL == lpwstrDelim)
    {
        //
        // Registry corruption
        //
        ASSERT_FALSE;
        return;

    }

    lpwstrCountryCode = wszRuleName;
    *lpwstrDelim = L'\0';
    lpwstrDelim ++;
    lpwstrAreaCode = lpwstrDelim;

    if (wcscmp( lpwstrAreaCode, TEXT("0")) == 0  )
    {
        wcscpy ( lpwstrAreaCode, TEXT("*"));
    }

    if (wcscmp( lpwstrCountryCode, TEXT("0")) == 0  )
    {
        wcscpy ( lpwstrCountryCode, TEXT("*"));
    }

    FaxLog(
        FAXLOG_CATEGORY_INIT,
        dwLevel,
        2,
        dwMessageID,
        lpwstrCountryCode,
        lpwstrAreaCode
        );

    return;
}


/************************************
*                                   *
*             Registry              *
*                                   *
************************************/

BOOL
EnumOutboundRoutingRulesCB(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID pContext
    )
{
    DEBUG_FUNCTION_NAME(TEXT("EnumOutboundRoutingGroupsCB"));
    DWORD dwRes;
    COutboundRoutingRule Rule;
    BOOL bRuleDeleted = FALSE;


    if (!SubKeyName)
    {
        return TRUE;
    }

    //
    // Add rule
    //
    dwRes = Rule.Load (hSubKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRule::Load failed, rule - %s, error %ld"),
            SubKeyName,
            dwRes);

        // Open Outbound Routing\Rules key
        HKEY hRulesKey = OpenRegistryKey( HKEY_LOCAL_MACHINE,
                                          REGKEY_FAX_OUTBOUND_ROUTING_RULES,
                                          FALSE,
                                          KEY_ALL_ACCESS );
        if (NULL == hRulesKey)
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenRegistryKey, error  %ld"),
                dwRes);
        }
        else
        {
            DWORD dwRetVal = RegDeleteKey (hRulesKey, SubKeyName);
            if (ERROR_SUCCESS != dwRetVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("RegDeleteKey failed, Rule name - %s,  error %ld"),
                    SubKeyName,
                    dwRetVal);
            }
            else
            {
                bRuleDeleted = TRUE;
            }
        }
        goto exit;
    }

    //
    // Check on which platform are we running
    //
    if ((Rule.GetDialingLocation()).GetCountryCode() != ROUTING_RULE_COUNTRY_CODE_ANY &&
        TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs. Only load default rule *.* (*.AreaCode is not loaded anyway)
        //
        goto exit;
    }

    FAX_ENUM_RULE_STATUS RuleStatus;
    dwRes = Rule.GetStatus(&RuleStatus);
    if (ERROR_SUCCESS == dwRes)
    {
        if (RuleStatus != FAX_RULE_STATUS_VALID &&
            RuleStatus != FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID)
        {
            FaxLogOutboundRule (SubKeyName, MSG_BAD_OUTBOUND_ROUTING_RULE_CONFIGUTATION);
        }
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRule::GetStatus failed, error %ld"),
            dwRes);
    }

    dwRes = g_pRulesMap->AddRule  (Rule);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundrulesMap::Addrule failed, rule name - %s, error %ld"),
            SubKeyName,
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        if (bRuleDeleted == FALSE)
        {
            FaxLogOutboundRule (SubKeyName, MSG_OUTBOUND_ROUTING_RULE_NOT_ADDED);
        }
        else
        {
            FaxLogOutboundRule (SubKeyName, MSG_OUTBOUND_ROUTING_RULE_NOT_LOADED);
        }
    }
    *(LPDWORD)pContext = ERROR_SUCCESS; // Let the service start
    return TRUE; // Let the service start

}  //  EnumOutboundRoutingRulesCB




/************************************
*                                   *
*         RPC handlers              *
*                                   *
************************************/

error_status_t
FAX_AddOutboundRule(
    HANDLE      hFaxHandle,
    DWORD       dwAreaCode,
    DWORD       dwCountryCode,
    DWORD       dwDeviceID,
    LPCWSTR     lpcwstrGroupName,
    BOOL        bUseGroup
    )
/*++

Routine name : FAX_AddOutboundRule

Routine description:

    Adds a new rule to the rules map and to the registry

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - Fax handle
    dwAreaCode          [in    ] - The rule area code
    dwCountryCode           [in    ] - The rule country code
    dwDeviceID          [in    ] - The rule's destinationis device ID. Valid only if bUseGroup is FALSE
    lpcwstrGroupName            [in    ] - The rule's destination group name. Valid only if bUseGroup is TRUE.
    bUseGroup           [in    ] - Flag that indicates whether to use the group as the rule destination

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_AddOutboundRule"));
    HKEY hRuleKey = NULL;
    DWORD rVal;
    BOOL fAccess;

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY)
    {
        //
        // *.* can not be added; *.AreaCode is not a valid rule dialing location.
        //
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("dwCountryCode = 0; *.* can not be added; *.AreaCode is not a valid rule dialing location"));
        return ERROR_INVALID_PARAMETER;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    if (TRUE == bUseGroup)
    {
        if (!lpcwstrGroupName)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("lpctstrGroupName is NULL"));
            return ERROR_INVALID_PARAMETER;
        }

        if (wcslen (lpcwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Group name length exceeded MAX_ROUTING_GROUP_NAME"));
            return ERROR_BUFFER_OVERFLOW;
        }
    }
    else
    {
        if (!dwDeviceID)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("dwDeviceId = 0; Not a valid device ID"));
            return ERROR_INVALID_PARAMETER;
        }
    }

    // Create a new Dialinglocation object
    CDialingLocation Dialinglocation (dwCountryCode, dwAreaCode);
    if (!Dialinglocation.IsValid())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CDialingLocation::IsValidDialingLocation failed, \
                  Area code %ld, Country code %ld"),
            dwAreaCode,
            dwCountryCode);
       return ERROR_INVALID_PARAMETER;
    }

    // Create a new rule object
    COutboundRoutingRule Rule;
    if (TRUE == bUseGroup)
    {
        try
        {
            wstring wstrGroupName(lpcwstrGroupName);
            dwRes = Rule.Init (Dialinglocation, wstrGroupName);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("COutboundRoutingRule::Init failed , ec %ld"), dwRes);
                return GetServerErrorCode(dwRes);
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            return ERROR_GEN_FAILURE;
        }
    }
    else
    {
        Rule.Init (Dialinglocation ,dwDeviceID);
    }

    EnterCriticalSection (&g_CsLine);
    EnterCriticalSection (&g_CsConfig);

    FAX_ENUM_RULE_STATUS RuleStatus;
    dwRes = Rule.GetStatus(&RuleStatus);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoule::GetStatus failed, error %ld"),
            dwRes);
        goto exit;
    }

    if (FAX_GROUP_STATUS_ALL_DEV_NOT_VALID == RuleStatus  ||
        FAX_RULE_STATUS_EMPTY_GROUP == RuleStatus)
    {
        // Empty group device list
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("Bad rule configutation, FAX_RULE_STATUS %ld"), RuleStatus);
        dwRes = FAX_ERR_BAD_GROUP_CONFIGURATION;
        goto exit;
    }

    if (FAX_RULE_STATUS_BAD_DEVICE == RuleStatus)
    {
        // Bad device
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("Bad rule configutation, FAX_RULE_STATUS %ld"), RuleStatus);
        dwRes = ERROR_BAD_UNIT;
        goto exit;
    }

    // Create the rule registry key
    hRuleKey = OpenOutboundRuleKey( dwCountryCode, dwAreaCode, TRUE, KEY_ALL_ACCESS );
    if (NULL == hRuleKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't create rule key, OpenRegistryKey failed  : %ld"),
          dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    // Add the new rule to the map
    dwRes = g_pRulesMap->AddRule (Rule);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoulesMap::AddRule failed, error %ld"),
            dwRes);
        goto exit;
    }

    // Save the new rule to the registry
    dwRes = Rule.Save (hRuleKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRule::Save failed,  with %ld"),
            dwRes);
        g_pRulesMap->DelRule (Dialinglocation);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }


#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing rules - after change"));
    g_pRulesMap->Dump();
#endif

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_RULES);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_RULES) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hRuleKey)
    {
        RegCloseKey (hRuleKey);
    }
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection (&g_CsLine);

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // We might find a line for a pending job. Wake up JobQueueThread
        //
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());

            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);
} // FAX_AddOutboundRule



error_status_t
FAX_RemoveOutboundRule (
    IN handle_t                   hFaxHandle,
    IN DWORD                      dwAreaCode,
    IN DWORD                      dwCountryCode
    )
/*++

Routine name : FAX_RemoveOutboundRule

Routine description:

    Removes an existing rule from the rules map and from the registry.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in] - Fax handle
    dwAreaCode          [in] - The rule area code
    dwCountryCode       [in] - The rule country code

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_RemoveOutboundRule"));
    DWORD rVal;
    PCRULE pCRule = NULL;

    BOOL fAccess;

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY)
    {
        //
        // *.* can not be removed; *.AreaCode is not a valid rule dialing location.
        //
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("dwCountryCode = 0; *.* can not be added; *.AreaCode is not a valid rule dialing location"));
        return ERROR_INVALID_PARAMETER;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    CDialingLocation Dialinglocation (dwCountryCode, dwAreaCode);

    EnterCriticalSection (&g_CsConfig);

    pCRule = g_pRulesMap->FindRule (Dialinglocation);
    if (NULL == pCRule)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoulesMap::FindRule failed, error %ld"),
            dwRes);
       goto exit;
    }

    // Delete the specified rule key
    dwRes = DeleteOutboundRuleKey (dwCountryCode, dwAreaCode);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("DeleteOutboundRuleKey failed, CountryCode - %ld,  AreaCode - %ld, error %ld"),
            dwCountryCode,
            dwAreaCode,
            dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    // Delete the rule from the memory
    dwRes = g_pRulesMap->DelRule (Dialinglocation);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRulesMap::DelRule failed,  error %ld"),
            dwRes);
        goto exit;
    }


#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing rules - after change"));
    g_pRulesMap->Dump();
#endif

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_RULES);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_RULES) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);


exit:
    LeaveCriticalSection (&g_CsConfig);

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // We might find a line for a pending job. Wake up JobQueueThread
        //
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());

            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return dwRes;
} // FAX_RemoveOutboundRule



error_status_t
FAX_SetOutboundRule(
    HANDLE                              hFaxHandle,
    PRPC_FAX_OUTBOUND_ROUTING_RULEW     pRule
    )
{
    DWORD dwRes = ERROR_SUCCESS;
    DWORD rVal;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetOutboundRule"));
    HKEY hRuleKey = NULL;
    PCRULE pCRule = NULL;
    FAX_ENUM_RULE_STATUS dwRuleStatus;
    BOOL fAccess;

    Assert (pRule);

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (TRUE == pRule->bUseGroup)
    {
        if (!(pRule->Destination).lpwstrGroupName)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("lpwstrGroupName is NULL"));
            return ERROR_INVALID_PARAMETER;
        }

        if (wcslen ((pRule->Destination).lpwstrGroupName) >= MAX_ROUTING_GROUP_NAME)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Group name length exceeded MAX_ROUTING_GROUP_NAME"));
            return ERROR_BUFFER_OVERFLOW;
        }
    }
    else
    {
        if (!(pRule->Destination).dwDeviceId)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("dwDeviceId = 0; Not a valid device ID"));
            return ERROR_INVALID_PARAMETER;
        }
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    CDialingLocation Dialinglocation (pRule->dwCountryCode, pRule->dwAreaCode);

    COutboundRoutingRule Rule, OldRule;
    if (TRUE == pRule->bUseGroup)
    {
        try
        {
            wstring wstrGroupName((pRule->Destination).lpwstrGroupName);
            dwRes = Rule.Init (Dialinglocation, wstrGroupName);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("COutboundRoutingRule::Init failed , ec %ld"), dwRes);
                return GetServerErrorCode(dwRes);
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("wstring caused exception (%S)"),
                ex.what());
            return ERROR_GEN_FAILURE;
        }
    }
    else
    {
        Rule.Init (Dialinglocation ,(pRule->Destination).dwDeviceId);
    }

    EnterCriticalSection (&g_CsLine);
    EnterCriticalSection (&g_CsConfig);

    // Check the new rule status
    dwRes = Rule.GetStatus (&dwRuleStatus);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingRule::GetStatus failed , ec %ld"), dwRes);
        goto exit;
    }

    if (FAX_GROUP_STATUS_ALL_DEV_NOT_VALID == dwRuleStatus  ||
        FAX_RULE_STATUS_EMPTY_GROUP == dwRuleStatus)
    {
        // Empty group device list
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("Bad rule configutation, FAX_RULE_STATUS %ld"), dwRuleStatus);
        dwRes = FAX_ERR_BAD_GROUP_CONFIGURATION;
        goto exit;
    }

    if (FAX_RULE_STATUS_BAD_DEVICE == dwRuleStatus)
    {
        // Bad device
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("Bad rule configutation, FAX_RULE_STATUS %ld"), dwRuleStatus);
        dwRes = ERROR_BAD_UNIT;
        goto exit;
    }

    pCRule = g_pRulesMap->FindRule (Dialinglocation);
    if (NULL == pCRule)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoulesMap::FindRule failed, error %ld"),
            dwRes);
       goto exit;
    }

    // Open the rule registry key
    hRuleKey = OpenOutboundRuleKey( pRule->dwCountryCode, pRule->dwAreaCode, FALSE, KEY_ALL_ACCESS );
    if (NULL == hRuleKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't open rule key, OpenRegistryKey failed  : %ld"),
          dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    OldRule = *pCRule;
    *pCRule = Rule;

    dwRes = pCRule->Save (hRuleKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRule::Save failed,  with %ld"),
            dwRes);
        *pCRule = OldRule;
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }


#if DBG
    DebugPrintEx(
          DEBUG_MSG,
          TEXT("Dump outbound routing rules - after change"));
    g_pRulesMap->Dump();
#endif

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_RULES);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_RULES) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hRuleKey)
    {
        RegCloseKey (hRuleKey);
    }
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection (&g_CsLine);

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // We might find a line for a pending job. Wake up JobQueueThread
        //
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());

            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);
} // FAX_FaxSetOutboundRule




error_status_t
FAX_EnumOutboundRules (
    handle_t                             hFaxHandle,
    LPBYTE*                              ppBuffer,
    LPDWORD                              lpdwBufferSize,
    LPDWORD                              lpdwNumRules
    )
/*++

Routine name : FAX_EnumOutboundRules

Routine description:

    Enumurates all outbound routing rules

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - Fax server handle
    ppBuffer            [out   ] - Adress of a pointer to a buffer to be filled with info
    lpdwBufferSize          [in/out] - The buffer size
    lpdwNumGroups           [out   ] - Number of rules returned

Return Value:

    error_status_t

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumOutboundRules"));
    BOOL fAccess;

    Assert (lpdwNumRules && lpdwBufferSize);    // ref pointer in idl
    if (!ppBuffer)                              // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support outbound routing on desktop SKUs.
        //
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
            //
            return ERROR_INVALID_PARAMETER;
        }
        else
        {
            return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
        }
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    *ppBuffer = NULL;
    *lpdwNumRules = 0;

    EnterCriticalSection (&g_CsLine);
    EnterCriticalSection (&g_CsConfig);

    dwRes = g_pRulesMap->SerializeRules ((PFAX_OUTBOUND_ROUTING_RULEW*)ppBuffer,
                                        lpdwNumRules,
                                        lpdwBufferSize);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingRulesMap::SerializeRules failed, error %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection (&g_CsLine);

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(dwRes);

}  //FAX_EnumOutboundGroups
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\routerule.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    RouteRule.h

Abstract:

    This file provides declaration of the service
    outbound routing rules.

Author:

    Oded Sacher (OdedS)  Dec, 1999

Revision History:

--*/

#ifndef _OUT_ROUTE_RULE_H
#define _OUT_ROUTE_RULE_H

#include <map>
#include <list>
#include <string>
#include <algorithm>

using namespace std;
#pragma hdrstop

#pragma warning (disable : 4786)    // identifier was truncated to '255' characters in the debug information
// This pragma does not work KB ID: Q167355


/************************************
*                                   *
*         CDialingLocation          *
*                                   *
************************************/
class CDialingLocation
{
public:
    CDialingLocation () {}
    CDialingLocation (DWORD dwCountryCode, DWORD dwAreaCode)
                      : m_dwCountryCode(dwCountryCode), m_dwAreaCode(dwAreaCode) {}
    ~CDialingLocation () {}

    BOOL IsValid () const;
    bool operator < ( const CDialingLocation &other ) const;
    DWORD GetCountryCode () const {return m_dwCountryCode;}
    DWORD GetAreaCode () const    {return m_dwAreaCode;}
    LPCWSTR GetCountryName () const;

private:

    DWORD m_dwCountryCode;
    DWORD m_dwAreaCode;
};  // CDialingLocation


/************************************
*                                   *
*     COutboundRoutingRule          *
*                                   *
************************************/
class COutboundRoutingRule
{
public:
    COutboundRoutingRule () {}
    ~COutboundRoutingRule () {}
    void Init (CDialingLocation DialingLocation, DWORD dwDevice)
    {
        m_dwDevice = dwDevice;
        m_bUseGroup = FALSE;
        m_DialingLocation = DialingLocation;
        return;
    }
    DWORD Init (CDialingLocation DialingLocation, wstring wstrGroupName);

    COutboundRoutingRule& operator= (const COutboundRoutingRule& rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        m_wstrGroupName = rhs.m_wstrGroupName;
        m_dwDevice = rhs.m_dwDevice;
        m_bUseGroup = rhs.m_bUseGroup;
        m_DialingLocation = rhs.m_DialingLocation;
        return *this;
    }

    DWORD GetStatus (FAX_ENUM_RULE_STATUS* lpdwStatus) const;
    DWORD GetDeviceList (LPDWORD* lppdwDevices, LPDWORD lpdwNumDevices) const;
    DWORD Save(HKEY hRuleKey) const;
    DWORD Load(HKEY hRuleKey);
    const CDialingLocation GetDialingLocation () const { return m_DialingLocation; }
    DWORD Serialize (LPBYTE lpBuffer,
                     PFAX_OUTBOUND_ROUTING_RULEW pFaxRule,
                     PULONG_PTR pupOffset) const;
    LPCWSTR GetGroupName () const;

#if DBG
    void Dump () const;
#endif

private:
    wstring m_wstrGroupName;
    DWORD m_dwDevice;
    BOOL m_bUseGroup;       // Flag that indicates whether to use m_dwDevice or m_wstrGroupName
    CDialingLocation m_DialingLocation;

};  // COutboundRoutingRule

typedef COutboundRoutingRule  *PCRULE;

/************************************
*                                   *
*     COutboundRulesMap             *
*                                   *
************************************/

typedef map<CDialingLocation, COutboundRoutingRule>  RULES_MAP, *PRULES_MAP;

//
// The COutboundRulesMap class maps between group name and a list of device ID's
//
class COutboundRulesMap
{
public:
    COutboundRulesMap () {}
    ~COutboundRulesMap () {}

    DWORD Load ();
    DWORD AddRule (COutboundRoutingRule& Rule);
    DWORD DelRule (CDialingLocation& DialingLocation);
    DWORD SerializeRules (PFAX_OUTBOUND_ROUTING_RULEW* ppRules,
                          LPDWORD lpdwNumRules,
                          LPDWORD lpdwBufferSize) const;
    PCRULE  FindRule (CDialingLocation& DialingLocation) const;
    BOOL CreateDefaultRule (void);
    DWORD IsGroupInRuleDest (LPCWSTR lpcwstrGroupName, BOOL* lpbGroupInRule) const;

#if DBG
    void Dump () const;
#endif

private:
    RULES_MAP   m_RulesMap;
};  // COutboundRulesMap



/************************************
*                                   *
*         Externes                  *
*                                   *
************************************/

extern COutboundRulesMap* g_pRulesMap;       // Map of dialing location to list of device IDs
//
//  IMPORTANT - No locking mechanism - USE g_CsConfig to serialize calls to g_pRulesMap
//


/************************************
*                                   *
*         Functions                 *
*                                   *
************************************/

BOOL CheckDefaultRule (void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\store.h ===
#ifndef _STORE_H
#define _STORE_H


HRESULT
EnumOutgoingArchive( 
		IN  LPWSTR		lpwstrDirectoryName,
		OUT LPWSTR	**	lpppwstrFileNames,
		OUT LPDWORD		lpdwNumFiles);

HRESULT
EnumCoverPagesStore( 
		IN  LPWSTR		lpwstrDirectoryName,
		OUT LPWSTR	**	lpppwstrFileNames,
		OUT LPDWORD		lpdwNumFiles);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\svcwin.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsvc.c

Abstract:

    This module contains the windows code for the
    FAX service debug window.

Author:

    Wesley Witt (wesw) 28-Feb-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

#include "resource.h"


HWND            hwndSvcMain;
HWND            hwndEdit;
HWND            hwndListMsg;
HWND            hwndListLines;
HWND            hwndListState;
DWORD           EditHeight;
DWORD           ListMsgHeight;
DWORD           ListLinesHeight;
DWORD           ListStateHeight;






DWORD
DebugServiceWindowThread(
    HANDLE hEvent
    );

LRESULT
WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


int
DebugService(
    VOID
    )

/*++

Routine Description:

    Starts the service in debug mode.  In this mode the FAX service
    runs as a regular WIN32 process.  This is implemented as an aid
    to debugging the service.

Arguments:

    argc        - argument count
    argv        - argument array

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    LONG        Rslt;
    HANDLE      WaitHandles[2];


    ServiceDebug = TRUE;
    ConsoleDebugOutput = TRUE;

    WaitHandles[1] = CreateEvent( NULL, FALSE, FALSE, NULL );

    WaitHandles[0] = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) DebugServiceWindowThread,
        WaitHandles[1],
        0,
        &Rslt
        );

    if (!WaitHandles[0]) {
        return GetLastError();
    }

    if (WaitForMultipleObjects( 2, WaitHandles, FALSE, INFINITE ) == WAIT_OBJECT_0) {
        //
        // the window initialization did not complete successfuly
        //
        GetExitCodeThread( WaitHandles[0], &Rslt );
        return Rslt;
    }

    return ServiceStart();
}


DWORD
DebugServiceWindowThread(
    HANDLE hEvent
    )
{
    WNDCLASS    wndclass;
    MSG         msg;
    HINSTANCE   hInstance;


    hInstance = GetModuleHandle( NULL );

    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = (WNDPROC) WndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_APPICON) );
    wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground  = (HBRUSH) (COLOR_3DFACE + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = TEXT("FaxService");

    RegisterClass( &wndclass );

    hwndSvcMain = CreateWindow (
        TEXT("FaxService"),      // window class name
        TEXT("Fax Service"),     // window caption
        WS_OVERLAPPEDWINDOW,     // window style
        CW_USEDEFAULT,           // initial x position
        CW_USEDEFAULT,           // initial y position
        CW_USEDEFAULT,           // initial x size
        CW_USEDEFAULT,           // initial y size
        NULL,                    // parent window handle
        NULL,                    // window menu handle
        hInstance,               // program instance handle
        NULL                     // creation parameters
        );

    if (!hwndSvcMain) {
        return 0;
    }

    ShowWindow( hwndSvcMain, SW_SHOWNORMAL );
    UpdateWindow (hwndSvcMain) ;

    SetEvent( hEvent );

    while (GetMessage (&msg, NULL, 0, 0)) {
        TranslateMessage (&msg) ;
        DispatchMessage (&msg) ;
    }

    return 0;
}


VOID
ConsoleDebugPrint(
    LPTSTR buf
    )
{
    static WPARAM   cxExtent = 0;
    static DWORD    MsgCount = 0;
    SIZE            size;
    HDC             hdc;
    HFONT           hFont;


    if (!ConsoleDebugOutput) {
        return;
    }

    SendMessage( hwndListMsg, LB_ADDSTRING, 0, (LPARAM) buf );
    SendMessage( hwndListMsg, LB_SETCURSEL, MsgCount, 0 );

    MsgCount += 1;

    hdc = GetDC( hwndListMsg );
    hFont = (HFONT)SendMessage( hwndListMsg, WM_GETFONT, 0, 0 );
    if (hFont != NULL) {
        SelectObject( hdc, hFont );
    }
    GetTextExtentPoint( hdc, buf, _tcslen(buf), &size );
    if (size.cx > (LONG)cxExtent) {
        cxExtent = size.cx;
    }
    ReleaseDC( hwndListMsg, hdc );

    SendMessage( hwndListMsg, LB_SETHORIZONTALEXTENT, cxExtent, 0 );
}


void
lbprintf(
    HWND hwndList,
    LPTSTR Format,
    ...
    )

/*++

Routine Description:

    Prints a debug string

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    TCHAR buf[1024];
    va_list arg_ptr;
    va_start(arg_ptr, Format);
    _vsntprintf(buf, sizeof(buf)/sizeof(TCHAR), Format, arg_ptr);
    va_end(arg_ptr);
    SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM) buf );
}


LRESULT
WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Window procedure for the TIFF image viewer main window.

Arguments:

    hwnd            - Window handle
    message         - message identifier
    wParam          - Parameter
    lParam          - Parameter

Return Value:

    Return result, zero for success.

--*/

{
    RECT                   Rect;
    HDC                    hDC;
    TEXTMETRIC             tm;
    HFONT                  hFont;
    DWORD                  Height;
    TCHAR                  CmdBuf[128];
    DWORD                  i;


    switch (message) {
        case WM_CREATE:

            GetClientRect( hwnd, &Rect );

            hFont = GetStockObject( SYSTEM_FIXED_FONT );
            SendMessage( hwnd, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );

            hDC = GetDC( hwnd );
            GetTextMetrics( hDC, &tm );
            ReleaseDC( hwnd, hDC );

            EditHeight      = (DWORD)(tm.tmHeight * 1.5);
            Height          = (Rect.bottom - Rect.top) - EditHeight;
            ListMsgHeight   = (DWORD) (Height * .40);
            ListLinesHeight = (DWORD) (Height * .60);
            ListStateHeight = (DWORD) (Height * .60);

            hwndEdit = CreateWindowEx(
                WS_EX_CLIENTEDGE,
                TEXT("EDIT"),
                NULL,
                WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP | ES_LEFT | ES_WANTRETURN | ES_MULTILINE | ES_AUTOVSCROLL,
                Rect.left,
                Rect.bottom - EditHeight,
                Rect.right  - Rect.left,
                EditHeight,
                hwnd,
                NULL,
                GetModuleHandle(NULL),
                NULL
                );

            SendMessage( hwndEdit, EM_LIMITTEXT, 128, 0 );
            SendMessage( hwndEdit, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );

            hwndListMsg = CreateWindowEx(
                WS_EX_CLIENTEDGE,
                TEXT("LISTBOX"),
                NULL,
                WS_VSCROLL           |
                WS_HSCROLL           |
                WS_CHILD             |
                WS_VISIBLE           |
                WS_BORDER            |
                LBS_NOTIFY           |
                LBS_NOINTEGRALHEIGHT |
                LBS_WANTKEYBOARDINPUT,
                Rect.left,
                Rect.bottom - EditHeight - ListMsgHeight,
                Rect.right  - Rect.left,
                ListMsgHeight,
                hwnd,
                NULL,
                GetModuleHandle(NULL),
                NULL
                );

            SendMessage( hwndListMsg, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );

            hwndListLines = CreateWindowEx(
                WS_EX_CLIENTEDGE,
                TEXT("LISTBOX"),
                NULL,
                WS_VSCROLL           |
                WS_HSCROLL           |
                WS_CHILD             |
                WS_VISIBLE           |
                WS_BORDER            |
                LBS_NOTIFY           |
                LBS_NOINTEGRALHEIGHT |
                LBS_WANTKEYBOARDINPUT,
                Rect.left,
                Rect.bottom - EditHeight - ListMsgHeight - ListLinesHeight,
                (Rect.right  - Rect.left) / 2,
                ListLinesHeight,
                hwnd,
                NULL,
                GetModuleHandle(NULL),
                NULL
                );

            SendMessage( hwndListLines, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );

            hwndListState = CreateWindowEx(
                WS_EX_CLIENTEDGE,
                TEXT("LISTBOX"),
                NULL,
                WS_VSCROLL           |
                WS_HSCROLL           |
                WS_CHILD             |
                WS_VISIBLE           |
                WS_BORDER            |
                LBS_NOTIFY           |
                LBS_NOINTEGRALHEIGHT |
                LBS_WANTKEYBOARDINPUT,
                Rect.left + ((Rect.right  - Rect.left) / 2),
                Rect.bottom - EditHeight - ListMsgHeight,
                (Rect.right  - Rect.left) / 2,
                ListStateHeight,
                hwnd,
                NULL,
                GetModuleHandle(NULL),
                NULL
                );

            SendMessage( hwndListState, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );

            SetFocus( hwndEdit );

            return 0;

        case WM_ACTIVATEAPP:
        case WM_SETFOCUS:
            SetFocus( hwndEdit );
            return 0;

        case WM_WINDOWPOSCHANGED:
            GetClientRect( hwnd, &Rect );

            Height          = (Rect.bottom - Rect.top) - EditHeight;
            ListMsgHeight   = (DWORD) (Height * .40);
            ListLinesHeight = (DWORD) (Height * .60);
            ListStateHeight = (DWORD) (Height * .60);

            MoveWindow(
                hwndEdit,
                Rect.left,
                Rect.bottom - Rect.top - EditHeight,
                Rect.right - Rect.left,
                EditHeight,
                TRUE
                );
            MoveWindow(
                hwndListMsg,
                Rect.left,
                Rect.bottom - Rect.top - EditHeight - ListMsgHeight,
                Rect.right - Rect.left,
                ListMsgHeight,
                TRUE
                );
            MoveWindow(
                hwndListLines,
                Rect.left,
                Rect.bottom - Rect.top - EditHeight - ListMsgHeight - ListLinesHeight,
                (Rect.right  - Rect.left) / 2,
                ListLinesHeight,
                TRUE
                );
            MoveWindow(
                hwndListState,
                Rect.left + ((Rect.right  - Rect.left) / 2),
                Rect.bottom - Rect.top - EditHeight - ListMsgHeight - ListLinesHeight,
                (Rect.right  - Rect.left) / 2,
                ListStateHeight,
                TRUE
                );
            return 0;

        case WM_COMMAND:
            switch ( HIWORD(wParam) ) {
                case EN_CHANGE:
                    GetWindowText( hwndEdit, CmdBuf, sizeof(CmdBuf) );
                    i = _tcslen(CmdBuf);
                    if (i && CmdBuf[i-1] == TEXT('\n')) {
                        SetWindowText( hwndEdit, TEXT("") );
                        CmdBuf[i-2] = 0;
                        ConsoleDebugPrint( CmdBuf );
                        switch( _totlower( CmdBuf[0] ) ) {
                            case TEXT('q'):
                                DestroyWindow( hwnd );
                                break;

                            default:
                                break;
                        }
                    }
                    break;

                case LBN_SELCHANGE:
                    if ((HWND)lParam == hwndListLines) {
                        extern PLINE_INFO TapiLines;
                        extern CRITICAL_SECTION CsLine;

print_line_state:
                        i = SendMessage( hwndListLines, LB_GETCURSEL, 0, 0 );

                        if (i != LB_ERR) {

                            SendMessage( hwndListState, WM_SETREDRAW, FALSE, 0 );
                            SendMessage( hwndListState, LB_RESETCONTENT, 0, 0 );

                            if (TapiLines[i].Provider) {
                                lbprintf( hwndListState, TEXT("Provider:    %s"),     TapiLines[i].Provider->ProviderName );
                                lbprintf( hwndListState, TEXT("Heap:        0x%08x"), TapiLines[i].Provider->HeapHandle   );
                                lbprintf( hwndListState, TEXT("Base:        0x%08x"), TapiLines[i].Provider->hModule      );
                            }

                            lbprintf( hwndListState, TEXT("DeviceId:    %d"),     TapiLines[i].DeviceId               );
                            lbprintf( hwndListState, TEXT("Line Handle: 0x%08x"), TapiLines[i].hLine                  );
                            lbprintf( hwndListState, TEXT("Job:         0x%08x"), TapiLines[i].JobEntry               );

                            SendMessage( hwndListState, WM_SETREDRAW, TRUE, 0 );

                        }

                    }

                    break;


                default:
                    break;
            }
            return 0;

        case WM_SERVICE_INIT:
            SendMessage( hwndListLines, LB_SETCURSEL, 0, 0 );
            goto print_line_state;
            return 0;

        case WM_CTLCOLOREDIT:
            SetBkColor( (HDC)wParam, RGB(128,128,0) );
            return (LPARAM)CreateSolidBrush( RGB(128,128,0) );

        case WM_CTLCOLORLISTBOX:
            if ((HWND)lParam == hwndListLines || (HWND)lParam == hwndListState) {
                SetBkColor( (HDC)wParam, RGB(192,192,192) );
                return (LPARAM)CreateSolidBrush( RGB(192,192,192) );
            }
            if ((HWND)lParam == hwndListMsg) {
                SetBkColor( (HDC)wParam, RGB(192,192,192) );
                return (LPARAM)CreateSolidBrush( RGB(192,192,192) );
            }
            return 0;

        case WM_DESTROY:
            ServiceStop();
#ifdef FAX_HEAP_DEBUG
            PrintAllocations();
#endif
            PostQuitMessage( 0 );
            return 0;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\store.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Store.c

Abstract:

    This module implements the Outgoing Archive and Cover Pages Storage

Author:

    Sasha Bessonov (v-sashab) 25-Jul-1999


Revision History:

--*/
#include <malloc.h>
#include "faxsvc.h"
#pragma hdrstop

//********************************************************************************
//* Name: EnumOutgoingArchive() 
//* Author: Sasha Bessonov
//* Date:   July 25, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		Enumerates all sent faxes from outgoing archive.
//* PARAMETERS:
//*		lpwstrDirectoryName - Archive directory name
//*		lpppwstrFileNames - Output string contains file names
//*		lpdwNumFiles - Archive size (number of files)
//* RETURN VALUE:
//*     ERROR_SUCCESS
//*         If all the faxes were enumerated successfully.
//*     ERROR_INVALID_PARAMETER
//*         If wrong parameters were passed.
//*********************************************************************************
HRESULT
EnumOutgoingArchive( 
		IN  LPWSTR		lpwstrDirectoryName,
		OUT LPWSTR	**	lpppwstrFileNames,
		OUT LPDWORD		lpdwNumFiles)
{
    WIN32_FIND_DATA FindData;
    HANDLE			hFind;
    WCHAR			szFileName[MAX_PATH]; 
	DWORD			dwNumFiles = 0;
	DWORD			dwIndex = 0;
	HRESULT			hRes;


    DEBUG_FUNCTION_NAME(L"EnumOutgoingArchive");

    if (!lpppwstrFileNames || !lpdwNumFiles) {
	   DebugPrintEx( DEBUG_WRN,
			  L"Invalid parameters ");
        return ERROR_INVALID_PARAMETER;
	}

	*lpdwNumFiles = 0;
	*lpppwstrFileNames = NULL;

    wsprintf( szFileName, L"%s\\*.tif", lpwstrDirectoryName ); 

	// calculate the number of files
    hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        DebugPrintEx( DEBUG_WRN,
                      L"No sent faxes found at archive dir %s",
                      lpwstrDirectoryName);
        return GetLastError();
    }
    do {
		dwNumFiles++;

    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose failed (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

	// initialize OUT parameters
	*lpdwNumFiles = dwNumFiles;
    *lpppwstrFileNames = (LPWSTR *) MemAlloc( *lpdwNumFiles * sizeof(LPWSTR) );
    // store file names at array
	dwIndex = 0;
	hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
		hRes = GetLastError();
        DebugPrintEx( DEBUG_WRN,
                      L"FindFirstFile failed to find file (ec: %ld)",
                      hRes);
        return hRes;
    }
    do {
		Assert (dwIndex < dwNumFiles);
        wsprintf( szFileName, L"%s", FindData.cFileName );
		(*lpppwstrFileNames) [dwIndex] = (LPWSTR) MemAlloc((wcslen(szFileName) + 1)* sizeof(WCHAR));
		if (!(*lpppwstrFileNames) [dwIndex]) {
	        return ERROR_NOT_ENOUGH_MEMORY;
		}
		wcscpy((*lpppwstrFileNames) [dwIndex],szFileName);
		dwIndex++;

    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose failed (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }


    return ERROR_SUCCESS;
}

//********************************************************************************
//* Name: EnumOutgoingArchive() 
//* Author: Sasha Bessonov
//* Date:   July 25, 1999
//*********************************************************************************
//* DESCRIPTION:
//*		Enumerates all cover pages from caver pages storage.
//* PARAMETERS:
//*     None.
//* RETURN VALUE:
//*     ERROR_SUCCESS
//*         If all the faxes were enumerated successfully.
//*     ERROR_INVALID_PARAMETER
//*         If wrong parameters were passed.
//*********************************************************************************
HRESULT
EnumCoverPagesStore( 
		IN  LPWSTR		lpwstrDirectoryName,
		OUT LPWSTR	**	lpppwstrFileNames,
		OUT LPDWORD		lpdwNumFiles)
{
    WIN32_FIND_DATA FindData;
    HANDLE			hFind;
    WCHAR			szFileName[MAX_PATH]; 
	DWORD			dwNumFiles = 0;
	DWORD			dwIndex = 0;
	HRESULT			hRes;


    DEBUG_FUNCTION_NAME(L"EnumCoverPagesStore");

    if (!lpppwstrFileNames || !lpdwNumFiles) {
	   DebugPrintEx( DEBUG_WRN,
			  L"Invalid parameters ");
        return ERROR_INVALID_PARAMETER;
	}

	*lpdwNumFiles = 0;
	*lpppwstrFileNames = NULL;

    wsprintf( szFileName, L"%s\\*.cov", lpwstrDirectoryName ); 

	// calculate the number of files
    hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        DebugPrintEx( DEBUG_WRN,
                      L"No cover pages found at server directory %s",
                      lpwstrDirectoryName);
        return GetLastError();
    }
    do {
		dwNumFiles++;

    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose failed (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }

	// initialize OUT parameters
	*lpdwNumFiles = dwNumFiles;
    *lpppwstrFileNames = (LPWSTR *) MemAlloc( *lpdwNumFiles * sizeof(LPWSTR) );
    // store file names at array
	dwIndex = 0;
	hFind = FindFirstFile( szFileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
		hRes = GetLastError();
        DebugPrintEx( DEBUG_WRN,
                      L"FindFirstFile failed to find file (ec: %ld)",
                      hRes);
        return hRes;
    }
    do {
		Assert (dwIndex < dwNumFiles);
        wsprintf( szFileName, L"%s", FindData.cFileName );
		(*lpppwstrFileNames) [dwIndex] = (LPWSTR) MemAlloc((wcslen(szFileName) + 1)* sizeof(WCHAR));
		if (!(*lpppwstrFileNames) [dwIndex]) {
	        return ERROR_NOT_ENOUGH_MEMORY;
		}
		wcscpy((*lpppwstrFileNames) [dwIndex],szFileName);
		dwIndex++;

    } while(FindNextFile( hFind, &FindData ));

    if (!FindClose( hFind )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindClose failed (ec: %ld)"),
            GetLastError());
        Assert(FALSE);
    }


    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\server.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    server.c

Abstract:

    This module contains the code to provide the RPC server.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

DWORD g_dwLastUniqueLineId;
INT g_iTotalFsp;


FAX_SERVER_RECEIPTS_CONFIGW         g_ReceiptsConfig;           // Global receipts configuration
FAX_ARCHIVE_CONFIG          g_ArchivesConfig[2];        // Global archives configuration
FAX_ACTIVITY_LOGGING_CONFIG g_ActivityLoggingConfig;    // Global activity logging configuration

const GUID gc_FaxSvcGuid = { 0xc3a9d640, 0xab07, 0x11d0, { 0x92, 0xbf, 0x0, 0xa0, 0x24, 0xaa, 0x1c, 0x1 } };

CFaxCriticalSection g_CsConfig;        // Protects configuration read / write

FAX_SERVER_ACTIVITY g_ServerActivity = {sizeof(FAX_SERVER_ACTIVITY), 0, 0, 0, 0, 0, 0, 0, 0};  //  Global Fax Service Activity
CFaxCriticalSection    g_CsActivity;              // Controls access to g_ServerActivity;

CFaxCriticalSection g_CsPerfCounters;
CFaxCriticalSection g_csUniqueQueueFile;

CFaxCriticalSection    g_CsServiceThreads;     // Controls service global threads count
LONG                g_lServiceThreadsCount; // Service threads count
HANDLE              g_hThreadCountEvent;    // This Event is set when the service threads count is 0.

DWORD g_dwOutboundSeconds;
DWORD g_dwInboundSeconds;
DWORD g_dwTotalSeconds;


CHAR Buffer[4096];

HANDLE g_hFaxPerfCountersMap;
PFAX_PERF_COUNTERS g_pFaxPerfCounters;
HANDLE g_hFaxServerEvent;   // Named event used to notify other instnaces on this machine that the fax service RPC server is up and running


#ifdef DBG
HANDLE g_hCritSecLogFile;
LIST_ENTRY g_CritSecListHead;
CFaxCriticalSection g_CsCritSecList;
#endif

typedef struct _RPC_PROTOCOL {
    LPTSTR  ProtName;
    LPTSTR  EndPoint;
} RPC_PROTOCOL, *PRPC_PROTOCOL;


RPC_PROTOCOL const gc_Protocols[] =
{
    TEXT("ncalrpc"),       NULL,
    TEXT("ncacn_ip_tcp"),  NULL,
    TEXT("ncacn_np"),      TEXT("\\PIPE\\faxsvc"),
    TEXT("ncadg_ip_udp"),  NULL
};

#define PROTOCOL_COUNT (sizeof(gc_Protocols)/sizeof(gc_Protocols[0]))

HANDLE   g_hRPCListeningThread;

WCHAR   g_wszFaxQueueDir[MAX_PATH];


DWORD
FaxInitThread(
     PREG_FAX_SERVICE FaxReg
    );

DWORD WINAPI FaxRPCListeningThread(
  LPVOID pvUnused
);



VOID
PrintBanner(
    VOID
    )
{
#ifdef DBG
    DWORD LinkTime;
    TCHAR FileName[MAX_PATH];
    DWORD VerSize;
    LPVOID VerInfo;
    VS_FIXEDFILEINFO *pvs;
    DWORD Tmp;
    LPTSTR TimeString;


    LinkTime = GetTimestampForLoadedLibrary( GetModuleHandle(NULL) );
    TimeString = _tctime( (time_t*) &LinkTime );
    TimeString[_tcslen(TimeString)-1] = 0;

    if (!GetModuleFileName( NULL, FileName, (sizeof(FileName)/sizeof(FileName[0])))) {
        return;
    }

    VerSize = GetFileVersionInfoSize( FileName, &Tmp );
    if (!VerSize) {
        return;
    }

    VerInfo = MemAlloc( VerSize );
    if (!VerInfo) {
        return;
    }

    if (!GetFileVersionInfo( FileName, 0, VerSize, VerInfo )) {
        return;
    }

    if (!VerQueryValue( VerInfo, TEXT("\\"), (LPVOID *)&pvs, (UINT *)&VerSize )) {
        MemFree( VerInfo );
        return;
    }

    DebugPrint(( TEXT("------------------------------------------------------------") ));
    DebugPrint(( TEXT("Windows XP Fax Server") ));
    DebugPrint(( TEXT("Copyright (C) Microsoft Corp 1996. All rights reserved.") ));
    DebugPrint(( TEXT("Built: %s"), TimeString ));
    DebugPrint(( TEXT("Version: %d.%d:%d.%d"),
        HIWORD(pvs->dwFileVersionMS), LOWORD(pvs->dwFileVersionMS),
        HIWORD(pvs->dwFileVersionLS), LOWORD(pvs->dwFileVersionLS)
        ));
    DebugPrint(( TEXT("------------------------------------------------------------") ));

    MemFree( VerInfo );

#endif //DBG
}



/*
 *  InitializeDefaultLogCategoryNames
 *
 *  Purpose:
 *          This function initializes the Name members of DefaultCategories,
 *          the global array of type FAX_LOG_CATEGORY.
 *
 *  Arguments:
 *          DefaultCategories - points to an array of FAX_LOG_CATEGORY structures.
 *          DefaultCategoryCount - the number of entries in DefaultCategories
 *
 *
 *  Returns:
 *          None.
 *
 */

VOID InitializeDefaultLogCategoryNames( PFAX_LOG_CATEGORY DefaultCategories,
                                        int DefaultCategoryCount )
{
    int         xCategoryIndex;
    int         xStringResourceId;
    LPTSTR      ptszCategoryName;

    for ( xCategoryIndex = 0; xCategoryIndex < DefaultCategoryCount; xCategoryIndex++ )
    {
        xStringResourceId = IDS_FAX_LOG_CATEGORY_INIT_TERM + xCategoryIndex;
        ptszCategoryName = GetString( xStringResourceId );

        if ( ptszCategoryName != (LPTSTR) NULL )
        {
            DefaultCategories[xCategoryIndex].Name = ptszCategoryName;
        }
        else
        {
            DefaultCategories[xCategoryIndex].Name = TEXT("");
        }
    }
    return;
}

DWORD
LoadConfiguration (
    PREG_FAX_SERVICE *ppFaxReg
)
/*++

Routine name : LoadConfiguration

Routine description:

    Loads the configuration of the Fax Server from the registry

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    ppFaxReg        [out] - Pointer to fax registry structure to recieve

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("LoadConfiguration"));

    EnterCriticalSection (&g_CsConfig);
    //
    // Get general settings (including outbox config)
    //
    dwRes = GetFaxRegistry(ppFaxReg);
    if (ERROR_SUCCESS != dwRes)
    {
        USES_DWORD_2_STR;

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFaxRegistry() failed (ec: %ld)"),
            dwRes);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_CONFIGURATION,
            DWORD2DECIMAL(dwRes)
            );
        goto exit;
    }
    g_dwLastUniqueLineId = (*ppFaxReg)->dwLastUniqueLineId;
    g_dwMaxLineCloseTime = ((*ppFaxReg)->dwMaxLineCloseTime) ? (*ppFaxReg)->dwMaxLineCloseTime : 60 * 5; //Set default value to 5 minutes

    //
    // Get SMTP configuration
    //
    dwRes = LoadReceiptsSettings (&g_ReceiptsConfig);
    if (ERROR_SUCCESS != dwRes)
    {
        USES_DWORD_2_STR;

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadReceiptsSettings() failed (ec: %ld)"),
            dwRes);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_RECEIPTS_CONFIGURATION,
            DWORD2DECIMAL(dwRes)
            );
        goto exit;
    }
    //
    // Get inbox archive configuration
    //
    dwRes = LoadArchiveSettings (FAX_MESSAGE_FOLDER_INBOX,
                                 &g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX]);
    if (ERROR_SUCCESS != dwRes)
    {
        USES_DWORD_2_STR;

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadArchiveSettings(FAX_MESSAGE_FOLDER_INBOX) failed (ec: %ld)"),
            dwRes);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_ARCHIVE_CONFIGURATION,
            DWORD2DECIMAL(dwRes)
            );
        goto exit;
    }
    //
    // Get SentItems archive configuration
    //
    dwRes = LoadArchiveSettings (FAX_MESSAGE_FOLDER_SENTITEMS,
                                 &g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS]);
    if (ERROR_SUCCESS != dwRes)
    {
        USES_DWORD_2_STR;

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadArchiveSettings(FAX_MESSAGE_FOLDER_SENTITEMS) failed (ec: %ld)"),
            dwRes);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_ARCHIVE_CONFIGURATION,
            DWORD2DECIMAL(dwRes)
            );
        goto exit;
    }
    //
    // Get activity logging configuration
    //
    dwRes = LoadActivityLoggingSettings (&g_ActivityLoggingConfig);
    if (ERROR_SUCCESS != dwRes)
    {
        USES_DWORD_2_STR;

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadActivityLoggingSettings() failed (ec: %ld)"),
            dwRes);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_ACTIVITY_LOGGING_CONFIGURATION,
            DWORD2DECIMAL(dwRes)
            );
        goto exit;
    }
    dwRes = ReadManualAnswerDeviceId (&g_dwManualAnswerDeviceId);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Non-critical
        //
        g_dwManualAnswerDeviceId = 0;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ReadManualAnswerDeviceId() failed (ec: %ld)"),
            dwRes);
    }

exit:
    LeaveCriticalSection (&g_CsConfig);
    return dwRes;
}   // LoadConfiguration



DWORD
ServiceStart(
    VOID
    )

/*++

Routine Description:

    Starts the RPC server.  This implementation listens on
    a list of protocols.  Hopefully this list is inclusive
    enough to handle RPC requests from most clients.

Arguments:

    None.
.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD Rval;
    DWORD ThreadId;
    DWORD dwExitCode;
    INT iTotalDelay = 0;
    HANDLE hThread = NULL;
    SECURITY_ATTRIBUTES *pSA;
    PREG_FAX_SERVICE FaxReg = NULL;
    RPC_BINDING_VECTOR *BindingVector = NULL;
    BOOL bLogEvent = TRUE;
    BOOL bRet = TRUE;
#if DBG
    HKEY hKeyLog;
    LPTSTR LogFileName;
#endif

   FAX_LOG_CATEGORY DefaultCategories[] =
   {
       { NULL, FAXLOG_CATEGORY_INIT,     FAXLOG_LEVEL_MED },
       { NULL, FAXLOG_CATEGORY_OUTBOUND, FAXLOG_LEVEL_MED },
       { NULL, FAXLOG_CATEGORY_INBOUND,  FAXLOG_LEVEL_MED },
       { NULL, FAXLOG_CATEGORY_UNKNOWN,  FAXLOG_LEVEL_MED }
   };   

   DEBUG_FUNCTION_NAME(TEXT("ServiceStart"));

#define DefaultCategoryCount  (sizeof(DefaultCategories) / sizeof(FAX_LOG_CATEGORY))

    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );

#ifdef DBG
    hKeyLog = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SOFTWARE,FALSE,KEY_READ);
    if (hKeyLog)
    {
        LogFileName = GetRegistryString(hKeyLog,TEXT("CritSecLogFile"),TEXT("NOFILE"));

        if (_wcsicmp(LogFileName, TEXT("NOFILE")) != 0 )
        {

            g_hCritSecLogFile = CreateFile(LogFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_ARCHIVE,
                                  NULL);
            if (g_hCritSecLogFile != INVALID_HANDLE_VALUE)
            {
                char AnsiBuffer[300];
                DWORD BytesWritten;

                wsprintfA(AnsiBuffer,
                          "Initializing log at %d\r\nTickCount\tObject\tObject Name\tCritical Section API\tFile\tLine\t(Time Held)\r\n",
                          GetTickCount()
                         );

                SetFilePointer(g_hCritSecLogFile,0,0,FILE_END);

                WriteFile(g_hCritSecLogFile,(LPBYTE)AnsiBuffer,strlen(AnsiBuffer) * sizeof(CHAR),&BytesWritten,NULL);
            }
        }

        MemFree( LogFileName );

        RegCloseKey( hKeyLog );
        ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    }
#endif

    PrintBanner();

    if (IsDesktopSKU())
    {
        BOOL bLocalFaxPrinterShared;
        DWORD dwRes;

        dwRes = IsLocalFaxPrinterShared (&bLocalFaxPrinterShared);
        if (ERROR_SUCCESS == dwRes)
        {
            if (bLocalFaxPrinterShared)
            {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Local fax printer is shared in desktop SKU - fixing that now."));
                dwRes = SetLocalFaxPrinterSharing (FALSE);
                if (ERROR_SUCCESS == dwRes)
                {
                    DebugPrintEx(
                        DEBUG_MSG,
                        TEXT("Local fax printer is no longer shared"));
                }
                else
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("SetLocalFaxPrinterSharing() failed: err = %d"),
                        dwRes);
                }
            }
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("IsLocalFaxPrinterShared() failed: err = %d"),
                dwRes);
        }
        ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    }
    // Initialize the Name members of the elements of DefaultCategories, the array
    // of FAX_LOG_CATEGORY structures.
    InitializeDefaultLogCategoryNames(DefaultCategories, DefaultCategoryCount); // Can not fail
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // initialize the event log so we can log events
    //
    if (!InitializeEventLog( &FaxReg, DefaultCategories, DefaultCategoryCount ))
    {
        Rval = GetLastError();
        Assert (ERROR_SUCCESS != Rval);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeEventLog() failed: err = %d"),
            Rval);
        return Rval;
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // initialize the string table
    //
    if (!InitializeStringTable())
    {
        Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeStringTable() failed: err = %d"),
            Rval);
        goto Error;
    }

    if (!InitializeFaxDirectories())
    {
        Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Couldn't InitFaxDirectories, ec = %d"),
        Rval);
       goto Error;
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    

    //
    // Create an event to signal all service threads are terminated.
    // The event is set/reset by the service threads reference count mechanism.
    // (IncreaseServiceThreadsCount DecreaseServiceThreadsCount AND CreateThreadAndRefCount).
    // The event must be created after g_CsServiceThreads is initialized because it is used also to mark g_CsServiceThreads is initialized.
    //
    g_hThreadCountEvent = CreateEvent(
        NULL,   // SD
        TRUE,   // reset type - Manual
        TRUE,   // initial state - Signaled. We didn't create any service threads yet. The event is reset when the first thread is created.
        NULL    // object name
        );
    if (NULL == g_hThreadCountEvent)
    {
        Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateEvent (g_hThreadCountEvent) failed (ec: %ld)"),
            Rval);
        goto Error;
    }

    //
    // Create the perf counters.
    // Since fax service might be running under the system account,
    // we must setup a security descriptor so other account (and other desktops) may access
    // the shared memory region
    //
    pSA = CreateSecurityAttributesWithThreadAsOwner (FILE_MAP_READ);
    if (!pSA)
    {
        Rval = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateSecurityAttributesWithThreadAsOwner() failed. (ec: %ld)"),
                Rval);
        goto Error;
    }

    g_hFaxPerfCountersMap = CreateFileMapping(
        INVALID_HANDLE_VALUE,
        pSA,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        sizeof(FAX_PERF_COUNTERS),
        FAXPERF_SHARED_MEMORY
        );
    if (NULL == g_hFaxPerfCountersMap)
    {
        Rval = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFileMapping() failed. (ec: %ld)"),
                Rval);
        DestroySecurityAttributes (pSA);
        goto Error;
    }
    DestroySecurityAttributes (pSA);
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    g_pFaxPerfCounters = (PFAX_PERF_COUNTERS) MapViewOfFile(
        g_hFaxPerfCountersMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (NULL == g_pFaxPerfCounters)
    {
        Rval = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("MapViewOfFile() failed. (ec: %ld)"),
                Rval);
        goto Error;
    }

    //
    // Create a named event for synchronization
    // of the server initialization phase.  This
    // object is necessary because we lie to the
    // service controller about our initialization
    // and create a thread that completes the
    // server initialization. This event is signaled
    // when the initialization thread is complete.
    // The security descriptor is created so that
    // processes running on other desktops can
    // access the event object.
    //
    pSA = CreateSecurityAttributesWithThreadAsOwner (SYNCHRONIZE);
    if (!pSA)
    {
        Rval = GetLastError ();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateSecurityAttributesWithThreadAsOwner() failed. (ec: %ld)"),
                Rval);
        goto Error;
    }

    g_hFaxServerEvent = CreateEvent( pSA, TRUE, FALSE, FAX_SERVER_EVENT_NAME );
    if (!g_hFaxServerEvent)
    {
        Rval = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateEvent() failed: err = %ld"),
            Rval);
        DestroySecurityAttributes (pSA);
        goto Error;
    }
    DestroySecurityAttributes (pSA);
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    SetErrorMode( SetErrorMode( 0 ) | SEM_FAILCRITICALERRORS );

    //
    // get the registry data
    // the FaxInitThread will free this structure
    //

    Assert (FaxReg);
    Rval = LoadConfiguration (&FaxReg);
    if (ERROR_SUCCESS != Rval)
    {
        //
        // Event log issued by LoadConfiguration();
        //
        bLogEvent = FALSE;

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadConfiguration() failed (ec: %ld)"),
            Rval);
        goto Error;
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // initialize activity logging
    //
    Rval = InitializeLogging();
    if (ERROR_SUCCESS != Rval)
    {
        USES_DWORD_2_STR;

        DebugPrint(( TEXT("InitializeLogging() failed: err = %d"), Rval));
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_LOGGING_NOT_INITIALIZED,
            DWORD2DECIMAL(Rval)
            );
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // Initialize events mechanism
    //
    Rval = InitializeServerEvents();
    if (ERROR_SUCCESS != Rval)
    {
        USES_DWORD_2_STR;

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeServerEvents failed (ec: %ld)"),
            Rval);

        FaxLog( FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
                DWORD2DECIMAL(Rval)
              );
        bLogEvent = FALSE;
        goto Error;
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // Initilaize the extension configuration notification map
    //
    Rval = g_pNotificationMap->Init ();
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CNotificationMap.Init() failed (ec: %ld)"),
            Rval);
        goto Error;
    }
    ReportServiceStatus( SERVICE_START_PENDING, 0, 60000 );
    //
    // Create a thread to do the rest of the initialization.
    // See FaxInitThread comments for details.
    //

    g_iTotalFsp = FaxReg->DeviceProviderCount;

    hThread = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) FaxInitThread,
                            LPVOID(FaxReg),
                            0,
                            &ThreadId
                            );
    if (!hThread)
    {
        DebugPrintEx(   DEBUG_ERR,
                        _T("Failed to create FaxInitThread (CreateThread)(ec: %ld)."),
                        Rval = GetLastError());

        bLogEvent = FALSE;
        goto Error;
    }

    ReportServiceStatus( SERVICE_START_PENDING, 0, 2*PROGRESS_RESOLUTION );
    iTotalDelay = 0;
    do
    {
        Rval = WaitForSingleObject(hThread,PROGRESS_RESOLUTION);
        if (Rval==WAIT_OBJECT_0)
        {
            bRet = GetExitCodeThread(hThread,&dwExitCode);
            if (!bRet)
            {
                DebugPrintEx(   DEBUG_ERR,
                                _T("GetExitCodeThread Failed (ec: %ld)."),
                                Rval = GetLastError());

                bLogEvent = FALSE;
                CloseHandle(hThread);
                goto Error;
            }
            // FaxInitThread finished successfully
            Rval = dwExitCode;
            break;
        }
        else if (Rval==WAIT_TIMEOUT)
        {
            iTotalDelay += PROGRESS_RESOLUTION;
            if (iTotalDelay>(STARTUP_SHUTDOWN_TIMEOUT * g_iTotalFsp))
            {
                DebugPrintEx(DEBUG_ERR,_T("Failed to Init"));
                bLogEvent = FALSE;
                Rval = ERROR_FUNCTION_FAILED;
                CloseHandle(hThread);
                goto Error;
            }
            ReportServiceStatus( SERVICE_START_PENDING, 0, 3*PROGRESS_RESOLUTION );
            DebugPrintEx(DEBUG_MSG,_T("Waiting for Init %d sec"),iTotalDelay/1000);
        }
        else
        {
            // WAIT_FAILED
            DebugPrintEx(   DEBUG_ERR,
                            _T("WaitForSingleObject Failed (ec: %ld)."),
                            Rval = GetLastError());

            bLogEvent = FALSE;
            CloseHandle(hThread);
            goto Error;

        }
    }
    while (Rval==WAIT_TIMEOUT);
    CloseHandle(hThread);

    if (ERROR_SUCCESS != Rval)
    {
        //
        // FaxInitThread failed
        //
        DebugPrintEx( DEBUG_ERR,
                      _T("FaxInitThread Failed (ec: %ld)."),
                      Rval);
        bLogEvent = FALSE;
        goto Error;
    }

    FaxLog(
        FAXLOG_CATEGORY_INIT,
        FAXLOG_LEVEL_MAX,
        0,
        MSG_SERVICE_STARTED
        );

    //
    // Get RPC going
    //
    Rval = StartFaxRpcServer( FAX_RPC_ENDPOINTW, fax_ServerIfHandle );
    if (Rval != 0 )
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartFaxRpcServer() failed (ec: %ld)"),
            Rval);
        goto Error;
    }

    //
    // Create a thread to wait for all RPC calls to terminate.
    // This thread Performs the wait operation associated with RpcServerListen only, NOT the listening.
    //
    g_hRPCListeningThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) FaxRPCListeningThread,
        NULL,
        0,
        &ThreadId);
    if (!g_hRPCListeningThread)
    {
        DebugPrintEx(   DEBUG_ERR,
                        _T("Failed to create FaxRPCListeningThread (CreateThread)(ec: %ld)."),
                        Rval = GetLastError());
        goto Error;
    }
    return ERROR_SUCCESS;

Error:
        //
        // the fax server did not initialize correctly
        //
        Assert (ERROR_SUCCESS != Rval);
        if (TRUE == bLogEvent)
        {
            USES_DWORD_2_STR;
            FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MIN,
                    1,
                    MSG_SERVICE_INIT_FAILED_INTERNAL,
                    DWORD2DECIMAL(Rval)
                  );
        }
        return Rval;
}


BOOL
NotifyServiceThreadsToTerminate(
    VOID
    )
/*++

Routine name : NotifyServiceThreadsToTerminate

Routine description:

    Notifies all service threads that do not wait on g_hServiceShutDownEvent, that the service is going down.

Author:

    Oded Sacher (OdedS),    Dec, 2000

Arguments:

    VOID            [ ]

Return Value:

    BOOL

--*/
{
    BOOL rVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("NotifyServiceThreadsToTerminate"));

    //
    // Notify FaxEventThread
    //
    if (NULL != g_hEventsCompPort)
    {
        if (!PostQueuedCompletionStatus( g_hEventsCompPort,
                                         0,
                                         SERVICE_SHUT_DOWN_KEY,
                                         (LPOVERLAPPED) NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - g_hEventsCompPort). (ec: %ld)"),
                GetLastError());
            rVal = FALSE;
        }
    }

    //
    // Notify CNotificationMap::ExtNotificationThread
    //
    if (NULL != g_pNotificationMap->m_hCompletionPort)
    {
        if (!PostQueuedCompletionStatus( g_pNotificationMap->m_hCompletionPort,
                                         0,
                                         SERVICE_SHUT_DOWN_KEY,
                                         (LPOVERLAPPED) NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - ExtNotificationThread). (ec: %ld)"),
                GetLastError());
            rVal = FALSE;
        }
    }

    //
    // Notify FaxStatusThread
    //
    if (NULL != g_StatusCompletionPortHandle)
    {
        if (!PostQueuedCompletionStatus( g_StatusCompletionPortHandle,
                                         0,
                                         SERVICE_SHUT_DOWN_KEY,
                                         (LPOVERLAPPED) NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - FaxStatusThread). (ec: %ld)"),
                GetLastError());
            rVal = FALSE;
        }
    }

    //
    // Notify TapiWorkerThread
    //
    if (NULL != g_TapiCompletionPort)
    {
        if (!PostQueuedCompletionStatus( g_TapiCompletionPort,
                                         0,
                                         SERVICE_SHUT_DOWN_KEY,
                                         (LPOVERLAPPED) NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY - TapiWorkerThread). (ec: %ld)"),
                GetLastError());
            rVal = FALSE;
        }
    }

    return rVal;
}



BOOL
StopFaxServiceProviders(
    VOID
    )
{
    DWORD ThreadId;
    DWORD dwExitCode;
    INT iTotalDelay = 0;
    BOOL bRet = TRUE;
    HANDLE hThread;
    DWORD Rval;
    DEBUG_FUNCTION_NAME(TEXT("StopFaxServiceProviders"));

    //
    // Call FaxDevShutDown() for all loaded EFSPs
    //
    hThread = CreateThread( NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) ShutdownDeviceProviders,
                            NULL,
                            0,
                            &ThreadId
                            );
    if (NULL == hThread)
    {
        DebugPrintEx(   DEBUG_ERR,
                        _T("Failed to create ShutdownDeviceProviders (ec: %ld)."),
                        GetLastError());
        bRet = FALSE;
    }
    else
    {
        //
        // Wait for FaxDevShutDown to terminate
        //
        ReportServiceStatus( SERVICE_STOP_PENDING, 0, 2*PROGRESS_RESOLUTION );
        iTotalDelay = 0;
        do
        {
            Rval = WaitForSingleObject(hThread, PROGRESS_RESOLUTION);
            if (Rval == WAIT_OBJECT_0)
            {
                bRet = GetExitCodeThread(hThread, &dwExitCode);
                if (!bRet)
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    _T("GetExitCodeThread Failed (ec: %ld)."),
                                    GetLastError());
                    bRet = FALSE;
                    break;
                }
                // ShutdownDeviceProviders finished successfully
                break;
            }
            else if (Rval == WAIT_TIMEOUT)
            {
                iTotalDelay += PROGRESS_RESOLUTION;
                if (iTotalDelay>(STARTUP_SHUTDOWN_TIMEOUT*g_iTotalFsp))
                {
                    DebugPrintEx(DEBUG_ERR,_T("Failed to Shutdown"));
                    ReportServiceStatus( SERVICE_STOP_PENDING, 0, 2*PROGRESS_RESOLUTION );
                    SetLastError(WAIT_TIMEOUT);
                    bRet = FALSE;
                    break;
                }
                DebugPrintEx(DEBUG_MSG,_T("Waiting for Shutdown %d sec"),iTotalDelay/1000);
                ReportServiceStatus( SERVICE_STOP_PENDING, 0, 3*PROGRESS_RESOLUTION );
            }
            else
            {
                // WAIT_FAILED
                DebugPrintEx(   DEBUG_ERR,
                                _T("WaitForSingleObject Failed (ec: %ld)."),
                                GetLastError());
                bRet = FALSE;
                break;
            }
        }
        while (Rval == WAIT_TIMEOUT);
        CloseHandle(hThread);
    }

    return bRet;
}




void
EndFaxSvc(
    DWORD SeverityLevel
    )
/*++

Routine Description:

    End the fax service.

Arguments:

    SeverityLevel - Event log severity level.

Return Value:

    None.

--*/
{
    DWORD Rval;

    DEBUG_FUNCTION_NAME(TEXT("EndFaxSvc"));
    Assert (TRUE == g_bServiceIsDown);
    Assert (g_hThreadCountEvent);

    //
    // let our legacy RPC clients know we're ending
    //
    if( !CreateFaxEvent(0,FEI_FAXSVC_ENDED,0xFFFFFFFF) )
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateFaxEvent failed. (ec: %ld)"),
            GetLastError());
    }

    //
    // Stop the service RPC server
    //
    Rval = StopFaxRpcServer();
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StopFaxRpcServer failed. (ec: %ld)"),
            Rval);
    }

    //
    // Notify all service threads that we go down
    //
    if (!NotifyServiceThreadsToTerminate())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Atleast one thread did not get the shut down event, NotifyServiceThreadsToTerminate() failed"));
    }    

    //
    // Tell all FSP's to shut down. This call is blocking! It reprts STOP_PENDING to SCM!
    //
    if (!StopFaxServiceProviders())
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("StopFaxServiceProviders failed (ec: %ld)"),
            GetLastError());
    }

    //
    // Wait for all threads to terminate
    //

    //
    // Check if threads count mecahnism isinitialized
    //
    if (NULL != g_hThreadCountEvent)
        {
        ReportServiceStatus( SERVICE_STOP_PENDING, 0, 2*PROGRESS_RESOLUTION );
        do
        {
            Rval = WaitForSingleObject(g_hThreadCountEvent, PROGRESS_RESOLUTION);
            if (WAIT_FAILED == Rval)
            {
                DebugPrintEx(DEBUG_ERR,_T("WaitForSingleObject (g_hThreadCountEvent) retuned  (ec: %ld)"), GetLastError());
            }
            else if (WAIT_TIMEOUT == Rval)
            {
                DebugPrintEx(DEBUG_MSG,_T("Waiting for all threads to terminate (g_hThreadCountEvent)..."));
            }
            ReportServiceStatus( SERVICE_STOP_PENDING, 0, 3*PROGRESS_RESOLUTION );
        }
        while (Rval == WAIT_TIMEOUT);

        ReportServiceStatus( SERVICE_STOP_PENDING, 0, 6*MILLISECONDS_PER_SECOND );

        //
        // EndFacSvc() waits on g_hThreadCountEvent before returning to FaxServiceMain() that calls FreeServiceGlobals().
        // g_hThreadCountEvent is set inside critical section g_CsServiceThreads only when the service thread count is 0, yet when the event is set,
        // the last thread that set it, is still alive, and is calling LeaveCriritcalSection(g_CsServiceThreads).
        // We must block FreeServiceGlobals() from deleting g_CsServiceThreads, untill the last thread is out of the
        // g_CsServiceThreads critical section.
        //
        EnterCriticalSection (&g_CsServiceThreads);
        //
        // Now we are sure that the last thread is out of g_CsServiceThreads critical section,
        // so we can proceed and delete it.
        //
        LeaveCriticalSection (&g_CsServiceThreads);
    }

    //
    // Free extensions (FSPs and Routing extensions)
    //
    UnloadDeviceProviders();
    FreeRoutingExtensions();

    //
    // Free service global lists
    //
    FreeServiceContextHandles();
    FreeTapiLines();

    //
    // Free the service queue
    //
    FreeServiceQueue();

    FaxLog(
        FAXLOG_CATEGORY_INIT,
        SeverityLevel,
        0,
        MSG_SERVICE_STOPPED
        );

    return;
}


DWORD
FaxInitThread(
    PREG_FAX_SERVICE FaxReg
    )
/*++

Routine Description:

    Initialize device providers, TAPI, job manager and router.
    This is done in a separate thread because NT Services should
    not block for long periods of time before setting the service status
    to SERVICE_RUNNING.  While a service is marked as START_PENDING, the SCM
    blocks all calls to StartService.  During TAPI initialization, StartService
    is called to start tapisrv and then tapisrv calls UNIMODEM that in turn
    calls StartService.

    Starts the RPC server.  This implementation listens on
    a list of protocols.  Hopefully this list is inclusive
    enough to handle RPC requests from most clients.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    ULONG i = 0;
    BOOL GoodProt = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("FaxInitThread"));

    //
    // Initialize archives quota
    //
    ec = InitializeServerQuota();
    if (ERROR_SUCCESS != ec)
    {
        USES_DWORD_2_STR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeServerQuota failed (ec: %ld)"),
            ec);

        FaxLog( FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
                DWORD2DECIMAL(ec)
              );
        goto exit;
    }

    ec = InitializeServerSecurity();
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeServerSecurity failed with %ld."),
            ec);
        goto exit;
    }

    //
    // load the device providers (generates its own event log msgs)
    //
    if (!LoadDeviceProviders( FaxReg ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("At least one provider failed to load."));
    }    

    //
    // Initialize the job manager data structures (inlcuding critical sections).
    // The job queue thread is NOT started here !!!
    // This must be called here since the rest of the initialization depends
    // on having the job queue related job structures in placed and initialized !
    //
    if (!InitializeJobManager( FaxReg ))
    {
        ec = ERROR_GEN_FAILURE;
        goto exit;
    }

    //
    // get the inbound fax router up and running (generates its own event log messages)
    //
    // generates event log for any failed routing module.

    if (!InitializeRouting( FaxReg ))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeRouting() failed (ec: %ld)."),
            ec);
        goto exit;
    }

    //
    // initialize TAPI devices (Note that it sets g_dwDeviceCount to the number of valid TAPI devices)
    //
    ec = TapiInitialize( FaxReg );
    if (ec)
    {
        //
        // Note: If ec is not 0 it can be a WINERROR or TAPI ERROR value.
        //+ g_ServerActivity    {...}
        USES_DWORD_2_STR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("TapiInitialize() failed (ec: %ld)"),
            ec);
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_TAPI,
                DWORD2DECIMAL(ec)
               );
        goto exit;
    }

    //
    // Create the Legacy Virtual Devices. They must be created before the providers are initialized
    // (backword compatability).
    //
    g_dwDeviceCount += CreateVirtualDevices( FaxReg,FSPI_API_VERSION_1 );

    //
    // initialize the device providers [Note: we now initialize the providers before enumerating devices]
    // The Legacy FSPI did not specify when FaxDevVirtualDeviceCreation() will be called so we can
    // "safely" change that.
    //

    if (!InitializeDeviceProviders())
    {
        DWORD dwProviders;
        dwProviders=GetSuccessfullyLoadedProvidersCount();
        if (0 == dwProviders)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("No device provider was initialized."));

                FaxLog(
                        FAXLOG_CATEGORY_INIT,
                        FAXLOG_LEVEL_MED,
                        0,
                        MSG_NO_FSP_INITIALIZED
                       );

        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("At least one provider failed failed to initialize."),
                ec);
            //
            // Event log for each failed provider issued by InitializeDeviceProviders().
            //
        }
    }

    //
    // Create the Extended virtual devices (they must be created after the providers are initialized).
    //
    // Event log entries are generated by the function itself.
    //
    g_dwDeviceCount += CreateVirtualDevices( FaxReg,FSPI_API_VERSION_2 );

    if (g_dwDeviceCount == 0)
    {
        //
        // No TAPI devices and no virtual devices.
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("No devices (TAPI + Virtual) found. exiting !!!."));

        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MED,
            0,
            MSG_NO_FAX_DEVICES
            );
    }

    //
    // Update the manual answer device
    //
    UpdateManualAnswerDevice();

    //
    // Make sure we do not exceed device limit
    //
    ec = UpdateDevicesFlags();
    if (ERROR_SUCCESS != ec)
    {
        USES_DWORD_2_STR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("UpdateDevicesFlags() failed (ec: %ld)"),
            ec);
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
                DWORD2DECIMAL(ec)
               );
        goto exit;
    }

    UpdateVirtualDevices();
    //
    // Count number of devices that are receive-enabled
    //
    UpdateReceiveEnabledDevicesCount ();

    //
    // Get Outbound routing groups configuration
    //
    ec = g_pGroupsMap->Load();
    if (ERROR_SUCCESS != ec)
    {
        USES_DWORD_2_STR;

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::Load() failed (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_OUTBOUND_ROUTING_CONFIGURATION,
            DWORD2DECIMAL(ec)
            );
        goto exit;
    }

    if (!g_pGroupsMap->UpdateAllDevicesGroup())
    {
        USES_DWORD_2_STR;

        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::UpdateAllDevicesGroup() failed (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_OUTBOUND_ROUTING_CONFIGURATION,
            DWORD2DECIMAL(ec)
            );
        goto exit;
    }

#if DBG
    g_pGroupsMap->Dump();
#endif

    //
    // Get Outbound routing rules configuration
    //
    ec = g_pRulesMap->Load();
    if (ERROR_SUCCESS != ec)
    {
        USES_DWORD_2_STR;

        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::Load() failed (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_OUTBOUND_ROUTING_CONFIGURATION,
            DWORD2DECIMAL(ec)
            );
        goto exit;
    }

    if (!g_pRulesMap->CreateDefaultRule())
    {
        USES_DWORD_2_STR;

         ec = GetLastError();
         DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::CreateDefaultRule() failed (ec: %ld)"),
            ec);
         FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_BAD_OUTBOUND_ROUTING_CONFIGURATION,
            DWORD2DECIMAL(ec)
            );
         goto exit;
    }

#if DBG
    g_pRulesMap->Dump();
#endif

    //
    // Create the JobQueueThread resources
    //
    g_hQueueTimer = CreateWaitableTimer( NULL, FALSE, NULL );
    if (NULL == g_hQueueTimer)
    {
        USES_DWORD_2_STR;
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateWaitableTimer() failed (ec: %ld)"),
            ec);

        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
            DWORD2DECIMAL(ec)
        );
        goto exit;
    }

    g_hJobQueueEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (NULL == g_hJobQueueEvent)
    {
        USES_DWORD_2_STR;
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateEvent() failed (ec: %ld)"),
            ec);

        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
            DWORD2DECIMAL(ec)
        );
        goto exit;
    }

    if (!CreateStatusThreads())
    {
        USES_DWORD_2_STR;
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create status threads (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
            DWORD2DECIMAL(ec)
        );
        goto exit;
    }

    if (!CreateTapiThread())
    {
        USES_DWORD_2_STR;
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create tapi thread (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
            DWORD2DECIMAL(ec)
           );
        goto exit;
    }

    if (!CreateJobQueueThread())
    {
        USES_DWORD_2_STR;
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create job queue thread (ec: %ld)"),
            ec);
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MIN,
            1,
            MSG_SERVICE_INIT_FAILED_SYS_RESOURCE,
            DWORD2DECIMAL(ec)
        );
        goto exit;
    }
    //
    // free the registry data
    //
    FreeFaxRegistry( FaxReg ); // It used to be a thread so it frees the input parameter itself

exit:
    return ec;
}   // FaxInitThread


DWORD WINAPI FaxRPCListeningThread(
    LPVOID pvUnused
    )
/*++

Routine Description:

    Performs the wait operation associated with RpcServerListen

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    DEBUG_FUNCTION_NAME(TEXT("FaxRPCListeningThread"));

    RpcStatus = RpcMgmtWaitServerListen();
    if (RPC_S_OK != RpcStatus)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcMgmtStopServerListening failed. (ec: %ld)"),
                RpcStatus);
    }
    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\security.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This module provides security for the service.

Author:

    Oded Sacher (OdedS) 13-Feb-2000


Revision History:

--*/

#include "faxsvc.h"
#include <aclapi.h>
#define ATLASSERT Assert
#include <smartptr.h>
#pragma hdrstop

//
// defined in ntrtl.h.
// do this to avoid dragging in ntrtl.h since we already include some stuff
// from ntrtl.h
//
extern "C"
NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );

//
// Global Fax Service Security Descriptor
//
PSECURITY_DESCRIPTOR   g_pFaxSD;

CFaxCriticalSection g_CsSecurity;

const GENERIC_MAPPING gc_FaxGenericMapping =
{
        (STANDARD_RIGHTS_READ | FAX_GENERIC_READ),
        (STANDARD_RIGHTS_WRITE | FAX_GENERIC_WRITE),
        (STANDARD_RIGHTS_EXECUTE | FAX_GENERIC_EXECUTE),
        (READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | FAX_GENERIC_ALL)
};


DWORD
InitializeSids(
    PSID*  ppSidWorld,
    PSID*  ppSidAliasAdmins,
    PSID*  ppSidInteractiveUsers
    )

/*++

Routine Description:

    This function initializes the global SIDs used by this module. The caller should call LocalFree to free the sids

Arguments:

    ppSidWorld
    ppSidAliasAdmins
    ppSidInteractiveUsers -   can be NULL ( in fact, it is present only when running on Desktop SKU )

Return Value:

    Win32 error indicating outcome.

--*/

{
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority         = SECURITY_NT_AUTHORITY;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("InitializeSids"));

    Assert (ppSidWorld && ppSidAliasAdmins);

    //
    // Allocate and initialize the world  SID
    //
    if (!AllocateAndInitializeSid( &WorldSidAuthority,
                                   1,
                                   SECURITY_WORLD_RID,
                                   0,0,0,0,0,0,0,
                                   ppSidWorld
                                  ))
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AllocateAndInitializeSid failed with (%ld)"),
            dwRes);
        goto exit;
    }

    //
    // Allocate and initialize the local admins SID
    //
    if (!AllocateAndInitializeSid( &NtAuthority,
                                   2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0,0,0,0,0,0,
                                   ppSidAliasAdmins
                                  ))
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AllocateAndInitializeSid failed with (%ld)"),
            dwRes);
        LocalFree (*ppSidWorld);
        goto exit;
    }

    //
    // Allocate and initialize the Interactive Users SID
    //
    if (ppSidInteractiveUsers)
    {
        if (!AllocateAndInitializeSid( &NtAuthority,
                                       1,
                                       SECURITY_INTERACTIVE_RID,
                                       0,0,0,0,0,0,0,
                                       ppSidInteractiveUsers
                                      ))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("AllocateAndInitializeSid failed with (%ld)"),
                dwRes);
            LocalFree (*ppSidWorld);
            LocalFree (*ppSidAliasAdmins);
            goto exit;
        }
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        *ppSidWorld = *ppSidAliasAdmins = NULL;
    }
    return dwRes;
}


DWORD
FaxSvcAccessCheck(
    IN  ACCESS_MASK DesiredAccess,
    OUT BOOL*      lpbAccessStatus,
    OUT LPDWORD    lpdwGrantedAccess
    )
/*++

Routine name : FaxSvcAccessCheck

Routine description:

    Performs an access check against the fax service security descriptor

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    DesiredAccess           [in    ] - Desired access
    lpbAccessStatus         [out   ] - Address of a BOOL to receive the access check result (TRUE is access allowed)
    lpdwGrantedAccess       [out   ] - Optional., Address of a DWORD to receive the maximum access allowed. Desired Access should be MAXIMUM_ALLOWED

Return Value:

    Standard Win32 error code

--*/
{
    DWORD rc;
    DWORD GrantedAccess;
    DWORD dwRes;
    BOOL fGenerateOnClose;
    DEBUG_FUNCTION_NAME(TEXT("FaxSvcAccessCheck"));

    Assert (lpbAccessStatus);

    //
    // Impersonate the client.
    //
    if ((rc = RpcImpersonateClient(NULL)) != RPC_S_OK)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcImpersonateClient() failed. (ec: %ld)"),
            rc);
        goto exit;
    }

    EnterCriticalSection( &g_CsSecurity );
    //
    // purify the access mask - get rid of generic access bits
    //
    MapGenericMask( &DesiredAccess, const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping) );

    //
    // Check if the client has the required access.
    //
    if (!AccessCheckAndAuditAlarm(
        FAX_SERVICE_NAME,                                       // subsystem name
        NULL,                                                   // handle to object
        NULL,                                                   // type of object
        NULL,                                                   // name of object
        g_pFaxSD,                                               // SD
        DesiredAccess,                                          // requested access rights
        const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping),    // mapping
        FALSE,                                                  // creation status
        &GrantedAccess,                                         // granted access rights
        lpbAccessStatus,                                        // result of access check
        &fGenerateOnClose                                       // audit generation option
        ))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AccessCheck() failed. (ec: %ld)"),
            rc);
        LeaveCriticalSection( &g_CsSecurity );
        goto exit;
    }

    if (lpdwGrantedAccess)
    {
        *lpdwGrantedAccess = GrantedAccess;
    }

    //
    // Always allow to submit lower priority faxes
    //

    //
    // Add lower priority access
    //
    if (NULL != lpdwGrantedAccess)
    {
        if (FAX_ACCESS_SUBMIT_HIGH == (*lpdwGrantedAccess & FAX_ACCESS_SUBMIT_HIGH))
        {
            if (MAXIMUM_ALLOWED == DesiredAccess ||
                FAX_ACCESS_SUBMIT_NORMAL == (DesiredAccess & FAX_ACCESS_SUBMIT_NORMAL))
            {
                *lpdwGrantedAccess |= FAX_ACCESS_SUBMIT_NORMAL;
            }
        }

        if (FAX_ACCESS_SUBMIT_NORMAL == (*lpdwGrantedAccess & FAX_ACCESS_SUBMIT_NORMAL))
        {
            if (MAXIMUM_ALLOWED == DesiredAccess ||
                FAX_ACCESS_SUBMIT == (DesiredAccess & FAX_ACCESS_SUBMIT))
            {
                *lpdwGrantedAccess |= FAX_ACCESS_SUBMIT;
            }
        }
    }

    //
    // Change the access check result if we failed on submit (low or normal), but we have higher submit rights
    //
    if (FALSE == *lpbAccessStatus)
    {
        DWORD dwFailedAccess;
        DWORD dwGrantedAccess;
        BOOL fAccess;

        if (!AccessCheckAndAuditAlarm(
            FAX_SERVICE_NAME,                                       // subsystem name
            NULL,                                                   // handle to object
            NULL,                                                   // type of object
            NULL,                                                   // name of object
            g_pFaxSD,                                               // SD
            MAXIMUM_ALLOWED,                                        // requested access rights
            const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping),    // mapping
            FALSE,                                                  // creation status
            &dwGrantedAccess,                                       // granted access rights
            &fAccess,                                               // result of access check
            &fGenerateOnClose                                       // audit generation option
            ))
        {
            rc = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("AccessCheck() failed. (ec: %ld)"),
                rc);
            LeaveCriticalSection( &g_CsSecurity );
            goto exit;
        }

        //
        // Set dwFailedAccess to contain the bits we failed on the access check
        //
        dwFailedAccess = (DesiredAccess & ~dwGrantedAccess);
        Assert (dwFailedAccess);

        //
        // Check if we failed on submit (low or normal) access
        //
        if (0 == (dwFailedAccess & ~(FAX_ACCESS_SUBMIT | FAX_ACCESS_SUBMIT_NORMAL)))
        {
            if ((DesiredAccess & FAX_ACCESS_SUBMIT_NORMAL) &&
                (dwGrantedAccess & FAX_ACCESS_SUBMIT_HIGH))
            {
                *lpbAccessStatus = TRUE;
            }

            if ((DesiredAccess & FAX_ACCESS_SUBMIT) &&
                (dwGrantedAccess & (FAX_ACCESS_SUBMIT_HIGH | FAX_ACCESS_SUBMIT_NORMAL)))
            {
                *lpbAccessStatus = TRUE;
            }
        }
    }

    LeaveCriticalSection( &g_CsSecurity );
    Assert (ERROR_SUCCESS == rc);

exit:
    dwRes=RpcRevertToSelf();
    if (RPC_S_OK != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcRevertToSelf() failed (ec: %ld)"),
            dwRes);
        Assert(FALSE);
    }
    return rc;
}


DWORD
SaveSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD
    )
/*++

Routine name : SaveSecurityDescriptor

Routine description:

    Saves the Fax Service SD to the registry

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    pSD         [in    ] - Pointer to a SD to be saved

Return Value:

    DWORD

--*/
{
    DWORD rc = ERROR_SUCCESS;
    DWORD dwSize;
    PSECURITY_DESCRIPTOR pSDSelfRelative = NULL;
    HKEY hKey = NULL;
    DWORD Disposition;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD dwRevision;
    DEBUG_FUNCTION_NAME(TEXT("SaveSecurityDescriptor"));

    Assert (pSD);

    rc = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SECURITY,
        0,
        TEXT(""),
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rc != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegCreateKeyEx() failed (ec: %ld)"),
            rc);
        return rc;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        rc = ERROR_INVALID_SECURITY_DESCR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsValidSecurityDescriptor() failed."));
        goto exit;
    }

    //
    // Check if the security descriptor  is absolute or self relative.
    //
    if (!GetSecurityDescriptorControl( pSD, &Control, &dwRevision))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetSecurityDescriptorControl() failed (ec: %ld)"),
            rc);
        goto exit;
    }


    //
    // store the security descriptor in the registry
    //
    dwSize = GetSecurityDescriptorLength( pSD );

    if (SE_SELF_RELATIVE & Control)
    {
        pSDSelfRelative = pSD;
    }
    else
    {
        //
        // Convert the absolute SD to self relative
        //
        pSDSelfRelative = (PSECURITY_DESCRIPTOR) MemAlloc( dwSize );
        if (NULL == pSDSelfRelative)
        {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error Allocating security descriptor"));
            goto exit;
        }

        //
        // make the security descriptor self relative
        //
        if (!MakeSelfRelativeSD( pSD, pSDSelfRelative, &dwSize))
        {
            rc = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("MakeSelfRelativeSD() failed (ec: %ld)"),
                rc);
            goto exit;
        }
    }

    //
    // store the security descriptor in the registry
    //
    rc = RegSetValueEx(
        hKey,
        REGVAL_DESCRIPTOR,
        0,
        REG_BINARY,
        (LPBYTE) pSDSelfRelative,
        dwSize
        );
    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegSetValueEx() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    Assert (ERROR_SUCCESS == rc);

exit:
    RegCloseKey (hKey);
    if (!(SE_SELF_RELATIVE & Control))
    {
        MemFree (pSDSelfRelative);
    }
    return rc;
}


DWORD
CreateDefaultSecurityDescriptor(
    VOID
    )
/*++

Routine name : CreateDefaultSecurityDescriptor

Routine description:

    Creates the default security descriptor

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:
    None.


Return Value:

    Standard Win32 error code.

--*/
{

#define FAX_ACE_MAX     3

    DWORD rc = ERROR_SUCCESS;
    PSID pWorldSid = NULL;
    PSID pLocalAdminsSid = NULL;
    PSID pInteractiveUsersSid = NULL;

    DWORD dwSidSize;
    PSID pLocalAdminsSid_Owner = NULL;         // We need another copy of the global sid since we use it for the owner
    PSID pLocalAdminsSid_Group = NULL;         // We need another copy of the global sid since we use it for the group

    EXPLICIT_ACCESS ea[FAX_ACE_MAX];
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;

    PSECURITY_DESCRIPTOR pPrivateObjectSD = NULL;
    HANDLE hFaxServiceToken = NULL;

    BOOL    bDesktopSKU = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("CreateDefaultSecurityDescriptor"));

    // Create the default security descriptor
    // Local admins - Full access; World - Submit Normal
    // Initialize a security descriptor and an ACL.
    // We use a large static buffer to contain the ACL.
    //

    //
    //  If this is PERSONAL SKU, then add Interactive Users SID
    //
    bDesktopSKU = IsDesktopSKU();

    //
    // Initialize SIDs
    //
    rc = InitializeSids(&pWorldSid, &pLocalAdminsSid, ((bDesktopSKU) ? &pInteractiveUsersSid : NULL));
    if (rc != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeSids() failed (ec: %ld)"),
            rc);
        return rc;
    }

    //
    // Get a copy of the admins sid for the owner
    //
    dwSidSize = GetLengthSid( pLocalAdminsSid );
    pLocalAdminsSid_Owner = (PSID) MemAlloc(dwSidSize);
    if (pLocalAdminsSid_Owner == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate SID buffer")
            );
        rc = ERROR_OUTOFMEMORY;
        goto exit;
    }

    if (!CopySid(dwSidSize, pLocalAdminsSid_Owner, pLocalAdminsSid))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CopySid Failed, Error : %ld"),
            rc
            );
        goto exit;
    }

    //
    // Get a copy of the admins sid for the group
    //
    pLocalAdminsSid_Group = (PSID) MemAlloc(dwSidSize);
    if (pLocalAdminsSid_Group == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate SID buffer")
            );
        rc = ERROR_OUTOFMEMORY;
        goto exit;
    }

    if (!CopySid(dwSidSize, pLocalAdminsSid_Group, pLocalAdminsSid))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CopySid Failed, Error : %ld"),
            rc
            );
        goto exit;
    }

    ZeroMemory(&ea, FAX_ACE_MAX * sizeof(EXPLICIT_ACCESS));

    //
    // Local Admins EXPLICIT_ACCESS
    //
    ea[0].grfAccessPermissions = (FAX_ACCESS_SUBMIT              |
                                  FAX_ACCESS_SUBMIT_NORMAL       |
                                  FAX_ACCESS_SUBMIT_HIGH         |
                                  FAX_ACCESS_QUERY_JOBS          |
                                  FAX_ACCESS_MANAGE_JOBS         |
                                  FAX_ACCESS_QUERY_CONFIG        |
                                  FAX_ACCESS_MANAGE_CONFIG       |
                                  FAX_ACCESS_QUERY_IN_ARCHIVE    |
                                  FAX_ACCESS_MANAGE_IN_ARCHIVE   |
                                  FAX_ACCESS_QUERY_OUT_ARCHIVE   |
                                  FAX_ACCESS_MANAGE_OUT_ARCHIVE  |
                                  WRITE_OWNER                       // For W2K Compatibility
                                  );
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance= NO_INHERITANCE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[0].Trustee.ptstrName  = (LPTSTR) pLocalAdminsSid;

    //
    // World EXPLICIT_ACCESS
    //
    ea[1].grfAccessPermissions = FAX_ACCESS_SUBMIT | FAX_ACCESS_SUBMIT_NORMAL;
    ea[1].grfAccessMode = SET_ACCESS;
    ea[1].grfInheritance= NO_INHERITANCE;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[1].Trustee.ptstrName  = (LPTSTR) pWorldSid;

    //
    // if we are on the Desktop SKU, then define Local Users EXPLICIT_ACCESS
    //
    if (bDesktopSKU)
    {
        //
        // By default, in desktop SKUs, Interactive users can view (jobs / Inbox/Sent items messages / config) +
        // submit low + normal + high priority jobs + manage all queue jobs (both incoming and outgoing).
        //
        ea[2].grfAccessPermissions = (FAX_ACCESS_SUBMIT             |
                                      FAX_ACCESS_SUBMIT_NORMAL      |
                                      FAX_ACCESS_SUBMIT_HIGH        |
                                      FAX_ACCESS_QUERY_JOBS         |
                                      FAX_ACCESS_MANAGE_JOBS        |
                                      FAX_ACCESS_QUERY_CONFIG       |
                                      FAX_ACCESS_QUERY_OUT_ARCHIVE  |
                                      FAX_ACCESS_QUERY_IN_ARCHIVE);
        ea[2].grfAccessMode = SET_ACCESS;
        ea[2].grfInheritance= NO_INHERITANCE;
        ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[2].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        ea[2].Trustee.ptstrName  = (LPTSTR) pInteractiveUsersSid;
    }

    //
    // Create a new ACL that contains the new ACEs.
    //
    rc = SetEntriesInAcl( ((bDesktopSKU) ? FAX_ACE_MAX : (FAX_ACE_MAX - 1)), ea, NULL, &pACL);
    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetEntriesInAcl() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    //
    // Initialize a security descriptor.
    //
    pSD = (PSECURITY_DESCRIPTOR) MemAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pSD == NULL)
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error Allocating security descriptor"));
        goto exit;
    }

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeSecurityDescriptor() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    //
    // Add the ACL to the security descriptor.
    //
    if (!SetSecurityDescriptorDacl(pSD, TRUE, pACL, FALSE))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetSecurityDescriptorDacl() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    //
    // set the owner
    //
    if (!SetSecurityDescriptorOwner( pSD, pLocalAdminsSid_Owner, FALSE )) {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetSecurityDescriptorOwner() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    //
    // set the primary group  - use the local copy of gs_pSidAliasAdmins
    //
    if (!SetSecurityDescriptorGroup( pSD, pLocalAdminsSid_Group, FALSE ))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetSecurityDescriptorGroup() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    //
    // Get the Fax Service Token
    //
    if (!OpenProcessToken( GetCurrentProcess(), // handle to process
                           TOKEN_QUERY,         // desired access to process
                           &hFaxServiceToken    // handle to open access token
                           ))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenThreadToken failed. (ec: %ld)"),
            rc);
        goto exit;
    }

    //
    // Create a private object SD
    //
    if (!CreatePrivateObjectSecurity( NULL,                                                     // parent directory SD
                                      pSD,                                                      // creator SD
                                      &pPrivateObjectSD,                                        // new SD
                                      FALSE,                                                    // container
                                      hFaxServiceToken,                                         // handle to access token
                                      const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping)       // mapping
                                      ))
    {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreatePrivateObjectSecurity() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    //
    // store the security descriptor in the registry
    //
    rc = SaveSecurityDescriptor (pPrivateObjectSD);
    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SaveSecurityDescriptor() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    //
    // All done! Set the global fax service security descriptor
    //
    g_pFaxSD = pPrivateObjectSD;
    pPrivateObjectSD = NULL;
    Assert (ERROR_SUCCESS == rc);

exit:
    if (pACL)
    {
        LocalFree( pACL );
    }

    MemFree(pSD);
    MemFree(pLocalAdminsSid_Group);
    MemFree(pLocalAdminsSid_Owner);

    if (pWorldSid)
    {
        FreeSid(pWorldSid);
    }

    if (pLocalAdminsSid)
    {
        FreeSid(pLocalAdminsSid);
    }

    if (pInteractiveUsersSid)
    {
        FreeSid(pInteractiveUsersSid);
    }

    if (NULL != hFaxServiceToken)
    {
        if (!CloseHandle(hFaxServiceToken))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle() failed. (ec: %ld)"),
                GetLastError());
        }
    }

    if (NULL != pPrivateObjectSD)
    {
        if (!DestroyPrivateObjectSecurity (&pPrivateObjectSD))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DestroyPrivateObjectSecurity() failed. (ec: %ld)"),
                GetLastError());
        }
    }

    return rc;
}

DWORD
LoadSecurityDescriptor(
    VOID
    )
/*++

Routine name : LoadSecurityDescriptor

Routine description:

    Loads the Fax Service security descriptor from the registry

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    None

Return Value:

    Standard Win32 error code

--*/
{
    DWORD rc = ERROR_SUCCESS;
    DWORD dwSize;
    HKEY hKey = NULL;
    DWORD Disposition;
    DWORD dwType;
    PSECURITY_DESCRIPTOR pRelativeSD = NULL;
    DEBUG_FUNCTION_NAME(TEXT("LoadSecurityDescriptor"));

    rc = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SECURITY,
        0,
        TEXT(""),
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rc != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegCreateKeyEx() failed (ec: %ld)"),
            rc);
        goto exit;
    }

    rc = RegQueryValueEx(
        hKey,
        REGVAL_DESCRIPTOR,
        NULL,
        &dwType,
        NULL,
        &dwSize
        );

    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegQueryValueEx  failed with %ld"),
            rc);
        goto exit;
    }

    //
    // We opened an existing registry value
    //
    if (REG_BINARY != dwType ||
        0 == dwSize)
    {
        //
        // We expect only binary data here
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading security descriptor from the registry, not a binary type, or size is 0"));
        rc = ERROR_BADDB;    // The configuration registry database is corrupt.
        goto exit;
    }

    //
    // Allocate required buffer
    // The buffer must be allocated using HeapAlloc (GetProcessHeap()...) because this is the way CreatePrivateObjectSecurity() allocates memory
    // This is a result of a bad design of private object security APIs, see Windows Bugs #324906.
    //
    pRelativeSD = (PSECURITY_DESCRIPTOR) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize );
    if (!pRelativeSD)
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate security descriptor buffer"));
        goto exit;
    }

    //
    // Read the data
    //
    rc = RegQueryValueEx(
        hKey,
        REGVAL_DESCRIPTOR,
        NULL,
        &dwType,
        (LPBYTE)pRelativeSD,
        &dwSize
        );
    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegQueryValueEx failed with %ld"),
            rc);
        goto exit;
    }

    if (!IsValidSecurityDescriptor(pRelativeSD))
    {
        rc = ERROR_INVALID_SECURITY_DESCR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsValidSecurityDescriptor() failed."));
        goto exit;
    }

    g_pFaxSD = pRelativeSD;
    pRelativeSD = NULL;
    Assert (ERROR_SUCCESS == rc);

exit:
    if (hKey)
    {
        RegCloseKey( hKey );
    }

    if (NULL != pRelativeSD)
    {
        if (!HeapFree(GetProcessHeap(), 0, pRelativeSD))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("pRelativeSD() failed. (ec: %ld)"),
                GetLastError());
        }
    }
    return rc;
}


DWORD
InitializeServerSecurity(
    VOID
    )
/*++

Routine name : InitializeServerSecurity

Routine description:

    Initializes the Fax Service security

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    None

Return Value:

    Standard Win32 error code

--*/
{
    DWORD rc = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("InitializeServerSecurity"));

    rc = LoadSecurityDescriptor();
    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadSecurityDescriptor() failed (ec: %ld), Create default security descriptor"),
            rc);
    }
    else
    {
        //success
        return rc;
    }

    //
    // We failed to load the security descriptor
    //
    if (ERROR_NOT_ENOUGH_MEMORY == rc)
    {
        //
        // Do not let the service start
        //
        return rc;
    }

    //
    // The registry is corrupted - create the default security descriptor
    //
    rc = CreateDefaultSecurityDescriptor();
    if (ERROR_SUCCESS != rc)
    {
       DebugPrintEx(
           DEBUG_ERR,
           TEXT("CreateDefaultSecurityDescriptor() failed (ec: %ld)"),
           rc);
    }
    return rc;
}

//*********************************************************************************
//* Name:GetClientUserName()
//* Author: Ronen Barenboim
//* Date:   May 02, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Returns the OS User Name of the connected RPC client.
//* PARAMETERS:
//*         None.
//* RETURN VALUE:
//*     A pointer to a newly allocated string holding the user name.
//*     The caller must free this string using MemFree().
//*     Returns NULL if an error occures.
//*     To get extended error information, call GetLastError.
//*********************************************************************************
LPWSTR
GetClientUserName(
    VOID
    )
{
    RPC_STATUS dwRes;
    LPWSTR lpwstrUserName = NULL;
    HANDLE hToken = NULL;
    PSID pUserSid;
    LPWSTR szShortUserName[64];
    LPWSTR szShortDomainName[64];
    DWORD dwUserNameLen = sizeof(szShortUserName) / sizeof(WCHAR);
    DWORD dwDomainNameLen = sizeof(szShortDomainName) / sizeof(WCHAR);
    LPWSTR szUserName = (LPWSTR)szShortUserName;
    LPWSTR szDomainName = (LPWSTR)szShortDomainName;
    SID_NAME_USE SidNameUse;
    LPWSTR szLongUserName = NULL;
    LPWSTR szLongDomainName = NULL;

    DEBUG_FUNCTION_NAME(TEXT("GetClientUserName"));

    //
    // Impersonate the user.
    //
    dwRes=RpcImpersonateClient(NULL);

    if (dwRes != RPC_S_OK)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcImpersonateClient(NULL) failed. (ec: %ld)"),
            dwRes);
        SetLastError (dwRes);
        return NULL;
    }

    //
    // Open the thread token. We're in an RPC thread, not the main thread.
    //
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenThreadToken failed. (ec: %ld)"),
            dwRes);
        goto exit;
    }

    //
    // Get the user's SID. A 128 byte long buffer should always suffice since
    // a SID length is limited to +/- 80 bytes at most.
    //
    BYTE abTokenUser[128];
    DWORD dwReqSize;

    if (!GetTokenInformation(hToken,
                             TokenUser,
                             (LPVOID)abTokenUser,
                             sizeof(abTokenUser),
                             &dwReqSize))
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetTokenInformation failed. (ec: %ld)"),
            dwRes);
        goto exit;
    }

    //
    // Get the user name and domain.
    //
    pUserSid = ((TOKEN_USER *)abTokenUser)->User.Sid;

    if (!LookupAccountSid(NULL,
                          pUserSid,
                          szUserName,
                          &dwUserNameLen,
                          szDomainName,
                          &dwDomainNameLen,
                          &SidNameUse))
    {
        dwRes = GetLastError();

        if (dwRes == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // At least one of buffer were too small.
            //
            if (dwUserNameLen > sizeof(szShortUserName) / sizeof(WCHAR))
            {
                //
                // Allocate a buffer for the user name.
                //
                szLongUserName = new WCHAR[dwUserNameLen];
                if (!szLongUserName)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to allocate user name buffer (%d bytes)"),
                        dwUserNameLen);
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }
                szUserName = szLongUserName;
            }

            if (dwDomainNameLen > sizeof(szShortDomainName) / sizeof(WCHAR))
            {
                //
                // Allocate a buffer for the domain name.
                //
                szLongDomainName = new WCHAR[dwDomainNameLen];
                if (!szLongDomainName)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to allocate domain name buffer (%d bytes)"),
                        dwDomainNameLen);
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }
                szDomainName = szLongDomainName;
            }
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LookupAccountSid(1) failed. (ec: %ld)"),
                dwRes);
            goto exit;
        }

        //
        // Try now with larger buffers.
        //
        if (!LookupAccountSid(NULL,
                              pUserSid,
                              szUserName,
                              &dwUserNameLen,
                              szDomainName,
                              &dwDomainNameLen,
                              &SidNameUse))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LookupAccountSid(2) failed. (ec: %ld)"),
                dwRes);
            goto exit;
        }
    }

    //
    // Allocate a buffer forthe combined string - domain\user
    //
    dwUserNameLen = wcslen(szUserName);
    dwDomainNameLen = wcslen(szDomainName);
    lpwstrUserName = (LPWSTR)MemAlloc(sizeof(WCHAR) * (dwUserNameLen + dwDomainNameLen + 2));
    if (!lpwstrUserName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate user and domain name buffer (%d bytes)"),
            sizeof(WCHAR) * (dwUserNameLen + dwDomainNameLen + 2));
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // Construct the combined string
    //
    memcpy(lpwstrUserName,
           szDomainName,
           sizeof(WCHAR) * dwDomainNameLen);
    lpwstrUserName[dwDomainNameLen] = L'\\';
    memcpy(lpwstrUserName + dwDomainNameLen + 1,
           szUserName,
           sizeof(WCHAR) * (dwUserNameLen + 1));

exit:
    DWORD dwErr = RpcRevertToSelf();
    if (RPC_S_OK != dwErr)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcRevertToSelf() failed. (ec: %ld)"),
            dwRes);
        Assert(dwErr == RPC_S_OK); // Assert(FALSE)
    }

    if (NULL != szLongUserName)
    {
        delete szLongUserName;
    }

    if (NULL != szLongDomainName)
    {
        delete szLongDomainName;
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    if (dwRes != ERROR_SUCCESS)
    {
        Assert (NULL == lpwstrUserName);
        SetLastError (dwRes);
    }
    return lpwstrUserName;
}


error_status_t
FAX_SetSecurity (
    IN handle_t hFaxHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN const LPBYTE lpBuffer,
    IN DWORD dwBufferSize
)
/*++

Routine name : FAX_SetSecurity

Routine description:

    RPC implementation of FaxSetSecurity

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in] - Unused
    SecurityInformation [in] - Defines the valid entries in the security descriptor (Bit wise OR )
    lpBuffer            [in] - Pointer to new security descriptor
    dwBufferSize        [in] - Buffer size

Return Value:

    Standard RPC error codes

--*/
{
    DWORD rVal = ERROR_SUCCESS;
    DWORD rVal2;
    BOOL fAccess;
    ACCESS_MASK AccessMask = 0;
    HANDLE hClientToken = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetSecurity"));

    Assert (g_pFaxSD);
    Assert (IsValidSecurityDescriptor(g_pFaxSD));

    if (!lpBuffer || !dwBufferSize)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("'Error Null buffer"));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Must validate the RPC blob before calling IsValidSecurityDescriptor();
    //
    if (!RtlValidRelativeSecurityDescriptor( (PSECURITY_DESCRIPTOR)lpBuffer,
                                             dwBufferSize,
                                             SecurityInformation))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RtlValidRelativeSecurityDescriptor failed"));
        return ERROR_INVALID_DATA;
    }

    //
    // Access check
    //
    if (SecurityInformation & OWNER_SECURITY_INFORMATION)
    {
        AccessMask |= WRITE_OWNER;
    }

    if (SecurityInformation & (GROUP_SECURITY_INFORMATION |
                               DACL_SECURITY_INFORMATION) )
    {
        AccessMask |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION)
    {
        AccessMask |= ACCESS_SYSTEM_SECURITY;
    }

    //
    // Block other threads from changing the SD
    //
    EnterCriticalSection (&g_CsSecurity);

    rVal = FaxSvcAccessCheck (AccessMask, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        goto exit;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the needed rights to change the security descriptor"));
        rVal = ERROR_ACCESS_DENIED;
        goto exit;
    }

    //
    // Get the calling client access token
    //
    // Impersonate the user.
    //
    rVal = RpcImpersonateClient(NULL);
    if (rVal != RPC_S_OK)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcImpersonateClient(NULL) failed. (ec: %ld)"),
            rVal);
        goto exit;
    }

    //
    // Open the thread token. We're in an RPC thread, not the main thread.
    //
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hClientToken))
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenThreadToken failed. (ec: %ld)"),
            rVal);

        DWORD dwErr = RpcRevertToSelf();
        if (RPC_S_OK != dwErr)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcRevertToSelf() failed. (ec: %ld)"),
                dwErr);
        }
        goto exit;
    }

    //
    // The calling process (SetPrivateObjectSecurity()) must not impersonate the client
    //
    rVal = RpcRevertToSelf();
    if (RPC_S_OK != rVal)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcRevertToSelf() failed. (ec: %ld)"),
            rVal);
        goto exit;
    }

    //
    // Get a new (Mereged) Fax service private object SD
    //
    if (!SetPrivateObjectSecurity ( SecurityInformation,
                                    (PSECURITY_DESCRIPTOR)lpBuffer,
                                    &g_pFaxSD,
                                    const_cast<PGENERIC_MAPPING>(&gc_FaxGenericMapping),
                                    hClientToken))
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetPrivateObjectSecurity failed. (ec: %ld)"),
            rVal);
        goto exit;
    }
    Assert (IsValidSecurityDescriptor(g_pFaxSD));

    //
    // Save the new SD
    //
    rVal = SaveSecurityDescriptor(g_pFaxSD);
    if (rVal != ERROR_SUCCESS)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error in SaveSecurityDescriptor (%ld)"),
            rVal);
        rVal = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    rVal2 = CreateConfigEvent (FAX_CONFIG_TYPE_SECURITY);
    if (ERROR_SUCCESS != rVal2)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_SECURITY) (ec: %lc)"),
            rVal2);
    }

    Assert (ERROR_SUCCESS == rVal);

exit:
    LeaveCriticalSection (&g_CsSecurity);
    if (NULL != hClientToken)
    {
        if (!CloseHandle(hClientToken))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle() failed. (ec: %ld)"),
                GetLastError());
        }
    }
    return GetServerErrorCode(rVal);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetSecurity


error_status_t
FAX_GetSecurityEx(
    IN  handle_t hFaxHandle,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPBYTE  *lpBuffer,
    OUT LPDWORD  lpdwBufferSize
    )
/*++

Routine Description:

    Retrieves the FAX security descriptor from the FAX server.

Arguments:

    hFaxHandle      - FAX handle obtained from FaxConnectFaxServer.
    SecurityInformation  - Defines the desired entries in the security descriptor (Bit wise OR )
    lpBuffer        - Pointer to a SECURITY_DESCRIPTOR structure.
    lpdwBufferSize  - Size of lpBuffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    DWORD dwDescLength = 0;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetSecurityEx"));
    BOOL fAccess;
    ACCESS_MASK AccessMask = 0;
    PSECURITY_DESCRIPTOR pSDPrivateObject = NULL;

    Assert (g_pFaxSD);
    Assert (IsValidSecurityDescriptor(g_pFaxSD));

    Assert (lpdwBufferSize);    // ref pointer in idl
    if (!lpBuffer)              // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpBuffer = NULL;
    *lpdwBufferSize = 0;

    //
    // Block other threads from changing the SD
    //
    EnterCriticalSection (&g_CsSecurity);

    //
    // Access check
    //
    if (SecurityInformation & (GROUP_SECURITY_INFORMATION |
                               DACL_SECURITY_INFORMATION  |
                               OWNER_SECURITY_INFORMATION) )
    {
        AccessMask |= READ_CONTROL;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION)
    {
        AccessMask |= ACCESS_SYSTEM_SECURITY;
    }

    rVal = FaxSvcAccessCheck (AccessMask, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        goto exit;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the READ_CONTROL or ACCESS_SYSTEM_SECURITY"));
        rVal = ERROR_ACCESS_DENIED;;
        goto exit;
    }

    if (!IsValidSecurityDescriptor( g_pFaxSD ))
    {
        rVal = ERROR_INVALID_SECURITY_DESCR;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("IsValidSecurityDescriptor() failed. Got invalid SD"));
        ASSERT_FALSE;
        goto exit;
    }

    //
    // Get the required buffer size
    //
    GetPrivateObjectSecurity( g_pFaxSD,                                    // SD
                              SecurityInformation,                         // requested info type
                              NULL,                                        // requested SD info
                              0,                                           // size of SD buffer
                              &dwDescLength                                // required buffer size
                              );

    //
    // Allocate returned security descriptor buffer
    //
    Assert(dwDescLength);
    *lpBuffer = (LPBYTE)MemAlloc(dwDescLength);
    if (NULL == *lpBuffer)
    {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate SD"));
        goto exit;
    }

    if (!GetPrivateObjectSecurity( g_pFaxSD,                                    // SD
                                   SecurityInformation,                         // requested info type
                                   (PSECURITY_DESCRIPTOR)*lpBuffer,             // requested SD info
                                   dwDescLength,                                // size of SD buffer
                                   &dwDescLength                                // required buffer size
                                   ))
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetPrivateObjectSecurity() failed. (ec: %ld)"),
            rVal);
        goto exit;
    }

    *lpdwBufferSize = dwDescLength;
    Assert (ERROR_SUCCESS == rVal);

exit:
    LeaveCriticalSection (&g_CsSecurity);
    if (ERROR_SUCCESS != rVal)
    {
        MemFree (*lpBuffer);
        *lpBuffer = NULL;
        *lpdwBufferSize = 0;
    }
    return GetServerErrorCode(rVal);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetSecurityEx

error_status_t
FAX_GetSecurity(
    IN  handle_t hFaxHandle,
    OUT LPBYTE  *lpBuffer,
    OUT LPDWORD  lpdwBufferSize
    )
/*++

Routine Description:

    Retrieves the FAX security descriptor from the FAX server.

Arguments:

    hFaxHandle      - FAX handle obtained from FaxConnectFaxServer.
    lpBuffer        - Pointer to a SECURITY_DESCRIPTOR structure.
    lpdwBufferSize  - Size of lpBuffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetSecurity"));

    rVal = FAX_GetSecurityEx (hFaxHandle,
                              DACL_SECURITY_INFORMATION      |   // Read DACL
                              GROUP_SECURITY_INFORMATION     |   // Read group
                              OWNER_SECURITY_INFORMATION     |   // Read owner
                              SACL_SECURITY_INFORMATION,         // Read SACL
                              lpBuffer,
                              lpdwBufferSize);
    if (ERROR_ACCESS_DENIED == rVal)
    {
        //
        // Let's try without the SACL
        //
        rVal = FAX_GetSecurityEx (hFaxHandle,
                                  DACL_SECURITY_INFORMATION      |   // Read DACL
                                  GROUP_SECURITY_INFORMATION     |   // Read group
                                  OWNER_SECURITY_INFORMATION,        // Read owner
                                  lpBuffer,
                                  lpdwBufferSize);
    }
    return rVal;
}   // FAX_GetSecurity



error_status_t
FAX_AccessCheck(
   IN handle_t  hBinding,
   IN DWORD     dwAccessMask,
   OUT BOOL*    pfAccess,
   OUT LPDWORD  lpdwRights
   )
/*++

Routine name : FAX_AccessCheck

Routine description:

    Performs an access check against the fax service security descriptor

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    hBinding        [in ] - Handle to the Fax Server obtained from FaxConnectFaxServer()
    dwAccessMask    [in ] - Desired access
    pfAccess        [out] - Address of a BOOL to receive the access check return value (TRUE - access allowed).
    lpdwRights      [out] - Optional, Address of a DWORD to receive the access rights bit wise OR.
                            To get the access rights, set dwAccessMask to MAXIMUM_ALLOWED

Return Value:

    Standard Win32 error code.

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_AccessCheck"));

    if (!pfAccess)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("fAccess is NULL "));
        return ERROR_INVALID_PARAMETER;
    }

    Rval = FaxSvcAccessCheck (dwAccessMask, pfAccess, lpdwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxSvcAccessCheck failed with error (%ld)"),
            Rval);
    }
    return GetServerErrorCode(Rval);
} // FAX_AccessCheck


//*********************************************************************************
//* Name:GetClientUserSID()
//* Author: Oded Sacher
//* Date:   Oct 26, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Returns the  SID of the connected RPC client.
//* PARAMETERS:
//*         None.
//* RETURN VALUE:
//*     A pointer to a newly allocated SID buffer.
//*     The caller must free this buffer using MemFree().
//*     Returns NULL if an error occures.
//*     To get extended error information, call GetLastError.
//*********************************************************************************
PSID
GetClientUserSID(
    VOID
    )
{
    RPC_STATUS dwRes;
    PSID pUserSid;
    DEBUG_FUNCTION_NAME(TEXT("GetClientUserSID"));
    //
    // Impersonate the user.
    //
    dwRes=RpcImpersonateClient(NULL);

    if (dwRes != RPC_S_OK)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcImpersonateClient(NULL) failed. (ec: %ld)"),
            dwRes);
        SetLastError( dwRes);
        return NULL;
    }
    //
    // Get SID of (impersonated) thread
    //
    pUserSid = GetCurrentThreadSID ();
    if (!pUserSid)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetCurrentThreadSID failed. (ec: %ld)"),
            dwRes);
    }
    dwRes = RpcRevertToSelf();
    if (RPC_S_OK != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcRevertToSelf() failed. (ec: %ld)"),
            dwRes);
        ASSERT_FALSE;
        //
        // Free SID (if exists)
        MemFree (pUserSid);
        SetLastError (dwRes);
        return NULL;
    }
    return pUserSid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\tapicountry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiCountry.h

Abstract:

    Utility functions for working with TAPI

Environment:
	Server

Revision History:

        09/18/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _TAPICOUNTRY_H_
#define _TAPICOUNTRY_H_


#include <tapi.h>
#include <shellapi.h>


//
// Init a list of countries
//

BOOL
GetCountries(
    VOID
    );

//
// Get a list of locations from TAPI
//

LPLINETRANSLATECAPS
GetTapiLocationInfo(
    );

//
// Change the default TAPI location
//

BOOL
SetCurrentLocation(
    DWORD   locationID
    );

//
// Return the list of country
//


LPLINECOUNTRYLIST	
GetCountryList(
			   );

#endif  // !_TAPICOUNTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\tapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapi.c

Abstract:

    This module wraps all of the TAPI calls.

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop
#include <set>
#include <vector>
using namespace std;
#include "tapiCountry.h"


//
// globals
//
HLINEAPP            g_hLineApp;                     // application line handle
HANDLE              g_TapiCompletionPort;           //

CFaxCriticalSection    g_CsLine;                         // critical section for accessing tapi lines
DWORD               g_dwDeviceCount;                    // number of devices in the g_TapiLinesListHead
LIST_ENTRY          g_TapiLinesListHead;              // linked list of tapi lines
LIST_ENTRY          g_RemovedTapiLinesListHead;       // linked list of removed tapi lines
LPBYTE              g_pAdaptiveFileBuffer;             // list of approved adaptive answer modems

DWORD               g_dwManualAnswerDeviceId;       // Id of (one and only) device capable of manual answering (protected by g_CsLine)

DWORD               g_dwDeviceEnabledLimit;       // Total number of devices
DWORD               g_dwDeviceEnabledCount;       // Device limt by SKU



static BOOL ValidateFSPIDevices(const FSPI_DEVICE_INFO * lpcDevices,
                                DWORD dwDeviceCount,
                                DWORD dwDevicesPrefix);

static BOOL LoadAdaptiveFileBuffer();

static BOOL IsExtendedVirtualLine (PLINE_INFO lpLineInfo);

static BOOL CreateLegacyVirtualDevices(
    PREG_FAX_SERVICE FaxReg,
    const REG_SETUP * lpRegSetup,
    DEVICE_PROVIDER * lpcProvider,
    LPDWORD lpdwDeviceCount);

static BOOL CreateExtendedVirtualDevices(
    PREG_FAX_SERVICE FaxReg,
    const REG_SETUP * lpRegSetup,
    const DEVICE_PROVIDER * lpcProvider,
    LPDWORD lpdwDeviceCount);

DWORD g_dwMaxLineCloseTime;   // Wait interval in sec before trying to resend a powered off device

BOOL
AddNewDevice(
    DWORD DeviceId,
    LPLINEDEVCAPS LineDevCaps,
    BOOL fServerInitialization,
    PREG_FAX_DEVICES    pInputFaxReg
    );

DWORD
InitializeTapiLine(
    DWORD DeviceId,
    DWORD dwUniqueLineId,
    LPLINEDEVCAPS LineDevCaps,
    DWORD Rings,
    DWORD Flags,
    LPTSTR Csid,
    LPTSTR Tsid,
    LPTSTR lptstrDescription,
    BOOL fCheckDeviceLimit,
    DWORD dwDeviceType
    );

BOOL
RemoveTapiDevice(
    DWORD dwTapiDeviceId
    );

void
ResetDeviceFlags(
    PLINE_INFO pLineInfo
    )
{
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("ResetDeviceFlags"));

    Assert (pLineInfo);
    pLineInfo->Flags = (pLineInfo->Flags & FPF_VIRTUAL) ? FPF_VIRTUAL : 0; // send/receive disabled
    dwRes = RegSetFaxDeviceFlags( pLineInfo->PermanentLineID,
                                  pLineInfo->Flags);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegSetFaxDeviceFlags() (ec: %ld)"),
            dwRes);
    }

    if (pLineInfo->PermanentLineID == g_dwManualAnswerDeviceId)
    {
        g_dwManualAnswerDeviceId = 0;  // Disable manual receive
        dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                dwRes);
        }
    }
}

LPTSTR
FixupDeviceName(
    LPTSTR OrigDeviceName
    )
{
    LPTSTR NewDeviceName;
    LPTSTR p;


    NewDeviceName = StringDup( OrigDeviceName );
    if (!NewDeviceName) {
        return NULL;
    }

    p = _tcschr( NewDeviceName, TEXT(',') );
    if (!p) {
        return NewDeviceName;
    }

    p = NewDeviceName;

    while( p ) {
        p = _tcschr( p, TEXT(',') );
        if (p) {
            *p = TEXT('_');
        }
    }

    return NewDeviceName;
}

void
FreeTapiLines(
    void
    )
{
    PLIST_ENTRY     pNext;
    PLINE_INFO      pLineInfo;

    pNext = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_TapiLinesListHead)
    {
        pLineInfo = CONTAINING_RECORD( pNext, LINE_INFO, ListEntry );
        pNext = pLineInfo->ListEntry.Flink;
        RemoveEntryList(&pLineInfo->ListEntry);
        FreeTapiLine(pLineInfo);
    }

    pNext = g_RemovedTapiLinesListHead.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_RemovedTapiLinesListHead)
    {
        pLineInfo = CONTAINING_RECORD( pNext, LINE_INFO, ListEntry );
        pNext = pLineInfo->ListEntry.Flink;
        RemoveEntryList(&pLineInfo->ListEntry);
        FreeTapiLine(pLineInfo);
    }
}


VOID
FreeTapiLine(
    PLINE_INFO LineInfo
    )
{
    HLINE hLine = NULL;


    if (!LineInfo)
    {
        return;
    }

    if (LineInfo->hLine)
    {
        hLine = LineInfo->hLine;
        LineInfo->hLine = NULL;
    }

    MemFree( LineInfo->DeviceName );
    MemFree( LineInfo->Tsid );
    MemFree( LineInfo->Csid );
    MemFree( LineInfo->lptstrDescription );

    MemFree( LineInfo );

    if (hLine)
    {
        lineClose( hLine );
    }
}



int
__cdecl
DevicePriorityCompare(
    const void *arg1,
    const void *arg2
    )
{
    if (((PDEVICE_SORT)arg1)->Priority < ((PDEVICE_SORT)arg2)->Priority) {
        return -1;
    }
    if (((PDEVICE_SORT)arg1)->Priority > ((PDEVICE_SORT)arg2)->Priority) {
        return 1;
    }
    return 0;
}

DWORD GetFaxDeviceCount(
    VOID
    )
/*++
Routine Description:

    counts the number of installed fax devices

Arguments:

    NONE.

Return Value:

    number of devices

--*/
{
    DWORD FaxDevices = 0;
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;


    __try {
        EnterCriticalSection(&g_CsLine);

        Next = g_TapiLinesListHead.Flink;

        while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead) {

            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;

            if (LineInfo->PermanentLineID && LineInfo->DeviceName) {
                FaxDevices += 1;
            }
        }

        LeaveCriticalSection(&g_CsLine);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&g_CsLine);
    }

    return FaxDevices;
}


BOOL GetDeviceTypeCount(
    LPDWORD SendDevices,
    LPDWORD ReceiveDevices
    )
/*++
Routine Description:

    counts the number of devices with receive enabled, number with send enabled

Arguments:

    SendDevices - receives number of send devices
    ReceiveDevices - receives number of receive devices

Return Value:

    number of devices

--*/
{
    DWORD Rx = 0, Tx = 0;
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;

    __try {
        EnterCriticalSection(&g_CsLine);

        Next = g_TapiLinesListHead.Flink;

        while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead) {

            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;

            if (LineInfo->PermanentLineID && LineInfo->DeviceName) {
                if ((LineInfo->Flags & FPF_SEND) == FPF_SEND) {
                    Tx++;
                }

                if ((LineInfo->Flags & FPF_RECEIVE) == FPF_RECEIVE) {
                    Rx++;
                }
            }
        }

        LeaveCriticalSection(&g_CsLine);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&g_CsLine);
    }

    if (SendDevices) {
        *SendDevices = Tx;
    }

    if (ReceiveDevices) {
        *ReceiveDevices = Rx;
    }

    return TRUE;
}

BOOL
CommitDeviceChanges(
    PLINE_INFO LineInfo
    )
/*++
Routine Description:

    commit device changes to registry.

Arguments:

    LineInfo - Pointer to the LINE_INFO describing the device to be commited.

Return Value:

    TRUE for success.

--*/
{

    EnterCriticalSection(&g_CsLine);
    RegAddNewFaxDevice(
                       &g_dwLastUniqueLineId,
                       &LineInfo->PermanentLineID,  // Do not create new device. Update it.
                       LineInfo->DeviceName,
                       LineInfo->Provider->ProviderName,
                       LineInfo->Provider->szGUID,
                       LineInfo->Csid,
                       LineInfo->Tsid,
                       LineInfo->TapiPermanentLineId,
                       LineInfo->Flags & 0x0fffffff,
                       LineInfo->RingsForAnswer);
    LeaveCriticalSection(&g_CsLine);
    return TRUE;


}
BOOL
SendIncomingCallEvent(
    PLINE_INFO LineInfo,
    LPLINEMESSAGE LineMsg,
    HCALL hCall
    )
/*++

Routine Description:
    This function posts FAX_EVENT_EX of
    FAX_EVENT_INCOMING_CALL type.

Arguments:
    LineInfo        - pointer to LINE_INFO structure
    LineMsg         - pointer to LINEMESSAGE structure
    hCall           - call handle to set into message

Return Values:
    TRUE for success
    FALSE for failure
--*/
{
    BOOL success = FALSE;
    DWORD dwEventSize;
    DWORD dwResult;
    PFAX_EVENT_EX pEvent = NULL;
    TCHAR CallerID[512];
    DEBUG_FUNCTION_NAME(TEXT("SendIncomingCallEvent"));

    //
    // save the line msg so we could verify hCall later
    //

    CopyMemory( &LineInfo->LineMsgOffering, LineMsg, sizeof(LINEMESSAGE) );

    //
    // allocate event structure, including caller ID info, if any
    //
    dwEventSize = sizeof(FAX_EVENT_EX);

    CallerID[0] = TEXT('\0');
    if(GetCallerIDFromCall(LineMsg->hDevice, CallerID, sizeof(CallerID)))
    {
        dwEventSize += (lstrlen(CallerID) + 1) * sizeof(TCHAR);
    }

    pEvent = (PFAX_EVENT_EX)MemAlloc(dwEventSize);
    if(!pEvent)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to notify clients of incoming call. Error allocating FAX_EVENT_EX"));
        goto Cleanup;
    }

    //
    // fill in event structure
    //
    ZeroMemory(pEvent, dwEventSize);
    pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EX);
    GetSystemTimeAsFileTime( &(pEvent->TimeStamp) );
    pEvent->EventType = FAX_EVENT_TYPE_NEW_CALL;
    pEvent->EventInfo.NewCall.hCall = hCall;
    pEvent->EventInfo.NewCall.dwDeviceId = LineInfo->PermanentLineID;

    //
    // copy caller ID info, if available
    //
    if(CallerID[0] != TEXT('\0'))
    {
        pEvent->EventInfo.NewCall.lptstrCallerId = (LPTSTR) sizeof(FAX_EVENT_EX);
        lstrcpy((LPTSTR)((BYTE *)pEvent + sizeof(FAX_EVENT_EX)), CallerID);
    }

    //
    // post extended event to any clients
    //

    dwResult = PostFaxEventEx(pEvent, dwEventSize, NULL);
    if(dwResult != ERROR_SUCCESS)
    {
        MemFree(pEvent);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to notify clients of incoming call. PostFaxEventEx() returned %x"),
            dwResult);
        goto Cleanup;
    }

    success = TRUE;

Cleanup:
    return success;
}


ULONG
TapiWorkerThread(
    LPVOID UnUsed
    )

/*++

Routine Description:

    This is worker thread for the FAX service.  All queued
    requests are processed here.

Arguments:

    None.

Return Value:

    Thread return value.

--*/

{
    PLINE_INFO LineInfo;
    BOOL Rval;
    DWORD Bytes;
    ULONG_PTR CompletionKey;
    LPLINEMESSAGE LineMsg = NULL;
    DWORD dwQueueState;
    BOOL fWakeupJobQueueThread;
    DEBUG_FUNCTION_NAME(TEXT("TapiWorkerThread"));


    while( TRUE )
    {
        fWakeupJobQueueThread = FALSE;     // We want to wake up the JobQueueThread if a new devce was added.

        if (LineMsg)
        {
            LocalFree( LineMsg );
        }

        Rval = GetQueuedCompletionStatus(
            g_TapiCompletionPort,
            &Bytes,
            &CompletionKey,
            (LPOVERLAPPED*) &LineMsg,
            INFINITE
            );

        if (!Rval)
        {
            Rval = GetLastError();
            LineMsg = NULL;
            DebugPrintEx(DEBUG_ERR, TEXT("GetQueuedCompletionStatus() failed, ec=0x%08x"), Rval);
            continue;
        }


        if (SERVICE_SHUT_DOWN_KEY == CompletionKey)
        {
            //
            // Service is shutting down
            //
            DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Service is shutting down"));
            break;
        }

        if(CompletionKey == ANSWERNOW_EVENT_KEY)
        {
            //
            // this is an event posted by FAX_AnswerCall
            //
            // the LINEMESSAGE structure must be filled out
            // as follows:
            //
            //     LineMsg->hDevice               ==  0
            //     LineMsg->dwMessageID           ==  0
            //     LineMsg->dwCallbackInstance    ==  0
            //     LineMsg->dwParam1              ==  Permanent device Id
            //     LineMsg->dwParam2              ==  0
            //     LineMsg->dwParam3              ==  0
            //

            PJOB_ENTRY pJobEntry;
            TCHAR FileName[MAX_PATH];
            DWORD dwOldFlags;

            EnterCriticalSection( &g_CsJob );
            EnterCriticalSection( &g_CsLine );

            //
            // Get LineInfo from permanent device ID
            //
            LineInfo = GetTapiLineFromDeviceId( (DWORD) LineMsg->dwParam1, FALSE );
            if(!LineInfo)
            {
                DebugPrintEx(DEBUG_ERR,
                             TEXT("Line %ld not found"),
                             LineMsg->dwParam1);
                goto next_event;
            }
            //
            // See if the device is still available
            //
            if(LineInfo->State != FPS_AVAILABLE)
            {
                DebugPrintEx(DEBUG_ERR,
                             TEXT("Line is not available (LineState is 0x%08x)."),
                             LineInfo->State);
                goto next_event;
            }

            if (!LineInfo->LineMsgOffering.hDevice)
            {
                //
                // There's no offering call - this is the 'answer-now' mode.
                //
                // If the line is ringing at the same time (has a new call), we must close the line (to make
                // all active calls go away) and re-open it.
                //
                // From MSDN: "If an application calls lineClose while it still has active calls on the opened line,
                //             the application's ownership of these calls is revoked.
                //             If the application was the sole owner of these calls, the calls are dropped as well."
                //
                // Otherwise, when we call the FSP's FaxDevReceive() function with hCall=0,
                // it calls lineMakeCall (..., PASSTHROUGH) which always succeeds but doesn't get LINECALLSTATE_OFFERING
                // until the other offering call is over.
                //
                if (LineInfo->hLine)
                {
                    LONG lRes = lineClose(LineInfo->hLine);
                    if (ERROR_SUCCESS != lRes)
                    {
                        DebugPrintEx(DEBUG_ERR,
                                     TEXT("lineClose failed with 0x%08x"),
                                     lRes);
                    }
                    LineInfo->hLine = 0;
                }
            }
            if (LineInfo->hLine == NULL)
            {
                //
                // Line is closed - open it now
                // This can be because:
                // 1. This is the 'answer now' mode but the line was never send or receive enabled.
                // 2. This is the 'answer now' mode the line was open and there was no call offered, we closed the line (above).
                //
                if (!OpenTapiLine(LineInfo))
                {
                    DWORD dwRes = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("OpenTapiLine failed. (ec: %ld)"),
                        dwRes);
                    goto next_event;
                }
            }
            Assert (LineInfo->hLine);
            //
            // start a receive fax job
            //
            // If we don't fake FPF_RECEIVE, GetTapiLineForFaxOperation() will fail StartReceiveJob() if the device is not
            // set to receive (manually or automatically)
            //
            dwOldFlags = LineInfo->Flags;
            LineInfo->Flags |= FPF_RECEIVE;
            pJobEntry = StartReceiveJob(LineInfo->PermanentLineID);
            //
            // Restore original device flags.
            //
            LineInfo->Flags = dwOldFlags;
            if (pJobEntry)
            {
                if(ERROR_SUCCESS != StartFaxReceive(
                    pJobEntry,
                    (HCALL)LineInfo->LineMsgOffering.hDevice,  // This is either 0 (answer now) or the active hCall (manual-answer)
                    LineInfo,
                    FileName,
                    sizeof(FileName)/sizeof(FileName[0])
                    ))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("StartFaxReceive failed. Line: %010d (%s) (ec: %ld)"),
                        LineInfo->DeviceId,
                        LineInfo->DeviceName,
                        GetLastError());
                    EndJob(pJobEntry);
                    //
                    // NTRAID#EdgeBugs-12677-2001/05/14-t-nicali: Should place an EVENTLOG entry here
                    //

                }
            }
            else
            {
                DebugPrintEx(DEBUG_ERR, TEXT("StartJob() failed, cannot receive incoming fax"));
            }
            goto next_event;
        }

        if ((CompletionKey == FAXDEV_EVENT_KEY) ||
            (CompletionKey == EFAXDEV_EVENT_KEY))
        {
            //
            // this is an event from a fax service provider
            // that has enumerated virtual device(s)
            //
            // the LINEMESSAGE structure must be filled out
            // as follows:
            //
            //     LineMsg->hDevice               ==  DeviceId from FaxDevStartJob()
            //     LineMsg->dwMessageID           ==  0
            //     LineMsg->dwCallbackInstance    ==  0
            //     LineMsg->dwParam1              ==  LINEDEVSTATE_RINGING
            //     LineMsg->dwParam2              ==  0
            //     LineMsg->dwParam3              ==  0
            //

            EnterCriticalSection( &g_CsJob );
            EnterCriticalSection( &g_CsLine );

            LineInfo = GetTapiLineFromDeviceId( (DWORD) LineMsg->hDevice,
                                                CompletionKey == FAXDEV_EVENT_KEY);
            if (!LineInfo) {
                goto next_event;
            }

            if (LineMsg->dwParam1 == LINEDEVSTATE_RINGING)
            {
                DWORD dwRes;
                LineInfo->RingCount += 1;
                if( !CreateFaxEvent( LineInfo->PermanentLineID, FEI_RINGING, 0xffffffff ) )
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateFaxEvent failed. (ec: %ld)"),
                        GetLastError());
                }

                dwRes = CreateDeviceEvent (LineInfo, TRUE);
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateDeviceEvent() (ec: %lc)"),
                        dwRes);
                }

                EnterCriticalSection (&g_CsConfig);
                dwQueueState = g_dwQueueState;
                LeaveCriticalSection (&g_CsConfig);

                if ((LineInfo->State == FPS_AVAILABLE)        &&                   // Device is available and
                    !(dwQueueState & FAX_INCOMING_BLOCKED)    &&                   // The incoming queue is not blocked and
                    (LineInfo->Flags & FPF_RECEIVE))                               // Device is set to auto-receive
                {
                    PJOB_ENTRY JobEntry;
                    TCHAR FileName[MAX_PATH];
                    //
                    // start a fax job
                    //
                    JobEntry = StartReceiveJob( LineInfo->PermanentLineID);
                    if (JobEntry)
                    {
                        //
                        // receive the fax
                        //
                        if (ERROR_SUCCESS != StartFaxReceive(
                                                JobEntry,
                                                0,
                                                LineInfo,
                                                FileName,
                                                sizeof(FileName)/sizeof(FileName[0])
                                                ))
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("StartFaxReceive failed. Line: 0x%08X (%s) (ec: %ld)"),
                                LineInfo->DeviceId,
                                LineInfo->DeviceName,
                                GetLastError());
                        }
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_ERR, TEXT("StartJob() failed, cannot receive incoming fax"));
                    }
                }
            }

            goto next_event;
        }

        LineInfo = (PLINE_INFO) LineMsg->dwCallbackInstance;

#if DBG
        ShowLineEvent(
            (HLINE) LineMsg->hDevice,
            (HCALL) LineMsg->hDevice,
            LineInfo == NULL ? TEXT("*NULL LineInfo*") : (LineInfo->JobEntry == NULL) ? TEXT("*NULL Job*") : NULL,
            LineMsg->dwCallbackInstance,
            LineMsg->dwMessageID,
            LineMsg->dwParam1,
            LineMsg->dwParam2,
            LineMsg->dwParam3
            );
#endif // #if DBG

        EnterCriticalSection( &g_CsJob );
        EnterCriticalSection( &g_CsLine );

        __try
        {
            switch( LineMsg->dwMessageID )
            {
                case LINE_ADDRESSSTATE:
                    break;

                case LINE_CALLINFO:
                    //
                    // generating FAX_EVENT_EX of type FAX_EVENT_TYPE_NEW_CALL when
                    // caller ID info becomes available
                    //
                    if((LineMsg->dwParam1 == LINECALLINFOSTATE_CALLERID)            &&
                       (LineInfo->PermanentLineID == g_dwManualAnswerDeviceId)
                      )
                    {
                        //
                        // Only send ringing event about the device set to manual answering
                        //
                        SendIncomingCallEvent(LineInfo, LineMsg, (HCALL)LineMsg->hDevice);
                    }
                    break;

                case LINE_CALLSTATE:
                    if (LineMsg->dwParam3 == LINECALLPRIVILEGE_OWNER && LineInfo->JobEntry && LineInfo->JobEntry->HandoffJob)
                    {
                        //
                        // call was just handed off to us
                        //
                        if (LineInfo->JobEntry  && LineInfo->JobEntry->HandoffJob)
                        {
                            LineInfo->HandoffCallHandle = (HCALL) LineMsg->hDevice;
                            SetEvent( LineInfo->JobEntry->hCallHandleEvent );
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR, TEXT("We have LINE_CALLSTATE msg, doing lineDeallocateCall\r\n"));
                            lineDeallocateCall( (HCALL) LineMsg->hDevice );
                       }
                    }

                    if (LineMsg->dwParam1 == LINECALLSTATE_IDLE)
                    {
                        DebugPrintEx(DEBUG_ERR, TEXT("We have LINE_CALLSTATE (IDLE) msg, doing 'ReleaseTapiLine'\r\n"));
                        ReleaseTapiLine( LineInfo, (HCALL) LineMsg->hDevice );
                        LineInfo->NewCall = FALSE;
                        if ( !CreateFaxEvent( LineInfo->PermanentLineID, FEI_IDLE, 0xffffffff ) )
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("CreateFaxEvent failed. (ec: %ld)"),
                                GetLastError());
                        }
                        DWORD dwRes = CreateDeviceEvent (LineInfo, FALSE);
                        if (ERROR_SUCCESS != dwRes)
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("CreateDeviceEvent() (ec: %lc)"),
                                dwRes);
                        }
                    }

                    if (LineInfo->NewCall && LineMsg->dwParam1 != LINECALLSTATE_OFFERING && LineInfo->State == FPS_AVAILABLE)
                    {
                        LineInfo->State = FPS_NOT_FAX_CALL;
                        LineInfo->NewCall = FALSE;
                    }

                    //
                    // generating FAX_EVENT_EX of type FAX_EVENT_NEW_INCOMING_CALL when
                    // line call state changes
                    //
                    if (LineInfo->PermanentLineID == g_dwManualAnswerDeviceId)
                    {
                        //
                        // Only send ringing event about the device set to manual answering
                        //
                        // When a call is offered to us, we send the event with hCall
                        // and any caller ID info we might have
                        //
                        if(LineMsg->dwParam1 == LINECALLSTATE_OFFERING)
                        {
                            SendIncomingCallEvent(LineInfo, LineMsg, (HCALL)LineMsg->hDevice);
                        }
                        //
                        // when the caller hangs up, we send the event without hCall
                        //
                        if(LineMsg->dwParam1 == LINECALLSTATE_IDLE)
                        {
                            SendIncomingCallEvent(LineInfo, LineMsg, NULL);
                        }
                    }

                    if (LineMsg->dwParam1 == LINECALLSTATE_OFFERING)
                    {
                        //
                        // we'll get a LINE_LINEDEVSTATE (RINGING) event, so we'll post the ring event there or we'll get a duplicate event
                        //
                        LineInfo->NewCall = FALSE;

                        if ((LineInfo->State == FPS_AVAILABLE)                      &&      //  Line is available and
                            (LineInfo->Flags & FPF_RECEIVE))                                //  Line is set to receive
                        {
                            EnterCriticalSection (&g_CsConfig);
                            dwQueueState = g_dwQueueState;
                            LeaveCriticalSection (&g_CsConfig);
                            if ((LineInfo->RingCount > LineInfo->RingsForAnswer)         &&     // Rings exceeded threshold and
                                !LineInfo->JobEntry                                      &&     // not job on this device yet and
                                !(dwQueueState & FAX_INCOMING_BLOCKED)                          // Incoming queue is not blocked
                               )
                            {
                                PJOB_ENTRY JobEntry;
                                TCHAR FileName[MAX_PATH];
                                //
                                // start a fax job
                                //
                                JobEntry = StartReceiveJob( LineInfo->PermanentLineID);
                                if (JobEntry)
                                {
                                    //
                                    // receive the fax
                                    //
                                    if (ERROR_SUCCESS != StartFaxReceive(
                                                            JobEntry,
                                                            (HCALL) LineMsg->hDevice,
                                                            LineInfo,
                                                            FileName,
                                                            sizeof(FileName)/sizeof(FileName[0])
                                                            ))
                                    {
                                        DebugPrintEx(
                                            DEBUG_ERR,
                                            TEXT("StartFaxReceive failed. Line: 0x%08X (%s) (ec: %ld)"),
                                            LineInfo->DeviceId,
                                            LineInfo->DeviceName,
                                            GetLastError());
                                    }
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, TEXT("StartJob() failed, cannot receive incoming fax"));
                                }
                            }
                            else
                            {
                                //
                                // save the line msg
                                //
                                CopyMemory( &LineInfo->LineMsgOffering, LineMsg, sizeof(LINEMESSAGE) );
                            }
                        }
                        else
                        {
                            //
                            // we are not supposed to answer the call, so give it to ras
                            //
                            HandoffCallToRas( LineInfo, (HCALL) LineMsg->hDevice );
                        }
                    }
                    break;

                case LINE_CLOSE:
                    {
                        //
                        // this usually happens when something bad happens to the modem device.
                        //
                        DebugPrintEx( DEBUG_MSG,
                                      (TEXT("Received LINE_CLOSE message for device %x [%s]."),
                                       LineInfo->DeviceId,
                                       LineInfo->DeviceName) );

                        LineInfo->hLine = NULL;
                        LineInfo->State = FPS_AVAILABLE;
                        GetSystemTimeAsFileTime ((FILETIME*)&LineInfo->LastLineClose);

                        if ((LineInfo->Flags & FPF_RECEIVE) ||                          // Line is in auto-anser or
                            (g_dwManualAnswerDeviceId == LineInfo->PermanentLineID))    // manual-answer mode
                        {
                            //
                            // Try to reopen the line
                            //
                            if (!OpenTapiLine(LineInfo))
                            {
                                DebugPrintEx( DEBUG_ERR,
                                              TEXT("OpenTapiLine failed for device %s"),
                                              LineInfo->DeviceName);
                            }
                        }
                        else
                        {
                            LineInfo->Flags |= FPF_POWERED_OFF;
                        }

                        //
                        // if we were waiting for a handoff, give up on it!
                        //
                        if (LineInfo->JobEntry && LineInfo->JobEntry->HandoffJob)
                        {
                            LineInfo->HandoffCallHandle = 0;
                            SetEvent(LineInfo->JobEntry->hCallHandleEvent);
                        }
                    }
                    break;

                case LINE_DEVSPECIFIC:
                    break;

                case LINE_DEVSPECIFICFEATURE:
                    break;

                case LINE_GATHERDIGITS:
                    break;

                case LINE_GENERATE:
                    break;

                case LINE_LINEDEVSTATE:
                    if (LineMsg->dwParam1 == LINEDEVSTATE_RINGING)
                    {
                        DWORD dwRes;

                        LineInfo->RingCount = (DWORD)LineMsg->dwParam3 + 1;

                        if( !CreateFaxEvent( LineInfo->PermanentLineID, FEI_RINGING, 0xffffffff ) )
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("CreateFaxEvent failed. (ec: %ld)"),
                                GetLastError());
                        }
                        dwRes = CreateDeviceEvent (LineInfo, TRUE);
                        if (ERROR_SUCCESS != dwRes)
                        {
                            DebugPrintEx(
                                DEBUG_ERR,
                                TEXT("CreateDeviceEvent() (ec: %lc)"),
                                dwRes);
                        }

                        //
                        // Pick up the line only if the last inbound job has completed
                        //
                        if (LineInfo->State != FPS_AVAILABLE)
                        {
                            break;
                        }
                        EnterCriticalSection (&g_CsConfig);
                        dwQueueState = g_dwQueueState;
                        LeaveCriticalSection (&g_CsConfig);
                        if (dwQueueState & FAX_INCOMING_BLOCKED)
                        {
                            //
                            // Inbox is blocked - no incoming faxes will be received.
                            //
                            break;
                        }
                        if ((LineInfo->Flags & FPF_RECEIVE)     &&      //    Line is set to receive and
                            (LineInfo->State == FPS_AVAILABLE))         //    the line is available
                        {
                            if (LineInfo->LineMsgOffering.hDevice == 0)
                            {
                                //
                                // wait for the offering message
                                //
                                break;
                            }

                            if ((LineInfo->RingCount > LineInfo->RingsForAnswer)  &&    // Rings count match and
                                !LineInfo->JobEntry                                     // There's no job on the line
                               )
                            {
                                PJOB_ENTRY JobEntry;
                                TCHAR FileName[MAX_PATH];
                                //
                                // Start a fax job
                                //
                                JobEntry = StartReceiveJob( LineInfo->PermanentLineID);
                                if (JobEntry)
                                {
                                    //
                                    // Receive the fax
                                    //
                                    if (ERROR_SUCCESS != StartFaxReceive(
                                                            JobEntry,
                                                            (HCALL) LineInfo->LineMsgOffering.hDevice,
                                                            LineInfo,
                                                            FileName,
                                                            sizeof(FileName)/sizeof(FileName[0])
                                                            ))
                                    {
                                        DebugPrintEx(
                                            DEBUG_ERR,
                                            TEXT("StartFaxReceive failed. Line: 0x%08X (%s) (ec: %ld)"),
                                            LineInfo->DeviceId,
                                            LineInfo->DeviceName,
                                            GetLastError());
                                    }
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, TEXT("StartJob() failed, cannot receive incoming fax"));
                                }
                            }
                        }
                        else
                        {
                            //
                            // we are not supposed to answer the call, so give it to ras
                            //
                            HandoffCallToRas( LineInfo, (HCALL) LineInfo->LineMsgOffering.hDevice );
                        }
                    }
                    break;

                case LINE_MONITORDIGITS:
                    break;

                case LINE_MONITORMEDIA:
                    break;

                case LINE_MONITORTONE:
                    break;

                case LINE_REPLY:
                    break;

                case LINE_REQUEST:
                    break;

                case PHONE_BUTTON:
                    break;

                case PHONE_CLOSE:
                    break;

                case PHONE_DEVSPECIFIC:
                    break;

                case PHONE_REPLY:
                    break;

                case PHONE_STATE:
                    break;

                case LINE_CREATE:
                    {
                        LPLINEDEVCAPS LineDevCaps;
                        LINEEXTENSIONID lineExtensionID;
                        DWORD LocalTapiApiVersion;
                        DWORD Rslt;
                        DWORD DeviceId;

                        DeviceId = (DWORD)LineMsg->dwParam1;


                        Rslt = lineNegotiateAPIVersion(
                            g_hLineApp,
                            DeviceId,
                            MIN_TAPI_LINE_API_VER,
                            MAX_TAPI_LINE_API_VER,
                            &LocalTapiApiVersion,
                            &lineExtensionID
                            );
                        if (Rslt == 0)
                        {
                            LineDevCaps = SmartLineGetDevCaps(g_hLineApp, DeviceId , LocalTapiApiVersion);
                            if (LineDevCaps)
                            {
                                EnterCriticalSection(&g_CsLine);
                                EnterCriticalSection(&g_CsConfig);
                                if (!AddNewDevice( DeviceId, LineDevCaps, FALSE , NULL))
                                {
                                    DebugPrintEx(
                                        DEBUG_WRN,
                                        TEXT("AddNewDevice() failed for Tapi Permanent device id: %ld (ec: %ld)"),
                                        LineDevCaps->dwPermanentLineID,
                                        GetLastError());
                                }
                                else
                                {
                                    //
                                    // A new device was succesfully added - wake up the JobQueueThread
                                    //
                                    fWakeupJobQueueThread = TRUE;
                                }
                                LeaveCriticalSection(&g_CsConfig);
                                LeaveCriticalSection(&g_CsLine);
                                MemFree( LineDevCaps );
                                UpdateReceiveEnabledDevicesCount ();
                            }
                        }
                    }
                    break;

                case PHONE_CREATE:
                    break;

                case LINE_AGENTSPECIFIC:
                    break;

                case LINE_AGENTSTATUS:
                    break;

                case LINE_APPNEWCALL:
                    LineInfo->NewCall = TRUE;
                    break;

                case LINE_PROXYREQUEST:
                    break;

                case LINE_REMOVE:
                    {
                        DWORD dwDeviceId = (DWORD)LineMsg->dwParam1;

                        EnterCriticalSection(&g_CsLine);
                        EnterCriticalSection (&g_CsConfig);
                        if (!RemoveTapiDevice(dwDeviceId))
                        {
                            DebugPrintEx( DEBUG_WRN,
                                          TEXT("RemoveTapiDevice() failed for device id: %ld (ec: %ld)"),
                                          dwDeviceId,
                                          GetLastError());
                        }
                        LeaveCriticalSection(&g_CsConfig);
                        LeaveCriticalSection(&g_CsLine);
                        UpdateReceiveEnabledDevicesCount ();
                    }
                    break;

                case PHONE_REMOVE:
                    break;
            }

            //
            // call the device provider's line callback function
            //
            if (LineInfo && LineInfo->JobEntry)
            {
                Assert (LineInfo->Provider && LineInfo->Provider->FaxDevCallback);

                __try
                {
                    LineInfo->Provider->FaxDevCallback(
                        (HANDLE) LineInfo->JobEntry->InstanceData,
                        LineMsg->hDevice,
                        LineMsg->dwMessageID,
                        LineMsg->dwCallbackInstance,
                        LineMsg->dwParam1,
                        LineMsg->dwParam2,
                        LineMsg->dwParam3
                        );
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    DebugPrintEx(DEBUG_ERR, TEXT("Device provider tapi callback crashed: 0x%08x"), GetExceptionCode());
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("TapiWorkerThread() crashed: 0x%08x"), GetExceptionCode());
        }

next_event:
        LeaveCriticalSection( &g_CsLine );
        LeaveCriticalSection( &g_CsJob );

        //
        // Check if we should wake up the JobQueueThread (if a new device was added)
        //
        if (TRUE == fWakeupJobQueueThread)
        {
            if (!SetEvent( g_hJobQueueEvent ))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                    GetLastError());

                EnterCriticalSection (&g_CsQueue);
                g_ScanQueueAfterTimeout = TRUE;
                LeaveCriticalSection (&g_CsQueue);
            }
        }
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return 0;
}


BOOL
HandoffCallToRas(
    PLINE_INFO LineInfo,
    HCALL hCall
    )

/*++

Routine Description:

    This function will try to hand a call of to RAS.
    We do this under 2 circumstances:
        1) we've answered an incoming call and
           determined that the call is NOT a fax call
        2) the configuration for the line that is
           ringing is not configured for receiving faxes
    If the handoff fails and we have an open job for the
    line, then we have to call the device provider so that
    the line can be put on hook.

Arguments:

    LineInfo    - LineInfo structure for the line this call is on
    hCall       - TAPI call handle

Return Value:

    TRUE for success
    FALSE for failure

--*/

{
    LONG Rval;
    DEBUG_FUNCTION_NAME(TEXT("HandoffCallToRas"));

    //
    // need to hand the call off to RAS
    //

    Rval = lineHandoff(
        hCall,
        RAS_MODULE_NAME,
        LINEMEDIAMODE_DATAMODEM
        );
    if (Rval != 0 && LineInfo && LineInfo->JobEntry)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("lineHandoff() failed, ec=0x%08x"), Rval);
        //
        // since the handoff failed we must notify
        // the fsp so that the call can be put onhook
        //
        if ((LineInfo->Provider->dwAPIVersion < FSPI_API_VERSION_2) ||
            (LineInfo->Provider->dwCapabilities & FSPI_CAP_ABORT_RECIPIENT)
           )
        {
            //
            // Either this is an FSP (Always supports FaxDevAbortOperation) or its an
            // EFSP that has FSPI_CAP_ABORT_RECIPIENT capabilities.
            //
            __try
            {
                LineInfo->Provider->FaxDevAbortOperation(
                        (HANDLE) LineInfo->JobEntry->InstanceData
                        );

            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                DebugPrintEx(DEBUG_ERR, TEXT("FaxDevAbortOperation() failed: 0x%08x"), GetExceptionCode());
            }
        }
        else
        {
            //
            // This is an EFSP that does not support aborting of jobs.
            //
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("[hCall: %ld] FaxDevAbortOperation is not available on this EFSP"),
                hCall);
        }

    }
    else
    {
        DebugPrintEx(DEBUG_MSG, TEXT("call handed off to RAS"));
    }
    return Rval == 0;
}


PLINE_INFO
GetTapiLineFromDeviceId(
    DWORD DeviceId,
    BOOL  fLegacyId
    )
{
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;


    Next = g_TapiLinesListHead.Flink;
    if (!Next) {
        return NULL;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead) {

        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;

        if (fLegacyId)
        {
            if (LineInfo->TapiPermanentLineId == DeviceId) {
                return LineInfo;
            }
        }
        else
        {
            if (LineInfo->PermanentLineID == DeviceId) {
                return LineInfo;
            }
        }
    }

    return NULL;
}



//*********************************************************************************
//* Name:   GetLineForSendOperation()
//* Author: Ronen Barenboim
//* Date:   June 03, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Returns a line to be used for a send operation.
//*
//* PARAMETERS:
//*     [IN ]       PJOB_QUEUE lpJobQueue
//*         The recipient job for which the line is intended.
//*
//*     [IN ]       DWORD dwDeviceId
//*         The device id of the requested line . USE_SERVER_DEVICE means that
//*         the function will select it for the caller.
//*
//*     [IN ]       BOOL bQueryOnly
//*         If TRUE the function will not mark the selected line as unavilable.
//*
//*     [IN ]       BOOL bIgnoreLineState
//*             If this is TRUE the function and DeviceId == USE_SERVER_DEVICE
//*             then the function will match a line even if its state indicates
//*             it is busy. This is used when creating recipient groups for
//*             FaxDevSendEx. The Anchor recipient gets hold of the line and for the
//*             rest of the recipients we just need to know to which line they are
//*             destined. We want the function to report the line even if it is
//*             busy.
//*
//* RETURN VALUE:
//*     On success the function returns a pointer to the LINE_INFO structure of
//*     the selected line.
//*     On failure it returns NULL.
//*********************************************************************************
PLINE_INFO
GetLineForSendOperation(
    PJOB_QUEUE lpJobQueue,
    DWORD dwDeviceId,
    BOOL bQueryOnly,
    BOOL bIgnoreLineState)
{
    DEBUG_FUNCTION_NAME(TEXT("GetLineForSendOperation"));
    Assert(lpJobQueue);
    BOOL bHandoff;
    //
    // assume send job without use_server_device is a handoff job
    //

    bHandoff = (dwDeviceId != USE_SERVER_DEVICE);
    return GetTapiLineForFaxOperation(
        dwDeviceId,
        JT_SEND,
        lpJobQueue->RecipientProfile.lptstrFaxNumber,
        bHandoff,
        bQueryOnly,
        bIgnoreLineState);
}



//*********************************************************************************
//* Name:   GetTapiLineForFaxOperation()
//* Author: Ronen Barenboim
//* Date:   June 03, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Locates an avaliable TAPI device for use in a
//*     FAX operation.  The selection is based on the
//*     available devices and their assigned priority.
//*     If DeviceId is USE_SERVER_DEVICE the function will locate a device which
//*     can be used for the job type specified. It does not revive devices in this
//*     case.
//*
//*     If DeviceId contains a specific device
//*     If Handoff is TRUE and the job type is JT_SEND
//*         The function will return the LINE_INFO for the specified line without
//*         checking if it is availble or not or configured for send or receive.
//*     Else
//*         The function will check first if the specified device match the
//*         requested job type and then return LINE_INFO.
//*         If the device is powered off the function will attempt to revive it.
//*
//* PARAMETERS:
//*     [IN ]       DWORD DeviceId
//*             The permanent device id (not tapi) of the line. If it is
//*             USE_SERVER_DEVICE the function will select a line based on the
//*             line send/receive capabilities, status and priorities.
//*
//*     [IN ]       DWORD JobType
//*             The type of job that is about to be executed on the line.
//*             can be JT_RECEIVE or JT_SEND.
//*
//*     [IN ]       LPWSTR FaxNumber
//*             For a send operation this is the fax number that is going to be
//*             used to send the fax. The function uses it to avoid sending
//*             to faxes to the same number simultaneously.
//*
//*     [IN ]       BOOL Handoff
//*             TRUE if the job is a handoff job. In this case DEVICEID must
//*             be a specific device and the job type must be JT_SEND.
//*             For a handoff job the function will return the line with the
//*             specified id without checking it availablity and send/receive
//*             enablement.
//*
//*     [IN ]       BOOL bQueryOnly
//*             If this is TRUE the function will not remove the line
//*             from the available lines pool. Otherwise if the line
//*             does not support multisend it will be marked as
//*             unavailable.
//*     [IN ]       BOOL bIgnoreLineState
//*             If this is TRUE the function and DeviceId == USE_SERVER_DEVICE
//*             then the function will match a line even if its state indicates
//*             it is busy. This is used when creating recipient groups for
//*             FaxDevSendEx. The Anchor recipient gets hold of the line and for the
//*             rest of the recipients we just need to know to which line they are
//*             destined. We want the function to report the line even if it is
//*             busy.
//*
//* RETURN VALUE:
//*         If the function succeeds it returns a pointer to the LINE_INFO
//*         structure of the selected line.  Otherwise it returns NULL.
//*         If it is NULL the function failed. Call GetLastError() for more info.
//*********************************************************************************
PLINE_INFO
GetTapiLineForFaxOperation(
    DWORD DeviceId,
    DWORD JobType,
    LPWSTR FaxNumber,
    BOOL Handoff,
    BOOL bQueryOnly,
    BOOL bIgnoreLineState
    )

{
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;
    PLINE_INFO SelectedLine = NULL;
    LPDWORD lpdwDevices = NULL;
    DEBUG_FUNCTION_NAME(TEXT("GetTapiLineForFaxOperation"));
    DWORD ec = ERROR_SUCCESS;

    EnterCriticalSection( &g_CsLine );

    if (FaxNumber)
    {
        if (FindJobEntryByRecipientNumber(FaxNumber))
        {
            //
            // We do not allow to outgoing calls to the same number.
            //
            LeaveCriticalSection( &g_CsLine );
            SetLastError (ERROR_NOT_FOUND);
            return NULL;
        }
    }

    //
    // Find out if there is another send job to the same number.
    // It there is do not select a line and return NULL.
    //

    if (DeviceId != USE_SERVER_DEVICE)
    {
        Next = g_TapiLinesListHead.Flink;
        Assert (Next);

        while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
        {
            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;
            //
            // The caller specified a specific device to use. Just find it for him.
            //
            if (LineInfo->PermanentLineID == DeviceId)
            {
                //
                // Found a device with a matching id.
                //
                if (Handoff)
                {

                    if (JobType != JT_SEND)
                    {
                        //
                        // Can't have a handoff job which is not JT_SEND. Don't select a line
                        // and return an error.
                        //
                        break;
                    }
                    //
                    // We found the line to return to the caller.
                    //
                    SelectedLine = LineInfo;
                    // LineInfo->State = FPS_???;
                    break;
                }

                if ((JobType == JT_RECEIVE)                                     &&      // Asking for a line to receive a fax and
                    ((LineInfo->Flags & FPF_RECEIVE)                            ||      //    Line is in auto-answer mode or
                     (g_dwManualAnswerDeviceId == LineInfo->PermanentLineID)            //    this is the manual-answer device
                    )
                   )
                {
                    //
                    // For receive jobs we assume that the requested device is free since it is
                    // the FSP that tells us when to receive.
                    // If the device does not support simultaneous send and receive operations then we
                    // need to mark it as unavailable until the receive operation is completed.
                    //

                    if ( !(bQueryOnly) && !(LineInfo->Provider->dwCapabilities & FSPI_CAP_SIMULTANEOUS_SEND_RECEIVE))
                    {
                        LineInfo->State = 0; // remove the FPS_AVAILABLE bit
                    }
                    SelectedLine = LineInfo;
                    break;
                }

                if( (LineInfo->State == FPS_AVAILABLE) && (JobType == JT_SEND) && (LineInfo->Flags & FPF_SEND))
                {
                    //
                    // If this is not a handoff job then we will return the selected
                    // line only if it can send or receive as requested.
                    //
                    if ( !(bQueryOnly) && !(LineInfo->Provider->dwCapabilities & FSPI_CAP_MULTISEND))
                    {
                        LineInfo->State = 0; // remove the FPS_AVAILABLE bit
                    }
                    SelectedLine = LineInfo;
                    break;
                }

                if (LineInfo->UnimodemDevice && (LineInfo->Flags & FPF_POWERED_OFF))
                {
                    //
                    // If the device is a unimodem device and indicated as powered off
                    // see if we can revive it by opening the line.
                    //
                    if (!OpenTapiLine( LineInfo ))
                    {
                        DebugPrintEx(DEBUG_ERR,
                                     TEXT("OpenTapiLine failed for Device [%s] (ec: %ld)"),
                                     LineInfo->DeviceName,
                                     GetLastError());
                        LineInfo->State = 0; // remove the FPS_AVAILABLE bit'
                        SelectedLine = LineInfo;
                    }
                }
                break;
            }
        }
    }
    else
    {
        //
        // The user wants us to find a free device for him. This is only valid for send operations
        // which are not handoff.
        //
        Assert( JT_SEND == JobType );
        DWORD dwNumDevices, dwCountryCode, dwAreaCode;

        Assert (FaxNumber);

        //
        //  Check DialAsEntered case
        //
        BOOL    bCanonicalAddress = FALSE;
        BOOL    bDialAsEntered = FALSE;

        ec = IsCanonicalAddress (FaxNumber, &bCanonicalAddress, &dwCountryCode, &dwAreaCode, NULL);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("IsCanoicalAddress failed with error %ld"),
                ec);
            goto exit;
        }

        if (TRUE == bCanonicalAddress)
        {
            LPLINECOUNTRYLIST           lpCountryList = NULL;
            //
            // Get the cached all countries list.
            //
            if (!(lpCountryList = GetCountryList()))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Can not get all countries cached list"));
                ec = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }

            if (IsAreaCodeMandatory(lpCountryList, dwCountryCode) == TRUE &&
                ROUTING_RULE_AREA_CODE_ANY == dwAreaCode)
            {
                //
                // The area code is missing  - dial as entered
                //
                DebugPrintEx(DEBUG_WRN,
                    TEXT("Area code is mandatory for Country code %ld,  FaxNumber - %s. The number will be dialed as entered"),
                    dwCountryCode,
                    FaxNumber);
                bDialAsEntered = TRUE;
            }
        }
        else
        {
            //
            // Not a canonical address - dial as entered
            //
            bDialAsEntered = TRUE;
        }

        if (FALSE == bDialAsEntered)
        {
            EnterCriticalSection( &g_CsConfig );

            ec = GetDeviceListByCountryAndAreaCode( dwCountryCode,
                                                    dwAreaCode,
                                                    &lpdwDevices,
                                                    &dwNumDevices);
            if (ERROR_SUCCESS != ec)
            {
                DebugPrintEx(DEBUG_ERR,
                    TEXT("GetDeviceListByCountryAndAreaCode failed with error %ld"),
                    ec);
                LeaveCriticalSection( &g_CsConfig );
                goto exit;
            }
        }
        else
        {
            //
            //  Dial As Entered case
            //

            //
            //  Bring List of Devices from "All Devices" group
            //
            EnterCriticalSection( &g_CsConfig );

            PCGROUP pCGroup;
            pCGroup = g_pGroupsMap->FindGroup (ROUTING_GROUP_ALL_DEVICESW);

            if (NULL == pCGroup)
            {
                ec = GetLastError();
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("g_pGroupsMap->FindGroup(ROUTING_GROUP_ALL_DEVICESW) failed (ec %ld)"), ec);
                LeaveCriticalSection( &g_CsConfig );
                goto exit;
            }

            ec = pCGroup->SerializeDevices (&lpdwDevices, &dwNumDevices);
            if (ERROR_SUCCESS != ec)
            {
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("pCGroup->SerializeDevices(&lpdwDevices, &dwNumDevices) failed (ec %ld)"), ec);
                LeaveCriticalSection( &g_CsConfig );
                goto exit;
            }
        }
        LeaveCriticalSection( &g_CsConfig );

        for (DWORD i = 0; i < dwNumDevices; i++)
        {
            Next = g_TapiLinesListHead.Flink;
            Assert (Next);

            while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
            {

                LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
                Next = LineInfo->ListEntry.Flink;

                //
                //  if DialAsEntered then check that EFSP supports Non-Canonical Fax Numbers
                //
                if (bDialAsEntered &&
                    (LineInfo->Provider->dwAPIVersion > FSPI_API_VERSION_1) &&
                    (!(LineInfo->Provider->dwCapabilities & FSPI_CAP_USE_DIALABLE_ADDRESS)))
                {
                    //
                    //  Continue to next Line Info
                    //
                    continue;
                }

                if ( (LineInfo->Flags & FPF_SEND)         &&
                     lpdwDevices[i] == LineInfo->PermanentLineID)
                {
                    if ( (LineInfo->Flags & FPF_POWERED_OFF)  ||
                         (LineInfo->Flags & FPF_RECEIVE)
                       )
                    {
                        //
                        // The device is marked as powered off. Check if we should try to send using this device
                        //
                        DWORDLONG dwlCurrentTime;
                        DWORDLONG dwlElapsedTime;
                        GetSystemTimeAsFileTime ((FILETIME*)&dwlCurrentTime);
                        Assert (dwlCurrentTime >= LineInfo->LastLineClose);
                        dwlElapsedTime = dwlCurrentTime - LineInfo->LastLineClose;
                        if (dwlElapsedTime < SecToNano(g_dwMaxLineCloseTime))
                        {
                            //
                            // Not enough time passes since the last LINE_CLOSE. skip this device
                            //
                            continue;
                        }
                    }
                    //
                    // The device is capable of sending and is not marked as FPF_POWERED_OFF.
                    //

                    //
                    // If it is a Tapi device, try to verify it s not busy
                    //
                    if (LineInfo->State == FPS_AVAILABLE &&
                !(LineInfo->JobEntry)            &&
                        !(LineInfo->Flags & FPF_VIRTUAL))
                    {
                        if (NULL == LineInfo->hLine)
                        {
                            if (!OpenTapiLine( LineInfo ))
                            {
                                DebugPrintEx(DEBUG_ERR,
                                             TEXT("OpenTapiLine failed for Device [%s] (ec: %ld)"),
                                             LineInfo->DeviceName,
                                             GetLastError());
                                continue;
                            }
                        }

                        LPLINEDEVSTATUS pLineDevStatus = NULL;
                        BOOL fLineBusy = FALSE;

                        //
                        // check to see if the line is in use
                        //
                        pLineDevStatus = MyLineGetLineDevStatus( LineInfo->hLine );
                        if (NULL != pLineDevStatus)
                        {
                            if (pLineDevStatus->dwNumOpens > 0 && pLineDevStatus->dwNumActiveCalls > 0)
                            {
                                fLineBusy = TRUE;
                            }
                            MemFree( pLineDevStatus );
                        }
                        else
                        {
                            // Assume the line is busy
                            DebugPrintEx(DEBUG_ERR,
                                         TEXT("MyLineGetLineDevStatus failed for Device [%s] (ec: %ld)"),
                                         LineInfo->DeviceName,
                                         GetLastError());

                            fLineBusy = TRUE;
                        }

                        ReleaseTapiLine( LineInfo, NULL );

                        if (TRUE == fLineBusy)
                        {
                            continue;
                        }
                    }

                    if (((LineInfo->State == FPS_AVAILABLE) && !(LineInfo->JobEntry)) || bIgnoreLineState)
                    {
                        //
                        // The line is free or we are to ignore its state.
                        //
                        if (!bQueryOnly && !(LineInfo->Provider->dwCapabilities & FSPI_CAP_MULTISEND))
                        {
                            //
                            // We mark the line as not avilable only if it does not support multisend and the
                            // user did not ask for a query only.
                            //
                            LineInfo->State = 0;
                        }
                        SelectedLine = LineInfo;
                    }
                    break;  // out of while
                }
            }
            if (SelectedLine != NULL)
            {
                break; // out of for
            }
        }
    }

    if (SelectedLine)
    {
        DebugPrintEx(DEBUG_MSG,
            TEXT("Line selected for FAX operation: %d, %d"),
            SelectedLine->DeviceId,
            SelectedLine->PermanentLineID
            );
    }

    Assert (ERROR_SUCCESS == ec);

exit:
    MemFree (lpdwDevices);
    LeaveCriticalSection( &g_CsLine );
    if (ERROR_SUCCESS == ec &&
        NULL == SelectedLine)
    {
        ec = ERROR_NOT_FOUND;
    }
    SetLastError (ec);
    return SelectedLine;
}

BOOL
ReleaseTapiLine(
    PLINE_INFO LineInfo,
    HCALL hCall
    )

/*++

Routine Description:

    Releases the specified TAPI line back into
    the list as an available device.
    Closes the line and deallocates the call. (line is not closed for a receive enabled
    device.

Arguments:

    LineInfo    - Pointer to the TAPI line to be released

Return Value:

    TRUE    - The line is release.
    FALSE   - The line is not released.

--*/
{
    LONG rVal;
    HLINE hLine;
    DEBUG_FUNCTION_NAME(TEXT("ReleaseTapiLine"));

    Assert(LineInfo);
    if (!LineInfo)
    {
        return FALSE;
    }

    EnterCriticalSection( &g_CsLine );

    LineInfo->State = FPS_AVAILABLE;
    LineInfo->RingCount = 0;
    hLine = LineInfo->hLine;

    ZeroMemory( &LineInfo->LineMsgOffering, sizeof(LINEMESSAGE) );

    if (hCall)
    {
        rVal = lineDeallocateCall( hCall );
        if (rVal != 0)
        {
            DebugPrintEx( DEBUG_ERR,
                        TEXT("lineDeallocateCall() failed, ec=0x%08X, hLine=0x%08X hCall=0x%08X"),
                        rVal,
                        hLine,
                        hCall);
        }
        else
        {
            if (LineInfo->JobEntry && LineInfo->JobEntry->CallHandle == hCall)
            {
                LineInfo->JobEntry->CallHandle = 0;
            }
        }
    }
    else
    {
        DebugPrintEx( DEBUG_WRN,
                    TEXT("ReleaseTapiLine(): cannot deallocate call, NULL call handle"));
    }
    //
    // We actually close the line (by lineClose) only if the line is not
    // intended for receiving.
    //
    if (!(LineInfo->Flags & FPF_RECEIVE)                        &&  // Line is not set to auto-receive and
        LineInfo->hLine                                         &&  // line is open and
        LineInfo->PermanentLineID != g_dwManualAnswerDeviceId       // this device is not set to manual answer mode
       )
    {
        //
        // Attempt to close the line
        //
        LONG lRes;
        LineInfo->hLine = 0;
        lRes=lineClose( hLine );
        if (!lRes)
        {
               DebugPrintEx( DEBUG_MSG,
                      TEXT("hLine 0x%08X closed successfuly"),
                      hLine );
        }
        else
        {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("Failed to close hLine 0x%08X (ec: 0x%08X)"),
                      hLine,
                      lRes);
        }
    }

    LeaveCriticalSection( &g_CsLine );

    return TRUE;
}



LPLINEDEVSTATUS
MyLineGetLineDevStatus(
    HLINE hLine
    )
{
    DWORD LineDevStatusSize;
    LPLINEDEVSTATUS LineDevStatus = NULL;
    LONG Rslt = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(_T("lineGetLineDevStatus"));


    //
    // allocate the initial linedevstatus structure
    //

    LineDevStatusSize = sizeof(LINEDEVSTATUS) + 4096;
    LineDevStatus = (LPLINEDEVSTATUS) MemAlloc( LineDevStatusSize );
    if (!LineDevStatus)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    LineDevStatus->dwTotalSize = LineDevStatusSize;

    Rslt = lineGetLineDevStatus(
        hLine,
        LineDevStatus
        );

    if (Rslt != 0)
    {
        DebugPrintEx( DEBUG_ERR, TEXT("lineGetLineDevStatus() failed, ec=0x%08x"), Rslt );
        goto exit;
    }

    if (LineDevStatus->dwNeededSize > LineDevStatus->dwTotalSize)
    {
        //
        // re-allocate the LineDevStatus structure
        //

        LineDevStatusSize = LineDevStatus->dwNeededSize;

        MemFree( LineDevStatus );

        LineDevStatus = (LPLINEDEVSTATUS) MemAlloc( LineDevStatusSize );
        if (!LineDevStatus)
        {
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        Rslt = lineGetLineDevStatus(
            hLine,
            LineDevStatus
            );

        if (Rslt != 0)
        {
            DebugPrintEx( DEBUG_ERR, TEXT("lineGetLineDevStatus() failed, ec=0x%08x"), Rslt );
            goto exit;
        }
    }

exit:
    if (Rslt != ERROR_SUCCESS)
    {
        MemFree( LineDevStatus );
        LineDevStatus = NULL;
        SetLastError(Rslt);
    }

    return LineDevStatus;
}


LONG
MyLineGetTransCaps(
    LPLINETRANSLATECAPS *LineTransCaps
    )
{
    DWORD LineTransCapsSize;
    LONG Rslt = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(_T("MyLineGetTransCaps"));


    //
    // allocate the initial linetranscaps structure
    //

    LineTransCapsSize = sizeof(LINETRANSLATECAPS) + 4096;
    *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
    if (!*LineTransCaps)
    {
        DebugPrintEx (DEBUG_ERR, TEXT("MemAlloc() failed, sz=0x%08x"), LineTransCapsSize);
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

    Rslt = lineGetTranslateCaps(
        g_hLineApp,
        MAX_TAPI_API_VER,
        *LineTransCaps
        );

    if (Rslt != 0) {
        DebugPrintEx(DEBUG_ERR, TEXT("lineGetTranslateCaps() failed, ec=0x%08x"), Rslt);
        goto exit;
    }

    if ((*LineTransCaps)->dwNeededSize > (*LineTransCaps)->dwTotalSize) {

        //
        // re-allocate the LineTransCaps structure
        //

        LineTransCapsSize = (*LineTransCaps)->dwNeededSize;

        MemFree( *LineTransCaps );

        *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
        if (!*LineTransCaps) {
            DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc() failed, sz=0x%08x"), LineTransCapsSize);
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

        Rslt = lineGetTranslateCaps(
            g_hLineApp,
            MAX_TAPI_API_VER,
            *LineTransCaps
            );

        if (Rslt != 0) {
            DebugPrintEx(DEBUG_ERR, TEXT("lineGetTranslateCaps() failed, ec=0x%08x"), Rslt);
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        MemFree( *LineTransCaps );
        *LineTransCaps = NULL;
    }

    return Rslt;
}




/******************************************************************************
* Name: OpenTapiLine
* Author:
*******************************************************************************
DESCRIPTION:
    - Opens the specified TAPI line with the right media modes and ownership.
      Supports both Unimodem devices and fax boards.
    - Sets the line so the required lines and address state events will be
      delivered.
PARAMETERS:
    [IN / OUT ] LineInfo
        A pointer to a LINE_INFO structure that contains the line information.
        LINE_INFO.hLine is set to the open line handle if the operation succeeds.
RETURN VALUE:
    TRUE if no error occured.
    FALSE otherwise.
    Does not explicitly set LastError.
REMARKS:
    NONE.
*******************************************************************************/
BOOL
OpenTapiLine(
    PLINE_INFO LineInfo
    )
{
    LONG Rslt = ERROR_SUCCESS;
    HLINE hLine;
    DWORD LineStates = 0;
    DWORD AddressStates = 0;

    DEBUG_FUNCTION_NAME(_T("OpenTapiLine"));

    EnterCriticalSection( &g_CsLine );

    if (LineInfo->UnimodemDevice)
    {
        Rslt = lineOpen(
            g_hLineApp,
            LineInfo->DeviceId,
            &hLine,
            MAX_TAPI_API_VER,
            0,
            (DWORD_PTR) LineInfo, // Note that the LineInfo pointer is used as CallbackInstance data. This means we will
                                  // get the LineInfo pointer each time we get a TAPI message.
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_DATAMODEM | LINEMEDIAMODE_UNKNOWN,
            NULL
            );

        if (Rslt != ERROR_SUCCESS)
        {
            Rslt = lineOpen(
                g_hLineApp,
                LineInfo->DeviceId,
                &hLine,
                MAX_TAPI_API_VER,
                0,
                (DWORD_PTR) LineInfo,
                LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
                LINEMEDIAMODE_DATAMODEM,
                NULL
                );
        }
    }
    else
    {
        Rslt = lineOpen(
            g_hLineApp,
            LineInfo->DeviceId,
            &hLine,
            MAX_TAPI_API_VER,
            0,
            (DWORD_PTR) LineInfo,
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_G3FAX,
            NULL
            );
    }

    if (Rslt != ERROR_SUCCESS)
    {
        DebugPrintEx( DEBUG_ERR,TEXT("Device %s FAILED to initialize, ec=%08x"), LineInfo->DeviceName, Rslt );
    }
    else
    {
        LineInfo->hLine = hLine;
        //
        // set the line status that we need
        //
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_OPEN     ? LINEDEVSTATE_OPEN     : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_CLOSE    ? LINEDEVSTATE_CLOSE    : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_RINGING  ? LINEDEVSTATE_RINGING  : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_NUMCALLS ? LINEDEVSTATE_NUMCALLS : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_REMOVED  ? LINEDEVSTATE_REMOVED  : 0;

        AddressStates = LINEADDRESSSTATE_INUSEZERO | LINEADDRESSSTATE_INUSEONE |
                        LINEADDRESSSTATE_INUSEMANY | LINEADDRESSSTATE_NUMCALLS;

        Rslt = lineSetStatusMessages( hLine, LineStates, AddressStates );
        if (Rslt != 0)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("lineSetStatusMessages() failed, [0x%08x:0x%08x], ec=0x%08x"), LineStates, AddressStates, Rslt );
            Rslt = ERROR_SUCCESS;
        }
    }

    LeaveCriticalSection( &g_CsLine );

    if (ERROR_SUCCESS != Rslt)
    {
        //
        // We set the modem to be FPF_POWERED_OFF to make sure we will not try to constantly resend
        // on this device. After MAX_LINE_CLOSE_TIME we will retry to send on this device.
        //
        LineInfo->hLine = NULL;
        LineInfo->Flags |= FPF_POWERED_OFF;
        GetSystemTimeAsFileTime((FILETIME*)&LineInfo->LastLineClose);
        //
        // Can not map the TAPI error to a win error so we just return general failure.
        // We do generate a debug output with the actual error earlier in this code.
        //
        SetLastError(ERROR_GEN_FAILURE);
        return FALSE;
    }
    else
    {
        LineInfo->Flags &= ~FPF_POWERED_OFF;
        return TRUE;
    }
}


BOOL CALLBACK
NewDeviceRoutingMethodEnumerator(
    PROUTING_METHOD RoutingMethod,
    DWORD DeviceId
    )
{
    BOOL Rslt = FALSE;
    DEBUG_FUNCTION_NAME(_T("NewDeviceRoutingMethodEnumerator"));

    __try
    {
        Rslt = RoutingMethod->RoutingExtension->FaxRouteDeviceChangeNotification( DeviceId, TRUE );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FaxRouteDeviceChangeNotification() crashed: 0x%08x"), GetExceptionCode());
    }

    return Rslt;
}


BOOL
AddNewDevice(
    DWORD DeviceId,
    LPLINEDEVCAPS LineDevCaps,
    BOOL fServerInitialization,
    PREG_FAX_DEVICES    pInputFaxReg
    )
{
    BOOL rVal = FALSE;
    BOOL UnimodemDevice = FALSE;
    PMDM_DEVSPEC MdmDevSpec = NULL;
    LPSTR ModemKey = NULL;
    LPTSTR DeviceName = NULL;
    REG_SETUP RegSetup = {0};
    DWORD dwUniqueLineId = 0;
    PDEVICE_PROVIDER lpProvider;
    LPTSTR lptstrTSPName;
    DWORD ec = ERROR_SUCCESS;
    BOOL fDeviceAddedToMap = FALSE;
    DWORD dwDeviceType = FAX_DEVICE_TYPE_OLD;
    DEBUG_FUNCTION_NAME(TEXT("AddNewDevice"));

    //
    // only add devices that support fax
    //
    if (! ( ((LineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM) &&
             (UnimodemDevice = IsDeviceModem( LineDevCaps, FAX_MODEM_PROVIDER_NAME ) )) ||
            (LineDevCaps->dwMediaModes & LINEMEDIAMODE_G3FAX) ))
    {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!(LineDevCaps->dwProviderInfoSize))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("No device provider information"));
         SetLastError (ERROR_INVALID_PARAMETER);
         return FALSE;
    }

    if (!GetOrigSetupData( LineDevCaps->dwPermanentLineID, &RegSetup ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetOrigSetupData failed (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    if (LineDevCaps->dwLineNameSize)
    {
        DeviceName = FixupDeviceName( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset) );
        if (NULL == DeviceName)
        {
            ec = GetLastError();
            DebugPrintEx( DEBUG_ERR,
                           TEXT("FixupDeviceName failed (ec: %ld)"),
                           ec);
            rVal = FALSE;
            goto exit;
        }
    }

    //
    // Find the device provider for this device using the TAPI provider name.
    //
    lptstrTSPName = (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset) ;
    lpProvider = FindDeviceProvider( lptstrTSPName);
    if (!lpProvider)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Could not find a valid device provider for TAPI device: [%s]. (Looking for TSP : [%s])"),
            DeviceName,
            lptstrTSPName
            );
        rVal = FALSE;
        goto exit;
    }
    Assert (FAX_PROVIDER_STATUS_SUCCESS == lpProvider->Status);

    // try to find this device from service registry and update RegSetup if found
    if ( pInputFaxReg )
    {
        dwUniqueLineId = FindServiceDeviceByTapiPermanentLineID ( LineDevCaps->dwPermanentLineID, DeviceName, &RegSetup, pInputFaxReg );
    }

    // try to find this device in device cache and update RegSetup if found
    if ( 0 == dwUniqueLineId )
    {
        BOOL fManualAnswer = FALSE;
        if (0 != (dwUniqueLineId = FindCacheEntryByTapiPermanentLineID( LineDevCaps->dwPermanentLineID,
                                                                        DeviceName,
                                                                        &RegSetup,
                                                                        &g_dwLastUniqueLineId,
                                                                        &fManualAnswer)))
        {
            //
            // The device was found in the cache
            //
            dwDeviceType = FAX_DEVICE_TYPE_CACHED;
            if (TRUE == fManualAnswer)
            {
                //
                // The device was set to manual answer when moved to the cache
                //
                dwDeviceType |= FAX_DEVICE_TYPE_MANUAL_ANSWER;
            }
        }
    }

    // still 0 so, add this new device to registry
    if ( 0 == dwUniqueLineId )
    {
        dwDeviceType = FAX_DEVICE_TYPE_NEW;
        ec = RegAddNewFaxDevice( &g_dwLastUniqueLineId,
                             &dwUniqueLineId, // Create new device.
                             DeviceName,
                             (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset),
                             lpProvider->szGUID,
                             RegSetup.Csid,
                             RegSetup.Tsid,
                             LineDevCaps->dwPermanentLineID,
                             RegSetup.Flags,
                             RegSetup.Rings);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("RegAddNewFaxDevice() failed for Tapi permanent device id: %ld (ec: %ld)"),
                LineDevCaps->dwPermanentLineID,
                ec);
            rVal = FALSE;
            goto exit;
        }
    }

    ec = g_pTAPIDevicesIdsMap->AddDevice (LineDevCaps->dwPermanentLineID, dwUniqueLineId);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("g_pTAPIDevicesIdsMap->AddDevice() failed for Tapi permanent device id: %ld (ec: %ld)"),
            LineDevCaps->dwPermanentLineID,
            ec);
        rVal = FALSE;
        goto exit;
    }
    fDeviceAddedToMap = TRUE;

    ec = InitializeTapiLine( DeviceId,
                             dwUniqueLineId,
                             LineDevCaps,
                             RegSetup.Rings,
                             RegSetup.Flags,
                             RegSetup.Csid,
                             RegSetup.Tsid,
                             RegSetup.lptstrDescription,
                             fServerInitialization,
                             dwDeviceType
                             );
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx( DEBUG_WRN,
                      TEXT("InitializeTapiLine failed for Fax unique device id: %ld (ec: %ld)"),
                      dwUniqueLineId,
                      ec);
        rVal = FALSE;
        goto exit;
    }

    if (FALSE == fServerInitialization)
    {
        PLINE_INFO pLineInfo = NULL;

        //
        // Close the line if the device is not receive enabled
        //
        pLineInfo = GetTapiLineFromDeviceId (dwUniqueLineId, FALSE);
        if (pLineInfo)
        {
            if (!(pLineInfo->Flags & FPF_RECEIVE)                        &&  // Device is not set to auto-receive and
                pLineInfo->hLine                                         &&  // device is open and
                pLineInfo->PermanentLineID != g_dwManualAnswerDeviceId       // this device is not set to manual answer mode
               )
            {
                //
                // Attempt to close the device
                //
                HLINE hLine = pLineInfo->hLine;
                LONG Rslt;

                pLineInfo->hLine = 0;
                Rslt = lineClose( hLine );
                if (Rslt)
                {
                    if (LINEERR_INVALLINEHANDLE != Rslt)
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("lineClose() for line %s [Permanent Id: %010d] has failed. (ec: %ld)"),
                            pLineInfo->DeviceName,
                            pLineInfo->TapiPermanentLineId,
                            Rslt);
                    }
                    else
                    {
                        //
                        // We can get LINEERR_INVALLINEHANDLE if we got LINE_CLOSE
                        // from TAPI.
                        //
                        DebugPrintEx(
                            DEBUG_WRN,
                            TEXT("lineClose() for line %s [Permanent Id: %010d] reported LINEERR_INVALLINEHANDLE. (May be caused by LINE_CLOSE event)"),
                            pLineInfo->DeviceName,
                            pLineInfo->TapiPermanentLineId
                            );
                    }
                }
            }
        }
        else
        {
            //
            // We must find the line because InitializeTapiLine() did not fail
            //
            ASSERT_FALSE;
        }

        if (!g_pGroupsMap->UpdateAllDevicesGroup())
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRoutingGroupsMap::UpdateAllDevicesGroup() failed (ec: %ld)"),
                ec);

            //
            // We failed to update <All devices> group. Remove the line.
            //
            PLINE_INFO pLineInfo = GetTapiLineFromDeviceId (dwUniqueLineId, FALSE);
            if (pLineInfo)
            {
                RemoveEntryList (&pLineInfo->ListEntry);
                //
                // Update enabled device counter
                //
                if (TRUE == IsDeviceEnabled(pLineInfo))
                {
                    Assert (g_dwDeviceEnabledCount);
                    g_dwDeviceEnabledCount -= 1;
                }
                FreeTapiLine (pLineInfo);
                g_dwDeviceCount -= 1;
             }
             rVal = FALSE;
             goto exit;
        }

        //
        //  Call CreateConfigEvent only when LINE_CREATE event accure during service operation
        //  and not during start up
        //
        ec = CreateConfigEvent (FAX_CONFIG_TYPE_DEVICES);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_DEVICES) failed (ec: %lc)"),
                ec);
        }

        ec = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) failed (ec: %lc)"),
                ec);
        }
    }

    rVal = TRUE;

exit:
    if (DeviceName)
    {
        MemFree( DeviceName );
    }

    if (FALSE == rVal &&
        TRUE == fDeviceAddedToMap)
    {
        DWORD dwRes = g_pTAPIDevicesIdsMap->RemoveDevice (LineDevCaps->dwPermanentLineID);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Cg_pTAPIDevicesIdsMap->RemoveDevice failed (ec: %lc)"),
                dwRes);
        }
    }

    FreeOrigSetupData( &RegSetup );
    EnumerateRoutingMethods( (PFAXROUTEMETHODENUM)NewDeviceRoutingMethodEnumerator, UlongToPtr(dwUniqueLineId) );
    if (FALSE == rVal)
    {
        SetLastError(ec);
    }
    return rVal;
}   // AddNewDevice



DWORD
InitializeTapiLine(
    DWORD DeviceId,
    DWORD dwUniqueLineId,
    LPLINEDEVCAPS LineDevCaps,
    DWORD Rings,
    DWORD Flags,
    LPTSTR Csid,
    LPTSTR Tsid,
    LPTSTR lptstrDescription,
    BOOL fServerInit,
    DWORD dwDeviceType
    )
{
    PLINE_INFO LineInfo = NULL;
    LONG Rslt = ERROR_SUCCESS;
    DWORD len;
    PDEVICE_PROVIDER Provider;
    BOOL UnimodemDevice;
    HLINE hLine = 0;
    LPTSTR ProviderName = NULL;
    LPTSTR DeviceName = NULL;
    BOOL NewDevice = TRUE;
    DWORD LineStates = 0;
    DWORD AddressStates = 0;
    LPLINEDEVSTATUS LineDevStatus;
    DEBUG_FUNCTION_NAME(TEXT("InitializeTapiLine"));

    Assert(dwUniqueLineId);
    //
    // allocate the LINE_INFO structure
    //

    LineInfo = (PLINE_INFO) MemAlloc( sizeof(LINE_INFO) );
    if (!LineInfo)
    {
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    ZeroMemory(LineInfo, sizeof(LINE_INFO));

    //
    // get the provider name
    //

    len = _tcslen( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset) );
    ProviderName = (LPTSTR)(MemAlloc( (len + 1) * sizeof(TCHAR) ));
    if (!ProviderName)
    {
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    _tcscpy( ProviderName, (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset) );

    //
    // get the device name
    //

    DeviceName = FixupDeviceName( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset) );
    if (!DeviceName)
    {
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // verify that the line id is good
    //

    if (LineDevCaps->dwPermanentLineID == 0)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("TAPI lines must have a non-zero line id [%s]"),
                     DeviceName);
        Rslt = ERROR_BAD_DEVICE;
        goto exit;
    }

    //
    // check for a modem device
    //

    UnimodemDevice = IsDeviceModem( LineDevCaps, FAX_MODEM_PROVIDER_NAME );

    //
    // assign the device provider
    //

    Provider = FindDeviceProvider( ProviderName );
    if (!Provider)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Could not find a valid device provider for device: %s"), DeviceName);
        Rslt = ERROR_BAD_PROVIDER;
        goto exit;
    }
    Assert (FAX_PROVIDER_STATUS_SUCCESS == Provider->Status);

    //
    // open the line
    //

    if (UnimodemDevice)
    {
        Rslt = lineOpen(
            g_hLineApp,
            DeviceId,
            &hLine,
            MAX_TAPI_API_VER,
            0,
            (DWORD_PTR) LineInfo,
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_DATAMODEM | LINEMEDIAMODE_UNKNOWN,
            NULL
            );

        if (Rslt != 0)
        {
            Rslt = lineOpen(
                g_hLineApp,
                DeviceId,
                &hLine,
                MAX_TAPI_API_VER,
                0,
                (DWORD_PTR) LineInfo,
                LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
                LINEMEDIAMODE_DATAMODEM,
                NULL
                );
        }
    }
    else
    {
        Rslt = lineOpen(
            g_hLineApp,
            DeviceId,
            &hLine,
            MAX_TAPI_API_VER,
            0,
            (DWORD_PTR) LineInfo,
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_G3FAX,
            NULL
            );
    }

    if (Rslt != 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Device %s FAILED to initialize, ec=%08x"), DeviceName, Rslt);
        goto exit;
    }
    //
    // Set hLine in the LINE_INFO structure so it will be freed on failure
    //
    LineInfo->hLine = hLine;


    //
    // set the line status that we need
    //

    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_OPEN     ? LINEDEVSTATE_OPEN     : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_CLOSE    ? LINEDEVSTATE_CLOSE    : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_RINGING  ? LINEDEVSTATE_RINGING  : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_NUMCALLS ? LINEDEVSTATE_NUMCALLS : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_REMOVED  ? LINEDEVSTATE_REMOVED  : 0;

    AddressStates = LINEADDRESSSTATE_INUSEZERO | LINEADDRESSSTATE_INUSEONE |
                    LINEADDRESSSTATE_INUSEMANY | LINEADDRESSSTATE_NUMCALLS;

    Rslt = lineSetStatusMessages( LineInfo->hLine, LineStates, AddressStates );
    if (Rslt != 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("lineSetStatusMessages() failed, [0x%08x:0x%08x], ec=0x%08x"), LineStates, AddressStates, Rslt);
        if (Rslt == LINEERR_INVALLINEHANDLE)
        {
            LineInfo->hLine = 0;
        }
        Rslt = 0;
    }

    //
    // now assign the necessary values to the line info struct
    //

    LineInfo->Signature             = LINE_SIGNATURE;
    LineInfo->DeviceId              = DeviceId;
    LineInfo->TapiPermanentLineId   = LineDevCaps->dwPermanentLineID;
    LineInfo->Provider              = Provider;
    LineInfo->UnimodemDevice        = UnimodemDevice;
    LineInfo->State                 = FPS_AVAILABLE;
    LineInfo->dwReceivingJobsCount  = 0;
    LineInfo->dwSendingJobsCount    = 0;
    LineInfo->LastLineClose         = 0;

    if (DeviceName)
    {
        LineInfo->DeviceName                  = StringDup( DeviceName );
        if (!LineInfo->DeviceName)
        {
            Rslt = GetLastError ();
            goto exit;
        }
    }
    else
    {
        LineInfo->DeviceName = NULL;
    }

    if (Csid)
    {
        LineInfo->Csid                  = StringDup( Csid );
        if (!LineInfo->Csid)
        {
            Rslt = GetLastError ();
            goto exit;
        }
    }
    else
    {
        LineInfo->Csid = NULL;
    }

    if (Tsid)
    {
        LineInfo->Tsid                  = StringDup( Tsid );
        if (!LineInfo->Tsid)
        {
            Rslt = GetLastError ();
            goto exit;
        }
    }
    else
    {
        LineInfo->Tsid = NULL;
    }

    if (lptstrDescription)
    {
        LineInfo->lptstrDescription                  = StringDup( lptstrDescription );
        if (!LineInfo->lptstrDescription)
        {
            Rslt = GetLastError ();
            goto exit;
        }
    }
    else
    {
        LineInfo->lptstrDescription = NULL;
    }

    LineInfo->RingsForAnswer        = (LineDevCaps->dwLineStates & LINEDEVSTATE_RINGING) ? Rings : 0;
    LineInfo->Flags                 = Flags;
    LineInfo->RingCount             = 0;
    LineInfo->LineStates            = LineDevCaps->dwLineStates;
    LineInfo->PermanentLineID       = dwUniqueLineId;
    LineInfo->dwDeviceType          = dwDeviceType;
    if (LineInfo->hLine)
    {
        //
        // check to see if the line is in use
        //
        LineDevStatus = MyLineGetLineDevStatus( LineInfo->hLine );
        if (LineDevStatus)
        {
            if (LineDevStatus->dwNumOpens > 0 && LineDevStatus->dwNumActiveCalls > 0)
            {
                LineInfo->ModemInUse = TRUE;
            }
            MemFree( LineDevStatus );
        }
    }
    else
    {
        //
        // if we don't have a line handle at this time then the
        // device must be powered off
        //
        DebugPrintEx(DEBUG_ERR, TEXT("Device %s is powered off or disconnected"), DeviceName);
        LineInfo->Flags |= FPF_POWERED_OFF;
        //
        // Since this function is called from TapiInitialize(), we don't have an RPC server up and running yet.
        // Don't create a FAX_EVENT_TYPE_DEVICE_STATUS event.
        //
    }

exit:

    MemFree( DeviceName );
    MemFree( ProviderName );

    if (Rslt == ERROR_SUCCESS)
    {
        InsertTailList( &g_TapiLinesListHead, &LineInfo->ListEntry );
        g_dwDeviceCount += 1;

        if (FALSE == fServerInit)
        {
            //
            // Add cached manual answer device and check device limit
            //
            if (0 == g_dwManualAnswerDeviceId  && // There is no manual answer device
                LineInfo->dwDeviceType == (FAX_DEVICE_TYPE_CACHED | FAX_DEVICE_TYPE_MANUAL_ANSWER) && // this is a cached manual answer device
                !(LineInfo->Flags & FPF_RECEIVE)) // the device is not set to auto receive
            {
                //
                // set this device as manual receive
                //
                g_dwManualAnswerDeviceId = LineInfo->PermanentLineID;
                DWORD dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                        dwRes);
                }
            }

            if (g_dwDeviceEnabledCount >= g_dwDeviceEnabledLimit)
            {
                //
                // We reached device limit on this SKU. set this device's flags to 0.
                //
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("Reached device limit on this SKU. reset device flags to 0. Device limit: %ld. Current device: %ld"),
                    g_dwDeviceEnabledLimit,
                    g_dwDeviceEnabledCount);

                ResetDeviceFlags(LineInfo);
            }
        }

        //
        // Update enabled device counter
        //
        if (TRUE == IsDeviceEnabled(LineInfo))
        {
            g_dwDeviceEnabledCount += 1;
        }
    }
    else
    {
        FreeTapiLine( LineInfo );
    }

    return Rslt;
} // InitializeTapiLine


BOOL
IsVirtualDevice(
    const LINE_INFO *pLineInfo
    )
{
    if (!pLineInfo) {
        return FALSE;
    }

    return (pLineInfo->Provider->dwAPIVersion == FSPI_API_VERSION_1) ?
                (pLineInfo->Provider->FaxDevVirtualDeviceCreation != NULL) :
                (pLineInfo->Provider->FaxDevEnumerateDevices != NULL);
}

VOID
UpdateVirtualDeviceSendAndReceiveStatus(
    PLINE_INFO  pLineInfo,
    BOOL        bSend,
    BOOL        bReceive
)
/*++

Routine name : UpdateVirtualDeviceSendAndReceiveStatus

Routine description:

    Updates a virtual device with the new send and receive flags

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pLineInfo       [in] - Pointer to line information
    bSend           [in] - Can the device send faxes?
    bReceive        [in] - Can the device receive faxes?

Remarks:

    This function should be called with g_CsLine held.

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("UpdateVirtualDeviceSendAndReceiveStatus"));
    if (!IsVirtualDevice(pLineInfo) || !pLineInfo->Provider->FaxDevCallback)
    {
        //
        // Not a virtual device or does not support FaxDevCallback
        //
        return;
    }
    __try
    {
        pLineInfo->Provider->FaxDevCallback( NULL,
                                             pLineInfo->TapiPermanentLineId,
                                             LINE_DEVSPECIFIC,
                                             0,
                                             bReceive,
                                             bSend,
                                             0
                                           );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception in FaxDevCallback, ec = %d"),
            GetExceptionCode());
    }
}   // UpdateVirtualDeviceSendAndReceiveStatus

VOID
UpdateVirtualDevices(
    VOID
    )
{
    PLIST_ENTRY         Next;
    PLINE_INFO          LineInfo = NULL;

    EnterCriticalSection( &g_CsLine );

    Next = g_TapiLinesListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &g_CsLine );
        return;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;
        UpdateVirtualDeviceSendAndReceiveStatus (LineInfo,
                                                 LineInfo->Flags & FPF_SEND,
                                                 LineInfo->Flags & FPF_RECEIVE
                                                );
    }
    LeaveCriticalSection( &g_CsLine );
}


DWORD
CreateVirtualDevices(
    PREG_FAX_SERVICE FaxReg,
    DWORD dwAPIVersion
    )
{
    PLIST_ENTRY         Next;
    PDEVICE_PROVIDER    Provider;
    PLINE_INFO          LineInfo = NULL;
    PREG_DEVICE         FaxDevice = NULL;
    PREG_FAX_DEVICES    FaxDevices = NULL;
    DWORD               dwVirtualDeviceCount = 0;
    REG_SETUP           RegSetup={0};
    DWORD ec;

    DEBUG_FUNCTION_NAME(TEXT("CreateVirtualDevices"));
    Next = g_DeviceProvidersListHead.Flink;
    if (!Next)
    {
        return dwVirtualDeviceCount;
    }

    if (!GetOrigSetupData( 0, &RegSetup ))
    {
        return dwVirtualDeviceCount;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        DWORD dwDeviceCount;

        dwDeviceCount = 0;
        Provider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        Next = Provider->ListEntry.Flink;
        if (Provider->Status != FAX_PROVIDER_STATUS_SUCCESS)
        {
            //
            // This FSP wasn't loaded successfully - skip it
            //
            continue;
        }
        if (Provider->dwAPIVersion != dwAPIVersion)
        {
            //
            // This FSP doesn't match the required API version - skip it
            //
            continue;
        }
        if (FSPI_API_VERSION_1 == Provider->dwAPIVersion)
        {
            if (Provider->FaxDevVirtualDeviceCreation)
            {
                if (!CreateLegacyVirtualDevices(FaxReg, &RegSetup, Provider, &dwDeviceCount))
                {
                    ec = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateLegacyVirtualDevices failed for provider [%s] (ec: %ld)"),
                        Provider->FriendlyName,
                        ec);
                    goto InitializationFailure;
                }
                else
                {
                    DebugPrintEx(
                        DEBUG_MSG,
                        TEXT("%ld Legacy Virtual devices added by provider [%s]"),
                        dwDeviceCount,
                        Provider->FriendlyName,
                        ec);
                }
            }

        }
        else if (FSPI_API_VERSION_2 == Provider->dwAPIVersion)
        {
            if (Provider->FaxDevEnumerateDevices)
            {
                if (!CreateExtendedVirtualDevices(FaxReg,&RegSetup, Provider, &dwDeviceCount))
                {
                    ec = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateExtendedVirtualDevices failed for provider [%s] (ec: %ld)"),
                        Provider->FriendlyName,
                        ec);
                    goto InitializationFailure;
                }
                else
                {
                    DebugPrintEx(
                        DEBUG_MSG,
                        TEXT("%ld Extended Virtual devices added by provider [%s]"),
                        dwDeviceCount,
                        Provider->FriendlyName,
                        ec);
                }
            }

        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Unsupported API Version (0x%08X) for provider [%s]"),
                Provider->dwAPIVersion,
                Provider->FriendlyName);
            Assert(FALSE);
            goto InitializationFailure;
        }

        dwVirtualDeviceCount+= dwDeviceCount;

        goto next;
InitializationFailure:
        Provider->Status = FAX_PROVIDER_STATUS_CANT_INIT;
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_VIRTUAL_DEVICE_INIT_FAILED,
                Provider->FriendlyName
              );
next:
    ;
    }

    DebugPrintEx(DEBUG_MSG, TEXT("Virtual devices initialized, devices=%d"), g_dwDeviceCount);

    FreeOrigSetupData( &RegSetup );

    return dwVirtualDeviceCount;
}


//*********************************************************************************
//* Name:   CreateExtendedVirtualDevices()
//* Author: Ronen Barenboim
//* Date:   May 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates the virtual line devices reported by a single EFSP and adds them
//*     to the line list. Also persists the line information in the registry.
//* PARAMETERS:
//*     [IN]        PREG_FAX_SERVICE FaxReg
//*
//*     [IN]        const REG_SETUP * lpRegSetup
//*
//*     [IN]        const DEVICE_PROVIDER * lpcProvider
//*         A pointer to the provider information.  This should be a virtual
//*         provider.
//*     [OUT]       LPDWORD lpdwDeviceCount
//*         The number of virtual devices actually added.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the creation succeeded.
//*     FALSE
//*         If the creation failed. Call GetLastError() to get extended error
//*         information. an error of ERROR_INVALID_FUNCTION indicates that
//*         the FSP creation function failed.
//*********************************************************************************
BOOL CreateExtendedVirtualDevices(
    PREG_FAX_SERVICE FaxReg,
    const REG_SETUP * lpRegSetup,
    const DEVICE_PROVIDER * lpcProvider,
    LPDWORD lpdwDeviceCount)
{
    PLINE_INFO          LineInfo = NULL;
    HRESULT             hr;
    DWORD               dwDeviceCount =0 ;              // The device count reported by the EFSP.
    LPFSPI_DEVICE_INFO  lpVirtualDevices = NULL;        // The array of virtual device information that the
                                                        // EFSP will fill.
    PREG_DEVICE         lpFaxDevice = NULL;             // Pointer to the registry information for the device
                                                        // it it already exists.
    UINT nDevice;
    PLINE_INFO          * lpAddedLines = NULL;
    DWORD ec = 0;

    DEBUG_FUNCTION_NAME(TEXT("CreateExtendedVirtualDevices"));

    Assert(lpcProvider);
    Assert(lpcProvider->FaxDevEnumerateDevices);
    Assert(lpdwDeviceCount);
    Assert(FaxReg);
    Assert(lpRegSetup);


    (*lpdwDeviceCount) = 0;

    DebugPrintEx(
            DEBUG_MSG,
            TEXT("Enumerating virtual devices for EFSP [%s]."),
            lpcProvider->FriendlyName);


    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Calling FaxDevEnumerateDevices() to get the number of virtual devices."));
    __try
    {
        hr = lpcProvider->FaxDevEnumerateDevices(lpcProvider->dwDevicesIdPrefix,
                                                 &dwDeviceCount,
                                                 NULL);
        if (FAILED(hr))
        {
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevEnumerateDevices() failed when trying to get the device count. (hr: 0x%08X)"),
                hr);
            goto InitializationFailure;
        }
        if (dwDeviceCount > 256)
        {
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("EFSP reported %ld virtual devices. 256 is the limit"),
                dwDeviceCount);

            dwDeviceCount = 256;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevEnumerateDevices() crashed: 0x%08x"),
                GetExceptionCode() );
            goto InitializationFailure;
    }


    DebugPrintEx(
        DEBUG_MSG,
        TEXT("FaxDevEnumerateDevices() succeeded. EFSP reported %ld virtual devices."),
        dwDeviceCount);


    if (0 == dwDeviceCount)
    {
        ec = ERROR_INVALID_FUNCTION;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxDevEnumerateDevices() reported 0 devices."));
        goto InitializationFailure;

    }


    //
    // Allocate the device array
    //
    lpVirtualDevices = (LPFSPI_DEVICE_INFO) MemAlloc(dwDeviceCount * sizeof(FSPI_DEVICE_INFO));
    if (!lpVirtualDevices)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate virtual device info array for %ld devices. (ec: %ld)"),
            dwDeviceCount,
            GetLastError());
        goto InitializationFailure;
    }

    //
    // Call the EFSP to get the actual device information.
    //

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Calling FaxDevEnumerateDevices() to get device information."),
        lpcProvider->FriendlyName);

    __try
    {
            hr = lpcProvider->FaxDevEnumerateDevices(lpcProvider->dwDevicesIdPrefix,
                                                     &dwDeviceCount,
                                                     lpVirtualDevices);
            if (FAILED(hr))
            {
                ec = ERROR_INVALID_FUNCTION;
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxDevEnumerateDevices() failed when trying to get the devices information. (hr: 0x%08X)"),
                    hr);
                goto InitializationFailure;
            }

            DebugPrintEx(
                DEBUG_MSG,
                TEXT("FaxDevEnumerateDevices() returned successfuly."),
                lpcProvider->FriendlyName);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevEnumerateDevices() crashed: 0x%08x"),
                GetExceptionCode() );
            goto InitializationFailure;
    }

    //
    //  Validate the device information array returned by the EFSP
    //  Note: ValidateFSPIDevices() CAN NOT raise an exception (AV) because of invalid array content.
    //
    if (!ValidateFSPIDevices(lpVirtualDevices, dwDeviceCount, lpcProvider->dwDevicesIdPrefix))
    {
        ec = GetLastError();
        if (ERROR_INVALID_DATA != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ValidateFSPIDevices() failed (internally) while trying to validate device ids (ec: %ld)"),
                ec);
            ASSERT_FALSE;
            goto InitializationFailure;
        }
        else
        {
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevEnumerateDevices() returned invalid device information."));
            goto InitializationFailure;

        }
    }

    //
    // Allocate the array that will hold pointers to the lines that we added to the
    // LINE_INFO list. We use it to know which lines to free on error cleanup.
    //
    lpAddedLines = (PLINE_INFO *)MemAlloc(dwDeviceCount * sizeof(PLINE_INFO));
    if (!lpAddedLines)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate PLINE_INFO array. (ec: %ld)"),
            dwDeviceCount,
            GetLastError());
        goto InitializationFailure;
    }
    memset(lpAddedLines, 0, dwDeviceCount * sizeof(PLINE_INFO));

    for (nDevice=0;nDevice < dwDeviceCount; nDevice++)
    {
        UINT    nRegDevice;
        DWORD   dwUniqueLineId;

        //
        // find the registry information for this device
        //
        lpFaxDevice = NULL;
        for (nRegDevice = 0; nRegDevice < FaxReg->DeviceCount; nRegDevice++)
        {
            if (TRUE == FaxReg->Devices[nRegDevice].bValidDevice &&
                !_tcscmp(FaxReg->Devices[nRegDevice].lptstrProviderGuid, lpcProvider->szGUID))
            {
                if( FaxReg->Devices[nRegDevice].TapiPermanentLineID == lpVirtualDevices[nDevice].dwId)
                {
                    lpFaxDevice = &FaxReg->Devices[nRegDevice];
                    break;
                }
            }
        }

        //
        // if the device is new then add it to the registry
        //
        if (!lpFaxDevice)
        {
            //
            // We set the Fax Device Id to be the VEFSP device id - we don't create one on our own
            //
            dwUniqueLineId = lpVirtualDevices[nDevice].dwId;
            RegAddNewFaxDevice(
                &g_dwLastUniqueLineId,
                &dwUniqueLineId,
                lpVirtualDevices[nDevice].szFriendlyName,
                (LPTSTR)lpcProvider->ProviderName,
                (LPTSTR)lpcProvider->szGUID,
                lpRegSetup->Csid,
                lpRegSetup->Tsid,
                lpVirtualDevices[nDevice].dwId,
                FPF_SEND | FPF_VIRTUAL,
                lpRegSetup->Rings
                );
        }
        else
        {
            dwUniqueLineId = lpFaxDevice->PermanentLineId;
            Assert(dwUniqueLineId > 0);
        }


        //
        // allocate the LINE_INFO structure
        //

        LineInfo = (PLINE_INFO) MemAlloc( sizeof(LINE_INFO) );
        if (!LineInfo) {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate LINE_INFO (ec: %ld). DeviceId: %010d DeviceName: %s"),
                GetLastError(),
                lpVirtualDevices[nDevice].dwId,
                lpVirtualDevices[nDevice].szFriendlyName);
            goto InitializationFailure;
        }

        lpAddedLines[*lpdwDeviceCount] = LineInfo;
        //
        // now assign the necessary values to the line info struct
        //

        LineInfo->Signature             = LINE_SIGNATURE;
        LineInfo->DeviceId              = lpVirtualDevices[nDevice].dwId;
        LineInfo->PermanentLineID       = dwUniqueLineId;
        Assert(LineInfo->PermanentLineID > 0);
        LineInfo->TapiPermanentLineId   = lpVirtualDevices[nDevice].dwId; // For Virtual devices the permanent TAPI id is the provider relative id.
        LineInfo->hLine                 = 0;
        LineInfo->Provider              = (PDEVICE_PROVIDER)lpcProvider;
        LineInfo->DeviceName            = StringDup(lpVirtualDevices[nDevice].szFriendlyName);
        LineInfo->UnimodemDevice        = FALSE;
        LineInfo->State                 = FPS_AVAILABLE;
        LineInfo->dwReceivingJobsCount  = 0;
        LineInfo->dwSendingJobsCount    = 0;
        LineInfo->LastLineClose         = 0; // We do not use this for virtual devices
        LineInfo->Csid                  = StringDup( lpFaxDevice ? lpFaxDevice->Csid : lpRegSetup->Csid );
        LineInfo->lptstrDescription     = lpFaxDevice ? StringDup(lpFaxDevice->lptstrDescription) : NULL;

        if (NULL == LineInfo->Csid)
        {   //No memory
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error in call to StringDup. (ec: %ld)"),
                GetLastError());
            goto InitializationFailure;
        }



        LineInfo->Tsid                  = StringDup( lpFaxDevice ? lpFaxDevice->Tsid : lpRegSetup->Tsid );
        if (NULL == LineInfo->Tsid)
        {   // No memory
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error in call to StringDup. (ec: %ld)"),
                GetLastError());
            goto InitializationFailure;
        }

        LineInfo->RingsForAnswer        = 0;
        LineInfo->Flags                 = lpFaxDevice ? lpFaxDevice->Flags : FPF_SEND | FPF_VIRTUAL;
        LineInfo->RingCount             = 0;
        LineInfo->LineStates            = 0;

        InsertTailList( &g_TapiLinesListHead, &LineInfo->ListEntry );

        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Added new extended virtual device. Name: %s RelativeId: %010d UniqueId: %010d"),
            LineInfo->DeviceName,
            LineInfo->DeviceId,
            LineInfo->PermanentLineID);

        (*lpdwDeviceCount)++;
    }

    Assert( (*lpdwDeviceCount) == dwDeviceCount);
    Assert( 0 == ec);
    goto Exit;

InitializationFailure:
    Assert (ec);
    //
    // Remove the added lines
    //
    if (lpAddedLines)
    {
        for (nDevice=0 ;nDevice<dwDeviceCount;nDevice++)
        {
            if (lpAddedLines[nDevice])
            {
                //
                // Remove the LINE_INFO from the line list
                //
                RemoveEntryList(&(lpAddedLines[nDevice]->ListEntry));
                //
                // Free the memory occupied by the LINE_INFO
                //
                FreeTapiLine(lpAddedLines[nDevice]);
                //
                //  Remove the provider ?
                //

            }
        }
    }
    *lpdwDeviceCount = 0; // If we fail with one device then we fail with all devices.

Exit:
    MemFree(lpAddedLines);
    MemFree(lpVirtualDevices);
    if (ec)
    {
        SetLastError(ec);
    }
    return (ec == 0);
}


//*********************************************************************************
//* Name:   CreateLegacyVirtualDevices()
//* Author: Ronen Barenboim
//* Date:   May 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates the virtual line devices reported by a single FSP and adds them
//*     to the line list. Also persists the line information in the registry.
//* PARAMETERS:
//*     [IN]        PREG_FAX_SERVICE FaxReg
//*
//*     [IN]        const REG_SETUP * lpRegSetup
//*
//*     [IN]        const DEVICE_PROVIDER * lpcProvider
//*         A pointer to the provider information.  This should be a virtual
//*         provider.
//*     [OUT]       LPDWORD lpdwDeviceCount
//*         The number of virtual devices actually added.
//*
//* RETURN VALUE:
//*     TRUE
//*         If the creation succeeded.
//*     FALSE
//*         If the creation failed. Call GetLastError() to get extended error
//*         information. an error of ERROR_INVALID_FUNCTION indicates that
//*         the FSP creation function failed.
//*********************************************************************************
BOOL CreateLegacyVirtualDevices(
        PREG_FAX_SERVICE FaxReg,
        const REG_SETUP * lpRegSetup,
        DEVICE_PROVIDER * lpcProvider,
        LPDWORD lpdwDeviceCount)
{
    DWORD               VirtualDeviceCount = 0;
    WCHAR               DevicePrefix[128] = {0};
    DWORD               DeviceIdPrefix;
    LPWSTR              DeviceName = NULL;
    DWORD               i,j;
    PLINE_INFO          LineInfo = NULL;
    PREG_DEVICE         FaxDevice = NULL;
    UINT nDevice;
    PLINE_INFO          * lpAddedLines = NULL;
    DWORD ec = 0;
    PLIST_ENTRY         Next;
    PLINE_INFO          pLineInfo;

    Assert(lpcProvider);
    Assert(lpcProvider->FaxDevVirtualDeviceCreation);
    Assert(lpdwDeviceCount);
    Assert(FaxReg);
    Assert(lpRegSetup);

    DEBUG_FUNCTION_NAME(TEXT("CreateLegacyVirtualDevices"));

    (*lpdwDeviceCount) = 0;

    __try
    {
        if (!lpcProvider->FaxDevVirtualDeviceCreation(
                    &VirtualDeviceCount,
                    DevicePrefix,
                    &DeviceIdPrefix,
                    g_TapiCompletionPort,
                    FAXDEV_EVENT_KEY
                    ))
        {
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevVirtualDeviceCreation failed for provider [%s] (ec: %ld)"),
                lpcProvider->FriendlyName,
                GetLastError());
            goto InitializationFailure;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        ec = ERROR_INVALID_FUNCTION;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxDevVirtualDeviceCreation() crashed: 0x%08x"),
            GetExceptionCode());
        goto InitializationFailure;
    }

    if (VirtualDeviceCount > 0)
    {
        if (VirtualDeviceCount > 256 )
        {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("VirtualDeviceCount returned too many devices (%d)- limit to 256"),
                VirtualDeviceCount);

            VirtualDeviceCount = 256;
        }
        if ((DeviceIdPrefix == 0) || (DeviceIdPrefix >= DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE))
        {
            //
            // Provider uses device ids out of allowed range
            //
            ec = ERROR_INVALID_FUNCTION;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Provider [%s] uses device ids base [%ld] out of allowed range."),
                lpcProvider->FriendlyName,
                DeviceIdPrefix);
            goto InitializationFailure;
        }

        //
        // Check if the range of device IDs does not conflict with an already loaded devices of another provider
        // Range [1 ... DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE-1] : Reserved for VFSPs.
        // Since we cannot dictate the range of device ids the VFSPS use, we allocate a space for them
        // and leave segments allocation to a PM effort here.
        //
        Next = g_TapiLinesListHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
        {
            pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = pLineInfo->ListEntry.Flink;

            if (pLineInfo->PermanentLineID >= DeviceIdPrefix &&
                pLineInfo->PermanentLineID <= DeviceIdPrefix + VirtualDeviceCount)
            {
                //
                // We have a conflict. log an event and do not load the devices
                //
                ec = ERROR_INVALID_FUNCTION;
                FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MIN,
                    2,
                    MSG_FAX_FSP_CONFLICT,
                    lpcProvider->FriendlyName,
                    pLineInfo->Provider->FriendlyName
                  );
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Provider [%s] uses device id [%ld] that conflicts with another FSP [%s]"),
                    lpcProvider->FriendlyName,
                    DeviceIdPrefix,
                    pLineInfo->Provider->FriendlyName
                    );
                goto InitializationFailure;
            }
        }

        lpAddedLines = (PLINE_INFO *)MemAlloc(VirtualDeviceCount * sizeof(PLINE_INFO));
        if (!lpAddedLines)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate PLINE_INFO array. (ec: %ld)"),
                VirtualDeviceCount,
                GetLastError());
            goto InitializationFailure;
        }
        memset(lpAddedLines, 0, VirtualDeviceCount * sizeof(PLINE_INFO));

        for (i = 0; i < VirtualDeviceCount; i++)
        {
            DWORD dwUniqueLineId;
            //
            // create the device name
            //
            __try
            {
                    DeviceName = (LPWSTR) MemAlloc( StringSize(DevicePrefix) + 16 );
                    if (!DeviceName) {
                        ec = GetLastError();
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("MemAlloc() failed for DeviceName (ec: %ld)"),
                            ec);
                        goto InitializationFailure;
                    }

                    swprintf( DeviceName, L"%s%d", DevicePrefix, i );
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                    ec = ERROR_INVALID_FUNCTION;
                    DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("string returned from FaxDevVirtualDeviceCreation() caused a crash: 0x%08x"),
                    GetExceptionCode());
                    goto InitializationFailure;
            }

            //
            // find the registry information for this device
            //
            for (j = 0, FaxDevice = NULL; j < FaxReg->DeviceCount; j++)
            {
                if (TRUE == FaxReg->Devices[j].bValidDevice &&
                    !_tcscmp(FaxReg->Devices[j].lptstrProviderGuid, lpcProvider->szGUID))
                {
                    if (FaxReg->Devices[j].TapiPermanentLineID == DeviceIdPrefix+i)
                    {
                        FaxDevice = &FaxReg->Devices[j];
                        break;
                    }
                }
            }
            //
            // if the device is new then add it to the registry
            //
            if (!FaxDevice)
            {
                //
                // We set the Fax Device Id to be the VFSP device id - we don't create one on our own
                //
                dwUniqueLineId = DeviceIdPrefix + i;
                RegAddNewFaxDevice(
                    &g_dwLastUniqueLineId,
                    &dwUniqueLineId,
                    DeviceName,
                    lpcProvider->ProviderName,
                    lpcProvider->szGUID,
                    lpRegSetup->Csid,
                    lpRegSetup->Tsid,
                    DeviceIdPrefix + i,
                    (lpRegSetup->Flags | FPF_VIRTUAL),
                    lpRegSetup->Rings
                    );
            }
            else
            {
                dwUniqueLineId = FaxDevice->PermanentLineId;
                Assert(dwUniqueLineId > 0);
            }
            //
            // allocate the LINE_INFO structure
            //
            LineInfo = (PLINE_INFO) MemAlloc( sizeof(LINE_INFO) );
            if (!LineInfo)
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to allocate LINE_INFO (ec: %ld). DeviceId: %010d DeviceName: %s"),
                    GetLastError(),
                    DeviceIdPrefix + i,
                    DeviceName);
                goto InitializationFailure;
            }
            //
            // Save a pointer to it so we can free it if we crash ahead
            //
            lpAddedLines[*lpdwDeviceCount] = LineInfo;
            //
            // now assign the necessary values to the line info struct
            //
            LineInfo->Signature             = LINE_SIGNATURE;
            LineInfo->DeviceId              = i;
            LineInfo->TapiPermanentLineId   = DeviceIdPrefix + i;
            LineInfo->PermanentLineID       = dwUniqueLineId;
            Assert(LineInfo->PermanentLineID > 0);
            LineInfo->hLine                 = 0;
            LineInfo->Provider              =  (PDEVICE_PROVIDER)lpcProvider;
            LineInfo->DeviceName            = DeviceName; // Note: DeviceName is heap allocated and need to be freed
            LineInfo->UnimodemDevice        = FALSE;
            LineInfo->State                 = FPS_AVAILABLE;
            LineInfo->Csid                  = StringDup( FaxDevice ? FaxDevice->Csid : lpRegSetup->Csid );
            LineInfo->Tsid                  = StringDup( FaxDevice ? FaxDevice->Tsid : lpRegSetup->Tsid );
            LineInfo->lptstrDescription     = FaxDevice ? StringDup(FaxDevice->lptstrDescription) : NULL;
            LineInfo->RingsForAnswer        = 0;
            LineInfo->RingCount             = 0;
            LineInfo->LineStates            = 0;
            LineInfo->dwReceivingJobsCount  = 0;
            LineInfo->dwSendingJobsCount    = 0;
            LineInfo->LastLineClose         = 0; // We do not use this for virtual devices
            LineInfo->dwDeviceType          = FaxDevice ? FAX_DEVICE_TYPE_OLD : FAX_DEVICE_TYPE_NEW;
            LineInfo->Flags                 = FaxDevice ? FaxDevice->Flags : (lpRegSetup->Flags | FPF_VIRTUAL);

            InsertTailList( &g_TapiLinesListHead, &LineInfo->ListEntry );
            (*lpdwDeviceCount)++;

            //
            // Update enabled device counter
            //
            if (TRUE == IsDeviceEnabled(LineInfo))
            {
                g_dwDeviceEnabledCount += 1;
            }
        }
    }
    else
    {
        ec = ERROR_INVALID_FUNCTION;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxDevVirtualDeviceCreation() reported 0 devices."));
        goto InitializationFailure;
    }


    Assert( (*lpdwDeviceCount) == VirtualDeviceCount);
    Assert (0 == ec);
    goto Exit;

InitializationFailure:
    Assert (0 != ec);
    //
    // Remove the added lines
    //
    if (lpAddedLines)
    {
        for (nDevice=0 ;nDevice < VirtualDeviceCount; nDevice++)
        {
            if (lpAddedLines[nDevice])
            {
                //
                // Remove the LINE_INFO from the line list
                //
                RemoveEntryList(&(lpAddedLines[nDevice]->ListEntry));
                //
                // Update enabled device counter
                //
                if (TRUE == IsDeviceEnabled(lpAddedLines[nDevice]))
                {
                    Assert (g_dwDeviceEnabledCount);
                    g_dwDeviceEnabledCount -= 1;
                }
                //
                // Free the memory occupied by the LINE_INFO
                //
                FreeTapiLine(lpAddedLines[nDevice]);
            }
        }
    }
    (*lpdwDeviceCount) = 0; // If we fail with one device then we fail with all devices.

Exit:
    MemFree(lpAddedLines);
    if (ec)
    {
        SetLastError(ec);
    }

    return ( 0 == ec);
}

DWORD
TapiInitialize(
    PREG_FAX_SERVICE FaxReg
    )

/*++

Routine Description:

    This function performs all necessary TAPI initialization.
    This includes device enumeration, message pump creation,
    device capabilities caputure, etc.  It is required that
    the device provider initialization is completed before
    calling this function.

Arguments:

    None.

Return Value:

    Error code.

--*/

{
    LONG Rslt;
    DWORD i,j;
    LPLINEDEVCAPS LineDevCaps = NULL;
    PREG_FAX_DEVICES FaxDevices = NULL;
    LINEINITIALIZEEXPARAMS LineInitializeExParams;
    TCHAR FaxSvcName[MAX_PATH*2];
    TCHAR Fname[_MAX_FNAME];
    TCHAR Ext[_MAX_EXT];
    DWORD LocalTapiApiVersion;
    LINEEXTENSIONID lineExtensionID;
    DWORD ec = 0;
    DWORDLONG dwlTimeNow;
    DWORD dwTapiDevices;


    DEBUG_FUNCTION_NAME(TEXT("TapiInitialize"));

    GetSystemTimeAsFileTime((FILETIME *)&dwlTimeNow);

    if (!LoadAdaptiveFileBuffer())  // Note: allocates AdaptiveFileBuffer (take care to delete it if error occurs later on)
    {
        if ( ERROR_FILE_NOT_FOUND == GetLastError()  )
        {
            //
            // We can live without the adaptive file buffer.
            //
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("AdaptiveFileBuffer (faxadapt.lst) not found."));
            ec = 0;
        }
        else
        {
            //
            // This is an unexpected error (no memory , file system error) we exit.
            //

            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LoadAdaptiveFileBuffer() failed (ec: %ld)"),
                ec);
            goto Error;
        }
    }

    //
    // we need to hold onto this cs until tapi is up and ready to serve
    //
    EnterCriticalSection( &g_CsLine );

    //
    // initialize tapi
    //
    g_TapiCompletionPort = CreateIoCompletionPort(
        INVALID_HANDLE_VALUE,
        NULL,
        0,
        1
        );
    if (!g_TapiCompletionPort)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateIoCompletionPort() failed (ec: %ld)"),
            ec);
        LeaveCriticalSection( &g_CsLine );
        goto Error;
    }

    LineInitializeExParams.dwTotalSize              = sizeof(LINEINITIALIZEEXPARAMS);
    LineInitializeExParams.dwNeededSize             = 0;
    LineInitializeExParams.dwUsedSize               = 0;
    LineInitializeExParams.dwOptions                = LINEINITIALIZEEXOPTION_USECOMPLETIONPORT;
    LineInitializeExParams.Handles.hCompletionPort  = g_TapiCompletionPort;
    LineInitializeExParams.dwCompletionKey          = TAPI_COMPLETION_KEY;

    LocalTapiApiVersion = MAX_TAPI_API_VER;

    Rslt = lineInitializeEx(
        &g_hLineApp,
        GetModuleHandle(NULL),
        NULL,
        FAX_SERVICE_DISPLAY_NAME,
        &dwTapiDevices,
        &LocalTapiApiVersion,
        &LineInitializeExParams
        );

    if (Rslt != 0)
    {
        ec = Rslt;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lineInitializeEx() failed devices=%d (ec: %ld)"),
            dwTapiDevices,
            ec);
        LeaveCriticalSection( &g_CsLine );
        goto Error;
    }

    if (LocalTapiApiVersion < MIN_TAPI_API_VER)
    {
        ec = LINEERR_INCOMPATIBLEAPIVERSION;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Unsupported TAPI API ver (Ver: %ld)"),
            LocalTapiApiVersion);
        LeaveCriticalSection( &g_CsLine );
        goto Error;
    }

    if (!GetModuleFileName( NULL, FaxSvcName, (sizeof(FaxSvcName)/sizeof(FaxSvcName))))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetModuleFileName for fax service module failed (ec: %ld)"),
            ec);
        LeaveCriticalSection( &g_CsLine );
        goto Error;
    }
    else
    {
        _tsplitpath( FaxSvcName, NULL, NULL, Fname, Ext );
        _stprintf( FaxSvcName, TEXT("%s%s"), Fname, Ext );

        Rslt = lineSetAppPriority(
            FaxSvcName,
            LINEMEDIAMODE_UNKNOWN,
            0,
            0,
            NULL,
            1
            );

        Rslt = lineSetAppPriority(
            FaxSvcName,
            LINEMEDIAMODE_DATAMODEM,
            0,
            0,
            NULL,
            1
            );

        if (Rslt != 0)
        {
            ec = Rslt;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("lineSetAppPriority() failed (ec: %ld)"),
                ec );
            LeaveCriticalSection( &g_CsLine );
            goto Error;

        }
    }

    //
    // add any new devices to the registry
    //
    FaxDevices = GetFaxDevicesRegistry();

    if (!FaxDevices)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFaxDevicesRegistry() failed in TapiInitialize. continueing to add devices into registry")
            );
    }

    for (i = 0; i < dwTapiDevices; i++)
    {
        Rslt = lineNegotiateAPIVersion
        (
            g_hLineApp,
            i,
            MIN_TAPI_LINE_API_VER,
            MAX_TAPI_LINE_API_VER,
            &LocalTapiApiVersion,
            &lineExtensionID
            );
        if (Rslt == 0)
        {
            LineDevCaps = SmartLineGetDevCaps (g_hLineApp, i, LocalTapiApiVersion );
            if (LineDevCaps)
            {
                if (!AddNewDevice( i, LineDevCaps, TRUE , FaxDevices))
                {

                    DebugPrintEx(
                        DEBUG_WRN,
                        TEXT("AddNewDevice() failed for device id: %ld (ec: %ld)"),
                        i,
                        GetLastError());

                    MemFree( LineDevCaps );
                }
                else
                {
                    MemFree( LineDevCaps );
                }
            }
            else
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SmartLineGetDevCaps failed for device id: %ld (ec: %ld)"),
                    i,
                    GetLastError());
                Assert(FALSE);
            }
        }
        else
        {

            DebugPrintEx(
                DEBUG_WRN,
                TEXT("lineNegotiateAPIVersion() failed for device id: %ld (ec: %ld)"),
                i,
                GetLastError());
        }
    }

    //
    // Delete any devices that need deletion
    //
    for (j = 0; j < FaxDevices->DeviceCount; j++)
    {
        //
        // skip any devices not created by us (created by FSPs) and virtual devices
        //
        if(!FaxDevices->Devices[j].bValidDevice ||
           FaxDevices->Devices[j].Flags & FPF_VIRTUAL) // Cache is not supported for VFSPs
        {
            continue;
        }

        if(!FaxDevices->Devices[j].DeviceInstalled)
        {
            //
            // update "LastDetected" field on installed devices
            //
            MoveDeviceRegIntoDeviceCache(
                FaxDevices->Devices[j].PermanentLineId,
                FaxDevices->Devices[j].TapiPermanentLineID,
                (FaxDevices->Devices[j].PermanentLineId == g_dwManualAnswerDeviceId));
        }
    }

    //
    //  Cache cleanning
    //
    CleanOldDevicesFromDeviceCache(dwlTimeNow);

    if (!GetCountries())
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Can't init Countries list"));
        if (!(ec = GetLastError()))
            ec = ERROR_GEN_FAILURE;
        LeaveCriticalSection( &g_CsLine );
        goto Error;

    }

    LeaveCriticalSection( &g_CsLine );

    goto Exit;

Error:
     if (g_hLineApp)
     {
         Rslt = lineShutdown(g_hLineApp);
         if (Rslt)
         {
             DebugPrintEx(
                 DEBUG_ERR,
                 TEXT("lineShutdown() failed (ec: %ld)"),
                 Rslt);
             Assert(FALSE);
         }
         g_hLineApp = NULL;
     }

    if (g_TapiCompletionPort)
    {
        if (!CloseHandle( g_TapiCompletionPort ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle( g_TapiCompletionPort ) failed (ec: %ld)"),
                GetLastError());
            Assert(FALSE);
        }
        g_TapiCompletionPort = NULL;
    }
    MemFree(g_pAdaptiveFileBuffer);
    g_pAdaptiveFileBuffer = NULL;


Exit:
     FreeFaxDevicesRegistry( FaxDevices );

     return ec;

}





BOOL IsExtendedVirtualLine (PLINE_INFO lpLineInfo)
{
    Assert(lpLineInfo);

    if (lpLineInfo->Provider->FaxDevEnumerateDevices)
    {
        Assert (FSPI_API_VERSION_2 ==lpLineInfo->Provider->dwAPIVersion );
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}



BOOL LoadAdaptiveFileBuffer()
{
    DWORD ec = 0;
    DWORD i, j;
    HANDLE AdaptiveFileHandle = INVALID_HANDLE_VALUE;
    LPTSTR AdaptiveFileName  = NULL;

    DEBUG_FUNCTION_NAME(TEXT("LoadAdaptiveFileBuffer"));
    //
    // open faxadapt.lst file to decide on enabling rx
    //
    g_pAdaptiveFileBuffer = NULL;

    AdaptiveFileName = ExpandEnvironmentString( TEXT("%systemroot%\\system32\\faxadapt.lst") );
    if (!AdaptiveFileName)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ExpandEnvironmentString(\"%systemroot%\\system32\\faxadapt.lst\") failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    AdaptiveFileHandle = CreateFile(
        AdaptiveFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (AdaptiveFileHandle == INVALID_HANDLE_VALUE )
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Could not open adaptive file [%s] (ec: %ld)"),
            _tcslwr(AdaptiveFileName),
            ec);
        goto Error;
    }


    i = GetFileSize( AdaptiveFileHandle, NULL );
    if (i != 0xffffffff)
    {
        g_pAdaptiveFileBuffer = (LPBYTE)MemAlloc( i + 16 );
        if (!g_pAdaptiveFileBuffer)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocated g_pAdaptiveFileBuffer (%ld bytes) (ec: %ld)"),
                i + 16,
                ec);
            goto Error;
        }
        if (!ReadFile( AdaptiveFileHandle, g_pAdaptiveFileBuffer, i, &j, NULL ) ) {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Could not read adaptive file [%s] (ec: %ld)"),
                _tcslwr(AdaptiveFileName),
                ec);
            goto Error;
        } else {
            g_pAdaptiveFileBuffer[j] = 0;  // need a string
        }
    }

    Assert (0 == ec);
    goto Exit;

Error:
    MemFree( g_pAdaptiveFileBuffer );
    g_pAdaptiveFileBuffer = NULL;

Exit:
    MemFree( AdaptiveFileName);

    if (AdaptiveFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle( AdaptiveFileHandle );
    }

    if (ec) {
        SetLastError(ec);
    }

    return (0 == ec);
}

//*********************************************************************************
//* Name:   ValidateFSPIDevices()
//* Author: Ronen Barenboim
//* Date:   June 20, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Validates an array of EFSP provided device information structures.
//* PARAMETERS:
//*     [IN ]   const FSPI_DEVICE_INFO * lpcDevices
//*         Points to an array of FSPI_DEVICE_INFO structures to validate.
//*     [IN ]    DWORD dwDeviceCount
//*         The number of devices in the array.
//*     [IN ]    DWORD dwDevicesPrefix
//*         The prefix of the device ids.
//*         All the device ids must be in the range
//*            [dwDevicesPrefix...dwDevicesPrefix+EFSPI_MAX_DEVICE_COUNT-1]
//* RETURN VALUE:
//*     TRUE
//*         All the devices were validated to be ok.
//*     FALSE
//*         A device was found to be invalid or an error occured.
//*         Call GetLastError() to get extended error information. If it is
//*         not ERROR_INVALID_DATA then an internal error (i.e. out of memory)
//*         has occured while trying to validate the array.
//*         if it is ERROR_INVALID_DATA the array was found to be invalid.
//*********************************************************************************
BOOL ValidateFSPIDevices(const FSPI_DEVICE_INFO * lpcDevices,
                         DWORD dwDeviceCount,
                         DWORD dwDevicesPrefix)
{

    set<DWORD> HandleSet;                       // A set (unique elements) of handles. We put the handles
                                                // in it check if they are indeed unique.
    pair<set<DWORD>::iterator, bool> pair;

    DWORD dwNameLen;

    DWORD dwDevice;

    DEBUG_FUNCTION_NAME(TEXT("ValidateFSPIDevices"));

    Assert(lpcDevices);
    Assert(dwDeviceCount > 0);

    for (dwDevice = 0; dwDevice < dwDeviceCount; dwDevice++)
    {
        if (0 == lpcDevices[dwDevice].dwId)
        {
            //
            // Found a 0 device id.
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("device id value of 0 found at index %ld"),
                dwDevice);
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }
        if ((lpcDevices[dwDevice].dwId <  dwDevicesPrefix) ||
            (lpcDevices[dwDevice].dwId >= dwDevicesPrefix + EFSPI_MAX_DEVICE_COUNT))
        {
            //
            // Device id is not in allocated range
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("device id value of %ld found at index %ld. Valid range is [%ld...%ld]"),
                lpcDevices[dwDevice].dwId,
                dwDevice,
                dwDevicesPrefix,
                dwDevicesPrefix + EFSPI_MAX_DEVICE_COUNT - 1);
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }
        if (lpcDevices[dwDevice].dwSizeOfStruct != sizeof(FSPI_DEVICE_INFO))
        {
            //
            // Found a bad structure size.
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid device id structure size [%ld] at index %ld"),
                lpcDevices[dwDevice].dwSizeOfStruct,
                dwDevice);
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        if (!SafeTcsLen(lpcDevices[dwDevice].szFriendlyName, &dwNameLen))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to calcualte length of invalid device name at index %ld (ec: %ld)"),
                dwDevice,
                GetLastError());
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        if ( 0 == dwNameLen )
        {
            //
            // Found an empty device name
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid empty device name at index %ld"),
                dwDevice);
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        if (dwNameLen >= FSPI_MAX_FRIENDLY_NAME)
        {
            //
            // Found a device name longer than the max device name
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid device name at index %ld. Device name length >= FSPI_MAX_FRIENDLY_NAME."),
                dwDevice);
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        //
        // check for uniqueness of device ids
        //

        try
        {
            pair = HandleSet.insert(lpcDevices[dwDevice].dwId);
        }
        catch(...)
        {
            //
            // set::insert failed because of memory shortage
            //
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        if (false == pair.second)
        {
            //
            // Element already exists in the set. I.e. we have duplicate handles
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Duplicate device id (%010d) found at index : %ld"),
                lpcDevices[dwDevice].dwId,
                dwDevice);
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;

        }
    }
    return TRUE;
}


LONG
MyLineTranslateAddress(
    LPCTSTR               Address,
    DWORD                 DeviceId,
    LPLINETRANSLATEOUTPUT *TranslateOutput
    )
{
    DWORD LineTransOutSize;
    LONG Rslt = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(_T("MyLineTranslateAddress"));

    //
    // allocate the initial linetranscaps structure
    //
    LineTransOutSize = sizeof(LINETRANSLATEOUTPUT) + 4096;
    *TranslateOutput = (LPLINETRANSLATEOUTPUT) MemAlloc( LineTransOutSize );
    if (!*TranslateOutput)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc() failed, sz=0x%08x"), LineTransOutSize);
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    (*TranslateOutput)->dwTotalSize = LineTransOutSize;

    Rslt = lineTranslateAddress(
        g_hLineApp,
        0,
        MAX_TAPI_API_VER,
        Address,
        0,
        0,
        *TranslateOutput
        );

    if (Rslt != 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("lineGetTranslateAddress() failed, ec=0x%08x"), Rslt);
        goto exit;
    }

    if ((*TranslateOutput)->dwNeededSize > (*TranslateOutput)->dwTotalSize)
    {
        //
        // re-allocate the LineTransCaps structure
        //
        LineTransOutSize = (*TranslateOutput)->dwNeededSize;

        MemFree( *TranslateOutput );

        *TranslateOutput = (LPLINETRANSLATEOUTPUT) MemAlloc( LineTransOutSize );
        if (!*TranslateOutput)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("MemAlloc() failed, sz=0x%08x"), LineTransOutSize);
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        (*TranslateOutput)->dwTotalSize = LineTransOutSize;

        Rslt = lineTranslateAddress(
            g_hLineApp,
            0,
            MAX_TAPI_API_VER,
            Address,
            0,
            0,
            *TranslateOutput
            );

        if (Rslt != 0)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("lineGetTranslateAddress() failed, ec=0x%08x"), Rslt);
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS)
    {
        MemFree( *TranslateOutput );
        *TranslateOutput = NULL;
    }
    return Rslt;
}





BOOL CreateTapiThread(void)
{
    HANDLE hThread = NULL;
    DWORD ThreadId;
    DWORD ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("CreateTapiThread"));

    hThread = CreateThreadAndRefCount(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) TapiWorkerThread,
        NULL,
        0,
        &ThreadId
        );

    if (!hThread)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Could not start TapiWorkerThread (CreateThreadAndRefCount)(ec: %ld)"),
            ec);
         goto Error;
    }
    Assert (ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert (ERROR_SUCCESS != ec);
Exit:
    //
    // Close the thread handle
    //
    if (!CloseHandle(hThread))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to close thread handle [handle = 0x%08X] (ec=0x%08x)."),
            hThread,
            GetLastError());
    }

    if (ec)
    {
        SetLastError(ec);
    }
    return (ERROR_SUCCESS == ec);
}


DWORD
GetDeviceListByCountryAndAreaCode(
    DWORD       dwCountryCode,
    DWORD       dwAreaCode,
    LPDWORD*    lppdwDevices,
    LPDWORD     lpdwNumDevices
    )
/*++

Routine name : GetDeviceListByCountryAndAreaCode

Routine description:

    Returns an ordered list of devices that are a rule destination.
    The rule is  specified by country and area code.
    The caller must call MemFree() to deallocate memory.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwCountryCode       [in    ] - Country code
    dwAreaCode          [in    ] - Area code
    lppdwDevices        [out   ] - Pointer to recieve the device list
    lpdwNumDevices      [out   ] - pointer to recieve the number of devices in the list

Return Value:

    Standard win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("GetDeviceListByCountryAndAreaCode"));
    DWORD ec = ERROR_SUCCESS;

    Assert (lppdwDevices && lpdwNumDevices);

    CDialingLocation DialingLocation(dwCountryCode, dwAreaCode);
    //
    // Search for CountryCode.AreaCode
    //
    PCRULE pCRule = g_pRulesMap->FindRule (DialingLocation);
    if (NULL == pCRule)
    {
        ec = GetLastError();
        if (FAX_ERR_RULE_NOT_FOUND != ec)
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRulesMap::FindRule failed with error %ld"),
                ec);
             goto exit;
        }
        //
        // Search for CountryCode.*
        //
        DialingLocation = CDialingLocation(dwCountryCode, ROUTING_RULE_AREA_CODE_ANY);
        pCRule = g_pRulesMap->FindRule (DialingLocation);
        if (NULL == pCRule)
        {
            ec = GetLastError();
            if (FAX_ERR_RULE_NOT_FOUND != ec)
            {
                 DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("COutboundRulesMap::FindRule failed with error %ld"),
                    ec);
                 goto exit;
            }
            //
            // Search for *.*
            //
            DialingLocation = CDialingLocation(ROUTING_RULE_COUNTRY_CODE_ANY, ROUTING_RULE_AREA_CODE_ANY);
            pCRule = g_pRulesMap->FindRule (DialingLocation);
            if (NULL == pCRule)
            {
                ec = GetLastError();
                if (FAX_ERR_RULE_NOT_FOUND != ec)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("COutboundRulesMap::FindRule failed with error %ld"),
                        ec);
                     goto exit;
                }
            }
        }
    }

    if (NULL == pCRule)
    {
        // No rule found!!!
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("No outbound routing rule found"));
        *lppdwDevices = NULL;
        *lpdwNumDevices = 0;
        ec = ERROR_NOT_FOUND;
        Assert (NULL != pCRule) // Assert (FALSE)
        goto exit;
    }
    else
    {
        ec = pCRule->GetDeviceList (lppdwDevices, lpdwNumDevices);
        if (ERROR_SUCCESS != ec)
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("COutboundRule::GetDeviceList failed with error %ld"),
                ec);
             goto exit;
        }
    }
    Assert (ERROR_SUCCESS == ec);

exit:
    return ec;
}


BOOL
IsAreaCodeMandatory(
    LPLINECOUNTRYLIST   lpCountryList,
    DWORD               dwCountryCode
    )
/*++

Routine name : IsAreaCodeMandatory

Routine description:

    Checks if an area code is mandatory for a specific country

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpCountryList           [in    ] - Pointer to LINECOUNTRYLIST list, returned from a call to LineGetCountry
    dwCountryCode           [in    ] - The country country code.

Return Value:

    TRUE - The area code is needed.
    FALSE - The area code is not mandatory.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("IsAreaCodeMandatory"));
    LPLINECOUNTRYENTRY          lpEntry = NULL;
    DWORD                       dwIndex;

    Assert (lpCountryList);

    lpEntry = (LPLINECOUNTRYENTRY)  // init array of entries
        ((PBYTE) lpCountryList + lpCountryList->dwCountryListOffset);
    for (dwIndex=0; dwIndex < lpCountryList->dwNumCountries; dwIndex++)
    {
        if (lpEntry[dwIndex].dwCountryCode == dwCountryCode)
        {
            //
            // Matching country code - Check long distance rule.
            //
            if (lpEntry[dwIndex].dwLongDistanceRuleSize  && lpEntry[dwIndex].dwLongDistanceRuleOffset )
            {
                LPWSTR lpwstrLongDistanceDialingRule = (LPWSTR)((LPBYTE)lpCountryList +
                                                                lpEntry[dwIndex].dwLongDistanceRuleOffset);
                if (wcschr(lpwstrLongDistanceDialingRule, TEXT('F')) != NULL)
                {
                    return TRUE;
                }
                return FALSE;
            }
        }
    }
    return FALSE;
}

VOID
UpdateReceiveEnabledDevicesCount ()
/*++

Routine name : UpdateReceiveEnabledDevicesCount

Routine description:

    Updates the counter of the number of devices that are enabled to receive faxes

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:


Return Value:

    None

--*/
{
    PLIST_ENTRY pNext;
    DWORD dwOldCount;
    BOOL fManualDeviceFound = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("UpdateReceiveEnabledDevicesCount"));

#if DBG
    DWORD dwEnabledDevices = 0;
    DWORD dwDevices        = 0;
#endif

    EnterCriticalSection( &g_CsLine );
    dwOldCount = g_dwReceiveDevicesCount;
    g_dwReceiveDevicesCount = 0;
    pNext = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_TapiLinesListHead)
    {
        PLINE_INFO  pLineInfo = CONTAINING_RECORD( pNext, LINE_INFO, ListEntry );
        pNext = pLineInfo->ListEntry.Flink;

        if (g_dwManualAnswerDeviceId == pLineInfo->PermanentLineID)
        {
            fManualDeviceFound = TRUE;
        }

        if ((pLineInfo->Flags) & FPF_RECEIVE)
        {
            if (g_dwManualAnswerDeviceId == pLineInfo->PermanentLineID)
            {
                DebugPrintEx(DEBUG_WRN,
                             TEXT("Device %ld is set to auto-receive AND manual-receive. Canceling the manual-receive for it"),
                             g_dwManualAnswerDeviceId);
                g_dwManualAnswerDeviceId = 0;
                DWORD dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
                if (ERROR_SUCCESS != dwRes)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                        dwRes);
                }
            }
            g_dwReceiveDevicesCount++;
        }
#if DBG
        if (TRUE == IsDeviceEnabled(pLineInfo))
        {
            dwEnabledDevices += 1;
        }
        dwDevices += 1;
#endif
    }

#if DBG
    Assert (dwEnabledDevices == g_dwDeviceEnabledCount);
    Assert (dwDevices == g_dwDeviceCount);
#endif

    if (FALSE == fManualDeviceFound &&
        0 != g_dwManualAnswerDeviceId)
    {
        //
        // There manual answer device id is not valid
        //
        g_dwManualAnswerDeviceId = 0;
        DWORD dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                dwRes);
        }
    }

    DebugPrintEx(DEBUG_MSG,
                 TEXT("Number of receive-enabled devices is now %ld"),
                 g_dwReceiveDevicesCount);

    LeaveCriticalSection( &g_CsLine );
}   // UpdateReceiveEnabledDevicesCount



BOOL
RemoveTapiDevice(
    DWORD dwDeviceId
    )
{
    DWORD ec = ERROR_SUCCESS;
    BOOL rVal = TRUE;
    PLINE_INFO pLineInfo = NULL;
    PLIST_ENTRY Next;
    DWORD dwPermanentTapiDeviceId;
    DWORD dwPermanentLineID;

    BOOL fFound = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("RemoveTapiDevice"));

    Next = g_TapiLinesListHead.Flink;
    Assert (Next);
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;
        if (!(pLineInfo->Flags & FPF_VIRTUAL) &&  // Virtual devices may have the same device id (device index) as the Tapi session id
                                                  // We do not support removal of VFSP device
            dwDeviceId == pLineInfo->DeviceId)
        {
            dwPermanentTapiDeviceId = pLineInfo->TapiPermanentLineId;
            dwPermanentLineID = pLineInfo->PermanentLineID;
            fFound = TRUE;
            break;
        }
    }
    if (FALSE == fFound)
    {
        //
        // Can be if for some reason the device was not added.
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("failed to find line for device id: %ld)"),
            dwDeviceId);
        SetLastError(ERROR_NOT_FOUND);
        return FALSE;
    }

    RemoveEntryList (&pLineInfo->ListEntry);
    InsertTailList (&g_RemovedTapiLinesListHead, &pLineInfo->ListEntry);
    Assert (g_dwDeviceCount);
    g_dwDeviceCount -= 1;

    MoveDeviceRegIntoDeviceCache(
        dwPermanentLineID,
        dwPermanentTapiDeviceId,
        (dwPermanentLineID == g_dwManualAnswerDeviceId));

    //
    // Update Enabled devices count
    //
    if (TRUE == IsDeviceEnabled(pLineInfo))
    {
        Assert (g_dwDeviceEnabledCount);
        g_dwDeviceEnabledCount -= 1;
    }

    if (dwPermanentLineID == g_dwManualAnswerDeviceId)
    {
        g_dwManualAnswerDeviceId = 0;
        DWORD dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                dwRes);
        }
    }

    ec = g_pTAPIDevicesIdsMap->RemoveDevice (dwPermanentTapiDeviceId);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("g_pTAPIDevicesIdsMap->RemoveDevice() failed for Tapi device id: %ld (ec: %ld)"),
            dwPermanentTapiDeviceId,
            ec);
        rVal = FALSE;
    }

    //
    // Update outbound routing
    //
    ec = g_pGroupsMap->RemoveDevice(dwPermanentLineID);
    if (ERROR_SUCCESS != ec)
    {
         DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::RemoveDevice() failed (ec: %ld)"),
            ec);
         rVal = FALSE;
    }

    if (TRUE == rVal)
    {
        DWORD dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_DEVICES);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_DEVICES) (ec: %lc)"),
                dwRes);
        }

        dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_OUT_GROUPS);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUT_GROUPS) (ec: %lc)"),
                dwRes);
        }
    }
    else
    {
        Assert (ERROR_SUCCESS != ec);
        SetLastError(ec);
    }
    return rVal;
}

BOOL
IsDeviceEnabled(
    PLINE_INFO pLineInfo
    )
/*++

Routine name : IsDeviceEnabled

Routine description:

    Checks if a device is send or receive or manual receive enabled
    Must be called inside G_CsLine

Author:

    Oded Sacher (OdedS), Feb, 2001

Arguments:


Return Value:

    TRUE if enabled. FALSE if not

--*/
{
    Assert (pLineInfo);
    if ((pLineInfo->Flags & FPF_RECEIVE) ||
        (pLineInfo->Flags & FPF_SEND)    ||
        pLineInfo->PermanentLineID == g_dwManualAnswerDeviceId)
    {
        //
        // The device was send/receive/manual receive enabled
        //
        return TRUE;
    }
    return FALSE;
}



/*++

Routine name : CleanOldDevicesFromDeviceCache


Routine description:

    The routine scan the device-cache and remove old entries (by DEFAULT_REGVAL_MISSING_DEVICE_LIFETIME constant).

Author:

    Caliv Nir (t-nicali), Apr, 2001

Arguments:

    dwlTimeNow  [in] - current time in UTC ( result of GetSystemTimeAsFileTime )


Return Value:

    ERROR_SUCCESS - when all devices was checked and cleaned

--*/
DWORD
CleanOldDevicesFromDeviceCache(DWORDLONG dwlTimeNow)
{
    DWORDLONG   dwOldestDate = dwlTimeNow - DEFAULT_REGVAL_MISSING_DEVICE_LIFETIME;     // oldest date allowed for cache device
    HKEY        hKeyCache   = NULL;
    DWORDLONG*  pDeviceDate;
    DWORD       dwDataSize = sizeof(DWORDLONG);
    DWORD       dwTapiPermanentLineID;

    DWORD       dwKeyNameLen;
    DWORD       dwIndex ;

    DWORD       dwRes = ERROR_SUCCESS;

    PTSTR       pszKeyName= NULL;

    vector<DWORD>   vecCacheEntryForDeletion;
    vector<DWORD>::const_iterator   iteratorVec;
    vector<DWORD>::const_iterator   iteratorEnd;

    DEBUG_FUNCTION_NAME(TEXT("CleanOldDevicesFromDeviceCache"));


    //  open cache registry entry
    hKeyCache = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_DEVICES_CACHE, FALSE, KEY_READ );
    if (!hKeyCache)
    {
        //
        //  No Device cache is present yet
        //
        dwRes = GetLastError();
        DebugPrintEx(
                DEBUG_WRN,
                TEXT("OpenRegistryKey failed with [%lu] for [%s] . Device cache still wasn't created."),
                dwRes,
                REGKEY_FAX_DEVICES_CACHE
                );
        return  dwRes;
    }


    // get length of longest key name in characrter
    DWORD dwMaxSubKeyLen;

    dwRes = RegQueryInfoKey(hKeyCache, NULL, NULL, NULL, NULL, &dwMaxSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL);

    if ( ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegQueryInfoKey failed with [%lu] for [%s]."),
                dwRes,
                REGKEY_FAX_DEVICES_CACHE
                );
        goto Exit;
    }

    // Add one for the NULL terminator
    dwMaxSubKeyLen++;

    // Allocate buffer for subkey names
    pszKeyName = (PTSTR) MemAlloc(dwMaxSubKeyLen * sizeof(TCHAR));
    if ( NULL == pszKeyName )
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("MemAlloc failure")
                );
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Store buffer length
    dwKeyNameLen = dwMaxSubKeyLen;

    // Start from the begining
    dwIndex = 0;

    while ( ERROR_SUCCESS == RegEnumKeyEx(hKeyCache, dwIndex++, pszKeyName, &dwKeyNameLen, NULL, NULL, NULL, NULL) )
    {
        HKEY    hKeyDevice;

        hKeyDevice = OpenRegistryKey( hKeyCache, pszKeyName, FALSE, KEY_READ );
        if (!hKeyDevice)
        {
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("OpenRegistryKey failed for [%s]."),
                pszKeyName
                );

            goto Next;
        }

        //
        //  get caching time
        //
        pDeviceDate = (DWORDLONG *)GetRegistryBinary(hKeyDevice, REGVAL_LAST_DETECTED_TIME, &dwDataSize);

        if ( (NULL == pDeviceDate) || (*pDeviceDate < dwOldestDate) )
        {
            //
            //  mark for deletion old or illegal cache-entry
            //
            _stscanf( pszKeyName, TEXT("%lx"),&dwTapiPermanentLineID );
            try{
                vecCacheEntryForDeletion.push_back(dwTapiPermanentLineID);
            }
            catch(...)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("push back failed throwing an exception")
                );
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                MemFree(pDeviceDate);
                RegCloseKey (hKeyDevice);
                goto Exit;
            }
        }

        MemFree(pDeviceDate);
        RegCloseKey (hKeyDevice);

Next:
        // restore buffer length
        dwKeyNameLen = dwMaxSubKeyLen;
    }

    try{
        iteratorEnd = vecCacheEntryForDeletion.end();

        for ( iteratorVec = vecCacheEntryForDeletion.begin() ; iteratorVec != iteratorEnd; ++iteratorVec )
        {
            dwTapiPermanentLineID = vecCacheEntryForDeletion.back();
            DeleteCacheEntry(dwTapiPermanentLineID);
            vecCacheEntryForDeletion.pop_back();
        }
    }
    catch (...)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("vector operation failed throwing an exception, abort cleanning")
        );
    }


Exit:

    MemFree(pszKeyName);
    RegCloseKey (hKeyCache);

    return dwRes;
}


DWORD
UpdateDevicesFlags(
    void
    )
/*++

Routine name : UpdateDevicesFlags


Routine description:

    Updates new devices flags ,so we will not exceed device limit on this SKU

Author:

    Sacher Oded (odeds), May, 2001

Arguments:

    None


Return Value:

    Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    PLIST_ENTRY Next;
    PLINE_INFO pLineInfo;
    DEBUG_FUNCTION_NAME(TEXT("UpdateDevicesFlags"));

    //
    // loop thru the devices and reset flags of new devices if we exceeded device limit
    //
    Next = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead &&
           g_dwDeviceEnabledCount > g_dwDeviceEnabledLimit)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;

        if (!(pLineInfo->dwDeviceType & FAX_DEVICE_TYPE_NEW) ||
            FALSE == IsDeviceEnabled(pLineInfo))
        {
            continue;
        }
        //
        // Device is new and enabled.
        //
        ResetDeviceFlags(pLineInfo);
        g_dwDeviceEnabledCount -= 1;
    }

    //
    // loop thru the devices and reset flags of cached devices if we exceeded device limit
    //
    Next = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead &&
           g_dwDeviceEnabledCount > g_dwDeviceEnabledLimit)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;

        if (!(pLineInfo->dwDeviceType & FAX_DEVICE_TYPE_CACHED) ||
            FALSE == IsDeviceEnabled(pLineInfo))
        {
            continue;
        }
        //
        // Device is cached and enabled.
        //
        ResetDeviceFlags(pLineInfo);
        g_dwDeviceEnabledCount -= 1;
    }

    //
    // loop thru the devices and reset flags of old devices if we exceeded device limit.
    //
    Next = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead &&
           g_dwDeviceEnabledCount > g_dwDeviceEnabledLimit)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;

        if (!(pLineInfo->dwDeviceType & FAX_DEVICE_TYPE_OLD) ||
            FALSE == IsDeviceEnabled(pLineInfo))
        {
            continue;
        }
        //
        // Device is old and enabled.
        //
        ResetDeviceFlags(pLineInfo);
        g_dwDeviceEnabledCount -= 1;
    }
    Assert (g_dwDeviceEnabledCount <= g_dwDeviceEnabledLimit);

    //
    // loop thru the devices and close the line handles
    // for all devices that are NOT set to receive
    //
    Next = g_TapiLinesListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = pLineInfo->ListEntry.Flink;

        if (!(pLineInfo->Flags & FPF_RECEIVE)                        &&  // Device is not set to auto-receive and
            pLineInfo->hLine                                         &&  // device is open and
            pLineInfo->PermanentLineID != g_dwManualAnswerDeviceId       // this device is not set to manual answer mode
           )
        {
            //
            // Attempt to close the device
            //
            HLINE hLine = pLineInfo->hLine;
            pLineInfo->hLine = 0;
            LONG Rslt = lineClose( hLine );
            if (Rslt)
            {
                if (LINEERR_INVALLINEHANDLE != Rslt)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("lineClose() for line %s [Permanent Id: %010d] has failed. (ec: %ld)"),
                        pLineInfo->DeviceName,
                        pLineInfo->TapiPermanentLineId,
                        Rslt);
                    ASSERT_FALSE;
                }
                else
                {
                    //
                    // We can get LINEERR_INVALLINEHANDLE if we got LINE_CLOSE
                    // from TAPI.
                    //
                    DebugPrintEx(
                        DEBUG_WRN,
                        TEXT("lineClose() for line %s [Permanent Id: %010d] reported LINEERR_INVALLINEHANDLE. (May be caused by LINE_CLOSE event)"),
                        pLineInfo->DeviceName,
                        pLineInfo->TapiPermanentLineId
                        );
                }
            }
        }
    }
    return dwRes;
}




VOID
UpdateManualAnswerDevice(
    void
    )
/*++

Routine name : UpdateManualAnswerDevice


Routine description:

    Updates the manual answer device with a cached device

Author:

    Sacher Oded (odeds), July, 2001

Arguments:

    None


Return Value:

    None

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("UpdateManualAnswerDevice"));

    //
    // Call UpdateReceiveEnabledDevicesCount () to make sure the manual answer device is valid
    //
    UpdateReceiveEnabledDevicesCount();

	//
	// if we have a valid manual answer device then finish
	//
    if (0 == g_dwManualAnswerDeviceId)
    {
        //
		//	No valid manual answer device is operational so look if chached devices were manual.
        //  loop through the cached devices and look for the first cached device and set it as a manual answer device
        //
        PLIST_ENTRY Next;
        PLINE_INFO pLineInfo;

        Next = g_TapiLinesListHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
        {
            BOOL fDeviceWasEnabled;
            DWORD dwRes;

            pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = pLineInfo->ListEntry.Flink;

            //
            // look for a cached manual answer device that is not set to auto receive
            //
            if ( pLineInfo->dwDeviceType != (FAX_DEVICE_TYPE_CACHED | FAX_DEVICE_TYPE_MANUAL_ANSWER) ||
                (pLineInfo->Flags & FPF_RECEIVE))
            {
                continue;
            }

            //
            // We found a device that can be set to manual receive
            //

			//
			// Now it may be that the cached device was not enabled (if for example it was marked as
			// manual-answer and no send ) so we didn't count it in the Enabled Count devices group.
			// if so then after setting it as a manual receive we ought to update g_dwDeviceEnabledCount
			//
            fDeviceWasEnabled = IsDeviceEnabled(pLineInfo);
            
			g_dwManualAnswerDeviceId = pLineInfo->PermanentLineID;
            dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);	// persist in registry
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                    dwRes);
            }

            //
            // Update enabled devices count
            //
            if (FALSE == fDeviceWasEnabled)
            {
                //
                // Another device is now enabled
                //
                g_dwDeviceEnabledCount += 1;
            }

			//
			//	No need to continue the search, only one "manual receive" device is allowed
			//
			break;
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\tapidbg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapidbg.c

Abstract:

    This module provides tapi specific debug support

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


typedef struct _LOOKUP {
    DWORD   dwVal;
    LPTSTR   lpszVal;
} LOOKUP, *PLOOKUP;

typedef struct _MSGTYPE {
    DWORD   MsgId;
    BOOL    LineMsg;
    LPTSTR  Text;
} MSGTYPE, *PMSGTYPE;


MSGTYPE  aMsgs[] =
{
    { LINE_ADDRESSSTATE,             TRUE,     TEXT("LINE_ADDRESSSTATE")         },
    { LINE_AGENTSPECIFIC,            TRUE,     TEXT("LINE_AGENTSPECIFIC")        },
    { LINE_AGENTSTATUS,              TRUE,     TEXT("LINE_AGENTSTATUS")          },
    { LINE_APPNEWCALL,               TRUE,     TEXT("LINE_APPNEWCALL")           },
    { LINE_CALLINFO,                 TRUE,     TEXT("LINE_CALLINFO")             },
    { LINE_CALLSTATE,                TRUE,     TEXT("LINE_CALLSTATE")            },
    { LINE_CLOSE,                    TRUE,     TEXT("LINE_CLOSE")                },
    { LINE_CREATE,                   TRUE,     TEXT("LINE_CREATE")               },
    { LINE_CREATE,                   TRUE,     TEXT("LINE_CREATE")               },
    { LINE_DEVSPECIFIC,              TRUE,     TEXT("LINE_DEVSPECIFIC")          },
    { LINE_DEVSPECIFICFEATURE,       TRUE,     TEXT("LINE_DEVSPECIFICFEATURE")   },
    { LINE_GATHERDIGITS,             TRUE,     TEXT("LINE_GATHERDIGITS")         },
    { LINE_GENERATE,                 TRUE,     TEXT("LINE_GENERATE")             },
    { LINE_LINEDEVSTATE,             TRUE,     TEXT("LINE_LINEDEVSTATE")         },
    { LINE_MONITORDIGITS,            TRUE,     TEXT("LINE_MONITORDIGITS")        },
    { LINE_MONITORMEDIA,             TRUE,     TEXT("LINE_MONITORMEDIA")         },
    { LINE_MONITORTONE,              TRUE,     TEXT("LINE_MONITORTONE")          },
    { LINE_PROXYREQUEST,             TRUE,     TEXT("LINE_PROXYREQUEST")         },
    { LINE_REMOVE,                   TRUE,     TEXT("LINE_REMOVE")               },
    { LINE_REPLY,                    TRUE,     TEXT("LINE_REPLY")                },
    { LINE_REQUEST,                  TRUE,     TEXT("LINE_REQUEST")              },
    { PHONE_BUTTON,                  FALSE,    TEXT("PHONE_BUTTON")              },
    { PHONE_CLOSE,                   FALSE,    TEXT("PHONE_CLOSE")               },
    { PHONE_CREATE,                  FALSE,    TEXT("PHONE_CREATE")              },
    { PHONE_DEVSPECIFIC,             FALSE,    TEXT("PHONE_DEVSPECIFIC")         },
    { PHONE_REMOVE,                  FALSE,    TEXT("PHONE_REMOVE")              },
    { PHONE_REPLY,                   FALSE,    TEXT("PHONE_REPLY")               },
    { PHONE_STATE,                   FALSE,    TEXT("PHONE_STATE")               },
    { 0xffffffff,                    FALSE,    NULL                              }
};

LOOKUP  aAddressStates[] =
{
    { LINEADDRESSSTATE_OTHER           ,TEXT("OTHER")              },
    { LINEADDRESSSTATE_DEVSPECIFIC     ,TEXT("DEVSPECIFIC")        },
    { LINEADDRESSSTATE_INUSEZERO       ,TEXT("INUSEZERO")          },
    { LINEADDRESSSTATE_INUSEONE        ,TEXT("INUSEONE")           },
    { LINEADDRESSSTATE_INUSEMANY       ,TEXT("INUSEMANY")          },
    { LINEADDRESSSTATE_NUMCALLS        ,TEXT("NUMCALLS")           },
    { LINEADDRESSSTATE_FORWARD         ,TEXT("FORWARD")            },
    { LINEADDRESSSTATE_TERMINALS       ,TEXT("TERMINALS")          },
    { LINEADDRESSSTATE_CAPSCHANGE      ,TEXT("CAPSCHANGE")         },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aBearerModes[] =
{
    { LINEBEARERMODE_VOICE             ,TEXT("VOICE")              },
    { LINEBEARERMODE_SPEECH            ,TEXT("SPEECH")             },
    { LINEBEARERMODE_MULTIUSE          ,TEXT("MULTIUSE")           },
    { LINEBEARERMODE_DATA              ,TEXT("DATA")               },
    { LINEBEARERMODE_ALTSPEECHDATA     ,TEXT("ALTSPEECHDATA")      },
    { LINEBEARERMODE_NONCALLSIGNALING  ,TEXT("NONCALLSIGNALING")   },
    { LINEBEARERMODE_PASSTHROUGH       ,TEXT("PASSTHROUGH")        },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aButtonModes[] =
{
    { PHONEBUTTONMODE_DUMMY            ,TEXT("DUMMY")              },
    { PHONEBUTTONMODE_CALL             ,TEXT("CALL")               },
    { PHONEBUTTONMODE_FEATURE          ,TEXT("FEATURE")            },
    { PHONEBUTTONMODE_KEYPAD           ,TEXT("KEYPAD")             },
    { PHONEBUTTONMODE_LOCAL            ,TEXT("LOCAL")              },
    { PHONEBUTTONMODE_DISPLAY          ,TEXT("DISPLAY")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aButtonStates[] =
{
    { PHONEBUTTONSTATE_UP              ,TEXT("UP")                 },
    { PHONEBUTTONSTATE_DOWN            ,TEXT("DOWN")               },
    { PHONEBUTTONSTATE_UNKNOWN         ,TEXT("UNKNOWN")            },
    { PHONEBUTTONSTATE_UNAVAIL         ,TEXT("UNAVAIL")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallInfoStates[] =
{
    { LINECALLINFOSTATE_OTHER          ,TEXT("OTHER")              },
    { LINECALLINFOSTATE_DEVSPECIFIC    ,TEXT("DEVSPECIFIC")        },
    { LINECALLINFOSTATE_BEARERMODE     ,TEXT("BEARERMODE")         },
    { LINECALLINFOSTATE_RATE           ,TEXT("RATE")               },
    { LINECALLINFOSTATE_MEDIAMODE      ,TEXT("MEDIAMODE")          },
    { LINECALLINFOSTATE_APPSPECIFIC    ,TEXT("APPSPECIFIC")        },
    { LINECALLINFOSTATE_CALLID         ,TEXT("CALLID")             },
    { LINECALLINFOSTATE_RELATEDCALLID  ,TEXT("RELATEDCALLID")      },
    { LINECALLINFOSTATE_ORIGIN         ,TEXT("ORIGIN")             },
    { LINECALLINFOSTATE_REASON         ,TEXT("REASON")             },
    { LINECALLINFOSTATE_COMPLETIONID   ,TEXT("COMPLETIONID")       },
    { LINECALLINFOSTATE_NUMOWNERINCR   ,TEXT("NUMOWNERINCR")       },
    { LINECALLINFOSTATE_NUMOWNERDECR   ,TEXT("NUMOWNERDECR")       },
    { LINECALLINFOSTATE_NUMMONITORS    ,TEXT("NUMMONITORS")        },
    { LINECALLINFOSTATE_TRUNK          ,TEXT("TRUNK")              },
    { LINECALLINFOSTATE_CALLERID       ,TEXT("CALLERID")           },
    { LINECALLINFOSTATE_CALLEDID       ,TEXT("CALLEDID")           },
    { LINECALLINFOSTATE_CONNECTEDID    ,TEXT("CONNECTEDID")        },
    { LINECALLINFOSTATE_REDIRECTIONID  ,TEXT("REDIRECTIONID")      },
    { LINECALLINFOSTATE_REDIRECTINGID  ,TEXT("REDIRECTINGID")      },
    { LINECALLINFOSTATE_DISPLAY        ,TEXT("DISPLAY")            },
    { LINECALLINFOSTATE_USERUSERINFO   ,TEXT("USERUSERINFO")       },
    { LINECALLINFOSTATE_HIGHLEVELCOMP  ,TEXT("HIGHLEVELCOMP")      },
    { LINECALLINFOSTATE_LOWLEVELCOMP   ,TEXT("LOWLEVELCOMP")       },
    { LINECALLINFOSTATE_CHARGINGINFO   ,TEXT("CHARGINGINFO")       },
    { LINECALLINFOSTATE_TERMINAL       ,TEXT("TERMINAL")           },
    { LINECALLINFOSTATE_DIALPARAMS     ,TEXT("DIALPARAMS")         },
    { LINECALLINFOSTATE_MONITORMODES   ,TEXT("MONITORMODES")       },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallSelects[] =
{
    { LINECALLSELECT_LINE              ,TEXT("LINE")               },
    { LINECALLSELECT_ADDRESS           ,TEXT("ADDRESS")            },
    { LINECALLSELECT_CALL              ,TEXT("CALL")               },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallStates[] =
{
    { LINECALLSTATE_IDLE               ,TEXT("IDLE")               },
    { LINECALLSTATE_OFFERING           ,TEXT("OFFERING")           },
    { LINECALLSTATE_ACCEPTED           ,TEXT("ACCEPTED")           },
    { LINECALLSTATE_DIALTONE           ,TEXT("DIALTONE")           },
    { LINECALLSTATE_DIALING            ,TEXT("DIALING")            },
    { LINECALLSTATE_RINGBACK           ,TEXT("RINGBACK")           },
    { LINECALLSTATE_BUSY               ,TEXT("BUSY")               },
    { LINECALLSTATE_SPECIALINFO        ,TEXT("SPECIALINFO")        },
    { LINECALLSTATE_CONNECTED          ,TEXT("CONNECTED")          },
    { LINECALLSTATE_PROCEEDING         ,TEXT("PROCEEDING")         },
    { LINECALLSTATE_ONHOLD             ,TEXT("ONHOLD")             },
    { LINECALLSTATE_CONFERENCED        ,TEXT("CONFERENCED")        },
    { LINECALLSTATE_ONHOLDPENDCONF     ,TEXT("ONHOLDPENDCONF")     },
    { LINECALLSTATE_ONHOLDPENDTRANSFER ,TEXT("ONHOLDPENDTRANSFER") },
    { LINECALLSTATE_DISCONNECTED       ,TEXT("DISCONNECTED")       },
    { LINECALLSTATE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aDigitModes[] =
{
    { LINEDIGITMODE_PULSE              ,TEXT("PULSE")              },
    { LINEDIGITMODE_DTMF               ,TEXT("DTMF")               },
    { LINEDIGITMODE_DTMFEND            ,TEXT("DTMFEND")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aHookSwitchDevs[] =
{
    { PHONEHOOKSWITCHDEV_HANDSET       ,TEXT("HANDSET")            },
    { PHONEHOOKSWITCHDEV_SPEAKER       ,TEXT("SPEAKER")            },
    { PHONEHOOKSWITCHDEV_HEADSET       ,TEXT("HEADSET")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aHookSwitchModes[] =
{
    { PHONEHOOKSWITCHMODE_ONHOOK       ,TEXT("ONHOOK")             },
    { PHONEHOOKSWITCHMODE_MIC          ,TEXT("MIC")                },
    { PHONEHOOKSWITCHMODE_SPEAKER      ,TEXT("SPEAKER")            },
    { PHONEHOOKSWITCHMODE_MICSPEAKER   ,TEXT("MICSPEAKER")         },
    { PHONEHOOKSWITCHMODE_UNKNOWN      ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aLampModes[] =
{
    { PHONELAMPMODE_DUMMY              ,TEXT("DUMMY")              },
    { PHONELAMPMODE_OFF                ,TEXT("OFF")                },
    { PHONELAMPMODE_STEADY             ,TEXT("STEADY")             },
    { PHONELAMPMODE_WINK               ,TEXT("WINK")               },
    { PHONELAMPMODE_FLASH              ,TEXT("FLASH")              },
    { PHONELAMPMODE_FLUTTER            ,TEXT("FLUTTER")            },
    { PHONELAMPMODE_BROKENFLUTTER      ,TEXT("BROKENFLUTTER")      },
    { PHONELAMPMODE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aLineStates[] =
{
    { LINEDEVSTATE_OTHER               ,TEXT("OTHER")              },
    { LINEDEVSTATE_RINGING             ,TEXT("RINGING")            },
    { LINEDEVSTATE_CONNECTED           ,TEXT("CONNECTED")          },
    { LINEDEVSTATE_DISCONNECTED        ,TEXT("DISCONNECTED")       },
    { LINEDEVSTATE_MSGWAITON           ,TEXT("MSGWAITON")          },
    { LINEDEVSTATE_MSGWAITOFF          ,TEXT("MSGWAITOFF")         },
    { LINEDEVSTATE_INSERVICE           ,TEXT("INSERVICE")          },
    { LINEDEVSTATE_OUTOFSERVICE        ,TEXT("OUTOFSERVICE")       },
    { LINEDEVSTATE_MAINTENANCE         ,TEXT("MAINTENANCE")        },
    { LINEDEVSTATE_OPEN                ,TEXT("OPEN")               },
    { LINEDEVSTATE_CLOSE               ,TEXT("CLOSE")              },
    { LINEDEVSTATE_NUMCALLS            ,TEXT("NUMCALLS")           },
    { LINEDEVSTATE_NUMCOMPLETIONS      ,TEXT("NUMCOMPLETIONS")     },
    { LINEDEVSTATE_TERMINALS           ,TEXT("TERMINALS")          },
    { LINEDEVSTATE_ROAMMODE            ,TEXT("ROAMMODE")           },
    { LINEDEVSTATE_BATTERY             ,TEXT("BATTERY")            },
    { LINEDEVSTATE_SIGNAL              ,TEXT("SIGNAL")             },
    { LINEDEVSTATE_DEVSPECIFIC         ,TEXT("DEVSPECIFIC")        },
    { LINEDEVSTATE_REINIT              ,TEXT("REINIT")             },
    { LINEDEVSTATE_LOCK                ,TEXT("LOCK")               },
    { LINEDEVSTATE_CAPSCHANGE          ,TEXT("CAPSCHANGE")         },
    { LINEDEVSTATE_CONFIGCHANGE        ,TEXT("CONFIGCHANGE")       },
    { LINEDEVSTATE_TRANSLATECHANGE     ,TEXT("TRANSLATECHANGE")    },
    { LINEDEVSTATE_COMPLCANCEL         ,TEXT("COMPLCANCEL")        },
    { LINEDEVSTATE_REMOVED             ,TEXT("REMOVED")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aMediaModes[] =
{
    { LINEMEDIAMODE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { LINEMEDIAMODE_INTERACTIVEVOICE   ,TEXT("INTERACTIVEVOICE")   },
    { LINEMEDIAMODE_AUTOMATEDVOICE     ,TEXT("AUTOMATEDVOICE")     },
    { LINEMEDIAMODE_DATAMODEM          ,TEXT("DATAMODEM")          },
    { LINEMEDIAMODE_G3FAX              ,TEXT("G3FAX")              },
    { LINEMEDIAMODE_TDD                ,TEXT("TDD")                },
    { LINEMEDIAMODE_G4FAX              ,TEXT("G4FAX")              },
    { LINEMEDIAMODE_DIGITALDATA        ,TEXT("DIGITALDATA")        },
    { LINEMEDIAMODE_TELETEX            ,TEXT("TELETEX")            },
    { LINEMEDIAMODE_VIDEOTEX           ,TEXT("VIDEOTEX")           },
    { LINEMEDIAMODE_TELEX              ,TEXT("TELEX")              },
    { LINEMEDIAMODE_MIXED              ,TEXT("MIXED")              },
    { LINEMEDIAMODE_ADSI               ,TEXT("ADSI")               },
    { LINEMEDIAMODE_VOICEVIEW          ,TEXT("VOICEVIEW")          },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aPhoneStates[] =
{
    { PHONESTATE_OTHER                 ,TEXT("OTHER")              },
    { PHONESTATE_CONNECTED             ,TEXT("CONNECTED")          },
    { PHONESTATE_DISCONNECTED          ,TEXT("DISCONNECTED")       },
    { PHONESTATE_OWNER                 ,TEXT("OWNER")              },
    { PHONESTATE_MONITORS              ,TEXT("MONITORS")           },
    { PHONESTATE_DISPLAY               ,TEXT("DISPLAY")            },
    { PHONESTATE_LAMP                  ,TEXT("LAMP")               },
    { PHONESTATE_RINGMODE              ,TEXT("RINGMODE")           },
    { PHONESTATE_RINGVOLUME            ,TEXT("RINGVOLUME")         },
    { PHONESTATE_HANDSETHOOKSWITCH     ,TEXT("HANDSETHOOKSWITCH")  },
    { PHONESTATE_HANDSETVOLUME         ,TEXT("HANDSETVOLUME")      },
    { PHONESTATE_HANDSETGAIN           ,TEXT("HANDSETGAIN")        },
    { PHONESTATE_SPEAKERHOOKSWITCH     ,TEXT("SPEAKERHOOKSWITCH")  },
    { PHONESTATE_SPEAKERVOLUME         ,TEXT("SPEAKERVOLUME")      },
    { PHONESTATE_SPEAKERGAIN           ,TEXT("SPEAKERGAIN")        },
    { PHONESTATE_HEADSETHOOKSWITCH     ,TEXT("HEADSETHOOKSWITCH")  },
    { PHONESTATE_HEADSETVOLUME         ,TEXT("HEADSETVOLUME")      },
    { PHONESTATE_HEADSETGAIN           ,TEXT("HEADSETGAIN")        },
    { PHONESTATE_SUSPEND               ,TEXT("SUSPEND")            },
    { PHONESTATE_RESUME                ,TEXT("RESUME")             },
    { PHONESTATE_DEVSPECIFIC           ,TEXT("DEVSPECIFIC")        },
    { PHONESTATE_REINIT                ,TEXT("REINIT")             },
    { PHONESTATE_CAPSCHANGE            ,TEXT("CAPSCHANGE")         },
    { PHONESTATE_REMOVED               ,TEXT("REMOVED")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aTerminalModes[] =
{
    { LINETERMMODE_BUTTONS             ,TEXT("BUTTONS")            },
    { LINETERMMODE_LAMPS               ,TEXT("LAMPS")              },
    { LINETERMMODE_DISPLAY             ,TEXT("DISPLAY")            },
    { LINETERMMODE_RINGER              ,TEXT("RINGER")             },
    { LINETERMMODE_HOOKSWITCH          ,TEXT("HOOKSWITCH")         },
    { LINETERMMODE_MEDIATOLINE         ,TEXT("MEDIATOLINE")        },
    { LINETERMMODE_MEDIAFROMLINE       ,TEXT("MEDIAFROMLINE")      },
    { LINETERMMODE_MEDIABIDIRECT       ,TEXT("MEDIABIDIRECT")      },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aToneModes[] =
{
    { LINETONEMODE_CUSTOM              ,TEXT("CUSTOM")             },
    { LINETONEMODE_RINGBACK            ,TEXT("RINGBACK")           },
    { LINETONEMODE_BUSY                ,TEXT("BUSY")               },
    { LINETONEMODE_BEEP                ,TEXT("BEEP")               },
    { LINETONEMODE_BILLING             ,TEXT("BILLING")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aTransferModes[] =
{
    { LINETRANSFERMODE_TRANSFER        ,TEXT("TRANSFER")           },
    { LINETRANSFERMODE_CONFERENCE      ,TEXT("CONFERENCE")         },
    { 0xffffffff                       ,TEXT("")                   }
};


LPTSTR
GetFlags(
    DWORD_PTR dwFlags,
    PLOOKUP   pLookup
    )
{
    int i;
    TCHAR buf[256];
    LPTSTR p = NULL;


    buf[0] = 0;

    for (i = 0; (dwFlags && (pLookup[i].dwVal != 0xffffffff)); i++) {
        if (dwFlags & pLookup[i].dwVal) {
            _tcscat( buf, pLookup[i].lpszVal );
            dwFlags = dwFlags & (~(DWORD_PTR)pLookup[i].dwVal);
        }
    }

    if (buf[0]) {
        p = (LPTSTR) MemAlloc( (_tcslen(buf) + 1) * sizeof(buf[1]) );
        if (p) {
            _tcscpy( p, buf );
        }
    }

    return p;
}


void
ShowLineEvent(
    HLINE       htLine,
    HCALL       htCall,
    LPTSTR      MsgStr,
    DWORD_PTR   dwCallbackInstance,
    DWORD       dwMsg,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    DWORD_PTR   dwParam3
    )
{
    int       i;
    LPTSTR    lpszParam1 = NULL;
    LPTSTR    lpszParam2 = NULL;
    LPTSTR    lpszParam3 = NULL;
    TCHAR     MsgBuf[1024];



    MsgBuf[0] = 0;

    if (MsgStr) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("%s "), MsgStr );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwCallbackInstance=0x%08x "), dwCallbackInstance );

    for (i = 0; aMsgs[i].MsgId != 0xffffffff; i++) {
        if (dwMsg == aMsgs[i].MsgId) {
            break;
        }
    }

    if (aMsgs[i].MsgId == 0xffffffff) {
        _stprintf(
            &MsgBuf[_tcslen(MsgBuf)],
            TEXT("<unknown msg id = %d> : hLine=0x%08x, hCall=0x%08x "),
            dwMsg,
            htLine,
            htCall
            );
    } else {
        _stprintf(
            &MsgBuf[_tcslen(MsgBuf)],
            TEXT("%s : hLine=0x%08x, hCall=0x%08x "),
            aMsgs[i].Text,
            htLine,
            htCall
            );
    }

    if (aMsgs[i].LineMsg) {

        switch (dwMsg) {
            case LINE_ADDRESSSTATE:
                lpszParam2 = GetFlags( dwParam2, aAddressStates );
                break;

            case LINE_CALLINFO:
                lpszParam1 = GetFlags( dwParam1, aCallInfoStates );
                break;

            case LINE_CALLSTATE:
                lpszParam1 = GetFlags( dwParam1, aCallStates );
                break;

            case LINE_LINEDEVSTATE:
                lpszParam1 = GetFlags( dwParam1, aLineStates );
                break;
        }

    } else {

        switch (dwMsg) {
            case PHONE_BUTTON:
                lpszParam2 = GetFlags( dwParam2, aButtonModes );
                lpszParam3 = GetFlags( dwParam3, aButtonStates );
                break;

            case PHONE_STATE:
                lpszParam1 = GetFlags( dwParam1, aPhoneStates);
                break;
        }

    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam1=0x%08x"), dwParam1 );
    if (lpszParam1) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s) "), lpszParam1 );
    } else {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT(" ") );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam2=0x%08x"), dwParam2 );
    if (lpszParam2) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s) "), lpszParam2 );
    } else {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT(" ") );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam3=0x%08x"), dwParam3 );
    if (lpszParam3) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s)"), lpszParam3 );
    }

    DebugPrint(( TEXT("%s"), MsgBuf ));

    if (lpszParam1) {
        MemFree( lpszParam1 );
    }

    if (lpszParam2) {
        MemFree( lpszParam2 );
    }

    if (lpszParam3) {
        MemFree( lpszParam3 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\tapicountry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiCountry.c

Abstract:

    Utility functions for working with TAPI

Environment:

    Server

Revision History:

    09/18/96 -davidx-
        Created it.

    07/25/99 -v-sashab-
        Moved from fxsui

--*/

#include "faxsvc.h"
#include "tapiCountry.h"

//
// Global variables used for accessing TAPI services
//
LPLINECOUNTRYLIST g_pLineCountryList;



BOOL
GetCountries(
    VOID
    )

/*++

Routine Description:

    Return a list of countries from TAPI

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

NOTE:

    We cache the result of lineGetCountry here since it's incredibly slow.
    This function must be invoked inside a critical section since it updates
    globally shared information.

--*/

{
#define INITIAL_SIZE_ALL_COUNTRY    22000
    DEBUG_FUNCTION_NAME(TEXT("GetCountries"));
    DWORD   cbNeeded;
    LONG    status;
    INT     repeatCnt = 0;

    if (g_pLineCountryList == NULL) {

        //
        // Initial buffer size
        //

        cbNeeded = INITIAL_SIZE_ALL_COUNTRY;

        while (TRUE) {

            MemFree(g_pLineCountryList);
			g_pLineCountryList = NULL;

            if (! (g_pLineCountryList = (LPLINECOUNTRYLIST)MemAlloc(cbNeeded)))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Memory allocation failed"));
                break;
            }

            g_pLineCountryList->dwTotalSize = cbNeeded;

            status = lineGetCountry(0, MAX_TAPI_API_VER, g_pLineCountryList);

            if ((g_pLineCountryList->dwNeededSize > g_pLineCountryList->dwTotalSize) &&
                (status == NO_ERROR ||
                 status == LINEERR_STRUCTURETOOSMALL ||
                 status == LINEERR_NOMEM) &&
                (repeatCnt++ == 0))
            {
                cbNeeded = g_pLineCountryList->dwNeededSize + 1;
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("LINECOUNTRYLIST size: %d"),cbNeeded);
                continue;
            }

            if (status != NO_ERROR) {

                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("lineGetCountry failed: %x"),status);
                MemFree(g_pLineCountryList);
                g_pLineCountryList = NULL;

            } else
                DebugPrintEx(DEBUG_MSG,TEXT("Number of countries: %d"), g_pLineCountryList->dwNumCountries);

            break;
        }
    }

    return g_pLineCountryList != NULL;
}


LPLINETRANSLATECAPS
GetTapiLocationInfo(
    )

/*++

Routine Description:

    Get a list of locations from TAPI

Arguments:

    NONE

Return Value:

    Pointer to a LINETRANSLATECAPS structure,
    NULL if there is an error

--*/


{
#define INITIAL_LINETRANSLATECAPS_SIZE  5000
    DEBUG_FUNCTION_NAME(TEXT("GetTapiLocationInfo"));

    DWORD               cbNeeded = INITIAL_LINETRANSLATECAPS_SIZE;
    LONG                status;
    INT                 repeatCnt = 0;
    LPLINETRANSLATECAPS pTranslateCaps = NULL;

    if (!g_hLineApp)
        return NULL;

    while (TRUE) {

        //
        // Free any existing buffer and allocate a new one with larger size
        //

        MemFree(pTranslateCaps);

        if (! (pTranslateCaps = (LPLINETRANSLATECAPS)MemAlloc(cbNeeded))) {

            DebugPrintEx(DEBUG_ERR,TEXT("Memory allocation failed"));
            return NULL;
        }

        //
        // Get the LINETRANSLATECAPS structure from TAPI
        //

        pTranslateCaps->dwTotalSize = cbNeeded;
        status = lineGetTranslateCaps(g_hLineApp, MAX_TAPI_API_VER, pTranslateCaps);

        //
        // Retry if our initial estimated buffer size was too small
        //

        if ((pTranslateCaps->dwNeededSize > pTranslateCaps->dwTotalSize) &&
            (status == NO_ERROR ||
             status == LINEERR_STRUCTURETOOSMALL ||
             status == LINEERR_NOMEM) &&
            (repeatCnt++ == 0))
        {
            cbNeeded = pTranslateCaps->dwNeededSize;
            DebugPrintEx(DEBUG_WRN,TEXT("LINETRANSLATECAPS size: %d"), cbNeeded);
            continue;
        }

        break;
    }

    if (status != NO_ERROR) {

        DebugPrintEx(DEBUG_ERR,TEXT("lineGetTranslateCaps failed: %x"), status);
        MemFree(pTranslateCaps);
        pTranslateCaps = NULL;
    }

    return pTranslateCaps;
}



BOOL
SetCurrentLocation(
    DWORD   locationID
    )

/*++

Routine Description:

    Change the default TAPI location

Arguments:

    locationID - The permanant ID for the new default TAPI location

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("SetCurrentLocation"));

    if (g_hLineApp && (lineSetCurrentLocation(g_hLineApp, locationID) == NO_ERROR))
    {
        DebugPrintEx(DEBUG_MSG,TEXT("Current location changed: ID = %d"), locationID);
        return TRUE;

    } else {

        DebugPrintEx(DEBUG_ERR,TEXT("Couldn't change current TAPI location"));
        return FALSE;
    }
}

LPLINECOUNTRYLIST
GetCountryList(
               )
{
    DEBUG_FUNCTION_NAME(TEXT("GetCountryList"));

    return g_pLineCountryList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\systray\fxsst.cpp ===
/**

Copyright (c)  Microsoft Corporation 1999-2000

Module Name:

    fxsst.cpp

Abstract:

    This module implements the tray icon for fax.
    The purpose of the tray icon is to provide
    status and feedback to the fax user.

**/
 
#include <windows.h>
#include <faxreg.h>
#include <fxsapip.h>
#include <faxutil.h>
#include <shellapi.h>
#include <winspool.h>
#include <shlobj.h>
#include <Mmsystem.h>
#include <tchar.h>
#include <DebugEx.h>

#include "monitor.h"
#include "resource.h"

////////////////////////////////////////////////////////////
// Global data
//

//
// The following message ids are used for internal custom messages.
//
#define WM_FAX_STARTED         (WM_USER + 204)      // Message indicating the loca fax service is up and running
#define WM_TRAYCALLBACK        (WM_USER + 205)      // Notification bar icon callback message
#define WM_FAX_EVENT           (WM_USER + 300)      // Fax extended event message

#define TRAY_ICON_ID            12345   // Unique enough

HINSTANCE g_hInstance;                          // DLL Global instance
                                                
HANDLE    g_hFaxSvcHandle = NULL;               // Handle to the fax service (from FaxConnectFaxServer)
DWORDLONG g_dwlCurrentMsgID = 0;                // ID of current message being monitored
DWORD     g_dwCurrentJobID  = 0;                // ID of current queue job being monitored
HANDLE    g_hServerStartupThread = NULL;        // Handle of thread which waits for the server startup event
HANDLE    g_hShutdownEvent = NULL;              // Event for DLL shutdown
BOOL      g_bShuttingDown = FALSE;              // Are we shutting down now?
                                                
HWND      g_hWndFaxNotify = NULL;               // Local (hidden) window handle
                                                
HANDLE    g_hNotification = NULL;               // Fax extended notification handle
                                                
HCALL     g_hCall = NULL;                       // Handle to call (from FAX_EVENT_TYPE_NEW_CALL)
DWORDLONG g_dwlNewMsgId;                        // ID of the last incoming fax
DWORDLONG g_dwlSendFailedMsgId;                 // ID of the last outgoing failed fax
DWORDLONG g_dwlSendSuccessMsgId;                // ID of the last successfully sent fax

TCHAR     g_szAddress[MAX_PATH] = {0};   // Current caller ID or recipient number
TCHAR     g_szRemoteId[MAX_PATH] = {0};  // Sender ID or Recipient ID
                                                //
                                                // Sender ID (receive):
                                                //      TSID or
                                                //      Caller ID or
                                                //      "unknown caller"
                                                //
                                                // Recipient ID (send):
                                                //      Recipient name or
                                                //      CSID or
                                                //      Recipient phone number.
                                                //

BOOL   g_bRecipientNameValid = FALSE;     // TRUE if the g_szRecipientName has valid data
TCHAR  g_szRecipientName[MAX_PATH] = {0}; // Keep the recipient name during sending

//
// Configuration options - read from the registry / Service
// Default values are set here.
//
CONFIG_OPTIONS g_ConfigOptions = {0};

//
// Notification bar icon states
//
typedef 
enum 
{
    ICON_RINGING=0,             // Device is ringing
    ICON_SENDING,               // Device is sending
    ICON_RECEIVING,             // Device is receiving  
    ICON_SEND_FAILED,           // Send operation failed
    ICON_RECEIVE_FAILED,        // Receive operation failed
    ICON_NEW_FAX,               // New unread fax
    ICON_SEND_SUCCESS,          // Send was successful
    ICON_IDLE,                  // Don't display an icon
    ICONS_COUNT                 // Number of icons we support                   
} eIconState;

eIconState g_CurrentIcon = ICONS_COUNT;     // The index of the currently displayed icon

#define TOOLTIP_SIZE            128   // Number of characters in the tooltip

struct SIconState
{
    BOOL    bEnable;                        // Is the state active? (e.g. are there any new unread faxes?)
    DWORD   dwIconResId;                    // Resource id of the icon to use
    HICON   hIcon;                          // Handle to icon to use
    LPCTSTR pctsSound;                      // Name of sound event
    TCHAR   tszToolTip[TOOLTIP_SIZE];       // Text to display in icon tooltip
    DWORD   dwBalloonTimeout;               // Timeout of balloon (millisecs)
    DWORD   dwBalloonIcon;                  // The icon to display in the balloon. (see NIIF_* constants)
};

//
// Fax notification icon state array.
// Several states may have the bEnable flag on.
// The array is sorted by priority and EvaluateIcon() scans it looking
// for the first active state.
//
SIconState g_Icons[ICONS_COUNT] = 
{
    {FALSE, IDI_RINGING_1,      NULL, TEXT("FaxLineRings"), TEXT(""), 30000, NIIF_INFO},    // ICON_RINGING   
    {FALSE, IDI_SENDING,        NULL, TEXT(""),             TEXT(""),     0, NIIF_INFO},    // ICON_SENDING
    {FALSE, IDI_RECEIVING,      NULL, TEXT(""),             TEXT(""),     0, NIIF_INFO},    // ICON_RECEIVING
    {FALSE, IDI_SEND_FAILED,    NULL, TEXT("FaxError"),     TEXT(""), 15000, NIIF_WARNING}, // ICON_SEND_FAILED    
    {FALSE, IDI_RECEIVE_FAILED, NULL, TEXT("FaxError"),     TEXT(""), 15000, NIIF_WARNING}, // ICON_RECEIVE_FAILED 
    {FALSE, IDI_NEW_FAX,        NULL, TEXT("FaxNew"),       TEXT(""), 15000, NIIF_INFO},    // ICON_NEW_FAX        
    {FALSE, IDI_SEND_SUCCESS,   NULL, TEXT("FaxSent"),      TEXT(""), 10000, NIIF_INFO},    // ICON_SEND_SUCCESS   
    {FALSE, IDI_FAX_NORMAL,     NULL, TEXT(""),             TEXT(""),     0, NIIF_NONE}     // ICON_IDLE
};

//
// Icons array for ringing animation
//
struct SRingIcon
{
    HICON   hIcon;          // Handle to loaded icon
    DWORD   dwIconResId;    // Resource ID of icon  
};

#define RING_ICONS_NUM                  4   // Number of frames (different icons) in ringing animation  
#define RING_ANIMATION_FRAME_DELAY    300   // Delay (millisecs) between ring animation frames
#define RING_ANIMATION_TIMEOUT      10000   // Timeout (millisecs) of ring animation. When the timeout expires, the animation
                                            // stops and the icon becomes static.

SRingIcon g_RingIcons[RING_ICONS_NUM] = 
{
    NULL, IDI_RINGING_1, 
    NULL, IDI_RINGING_2, 
    NULL, IDI_RINGING_3, 
    NULL, IDI_RINGING_4 
};

UINT_PTR  g_uRingTimerID = 0;           // Timer of ringing animation
DWORD     g_dwCurrRingIconIndex = 0;    // Index of current frame (into g_RingIcons)
DWORD     g_dwRingAnimationStartTick;   // Tick count (time) of animation start

#define MAX_BALLOON_TEXT_LEN     256    // Max number of character in balloon text
#define MAX_BALLOON_TITLE_LEN     64    // Max number of character in balloon title

struct SBalloonInfo
{
    BOOL        bEnable;                            // This flag is set when there's a need to display some balloon.
                                                    // EvaluateIcon() detects this bit, asks for a balloon and turns the bit off.
    BOOL        bDelete;                            // This flag is set when there's a need to destroy some balloon.
    eIconState  eState;                             // The current state of the icon
    TCHAR       szInfo[MAX_BALLOON_TEXT_LEN];       // The text to display on the balloon
    TCHAR       szInfoTitle[MAX_BALLOON_TITLE_LEN]; // The title to display on the balloon
};

BOOL g_bIconAdded = FALSE;                      // Do we have an icon on the status bar?
SBalloonInfo  g_BalloonInfo = {0};              // The current icon + ballon state

struct EVENT_INFO
{
    DWORD     dwExtStatus;      // Extended status code
    UINT      uResourceId;      // String for display
    eIconType eIcon;
};

static const EVENT_INFO g_StatusEx[] =
{
    JS_EX_DISCONNECTED,         IDS_FAX_DISCONNECTED,       LIST_IMAGE_ERROR,
    JS_EX_INITIALIZING,         IDS_FAX_INITIALIZING,       LIST_IMAGE_NONE,
    JS_EX_DIALING,              IDS_FAX_DIALING,            LIST_IMAGE_NONE,
    JS_EX_TRANSMITTING,         IDS_FAX_SENDING,            LIST_IMAGE_NONE,
    JS_EX_ANSWERED,             IDS_FAX_ANSWERED,           LIST_IMAGE_NONE,
    JS_EX_RECEIVING,            IDS_FAX_RECEIVING,          LIST_IMAGE_NONE,
    JS_EX_LINE_UNAVAILABLE,     IDS_FAX_LINE_UNAVAILABLE,   LIST_IMAGE_ERROR,
    JS_EX_BUSY,                 IDS_FAX_BUSY,               LIST_IMAGE_WARNING,
    JS_EX_NO_ANSWER,            IDS_FAX_NO_ANSWER,          LIST_IMAGE_WARNING,
    JS_EX_BAD_ADDRESS,          IDS_FAX_BAD_ADDRESS,        LIST_IMAGE_ERROR,
    JS_EX_NO_DIAL_TONE,         IDS_FAX_NO_DIAL_TONE,       LIST_IMAGE_ERROR,
    JS_EX_FATAL_ERROR,          IDS_FAX_FATAL_ERROR_SND,    LIST_IMAGE_ERROR,
    JS_EX_CALL_DELAYED,         IDS_FAX_CALL_DELAYED,       LIST_IMAGE_ERROR,   
    JS_EX_CALL_BLACKLISTED,     IDS_FAX_CALL_BLACKLISTED,   LIST_IMAGE_ERROR,
    JS_EX_NOT_FAX_CALL,         IDS_FAX_NOT_FAX_CALL,       LIST_IMAGE_ERROR,
    JS_EX_PARTIALLY_RECEIVED,   IDS_FAX_PARTIALLY_RECEIVED, LIST_IMAGE_WARNING,
    JS_EX_CALL_COMPLETED,       IDS_FAX_CALL_COMPLETED,     LIST_IMAGE_NONE,
    JS_EX_CALL_ABORTED,         IDS_FAX_CALL_ABORTED,       LIST_IMAGE_NONE,
    0,                          0,                          LIST_IMAGE_NONE
};

/////////////////////////////////////////////////////////////////////
// Function prototypes
//
STDAPI DllMain(HINSTANCE hModule, DWORD dwReason, void* lpReserved);

void   GetConfiguration();

DWORD WaitForRestartThread(LPVOID  ThreadData);
VOID  WaitForFaxRestart(HWND hWnd);

LRESULT CALLBACK NotifyWndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

BOOL Connect();

BOOL RegisterForServerEvents();
VOID OnFaxEvent(FAX_EVENT_EX *pEvent);

VOID OnNewCall (const FAX_EVENT_NEW_CALL &NewCall);
VOID StatusUpdate (PFAX_JOB_STATUS pStatus);
BOOL GetStatusEx(PFAX_JOB_STATUS pStatus, eIconType* peIcon, TCHAR* ptsStatusEx, DWORD dwSize);
BOOL IsUserGrantedAccess(DWORD);

void EvaluateIcon();
void SetIconState(eIconState eIcon, BOOL bEnable, TCHAR* ptsStatus = NULL);

VOID AnswerTheCall();
VOID InvokeClientConsole();
VOID DoFaxContextMenu(HWND hwnd);
VOID OnTrayCallback (HWND hwnd, WPARAM wp, LPARAM lp);
VOID CALLBACK RingTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);
VOID OnDeviceRing(DWORD dwDeviceID);
VOID InitGlobals ();
VOID GetRemoteId(PFAX_JOB_STATUS pStatus);
BOOL InitModule ();
BOOL DestroyModule ();
DWORD CheckAnswerNowCapability (BOOL bForceReconnect, LPDWORD lpdwDeviceId /* = NULL */);
VOID FaxPrinterProperties(DWORD dwPage);
VOID CopyLTRString(TCHAR* szDest, LPCTSTR szSource, DWORD dwSize);

//////////////////////////////////////////////////////////////////////
// Implementation
//

extern "C"
BOOL
FaxMonitorShutdown()
{
    g_bShuttingDown = TRUE;
    return DestroyModule();
}   // FaxMonitorShutdown

extern "C"
BOOL
IsFaxMessage(
    PMSG pMsg
)
/*++

Routine name : IsFaxMessage

Routine description:

    Fax message handle 

Arguments:

    pMsg - pointer to a message

Return Value:

    TRUE if the message was handled
    FALSE otherwise

--*/
{
    BOOL bRes = FALSE;

    if(g_hMonitorDlg)
    {
        bRes = IsDialogMessage(g_hMonitorDlg, pMsg);
    }
    return bRes;

} // IsFaxMessage

VOID 
InitGlobals ()
/*++

Routine name : InitGlobals

Routine description:

    Initializes all server connection related global variables

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("InitGlobals"));
                                               
    g_hFaxSvcHandle   = NULL;
    g_dwlCurrentMsgID = 0;
    g_dwCurrentJobID  = 0;
    g_hNotification   = NULL;
    g_hCall           = NULL;
    g_szAddress[0]    = TEXT('\0');
    g_szRemoteId[0]   = TEXT('\0');

    g_bRecipientNameValid = FALSE;
    g_szRecipientName[0]  = TEXT('\0');     

    BOOL bDesktopSKU = IsDesktopSKU();

    g_ConfigOptions.dwMonitorDeviceId      = 0;
    g_ConfigOptions.bSend                  = FALSE;
    g_ConfigOptions.bReceive               = FALSE;
    g_ConfigOptions.dwManualAnswerDeviceId = 0;
    g_ConfigOptions.dwAccessRights         = 0;   
    g_ConfigOptions.bNotifyProgress        = bDesktopSKU;  
    g_ConfigOptions.bNotifyInCompletion    = bDesktopSKU; 
    g_ConfigOptions.bNotifyOutCompletion   = bDesktopSKU; 
    g_ConfigOptions.bMonitorOnSend         = bDesktopSKU; 
    g_ConfigOptions.bMonitorOnReceive      = bDesktopSKU; 
    g_ConfigOptions.bSoundOnRing           = bDesktopSKU; 
    g_ConfigOptions.bSoundOnReceive        = bDesktopSKU; 
    g_ConfigOptions.bSoundOnSent           = bDesktopSKU; 
    g_ConfigOptions.bSoundOnError          = bDesktopSKU; 

    for (DWORD dw = 0; dw < ICONS_COUNT; dw++)
    {
        g_Icons[dw].bEnable = FALSE;
        g_Icons[dw].tszToolTip[0] = TEXT('\0');
    }

    g_uRingTimerID                  = 0;
    g_dwCurrRingIconIndex           = 0;
    g_dwRingAnimationStartTick      = 0;
    g_BalloonInfo.bEnable           = FALSE;
    g_BalloonInfo.bDelete           = FALSE;
    g_BalloonInfo.szInfo[0]         = TEXT('\0');
    g_BalloonInfo.szInfoTitle[0]    = TEXT('\0');
    g_CurrentIcon                   = ICONS_COUNT;
}   // InitGlobals

BOOL
InitModule ()
/*++

Routine name : InitModule

Routine description:

	Initializes the DLL module. Call only once.

Author:

	Eran Yariv (EranY),	Mar, 2001

Arguments:


Return Value:

    TRUE on success

--*/
{
    BOOL    bRes = FALSE;
    DWORD   dwRes;
    DBG_ENTER(TEXT("InitModule"), bRes);

    InitGlobals ();
    //
    // Don't have DllMain called for thread inits and shutdown.
    //
    DisableThreadLibraryCalls(g_hInstance);
    //
    // Load icons
    //
    for(DWORD dw=0; dw < ICONS_COUNT; ++dw)
    {
        g_Icons[dw].hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(g_Icons[dw].dwIconResId));
        if(!g_Icons[dw].hIcon)
        {
            dwRes = GetLastError();
            CALL_FAIL (RESOURCE_ERR, TEXT ("LoadIcon"), dwRes);
            bRes = FALSE;
            return bRes;
        }
    }
    //
    // Load animation icons
    //
    for(dw=0; dw < RING_ICONS_NUM; ++dw)
    {
        g_RingIcons[dw].hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(g_RingIcons[dw].dwIconResId));
        if(!g_RingIcons[dw].hIcon)
        {
            dwRes = GetLastError();
            CALL_FAIL (RESOURCE_ERR, TEXT ("LoadIcon"), dwRes);
            bRes = FALSE;
            return bRes;
        }
    }
    //
    // Load "new fax" tooltip
    //
    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_NEW_FAX, g_Icons[ICON_NEW_FAX].tszToolTip)))
    {
        SetLastError (dwRes);
        bRes = FALSE;
        return bRes;
    }
    //
    // Register our hidden window and create it
    //
    WNDCLASSEX  wndclass = {0};

    wndclass.cbSize         = sizeof(wndclass);
    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = NotifyWndProc;
    wndclass.hInstance      = g_hInstance;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = (HBRUSH) (COLOR_INACTIVEBORDER + 1);
    wndclass.lpszClassName  = FAXSTAT_WINCLASS;

    if(!RegisterClassEx(&wndclass))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("RegisterClassEx"), dwRes);
        bRes = FALSE;
        return bRes;
    }

    g_hWndFaxNotify = CreateWindow (FAXSTAT_WINCLASS, 
                                    TEXT("HiddenFaxWindow"),
                                    0, 
                                    CW_USEDEFAULT, 
                                    0, 
                                    CW_USEDEFAULT, 
                                    0,
                                    NULL, 
                                    NULL, 
                                    g_hInstance, 
                                    NULL);
    if(!g_hWndFaxNotify)
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("CreateWindow"), dwRes);
        bRes = FALSE;
        return bRes;
    }
    //
    // Create DLL shutdown event
    //
    g_hShutdownEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if(!g_hShutdownEvent)
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("CreateEvent"), dwRes);
        bRes = FALSE;
        return bRes;
    }
    //
    // Launch a thread which waits for the local fax service startup event.
    // When the event is set, the thread posts WM_FAX_STARTED to our hidden window.
    //
    WaitForFaxRestart(g_hWndFaxNotify);
    bRes = TRUE;
    return bRes;
}   // InitModule

DWORD 
WaitForBackgroundThreadToDie ()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("WaitForBackgroundThreadToDie"), dwRes);

    ASSERTION (g_hServerStartupThread);

    DWORD dwWaitRes = WaitForSingleObject (g_hServerStartupThread, INFINITE);
    switch (dwWaitRes)
    {
        case WAIT_OBJECT_0:
            //
            // Thread terminated - hooray
            //
            VERBOSE (DBG_MSG, TEXT("Background thread terminated successfully"));
            CloseHandle (g_hServerStartupThread);
            g_hServerStartupThread = NULL;
            break;

        case WAIT_FAILED:
            //
            // Error waiting for thread to die
            //
            dwRes = GetLastError ();
            VERBOSE (DBG_MSG, TEXT("Can't wait for background thread: %ld"), dwRes);
            break;

        default:
            //
            // No other return value from WaitForSingleObject is valid
            //
            ASSERTION_FAILURE;
            dwRes = ERROR_GEN_FAILURE;
            break;
    }
    return dwRes;
}   // WaitForBackgroundThreadToDie

BOOL
DestroyModule ()
/*++

Routine name : DestroyModule

Routine description:

	Destroys the DLL module. Call only once.

Author:

	Eran Yariv (EranY),	Mar, 2001

Arguments:


Return Value:

    TRUE on success

--*/
{
    BOOL    bRes = FALSE;
    DBG_ENTER(TEXT("DestroyModule"), bRes);

    //
    // Prepare for shutdown - destroy all active windows
    //
    if (g_hMonitorDlg)
    {
        //
        // Fake 'hide' key press on the monitor dialog
        //
        SendMessage (g_hMonitorDlg, WM_COMMAND, IDCANCEL, 0);
    }
    //
    // Delete the system tray icon if existed
    //
    if (g_bIconAdded)
    {
        NOTIFYICONDATA iconData = {0};

        iconData.cbSize           = sizeof(iconData);
        iconData.hWnd             = g_hWndFaxNotify;
        iconData.uID              = TRAY_ICON_ID;

        Shell_NotifyIcon(NIM_DELETE, &iconData);
        g_bIconAdded = FALSE;
    }
    //
    // Destory this window
    //
    if (!DestroyWindow (g_hWndFaxNotify))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("DestroyWindow"), GetLastError ());
    }
    g_hWndFaxNotify = NULL;
    //
    // Signal the DLL shutdown event
    //
    ASSERTION (g_hShutdownEvent);
    if (SetEvent (g_hShutdownEvent))
    {
        VERBOSE (DBG_MSG, TEXT("DLL shutdown event signaled"));
        if (g_hServerStartupThread)
        {
            //
            // Wait for background thread to die
            //
            DWORD dwRes = WaitForBackgroundThreadToDie();
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("WaitForBackgroundThreadToDie"), dwRes);
            }
        }
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT("SetEvent (g_hShutdownEvent)"), GetLastError ());
    }
    //
    // Release our DLL shutdown event
    //
    CloseHandle (g_hShutdownEvent);
    g_hShutdownEvent = NULL;
    //
    // Free the data of the monitor module
    //
    FreeMonitorDialogData (TRUE);
    //
    // Unregister window class
    //
    if (!UnregisterClass (FAXSTAT_WINCLASS, g_hInstance))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("UnregisterClass"), GetLastError ());
    }
    //
    // Unregister from server notifications
    //
    if (g_hNotification)
    {
        if(!FaxUnregisterForServerEvents(g_hNotification))
        {
            CALL_FAIL (RPC_ERR, TEXT("FaxUnregisterForServerEvents"), GetLastError());
        }
        g_hNotification = NULL;
    }
    //
    // Disconnect from the fax service
    //
    if (g_hFaxSvcHandle)
    {
        if (!FaxClose (g_hFaxSvcHandle))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("FaxClose"), GetLastError ());
        }
        g_hFaxSvcHandle = NULL;
    }
    //
    // Unload all icons
    //
    for (DWORD dw = 0; dw < ICONS_COUNT; dw++)
    {
        if (g_Icons[dw].hIcon)
        {   
            if (!DestroyIcon (g_Icons[dw].hIcon))
            {
                CALL_FAIL (WINDOW_ERR, TEXT("DestroyIcon"), GetLastError ());
            }
            g_Icons[dw].hIcon = NULL;
        }
    }
    for (DWORD dw = 0; dw < RING_ICONS_NUM; dw++)
    {
        if (g_RingIcons[dw].hIcon)
        {   
            if (!DestroyIcon (g_RingIcons[dw].hIcon))
            {
                CALL_FAIL (WINDOW_ERR, TEXT("DestroyIcon"), GetLastError ());
            }
            g_RingIcons[dw].hIcon = NULL;
        }
    }
    //
    // Kill animation timer
    //
    if(g_uRingTimerID)
    {
        if (!KillTimer(NULL, g_uRingTimerID))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("KillTimer"), GetLastError ());
        }
        g_uRingTimerID = NULL;
    }
    bRes = TRUE;
    return bRes;
}   // DestroyModule

STDAPI 
DllMain(
    HINSTANCE hModule, 
    DWORD     dwReason, 
    void*     lpReserved
)
/*++

Routine description:

    Fax notifications startup 

Arguments:

    hinstDLL    - handle to the DLL module
    fdwReason   - reason for calling function
    lpvReserved - reserved

Return Value:

    TRUE if success
    FALSE otherwise

--*/
{
    BOOL bRes = TRUE;
    DBG_ENTER(TEXT("DllMain"), bRes, TEXT("Reason = %ld"), dwReason);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hModule;
            bRes = InitModule ();
            return bRes;

        case DLL_PROCESS_DETACH:
            //
            // If g_bShuttingDown is not TRUE, someone (STOBJECT.DLL) forgot to call 
            // FaxMonitorShutdown() (our shutdown procedure) before doing FreeLibrary on us. 
            // This is not the way we're supposed to be used - a bug.
            //
            ASSERTION (g_bShuttingDown);
            return bRes;

        default:
            return bRes;
    }
} // DllMain


DWORD
WaitForRestartThread(
   LPVOID  ThreadData
)
{
    //
    // Wait for event to be signaled, indicating fax service started
    //
    DWORD dwRes = ERROR_SUCCESS;
    HANDLE hFaxServerEvent = NULL;
    HANDLE hEvents[2] = {0};
    DBG_ENTER(TEXT("WaitForRestartThread"), dwRes);

    //
    // Obtain service startup event handle.
    //
    // NOTICE: Events order in the array matters - we want to detect DLL shutdown BEFORE we detect service startup
    //
    hEvents[1] = OpenSvcStartEvent();
    if (!hEvents[1])
    {
        dwRes = GetLastError ();
        CALL_FAIL (GENERAL_ERR, TEXT("OpenSvcStartEvent"), dwRes);
        goto ExitThisThread;
    }
    hEvents[0] = g_hShutdownEvent;

    for(;;)
    {
        //
        // Wait for either the service startup event or the DLL shutdown event
        //
        DWORD dwWaitRes = WaitForMultipleObjects(ARR_SIZE(hEvents), 
                                                 hEvents, 
                                                 FALSE, 
                                                 INFINITE);
        switch (dwWaitRes)
        {
            case WAIT_OBJECT_0 + 1:
                //
                // Service startup event
                //
                VERBOSE (DBG_MSG, TEXT("Service startup event received"));
                if(SendMessage((HWND) ThreadData, WM_FAX_STARTED, 0, 0))
                {
                    goto ExitThisThread;
                }
                //
                // RegisterForServerEvents() failed
                // try once more after a minute
                //
                Sleep(60000);
                break;

            case WAIT_OBJECT_0:
                //
                // DLL shutdown event - exit thread ASAP.
                //
                VERBOSE (DBG_MSG, TEXT("DLL shutdown event received"));
                goto ExitThisThread;

            case WAIT_FAILED:
                dwRes = GetLastError ();
                CALL_FAIL (GENERAL_ERR, TEXT("WaitForMultipleObjects"), dwRes);
                goto ExitThisThread;

            default:
                //
                // No other return value from WaitForMultipleObjects is valid.
                //
                ASSERTION_FAILURE;
                goto ExitThisThread;
        }
    }

ExitThisThread:

    if (hFaxServerEvent)
    {
        CloseHandle (hFaxServerEvent);
    }
    return dwRes;
} // WaitForRestartThread

VOID
WaitForFaxRestart(
    HWND  hWnd
)
{
    DBG_ENTER(TEXT("WaitForFaxRestart"));

    if (g_bShuttingDown)
    {
        //
        // Shutting down - no thread creation allowed
        //
        return;
    }
    if (g_hServerStartupThread)
    {
        //
        // A Previous thead exists - wait for it to die
        //
        DWORD dwRes = WaitForBackgroundThreadToDie();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("WaitForBackgroundThreadToDie"), dwRes);
            return;
        }
    }
    ASSERTION (NULL == g_hServerStartupThread);
    g_hServerStartupThread = CreateThread(NULL, 0, WaitForRestartThread, (LPVOID) hWnd, 0, NULL);
    if (g_hServerStartupThread) 
    {
        VERBOSE (DBG_MSG, TEXT("Background therad created successfully"));
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CreateThread(WaitForRestartThread)"), GetLastError());
    }
} // WaitForFaxRestart


void
GetConfiguration()
/*++

Routine description:

    Read notification configuration from the registry

Arguments:

    none

Return Value:

  none

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("GetConfiguration"));

    HKEY  hKey;

    if(Connect())
    {
        if (!FaxAccessCheckEx(g_hFaxSvcHandle, MAXIMUM_ALLOWED, &g_ConfigOptions.dwAccessRights))
        {
            dwRes = GetLastError ();
            CALL_FAIL (RPC_ERR, TEXT("FaxAccessCheckEx"), dwRes);
        }
    }
    
    dwRes = RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, 0, KEY_READ, &hKey);
    if (dwRes != ERROR_SUCCESS) 
    {
        //
        // Can't open user information key - use defaults
        //
        CALL_FAIL (GENERAL_ERR, TEXT("RegOpenKeyEx(REGKEY_FAX_USERINFO)"), dwRes);
        BOOL bDesktopSKU = IsDesktopSKU();

        g_ConfigOptions.dwMonitorDeviceId      = 0;
        g_ConfigOptions.bNotifyProgress        = bDesktopSKU;  
        g_ConfigOptions.bNotifyInCompletion    = bDesktopSKU; 
        g_ConfigOptions.bNotifyOutCompletion   = bDesktopSKU; 
        g_ConfigOptions.bMonitorOnSend         = bDesktopSKU; 
        g_ConfigOptions.bMonitorOnReceive      = bDesktopSKU; 
        g_ConfigOptions.bSoundOnRing           = bDesktopSKU; 
        g_ConfigOptions.bSoundOnReceive        = bDesktopSKU; 
        g_ConfigOptions.bSoundOnSent           = bDesktopSKU; 
        g_ConfigOptions.bSoundOnError          = bDesktopSKU; 
    }
    else
    {
        GetRegistryDwordEx(hKey, REGVAL_NOTIFY_PROGRESS,     &g_ConfigOptions.bNotifyProgress);
        GetRegistryDwordEx(hKey, REGVAL_NOTIFY_IN_COMPLETE,  &g_ConfigOptions.bNotifyInCompletion);
        GetRegistryDwordEx(hKey, REGVAL_NOTIFY_OUT_COMPLETE, &g_ConfigOptions.bNotifyOutCompletion);
        GetRegistryDwordEx(hKey, REGVAL_MONITOR_ON_SEND,     &g_ConfigOptions.bMonitorOnSend);
        GetRegistryDwordEx(hKey, REGVAL_MONITOR_ON_RECEIVE,  &g_ConfigOptions.bMonitorOnReceive);
        GetRegistryDwordEx(hKey, REGVAL_SOUND_ON_RING,       &g_ConfigOptions.bSoundOnRing);
        GetRegistryDwordEx(hKey, REGVAL_SOUND_ON_RECEIVE,    &g_ConfigOptions.bSoundOnReceive);
        GetRegistryDwordEx(hKey, REGVAL_SOUND_ON_SENT,       &g_ConfigOptions.bSoundOnSent);
        GetRegistryDwordEx(hKey, REGVAL_SOUND_ON_ERROR,      &g_ConfigOptions.bSoundOnError);
        GetRegistryDwordEx(hKey, REGVAL_DEVICE_TO_MONITOR,   &g_ConfigOptions.dwMonitorDeviceId);
        RegCloseKey( hKey );
    }

    g_ConfigOptions.dwManualAnswerDeviceId = 0;

    if(Connect() && IsUserGrantedAccess(FAX_ACCESS_QUERY_CONFIG))
    {
        PFAX_PORT_INFO_EX  pPortsInfo = NULL;
        DWORD              dwPorts = 0;

        if(!FaxEnumPortsEx(g_hFaxSvcHandle, &pPortsInfo, &dwPorts))
        {
            dwRes = GetLastError ();
            CALL_FAIL (RPC_ERR, TEXT("FaxEnumPortsEx"), dwRes);
        }
        else
        {
            if (dwPorts)
            {
                DWORD dwDevIndex = 0;
                for(DWORD dw=0; dw < dwPorts; ++dw)
                {
                    //
                    // Iterate all fax devices
                    //
                    if ((g_ConfigOptions.dwMonitorDeviceId == pPortsInfo[dw].dwDeviceID)    ||  // Found the monitored device or
                        (!g_ConfigOptions.dwMonitorDeviceId &&                                  //    No monitored device and
                            (pPortsInfo[dw].bSend ||                                            //       the device is send-enabled or
                             (FAX_DEVICE_RECEIVE_MODE_OFF != pPortsInfo[dw].ReceiveMode)        //       the device is receive-enabled
                            )
                        )
                       )
                    {
                        //
                        // Mark the index of the device we use for monitoring.
                        //
                        dwDevIndex = dw;
                    }
                    if (FAX_DEVICE_RECEIVE_MODE_MANUAL == pPortsInfo[dw].ReceiveMode)
                    {
                        //
                        // Mark the id of the device set for manual-answer
                        //
                        g_ConfigOptions.dwManualAnswerDeviceId = pPortsInfo[dw].dwDeviceID;
                    }
                }
                //
                // Update the device used for monitoring from the index we found
                //
                g_ConfigOptions.dwMonitorDeviceId = pPortsInfo[dwDevIndex].dwDeviceID;
                g_ConfigOptions.bSend             = pPortsInfo[dwDevIndex].bSend;
                g_ConfigOptions.bReceive          = FAX_DEVICE_RECEIVE_MODE_OFF != pPortsInfo[dwDevIndex].ReceiveMode;
            }
            else
            {
                //
                // No devices
                //
                g_ConfigOptions.dwMonitorDeviceId = 0;
                g_ConfigOptions.bSend = FALSE;
                g_ConfigOptions.bReceive = FALSE;   
            }
            FaxFreeBuffer(pPortsInfo);
        }
    }
} // GetConfiguration


BOOL
Connect(
)
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("Connect"), bRes);

    if (g_hFaxSvcHandle) 
    {
        //
        // Already connected
        //
        bRes = TRUE;
        return bRes;
    }

    if (!FaxConnectFaxServer(NULL, &g_hFaxSvcHandle)) 
    {
        CALL_FAIL (RPC_ERR, TEXT("FaxConnectFaxServer"), GetLastError());
        return bRes;
    }
    bRes = TRUE;
    return bRes;
} // Connect

BOOL
RegisterForServerEvents()
/*++

Routine description:

    Register for fax notifications

Arguments:

    none

Return Value:

    none

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("RegisterForServerEvents"));

    if (!Connect())
    {
        return FALSE;
    }

    //
    // Load configuration
    //
    GetConfiguration ();

    if(g_hNotification)
    {
        if(!FaxUnregisterForServerEvents(g_hNotification))
        {
            CALL_FAIL (RPC_ERR, TEXT("FaxUnregisterForServerEvents"), GetLastError());
        }
        g_hNotification = NULL;
    }

    //
    // Register for the fax events
    //
    DWORD dwEventTypes = (FAX_EVENT_TYPE_FXSSVC_ENDED | FAX_EVENT_TYPE_LOCAL_ONLY); // Register for local events only

    VERBOSE (DBG_MSG, 
             TEXT("User has the following rights: %x. Asking for FAX_EVENT_TYPE_FXSSVC_ENDED"), 
             g_ConfigOptions.dwAccessRights);

    if(IsUserGrantedAccess(FAX_ACCESS_SUBMIT)			||
	   IsUserGrantedAccess(FAX_ACCESS_SUBMIT_NORMAL)	||
	   IsUserGrantedAccess(FAX_ACCESS_SUBMIT_HIGH))      // User can submit new faxes (and view his own faxes)
    {
        dwEventTypes |= FAX_EVENT_TYPE_OUT_QUEUE;
        VERBOSE (DBG_MSG, TEXT("Also asking for FAX_EVENT_TYPE_OUT_QUEUE"));
    }

    if(IsUserGrantedAccess(FAX_ACCESS_QUERY_JOBS))    // User can view all jobs (in and out)
    {
        dwEventTypes |= FAX_EVENT_TYPE_OUT_QUEUE | FAX_EVENT_TYPE_IN_QUEUE;
        VERBOSE (DBG_MSG, TEXT("Also asking for FAX_EVENT_TYPE_OUT_QUEUE & FAX_EVENT_TYPE_IN_QUEUE"));
    }

    if(IsUserGrantedAccess(FAX_ACCESS_QUERY_CONFIG))
    {
        dwEventTypes |= FAX_EVENT_TYPE_CONFIG | FAX_EVENT_TYPE_DEVICE_STATUS;
        VERBOSE (DBG_MSG, TEXT("Also asking for FAX_EVENT_TYPE_CONFIG & FAX_EVENT_TYPE_DEVICE_STATUS"));
    }

    if(IsUserGrantedAccess(FAX_ACCESS_QUERY_IN_ARCHIVE))
    {
        dwEventTypes |= FAX_EVENT_TYPE_IN_ARCHIVE | FAX_EVENT_TYPE_NEW_CALL;
        VERBOSE (DBG_MSG, TEXT("Also asking for FAX_EVENT_TYPE_IN_ARCHIVE"));
    }

    if (!FaxRegisterForServerEvents (g_hFaxSvcHandle,
                dwEventTypes,       // Types of events to receive
                NULL,               // Not using completion ports
                0,                  // Not using completion ports
                g_hWndFaxNotify,    // Handle of window to receive notification messages
                WM_FAX_EVENT,       // Message id
                &g_hNotification))  // Notification handle
    {
        dwRes = GetLastError ();
        CALL_FAIL (RPC_ERR, TEXT("FaxRegisterForServerEvents"), dwRes);
        g_hNotification = NULL;
    }

    if(!FaxRelease(g_hFaxSvcHandle))
    {
        CALL_FAIL (RPC_ERR, TEXT("FaxRelease"), GetLastError ());
    }

    return ERROR_SUCCESS == dwRes;

} // RegisterForServerEvents


VOID
OnFaxEvent(FAX_EVENT_EX* pEvent)
/*++

Routine description:

    Handle fax events

Arguments:

    pEvent - fax event data

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnFaxEvent"), TEXT("%x"), pEvent);
    if(!pEvent || pEvent->dwSizeOfStruct != sizeof(FAX_EVENT_EX))
    {
        VERBOSE (DBG_MSG, TEXT("Either event is bad or it has bad size"));
        return;
    }
    
    switch (pEvent->EventType)
    {
        case FAX_EVENT_TYPE_NEW_CALL:

            OnNewCall (pEvent->EventInfo.NewCall);
            break;

        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:

            switch (pEvent->EventInfo.JobInfo.Type)
            {
                case FAX_JOB_EVENT_TYPE_ADDED:
                case FAX_JOB_EVENT_TYPE_REMOVED:
                    break;

                case FAX_JOB_EVENT_TYPE_STATUS:
                    if(pEvent->EventInfo.JobInfo.pJobData &&
                       pEvent->EventInfo.JobInfo.pJobData->dwDeviceID &&
                       pEvent->EventInfo.JobInfo.pJobData->dwDeviceID == g_ConfigOptions.dwMonitorDeviceId)
                    {   
                        if(g_dwlCurrentMsgID != pEvent->EventInfo.JobInfo.dwlMessageId)
                        {
                            g_bRecipientNameValid = FALSE;
                        }
                        g_dwlCurrentMsgID = pEvent->EventInfo.JobInfo.dwlMessageId;
                    }

                    if(g_dwlCurrentMsgID == pEvent->EventInfo.JobInfo.dwlMessageId)
                    {
                        StatusUpdate(pEvent->EventInfo.JobInfo.pJobData);
                    }
                    break;
            }
            break;

        case FAX_EVENT_TYPE_IN_ARCHIVE:
            if(FAX_JOB_EVENT_TYPE_ADDED == pEvent->EventInfo.JobInfo.Type)
            {                
                g_dwlNewMsgId = pEvent->EventInfo.JobInfo.dwlMessageId;

                SetIconState(ICON_NEW_FAX, TRUE);
            }
            break;

        case FAX_EVENT_TYPE_CONFIG:
            if (FAX_CONFIG_TYPE_SECURITY == pEvent->EventInfo.ConfigType)
            {
                //
                // Security has changed. 
                // We should re-register for events now.
                // Also re-read the current user rights
                //
                RegisterForServerEvents();
            }
            else if (FAX_CONFIG_TYPE_DEVICES == pEvent->EventInfo.ConfigType)
            {
                //
                // Device configuration has changed.
                // The only reason we need to know that is because the device we were listening on might be gone now.
                // If that's true, we should pick the first available device as the monitoring device.
                //
                GetConfiguration();
                UpdateMonitorData(g_hMonitorDlg);
            }
            else
            {
                //
                // Non-interesting configuraton change - ignore.
                //
            }
            break;

        case FAX_EVENT_TYPE_DEVICE_STATUS:
            if(pEvent->EventInfo.DeviceStatus.dwDeviceId == g_ConfigOptions.dwMonitorDeviceId ||
               pEvent->EventInfo.DeviceStatus.dwDeviceId == g_ConfigOptions.dwManualAnswerDeviceId)
            {
                //
                // we only care about the monitored / manual-answer devices
                //
                if ((pEvent->EventInfo.DeviceStatus.dwNewStatus) & FAX_DEVICE_STATUS_RINGING)
                {
                    //
                    // Device is ringing
                    //
                    OnDeviceRing (pEvent->EventInfo.DeviceStatus.dwDeviceId);
                }
                else
                {   
                    if (FAX_RINGING == g_devState)
                    {
                        //
                        // Device is not ringing anymore but the monitor shows 'ringing'.
                        // Set the monitor to idle state.
                        //
                        SetStatusMonitorDeviceState(FAX_IDLE);
                    }
                }
            }
            break;

        case FAX_EVENT_TYPE_FXSSVC_ENDED:
            //
            // Service was stopped
            //
            SetIconState(ICON_RINGING,   FALSE);
            SetIconState(ICON_SENDING,   FALSE);
            SetIconState(ICON_RECEIVING, FALSE);

            SetStatusMonitorDeviceState(FAX_IDLE);
            //
            // We just lost our RPC connection handle and our notification handle. Close and zero them.
            //
            if (g_hNotification)
            {
                FaxUnregisterForServerEvents (g_hNotification);
                g_hNotification = NULL;
            }
            if (g_hFaxSvcHandle)
            {
                FaxClose (g_hFaxSvcHandle);
                g_hFaxSvcHandle = NULL;
            }
            WaitForFaxRestart(g_hWndFaxNotify);
            break;
    }

    FaxFreeBuffer (pEvent);
} // OnFaxEvent


VOID  
OnDeviceRing(
    DWORD dwDeviceID
)
/*++

Routine description:

    Called when a device is ringing

Arguments:

    dwDeviceID - device ID 

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnDeviceRing"), TEXT("%d"), dwDeviceID);

    //
    // It can be monitored or manual answer device
    //
    SetStatusMonitorDeviceState(FAX_RINGING);
    AddStatusMonitorLogEvent(LIST_IMAGE_NONE, IDS_RINGING);
    if(g_ConfigOptions.bSoundOnRing)
    {
        if(!PlaySound(g_Icons[ICON_RINGING].pctsSound, NULL, SND_ASYNC | SND_APPLICATION | SND_NODEFAULT))
        {
            CALL_FAIL (WINDOW_ERR, TEXT ("PlaySound"), 0);
        }
    }
}


VOID
OnNewCall (
    const FAX_EVENT_NEW_CALL &NewCall
)
/*++

Routine description:

    Handle "new call" fax event

Arguments:

    NewCall - fax event data

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnNewCall"));

    //
    // It can be any manual answer device
    //
    g_hCall = NewCall.hCall;

    if(NewCall.hCall)
    {
        LPCTSTR lpctstrParam = NULL;
        DWORD  dwStringResId = IDS_INCOMING_CALL;

        CopyLTRString(g_szAddress, NewCall.lptstrCallerId, ARR_SIZE(g_szAddress) - 1);

        _tcscpy(g_szRemoteId, g_szAddress);

        if(NewCall.lptstrCallerId && _tcslen(NewCall.lptstrCallerId))
        {
            //
            // We know the caller id.
            // Use another string which formats the caller ID parameter
            //
            lpctstrParam  = NewCall.lptstrCallerId;
            dwStringResId = IDS_INCOMING_CALL_FROM;
        }
        TCHAR tszEvent[MAX_PATH];
        AddStatusMonitorLogEvent (LIST_IMAGE_NONE, dwStringResId, lpctstrParam, tszEvent);
        SetStatusMonitorDeviceState(FAX_RINGING);
        SetIconState(ICON_RINGING, TRUE, tszEvent);
    }
    else
    {
        //
        // Call is gone
        //
        SetStatusMonitorDeviceState(FAX_IDLE);
        SetIconState(ICON_RINGING, FALSE, TEXT(""));
    }
} // OnNewCall

VOID
GetRemoteId(
    PFAX_JOB_STATUS pStatus
)
/*++

Routine description:

    Write Sender ID or Recipient ID into g_szRemoteId
    Sender ID (receive):
          TSID or
          Caller ID or
          "unknown caller"
    
    Recipient ID (send):
          Recipient name or
          CSID or
          Recipient phone number.

Arguments:

    pStatus - job status data

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("GetRemoteId"));

    if(!pStatus)
    {
        return;
    }

    if(JT_SEND == pStatus->dwJobType)
    {
        //
        // Recipient ID (send)
        //
        if(!g_bRecipientNameValid)
        {
            //
            // Store the recipient name into g_szRecipientName
            //
            PFAX_JOB_ENTRY_EX pJobEntry = NULL;
            if(!FaxGetJobEx(g_hFaxSvcHandle, g_dwlCurrentMsgID, &pJobEntry))
            {
                CALL_FAIL (RPC_ERR, TEXT ("FaxGetJobEx"), GetLastError());
                g_szRecipientName[0] = TEXT('\0');
            }
            else
            {
                if(pJobEntry->lpctstrRecipientName && _tcslen(pJobEntry->lpctstrRecipientName))
                {
                    _tcsncpy(g_szRecipientName, pJobEntry->lpctstrRecipientName, ARR_SIZE(g_szRecipientName) - 1);
                }
                else
                {
                    g_szRecipientName[0] = TEXT('\0');
                }
                g_bRecipientNameValid = TRUE;

                FaxFreeBuffer(pJobEntry);
            }
        }

        if(_tcslen(g_szRecipientName))
        {
            //
            // Recipient name
            //
            _tcsncpy(g_szRemoteId, g_szRecipientName, ARR_SIZE(g_szRemoteId) - 1);
        }
        else if(pStatus->lpctstrCsid && _tcslen(pStatus->lpctstrCsid))
        {
            //
            // CSID
            //
            CopyLTRString(g_szRemoteId, pStatus->lpctstrCsid, ARR_SIZE(g_szRemoteId) - 1);
        }
        else if(pStatus->lpctstrCallerID && _tcslen(pStatus->lpctstrCallerID))
        {
            //
            // Recipient number
            // For outgoing fax FAX_JOB_STATUS.lpctstrCallerID field
            // contains a recipient fax number.
            //
            CopyLTRString(g_szRemoteId, pStatus->lpctstrCallerID, ARR_SIZE(g_szRemoteId) - 1);
        }
    }
    else if(JT_RECEIVE == pStatus->dwJobType)
    {
        //
        // Sender ID (receive)
        //
        if(pStatus->lpctstrTsid     && _tcslen(pStatus->lpctstrTsid) &&
           pStatus->lpctstrCallerID && _tcslen(pStatus->lpctstrCallerID))
        {
            //
            // We have Caller ID and TSID
            //
            TCHAR szTmp[MAX_PATH];
            _sntprintf(szTmp, 
                       ARR_SIZE(szTmp)-1, 
                       TEXT("%s (%s)"), 
                       pStatus->lpctstrCallerID,
                       pStatus->lpctstrTsid); 
            CopyLTRString(g_szRemoteId, szTmp, ARR_SIZE(g_szRemoteId) - 1);
        }
        else if(pStatus->lpctstrTsid && _tcslen(pStatus->lpctstrTsid))
        {
            //
            // TSID
            //
            CopyLTRString(g_szRemoteId, pStatus->lpctstrTsid, ARR_SIZE(g_szRemoteId) - 1);
        }
        else if(pStatus->lpctstrCallerID && _tcslen(pStatus->lpctstrCallerID))
        {
            //
            // Caller ID
            //
            CopyLTRString(g_szRemoteId, pStatus->lpctstrCallerID, ARR_SIZE(g_szRemoteId) - 1);
        }
        else
        {
            //
            // unknown caller
            //
            _tcsncpy(g_szRemoteId, TEXT(""), ARR_SIZE(g_szRemoteId) - 1);
        }
    }
}


VOID
StatusUpdate(PFAX_JOB_STATUS pStatus)
/*++

Routine description:

    Handle "status update" fax event

Arguments:

    pStatus - job status data

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("StatusUpdate"));

    DWORD dwRes;

    if(!pStatus)
    {
        return;
    }
    VERBOSE (DBG_MSG, 
             TEXT("Job status event - Type=%x, QueueStatus=%x, ExtendedStatus=%x"),
             pStatus->dwJobType, 
             pStatus->dwQueueStatus, 
             pStatus->dwExtendedStatus);

    if(JT_RECEIVE != pStatus->dwJobType && JT_SEND != pStatus->dwJobType)
    {
        VERBOSE (DBG_MSG, TEXT("Job type (%d) is not JT_RECEIVE or JT_SEND. Ignoring."), pStatus->dwJobType);
        return;
    }

    eIconType eIcon = LIST_IMAGE_NONE;  // New icon to set

    DWORD  dwStatusId = 0;             // string resource ID
    TCHAR  tszStatus[MAX_PATH] = {0};  // String to show in status monitor
    BOOL   bStatus = FALSE;            // TRUE if tszStatus has valid string

    if(pStatus->dwQueueStatus & JS_PAUSED)
    {
        //
        // The job has been paused in the outbox queue after a failure
        //
        g_dwlCurrentMsgID = 0;
        return;
    }

    if(pStatus->dwQueueStatus & JS_COMPLETED || pStatus->dwQueueStatus & JS_ROUTING)
    {
        //
        // Incoming job sends JS_ROUTING status by completion
        //
        if(JS_EX_PARTIALLY_RECEIVED == pStatus->dwExtendedStatus)
        {
            bStatus = GetStatusEx(pStatus, &eIcon, tszStatus, ARR_SIZE(tszStatus) - 1);
        }
        else
        {
            eIcon = LIST_IMAGE_SUCCESS;
            dwStatusId = (JT_SEND == pStatus->dwJobType) ? IDS_FAX_SNT_COMPLETED : IDS_FAX_RCV_COMPLETED;
        }
    }
    else if(pStatus->dwQueueStatus & JS_CANCELING)
    {
        dwStatusId = IDS_FAX_CANCELING;
    }
    else if(pStatus->dwQueueStatus & JS_CANCELED)
    {
        dwStatusId = IDS_FAX_CANCELED;
    }
    else if(pStatus->dwQueueStatus & JS_INPROGRESS)
    {
        GetRemoteId(pStatus);

        bStatus = GetStatusEx(pStatus, &eIcon, tszStatus, ARR_SIZE(tszStatus) - 1);

        g_dwCurrentJobID = pStatus->dwJobID;

        SetIconState((JT_SEND == pStatus->dwJobType) ? ICON_SENDING : ICON_RECEIVING, TRUE, tszStatus);

        SetStatusMonitorDeviceState((JT_SEND == pStatus->dwJobType) ? FAX_SENDING : FAX_RECEIVING);
    }
    else if(pStatus->dwQueueStatus & JS_FAILED)
    {
        if(!(bStatus = GetStatusEx(pStatus, &eIcon, tszStatus, ARR_SIZE(tszStatus) - 1)))
        {
            eIcon = LIST_IMAGE_ERROR;
            dwStatusId = (JT_SEND == pStatus->dwJobType) ? IDS_FAX_FATAL_ERROR_SND : IDS_FAX_FATAL_ERROR_RCV;
        }
    }
    else if(pStatus->dwQueueStatus & JS_RETRIES_EXCEEDED)
    {
        //
        // Add two strings to the log.
        // The first is extended status.
        // The second is "Retries exceeded"
        //
        if(bStatus = GetStatusEx(pStatus, &eIcon, tszStatus, ARR_SIZE(tszStatus) - 1))
        {
            AddStatusMonitorLogEvent(eIcon, tszStatus);
            bStatus = FALSE;
        }

        eIcon = LIST_IMAGE_ERROR;
        dwStatusId = IDS_FAX_RETRIES_EXCEEDED;
    }
    else if(pStatus->dwQueueStatus & JS_RETRYING)
    {
        if(!(bStatus = GetStatusEx(pStatus, &eIcon, tszStatus, ARR_SIZE(tszStatus) - 1)))
        {
            eIcon = LIST_IMAGE_ERROR;
            dwStatusId = IDS_FAX_FATAL_ERROR_SND;
        }
    }
    

    if(!bStatus && dwStatusId)
    {
        if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (dwStatusId, tszStatus)))
        {
            bStatus = FALSE;
        }
        else
        {
            bStatus = TRUE;
        }
    }

    if(bStatus)
    {
        AddStatusMonitorLogEvent (eIcon, tszStatus);
    }    

    if(!(pStatus->dwQueueStatus & JS_INPROGRESS))
    {
        g_dwCurrentJobID = 0;

        SetStatusMonitorDeviceState(FAX_IDLE);

        SetIconState(ICON_SENDING,   FALSE);
        SetIconState(ICON_RECEIVING, FALSE);
    }
    
    if(pStatus->dwQueueStatus & (JS_FAILED | JS_RETRIES_EXCEEDED | JS_RETRYING))
    {
        if(JT_SEND == pStatus->dwJobType)
        {
            g_dwlSendFailedMsgId = g_dwlCurrentMsgID;
        }

        SetIconState((JT_SEND == pStatus->dwJobType) ? ICON_SEND_FAILED : ICON_RECEIVE_FAILED, TRUE, tszStatus);
    }

    if((JT_SEND == pStatus->dwJobType) && (pStatus->dwQueueStatus & JS_COMPLETED))
    {
        SetIconState(ICON_SEND_SUCCESS, TRUE, tszStatus);
        g_dwlSendSuccessMsgId = g_dwlCurrentMsgID;
    }
} // StatusUpdate

/*
Unhandled Job Statuses:
 JS_NOLINE 
 JS_PAUSED 
 JS_PENDING
 JS_DELETING     
 
Unhandled Extneded Job Statuses:
 JS_EX_HANDLED           
*/

BOOL
GetStatusEx(
    PFAX_JOB_STATUS pStatus,
    eIconType*      peIcon,
    TCHAR*          ptsStatusEx,
    DWORD           dwSize
)
/*++

Routine description:

    Find string description and icon type for a job 
    according to its extended status

Arguments:

    pStatus     - [in]  job status data
    peIcon      - [out] job icon type
    ptsStatusEx - [out] job status string
    dwSize      - [in]  status string size

Return Value:

    TRUE if success
    FALSE otherwise

--*/
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("GetStatusEx"), bRes);

    ASSERTION (pStatus && peIcon && ptsStatusEx);

    if(!(pStatus->dwValidityMask & FAX_JOB_FIELD_STATUS_EX) || 
        !pStatus->dwExtendedStatus)
    {
        return FALSE;
    }

    TCHAR tszFormat[MAX_PATH]={0};

    *peIcon = LIST_IMAGE_NONE;
    for(DWORD dw=0; g_StatusEx[dw].dwExtStatus != 0; ++dw)
    {
        if(g_StatusEx[dw].dwExtStatus == pStatus->dwExtendedStatus)
        {
            DWORD dwRes;

            *peIcon = g_StatusEx[dw].eIcon;
            if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (g_StatusEx[dw].uResourceId, tszFormat)))
            {
                return bRes;
            }
            break;
        }
    }

    switch(pStatus->dwExtendedStatus)    
    {
        case JS_EX_DIALING:
            //
            // For outgoing fax FAX_JOB_STATUS.lpctstrCallerID field
            // contains a recipient fax number.
            //
            CopyLTRString(g_szAddress, pStatus->lpctstrCallerID, ARR_SIZE(g_szAddress) - 1);

            _sntprintf(ptsStatusEx, dwSize, tszFormat, g_szAddress);
            break;

        case JS_EX_TRANSMITTING:
            _sntprintf(ptsStatusEx, dwSize, tszFormat, pStatus->dwCurrentPage, pStatus->dwPageCount);
            break;

        case JS_EX_RECEIVING:
            _sntprintf(ptsStatusEx, dwSize, tszFormat, pStatus->dwCurrentPage);
            break;

        case JS_EX_FATAL_ERROR:
            {
                DWORD dwRes;
                if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (
                                        (JT_SEND == pStatus->dwJobType) ? 
                                                IDS_FAX_FATAL_ERROR_SND : 
                                                IDS_FAX_FATAL_ERROR_RCV, 
                                        ptsStatusEx)))
                {
                    return bRes;
                }
            }
            break;

        case JS_EX_PROPRIETARY:
            _tcsncpy(ptsStatusEx, pStatus->lpctstrExtendedStatus ? pStatus->lpctstrExtendedStatus : TEXT(""), dwSize);
            break;

        default:
            _tcsncpy(ptsStatusEx, tszFormat, dwSize);
            break;
    }
    bRes = TRUE;
    return bRes;
} // GetStatusEx


BOOL
IsNotifyEnable(
    eIconState state
)
/*++

Routine description:

  Check if the UI notification is enabled for a specific icon state

Arguments:

  state  [in] - icon state

Return Value:

  TRUE if the notification is enabled
  FASLE otherwise

--*/
{
    BOOL bEnable = TRUE;
    switch(state)
    {
    case ICON_SENDING:
    case ICON_RECEIVING:
        bEnable = g_ConfigOptions.bNotifyProgress;
        break;

    case ICON_NEW_FAX:
    case ICON_RECEIVE_FAILED:
        bEnable = g_ConfigOptions.bNotifyInCompletion;
        break;

    case ICON_SEND_SUCCESS:
    case ICON_SEND_FAILED:
        bEnable = g_ConfigOptions.bNotifyOutCompletion;
        break;

    };

    return bEnable;

} // IsNotifyEnable

eIconState
GetVisibleIconType ()
/*++

Routine name : GetVisibleIconType

Routine description:

	Return the index (type) of the currently visible icon

Author:

	Eran Yariv (EranY),	May, 2001

Arguments:


Return Value:

    Icon type

--*/
{
    for(int index = ICON_RINGING; index < ICONS_COUNT; ++index)
    {
        if(!IsNotifyEnable(eIconState(index)))
        {
            continue;
        }

        if(g_Icons[index].bEnable)
        {
            return eIconState(index);
        }
    }
    return ICONS_COUNT;
}   // GetVisibleIconType

void
EvaluateIcon()
/*++

Routine description:

  Show notification icon, tooltip and balloon
  according to the current icon state

Arguments:

Return Value:

  none

--*/
{    
    DBG_ENTER(TEXT("EvaluateIcon"));

    ASSERTION (g_hWndFaxNotify);

    NOTIFYICONDATA iconData = {0};

    iconData.cbSize           = sizeof(iconData);
    iconData.hWnd             = g_hWndFaxNotify;
    iconData.uID              = TRAY_ICON_ID;
    iconData.uFlags           = NIF_MESSAGE | NIF_TIP;
    iconData.uCallbackMessage = WM_TRAYCALLBACK;


    g_CurrentIcon = GetVisibleIconType();
    if(ICONS_COUNT == g_CurrentIcon)
    {
        //
        // No visible icon
        //
        if(g_bIconAdded)
        {
            Shell_NotifyIcon(NIM_DELETE, &iconData);
            g_bIconAdded = FALSE;
        }

        //
        // No icon - no balloon
        //
        g_BalloonInfo.bDelete = FALSE;
        g_BalloonInfo.bEnable = FALSE;
        return;
    }
    iconData.uFlags = iconData.uFlags | NIF_ICON;
    iconData.hIcon  = g_Icons[g_CurrentIcon].hIcon;
    
    _tcscpy(iconData.szTip, g_Icons[g_CurrentIcon].tszToolTip);

    if(g_BalloonInfo.bEnable)
    {
        if(IsNotifyEnable(g_BalloonInfo.eState))
        {
            //
            // Show balloon tooltip
            //
            iconData.uTimeout    = g_Icons[g_BalloonInfo.eState].dwBalloonTimeout;
            iconData.uFlags      = iconData.uFlags | NIF_INFO;
            iconData.dwInfoFlags = g_Icons[g_BalloonInfo.eState].dwBalloonIcon | NIIF_NOSOUND;

            _tcscpy(iconData.szInfo,      g_BalloonInfo.szInfo);
            _tcscpy(iconData.szInfoTitle, g_BalloonInfo.szInfoTitle);
        }
        g_BalloonInfo.bEnable = FALSE;
    }

    if(g_BalloonInfo.bDelete)
    {
        //
        // Destroy currently open balloon tooltip
        //
        iconData.uFlags = iconData.uFlags | NIF_INFO;

        _tcscpy(iconData.szInfo,      TEXT(""));
        _tcscpy(iconData.szInfoTitle, TEXT(""));

        g_BalloonInfo.bDelete = FALSE;
    }

    Shell_NotifyIcon(g_bIconAdded ? NIM_MODIFY : NIM_ADD, &iconData);
    g_bIconAdded = TRUE;
} // EvaluateIcon

void
SetIconState(
    eIconState eIcon,
    BOOL       bEnable,
    TCHAR*     ptsStatus /* = NULL */
)
/*++

Routine description:

  Change notification bar icon state.

Arguments:

    eIcon      - icon type
    bEnable    - icon state (enable/disable)
    ptsStatus  - status string (optional)

Return Value:

  none

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("SetIconState"), 
              TEXT("Icon id=%d, Enable=%d, Status=%s"),
              eIcon,
              bEnable,
              ptsStatus);

    ASSERTION (eIcon < ICONS_COUNT);

    if(!bEnable && eIcon != ICON_RINGING)
    {
        //
        // We're turning off a state - nothing special to do
        //
        goto exit;
    }

    TCHAR tsFormat[MAX_PATH]= {0};
    LPCTSTR strParam      = NULL;
    DWORD   dwStringResId = 0;

    switch(eIcon)
    {
        case ICON_RINGING:
            if(bEnable)
            {
                //
                // Sound, Balloon, and Animation 
                //
                SetIconState(ICON_SENDING,   FALSE);
                SetIconState(ICON_RECEIVING, FALSE);

                g_BalloonInfo.bEnable = TRUE;
                g_BalloonInfo.eState  = eIcon;

                //
                // Compose the balloon tooltip
                //
                strParam      = NULL;
                dwStringResId = IDS_INCOMING_CALL;
                if(_tcslen(g_szAddress))
                {
                    //
                    // Caller id is known - use it in formatted string
                    //
                    strParam = g_szAddress;
                    dwStringResId = IDS_INCOMING_CALL_FROM;
                }
                if (ERROR_SUCCESS != LoadAndFormatString(dwStringResId, tsFormat, strParam))
                {
                    return;
                }

                _tcsncpy(g_BalloonInfo.szInfoTitle, tsFormat, MAX_BALLOON_TITLE_LEN-1);

                if (ERROR_SUCCESS != LoadAndFormatString(IDS_CLICK_TO_ANSWER, g_BalloonInfo.szInfo))
                {
                    return;
                }

                //
                // Set tooltip
                //
                _sntprintf(g_Icons[eIcon].tszToolTip, 
                           TOOLTIP_SIZE-1, 
                           TEXT("%s\n%s"), 
                           tsFormat, 
                           g_BalloonInfo.szInfo);

                if(!g_uRingTimerID)
                {
                    //
                    // Set animation timer
                    //
                    g_uRingTimerID = SetTimer(NULL, 0, RING_ANIMATION_FRAME_DELAY, RingTimerProc);
                    if(!g_uRingTimerID)
                    {
                        dwRes = GetLastError();
                        CALL_FAIL (GENERAL_ERR, TEXT ("SetTimer"), dwRes);
                    }
                    else
                    {
                        g_dwRingAnimationStartTick = GetTickCount();
                    }
                }
            }
            else // disable ringing
            {   
                if(g_Icons[eIcon].bEnable)
                {
                    //
                    // Remove ringing balloon
                    //
                    g_BalloonInfo.bDelete = TRUE;
                }

                if(g_uRingTimerID)
                {
                    //
                    // kill animation timer
                    //
                    if(!KillTimer(NULL, g_uRingTimerID))
                    {
                        dwRes = GetLastError();
                        CALL_FAIL (GENERAL_ERR, TEXT ("KillTimer"), dwRes);
                    }
                    g_uRingTimerID = 0;
                    g_dwRingAnimationStartTick = 0;
                }
            }
            break;

        case ICON_SENDING:
            //
            // Compose tooltip
            //
            if (ERROR_SUCCESS != LoadAndFormatString (IDS_SENDING_TO, tsFormat, g_szRemoteId))
            {
                return;
            }              
            _sntprintf(g_Icons[eIcon].tszToolTip, 
                       TOOLTIP_SIZE-1, 
                       TEXT("%s\n%s"), 
                       tsFormat, 
                       ptsStatus ? ptsStatus : TEXT(""));

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                SetIconState(ICON_RINGING,   FALSE);
                SetIconState(ICON_RECEIVING, FALSE);

                //
                // Open fax monitor 
                //
                if(g_ConfigOptions.bMonitorOnSend)
                {
                    dwRes = OpenFaxMonitor();
                    if(ERROR_SUCCESS != dwRes)
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT ("OpenFaxMonitor"), dwRes);
                    }
                }
            }
            break;

        case ICON_RECEIVING:

            //
            // Compose tooltip
            // 
            strParam      = NULL;
            dwStringResId = IDS_RECEIVING;
            if(_tcslen(g_szRemoteId))
            {
                strParam      = g_szRemoteId;
                dwStringResId = IDS_RECEIVING_FROM;
            }

            if (ERROR_SUCCESS != LoadAndFormatString (dwStringResId, tsFormat, strParam))
            {
                return;
            }
            _sntprintf(g_Icons[eIcon].tszToolTip, 
                       TOOLTIP_SIZE-1, 
                       TEXT("%s\n%s"), 
                       tsFormat, 
                       ptsStatus ? ptsStatus : TEXT(""));

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                SetIconState(ICON_RINGING, FALSE);
                SetIconState(ICON_SENDING, FALSE);

                //
                // open fax monitor 
                //
                if(g_ConfigOptions.bMonitorOnReceive)
                {
                    dwRes = OpenFaxMonitor();
                    if(ERROR_SUCCESS != dwRes)
                    {
                        CALL_FAIL (GENERAL_ERR, TEXT ("OpenFaxMonitor"), dwRes);
                    }
                }
            }
            break;

        case ICON_SEND_FAILED:
            //
            // Compose tooltip
            //
            if (ERROR_SUCCESS != LoadAndFormatString (IDS_SEND_ERROR_BALLOON, tsFormat, g_szRemoteId))
            {
                return;
            }

            _sntprintf(g_Icons[eIcon].tszToolTip, 
                       TOOLTIP_SIZE-1, 
                       TEXT("%s\n%s"),
                       tsFormat, 
                       ptsStatus ? ptsStatus : TEXT(""));

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                if(g_ConfigOptions.bSoundOnError)
                {
                    if(!PlaySound(g_Icons[eIcon].pctsSound, NULL, SND_ASYNC | SND_APPLICATION | SND_NODEFAULT))
                    {
                        CALL_FAIL (WINDOW_ERR, TEXT ("PlaySound"), 0);
                    }
                }

                g_BalloonInfo.bEnable = TRUE;
                g_BalloonInfo.eState  = eIcon;            

                //
                // Compose the balloon
                //
                _tcsncpy(g_BalloonInfo.szInfoTitle, tsFormat, MAX_BALLOON_TITLE_LEN-1);
                _tcsncpy(g_BalloonInfo.szInfo, ptsStatus ? ptsStatus : TEXT(""), MAX_BALLOON_TEXT_LEN-1);
            }
            break;

        case ICON_RECEIVE_FAILED:
            //
            // Compose tooltip
            // 
            strParam      = NULL;
            dwStringResId = IDS_RCV_ERROR_BALLOON;
            if(_tcslen(g_szRemoteId))
            {
                strParam      = g_szRemoteId;
                dwStringResId = IDS_RCV_FROM_ERROR_BALLOON;
            }

            if (ERROR_SUCCESS != LoadAndFormatString (dwStringResId, tsFormat, strParam))
            {
                return;
            }

            _sntprintf(g_Icons[eIcon].tszToolTip, 
                       TOOLTIP_SIZE-1, 
                       TEXT("%s\n%s"),
                       tsFormat, 
                       ptsStatus ? ptsStatus : TEXT(""));

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                if(g_ConfigOptions.bSoundOnError)
                {
                    if(!PlaySound(g_Icons[eIcon].pctsSound, NULL, SND_ASYNC | SND_APPLICATION | SND_NODEFAULT))
                    {
                        CALL_FAIL (WINDOW_ERR, TEXT ("PlaySound"), 0);
                    }
                }

                g_BalloonInfo.bEnable = TRUE;
                g_BalloonInfo.eState  = eIcon; 

                //
                // Compose the balloon
                //
                _tcsncpy(g_BalloonInfo.szInfoTitle, tsFormat, MAX_BALLOON_TITLE_LEN-1);
                _tcsncpy(g_BalloonInfo.szInfo, ptsStatus ? ptsStatus : TEXT(""), MAX_BALLOON_TEXT_LEN-1);
            }
            break;

        case ICON_NEW_FAX:
            //
            // Compose tooltip
            // 
            strParam      = NULL;
            dwStringResId = IDS_NEW_FAX_BALLOON;
            if(_tcslen(g_szRemoteId))
            {
                strParam      = g_szRemoteId;
                dwStringResId = IDS_NEW_FAX_FROM_BALLOON;
            }

            if (ERROR_SUCCESS != LoadAndFormatString (dwStringResId, tsFormat, strParam))
            {
                return;
            }

            if (ERROR_SUCCESS != LoadAndFormatString (IDS_CLICK_TO_VIEW, g_BalloonInfo.szInfo))
            {
                return;
            }

            _sntprintf(g_Icons[eIcon].tszToolTip, 
                       TOOLTIP_SIZE-1, 
                       TEXT("%s\n%s"),
                       tsFormat, 
                       g_BalloonInfo.szInfo);

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                if (g_ConfigOptions.bSoundOnReceive)
                {
                    if(!PlaySound(g_Icons[eIcon].pctsSound, NULL, SND_ASYNC | SND_APPLICATION | SND_NODEFAULT))
                    {
                        CALL_FAIL (WINDOW_ERR, TEXT ("PlaySound"), 0);
                    }
                }

                g_BalloonInfo.bEnable = TRUE;
                g_BalloonInfo.eState  = eIcon;            
        
                //
                // Compose the balloon
                //
                _tcsncpy(g_BalloonInfo.szInfoTitle, tsFormat, MAX_BALLOON_TITLE_LEN-1);
            }
            break;

        case ICON_SEND_SUCCESS:

            if(!g_Icons[eIcon].bEnable)
            {
                //
                // Turn the icon on
                //
                if(g_ConfigOptions.bSoundOnSent)
                {
                    if(!PlaySound(g_Icons[eIcon].pctsSound, NULL, SND_ASYNC | SND_APPLICATION | SND_NODEFAULT))
                    {
                        CALL_FAIL (WINDOW_ERR, TEXT ("PlaySound"), 0);
                    }
                }

                g_BalloonInfo.bEnable = TRUE;
                g_BalloonInfo.eState  = eIcon;

                //
                // Compose the balloon
                //
                if (ERROR_SUCCESS != LoadAndFormatString (IDS_SEND_OK, tsFormat))
                {
                    return;
                }
                _tcsncpy(g_BalloonInfo.szInfoTitle, tsFormat, MAX_BALLOON_TITLE_LEN-1);
                
                if (ERROR_SUCCESS != LoadAndFormatString (IDS_SEND_OK_BALLOON, g_BalloonInfo.szInfo, g_szRemoteId))
                {
                    return;
                }
            }
            break;

        default:
            break;
    }

exit:
    g_Icons[eIcon].bEnable = bEnable;

    EvaluateIcon();
} // SetIconState

VOID 
CALLBACK 
RingTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
/*++

Routine description:

    Animate ringing icon

Arguments:

  hwnd    - handle to window
  uMsg    - WM_TIMER message
  idEvent - timer identifier
  dwTime  - current system time

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("RingTimerProc"));
    if ((GetTickCount() - g_dwRingAnimationStartTick) > RING_ANIMATION_TIMEOUT)
    {
        //
        // Animation has expired - keep static icon
        //
        g_Icons[ICON_RINGING].hIcon = g_RingIcons[0].hIcon;
        if(!KillTimer(NULL, g_uRingTimerID))
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("KillTimer"), GetLastError());
        }
        g_uRingTimerID = 0;
        g_dwRingAnimationStartTick = 0;
    }
    else
    {
        g_dwCurrRingIconIndex = (g_dwCurrRingIconIndex + 1) % RING_ICONS_NUM;
        g_Icons[ICON_RINGING].hIcon = g_RingIcons[g_dwCurrRingIconIndex].hIcon;
    }
    EvaluateIcon();
}   // RingTimerProc


VOID
InvokeClientConsole ()
/*++

Routine description:

  Invoke Client Console

Arguments:

  none

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("InvokeClientConsole"));

    TCHAR szCmdLine[MAX_PATH];
    static TCHAR szFmtMsg[]   = TEXT(" -folder %s -MessageId %I64x");
    static TCHAR szFmtNoMsg[] = TEXT(" -folder %s");

    DWORDLONG dwlMsgId = 0;
    LPCWSTR lpcwstrFolder = TEXT("");


    switch (g_CurrentIcon)
    {
        case ICON_RINGING:          // Line is ringing - nothing special to do
        case ICON_RECEIVE_FAILED:   // Receive operation failed - nothing special to do
        default:                    // Any other icon state - nothing special to do
            break;

        case ICON_SENDING:
            //
            // Device is sending - open fax console in Outbox folder
            //
            dwlMsgId = g_dwlCurrentMsgID;
            lpcwstrFolder = CONSOLE_CMD_PRM_STR_OUTBOX;
            break;

        case ICON_SEND_FAILED:
            //
            // Send operation failed - open fax console in Outbox folder
            //
            dwlMsgId = g_dwlSendFailedMsgId;
            lpcwstrFolder = CONSOLE_CMD_PRM_STR_OUTBOX;
            break;

        case ICON_RECEIVING:
            //
            // Device is receiving - open fax console in Incoming folder
            //
            dwlMsgId = g_dwlCurrentMsgID;
            lpcwstrFolder = CONSOLE_CMD_PRM_STR_INCOMING;
            break;
    
            break;

        case ICON_NEW_FAX:
            //
            // New unread fax - open fax console in Inbox folder
            //
            dwlMsgId = g_dwlNewMsgId;
            lpcwstrFolder = CONSOLE_CMD_PRM_STR_INBOX;
            break;

        case ICON_SEND_SUCCESS:
            //
            // Send was successful - open fax console in Sent Items folder
            //
            dwlMsgId = g_dwlSendSuccessMsgId;
            lpcwstrFolder = CONSOLE_CMD_PRM_STR_SENT_ITEMS;
            break;
    }

    if (dwlMsgId)
    {
        wsprintf (szCmdLine, szFmtMsg, lpcwstrFolder, dwlMsgId);
    }
    else
    {
        wsprintf (szCmdLine, szFmtNoMsg, lpcwstrFolder);
    }

    HINSTANCE hRes;
    hRes = ShellExecute(g_hWndFaxNotify, 
                 NULL, 
                 FAX_CLIENT_CONSOLE_IMAGE_NAME,
                 szCmdLine,
                 NULL,
                 SW_SHOW);
    if((DWORD_PTR)hRes <= 32)
    {
        //
        // error
        //
        CALL_FAIL (GENERAL_ERR, TEXT("ShellExecute"), PtrToUlong(hRes));
    }    

} // InvokeClientConsole

VOID
AnswerTheCall ()
/*++

Routine description:

  Answer the current incoming call

Arguments:

  none

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("AnswerTheCall"));
    DWORD dwDeviceId;

    //
    // Check for 'Answer now' capabilities and auto-detect the device id.
    //
    DWORD dwRes = CheckAnswerNowCapability (TRUE,           // Start service if necessary
                                            &dwDeviceId);   // Get device id for FaxAnswerCall
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Can't 'Answer Now' - dwRes has the string resource id for the message to show to the user.
        //
        FaxMessageBox (g_hMonitorDlg, dwRes, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    //
    // Reset remote ID
    //
    _tcscpy(g_szRemoteId, TEXT(""));

    //
    // Looks like we have a chance of FaxAnswerCall succeeding - let's try it.
    // First, open the monitor (or make sure it's already open).
    //
    OpenFaxMonitor ();
    //
    // Start by disabling the 'Answer Now' button on the monitor dialog
    //
    if (g_hMonitorDlg)
    {
        //
        // Monitor dialog is there
        //
        HWND hWndAnswerNow = GetDlgItem(g_hMonitorDlg, IDC_DISCONNECT);
        if(hWndAnswerNow)
        {
            EnableWindow(hWndAnswerNow, FALSE);
        }
    }
    //
    // Call is gone
    //
    g_hCall = NULL;
    SetIconState(ICON_RINGING, FALSE, TEXT(""));

    if(!FaxAnswerCall(g_hFaxSvcHandle, dwDeviceId))
    {
        CALL_FAIL (RPC_ERR, TEXT ("FaxAnswerCall"), GetLastError());
        FaxMessageBox(g_hWndFaxNotify, IDS_CANNOT_ANSWER, MB_OK | MB_ICONEXCLAMATION);
        SetStatusMonitorDeviceState (FAX_IDLE);
    }
    else
    {
        g_tszLastEvent[0] = TEXT('\0');
        SetStatusMonitorDeviceState(FAX_RECEIVING);
    }
} // AnswerTheCall

VOID 
FaxPrinterProperties(DWORD dwPage)
/*++

Routine description:

  Open Fax Printer Property Sheet

Arguments:

  dwPage - page number

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("FaxPrinterProperties"));

    //
    // open fax printer properties on the Tracking page
    //
    TCHAR tsPrinter[MAX_PATH];

    typedef VOID (*PRINTER_PROP_PAGES_PROC)(HWND, LPCTSTR, INT, LPARAM);  

    HMODULE hPrintUI = NULL;
    PRINTER_PROP_PAGES_PROC fpPrnPropPages = NULL;

    if(!GetFirstLocalFaxPrinterName(tsPrinter, MAX_PATH))
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("GetFirstLocalFaxPrinterName"), GetLastError());
        return;
    }
    
    hPrintUI = LoadLibrary(TEXT("printui.dll"));
    if(!hPrintUI)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("LoadLibrary(printui.dll)"), GetLastError());
        return;
    }

    fpPrnPropPages = (PRINTER_PROP_PAGES_PROC)GetProcAddress(hPrintUI, "vPrinterPropPages");
    if(fpPrnPropPages)
    {
        fpPrnPropPages(g_hWndFaxNotify, tsPrinter, SW_SHOWNORMAL, dwPage);
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("GetProcAddress(vPrinterPropPages)"), GetLastError());
    }
    
    FreeLibrary(hPrintUI);

} // FaxPrinterProperties

VOID
DoFaxContextMenu (HWND hwnd)
/*++

Routine description:

  Popup and handle context menu

Arguments:

  hwnd   - notification window handle

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("DoFaxContextMenu"));

    POINT pt;
    HMENU hm = LoadMenu (g_hInstance, MAKEINTRESOURCE (IDM_FAX_MENU));
    HMENU hmPopup = GetSubMenu(hm, 0);

    if (!g_Icons[ICON_RINGING].bEnable)
    {
        RemoveMenu (hmPopup, ID_ANSWER_CALL, MF_BYCOMMAND);
    }

    if(g_dwCurrentJobID == 0)
    {
        RemoveMenu (hmPopup, ID_DISCONNECT_CALL, MF_BYCOMMAND);
    }

    if(!g_Icons[ICON_RINGING].bEnable && g_dwCurrentJobID == 0)
    {
        //
        // delete the menu separator
        //
        DeleteMenu(hmPopup, 0, MF_BYPOSITION);
    }

    SetMenuDefaultItem(hmPopup, ID_FAX_QUEUE, FALSE);

    GetCursorPos (&pt);
    SetForegroundWindow(hwnd);

    INT idCmd = TrackPopupMenu (GetSubMenu(hm, 0),
                                TPM_RETURNCMD | TPM_NONOTIFY,
                                pt.x, pt.y,
                                0, hwnd, NULL);
    switch (idCmd)
    {
        case ID_ICON_PROPERTIES:
            FaxPrinterProperties(IsSimpleUI() ? 3 : 5);
            break;

         case ID_FAX_QUEUE:
             InvokeClientConsole ();
             break;

         case ID_ANSWER_CALL:
             AnswerTheCall ();
             break;

         case ID_FAX_MONITOR:
             OpenFaxMonitor ();
             break;

         case ID_DISCONNECT_CALL:
             OnDisconnect();
             break;
    }
    if (hm)
    {
        DestroyMenu (hm);
    }
} // DoFaxContextMenu


VOID
OnTrayCallback (HWND hwnd, WPARAM wp, LPARAM lp)
/*++

Routine description:

  Handle messages from the notification icon

Arguments:

  hwnd   - notification window handle
  wp     - message parameter
  lp     - message parameter

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("OnTrayCallback"), TEXT("hWnd=%08x, wParam=%08x, lParam=%08x"), hwnd, wp, lp);

    switch (lp)
    {
        case NIN_BALLOONUSERCLICK:      // User clicked balloon or
        case WM_LBUTTONDOWN:            // User pressed icon
        {
            //
            // Our behavior depends on the icon currently being displyed
            //
            switch (g_CurrentIcon)
            {
                case ICON_RINGING:
                    //    
                    // Device is ringing - answer the call
                    //
                    AnswerTheCall ();
                    break;

                case ICON_NEW_FAX:              // New unread fax - open fax console in Inbox folder
                case ICON_SEND_SUCCESS:         // Send was successful - open fax console in Sent Items folder
                case ICON_SEND_FAILED:          // Send operation failed - open fax console in Outbox folder
                    //
                    // Turn off the current icon state
                    //
                    InvokeClientConsole ();
                    SetIconState(g_CurrentIcon, FALSE);
                    break;

                case ICON_SENDING:              // Device is sending - open fax console in Outbox folder
                case ICON_RECEIVING:            // Device is receiving - open fax console in Incoming folder
                    InvokeClientConsole ();
                    break;

                case ICON_RECEIVE_FAILED:
                    //
                    // Receive operation failed
                    //
                    SetIconState(g_CurrentIcon, FALSE);
                    break;

                case ICON_IDLE:                 // Don't display an icon - this cannot be a valid current icon state
                case ICONS_COUNT:               // No active icon state was found - this can't happen because we got an icon message
                default:                        // Some bizzare icon index - a bug
                    ASSERTION_FAILURE;
                    break;
            }    
        }
        //
        // no break ==> fall-through
        //
        case NIN_BALLOONTIMEOUT:
            if (g_BalloonInfo.eState == ICON_RECEIVE_FAILED ||
                g_BalloonInfo.eState == ICON_SEND_SUCCESS)
            {
                SetIconState(g_BalloonInfo.eState, FALSE);
            }
            g_BalloonInfo.eState = ICON_IDLE;
            break;

        case WM_RBUTTONDOWN:
            DoFaxContextMenu (hwnd);
            break;

    }
} // OnTrayCallback

BOOL 
IsUserGrantedAccess(
    DWORD dwAccess
)
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("IsUserGrantedAccess"), bRes, TEXT("%d"), dwAccess);
    if (!g_hFaxSvcHandle)
    {
        //
        // Not connected - no rights
        //
        return bRes;
    }
    if (dwAccess == (g_ConfigOptions.dwAccessRights & dwAccess))
    {
        bRes = TRUE;
    }
    return bRes;
}   // IsUserGrantedAccess


DWORD
CheckAnswerNowCapability (
    BOOL    bForceReconnect,
    LPDWORD lpdwDeviceId /* = NULL */
)
/*++

Routine name : CheckAnswerNowCapability

Routine description:

	Checks if the 'Answer Now' option can be used

Author:

	Eran Yariv (EranY),	Mar, 2001

Arguments:

    bForceReconnect [in]  - If the service is down, should we bring it up now?
    lpdwDeviceId    [out] - The device id to use when calling FaxAnswerCall.
                            If the Manual-Answer-Device is ringing, we use the Manual-Answer-Device id.
                            Otherwise, it's the monitored device id. (Optional)

Return Value:

    ERROR_SUCCESS if the 'Answer Now' can be used.
    Othewise, returns a string resource id that can be used in a message box to tell the user
    why 'Answer Now' is not available.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CheckAnswerNowCapability"), dwRes);
    //
    // First, let's see if we're connected to the local server
    //
    if (NULL == g_hFaxSvcHandle)
    {
        //
        // Service is down
        //
        if (!bForceReconnect)
        {   
            //
            // We assume the user can 'Answer now'
            //
            ASSERTION (NULL == lpdwDeviceId);
            return dwRes;
        }
        //
        // Try to start up the local fax service
        //
        if (!Connect())
        {
            //
            // Couldn't start up the service
            //
            dwRes = GetLastError ();
            CALL_FAIL (GENERAL_ERR, TEXT("Connect"), dwRes);
            dwRes = IDS_ERR_CANT_TALK_TO_SERVICE; 
            return dwRes;
        }
        //
        // Now that the service is up - we need to connect.
        // Send a message to the main window to bring up the connection.
        //
        if (!SendMessage (g_hWndFaxNotify, WM_FAX_STARTED, 0, 0))
        {
            //
            // Failed to connect
            //
            dwRes = IDS_ERR_CANT_TALK_TO_SERVICE; 
            return dwRes;
        }
        //
        // Now we're connected !!!
        //
    }
    if (!IsUserGrantedAccess (FAX_ACCESS_QUERY_IN_ARCHIVE))
    {
        //
        // User can't receive-now
        //
        dwRes = IDS_ERR_ACCESS_DENIED; 
        return dwRes;
    }
    if (0 == g_ConfigOptions.dwMonitorDeviceId)
    {
        //
        // No devices
        //
        dwRes = IDS_ERR_NO_DEVICES;
        return dwRes;
    }
    if (g_hCall)
    {
        //
        // The Manual-Answer-Device is ringing, we use the Manual-Answer-Device id.
        //
        ASSERTION (g_ConfigOptions.dwManualAnswerDeviceId);
        if (lpdwDeviceId)
        {
            *lpdwDeviceId = g_ConfigOptions.dwManualAnswerDeviceId;
        }
        return dwRes;
    }
    //
    // The Manual-Answer-Device is NOT ringing; we should receive on the monitored device
    //
    if ((0 != g_dwCurrentJobID) || (FAX_IDLE != g_devState))
    {
        //
        // There's a job on the monitored device
        //
        dwRes = IDS_ERR_DEVICE_BUSY;
        return dwRes;
    }
    //
    // One last check - is the monitored device virtual?
    //
    BOOL bVirtual;
    dwRes = IsDeviceVirtual (g_hFaxSvcHandle, g_ConfigOptions.dwMonitorDeviceId, &bVirtual);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Can't tell - assume virtual
        //
        bVirtual = TRUE;
    }
    if (bVirtual)
    {
        //
        // Sorry, manual answering on virtual devices is NOT supported
        //
        dwRes = IDS_ERROR_VIRTUAL_DEVICE;
        return dwRes;
    }
    //
    // It's ok to call FaxAnswerCall on the monitored device
    //
    if (lpdwDeviceId)
    {
        *lpdwDeviceId = g_ConfigOptions.dwMonitorDeviceId;
    }
    return dwRes;
}   // CheckAnswerNowCapability

LRESULT 
CALLBACK
NotifyWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
/*++

Routine description:

  Notification window procedure

Arguments:

  hwnd   - notification window handle
  msg    - message ID
  wp     - message parameter
  lp     - message parameter

Return Value:

  result

--*/
{
    switch (msg)
    {
        case WM_CREATE:
            break;

        case WM_FAX_STARTED:
            //
            // We get this message after service startup event
            //
            return RegisterForServerEvents();

        case WM_TRAYCALLBACK:
            OnTrayCallback (hwnd, wp, lp);
            break;

        case WM_FAX_EVENT:

#ifndef DEBUG
            try
            {
#endif
                OnFaxEvent ((FAX_EVENT_EX*)lp);
#ifndef DEBUG
            }
            catch(...)
            {
                //
                // Do not handle the exception for the debug version
                //
                DBG_ENTER(TEXT("NotifyWndProc"));
                CALL_FAIL (GENERAL_ERR, TEXT("OnFaxEvent"), 0);
                return 0;
            }
#endif
            return 0;

        case WM_FAXSTAT_CONTROLPANEL:
            //
            // configuration has been changed
            //
            GetConfiguration ();
            EvaluateIcon();
            UpdateMonitorData(g_hMonitorDlg);
            return 0;

        case WM_FAXSTAT_OPEN_MONITOR:
            OpenFaxMonitor ();
            return 0;

        case WM_FAXSTAT_INBOX_VIEWED:
            //
            // Client Console Inbox has been viewed
            //
            SetIconState(ICON_NEW_FAX, FALSE);
            return 0;

        case WM_FAXSTAT_OUTBOX_VIEWED:
            //
            // Client Console Outbox has been viewed
            //
            SetIconState(ICON_SEND_FAILED, FALSE);
            return 0;

        case WM_FAXSTAT_RECEIVE_NOW:
            //
            // Start receiving now
            //
            AnswerTheCall ();
            return 0;

        case WM_FAXSTAT_PRINTER_PROPERTY:
            //
            // Open Fax Printer Property Sheet
            //
            FaxPrinterProperties((DWORD)(wp));
            return 0;

        default:
           break;
    }
    return CallWindowProc (DefWindowProc, hwnd, msg, wp, lp);
} // NotifyWndProc

VOID
CopyLTRString(
    TCHAR*  szDest, 
    LPCTSTR szSource, 
    DWORD   dwSize)
/*++

Routine description:

  Copy the string and add left-to-right Unicode control characters if needed

Arguments:

  szDest    - destination string
  szSource  - source string
  dwSize    - destination string maximum size in characters

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("CopyLTRString"));

    if(!szDest)
    {
        ASSERTION_FAILURE;
        return;
    }

    if(IsRTLUILanguage() && szSource && _tcslen(szSource))
    {
        //
        // The string always should be LTR
        // Add LEFT-TO-RIGHT OVERRIDE  (LRO)
        //
        _sntprintf(szDest, 
                   dwSize,
                   TEXT("%c%s%c"),
                   UNICODE_LRO,
                   szSource,
                   UNICODE_PDF);

    }
    else
    {
        _tcsncpy(szDest, 
                 szSource ? szSource : TEXT(""), 
                 dwSize);
    }

} // CopyLTRString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\systray\resource.h ===
#ifndef _INC_FAX_ST_RES_
#define _INC_FAX_ST_RES_


// dialogs
#define IDD_FAX_ANSWER_CALL             1102

// resources
#define IDR_FAX_IDLE                    1201
#define IDR_FAX_SEND                    1202
#define IDR_FAX_RECEIVE                 1203
#define IDI_SEND_SUCCESS                1204
#define IDI_SENDING                     1206
#define IDI_RECEIVING                   1207
#define IDI_SEND_FAILED                 1208
#define IDI_RECEIVE_FAILED              1209
#define IDI_NEW_FAX                     1210
#define IDI_RINGING_1                   1211
#define IDI_RINGING_2                   1212
#define IDI_RINGING_3                   1213
#define IDI_RINGING_4                   1214

#define IDR_FAX_RINGING                 1215

// icons
#define IDI_FAX_NORMAL                  1301
#define IDI_FAX_INFO                    1302
#define IDI_FAX_MONITOR                 1303
#define IDB_LIST_IMAGES                 1304

// menus
#define IDM_FAX_MENU                    1500
#define ID_ICON_PROPERTIES              1501
#define ID_FAX_QUEUE                    1502
#define ID_DISABLE_MONITORING           1503
#define ID_ANSWER_CALL                  1505
#define ID_FAX_MONITOR                  1506


// strings
#define IDS_FAX_DIALING                 1401
#define IDS_FAX_SENDING                 1402
#define IDS_FAX_RECEIVING               1403
#define IDS_FAX_BUSY                    1405
#define IDS_FAX_NO_ANSWER               1406
#define IDS_FAX_BAD_ADDRESS             1407
#define IDS_FAX_NO_DIAL_TONE            1408
#define IDS_FAX_DISCONNECTED            1409
#define IDS_FAX_FATAL_ERROR_SND         1410
#define IDS_FAX_FATAL_ERROR_RCV         1411
#define IDS_FAX_NOT_FAX_CALL            1412
#define IDS_FAX_CALL_DELAYED            1413
#define IDS_FAX_CALL_BLACKLISTED        1414
#define IDS_FAX_ANSWERED                1420
#define IDS_FAX_UNKNOWN_CALLER          1434
#define IDS_NEW_FAX                     1437
#define IDS_FAX_INCOMING                1438
#define IDS_FAX_INCOMING_TITLE          1439

//
// Monitor dialog
//
#define IDD_MONITOR                     1451
#define IDC_ANIMATE                     1452
#define IDC_STATUS                      1453
#define IDC_ELAPSED_TIME                1454
#define IDC_TITLE                       1455
#define IDC_ALWAYS_ON_TOP               1456
#define IDC_ANSWER_NEXT_CALL            1457
#define IDC_HIDE                        1458
#define IDC_DISCONNECT                  1459
#define IDC_DETAILS                     1460
#define IDC_LIST_DETAILS                1461
#define IDC_CLEAR_LOG                   1462
#define ID_DISCONNECT_CALL              1463

#define IDS_DETAIL_TIME_HEADER          1470
#define IDS_DETAIL_EVENT_HEADER         1471
#define IDS_ELAPSED_TIME                1472
#define IDS_STATUS_IDLE                 1473
#define IDS_SENDING_TO                  1474
#define IDS_RECEIVING_FROM              1475
#define IDS_INCOMING_CALL               1476
#define IDS_INCOMING_CALL_FROM          1477
#define IDS_FAX_INITIALIZING            1478
#define IDS_FAX_LINE_UNAVAILABLE        1479
#define IDS_FAX_PARTIALLY_RECEIVED      1480
#define IDS_FAX_CANCELED                1481
#define IDS_FAX_RETRIES_EXCEEDED        1482
#define IDS_FAX_CANCELING               1483
#define IDS_SENDING                     1484
#define IDS_RECEIVING                   1485
#define IDS_MESSAGE_BOX_CAPTION         1486
#define IDS_DISCONNECT_CONFIRM          1487
#define IDS_FAX_SNT_COMPLETED           1489
#define IDS_FAX_RCV_COMPLETED           1490
#define IDS_CANNOT_ANSWER               1491

#define IDS_RINGING_BALLOON             1600
#define IDS_RINGING_FROM_BALLOON        1601
#define IDS_SEND_ERROR_BALLOON          1602
#define IDS_RCV_ERROR_BALLOON           1603
#define IDS_RCV_FROM_ERROR_BALLOON      1604
#define IDS_NEW_FAX_BALLOON             1605
#define IDS_SEND_OK_BALLOON             1607
#define IDS_RINGING                     1608
#define IDS_BUTTON_MORE                 1609
#define IDS_BUTTON_LESS                 1610
#define IDS_DELETE_ACCESS_DENIED        1611
#define IDS_FAX_CALL_COMPLETED          1612
#define IDS_FAX_CALL_ABORTED            1613
#define IDS_FAX_READY                   1614
#define IDS_READY_TO_SND                1615
#define IDS_READY_TO_RCV                1616
#define IDS_READY_TO_SND_AND_RCV        1617
#define IDS_ABORT_SEND_CONFIRM          1618
#define IDS_ABORT_RECEIVE_CONFIRM       1619
#define IDS_BUTTON_DISCONNECT           1621
#define IDS_BUTTON_ANSWER               1622
#define IDS_CLICK_TO_ANSWER             1623
#define IDS_CLICK_TO_VIEW               1624
#define IDS_NEW_FAX_FROM_BALLOON        1625
#define IDS_SEND_OK                     1626
#define IDS_ERR_CANT_TALK_TO_SERVICE    1627
#define IDS_ERR_ACCESS_DENIED           1628
#define IDS_ERR_NO_DEVICES              1629
#define IDS_ERR_DEVICE_BUSY             1630
#define IDS_ERROR_VIRTUAL_DEVICE        1631    


#endif // _INC_FAX_ST_RES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\server\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains various utility functions.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:
    BoazF 24-May-1999 - Added GetDevStatus

--*/

#include "faxsvc.h"
#include "faxreg.h"
#include <comenum.h>
#pragma hdrstop

#ifdef EnterCriticalSection
    #undef EnterCriticalSection
#endif


#ifdef LeaveCriticalSection
    #undef LeaveCriticalSection
#endif

#ifdef InitializeCriticalSection
    #undef InitializeCriticalSection
#endif


#ifdef InitializeCriticalSectionAndSpinCount
    #undef InitializeCriticalSectionAndSpinCount
#endif


DWORDLONG g_dwLastUniqueId;


STRING_TABLE g_ServiceStringTable[] =
{
    { IDS_DIALING,                          FPS_DIALING,                          NULL },
    { IDS_SENDING,                          FPS_SENDING,                          NULL },
    { IDS_RECEIVING,                        FPS_RECEIVING,                        NULL },
    { IDS_COMPLETED,                        FPS_COMPLETED,                        NULL },
    { IDS_HANDLED,                          FPS_HANDLED,                          NULL },
    { IDS_BUSY,                             FPS_BUSY,                             NULL },
    { IDS_NO_ANSWER,                        FPS_NO_ANSWER,                        NULL },
    { IDS_BAD_ADDRESS,                      FPS_BAD_ADDRESS,                      NULL },
    { IDS_NO_DIAL_TONE,                     FPS_NO_DIAL_TONE,                     NULL },
    { IDS_DISCONNECTED,                     FPS_DISCONNECTED,                     NULL },
    { IDS_FATAL_ERROR,                      FPS_FATAL_ERROR,                      NULL },
    { IDS_NOT_FAX_CALL,                     FPS_NOT_FAX_CALL,                     NULL },
    { IDS_CALL_DELAYED,                     FPS_CALL_DELAYED,                     NULL },
    { IDS_CALL_BLACKLISTED,                 FPS_CALL_BLACKLISTED,                 NULL },
    { IDS_UNAVAILABLE,                      FPS_UNAVAILABLE,                      NULL },
    { IDS_AVAILABLE,                        FPS_AVAILABLE,                        NULL },
    { IDS_ABORTING,                         FPS_ABORTING,                         NULL },
    { IDS_ROUTING,                          FPS_ROUTING,                          NULL },
    { IDS_INITIALIZING,                     FPS_INITIALIZING,                     NULL },
    { IDS_SENDFAILED,                       FPS_SENDFAILED,                       NULL },
    { IDS_SENDRETRY,                        FPS_SENDRETRY,                        NULL },
    { IDS_BLANKSTR,                         FPS_BLANKSTR,                         NULL },
    { IDS_ROUTERETRY,                       FPS_ROUTERETRY,                       NULL },
    { IDS_CALL_COMPLETED,                   IDS_CALL_COMPLETED,                   NULL },
    { IDS_CALL_ABORTED,                     IDS_CALL_ABORTED,                     NULL },
    { IDS_ANSWERED,                         FPS_ANSWERED,                         NULL },
    { IDS_DR_SUBJECT,                       IDS_DR_SUBJECT,                       NULL },
    { IDS_DR_FILENAME,                      IDS_DR_FILENAME,                      NULL },
    { IDS_NDR_SUBJECT,                      IDS_NDR_SUBJECT,                      NULL },
    { IDS_NDR_FILENAME,                     IDS_NDR_FILENAME,                     NULL },
    { IDS_SERVICE_NAME,                     IDS_SERVICE_NAME,                     NULL },
    { IDS_NO_MAPI_LOGON,                    IDS_NO_MAPI_LOGON,                    NULL },
    { IDS_DEFAULT,                          IDS_DEFAULT,                          NULL },
    { IDS_FAX_LOG_CATEGORY_INIT_TERM,       IDS_FAX_LOG_CATEGORY_INIT_TERM,       NULL },
    { IDS_FAX_LOG_CATEGORY_OUTBOUND,        IDS_FAX_LOG_CATEGORY_OUTBOUND,        NULL },
    { IDS_FAX_LOG_CATEGORY_INBOUND,         IDS_FAX_LOG_CATEGORY_INBOUND,         NULL },
    { IDS_FAX_LOG_CATEGORY_UNKNOWN,         IDS_FAX_LOG_CATEGORY_UNKNOWN,         NULL },
    { IDS_SET_CONFIG,                       IDS_SET_CONFIG,                       NULL },
    { IDS_PARTIALLY_RECEIVED,               IDS_PARTIALLY_RECEIVED,               NULL },
    { IDS_FAILED_SEND,                      IDS_FAILED_SEND,                      NULL },
    { IDS_FAILED_RECEIVE,                   IDS_FAILED_RECEIVE,                   NULL },
    { IDS_CANCELED,                         IDS_CANCELED,                         NULL },
    { IDS_RECEIPT_RECIPIENT_NUMBER,         IDS_RECEIPT_RECIPIENT_NUMBER,         NULL },
    { IDS_RECEIPT_RECIPIENT_NUMBER_WIDTH,   IDS_RECEIPT_RECIPIENT_NUMBER_WIDTH,   NULL },
    { IDS_RECEIPT_RECIPIENT_NAME,           IDS_RECEIPT_RECIPIENT_NAME,           NULL },
    { IDS_RECEIPT_RECIPIENT_NAME_WIDTH,     IDS_RECEIPT_RECIPIENT_NAME_WIDTH,     NULL },
    { IDS_RECEIPT_START_TIME,               IDS_RECEIPT_START_TIME,               NULL },
    { IDS_RECEIPT_START_TIME_WIDTH,         IDS_RECEIPT_START_TIME_WIDTH,         NULL },
    { IDS_RECEIPT_END_TIME,                 IDS_RECEIPT_END_TIME,                 NULL },
    { IDS_RECEIPT_END_TIME_WIDTH,           IDS_RECEIPT_END_TIME_WIDTH,           NULL },
    { IDS_RECEIPT_RETRIES,                  IDS_RECEIPT_RETRIES,                  NULL },
    { IDS_RECEIPT_RETRIES_WIDTH,            IDS_RECEIPT_RETRIES_WIDTH,            NULL },
    { IDS_RECEIPT_LAST_ERROR,               IDS_RECEIPT_LAST_ERROR,               NULL },
    { IDS_RECEIPT_LAST_ERROR_WIDTH,         IDS_RECEIPT_LAST_ERROR_WIDTH,         NULL },
    { IDS_COMPLETED_RECP_LIST_HEADER,       IDS_COMPLETED_RECP_LIST_HEADER,       NULL },
    { IDS_FAILED_RECP_LIST_HEADER,          IDS_FAILED_RECP_LIST_HEADER,          NULL },
    { IDS_RECEIPT_NO_CP_AND_BODY_ATTACH,    IDS_RECEIPT_NO_CP_AND_BODY_ATTACH,    NULL },
    { IDS_RECEIPT_NO_CP_ATTACH,             IDS_RECEIPT_NO_CP_ATTACH,             NULL }
};

const DWORD gc_dwCountServiceStringTable  = (sizeof(g_ServiceStringTable)/sizeof(g_ServiceStringTable[0]));



LPWSTR  lpszEventCodes[]= {
    L"FEI_DIALING",
    L"FEI_SENDING",
    L"FEI_RECEIVING",
    L"FEI_COMPLETED",
    L"FEI_BUSY",
    L"FEI_NO_ANSWER",
    L"FEI_BAD_ADDRESS",
    L"FEI_NO_DIAL_TONE",
    L"FEI_DISCONNECTED",
    L"FEI_FATAL_ERROR",
    L"FEI_NOT_FAX_CALL",
    L"FEI_CALL_DELAYED",
    L"FEI_CALL_BLACKLISTED",
    L"FEI_RINGING",
    L"FEI_ABORTING",
    L"FEI_ROUTING",
    L"FEI_MODEM_POWERED_ON",
    L"FEI_MODEM_POWERED_OFF",
    L"FEI_IDLE",
    L"FEI_FAXSVC_ENDED",
    L"FEI_ANSWERED",
    L"FEI_JOB_QUEUED",
    L"FEI_DELETED",
    L"FEI_INITIALIZING",
    L"FEI_LINE_UNAVAILABLE",
    L"FEI_HANDLED",
    L"FEI_FAXSVC_STARTED"};


LPTSTR GetEventCodeString(DWORD dwEventCode)
{
    if (dwEventCode<FEI_DIALING || dwEventCode>FEI_FAXSVC_STARTED) {
        return L"*** INVALID EVENT CODE ***";
    }
    else {
        return lpszEventCodes[dwEventCode-1];
    }


}

#ifdef DBG
//*********************************************************************************
//* Name:   DebugDateTime()
//* Author:
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Accepts a 64 bit file time and generates a string with its content.
//*     The format is Date Time (GMT). Date and Time format are system settings
//*     specific.
//* PARAMETERS:
//*     [IN]    DWORD DateTime
//*                 64 bit file time value
//*     [OUT]   LPTSTR lptstrDateTime
//*                 A pointer to a string buffer where the resulting string will
//*                 be placed.
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//*
//*********************************************************************************
BOOL DebugDateTime( DWORDLONG DateTime,LPTSTR lptstrDateTime)
{

    SYSTEMTIME SystemTime;
    TCHAR DateBuffer[256] = TEXT("NULL");
    TCHAR TimeBuffer[256] = TEXT("NULL");

    DEBUG_FUNCTION_NAME(TEXT("DebugDateTime"));

    if (!FileTimeToSystemTime( (LPFILETIME) &DateTime, &SystemTime ))
    {
        return FALSE;
    }

    GetY2KCompliantDate (
        LOCALE_SYSTEM_DEFAULT,
        0,
        &SystemTime,
        DateBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    FaxTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        0,
        &SystemTime,
        NULL,
        TimeBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    _stprintf(lptstrDateTime,TEXT("%s %s (GMT)"),DateBuffer, TimeBuffer);

    return TRUE;

}

VOID
DebugPrintDateTime(
    LPTSTR Heading,
    DWORDLONG DateTime
    )
{
    SYSTEMTIME SystemTime;
    TCHAR DateBuffer[256] = TEXT("NULL");
    TCHAR TimeBuffer[256] = TEXT("NULL");

    if (!FileTimeToSystemTime( (LPFILETIME) &DateTime, &SystemTime ))
    {
        return;
    }

    GetY2KCompliantDate (
        LOCALE_SYSTEM_DEFAULT,
        0,
        &SystemTime,
        DateBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    FaxTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        0,
        &SystemTime,
        NULL,
        TimeBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    if (Heading) {
        DebugPrint((TEXT("%s %s %s (GMT)"), Heading, DateBuffer, TimeBuffer));
    } else {
        DebugPrint((TEXT("%s %s (GMT)"), DateBuffer, TimeBuffer));
    }

}


//*********************************************************************************
//* Name:   SystemTimeToStr()
//* Author:
//* Date:
//*********************************************************************************
//* DESCRIPTION:
//*     Accepts a pointer to a system time structure and generates a string with its content.
//*     The format is Date Time (GMT). Date and Time format are system settings
//*     specific.
//* PARAMETERS:
//*     [IN]    SYSTEMTIME *  lptmTime
//*                 Pointer to SYSTEMTIME structure to convet to string
//*     [OUT]   LPTSTR lptstrDateTime
//*                 A pointer to a string buffer where the resulting string will
//*                 be placed.
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//*
//*********************************************************************************
BOOL SystemTimeToStr( const SYSTEMTIME *  lptmTime,LPTSTR lptstrDateTime)
{

    TCHAR DateBuffer[256] = TEXT("NULL");
    TCHAR TimeBuffer[256] = TEXT("NULL");

    GetY2KCompliantDate (
        LOCALE_SYSTEM_DEFAULT,
        0,
        lptmTime,
        DateBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    FaxTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        0,
        lptmTime,
        NULL,
        TimeBuffer,
        sizeof(TimeBuffer)/sizeof(TimeBuffer[0])
        );

    _stprintf(lptstrDateTime,TEXT("%s %s (GMT)"),DateBuffer, TimeBuffer);

    return TRUE;

}

#endif
BOOL
InitializeStringTable(
    VOID
    )
{
    DWORD i;
    HINSTANCE hInstance;
    TCHAR Buffer[512];
    DWORD ec = ERROR_SUCCESS;


    hInstance = GetModuleHandle(NULL);

    for (i = 0; i < gc_dwCountServiceStringTable; i++)
    {
        if (LoadString(
                hInstance,
                g_ServiceStringTable[i].ResourceId,
                Buffer,
                sizeof(Buffer)/sizeof(TCHAR)
                ))
        {
            g_ServiceStringTable[i].String = (LPTSTR) MemAlloc( StringSize( Buffer ) );
            if (!g_ServiceStringTable[i].String)
            {
                ec = ERROR_OUTOFMEMORY;
                goto Error;
            }
            else
            {
                _tcscpy( g_ServiceStringTable[i].String, Buffer );
            }
        }
        else
        {
            ec = GetLastError();
            goto Error;
        }
    }
    return TRUE;

Error:
    Assert (ERROR_SUCCESS != ec);

    for (i = 0; i < gc_dwCountServiceStringTable; i++)
    {
        MemFree (g_ServiceStringTable[i].String);
        g_ServiceStringTable[i].String = NULL;
    }

    SetLastError(ec);
    return FALSE;
}





LPTSTR
GetLastErrorText(
    DWORD ErrorCode
    )

/*++

Routine Description:

    Gets a string for a given WIN32 error code.

Arguments:

    ErrorCode   - WIN32 error code.

Return Value:

    Pointer to a string representing the ErrorCode.

--*/

{
    static TCHAR ErrorBuf[256];
    DWORD Count;

    Count = FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        ErrorCode,
        LANG_NEUTRAL,
        ErrorBuf,
        sizeof(ErrorBuf)/sizeof(ErrorBuf[0]),
        NULL
        );

    if (Count) {
        if (ErrorBuf[Count-1] == TEXT('\n')) {
            ErrorBuf[Count-1] = 0;
        }
        if ((Count>1) && (ErrorBuf[Count-2] == TEXT('\r'))) {
            ErrorBuf[Count-2] = 0;
        }
    }

    return ErrorBuf;
}

LPTSTR
GetString(
    DWORD InternalId
    )

/*++

Routine Description:

    Loads a resource string and returns a pointer to the string.
    The caller must free the memory.

Arguments:

    ResourceId      - resource string id

Return Value:

    pointer to the string

--*/

{
    DWORD i;

    for (i=0; i<gc_dwCountServiceStringTable; i++) {
        if (g_ServiceStringTable[i].InternalId == InternalId) {
            return g_ServiceStringTable[i].String;
        }
    }

    return NULL;
}


BOOL
InitializeFaxDirectories(
    VOID
    )
/*++

Routine Description:

    Initializes the directories that fax will use.
    We call into the shell to get the correct base path for fax directories and then tack on a relative path.

Arguments:

    None.

Return Value:

    TRUE if successful. modifies path globals

--*/
{
   WCHAR   FaxDir[MAX_PATH];
   if (!GetSpecialPath( CSIDL_COMMON_APPDATA, FaxDir ) ) {
       DebugPrint(( TEXT("Couldn't GetSpecialPath, ec = %d\n"), GetLastError() ));
       return FALSE;
   }

   wcscpy(g_wszFaxQueueDir,FaxDir);
   ConcatenatePaths(g_wszFaxQueueDir, FAX_QUEUE_DIR);

   return TRUE;
}


//*********************************************************************************
//* Name:   GenerateUniqueQueueFile()
//* Author: Ronen Barenboim
//* Date:   April 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Generates a unique QUEUE file in the queue directory.
//*     returns a UNIQUE id for the file based on the job type. (see the remarks
//*     section for more details).
//* PARAMETERS:
//*     [IN]    DWORD dwJobType
//*         The job type for which a file is to be generated
//*     [OUT]       LPTSTR lptstrFileName
//*         A pointer to the buffer where the resulting file name (including path)
//*         will be placed.
//*     [IN]        DWORD  dwFileNameSize
//*         The size of the output file name buffer.
//* RETURN VALUE:
//*      If successful the function returns A DWORDLONG with the unique id for the file.
//*      On failure it returns 0.
//* REMARKS:
//*     The generated unique id is derived from the unique name of the generated
//*     file (which is only unique within files with the same extension) and the
//*     type of the job for which the file was generated.
//*     Thus it is ensured that there can be no two jobs with the same unique id
//*     although there can be two jobs with the same unique file name which are
//*     different only by the file extension.
//*     The 64 bit unique file id is the result of SystemTimeToFileTime.
//*     This is the number of 100 nano seconds intervals since 1-1-1601
//*     In year 3000 it will be approximately 5BC826A600000 i.e. 52 bites long.
//      We use the left most 8 bits for the job type. Leaving extra 4 more bits
//*     |-----------------3----------------2----------------1----------------|
//*     |FEDCBA98|76543210|FEDCBA9876543210|FEDCBA9876543210|FEDCBA9876543210|
//*     |-----------------|----------------|----------------|----------------|
//*     | JobType|          56 LSB bits of  SystemTimeToFileTime             |
//*     |-----------------|----------------|----------------|----------------|
//*     Job Type:
//*         The JT_* value of the job type.
//*********************************************************************************
DWORDLONG GenerateUniqueQueueFile(
    DWORD dwJobType,
    LPTSTR lptstrFileName,
    DWORD  dwFileNameSize)
{
    DWORD dwUniqueIdHigh;
    DWORD dwUniqueIdLow;
    DWORDLONG dwlUniqueId = 0 ;
    FILETIME FileTime;
    SYSTEMTIME SystemTime;
    LPTSTR lpszExt=NULL;

      DEBUG_FUNCTION_NAME(TEXT("GenerateUniqueQueueFile"));

    EnterCriticalSection(&g_csUniqueQueueFile);

    GetSystemTime( &SystemTime ); // returns VOID
    if (!SystemTimeToFileTime( &SystemTime, &FileTime ))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("SystemTimeToFileTime() failed (ec: %ld)"), GetLastError());
        goto Error;
    }

    dwlUniqueId = MAKELONGLONG(FileTime.dwLowDateTime, FileTime.dwHighDateTime);

    dwlUniqueId = dwlUniqueId >> 8;
    if(dwlUniqueId == g_dwLastUniqueId)
    {
        //
        // Not enough time has passed since the last generation to ensure
        // out time based unique id algorithm will produce a unique id
        // (in case the already generated file was deleted from the queue directory).
        // Let some more time pass to ensure uniqueness.
        //
        Sleep(1);
    }
    //
    // Note that dwlUniqueId might be smaller than g_dwLastUniqueId if the system time was moved
    // back during the service operation.
    //
    switch (dwJobType)
    {
            case JT_SEND:
            {
                lpszExt=TEXT("FQE");
            }
            break;

        case JT_BROADCAST:
            {
                lpszExt=TEXT("FQP");
            }
            break;

        case JT_RECEIVE:
            {
                lpszExt=FAX_TIF_FILE_EXT;
            }
            break;
        case JT_ROUTING:
            {
                lpszExt=TEXT("FQR");
            }
            break;
        default:
            Assert(FALSE);
    }

    dwlUniqueId=GenerateUniqueFileName(
        g_wszFaxQueueDir,
        lpszExt,
        lptstrFileName,
        dwFileNameSize);
    if (!dwlUniqueId) {
        goto Error;
    }

    g_dwLastUniqueId = dwlUniqueId;

    dwUniqueIdHigh = (DWORD) (dwlUniqueId >> 32);
    dwUniqueIdLow = (DWORD) dwlUniqueId;

    //
    // Set the 8 MSB bits to zero.
    //
    dwUniqueIdHigh &= 0x00FFFFFF;

    //
    // skip past the 56 bits of SystemTimeToFileTime and put the job type at the high 8 MSB bits.
    //
    dwUniqueIdHigh |= (dwJobType << 24) ;


    dwlUniqueId = MAKELONGLONG(dwUniqueIdLow,dwUniqueIdHigh);

Error:
    LeaveCriticalSection(&g_csUniqueQueueFile);
    return dwlUniqueId;
}


//*********************************************************************************
//* Name:   GenerateUniqueArchiveFileName()
//* Author: Oded Sacher
//* Date:   7/11/99
//*********************************************************************************
//* DESCRIPTION:
//*     Generates a unique file name and creates an archived file.
//* PARAMETERS:
//*     [IN]    LPTSTR Directory
//*         The path where the file is to be created.
//*     [OUT]    LPTSTR FileName
//*         The buffer where the resulting file name (including path) will be
//*         placed. FileName size must not exceed MAX_PATH
//*     [IN]     DWORDLONG JobId
//*         Input for the file name.
//*     [IN]    LPTSTR lptstrUserSid
//*         Input for the file name.
//* RETURN VALUE:
//*      If successful the function returns TRUE.
//* REMARKS:
//*    FileName size must not exceed MAX_PATH
BOOL
GenerateUniqueArchiveFileName(
    LPTSTR Directory,
    LPTSTR FileName,
    DWORDLONG JobId,
    LPTSTR lptstrUserSid
    )
{
    TCHAR TempPath[MAX_PATH];
    int iCount;
    DEBUG_FUNCTION_NAME(TEXT("GenerateUniqueArchiveFileName"));

    if (!Directory) {
        GetTempPath( sizeof(TempPath)/sizeof(TCHAR), TempPath );
        Directory = TempPath;
    }

    if (Directory[_tcslen(Directory)-1] == TEXT('\\')) {
        Directory[_tcslen(Directory)-1] = 0;
    }

    HANDLE hFile = INVALID_HANDLE_VALUE;

    if (lptstrUserSid != NULL)
    {
        iCount  = _sntprintf(  FileName,
                               MAX_PATH - 1,
                               TEXT("%s\\%s$%I64x.%s"),
                               Directory,
                               lptstrUserSid,
                               JobId,
                               FAX_TIF_FILE_EXT);
    }
    else
    {
        iCount  = _sntprintf(   FileName,
                                MAX_PATH - 1,
                                TEXT("%s\\%I64x.%s"),
                                Directory,
                                JobId,
                                FAX_TIF_FILE_EXT
                                );
    }

    if (iCount < 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("File Name exceded MAX_PATH"));
        return FALSE;
    }

    hFile = CreateFile(
        FileName,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    if (hFile == INVALID_HANDLE_VALUE) {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateFile Faoled, err : %ld"),
                     GetLastError());
        return FALSE;
    }

    CloseHandle( hFile );
    return TRUE;
}


DWORD
MessageBoxThread(
    IN PMESSAGEBOX_DATA MsgBox
    )
{
    DWORD Answer = (DWORD) AlignedMessageBox(
        NULL,
        MsgBox->Text,
        GetString( IDS_SERVICE_NAME ),
        MsgBox->Type | MB_SERVICE_NOTIFICATION
        );

    if (MsgBox->Response) {
        *MsgBox->Response = Answer;
    }

    MemFree( MsgBox->Text );
    MemFree( MsgBox );

    return 0;
}


//*********************************************************************************
//* Name:   CreateFaxEvent()
//* Author: Ronen Barenboim
//* Date:   March 21, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a new FAX_EVENT structure. Initializes it and posts it to the
//*     status completion port with completion key EVENT_COMPLETION_KEY.
//* PARAMETERS:
//*     DeviceId
//*
//*     EventId
//*
//*     DWORD JobId
//*
//* RETURN VALUE:
//*     FALSE
//*         If not enough memory is available to allocated the FAX_EVENT structure
//*     TRUE
//*         If the operation completed successfully
//*
//*     To get extended error information, call GetLastError .
//*
//* REMARKS:
//*
//*********************************************************************************
BOOL CreateFaxEvent(
    DWORD DeviceId,
    DWORD EventId,
    DWORD JobId
    )
{
    PFAX_EVENT FaxEvent = NULL;
    DEBUG_FUNCTION_NAME(TEXT("CreateFaxEvent"));

    if (NULL == g_StatusCompletionPortHandle)
    {
        //
        // Events mechanism is not yet initialized
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Events mechanism is not yet initialized"));
        return TRUE;
    }

    //
    // Note: W2K Fax did issue notifications with EventId == 0 whenever an
    // FSP reported proprietry status code. To keep backward compatability
    // we keep up this behaviour although it might be regarded as a bug
    //

    FaxEvent =(PFAX_EVENT) MemAlloc( sizeof(FAX_EVENT) );
    if (!FaxEvent) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't allocate memory for FAX_EVENT. (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    FaxEvent->SizeOfStruct = sizeof(FAX_EVENT);
    GetSystemTimeAsFileTime( &FaxEvent->TimeStamp );
    FaxEvent->EventId = EventId;
    FaxEvent->DeviceId = DeviceId;
    FaxEvent->JobId = JobId;
#if DBG
    WCHAR szTime[256] = {0};
    DebugDateTime(*(DWORDLONG *)&FaxEvent->TimeStamp,szTime);
    DebugPrintEx(DEBUG_MSG,TEXT("Sending notification. Event = %s(0x%0X), Device Id = 0x%0X , Time = %s"), GetEventCodeString(EventId), EventId, DeviceId, szTime);
#endif

    if (!PostQueuedCompletionStatus(
        g_StatusCompletionPortHandle,
        sizeof(FAX_EVENT),
        EVENT_COMPLETION_KEY,  // Mark it as a a fax event and not FSP event
        (LPOVERLAPPED) FaxEvent
        ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PostQueuedCompletionStatus failed. (ec: %ld)"),
            GetLastError());
        MemFree (FaxEvent);
        FaxEvent = NULL;
        return FALSE;
    }
    return TRUE;
}


DWORD
MapFSPIJobStatusToEventId(
    LPCFSPI_JOB_STATUS lpcFSPIJobStatus
    )
{
    DEBUG_FUNCTION_NAME(TEXT("MapFSPIJobStatusToEventId"));
    DWORD EventId = 0;

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("lpcFSPIJobStatus->dwJobStatus: 0x%08X lpcFSPIJobStatus->dwExtendedStatus: 0x%08X"),
        lpcFSPIJobStatus->dwJobStatus,
        lpcFSPIJobStatus->dwExtendedStatus
        );



    switch (lpcFSPIJobStatus->dwJobStatus)
    {
        case FSPI_JS_INPROGRESS:
        {
            switch( lpcFSPIJobStatus->dwExtendedStatus) {
                case FSPI_ES_INITIALIZING:
                    EventId = FEI_INITIALIZING;
                    break;
                case FSPI_ES_DIALING:
                    EventId = FEI_DIALING;
                    break;
                case FSPI_ES_TRANSMITTING:
                    EventId = FEI_SENDING;
                    break;
                case FSPI_ES_RECEIVING:
                    EventId = FEI_RECEIVING;
                    break;
                case FSPI_ES_HANDLED:
                    EventId = FEI_HANDLED;
                    break;
                case FSPI_ES_ANSWERED:
                    EventId = FEI_ANSWERED;
                    break;
                default:
                    //
                    // In W2K Fax a proprietry code generated an event with EventId ==0
                    //
                    EventId = 0;
                    break;
            }
        }
        break;

        case FSPI_JS_COMPLETED:
            EventId = FEI_COMPLETED;
            break;

        case FSPI_JS_FAILED_NO_RETRY:
        case FSPI_JS_FAILED:
        case FSPI_JS_RETRY:
        case FSPI_JS_DELETED:
            switch( lpcFSPIJobStatus->dwExtendedStatus)
            {
                case FSPI_ES_LINE_UNAVAILABLE:
                    EventId = FEI_LINE_UNAVAILABLE;
                break;
                case FSPI_ES_BUSY:
                    EventId = FEI_BUSY;
                    break;
                case FSPI_ES_NO_ANSWER:
                    EventId = FEI_NO_ANSWER;
                    break;
                case FSPI_ES_BAD_ADDRESS:
                    EventId = FEI_BAD_ADDRESS;
                    break;
                case FSPI_ES_NO_DIAL_TONE:
                    EventId = FEI_NO_DIAL_TONE;
                    break;
                case FSPI_ES_DISCONNECTED:
                    EventId = FEI_DISCONNECTED;
                    break;
                case FSPI_ES_FATAL_ERROR:
                    EventId = FEI_FATAL_ERROR;
                    break;
                case FSPI_ES_NOT_FAX_CALL:
                    EventId = FEI_NOT_FAX_CALL;
                    break;
                case FSPI_ES_CALL_DELAYED:
                    EventId = FEI_CALL_DELAYED;
                    break;
                case FSPI_ES_CALL_BLACKLISTED:
                    EventId = FEI_CALL_BLACKLISTED;
                    break;
                default:
                    //
                    // In W2K Fax a proprietry code generated an event with EventId ==0
                    //
                    EventId = 0;
                    break;

            }
            break;

        case FSPI_JS_ABORTED:
        case FSPI_JS_ABORTING:
            EventId = FEI_ABORTING;
            break;

        case FSPI_JS_UNKNOWN:
        case FSPI_JS_RESUMING:
        case FSPI_JS_SUSPENDED:
        case FSPI_JS_SUSPENDING:
        case FSPI_JS_SYSTEM_ABORT:
            //
            // No legacy notification for these states
            //
            EventId = 0;
            break;


        default:
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid FSPI_JS: 0x%08X"),
                lpcFSPIJobStatus->dwJobStatus);
            Assert(FSPI_JS_ABORTED == lpcFSPIJobStatus->dwJobStatus); // ASSERT_FALSE
            break;
    }

    return EventId;

}


#if 0
DWORD
MapStatusIdToEventId(
    DWORD StatusId
    )
{
    DWORD EventId = 0;

    switch( StatusId ) {
        case FS_INITIALIZING:
            EventId = FEI_INITIALIZING;
            break;
        case FS_DIALING:
            EventId = FEI_DIALING;
            break;
        case FS_TRANSMITTING:
            EventId = FEI_SENDING;
            break;
        case FS_RECEIVING:
            EventId = FEI_RECEIVING;
            break;
        case FS_COMPLETED:
            EventId = FEI_COMPLETED;
            break;
        case FS_HANDLED:
            EventId = FEI_HANDLED;
            break;
        case FS_LINE_UNAVAILABLE:
            EventId = FEI_LINE_UNAVAILABLE;
            break;
        case FS_BUSY:
            EventId = FEI_BUSY;
            break;
        case FS_NO_ANSWER:
            EventId = FEI_NO_ANSWER;
            break;
        case FS_BAD_ADDRESS:
            EventId = FEI_BAD_ADDRESS;
            break;
        case FS_NO_DIAL_TONE:
            EventId = FEI_NO_DIAL_TONE;
            break;
        case FS_DISCONNECTED:
            EventId = FEI_DISCONNECTED;
            break;
        case FS_FATAL_ERROR:
            EventId = FEI_FATAL_ERROR;
            break;
        case FS_NOT_FAX_CALL:
            EventId = FEI_NOT_FAX_CALL;
            break;
        case FS_CALL_DELAYED:
            EventId = FEI_CALL_DELAYED;
            break;
        case FS_CALL_BLACKLISTED:
            EventId = FEI_CALL_BLACKLISTED;
            break;
        case FS_USER_ABORT:
            EventId = FEI_ABORTING;
            break;
        case FS_ANSWERED:
             EventId = FEI_ANSWERED;
            break;

    }

    return EventId;

}
#endif


void
FaxLogSend(
    const JOB_QUEUE * lpcJobQueue, BOOL bRetrying
    )
/*++

Routine Description:

    Log a fax send event.

Arguments:
    lpcJobQueue  - Pointer to the recipient job to log send information for.
                  (It must be in a running state).

Return Value:

    VOID

--*/


{
    DWORD Level;
    DWORD FormatId;
    TCHAR PageCountStr[64];
    TCHAR TimeStr[128];
    BOOL fLog = TRUE;

    PJOB_ENTRY lpJobEntry;

    Assert(lpcJobQueue);
    lpJobEntry = lpcJobQueue->JobEntry;
    Assert(lpJobEntry);

    FormatElapsedTimeStr(
        (FILETIME*)&lpJobEntry->ElapsedTime,
        TimeStr,
        sizeof(TimeStr)
        );
    _ltot((LONG) lpJobEntry->FSPIJobStatus.dwPageCount, PageCountStr, 10);
    if ( FSPI_JS_COMPLETED == lpJobEntry->FSPIJobStatus.dwJobStatus ) {
        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MAX,
            10,
            MSG_FAX_SEND_SUCCESS,
            lpcJobQueue->SenderProfile.lptstrName,
            lpcJobQueue->SenderProfile.lptstrBillingCode,
            lpcJobQueue->SenderProfile.lptstrCompany,
            lpcJobQueue->SenderProfile.lptstrDepartment,
            lpcJobQueue->RecipientProfile.lptstrName,
            lpJobEntry->DisplayablePhoneNumber,
            lpJobEntry->FSPIJobStatus.lpwstrRemoteStationId,
            PageCountStr,
            TimeStr,
            lpJobEntry->LineInfo->DeviceName
            );
    }
    else
    {
        if (FSPI_JS_ABORTED == lpJobEntry->FSPIJobStatus.dwJobStatus )
        {
                Level = FAXLOG_LEVEL_MAX;
                FormatId = MSG_FAX_SEND_USER_ABORT;
        }
        else
        {

            switch (lpJobEntry->FSPIJobStatus.dwExtendedStatus)
            {
                case FSPI_ES_FATAL_ERROR:
                    Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_FATAL_RETRY : MSG_FAX_SEND_FATAL_ABORT;
                    break;
                case FSPI_ES_NO_DIAL_TONE:
                    Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_NDT_RETRY : MSG_FAX_SEND_NDT_ABORT;
                    break;
                case FSPI_ES_NO_ANSWER:
                    Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_NA_RETRY : MSG_FAX_SEND_NA_ABORT;
                    break;
                case FSPI_ES_DISCONNECTED:
                    Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_INTERRUPT_RETRY : MSG_FAX_SEND_INTERRUPT_ABORT;
                    break;
                case FSPI_ES_NOT_FAX_CALL:
                    Level = bRetrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_NOTFAX_RETRY : MSG_FAX_SEND_NOTFAX_ABORT;
                    break;
                case FSPI_ES_BUSY:
                    Level = bRetrying ? FAXLOG_LEVEL_MAX : FAXLOG_LEVEL_MIN;
                    FormatId = bRetrying ? MSG_FAX_SEND_BUSY_RETRY : MSG_FAX_SEND_BUSY_ABORT;
                    break;
                case FSPI_ES_CALL_BLACKLISTED:
                    Level = FAXLOG_LEVEL_MIN;
                    FormatId = MSG_FAX_CALL_BLACKLISTED_ABORT;
                    break;
                case FSPI_ES_CALL_DELAYED:
                    Level = FAXLOG_LEVEL_MIN;
                    FormatId = MSG_FAX_CALL_DELAYED_ABORT;
                    break;
                case FSPI_ES_BAD_ADDRESS:
                    Level = FAXLOG_LEVEL_MIN;
                    FormatId = MSG_FAX_BAD_ADDRESS_ABORT;
                    break;
                default:
                    fLog = FALSE;
            }
        }
        if(fLog)
        {
            FaxLog(
                FAXLOG_CATEGORY_OUTBOUND,
                Level,
                7,
                FormatId,
                lpcJobQueue->SenderProfile.lptstrName,
                lpcJobQueue->SenderProfile.lptstrBillingCode,
                lpcJobQueue->SenderProfile.lptstrCompany,
                lpcJobQueue->SenderProfile.lptstrDepartment,
                lpcJobQueue->RecipientProfile.lptstrName,
                lpJobEntry->DisplayablePhoneNumber,
                lpJobEntry->LineInfo->DeviceName
                );
        }
    }

}




DWORD MyGetFileSize(LPCTSTR FileName)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD sizelow=0, sizehigh=0;
    DWORD ec = ERROR_SUCCESS;

    hFile = CreateFile(
        FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return 0;
    }

    sizelow = GetFileSize(hFile,&sizehigh);
    if (sizelow == 0xFFFFFFFFF)
    {
        ec = GetLastError();
        sizelow = 0;
    }
    else if (sizehigh != 0)
    {
        sizelow=0xFFFFFFFF;
    }

    CloseHandle(hFile);
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }
    return sizelow;
}


LPCWSTR szCsClients = L"g_CsClients";
LPCWSTR szCsHandleTable = L"g_CsHandleTable";
LPCWSTR szCsJob = L"g_CsJob";
LPCWSTR szCsLine = L"g_CsLine";
LPCWSTR szCsPerfCounters = L"g_CsPerfCounters";
LPCWSTR szCsQueue = L"g_CsQueue";
LPCWSTR szCsRouting = L"g_CsRouting";
LPCWSTR szCsConfig = L"g_CsConfig";
LPCWSTR szCsInboundActivityLogging = L"g_CsInboundActivityLogging";
LPCWSTR szCsOutboundActivityLogging = L"g_CsOutboundActivityLogging";
LPCWSTR szCsActivity = L"g_CsActivity";
LPCWSTR szCsUnknown = L"Other CS";

LPCWSTR GetSzCs(
    LPCRITICAL_SECTION cs
    )
{



    if (cs == &g_CsClients) {
        return szCsClients;
    } else if (cs == &g_CsHandleTable) {
        return szCsHandleTable;
    } else if (cs == &g_CsLine) {
        return szCsLine;
    } else if (cs == &g_CsJob) {
        return szCsJob;
    } else if (cs == &g_CsPerfCounters) {
        return szCsPerfCounters;
    } else if (cs == &g_CsQueue) {
        return szCsQueue;
    } else if (cs == &g_CsRouting) {
        return szCsRouting;
    } else if (cs == &g_CsConfig) {
        return szCsConfig;
    } else if (cs == &g_CsInboundActivityLogging) {
        return szCsInboundActivityLogging;
    } else if (cs == &g_CsOutboundActivityLogging) {
        return szCsOutboundActivityLogging;
    } else if (cs == &g_CsActivity) {
        return szCsActivity;
    }

    return szCsUnknown;
}


#if DBG
VOID AppendToLogFile(
    LPWSTR String
    )
{
    DWORD BytesWritten;
    LPSTR AnsiBuffer = UnicodeStringToAnsiString( String );

    if (g_hCritSecLogFile != INVALID_HANDLE_VALUE) {
        WriteFile(g_hCritSecLogFile,(LPBYTE)AnsiBuffer,strlen(AnsiBuffer) * sizeof(CHAR),&BytesWritten,NULL);
    }

    MemFree(AnsiBuffer);

}

VOID AppendFuncToLogFile(
    LPCRITICAL_SECTION cs,
    LPTSTR szFunc,
    DWORD line,
    LPTSTR file,
    PDBGCRITSEC CritSec
    )
{
    WCHAR Buffer[300];
    LPWSTR FileName;
    LPCWSTR szcs = GetSzCs(cs);

    FileName = wcsrchr(file,'\\');
    if (!FileName) {
        FileName = TEXT("Unknown  ");
    } else {
        FileName += 1;
    }
    if (CritSec) {
        wsprintf(Buffer,TEXT("%d\t%x\t%s\t%s\t%s\t%d\t%d\r\n"),
                 GetTickCount(),
                 (PULONG_PTR)cs,
                 szcs,
                 szFunc,
                 FileName,
                 line,
                 CritSec->ReleasedTime - CritSec->AquiredTime);
    } else {
        wsprintf(Buffer,TEXT("%d\t%x\t%s\t%s\t%s\t%d\r\n"),GetTickCount(),(PULONG_PTR)cs,szcs,szFunc, FileName,line);
    }

    AppendToLogFile( Buffer );

    return;

}

VOID pEnterCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    )
{
    PDBGCRITSEC pCritSec = (PDBGCRITSEC)MemAlloc(sizeof(DBGCRITSEC));
    if( pCritSec == NULL )
    {
        // memory allocation failed, do the actual work and exit...
        EnterCriticalSection(cs);
        return;
    }

    pCritSec->CritSecAddr = (ULONG_PTR) cs;
    pCritSec->AquiredTime = GetTickCount();
    pCritSec->ThreadId = GetCurrentThreadId();


    EnterCriticalSection(&g_CsCritSecList);

    InsertHeadList( &g_CritSecListHead, &pCritSec->ListEntry );
    AppendFuncToLogFile(cs,TEXT("EnterCriticalSection"), line, file, NULL );
    //
    // check ordering of threads. ALWAYS aquire g_CsLine before aquiring g_CsQueue!!!
    //
    if ((LPCRITICAL_SECTION)cs == (LPCRITICAL_SECTION)&g_CsQueue)
    {
        if ((DWORD)GetCurrentThreadId() != PtrToUlong(g_CsJob.OwningThread()))
        {
            WCHAR DebugBuf[300];
            wsprintf(DebugBuf, TEXT("%d : Attempting to aquire g_CsQueue (thread %x) without aquiring g_CsJob (thread %x, lock count %x) first, possible deadlock!\r\n"),
                         GetTickCount(),
                         GetCurrentThreadId(),
                         g_CsJob.OwningThread(),
                         g_CsJob.LockCount());
            AppendToLogFile( DebugBuf );
        }
    }

    LeaveCriticalSection(&g_CsCritSecList);

    EnterCriticalSection(cs);
}

VOID pLeaveCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    )
{
    PDBGCRITSEC CritSec = NULL;
    BOOL fRemove = FALSE;

    EnterCriticalSection(&g_CsCritSecList);

    PLIST_ENTRY Next = g_CritSecListHead.Flink;


    while ((ULONG_PTR)Next != (ULONG_PTR) &g_CritSecListHead)
    {
        CritSec = CONTAINING_RECORD( Next, DBGCRITSEC, ListEntry );
        if ((ULONG_PTR)CritSec->CritSecAddr == (ULONG_PTR) cs &&
            ( GetCurrentThreadId() == CritSec->ThreadId ) )
        {
            CritSec->ReleasedTime = GetTickCount();
            fRemove = TRUE;
            break;
        }
        Next = Next->Flink;
    }

    AppendFuncToLogFile(cs,TEXT("LeaveCriticalSection"),line, file, CritSec );

    if (fRemove) {
        RemoveEntryList( &CritSec->ListEntry );
        MemFree( CritSec );
    }

    LeaveCriticalSection(&g_CsCritSecList);


    LeaveCriticalSection(cs);
}

VOID pInitializeCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    )
{
    AppendFuncToLogFile(cs,TEXT("InitializeCriticalSection"),line, file, NULL);

    InitializeCriticalSection(cs);
}

BOOL pInitializeCriticalSectionAndSpinCount(
    LPCRITICAL_SECTION cs,
    DWORD dwSpinCount,
    DWORD line,
    LPTSTR file
    )
{
    AppendFuncToLogFile(cs,TEXT("pInitializeCriticalSectionAndSpinCount"),line, file, NULL);

    return InitializeCriticalSectionAndSpinCount(cs, dwSpinCount);
}

BOOL
ThreadOwnsCs(
    VOID
    )
{
    PDBGCRITSEC pCritSec = NULL;
    DWORD dwThreadId = GetCurrentThreadId();

    EnterCriticalSection(&g_CsCritSecList);
    PLIST_ENTRY Next = g_CritSecListHead.Flink;

    while ((ULONG_PTR)Next != (ULONG_PTR) &g_CritSecListHead)
    {
        pCritSec = CONTAINING_RECORD( Next, DBGCRITSEC, ListEntry );
        if (dwThreadId == pCritSec->ThreadId )
        {
            LeaveCriticalSection(&g_CsCritSecList);
            return TRUE;
        }
        Next = Next->Flink;
    }

    LeaveCriticalSection(&g_CsCritSecList);
    return FALSE;
}


#endif


DWORD
ValidateTiffFile(
    LPCWSTR TifFileName
    )
{

    HANDLE hTiff;
    DWORD rc = ERROR_SUCCESS;
    TIFF_INFO TiffInfo;

    //
    // Validate tiff format
    //
    hTiff = TiffOpen( (LPWSTR)TifFileName, &TiffInfo, FALSE, FILLORDER_MSB2LSB );
    if (!hTiff) {
        rc = GetLastError();
        return rc;
    }

    TiffClose( hTiff );
    return ERROR_SUCCESS;
}

//
// Function:
//      LegacyJobStatusToStatus
//
// Parameters:
//      dwLegacyStatus - Legacy job status (FS_*)
//      pdwStatus - A pointer to a DWORD that receives the new job status.
//      pdwExtendedStatus - A pointer to a DWORD that receives the extended
//          job status.
//
// Return Value:
//      If the function succeeds, the return value is ERROR_SUCCESS, else the
//      return value is an error code.
//
// Description:
//      The function converts legacy FSP job status values to new job status
//      values as returned by EFSPs.
//
DWORD
LegacyJobStatusToStatus(
    DWORD dwLegacyStatus,
    PDWORD pdwStatus,
    PDWORD pdwExtendedStatus,
    PBOOL  pbPrivateStatusCode)
{

    Assert(pdwStatus);
    Assert(pdwExtendedStatus);
    Assert(pbPrivateStatusCode);
    *pbPrivateStatusCode = FALSE;

    switch (dwLegacyStatus)
    {
    case FS_INITIALIZING:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_INITIALIZING;
        break;

    case FS_DIALING:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_DIALING;
        break;

    case FS_TRANSMITTING:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_TRANSMITTING;
        break;

    case FS_RECEIVING:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_RECEIVING;
        break;

    case FS_COMPLETED:
        *pdwStatus = FSPI_JS_COMPLETED;
        *pdwExtendedStatus = FSPI_ES_CALL_COMPLETED;
        break;

    case FS_HANDLED:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_HANDLED;
        break;

    case FS_LINE_UNAVAILABLE:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_LINE_UNAVAILABLE;
        break;

    case FS_BUSY:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_BUSY;
        break;

    case FS_NO_ANSWER:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_NO_ANSWER;
        break;

    case FS_BAD_ADDRESS:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_BAD_ADDRESS;
        break;

    case FS_NO_DIAL_TONE:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_NO_DIAL_TONE;
        break;

    case FS_DISCONNECTED:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_DISCONNECTED;
        break;

    case FS_FATAL_ERROR:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_FATAL_ERROR;
        break;

    case FS_NOT_FAX_CALL:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_NOT_FAX_CALL;
        break;

    case FS_CALL_DELAYED:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_CALL_DELAYED;
        break;

    case FS_CALL_BLACKLISTED:
        *pdwStatus = FSPI_JS_FAILED;
        *pdwExtendedStatus = FSPI_ES_CALL_BLACKLISTED;
        break;

    case FS_USER_ABORT:
        *pdwStatus = FSPI_JS_ABORTED;
        *pdwExtendedStatus = FSPI_ES_CALL_ABORTED;
        break;

    case FS_SYSTEM_ABORT: // Private T30 status. Used if FaxDevShutDown() was called.
        *pdwStatus = FSPI_JS_SYSTEM_ABORT;
        *pdwExtendedStatus = FSPI_ES_CALL_ABORTED;
        break;

    case FS_ANSWERED:
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = FSPI_ES_ANSWERED;
        break;

    default:
        //
        // The FSP reports a status code which is not one of the predefined status codes.
        // This can be a proprietry status code (in this case the StringId must not be zero)
        // or a TAPI line error (one of LINEERR_constants). Note that all LINERR_constants
        // are negative numbers (documented in MSDN).
        // We mark the fact that it is not one of the stock values so we can map it back
        // to legacy Fax API status codes. Otherwise we might get confused and think that
        // a FSP proprietry code is one of the EFSPI extended status codes.
        //
        // Note that we don't have a way to correctly map the proprietry code
        // to a FSPI_JS status code since we do not know the semantics of the
        // proprietry code. We choose to report it as FSPI_JS_INPROGRESS.
        //
        *pdwStatus = FSPI_JS_INPROGRESS;
        *pdwExtendedStatus = dwLegacyStatus;
        *pbPrivateStatusCode = TRUE;

        break;
    }
    return(ERROR_SUCCESS);
}

//
// Function:
//      GetDevStatusEx
//
// Parameters:
//      hFaxJob - the job handle that FaxDevStartJob returned.
//      LineInfo - Ther line information structure.
//      ppFaxStatus - A pointer to a buffer that receives the address of the
//          FSPI_JOB_STATUS that contains the status.
//
// Return Value:
//      If the function succeeds, the return value is ERROR_SUCCESS, else the
//      return value is an error code.
//
// Description:
//      The function allocates a FSPI_JOB_STATUS structure and calls the EFSP
//      for final job status report. The FSPI_JOB_STATUS is allocated with spare
//      space so that the EFSP can store the strings in that space.
//
static
DWORD
GetDevStatusEx(
    HANDLE hFaxJob,
    PLINE_INFO LineInfo,
    LPFSPI_JOB_STATUS *ppFaxStatus)
{
    DEBUG_FUNCTION_NAME(TEXT("GetDevStatusEx"));
    DWORD dwRet = ERROR_SUCCESS;

    Assert(LineInfo->Provider->dwAPIVersion == FSPI_API_VERSION_2);
    Assert(LineInfo->Provider->FaxDevReportStatusEx);

    LPFSPI_JOB_STATUS pFaxStatus = NULL;

    //
    // allocate memory for the status packet this is a variable size packet
    // based on the size of the strings contained withing the packet.
    //
    DWORD StatusSize = sizeof(FSPI_JOB_STATUS) + FAXDEVREPORTSTATUS_SIZE;
    pFaxStatus = (LPFSPI_JOB_STATUS) MemAlloc( StatusSize );
    if (!pFaxStatus) {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to allocate memory for FSPI_JOB_STATUS"));
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    // Setup the status packet
    //
    pFaxStatus->dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);

    __try {

        //
        // Call the EFSP
        //
        DWORD BytesNeeded;

        dwRet = LineInfo->Provider->FaxDevReportStatusEx(
                     hFaxJob,
                     pFaxStatus,
                     StatusSize,
                     &BytesNeeded
                    );
        //
        // we can't handle the case where the buffer is too small because the status can always
        // change when you trying to reallocate the buffer.
		//
        if (dwRet != ERROR_SUCCESS) {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("FaxDevReportStatus() failed - %d"),
                         dwRet);
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrintEx(DEBUG_ERR,
                     TEXT("FaxDevReportStatus() * CRASHED * . ")
                     TEXT("Exception code = 0x%08x"),
                     GetExceptionCode());
        dwRet = ERROR_INTERNAL_ERROR;
    }

Exit:
    if (dwRet == ERROR_SUCCESS) {
        *ppFaxStatus = pFaxStatus;
    } else {
        MemFree(pFaxStatus);
    }

    return(dwRet);
}

//
// Function:
//      GetDevStatus
//
// Parameters:
//      hFaxJob - the job handle that FaxDevStartJob returned.
//      LineInfo - Ther line information structure.
//      ppFaxStatus - A pointer to a buffer that receives the address of the
//          FSPI_JOB_STATUS that contains the status.
//
// Return Value:
//      If the function succeeds, the return value is ERROR_SUCCESS, else the
//      return value is an error code.
//
// Description:
//      The function allocates a FSPI_JOB_STATUS structure and calls the FSP
//      for final job status report. The FSPI_JOB_STATUS is allocated with spare
//      space so that the EFSP can store the strings in that space.
//      If the FSP is a legacy FSP, the function allocates first a
//      FAX_DEV_STATUS structure, calls the legacy FSP status report function
//      and mapps the returned values into the FSPI_JOB_STATUS structure.
//
DWORD
GetDevStatus(
    HANDLE hFaxJob,
    PLINE_INFO LineInfo,
    LPFSPI_JOB_STATUS *ppFaxStatus)
{
    DEBUG_FUNCTION_NAME(TEXT("GetDevStatus"));
    DWORD dwRet = ERROR_SUCCESS;
    LPWSTR szStatusStr = NULL;
    DWORD dwSize = 0;
    BOOL bPrivateStatusCode = FALSE;

    Assert(hFaxJob);
    Assert(LineInfo);
    Assert(ppFaxStatus);

    if (LineInfo->Provider->dwAPIVersion == FSPI_API_VERSION_2)
    {
        //
        // Call the EFSP
        //
        return GetDevStatusEx(hFaxJob, LineInfo, ppFaxStatus);
    }

    Assert(LineInfo->Provider->dwAPIVersion == FSPI_API_VERSION_1);

    //
    // We're have a legacy FSP to deal with.
    //
    PFAX_DEV_STATUS pLegacyFaxStatus = NULL;
    LPFSPI_JOB_STATUS pFaxStatus = NULL;

    //
    // Allocate memory for the status packet this is a variable size packet
    // based on the size of the strings contained withing the packet.
    //
    DWORD StatusSize = sizeof(FAX_DEV_STATUS) + FAXDEVREPORTSTATUS_SIZE;
    pLegacyFaxStatus = (PFAX_DEV_STATUS) MemAlloc( StatusSize );
    if (!pLegacyFaxStatus)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to allocate memory for FAX_DEV_STATUS"));
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    // Setup the status packet
    //
    pLegacyFaxStatus->SizeOfStruct = StatusSize;

    Assert(LineInfo->Provider->FaxDevReportStatus);

    __try
    {

        //
        // Call the FSP
        //
        DWORD BytesNeeded;

        if (!LineInfo->Provider->FaxDevReportStatus(
                     hFaxJob,
                     pLegacyFaxStatus,
                     StatusSize,
                     &BytesNeeded
                    )) {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("FaxDevReportStatus() failed - %d"),
                         dwRet);
            dwRet = GetLastError();

			// catch the case in which FaxDevReportStatus() failded but doesn't
			// report an error
			Assert (ERROR_SUCCESS != dwRet);

			// in case the provider did not set last error 
			if ( dwRet == ERROR_SUCCESS )
			{
				// force it to report an error
				dwRet = ERROR_INVALID_FUNCTION;
			}

            goto Exit;
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {

        DebugPrintEx(DEBUG_ERR,
                     TEXT("FaxDevReportStatus() * CRASHED * . ")
                     TEXT("Exception code = 0x%08x"),
                     GetExceptionCode());
        dwRet = ERROR_INVALID_FUNCTION;
        goto Exit;

    }

    //
    // Map FAX_DEV_STATUS into FSPI_JOB_STATUS.
    //

    //
    // Compute the extra space that is needed after the structure for the
    // various strings.
    //
    dwSize = sizeof(FSPI_JOB_STATUS);

    if (pLegacyFaxStatus->CSI)
    {
        dwSize += sizeof(WCHAR) * (wcslen(pLegacyFaxStatus->CSI) + 1);
    }
    if (pLegacyFaxStatus->CallerId)
    {
        dwSize += sizeof(WCHAR) * (wcslen(pLegacyFaxStatus->CallerId) + 1);
    }
    if (pLegacyFaxStatus->RoutingInfo)
    {
        dwSize += sizeof(WCHAR) * (wcslen(pLegacyFaxStatus->RoutingInfo) + 1);
    }

    //
    // Allocate the FSPI_JOB_STATUS structure with extra space for the strings.
    //
    pFaxStatus = (LPFSPI_JOB_STATUS)MemAlloc(dwSize);
    if (!pFaxStatus)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to allocate memory for FSPI_JOB_STATUS"));
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    //
    // Zero-out the structure.
    //
    memset(pFaxStatus, 0, dwSize);

    pFaxStatus->dwSizeOfStruct = sizeof(FSPI_JOB_STATUS);

    //
    // Map the legacy status into new EFSPI status.
    //
    dwRet = LegacyJobStatusToStatus(pLegacyFaxStatus->StatusId,
                                    &(pFaxStatus->dwJobStatus),
                                    &(pFaxStatus->dwExtendedStatus),
                                    &bPrivateStatusCode);
    if (dwRet != ERROR_SUCCESS)
    {

        DebugPrintEx(DEBUG_ERR,
                     TEXT("LegacyJobStatusToStatus failed  - %d"),
                     dwRet);
        goto Exit;
    }

    if  (bPrivateStatusCode)
    {
        //
        // The FSP  reported a private status code (not one of the FS_* status codes).
        // We mark this in the returned FSPI_JOB_STATUS by turning on the private flag
        // FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE.
        // We will check this flag when converting the FSPI_JOB_STATUS
        // back to FPS_ device status so we won't get confused by an FSP that returned
        // a proprietry status code which is equal to one the new FSPI_JS_* codes.
        //
         pFaxStatus->fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE;

#if DEBUG
         if (0 == pLegacyFaxStatus->StringId && pLegacyFaxStatus->StatusId < LINEERR_ALLOCATED)
         {
             //
             // The status reported is not one of the stock status codes and is not a TAPI Error code.
             // pLegacyFaxStatus->StringId must not be 0.
             //
             DebugPrintEx(
                 DEBUG_WRN,
                 TEXT("Provider [%s] has reported an illegal FAX_DEV_STATUS for device [%s]\n. ")
                 TEXT("Although the reported status code (0x%08X) is proprietry the string id is 0"),
                 LineInfo->Provider->FriendlyName,
                 LineInfo->DeviceName,
                 pLegacyFaxStatus->StatusId);

         }
#endif
    }
    pFaxStatus->dwExtendedStatusStringId = pLegacyFaxStatus->StringId;


    szStatusStr = (LPWSTR)(((PBYTE)pFaxStatus) + sizeof(FSPI_JOB_STATUS));

    //
    // Copy CSI into lpwstrRemoteStationId
    //
    if (pLegacyFaxStatus->CSI)
    {
        pFaxStatus->lpwstrRemoteStationId = szStatusStr;
        wcscpy(szStatusStr, pLegacyFaxStatus->CSI);
        szStatusStr += wcslen(pLegacyFaxStatus->CSI) + 1;
    }

    //
    // Copy the Caller ID string.
    //
    if (pLegacyFaxStatus->CallerId)
    {
        pFaxStatus->lpwstrCallerId = szStatusStr;
        wcscpy(szStatusStr, pLegacyFaxStatus->CallerId);
        szStatusStr += wcslen(pLegacyFaxStatus->CallerId) + 1;
    }

    //
    // Copy the Routing Info string.
    //
    if (pLegacyFaxStatus->RoutingInfo)
    {
        pFaxStatus->lpwstrRoutingInfo = szStatusStr;
        wcscpy(szStatusStr, pLegacyFaxStatus->RoutingInfo);
    }

    //
    // Copy Page Count.
    //
    pFaxStatus->dwPageCount = pLegacyFaxStatus->PageCount;
    pFaxStatus->fAvailableStatusInfo |= FSPI_JOB_STATUS_INFO_PAGECOUNT;

Exit:;
    if (dwRet == ERROR_SUCCESS)
    {
        *ppFaxStatus = pFaxStatus;
    }
    else
    {
        MemFree(pFaxStatus);
    }

    MemFree(pLegacyFaxStatus);
    return(dwRet);
}

DWORD
GetFileVersion (
    LPWSTR       lpwstrFileName,
    PFAX_VERSION pVersion
)
/*++

Routine name : GetFileVersion

Routine description:

    Fills a FAX_VERSION structure with data about a given file module

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    lpwstrFileName      [in ] - File name
    pVersion            [out] - Version information

Return Value:

    Standard Win32 error

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwVerInfoSize;
    DWORD dwVerHnd=0;           // An ignored parameter, always 0
    LPBYTE lpbVffInfo = NULL;
    VS_FIXEDFILEINFO *pFixedFileInfo;
    UINT uVersionDataLength;
    DEBUG_FUNCTION_NAME(TEXT("GetFileVersion"));

    if (!pVersion)
    {
        return ERROR_INVALID_PARAMETER;
    }
    if (sizeof (FAX_VERSION) != pVersion->dwSizeOfStruct)
    {
        //
        // Size mismatch
        //
       return ERROR_INVALID_PARAMETER;
    }
    pVersion->bValid = FALSE;
    //
    // Find size needed for version information
    //
    dwVerInfoSize = GetFileVersionInfoSize (lpwstrFileName, &dwVerHnd);
    if (0 == dwVerInfoSize)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFileVersionInfoSize() failed . dwRes = %ld"),
            dwRes);
        return dwRes;
    }
    //
    // Allocate memory for file version info
    //
    lpbVffInfo = (LPBYTE)MemAlloc (dwVerInfoSize);
    if (NULL == lpbVffInfo)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Cant allocate %ld bytes"),
            dwVerInfoSize);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    //
    // Try to get the version info
    //
    if (!GetFileVersionInfo(
        lpwstrFileName,
        dwVerHnd,
        dwVerInfoSize,
        (LPVOID)lpbVffInfo))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFileVersionInfo() failed . dwRes = %ld"),
            dwRes);
        goto exit;
    }
    //
    // Query the required version structure
    //
    if (!VerQueryValue (
        (LPVOID)lpbVffInfo,
        TEXT ("\\"),    // Retrieve the VS_FIXEDFILEINFO struct
        (LPVOID *)&pFixedFileInfo,
        &uVersionDataLength))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("VerQueryValue() failed . dwRes = %ld"),
            dwRes);
        goto exit;
    }
    pVersion->dwFlags = (pFixedFileInfo->dwFileFlags & VS_FF_DEBUG) ? FAX_VER_FLAG_CHECKED : 0;
    pVersion->wMajorVersion      = WORD((pFixedFileInfo->dwProductVersionMS) >> 16);
    pVersion->wMinorVersion      = WORD((pFixedFileInfo->dwProductVersionMS) & 0x0000ffff);
    pVersion->wMajorBuildNumber  = WORD((pFixedFileInfo->dwProductVersionLS) >> 16);
    pVersion->wMinorBuildNumber  = WORD((pFixedFileInfo->dwProductVersionLS) & 0x0000ffff);
    pVersion->bValid = TRUE;

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (lpbVffInfo)
    {
        MemFree (lpbVffInfo);
    }
    return dwRes;
}   // GetFileVersion


BOOL
GetRealFaxTimeAsSystemTime (
    const PJOB_ENTRY lpcJobEntry,
    FAX_ENUM_TIME_TYPES TimeType,
    SYSTEMTIME* lpFaxTime
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetRealFaxTimeAsSystemTime)"));
    Assert (lpcJobEntry);
    Assert (lpFaxTime);

    PJOB_QUEUE pJobQueue = lpcJobEntry->lpJobQueueEntry;
    Assert (pJobQueue);
    DWORDLONG dwlFileTime;

    if (pJobQueue->EFSPPermanentMessageId.dwIdSize == 0)
    {
        // Non queueing EFSP
        dwlFileTime = ((TimeType == FAX_TIME_TYPE_START) ? lpcJobEntry->StartTime : lpcJobEntry->EndTime);
        if (dwlFileTime == 0)
        {
            DebugPrintEx(
                      DEBUG_ERR,
                      TEXT("JonEntry contains invalid time (=0) "));
            SetLastError (ERROR_INVALID_DATA);
            return FALSE;
        }

        if (!FileTimeToSystemTime ((FILETIME*)&dwlFileTime, lpFaxTime))
        {
           DebugPrintEx(
               DEBUG_ERR,
               TEXT("FileTimeToSystemTime failed (ec: %ld)"),
               GetLastError());
           return FALSE;
        }
    }
    else
    {
        // Queueing EFSP
        if (TimeType == FAX_TIME_TYPE_START)
        {
            if (!(lpcJobEntry->FSPIJobStatus.fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_TRANSMISSION_START))
            {
                DebugPrintEx(
                  DEBUG_ERR,
                  TEXT("FSPIJobStatus does not contain a valid start time "));
                SetLastError (ERROR_INVALID_DATA);
                return FALSE;
            }
            *lpFaxTime = lpcJobEntry->FSPIJobStatus.tmTransmissionStart;
        }
        else
        {
            if (!(lpcJobEntry->FSPIJobStatus.fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_TRANSMISSION_END))
            {
                DebugPrintEx(
                  DEBUG_ERR,
                  TEXT("FSPIJobStatus does not contain a valid end time "));
                SetLastError (ERROR_INVALID_DATA);
                return FALSE;
            }
            *lpFaxTime = lpcJobEntry->FSPIJobStatus.tmTransmissionEnd;
        }
    }

    return TRUE;
}


BOOL
GetRealFaxTimeAsFileTime (
    const PJOB_ENTRY lpcJobEntry,
    FAX_ENUM_TIME_TYPES TimeType,
    FILETIME* lpFaxTime
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetRealFaxTimeAsSystemTime)"));
    Assert (lpcJobEntry);
    Assert (lpFaxTime);

    PJOB_QUEUE pJobQueue = lpcJobEntry->lpJobQueueEntry;
    Assert (pJobQueue);
    DWORDLONG dwlFileTime;

    if (pJobQueue->EFSPPermanentMessageId.dwIdSize == 0)
    {
        // Non queueing EFSP
        dwlFileTime = ((TimeType == FAX_TIME_TYPE_START) ? lpcJobEntry->StartTime : lpcJobEntry->EndTime);
        if (dwlFileTime == 0)
        {
            DebugPrintEx(
                      DEBUG_ERR,
                      TEXT("JonEntry contains invalid time (=0) "));
            SetLastError (ERROR_INVALID_DATA);
            return FALSE;
        }
        *lpFaxTime = *((FILETIME*)&dwlFileTime);
    }
    else
    {
        // Queueing EFSP
        if (TimeType == FAX_TIME_TYPE_START)
        {
            if (!(lpcJobEntry->FSPIJobStatus.fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_TRANSMISSION_START))
            {
                DebugPrintEx(
                  DEBUG_ERR,
                  TEXT("FSPIJobStatus does not contain a valid start time "));
                SetLastError (ERROR_INVALID_DATA);
                return FALSE;
            }

            if (!SystemTimeToFileTime (&lpcJobEntry->FSPIJobStatus.tmTransmissionStart, lpFaxTime))
            {
               DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("SystemTimeToFileTime failed (ec: %ld)"),
                   GetLastError());
               return FALSE;
            }
        }
        else
        {
            if (!(lpcJobEntry->FSPIJobStatus.fAvailableStatusInfo & FSPI_JOB_STATUS_INFO_TRANSMISSION_END))
            {
                DebugPrintEx(
                  DEBUG_ERR,
                  TEXT("FSPIJobStatus does not contain a valid end time "));
                SetLastError (ERROR_INVALID_DATA);
                return FALSE;
            }

            if (!SystemTimeToFileTime (&lpcJobEntry->FSPIJobStatus.tmTransmissionEnd, lpFaxTime))
            {
               DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("SystemTimeToFileTime failed (ec: %ld)"),
                   GetLastError());
               return FALSE;
            }
        }
    }
    return TRUE;
}


VOID
FaxExtFreeBuffer(
    LPVOID lpvBuffer
)
{
    MemFree( lpvBuffer );
}

DWORD
CheckToSeeIfSameDir(
    LPWSTR lpwstrDir1,
    LPWSTR lpwstrDir2,
    BOOL*  pIsSameDir
    )
{
/*++

Routine name : IsDiffrentDir

Routine description:

    Checks if both paths point to the same directory. Note that the directory pointed by lpwstrDir1 must exist.

Author:

    Oded Sacher (OdedS), Aug, 2000

Arguments:

    lpwstrDir1      [in]  - First path - the directory must exist.
    lpwstrDir2      [in]  - Second path - the directory does not have to exist
    pIsSameDir      [out] - Receives the answer to "IsSameDir?" Valid only if the function succeeds.

Return Value:
    Win32 Erorr code

--*/
    Assert (lpwstrDir1 && lpwstrDir2 && pIsSameDir);
    DWORD ec = ERROR_SUCCESS;
    WCHAR wszTestFile1[MAX_PATH];
    WCHAR wszTestFile2[MAX_PATH * 2];
    BOOL fFileCreated = FALSE;
    HANDLE hFile1 = INVALID_HANDLE_VALUE;
    HANDLE hFile2 = INVALID_HANDLE_VALUE;
    LPWSTR lpwstrFileName = NULL;
    DEBUG_FUNCTION_NAME(TEXT("CheckToSeeIfSameDir)"));

    if (0 == _wcsicmp(lpwstrDir1, lpwstrDir2))
    {
        *pIsSameDir = TRUE;
        return ERROR_SUCCESS;
    }

    //
    // Create temporary files
    //
    if (!GetTempFileName (lpwstrDir1, L"TST", 0, wszTestFile1))
    {
        //
        // Either the folder doesn't exist or we don't have access
        //
        ec = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetTempFileName failed with %ld"), ec);
        goto exit;
    }
    fFileCreated = TRUE;

    hFile1 = CreateFile(wszTestFile1,
                       0,
                       FILE_SHARE_READ|FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);
    if (INVALID_HANDLE_VALUE == hFile1)
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateFile failed (ec: %ld)"),
                     ec);
        return ec;
    }

    lpwstrFileName = wcsrchr(wszTestFile1, L'\\');
    Assert (lpwstrFileName);
    wcscpy (wszTestFile2, lpwstrDir2);
    wcscat (wszTestFile2, lpwstrFileName);

    hFile2 = CreateFile(wszTestFile2,
                       0,
                       FILE_SHARE_READ|FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);
    if (INVALID_HANDLE_VALUE == hFile2)
    {
        //
        // Check if failed because the paths are diffrent
        //
        ec = GetLastError ();
        if (ERROR_FILE_NOT_FOUND == ec ||
            ERROR_PATH_NOT_FOUND == ec)
        {
            //
            // The paths are diffrent
            //
            ec = ERROR_SUCCESS;
            *pIsSameDir = FALSE;
            goto exit;
        }

        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateFile failed (ec: %ld)"),
                     ec);
        goto exit;
    }

    BY_HANDLE_FILE_INFORMATION  hfi1;
    BY_HANDLE_FILE_INFORMATION  hfi2;

    if (!GetFileInformationByHandle(hFile1, &hfi1))
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("GetFileInformationByHandle failed (ec: %ld)"),
                     ec);
        goto exit;
    }

    if (!GetFileInformationByHandle(hFile2, &hfi2))
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("GetFileInformationByHandle failed (ec: %ld)"),
                     ec);
        goto exit;
    }

    if ((hfi1.nFileIndexHigh == hfi2.nFileIndexHigh) &&
        (hfi1.nFileIndexLow == hfi2.nFileIndexLow) &&
        (hfi1.dwVolumeSerialNumber == hfi2.dwVolumeSerialNumber))
    {
        *pIsSameDir = TRUE;
    }
    else
    {
        *pIsSameDir = FALSE;
    }

    Assert (ERROR_SUCCESS == ec);

exit:

    if (INVALID_HANDLE_VALUE != hFile1)
    {
        if (!CloseHandle(hFile1))
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("CloseHandle failed (ec: %ld)"),
                         GetLastError());
        }
    }

    if (INVALID_HANDLE_VALUE != hFile2)
    {
        if (!CloseHandle(hFile2))
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("CloseHandle failed (ec: %ld)"),
                         GetLastError());
        }
    }

    if (TRUE == fFileCreated)
    {
        if (!DeleteFile(wszTestFile1))
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("DeleteFile failed. File: %s,  (ec: %ld)"),
                         wszTestFile1,
                         GetLastError());
        }
    }

    return ec;
}


//
// Service threads count functions.
// The service is terminated only when service threads refernce count is 0.
// When the count is 0 the  g_hThreadCountEvent is set.
// When the count is greater than 0, the g_hThreadCountEvent is reset.
// EndFaxSvc() waits on g_hThreadCountEvent before starting to cleanup.
//
BOOL
IncreaseServiceThreadsCount(
    VOID
    )
/*++

Routine name : IncreaseServiceThreadsCount

Routine description:

    Safetly increments the service threads reference count

Author:

    Oded Sacher (OdedS),    Dec, 2000

Arguments:

    VOID

Return Value:

    BOOL

--*/
{
    BOOL bRet = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("IncreaseServiceThreadsCount"));

    EnterCriticalSection (&g_CsServiceThreads);
    g_lServiceThreadsCount++;

    DebugPrintEx(
            DEBUG_MSG,
            TEXT("Current service threads count is %ld"),
            g_lServiceThreadsCount);

    if (1 == g_lServiceThreadsCount)
    {
        bRet = ResetEvent (g_hThreadCountEvent);
        if (FALSE == bRet)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ResetEvent failed (g_hThreadCountEvent) (ec: %ld"),
                GetLastError());
        }
    }

    LeaveCriticalSection (&g_CsServiceThreads);
    return bRet;
}

BOOL
DecreaseServiceThreadsCount(
    VOID
    )
/*++

Routine name : DecreaseServiceThreadsCount

Routine description:

    Safetly decrements the service threads reference count

Author:

    Oded Sacher (OdedS),    Dec, 2000

Arguments:

    VOID

Return Value:

    BOOL

--*/
{
    BOOL bRet = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("DecreaseServiceThreadsCount"));

    Assert (!ThreadOwnsCs()); // verify that the terminating thread does not own a critical section!!!

    EnterCriticalSection (&g_CsServiceThreads);

    g_lServiceThreadsCount--;
    Assert (g_lServiceThreadsCount >= 0);

    DebugPrintEx(
            DEBUG_MSG,
            TEXT("Current service threads count is %ld"),
            g_lServiceThreadsCount);

    if (0 == g_lServiceThreadsCount)
    {
        bRet = SetEvent (g_hThreadCountEvent);
        if (FALSE == bRet)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetEvent failed (g_hThreadCountEvent) (ec: %ld"),
                GetLastError());
        }
    }

    LeaveCriticalSection (&g_CsServiceThreads);
    return bRet;
}



HANDLE CreateThreadAndRefCount(
  LPSECURITY_ATTRIBUTES lpThreadAttributes, // SD
  DWORD dwStackSize,                        // initial stack size
  LPTHREAD_START_ROUTINE lpStartAddress,    // thread function
  LPVOID lpParameter,                       // thread argument
  DWORD dwCreationFlags,                    // creation option
  LPDWORD lpThreadId                        // thread identifier
)
/*++

Routine name : CreateThreadAndRefCount

Routine description:

    Creates a thread and saftely increments the service threads reference count.
    All function parameters and return value are IDENTICAL to CreateThread().

Author:

    Oded Sacher (OdedS),    Dec, 2000

Arguments:

    lpThreadAttributes  [      ] -
    dwStackSize         [      ] -
    lpStartAddress      [      ] -
    lpParameter         [      ] -
    dwCreationFlags     [      ] -
    lpThreadId          [      ] -

Return Value:

    HANDLE

--*/
{
    HANDLE hThread;
    DWORD ec;
    DEBUG_FUNCTION_NAME(TEXT("CreateThreadAndRefCount"));


    //
    // First enter g_CsServiceThreads so the threads reference counter is always ssynced!
    //
    EnterCriticalSection (&g_CsServiceThreads);

    hThread = CreateThread( lpThreadAttributes,
                            dwStackSize,
                            lpStartAddress,
                            lpParameter,
                            dwCreationFlags,
                            lpThreadId
                          );
    if (NULL == hThread)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateThread failed (ec: %ld"),
            ec);
    }
    else
    {
        if (!IncreaseServiceThreadsCount())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("IncreaseServiceThreadsCount failed (ec: %ld"),
                GetLastError());
        }
    }

    LeaveCriticalSection (&g_CsServiceThreads);
    if (NULL == hThread)
    {
        SetLastError(ec);
    }
    return hThread;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\winfax\devtest\testwinfax.cpp ===
#include <winfax.h>

void CallEverythingWithGarbage ()
{
    FaxAbort (NULL, 0);
    FaxAccessCheck (NULL, 0);
    FaxClose (NULL);
    FaxCompleteJobParamsA (NULL, NULL);
    FaxCompleteJobParamsW (NULL, NULL);
    FaxConnectFaxServerA (NULL, NULL);
    FaxConnectFaxServerW (NULL, NULL);
    FaxEnableRoutingMethodA (NULL, NULL, FALSE);
    FaxEnableRoutingMethodW (NULL, NULL, FALSE);
    FaxEnumGlobalRoutingInfoA (NULL, NULL, NULL);
    FaxEnumGlobalRoutingInfoW (NULL, NULL, NULL);
    FaxEnumJobsA (NULL, NULL, NULL);
    FaxEnumJobsW (NULL, NULL, NULL);
    FaxEnumPortsA (NULL, NULL, NULL);
    FaxEnumPortsW (NULL, NULL, NULL);
    FaxEnumRoutingMethodsA (NULL, NULL, NULL);
    FaxEnumRoutingMethodsW (NULL, NULL, NULL);
    FaxFreeBuffer (NULL);
    FaxGetConfigurationA (NULL, NULL);
    FaxGetConfigurationW (NULL, NULL);
    FaxGetDeviceStatusA (NULL, NULL);
    FaxGetDeviceStatusW (NULL, NULL);
    FaxGetJobA (NULL, 0, NULL);
    FaxGetJobW (NULL, 0, NULL);
    FaxGetLoggingCategoriesA (NULL, NULL, NULL);
    FaxGetLoggingCategoriesW (NULL, NULL, NULL);
    FaxGetPageData (NULL, 0, NULL, NULL, NULL, NULL);
    FaxGetPortA (NULL, NULL);
    FaxGetPortW (NULL, NULL);
    FaxGetRoutingInfoA (NULL, NULL, NULL, NULL);
    FaxGetRoutingInfoW (NULL, NULL, NULL, NULL);
    FaxInitializeEventQueue (NULL, NULL, NULL, NULL, 0);
    FaxOpenPort (NULL, 0, 0, NULL);
    FaxPrintCoverPageA (NULL, NULL);
    FaxPrintCoverPageW (NULL, NULL);
    FaxRegisterRoutingExtensionW (NULL, NULL, NULL, NULL, NULL, NULL);
    FaxRegisterServiceProviderW (NULL, NULL, NULL, NULL);
    FaxSendDocumentA (NULL, NULL, NULL, NULL, NULL);
    FaxSendDocumentW (NULL, NULL, NULL, NULL, NULL);
    FaxSendDocumentForBroadcastA (NULL, NULL, NULL, NULL, NULL);
    FaxSendDocumentForBroadcastW (NULL, NULL, NULL, NULL, NULL);
    FaxSetConfigurationA (NULL, NULL);
    FaxSetConfigurationW (NULL, NULL);
    FaxSetGlobalRoutingInfoA (NULL, NULL);
    FaxSetGlobalRoutingInfoW (NULL, NULL);
    FaxSetJobA (NULL, 0, 0, NULL);
    FaxSetJobW (NULL, 0, 0, NULL);
    FaxSetLoggingCategoriesA (NULL, NULL, 0);
    FaxSetLoggingCategoriesW (NULL, NULL, 0);
    FaxSetPortA (NULL, NULL);
    FaxSetPortW (NULL, NULL);
    FaxSetRoutingInfoA (NULL, NULL, NULL, 0);
    FaxSetRoutingInfoW (NULL, NULL, NULL, 0);
    FaxStartPrintJobA (NULL, NULL, NULL, NULL);
    FaxStartPrintJobW (NULL, NULL, NULL, NULL);
}

#ifndef _UNICODE
int main (
    int argc,
    char *argv[]
)
{
    //
    // We only check the linkage - not performance.
    //
    CallEverythingWithGarbage();
    return 0;
}
#else
int wmain (
    int argc,
    WCHAR *argv[]
)
{
    //
    // We only check the linkage - not performance.
    //
    CallEverythingWithGarbage();
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\systray\monitor.cpp ===
/**

Copyright (c)  Microsoft Corporation 1999-2000

Module Name:

    monitor.cpp

Abstract:

    This module implements the fax monitor dialog.

**/


#include <windows.h>
#include <faxreg.h>
#include <faxutil.h>
#include <fxsapip.h>
#include <commctrl.h>
#include <tchar.h>
#include <DebugEx.h>

#include <list>
using namespace std;

#include "monitor.h"
#include "resource.h"

#define DURATION_TIMER_RESOLUTION   500     // Resolution (millisecs) of duration text update timer

//////////////////////////////////////////////////////////////
// Global data
//

extern HINSTANCE        g_hInstance;
extern HANDLE           g_hFaxSvcHandle;
extern DWORD            g_dwCurrentJobID;
extern CONFIG_OPTIONS   g_ConfigOptions;
extern TCHAR            g_szRemoteId[MAX_PATH];  // Sender ID or Recipient ID
extern HCALL            g_hCall;                 // Handle to call (from FAX_EVENT_TYPE_NEW_CALL)
//
// Events log
//

struct EVENT_ENTRY
{
    eIconType eIcon;                // Event icon
    TCHAR     tszTime[30];          // Event time string
    TCHAR     tszEvent[MAX_PATH];   // Event string
};

typedef EVENT_ENTRY *PEVENT_ENTRY;

typedef list<EVENT_ENTRY> EVENTS_LIST, *PEVENTS_LIST;

EVENTS_LIST g_lstEvents;        // Global list of events

#define MAX_EVENT_LIST_SIZE   50  // Maximal number of events in log

//
// Monitor dialog
//
HWND   g_hMonitorDlg = NULL;

//
// Controls
//
HWND   g_hStatus         = NULL;    // Status line (static text)
HWND   g_hElapsedTime    = NULL;    // Elapsed time line (static text)
HWND   g_hToFrom         = NULL;    // To/From line (static text)
HWND   g_hListDetails    = NULL;    // Details list control
HWND   g_hAnimation      = NULL;    // Animation control
HWND   g_hDisconnect     = NULL;    // Disconnect button

HICON      g_hDlgIcon      = NULL;    // Dialog main icon
HIMAGELIST g_hDlgImageList = NULL;  // Dialog's image list

//
// Data
//
BOOL         g_bAnswerNow = FALSE;  // TRUE if the dialog button shows 'Answer Now'. FALSE if it shows 'Disconnect'.
DWORD        g_dwHeightDelta = 0;   // Used when pressing "More >>>" / "Less <<<" to resize the dialog
DWORD        g_dwDlgHeight = 0;     // The dialog height
BOOL         g_bDetails = FALSE;    // Is the "More >>>" button pressed?
DeviceState  g_devState = FAX_IDLE; // Current fax state (animation)
DWORD        g_dwStartTime = 0;     // Activity start time (tick counts)
UINT_PTR     g_nElapsedTimerId = 0; // Timer id for elapsed time (ticks every 1 second)
TCHAR        g_tszTimeSeparator[5] = {0};
DWORD        g_dwCurrentAnimationId = 0;      // Current animation resource ID
TCHAR        g_tszLastEvent[MAX_PATH] = {0};  // The last event string
POINT        g_ptPosition = {-1, -1};         // Dialog position
BOOL         g_bTopMost = FALSE;    // Is the monitor dialog always visible?

#define DETAILS_TIME_COLUMN_WIDTH    90


/////////////////////////////////////////////////////////////////////
// Function prototypes
//

// public
BOOL  IsUserGrantedAccess(DWORD);
DWORD OpenFaxMonitor(VOID);
void  SetStatusMonitorDeviceState(DeviceState devState);
void  OnDisconnect();
void  FreeMonitorDialogData (BOOL bShutdown);

// Private
INT_PTR CALLBACK FaxMonitorDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID    CALLBACK ElapsedTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

void  InitMonitorDlg(HWND hDlg);
DWORD UpdateMonitorData(HWND hDlg);
void  AddEventToView(PEVENT_ENTRY pEvent);
void  OnAlwaysOnTop(HWND hDlg);
void  OnDetailsButton(HWND hDlg, BOOL bDetails);
void  OnClearLog();
int   FaxMessageBox(HWND hWnd, DWORD dwTextID, UINT uType);
DWORD  RefreshImageList ();

//////////////////////////////////////////////////////////////////////
// Implementation
//

void  
FreeMonitorDialogData (
    BOOL bShutdown /* = FALSE */
)
/*++

Routine name : FreeMonitorDialogData

Routine description:

    Frees up all the data allocated by the monitor module

Author:

    Eran Yariv (EranY), Mar, 2001

Arguments:

    bShutdown - [in] TRUE only is the module is shutting down.

Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("FreeMonitorDialogData"), dwRes);

    if(g_nElapsedTimerId)
    {
        if (!KillTimer(NULL, g_nElapsedTimerId))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("KillTimer"), GetLastError ());
        }
        g_nElapsedTimerId = NULL;
    }

    RECT rc = {0};
    if(GetWindowRect(g_hMonitorDlg, &rc))
    {
        g_ptPosition.x = rc.left;
        g_ptPosition.y = rc.top;
    }
    
    
    g_hMonitorDlg = NULL;

    g_hStatus      = NULL;
    g_hElapsedTime = NULL;
    g_hToFrom      = NULL;
    g_hListDetails = NULL;
    g_hDisconnect  = NULL;
    g_hAnimation   = NULL;
    g_dwCurrentAnimationId = 0;

    if (g_hDlgImageList)
    {
        ImageList_Destroy (g_hDlgImageList);
        g_hDlgImageList = NULL;
    }
    if (bShutdown)
    {
        //
        // DLL is shutting down.
        //

        //
        // The icon is cached in memory even when the dialog is closed.
        // This is a good time to free it.
        //
        if (g_hDlgIcon)
        {
            if (!DestroyIcon (g_hDlgIcon))
            {
                CALL_FAIL (WINDOW_ERR, TEXT("DestroyIcon"), GetLastError ());
            }
            g_hDlgIcon = NULL;
        }
        //
        // Also delete all the events from the list
        //
        try
        {
            g_lstEvents.clear();
        }
        catch (exception &ex)
        {
            VERBOSE (MEM_ERR, 
                     TEXT("Got an STL exception while clearing the events list (%S)"),
                     ex.what());
        }

        g_ptPosition.x = -1;
        g_ptPosition.y = -1;
    }
}   // FreeMonitorDialogData


INT_PTR 
CALLBACK 
FaxMonitorDlgProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
/*++

Routine description:

    fax monitor dialog procedure

Arguments:

  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter

Return Value:

    return TRUE if it processed the message

--*/

{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            InitMonitorDlg(hwndDlg);
            return TRUE;

        case WM_DESTROY:
            FreeMonitorDialogData ();
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_DETAILS:
                        g_bDetails = !g_bDetails;
                        OnDetailsButton(hwndDlg, g_bDetails);
                        return TRUE;

                case IDC_ALWAYS_ON_TOP:
                        OnAlwaysOnTop(hwndDlg);
                        return TRUE;

                case IDC_CLEAR_LOG:
                        OnClearLog();
                        return TRUE;

                case IDC_DISCONNECT:
                        OnDisconnect();
                        return TRUE;

                case IDCANCEL:
                        DestroyWindow( hwndDlg );
                        return TRUE;

            } // switch(LOWORD(wParam))

            break;

        case WM_HELP:
            WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hwndDlg);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hwndDlg);            
            return TRUE;

        case WM_SYSCOLORCHANGE:
            RefreshImageList ();
            return TRUE;

    } // switch ( uMsg )
    return FALSE;
} // FaxMonitorDlgProc

DWORD
RefreshImageList ()
/*++

Routine name : RefreshImageList

Routine description:

    Refreshes the image list and list view background color

Author:

    Eran Yariv (EranY), May, 2001

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("RefreshImageList"), dwRes);
    ListView_SetExtendedListViewStyle(g_hListDetails, 
                                      LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP | LVS_EX_ONECLICKACTIVATE);

    if (NULL != g_hDlgImageList)
    {
        ImageList_Destroy (g_hDlgImageList);
        g_hDlgImageList = NULL;
    }
    g_hDlgImageList = ImageList_Create (16, 16, ILC_COLOR8, 4, 0);
    if(!g_hDlgImageList)
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT("ImageList_Create"), dwRes);
        return dwRes;
    }
    HBITMAP hBmp = (HBITMAP) LoadImage (
                              g_hInstance, 
                              MAKEINTRESOURCE(IDB_LIST_IMAGES),
                              IMAGE_BITMAP,
                              0,
                              0,
                              LR_DEFAULTSIZE | LR_LOADTRANSPARENT);
    if (!hBmp)
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT("LoadBitmap"), dwRes);
        ImageList_Destroy (g_hDlgImageList);
        g_hDlgImageList = NULL;
        return dwRes;
    }
    ImageList_Add (g_hDlgImageList, hBmp, NULL);
    //
    // ImageList_Add creates a copy of the bitmap - it's now safe to delete it
    //
    ::DeleteObject ((HGDIOBJ)hBmp);
    ListView_SetImageList(g_hListDetails, g_hDlgImageList, LVSIL_SMALL);
    ListView_SetBkColor  (g_hListDetails, ::GetSysColor(COLOR_WINDOW));
    return dwRes;
}   // RefreshImageList

void
InitMonitorDlg(
    HWND hDlg
)
/*++

Routine description:

    Initialize fax monitor dialog

Arguments:

    hDlg          [in] - fax monitor dialog handle

Return Value:

    none

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("InitMonitorDlg"), dwRes);

    //
    // Set the dialog icon
    //
    if (NULL == g_hDlgIcon)
    {
        //
        // 1st time the dialog is opened - load the icons
        //
        g_hDlgIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_FAX_MONITOR));
        if(!g_hDlgIcon)
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("LoadIcon"), dwRes);
            return;
        }
    }
    SendMessage(hDlg, WM_SETICON, ICON_BIG,   (LPARAM)g_hDlgIcon);
    SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)g_hDlgIcon);
    //
    // Calculate the height of the details part
    //
    RECT rcList, rcDialog;
    if(!GetWindowRect(hDlg, &rcDialog))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("GetWindowRect"), dwRes);
        return;
    }
    g_dwDlgHeight = rcDialog.bottom - rcDialog.top;

    g_hListDetails = GetDlgItem(hDlg, IDC_LIST_DETAILS);
    ASSERTION (g_hListDetails);

    if(!GetWindowRect(g_hListDetails, &rcList))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("GetWindowRect"), dwRes);
        return;
    }

    g_dwHeightDelta = rcDialog.bottom - rcList.top;

    //
    //  Shrink down to small size (initially)
    //
    OnDetailsButton(hDlg, g_bDetails);

    //
    // Init the list view
    //
    RefreshImageList ();
    //
    // Add time column
    //
    TCHAR tszHeader[MAX_PATH];

    LVCOLUMN lvColumn = {0};
    lvColumn.mask     = LVCF_TEXT | LVCF_WIDTH;
    lvColumn.cx       = DETAILS_TIME_COLUMN_WIDTH;
    lvColumn.pszText  = tszHeader;

    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_DETAIL_TIME_HEADER, tszHeader)))
    {
        return;
    }

    ListView_InsertColumn(g_hListDetails, 0, &lvColumn);

    //
    // add event column
    //
    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_DETAIL_EVENT_HEADER, tszHeader)))
    {
        return;
    }
    ListView_InsertColumn(g_hListDetails, 1, &lvColumn);

    //
    // Autosize the last column width
    //
    ListView_SetColumnWidth(g_hListDetails, 1, LVSCW_AUTOSIZE_USEHEADER); 

    //
    // Animation control
    //
    g_hAnimation = GetDlgItem(hDlg, IDC_ANIMATE);
    ASSERTION (g_hAnimation);
    //
    // Get static text controls
    //
    g_hStatus = GetDlgItem(hDlg, IDC_STATUS);
    ASSERTION (g_hStatus);
    g_hElapsedTime = GetDlgItem(hDlg, IDC_ELAPSED_TIME);
    ASSERTION (g_hElapsedTime);
    g_hToFrom = GetDlgItem(hDlg, IDC_TITLE);
    ASSERTION (g_hToFrom);
    //
    // Disconnect button
    //
    g_hDisconnect = GetDlgItem(hDlg, IDC_DISCONNECT);
    ASSERTION (g_hDisconnect);    
    //
    // Get the time separator string
    //
    if(!GetLocaleInfo(LOCALE_USER_DEFAULT, 
                      LOCALE_STIME, 
                      g_tszTimeSeparator, 
                      ARR_SIZE(g_tszTimeSeparator) - 1))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("GetLocaleInfo(LOCALE_STIME)"), dwRes);
    } 
    
    if(g_ptPosition.x != -1 && g_ptPosition.y != -1)
    {
        SetWindowPos(hDlg, 0, g_ptPosition.x, g_ptPosition.y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
    }

    UpdateMonitorData(hDlg);

} // InitMonitorDlg


DWORD
UpdateMonitorData(
    HWND hDlg
)
/*++

Routine description:

    Update monitor data and controls

Arguments:

    hDlg          [in] - fax monitor dialog handle
    
Return Value:

    standard error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("UpdateMonitorData"), dwRes);

    if(!hDlg || !g_hStatus || !g_hElapsedTime || !g_hToFrom || !g_hListDetails || !g_hDisconnect)
    {
        return dwRes;
    }
    //
    // elapsed time
    //
    if(FAX_IDLE == g_devState)
    {
        if(!SetWindowText(g_hElapsedTime, TEXT("")))
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowText"), dwRes);
        }        
    }
    //
    // Disconnect/Answer button
    //
    BOOL  bButtonEnable = FALSE;
    DWORD dwButtonTitleID = IDS_BUTTON_DISCONNECT;
    TCHAR tszButtonTitle[MAX_PATH] = {0};
    g_bAnswerNow = FALSE;
    if (ERROR_SUCCESS == CheckAnswerNowCapability (FALSE,           // Don't force service to be up
                                                   NULL))           // Don't care about device id 
    {
        //
        // Answer Now option is valid
        //
        g_bAnswerNow      = TRUE;
        bButtonEnable   = TRUE;
        dwButtonTitleID = IDS_BUTTON_ANSWER;
    }
    else if((FAX_SENDING == g_devState || 
             FAX_RECEIVING == g_devState) 
             && 
            (IsUserGrantedAccess(FAX_ACCESS_SUBMIT)         || 
             IsUserGrantedAccess(FAX_ACCESS_SUBMIT_NORMAL)  ||
             IsUserGrantedAccess(FAX_ACCESS_SUBMIT_HIGH)    ||
             IsUserGrantedAccess(FAX_ACCESS_MANAGE_JOBS)))
    {
        //
        // Fax in progress
        //
        bButtonEnable   = TRUE;
        dwButtonTitleID = IDS_BUTTON_DISCONNECT;
    }

    EnableWindow(g_hDisconnect, bButtonEnable);

    if (ERROR_SUCCESS  == LoadAndFormatString (dwButtonTitleID, tszButtonTitle))
    {
        SetWindowText(g_hDisconnect, tszButtonTitle);
    }
    else
    {
        ASSERTION_FAILURE;
    }
    //
    // Animation
    //
    DWORD dwAnimationId = IDR_FAX_IDLE;
    switch(g_devState)
    {
        case FAX_IDLE:
            dwAnimationId = IDR_FAX_IDLE;
            break;
        case FAX_RINGING:
            dwAnimationId = IDR_FAX_RINGING;
            break;
        case FAX_SENDING:
            dwAnimationId = IDR_FAX_SEND;
            break;
        case FAX_RECEIVING:
            dwAnimationId = IDR_FAX_RECEIVE;
            break;
    }

    if(g_dwCurrentAnimationId != dwAnimationId)
    {
        if(!Animate_Open(g_hAnimation, MAKEINTRESOURCE(dwAnimationId)))
        {
            CALL_FAIL (WINDOW_ERR, TEXT ("Animate_Open"), 0);
        }
        else
        {
            if(!Animate_Play(g_hAnimation, 0, -1, -1))
            {
                CALL_FAIL (WINDOW_ERR, TEXT ("Animate_Play"), 0);
            }
            else
            {
                g_dwCurrentAnimationId = dwAnimationId;
            }
        }
    }
    // 
    // Status
    //
    if(FAX_IDLE != g_devState)         // Non-idle state and
    {
        if(!SetWindowText(g_hStatus, g_tszLastEvent))
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowText"), dwRes);
        }
    }
    else // idle
    {
        DWORD dwStrId = IDS_FAX_READY;
        TCHAR tszReady[MAX_PATH];

        if(g_ConfigOptions.bSend && 
          (g_ConfigOptions.bReceive || g_ConfigOptions.dwManualAnswerDeviceId == g_ConfigOptions.dwMonitorDeviceId))
        {
            dwStrId = IDS_READY_TO_SND_AND_RCV;
        }
        else if(g_ConfigOptions.bSend)
        {
            dwStrId = IDS_READY_TO_SND;
        }
        else if(g_ConfigOptions.bReceive || g_ConfigOptions.dwManualAnswerDeviceId == g_ConfigOptions.dwMonitorDeviceId)
        {
            dwStrId = IDS_READY_TO_RCV;
        }

        if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (dwStrId, tszReady)))
        {
            return dwRes;
        }
        if(!SetWindowText(g_hStatus, tszReady))
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowText"), dwRes);
        }
    }
    //
    // to/from
    //
    TCHAR tszToFrom[MAX_PATH] = {0};
    if(FAX_SENDING == g_devState || FAX_RECEIVING == g_devState)
    {
        LPCTSTR lpctstrAddressParam = NULL;
        DWORD  dwStringResId = (FAX_SENDING == g_devState) ? IDS_SENDING : IDS_RECEIVING;
        if(_tcslen(g_szRemoteId))
        {
            //
            // Remote ID is known
            //
            lpctstrAddressParam = g_szRemoteId;
            dwStringResId = (FAX_SENDING == g_devState) ? IDS_SENDING_TO : IDS_RECEIVING_FROM;
        }
        if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (dwStringResId, tszToFrom, lpctstrAddressParam)))
        {
            return dwRes;
        }
    }
    if(!SetWindowText(g_hToFrom, tszToFrom))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowText"), dwRes);
    }
    //
    // Details log list
    // 
    if(ListView_GetItemCount(g_hListDetails) == 0)
    {
        //
        // Log is empty - fill it with list data
        //
        ASSERTION (g_lstEvents.size() <= MAX_EVENT_LIST_SIZE);
        for (EVENTS_LIST::iterator it = g_lstEvents.begin(); it != g_lstEvents.end(); ++it)
        {
            EVENT_ENTRY &Event = *it;
            AddEventToView(&Event);
        }
    }

    if(!CheckDlgButton(hDlg, IDC_ALWAYS_ON_TOP, g_bTopMost ? BST_CHECKED : BST_UNCHECKED))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("CheckDlgButton(IDC_ALWAYS_ON_TOP)"), dwRes);
    }

    OnAlwaysOnTop(hDlg);

    return dwRes;
} // UpdateMonitorData


void  
OnDetailsButton(
    HWND hDlg,
    BOOL bDetails
)
/*++

Routine description:

  Show/Hide event log and change the details button text 
  according to bDetails value

Arguments:

  hDlg          [in] - fax monitor dialog handle
  bDetails      [in] - new details state
    
Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnDetailsButton"));

    if(!hDlg)
    {
        ASSERTION (FALSE);
        return;
    }

    //
    // Show/Hide the event log
    //
    RECT rc;
    GetWindowRect(hDlg, &rc);

    BOOL bLogOpened = (rc.bottom - rc.top > g_dwDlgHeight - g_dwHeightDelta/2);
    //
    // If the current dialog heigh more then 
    // dlialog heigh with open log minus half log heigh
    // we suppose that the log is opened.
    // This done due to different dialog size in the high contrast mode.
    //
    if(bLogOpened != bDetails)
    {
        //
        // Current log state does not fit the new state
        //
        rc.bottom += g_dwHeightDelta * (bDetails ? 1 : -1);
        MoveWindow(hDlg, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, TRUE);
    }

    //
    // Set More/Less button text
    //
    TCHAR tszButtonText[MAX_PATH];
    if (ERROR_SUCCESS != LoadAndFormatString (bDetails ? IDS_BUTTON_LESS : IDS_BUTTON_MORE, tszButtonText))
    {
        return;
    }

    if(!SetDlgItemText(hDlg, IDC_DETAILS, tszButtonText))
    {
        CALL_FAIL (WINDOW_ERR, TEXT ("SetDlgItemText"), GetLastError());
    }

} // OnDetailsButton

void  
OnAlwaysOnTop(
    HWND hDlg
)
/*++

Routine description:

    Change monitor "on top" state and save it to the registry

Arguments:

  hDlg          [in] - fax monitor dialog handle
    
Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnAlwaysOnTop"));

    if(!hDlg)
    {
        ASSERTION (FALSE);
        return;
    }

    g_bTopMost = (IsDlgButtonChecked(hDlg, IDC_ALWAYS_ON_TOP) == BST_CHECKED) ? 1:0;
    DWORD dwRes;

    if(!SetWindowPos(hDlg,
                     g_bTopMost ? HWND_TOPMOST : HWND_NOTOPMOST,
                     0,
                     0,
                     0,
                     0,
                     SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowPos"), dwRes);
    }

    HKEY  hKey;
    dwRes = RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, 0, KEY_WRITE, &hKey);
    if (ERROR_SUCCESS == dwRes) 
    {
        dwRes = RegSetValueEx(hKey, REGVAL_ALWAYS_ON_TOP, 0, REG_DWORD, (CONST BYTE*)&g_bTopMost, sizeof(g_bTopMost));
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (WINDOW_ERR, TEXT ("RegSetValueEx(REGVAL_ALWAYS_ON_TOP)"), dwRes);
        }
    
        RegCloseKey( hKey );
    }
    else
    {
        CALL_FAIL (WINDOW_ERR, TEXT ("RegOpenKeyEx"), dwRes);
    }
} // OnAlwaysOnTop

void
SetStatusMonitorDeviceState(
    DeviceState devState
)
/*++

Routine description:

    Change device state
    Start/stop elapsed timer

Arguments:

    devState  - [in] device state

Return Value:

    none

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("SetStatusMonitorDeviceState"), dwRes);

    if(g_devState != devState)
    {
        //
        // State has changed
        //
        if(g_nElapsedTimerId)
        {
            //
            // Old timer exists
            //
            if(!KillTimer(NULL, g_nElapsedTimerId))
            {
                dwRes = GetLastError();
                CALL_FAIL (WINDOW_ERR, TEXT ("KillTimer"), dwRes);
            }
            g_nElapsedTimerId = 0;
        }
    }

    if(!g_nElapsedTimerId && (devState == FAX_SENDING || devState == FAX_RECEIVING))
    {
        //
        // We need to count elapsed time for send / receive states.
        //
        g_dwStartTime = GetTickCount();

        g_nElapsedTimerId = SetTimer(NULL, 0, DURATION_TIMER_RESOLUTION, ElapsedTimerProc);
        if(!g_nElapsedTimerId)
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("SetTimer"), dwRes);
        }
    }

    g_devState = devState;

    UpdateMonitorData(g_hMonitorDlg);
}   // SetStatusMonitorDeviceState


VOID 
CALLBACK 
ElapsedTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
/*++

Routine description:

    Timer precedure to update elapsed time value

Arguments:

  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("ElapsedTimerProc"));

    if(!g_hElapsedTime)
    {
        return;
    }

    TCHAR  tszTime[MAX_PATH] = {0};
    TCHAR  tszTimeFormat[MAX_PATH] = {0};

    DWORD dwRes;

    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_ELAPSED_TIME, tszTimeFormat)))
    {
        return;
    }

    DWORD dwElapsedTime = (GetTickCount() - g_dwStartTime)/1000;

    _sntprintf(tszTime, 
               ARR_SIZE(tszTime) - 1, 
               tszTimeFormat, 
               dwElapsedTime/60,
               g_tszTimeSeparator,
               dwElapsedTime%60);
    
    if(!SetWindowText(g_hElapsedTime, tszTime))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("SetWindowText"), dwRes);
    }
}   // ElapsedTimerProc


DWORD 
LoadAndFormatString (
    DWORD     dwStringResourceId,
    LPTSTR    lptstrFormattedString,
    LPCTSTR   lpctstrAdditionalParam /* = NULL */
)
/*++

Routine name : LoadAndFormatString

Routine description:

    Loads a string from the resource and optionally formats it with another string

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:

    dwStringResourceId     [in]     - String resource id
    lptstrFormattedString  [out]    - Result buffer. Must be at least MAX_PATH charactes long.
    lpctstrAdditionalParam [in]     - Optional string paramter.
                                      If non-NULL, this loaded strings is used as a format specifier (sprintf-like) to
                                      format this additional string.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("LoadAndFormatString"), 
              dwRes, 
              TEXT("ResourceId=%d, Param=%s"),
              dwStringResourceId,
              lpctstrAdditionalParam);

    ASSERTION (lptstrFormattedString && dwStringResourceId);

    TCHAR tszString[MAX_PATH];

    if (!LoadString(g_hInstance, dwStringResourceId, tszString, ARR_SIZE(tszString)))
    {
        dwRes = GetLastError();
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadString"), dwRes);
        return dwRes;
    }
    if (lpctstrAdditionalParam)
    {
        _sntprintf(lptstrFormattedString, 
                   MAX_PATH,
                   tszString, 
                   lpctstrAdditionalParam);
    }
    else
    {
        lstrcpy (lptstrFormattedString, tszString);
    }
    return dwRes;
}   // LoadAndFormatString

DWORD 
AddStatusMonitorLogEvent (
    eIconType eIcon,
    DWORD     dwStringResourceId,
    LPCTSTR   lpctstrAdditionalParam /* = NULL */,
    LPTSTR    lptstrFormattedEvent /* = NULL */
)
/*++

Routine name : AddStatusMonitorLogEvent

Routine description:

    Adds a status monitor event log line

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:

    eIcon                  [in]  - Icon to display in log entry
    dwStringResourceId     [in]  - String resource id to use
    lpctstrAdditionalParam [in]  - Optional string. If non-NULL, the string loaded from dwStringResourceId
                                   is used to format the additional parameter.
    lptstrFormattedEvent   [out] - Optional, if non-NULL, points to a buffer to receive the final status string.
                                   Buffer must be at least MAX_PATH characters long.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("AddStatusMonitorLogEvent"), 
              dwRes, 
              TEXT("Icon=%d, ResourceId=%d, Param=%s"),
              eIcon,
              dwStringResourceId,
              lpctstrAdditionalParam);
    
    TCHAR tszStatus[MAX_PATH * 2];
    dwRes = LoadAndFormatString (dwStringResourceId, tszStatus, lpctstrAdditionalParam);
    if (ERROR_SUCCESS != dwRes)
    {
        return dwRes;
    }
    if (lptstrFormattedEvent)
    {
        lstrcpy (lptstrFormattedEvent, tszStatus);
    }
    dwRes = AddStatusMonitorLogEvent (eIcon, tszStatus);
    return dwRes;
}   // AddStatusMonitorLogEvent


DWORD 
AddStatusMonitorLogEvent (
    eIconType  eIcon,
    LPCTSTR    lpctstrString
)
/*++

Routine description:

    Add new event to the event list

Arguments:
    
    eIcon         - [in] icon index
    lpctstrString - [in] event description

Return Value:

    standard error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("AddStatusMonitorLogEvent"), 
              dwRes, 
              TEXT("Icon=%d, Status=%s"),
              eIcon,
              lpctstrString);

    TCHAR tszTime [MAX_PATH] = {0};

    ASSERTION (lpctstrString);

    static TCHAR tszRinging[MAX_PATH] = {0};

    if(_tcslen(tszRinging) == 0)
    {
        if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_RINGING, tszRinging)))
        {
            ASSERTION_FAILURE;
            return dwRes;
        }
    }

    if(_tcscmp(lpctstrString, g_tszLastEvent) == 0 &&
       _tcscmp(lpctstrString, tszRinging)     != 0)
    {
        //
        // Do not display the same string twice
        // except "Ringing"
        //
        return dwRes;
    }

    EVENT_ENTRY Event;
    Event.eIcon = eIcon;

    SYSTEMTIME sysTime;
    GetLocalTime(&sysTime);
    if(!FaxTimeFormat(LOCALE_USER_DEFAULT, 0, &sysTime, NULL, Event.tszTime, ARR_SIZE(Event.tszTime) - 1))
    {
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, TEXT ("FaxTimeFormat"), dwRes);
        return dwRes;
    }

    lstrcpy (Event.tszEvent, lpctstrString);
    lstrcpy (g_tszLastEvent, lpctstrString);

    try
    {
        g_lstEvents.push_back (Event);
        if (g_lstEvents.size() > MAX_EVENT_LIST_SIZE)
        {
            //
            // We exceeded the maximal size we permit - remove the most ancient entry
            //
            g_lstEvents.pop_front ();
        }
    }
    catch (exception &ex)
    {
        VERBOSE (MEM_ERR, 
                 TEXT("Got an STL exception while handling with event list (%S)"),
                 ex.what());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    AddEventToView(&Event);
    dwRes = UpdateMonitorData(g_hMonitorDlg);
    return dwRes;
} // AddStatusMonitorLogEvent

void
AddEventToView(
    PEVENT_ENTRY pEvent
)
/*++

Routine description:

    Add event to the list view

Arguments:
    
      pEvent - event data

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("AddEventToView"));
    ASSERTION (pEvent);

    if(!g_hListDetails)
    {
        return;
    }

    LV_ITEM lvi = {0};
    DWORD dwItem;

    lvi.pszText  = pEvent->tszTime ? pEvent->tszTime : TEXT("");
    lvi.iItem    = ListView_GetItemCount( g_hListDetails );
    lvi.iSubItem = 0;
    lvi.mask     = LVIF_TEXT | LVIF_IMAGE;
    lvi.iImage   = pEvent->eIcon;

    dwItem = ListView_InsertItem( g_hListDetails, &lvi );

    lvi.pszText  = pEvent->tszEvent ? pEvent->tszEvent : TEXT("");
    lvi.iItem    = dwItem;
    lvi.iSubItem = 1;
    lvi.mask     = LVIF_TEXT;
    ListView_SetItem( g_hListDetails, &lvi );

    ListView_EnsureVisible(g_hListDetails, dwItem, FALSE);

    if(ListView_GetItemCount(g_hListDetails) > MAX_EVENT_LIST_SIZE)
    {
        ListView_DeleteItem(g_hListDetails, 0);
    }

    //
    // Autosize the last column to get rid of unnecessary horizontal scroll bar
    //
    ListView_SetColumnWidth(g_hListDetails, 1, LVSCW_AUTOSIZE_USEHEADER); 

} // AddEventToView


DWORD
OpenFaxMonitor(VOID)
/*++

Routine description:

    Opens fax monitor dialog

Arguments:

    none

Return Value:

    Standard error code.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("OpenFaxMonitor"), dwRes);

    if(!g_hMonitorDlg)
    {
        //
        // Read 'top most' value
        //
        HKEY hKey;

        dwRes = RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, 0, KEY_READ, &hKey);
        if (ERROR_SUCCESS == dwRes) 
        {
            g_bTopMost = GetRegistryDword(hKey, REGVAL_ALWAYS_ON_TOP);
            RegCloseKey( hKey );
        }
        else
        {
            CALL_FAIL (WINDOW_ERR, TEXT ("RegOpenKeyEx"), dwRes);
        }
        //
        // Create the dialog
        //
        g_hMonitorDlg = CreateDialogParam(g_hInstance,
                                          MAKEINTRESOURCE(IDD_MONITOR),
                                          NULL, 
                                          FaxMonitorDlgProc,
                                          NULL);
        if(!g_hMonitorDlg)
        {
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("CreateDialogParam"), dwRes);
        }
    }
    //
    // Set the focus on the dialog and make it the top window
    //
    SetFocus(g_hMonitorDlg);
    SetActiveWindow(g_hMonitorDlg);
    SetWindowPos(g_hMonitorDlg, 
                 HWND_TOPMOST, 
                 0, 
                 0, 
                 0,
                 0, 
                 SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);
    if (!g_bTopMost)
    {
        SetWindowPos(g_hMonitorDlg, 
                     HWND_NOTOPMOST, 
                     0, 
                     0, 
                     0, 
                     0, 
                     SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);
    }
    return dwRes;
} // OpenFaxMonitor

void  
OnDisconnect()
/*++

Routine description:

    Abort current transmission 
    OR 
    Answer a call

Return Value:

    none

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("OnDisconnect"), dwRes);

    if(g_bAnswerNow)
    {
        //
        // The button shows 'Answer Now'
        //
        AnswerTheCall();
        return;
    }
    //
    // Else, the button shows 'Disconnect'
    //
    if(!g_dwCurrentJobID)
    {
        //
        // No job - nothing to disconnect
        //
        SetStatusMonitorDeviceState(FAX_IDLE);
        return;
    }

    DWORD dwMsgId = (FAX_SENDING == g_devState) ? IDS_ABORT_SEND_CONFIRM : IDS_ABORT_RECEIVE_CONFIRM;

    if(IDYES != FaxMessageBox(g_hMonitorDlg, dwMsgId, MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION))
    {
        return;
    }

    if(!Connect())
    {
        dwRes = GetLastError();
        CALL_FAIL (RPC_ERR, TEXT ("Connect"), dwRes);
        return;
    }

    FAX_JOB_ENTRY fje = {0};
    fje.SizeOfStruct = sizeof(FAX_JOB_ENTRY);

    if(g_hDisconnect)
    {
        EnableWindow(g_hDisconnect, FALSE);
    }

    if (!FaxSetJob (g_hFaxSvcHandle, g_dwCurrentJobID, JC_DELETE, &fje))
    {
        dwRes = GetLastError();
        CALL_FAIL (RPC_ERR, TEXT ("FaxSetJob"), dwRes);

        if(g_hDisconnect)
        {
            EnableWindow(g_hDisconnect, TRUE);
        }

        if(ERROR_ACCESS_DENIED == dwRes)
        {
            FaxMessageBox(g_hMonitorDlg, IDS_DELETE_ACCESS_DENIED, MB_OK | MB_ICONSTOP);
        }
    }

} // OnDisconnect


void  
OnClearLog()
/*++

Routine description:

    Clear the monitor event log

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("OnClearLog"));
    ASSERTION (g_hListDetails);    
    try
    {
        g_lstEvents.clear();
    }
    catch (exception &ex)
    {
        VERBOSE (MEM_ERR, 
                 TEXT("Got an STL exception while clearing the events list (%S)"),
                 ex.what());
    }
    if(!ListView_DeleteAllItems(g_hListDetails))
    {
        CALL_FAIL (WINDOW_ERR, TEXT ("ListView_DeleteAllItems"), 0);
    }
} // OnClearLog


int 
FaxMessageBox(
  HWND  hWnd,   
  DWORD dwTextID,
  UINT  uType    
)
/*++

Routine description:

  Open standard message box

Arguments:

  hWnd     - handle to owner window
  dwTextID - text resource ID in message box
  uType    - message box style

Return Value:

    MessageBox() return value

--*/
{
    int iRes;
    DBG_ENTER(TEXT("FaxMessageBox"), iRes);

    TCHAR tsCaption[MAX_PATH];
    TCHAR tsText[MAX_PATH];

    DWORD dwRes;
    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (IDS_MESSAGE_BOX_CAPTION, tsCaption)))
    {
        SetLastError (dwRes);
        iRes = 0;
        return iRes;
    }

    if (ERROR_SUCCESS != (dwRes = LoadAndFormatString (dwTextID, tsText)))
    {
        SetLastError (dwRes);
        iRes = 0;
        return iRes;
    }
    iRes = AlignedMessageBox(hWnd, tsText, tsCaption, uType);
    return iRes;
}   // FaxMessageBox
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\systray\monitor.h ===
#ifndef _INC_FAX_MONITOR_
#define _INC_FAX_MONITOR_

#include <windows.h>

//
// Fax Monitor dialog states
//
enum DeviceState {FAX_IDLE, FAX_RINGING, FAX_SENDING, FAX_RECEIVING};

//
// Status monitor log icons
//
enum eIconType
{
    LIST_IMAGE_NONE = 0,
    LIST_IMAGE_WARNING,
    LIST_IMAGE_ERROR,
    LIST_IMAGE_SUCCESS
};

//
// monitor.cpp
//

DWORD 
LoadAndFormatString (
    DWORD     dwStringResourceId,
    LPTSTR    lptstrFormattedString,
    LPCTSTR   lpctstrAdditionalParam = NULL
);
//
// Add string to the monitor dialog's events log
//
DWORD 
AddStatusMonitorLogEvent (
    eIconType eIcon,
    DWORD     dwStringResourceId,
    LPCTSTR   lpctstrAdditionalParam = NULL,
    LPTSTR    lptstrFormattedEvent = NULL
);

DWORD 
AddStatusMonitorLogEvent (
    eIconType eIcon,
    LPCTSTR    lpctstrString
);

void  
FreeMonitorDialogData (BOOL bShutdown = FALSE);

//
// Open the monitor dialog
//
DWORD OpenFaxMonitor(VOID);

DWORD UpdateMonitorData(HWND hDlg);

int   FaxMessageBox(HWND hWnd, DWORD dwTextID, UINT uType);

//
// Change state of the monitor dialog
//
void SetStatusMonitorDeviceState(DeviceState devState);


//
// fxsst.cpp
//

//
// configuration structure
//
struct CONFIG_OPTIONS 
{
    DWORD   dwMonitorDeviceId;      // Device ID to monitor
    BOOL    bSend;                  // Is monitored device configured to send faxes
    BOOL    bReceive;               // Is monitored device configured to receive faxes
    DWORD   dwManualAnswerDeviceId; // Manual answer device ID
    DWORD   dwAccessRights;         // User access rights
    DWORD   bNotifyProgress;        // Show notification icon during send/receive
    DWORD   bNotifyInCompletion;    // Show notification icon and baloons upon incoming job completion
    DWORD   bNotifyOutCompletion;   // Show notification icon and baloons upon outgoing job completion
    DWORD   bMonitorOnSend;         // Open monitor dialog upon outgoing job start
    DWORD   bMonitorOnReceive;      // Open monitor dialog upon incoming job start
    DWORD   bSoundOnRing;           // Play sound when manual answer line is ringing
    DWORD   bSoundOnReceive;        // Play sound when fax is received
    DWORD   bSoundOnSent;           // Play sound when fax is sent
    DWORD   bSoundOnError;          // Play sound when upon error
};

//
// connect to the fax server
//
BOOL Connect();

//
// Answer the incoming call
//
VOID AnswerTheCall();
DWORD CheckAnswerNowCapability (BOOL bForceReconnect, LPDWORD lpdwDeviceId = NULL);

//
// Abort current transmission
//
void OnDisconnect();

//
// Window handle to the status monitor dialog
//
extern HWND   g_hMonitorDlg;  

extern DeviceState  g_devState;

extern TCHAR        g_tszLastEvent[];


#endif // _INC_FAX_MONITOR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\service\winfax\winfax.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	winfax.cpp

Abstract:

	A wrapper DLL that provides old WinFax.dll support from the new (private) DLL

Author:

	Eran Yariv (EranY)	Jun, 2000

Revision History:

Remarks:

    FAXAPI is defined in the sources file as the name of the new (private) DLL to actualy use.

--*/

#include <winfax.h>
#include <DebugEx.h>
#include <faxutil.h>

HMODULE                         g_hFaxApi                       = NULL;

PFAXABORT                       g_pFaxAbort                     = NULL;
PFAXACCESSCHECK                 g_pFaxAccessCheck               = NULL;
PFAXCLOSE                       g_pFaxClose                     = NULL;
PFAXCOMPLETEJOBPARAMSA          g_pFaxCompleteJobParamsA        = NULL;
PFAXCOMPLETEJOBPARAMSW          g_pFaxCompleteJobParamsW        = NULL;
PFAXCONNECTFAXSERVERA           g_pFaxConnectFaxServerA         = NULL;
PFAXCONNECTFAXSERVERW           g_pFaxConnectFaxServerW         = NULL;
PFAXENABLEROUTINGMETHODA        g_pFaxEnableRoutingMethodA      = NULL;
PFAXENABLEROUTINGMETHODW        g_pFaxEnableRoutingMethodW      = NULL;
PFAXENUMGLOBALROUTINGINFOA      g_pFaxEnumGlobalRoutingInfoA    = NULL;
PFAXENUMGLOBALROUTINGINFOW      g_pFaxEnumGlobalRoutingInfoW    = NULL;
PFAXENUMJOBSA                   g_pFaxEnumJobsA                 = NULL;
PFAXENUMJOBSW                   g_pFaxEnumJobsW                 = NULL;
PFAXENUMPORTSA                  g_pFaxEnumPortsA                = NULL;
PFAXENUMPORTSW                  g_pFaxEnumPortsW                = NULL;
PFAXENUMROUTINGMETHODSA         g_pFaxEnumRoutingMethodsA       = NULL;
PFAXENUMROUTINGMETHODSW         g_pFaxEnumRoutingMethodsW       = NULL;
PFAXFREEBUFFER                  g_pFaxFreeBuffer                = NULL;
PFAXGETCONFIGURATIONA           g_pFaxGetConfigurationA         = NULL;
PFAXGETCONFIGURATIONW           g_pFaxGetConfigurationW         = NULL;
PFAXGETDEVICESTATUSA            g_pFaxGetDeviceStatusA          = NULL;
PFAXGETDEVICESTATUSW            g_pFaxGetDeviceStatusW          = NULL;
PFAXGETJOBA                     g_pFaxGetJobA                   = NULL;
PFAXGETJOBW                     g_pFaxGetJobW                   = NULL;
PFAXGETLOGGINGCATEGORIESA       g_pFaxGetLoggingCategoriesA     = NULL;
PFAXGETLOGGINGCATEGORIESW       g_pFaxGetLoggingCategoriesW     = NULL;
PFAXGETPAGEDATA                 g_pFaxGetPageData               = NULL;
PFAXGETPORTA                    g_pFaxGetPortA                  = NULL;
PFAXGETPORTW                    g_pFaxGetPortW                  = NULL;
PFAXGETROUTINGINFOA             g_pFaxGetRoutingInfoA           = NULL;
PFAXGETROUTINGINFOW             g_pFaxGetRoutingInfoW           = NULL;
PFAXINITIALIZEEVENTQUEUE        g_pFaxInitializeEventQueue      = NULL;
PFAXOPENPORT                    g_pFaxOpenPort                  = NULL;
PFAXPRINTCOVERPAGEA             g_pFaxPrintCoverPageA           = NULL;
PFAXPRINTCOVERPAGEW             g_pFaxPrintCoverPageW           = NULL;
PFAXREGISTERSERVICEPROVIDERW    g_pFaxRegisterServiceProviderW  = NULL;
PFAXREGISTERROUTINGEXTENSIONW   g_pFaxRegisterRoutingExtensionW = NULL;
PFAXSENDDOCUMENTA               g_pFaxSendDocumentA             = NULL;
PFAXSENDDOCUMENTW               g_pFaxSendDocumentW             = NULL;
PFAXSENDDOCUMENTFORBROADCASTA   g_pFaxSendDocumentForBroadcastA = NULL;
PFAXSENDDOCUMENTFORBROADCASTW   g_pFaxSendDocumentForBroadcastW = NULL;
PFAXSETCONFIGURATIONA           g_pFaxSetConfigurationA         = NULL;
PFAXSETCONFIGURATIONW           g_pFaxSetConfigurationW         = NULL;
PFAXSETGLOBALROUTINGINFOA       g_pFaxSetGlobalRoutingInfoA     = NULL;
PFAXSETGLOBALROUTINGINFOW       g_pFaxSetGlobalRoutingInfoW     = NULL;
PFAXSETJOBA                     g_pFaxSetJobA                   = NULL;
PFAXSETJOBW                     g_pFaxSetJobW                   = NULL;
PFAXSETLOGGINGCATEGORIESA       g_pFaxSetLoggingCategoriesA     = NULL;
PFAXSETLOGGINGCATEGORIESW       g_pFaxSetLoggingCategoriesW     = NULL;
PFAXSETPORTA                    g_pFaxSetPortA                  = NULL;
PFAXSETPORTW                    g_pFaxSetPortW                  = NULL;
PFAXSETROUTINGINFOA             g_pFaxSetRoutingInfoA           = NULL;
PFAXSETROUTINGINFOW             g_pFaxSetRoutingInfoW           = NULL;
PFAXSTARTPRINTJOBA              g_pFaxStartPrintJobA            = NULL;
PFAXSTARTPRINTJOBW              g_pFaxStartPrintJobW            = NULL;


static 
FARPROC 
LinkExport (
    LPCSTR lpcstrFuncName
)
/*++

Routine name : LinkExport

Routine description:

	Performs a GetProcAddress with debug output

Author:

	Eran Yariv (EranY),	Jun, 2000

Arguments:

	lpcstrFuncName                [in]     - Function to link to

Return Value:

    Same as return value of GetProcAddress

--*/
{
    DBG_ENTER (TEXT("LinkExport"), TEXT("Func = %S"), lpcstrFuncName);
    ASSERTION (g_hFaxApi);

    FARPROC fp = GetProcAddress (g_hFaxApi, lpcstrFuncName);
    if (!fp)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("GetProcAddress"), GetLastError ());
    }
    return fp;
}

static 
BOOL 
DynamicLoadFaxApi ()
/*++

Routine name : DynamicLoadFaxApi

Routine description:

	Loads the new (private) DLL and attempt to link to all legacy functions

Author:

	Eran Yariv (EranY),	Jun, 2000

Arguments:


Return Value:

    TRUE on success, FALSE otherwise (set last error code)

--*/
{
    BOOL bRes = FALSE;
    DBG_ENTER (TEXT("DynamicLoadFaxApi"), bRes);

    if (g_hFaxApi)
    {
        //
        // Already loaded
        //
        bRes = TRUE;
        return bRes;
    }
    g_hFaxApi = LoadLibrary (FAXAPI);
    if (!g_hFaxApi)
    {
        DWORD dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadLibrary"), dwRes);
        return bRes;
    }
    if (!(g_pFaxAbort                       = (PFAXABORT) LinkExport ("FaxAbort")) ||
        !(g_pFaxAccessCheck                 = (PFAXACCESSCHECK) LinkExport ("FaxAccessCheck")) ||
        !(g_pFaxClose                       = (PFAXCLOSE) LinkExport ("FaxClose")) ||
        !(g_pFaxCompleteJobParamsA          = (PFAXCOMPLETEJOBPARAMSA) LinkExport ("FaxCompleteJobParamsA")) ||
        !(g_pFaxCompleteJobParamsW          = (PFAXCOMPLETEJOBPARAMSW) LinkExport ("FaxCompleteJobParamsW")) ||
        !(g_pFaxConnectFaxServerA           = (PFAXCONNECTFAXSERVERA) LinkExport ("FaxConnectFaxServerA")) ||
        !(g_pFaxConnectFaxServerW           = (PFAXCONNECTFAXSERVERW) LinkExport ("FaxConnectFaxServerW")) ||
        !(g_pFaxEnableRoutingMethodA        = (PFAXENABLEROUTINGMETHODA) LinkExport ("FaxEnableRoutingMethodA")) ||
        !(g_pFaxEnableRoutingMethodW        = (PFAXENABLEROUTINGMETHODW) LinkExport ("FaxEnableRoutingMethodW")) ||
        !(g_pFaxEnumGlobalRoutingInfoA      = (PFAXENUMGLOBALROUTINGINFOA) LinkExport ("FaxEnumGlobalRoutingInfoA")) ||
        !(g_pFaxEnumGlobalRoutingInfoW      = (PFAXENUMGLOBALROUTINGINFOW) LinkExport ("FaxEnumGlobalRoutingInfoW")) ||
        !(g_pFaxEnumJobsA                   = (PFAXENUMJOBSA) LinkExport ("FaxEnumJobsA")) ||
        !(g_pFaxEnumJobsW                   = (PFAXENUMJOBSW) LinkExport ("FaxEnumJobsW")) ||
        !(g_pFaxEnumPortsA                  = (PFAXENUMPORTSA) LinkExport ("FaxEnumPortsA")) ||
        !(g_pFaxEnumPortsW                  = (PFAXENUMPORTSW) LinkExport ("FaxEnumPortsW")) ||
        !(g_pFaxEnumRoutingMethodsA         = (PFAXENUMROUTINGMETHODSA) LinkExport ("FaxEnumRoutingMethodsA")) ||
        !(g_pFaxEnumRoutingMethodsW         = (PFAXENUMROUTINGMETHODSW) LinkExport ("FaxEnumRoutingMethodsW")) ||
        !(g_pFaxFreeBuffer                  = (PFAXFREEBUFFER) LinkExport ("FaxFreeBuffer")) ||
        !(g_pFaxGetConfigurationA           = (PFAXGETCONFIGURATIONA) LinkExport ("FaxGetConfigurationA")) ||
        !(g_pFaxGetConfigurationW           = (PFAXGETCONFIGURATIONW) LinkExport ("FaxGetConfigurationW")) ||
        !(g_pFaxGetDeviceStatusA            = (PFAXGETDEVICESTATUSA) LinkExport ("FaxGetDeviceStatusA")) ||
        !(g_pFaxGetDeviceStatusW            = (PFAXGETDEVICESTATUSW) LinkExport ("FaxGetDeviceStatusW")) ||
        !(g_pFaxGetJobA                     = (PFAXGETJOBA) LinkExport ("FaxGetJobA")) ||
        !(g_pFaxGetJobW                     = (PFAXGETJOBW) LinkExport ("FaxGetJobW")) ||
        !(g_pFaxGetLoggingCategoriesA       = (PFAXGETLOGGINGCATEGORIESA) LinkExport ("FaxGetLoggingCategoriesA")) ||
        !(g_pFaxGetLoggingCategoriesW       = (PFAXGETLOGGINGCATEGORIESW) LinkExport ("FaxGetLoggingCategoriesW")) ||
        !(g_pFaxGetPageData                 = (PFAXGETPAGEDATA) LinkExport ("FaxGetPageData")) ||
        !(g_pFaxGetPortA                    = (PFAXGETPORTA) LinkExport ("FaxGetPortA")) ||
        !(g_pFaxGetPortW                    = (PFAXGETPORTW) LinkExport ("FaxGetPortW")) ||
        !(g_pFaxGetRoutingInfoA             = (PFAXGETROUTINGINFOA) LinkExport ("FaxGetRoutingInfoA")) ||
        !(g_pFaxGetRoutingInfoW             = (PFAXGETROUTINGINFOW) LinkExport ("FaxGetRoutingInfoW")) ||
        !(g_pFaxInitializeEventQueue        = (PFAXINITIALIZEEVENTQUEUE) LinkExport ("FaxInitializeEventQueue")) ||
        !(g_pFaxOpenPort                    = (PFAXOPENPORT) LinkExport ("FaxOpenPort")) ||
        !(g_pFaxPrintCoverPageA             = (PFAXPRINTCOVERPAGEA) LinkExport ("FaxPrintCoverPageA")) ||
        !(g_pFaxPrintCoverPageW             = (PFAXPRINTCOVERPAGEW) LinkExport ("FaxPrintCoverPageW")) ||
        !(g_pFaxRegisterServiceProviderW    = (PFAXREGISTERSERVICEPROVIDERW) LinkExport ("FaxRegisterServiceProviderW")) ||
        !(g_pFaxRegisterRoutingExtensionW   = (PFAXREGISTERROUTINGEXTENSIONW) LinkExport ("FaxRegisterRoutingExtensionW")) ||
        !(g_pFaxSendDocumentA               = (PFAXSENDDOCUMENTA) LinkExport ("FaxSendDocumentA")) ||
        !(g_pFaxSendDocumentW               = (PFAXSENDDOCUMENTW) LinkExport ("FaxSendDocumentW")) ||
        !(g_pFaxSendDocumentForBroadcastA   = (PFAXSENDDOCUMENTFORBROADCASTA) LinkExport ("FaxSendDocumentForBroadcastA")) ||
        !(g_pFaxSendDocumentForBroadcastW   = (PFAXSENDDOCUMENTFORBROADCASTW) LinkExport ("FaxSendDocumentForBroadcastW")) ||
        !(g_pFaxSetConfigurationA           = (PFAXSETCONFIGURATIONA) LinkExport ("FaxSetConfigurationA")) ||
        !(g_pFaxSetConfigurationW           = (PFAXSETCONFIGURATIONW) LinkExport ("FaxSetConfigurationW")) ||
        !(g_pFaxSetGlobalRoutingInfoA       = (PFAXSETGLOBALROUTINGINFOA) LinkExport ("FaxSetGlobalRoutingInfoA")) ||
        !(g_pFaxSetGlobalRoutingInfoW       = (PFAXSETGLOBALROUTINGINFOW) LinkExport ("FaxSetGlobalRoutingInfoW")) ||
        !(g_pFaxSetJobA                     = (PFAXSETJOBA) LinkExport ("FaxSetJobA")) ||
        !(g_pFaxSetJobW                     = (PFAXSETJOBW) LinkExport ("FaxSetJobW")) ||
        !(g_pFaxSetLoggingCategoriesA       = (PFAXSETLOGGINGCATEGORIESA) LinkExport ("FaxSetLoggingCategoriesA")) ||
        !(g_pFaxSetLoggingCategoriesW       = (PFAXSETLOGGINGCATEGORIESW) LinkExport ("FaxSetLoggingCategoriesW")) ||
        !(g_pFaxSetPortA                    = (PFAXSETPORTA) LinkExport ("FaxSetPortA")) ||
        !(g_pFaxSetPortW                    = (PFAXSETPORTW) LinkExport ("FaxSetPortW")) ||
        !(g_pFaxSetRoutingInfoA             = (PFAXSETROUTINGINFOA) LinkExport ("FaxSetRoutingInfoA")) ||
        !(g_pFaxSetRoutingInfoW             = (PFAXSETROUTINGINFOW) LinkExport ("FaxSetRoutingInfoW")) ||
        !(g_pFaxStartPrintJobA              = (PFAXSTARTPRINTJOBA) LinkExport ("FaxStartPrintJobA")) ||
        !(g_pFaxStartPrintJobW              = (PFAXSTARTPRINTJOBW) LinkExport ("FaxStartPrintJobW"))
       )
    {
        //
        // Debug output is done in LinkExport()
        //
        FreeLibrary (g_hFaxApi);
        g_hFaxApi = NULL;
        return bRes;
    }                     
    bRes = TRUE;
    return bRes;        
}        

extern "C"
DWORD
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvContext
)
{
    BOOL bRes = TRUE;
    DBG_ENTER (TEXT("DllMain"), bRes, TEXT("Reason = %d"), dwReason);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hInstance );
            break;

        case DLL_PROCESS_DETACH:
            if (g_hFaxApi)
            {
                FreeLibrary (g_hFaxApi);
            }
            break;
    }
    return bRes;
}

/****************************************************************************

               L e g a c y   f u n c t i o n s   w r a p p e r s

****************************************************************************/

extern "C"
BOOL 
WINAPI WinFaxAbort(
  HANDLE    FaxHandle,      // handle to the fax server
  DWORD     JobId           // identifier of fax job to terminate
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxAbort (FaxHandle, JobId);
}

extern "C"
BOOL 
WINAPI WinFaxAccessCheck(
  HANDLE    FaxHandle,      // handle to the fax server
  DWORD     AccessMask      // set of access level bit flags
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxAccessCheck (FaxHandle, AccessMask);
}

extern "C"
BOOL 
WINAPI WinFaxClose(
  HANDLE FaxHandle  // fax handle to close
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxClose (FaxHandle);
}

extern "C"
BOOL 
WINAPI WinFaxCompleteJobParamsA(
  PFAX_JOB_PARAMA *JobParams,          // pointer to 
                                       //   job information structure
  PFAX_COVERPAGE_INFOA *CoverpageInfo  // pointer to 
                                       //   cover page structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxCompleteJobParamsA (JobParams, CoverpageInfo);
}


extern "C"
BOOL 
WINAPI WinFaxCompleteJobParamsW(
  PFAX_JOB_PARAMW *JobParams,          // pointer to 
                                       //   job information structure
  PFAX_COVERPAGE_INFOW *CoverpageInfo  // pointer to 
                                       //   cover page structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxCompleteJobParamsW (JobParams, CoverpageInfo);
}


extern "C"
BOOL 
WINAPI WinFaxConnectFaxServerA(
  LPCSTR MachineName OPTIONAL,   // fax server name
  LPHANDLE FaxHandle             // handle to the fax server
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    if (IsLocalMachineNameA (MachineName))
    {
        //
        // Windows 2000 supported only local fax connection.
        // Prevent apps that use the Windows 2000 API from connection to remote fax servers.
        //
        return g_pFaxConnectFaxServerA (MachineName, FaxHandle);
    }
    else
    {
        DBG_ENTER (TEXT("WinFaxConnectFaxServerA"), TEXT("MachineName = %s"), MachineName);
        return ERROR_ACCESS_DENIED;
    }
}


extern "C"
BOOL 
WINAPI WinFaxConnectFaxServerW(
  LPCWSTR MachineName OPTIONAL,  // fax server name
  LPHANDLE FaxHandle             // handle to the fax server
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }

    if (IsLocalMachineNameW (MachineName))
    {
        //
        // Windows 2000 supported only local fax connection.
        // Prevent apps that use the Windows 2000 API from connection to remote fax servers.
        //
        return g_pFaxConnectFaxServerW (MachineName, FaxHandle);
    }
    else
    {
        DBG_ENTER (TEXT("WinFaxConnectFaxServerA"), TEXT("MachineName = %s"), MachineName);
        return ERROR_ACCESS_DENIED;
    }
}


extern "C"
BOOL 
WINAPI WinFaxEnableRoutingMethodA(
  HANDLE FaxPortHandle,  // fax port handle
  LPCSTR RoutingGuid,    // GUID that identifies the fax routing method
  BOOL Enabled           // fax routing method enable/disable flag
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxEnableRoutingMethodA (FaxPortHandle, RoutingGuid, Enabled);
}


extern "C"
BOOL 
WINAPI WinFaxEnableRoutingMethodW(
  HANDLE FaxPortHandle,  // fax port handle
  LPCWSTR RoutingGuid,   // GUID that identifies the fax routing method
  BOOL Enabled           // fax routing method enable/disable flag
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxEnableRoutingMethodW (FaxPortHandle, RoutingGuid, Enabled);
}


extern "C"
BOOL 
WINAPI WinFaxEnumGlobalRoutingInfoA(
  HANDLE FaxHandle,       //handle to the fax server
  PFAX_GLOBAL_ROUTING_INFOA *RoutingInfo, 
                          //buffer to receive global routing structures
  LPDWORD MethodsReturned //number of global routing structures returned
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxEnumGlobalRoutingInfoA (FaxHandle, RoutingInfo, MethodsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumGlobalRoutingInfoW(
  HANDLE FaxHandle,       //handle to the fax server
  PFAX_GLOBAL_ROUTING_INFOW *RoutingInfo, 
                          //buffer to receive global routing structures
  LPDWORD MethodsReturned //number of global routing structures returned
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxEnumGlobalRoutingInfoW (FaxHandle, RoutingInfo, MethodsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumJobsA(
  HANDLE FaxHandle,          // handle to the fax server
  PFAX_JOB_ENTRYA *JobEntry, // buffer to receive array of job data
  LPDWORD JobsReturned       // number of fax job structures returned
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxEnumJobsA (FaxHandle, JobEntry, JobsReturned);
}



extern "C"
BOOL 
WINAPI WinFaxEnumJobsW(
  HANDLE FaxHandle,          // handle to the fax server
  PFAX_JOB_ENTRYW *JobEntry, // buffer to receive array of job data
  LPDWORD JobsReturned       // number of fax job structures returned
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxEnumJobsW (FaxHandle, JobEntry, JobsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumPortsA(
  HANDLE FaxHandle,          // handle to the fax server
  PFAX_PORT_INFOA *PortInfo, // buffer to receive array of port data
  LPDWORD PortsReturned      // number of fax port structures returned
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxEnumPortsA (FaxHandle, PortInfo, PortsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumPortsW(
  HANDLE FaxHandle,          // handle to the fax server
  PFAX_PORT_INFOW *PortInfo, // buffer to receive array of port data
  LPDWORD PortsReturned      // number of fax port structures returned
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxEnumPortsW (FaxHandle, PortInfo, PortsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumRoutingMethodsA(
  HANDLE FaxPortHandle,    // fax port handle
  PFAX_ROUTING_METHODA *RoutingMethod, 
                           // buffer to receive routing method data
  LPDWORD MethodsReturned  // number of routing method structures returned
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxEnumRoutingMethodsA (FaxPortHandle, RoutingMethod, MethodsReturned);
}


extern "C"
BOOL 
WINAPI WinFaxEnumRoutingMethodsW(
  HANDLE FaxPortHandle,    // fax port handle
  PFAX_ROUTING_METHODW *RoutingMethod, 
                           // buffer to receive routing method data
  LPDWORD MethodsReturned  // number of routing method structures returned
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxEnumRoutingMethodsW (FaxPortHandle, RoutingMethod, MethodsReturned);
}


extern "C"
VOID 
WINAPI WinFaxFreeBuffer(
  LPVOID Buffer  // pointer to buffer to free
)
{
    if (!DynamicLoadFaxApi())
    {
        return;
    }
    return g_pFaxFreeBuffer (Buffer);
}


extern "C"
BOOL 
WINAPI WinFaxGetConfigurationA(
  HANDLE FaxHandle,              // handle to the fax server
  PFAX_CONFIGURATIONA *FaxConfig  // structure to receive configuration data
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetConfigurationA (FaxHandle, FaxConfig);
}


extern "C"
BOOL 
WINAPI WinFaxGetConfigurationW(
  HANDLE FaxHandle,              // handle to the fax server
  PFAX_CONFIGURATIONW *FaxConfig  // structure to receive configuration data
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetConfigurationW (FaxHandle, FaxConfig);
}


extern "C"
BOOL 
WINAPI WinFaxGetDeviceStatusA(
  HANDLE FaxPortHandle,  // fax port handle
  PFAX_DEVICE_STATUSA *DeviceStatus
                         // structure to receive fax device data
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetDeviceStatusA (FaxPortHandle, DeviceStatus);
}


extern "C"
BOOL 
WINAPI WinFaxGetDeviceStatusW(
  HANDLE FaxPortHandle,  // fax port handle
  PFAX_DEVICE_STATUSW *DeviceStatus
                         // structure to receive fax device data
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetDeviceStatusW (FaxPortHandle, DeviceStatus);
}


extern "C"
BOOL 
WINAPI WinFaxGetJobA(
  HANDLE FaxHandle,         // handle to the fax server
  DWORD JobId,              // fax job identifier
  PFAX_JOB_ENTRYA *JobEntry  // pointer to job data structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetJobA (FaxHandle, JobId, JobEntry);
}


extern "C"
BOOL 
WINAPI WinFaxGetJobW(
  HANDLE FaxHandle,         // handle to the fax server
  DWORD JobId,              // fax job identifier
  PFAX_JOB_ENTRYW *JobEntry  // pointer to job data structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetJobW (FaxHandle, JobId, JobEntry);
}


extern "C"
BOOL 
WINAPI WinFaxGetLoggingCategoriesA(
  HANDLE FaxHandle,              // handle to the fax server
  PFAX_LOG_CATEGORYA *Categories, // buffer to receive category data
  LPDWORD NumberCategories       // number of logging categories returned
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetLoggingCategoriesA (FaxHandle, Categories, NumberCategories);
}


extern "C"
BOOL 
WINAPI WinFaxGetLoggingCategoriesW(
  HANDLE FaxHandle,              // handle to the fax server
  PFAX_LOG_CATEGORYW *Categories, // buffer to receive category data
  LPDWORD NumberCategories       // number of logging categories returned
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetLoggingCategoriesW (FaxHandle, Categories, NumberCategories);
}


extern "C"
BOOL 
WINAPI WinFaxGetPageData(
  HANDLE FaxHandle,    // handle to the fax server
  DWORD JobId,         // fax job identifier
  LPBYTE *Buffer,      // buffer to receive first page of data
  LPDWORD BufferSize,  // size of buffer, in bytes
  LPDWORD ImageWidth,  // page image width, in pixels
  LPDWORD ImageHeight  // page image height, in pixels
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetPageData (FaxHandle, JobId, Buffer, BufferSize, ImageWidth, ImageHeight);
}


extern "C"
BOOL 
WINAPI WinFaxGetPortA(
  HANDLE FaxPortHandle,     // fax port handle
  PFAX_PORT_INFOA *PortInfo  // structure to receive port data
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetPortA (FaxPortHandle, PortInfo);
}


extern "C"
BOOL 
WINAPI WinFaxGetPortW(
  HANDLE FaxPortHandle,     // fax port handle
  PFAX_PORT_INFOW *PortInfo  // structure to receive port data
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetPortW (FaxPortHandle, PortInfo);
}


extern "C"
BOOL 
WINAPI WinFaxGetRoutingInfoA(
  HANDLE FaxPortHandle,  // fax port handle
  LPCSTR RoutingGuid,   // GUID that identifies fax routing method
  LPBYTE *RoutingInfoBuffer, 
                         // buffer to receive routing method data
  LPDWORD RoutingInfoBufferSize 
                         // size of buffer, in bytes
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetRoutingInfoA (FaxPortHandle, RoutingGuid, RoutingInfoBuffer, RoutingInfoBufferSize);
}


extern "C"
BOOL 
WINAPI WinFaxGetRoutingInfoW(
  HANDLE FaxPortHandle,  // fax port handle
  LPCWSTR RoutingGuid,   // GUID that identifies fax routing method
  LPBYTE *RoutingInfoBuffer, 
                         // buffer to receive routing method data
  LPDWORD RoutingInfoBufferSize 
                         // size of buffer, in bytes
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxGetRoutingInfoW (FaxPortHandle, RoutingGuid, RoutingInfoBuffer, RoutingInfoBufferSize);
}


extern "C"
BOOL 
WINAPI WinFaxInitializeEventQueue(
  HANDLE FaxHandle,        // handle to the fax server
  HANDLE CompletionPort,   // handle to an I/O completion port
  ULONG_PTR CompletionKey, // completion key value
  HWND hWnd,               // handle to the notification window
  UINT MessageStart        // window message base event number
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxInitializeEventQueue (FaxHandle, CompletionPort, CompletionKey, hWnd, MessageStart);
}


extern "C"
BOOL 
WINAPI WinFaxOpenPort(
  HANDLE FaxHandle,       // handle to the fax server
  DWORD DeviceId,         // receiving device identifier
  DWORD Flags,            // set of port access level bit flags
  LPHANDLE FaxPortHandle  // fax port handle
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxOpenPort (FaxHandle, DeviceId, Flags, FaxPortHandle);
}


extern "C"
BOOL 
WINAPI WinFaxPrintCoverPageA(
  CONST FAX_CONTEXT_INFOA *FaxContextInfo,
                         // pointer to device context structure
  CONST FAX_COVERPAGE_INFOA *CoverPageInfo 
                         // pointer to local cover page structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxPrintCoverPageA (FaxContextInfo, CoverPageInfo);
}


extern "C"
BOOL 
WINAPI WinFaxPrintCoverPageW(
  CONST FAX_CONTEXT_INFOW *FaxContextInfo,
                         // pointer to device context structure
  CONST FAX_COVERPAGE_INFOW *CoverPageInfo 
                         // pointer to local cover page structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxPrintCoverPageW (FaxContextInfo, CoverPageInfo);
}


extern "C"
BOOL 
WINAPI WinFaxRegisterServiceProviderW(
  LPCWSTR DeviceProvider,  // fax service provider DLL name
  LPCWSTR FriendlyName,    // fax service provider user-friendly name
  LPCWSTR ImageName,       // path to fax service provider DLL
  LPCWSTR TspName          // telephony service provider name
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxRegisterServiceProviderW (DeviceProvider, FriendlyName, ImageName, TspName);
}


extern "C"
BOOL 
WINAPI WinFaxRegisterRoutingExtensionW(
  HANDLE FaxHandle,       // handle to the fax server
  LPCWSTR ExtensionName,  // fax routing extension DLL name
  LPCWSTR FriendlyName,   // fax routing extension user-friendly name
  LPCWSTR ImageName,      // path to fax routing extension DLL
  PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack, // pointer to fax 
                          // routing installation callback function
  LPVOID Context          // pointer to context information
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxRegisterRoutingExtensionW (FaxHandle, ExtensionName, FriendlyName, ImageName, CallBack, Context);
}


extern "C"
BOOL 
WINAPI WinFaxSendDocumentA(
  HANDLE FaxHandle,          // handle to the fax server
  LPCSTR FileName,          // file with data to transmit
  PFAX_JOB_PARAMA JobParams,  // pointer to job information structure
  CONST FAX_COVERPAGE_INFOA *CoverpageInfo OPTIONAL, 
                             // pointer to local cover page structure
  LPDWORD FaxJobId           // fax job identifier
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSendDocumentA (FaxHandle, FileName, JobParams, CoverpageInfo, FaxJobId);
}


extern "C"
BOOL 
WINAPI WinFaxSendDocumentW(
  HANDLE FaxHandle,          // handle to the fax server
  LPCWSTR FileName,          // file with data to transmit
  PFAX_JOB_PARAMW JobParams,  // pointer to job information structure
  CONST FAX_COVERPAGE_INFOW *CoverpageInfo OPTIONAL, 
                             // pointer to local cover page structure
  LPDWORD FaxJobId           // fax job identifier
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSendDocumentW (FaxHandle, FileName, JobParams, CoverpageInfo, FaxJobId);
}


extern "C"
BOOL 
WINAPI WinFaxSendDocumentForBroadcastA(
  HANDLE FaxHandle,  // handle to the fax server
  LPCSTR FileName,  // fax document file name
  LPDWORD FaxJobId,  // fax job identifier
  PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback, 
                     // pointer to fax recipient callback function
  LPVOID Context     // pointer to context information
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSendDocumentForBroadcastA (FaxHandle, FileName, FaxJobId, FaxRecipientCallback, Context);
}


extern "C"
BOOL 
WINAPI WinFaxSendDocumentForBroadcastW(
  HANDLE FaxHandle,  // handle to the fax server
  LPCWSTR FileName,  // fax document file name
  LPDWORD FaxJobId,  // fax job identifier
  PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback, 
                     // pointer to fax recipient callback function
  LPVOID Context     // pointer to context information
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSendDocumentForBroadcastW (FaxHandle, FileName, FaxJobId, FaxRecipientCallback, Context);
}


extern "C"
BOOL 
WINAPI WinFaxSetConfigurationA(
  HANDLE FaxHandle,                   // handle to the fax server
  CONST FAX_CONFIGURATIONA *FaxConfig  // new configuration data
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetConfigurationA (FaxHandle, FaxConfig);
}


extern "C"
BOOL 
WINAPI WinFaxSetConfigurationW(
  HANDLE FaxHandle,                   // handle to the fax server
  CONST FAX_CONFIGURATIONW *FaxConfig  // new configuration data
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetConfigurationW (FaxHandle, FaxConfig);
}


extern "C"
BOOL 
WINAPI WinFaxSetGlobalRoutingInfoA(
  HANDLE FaxHandle, //handle to the fax server
  CONST FAX_GLOBAL_ROUTING_INFOA *RoutingInfo 
                    //pointer to global routing information structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetGlobalRoutingInfoA (FaxHandle, RoutingInfo);
}


extern "C"
BOOL 
WINAPI WinFaxSetGlobalRoutingInfoW(
  HANDLE FaxHandle, //handle to the fax server
  CONST FAX_GLOBAL_ROUTING_INFOW *RoutingInfo 
                    //pointer to global routing information structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetGlobalRoutingInfoW (FaxHandle, RoutingInfo);
}


extern "C"
BOOL 
WINAPI WinFaxSetJobA(
  HANDLE FaxHandle,        // handle to the fax server
  DWORD JobId,             // fax job identifier
  DWORD Command,           // job command value
  CONST FAX_JOB_ENTRYA *JobEntry 
                           // pointer to job information structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetJobA (FaxHandle, JobId, Command, JobEntry);
}


extern "C"
BOOL 
WINAPI WinFaxSetJobW(
  HANDLE FaxHandle,        // handle to the fax server
  DWORD JobId,             // fax job identifier
  DWORD Command,           // job command value
  CONST FAX_JOB_ENTRYW *JobEntry 
                           // pointer to job information structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetJobW (FaxHandle, JobId, Command, JobEntry);
}


extern "C"
BOOL 
WINAPI WinFaxSetLoggingCategoriesA(
  HANDLE FaxHandle,              // handle to the fax server
  CONST FAX_LOG_CATEGORYA *Categories, 
                                 // new logging categories data
  DWORD NumberCategories         // number of category structures
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetLoggingCategoriesA (FaxHandle, Categories, NumberCategories);
}


extern "C"
BOOL 
WINAPI WinFaxSetLoggingCategoriesW(
  HANDLE FaxHandle,              // handle to the fax server
  CONST FAX_LOG_CATEGORYW *Categories, 
                                 // new logging categories data
  DWORD NumberCategories         // number of category structures
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetLoggingCategoriesW (FaxHandle, Categories, NumberCategories);
}


extern "C"
BOOL 
WINAPI WinFaxSetPortA(
  HANDLE FaxPortHandle,          // fax port handle
  CONST FAX_PORT_INFOA *PortInfo  // new port configuration data
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetPortA (FaxPortHandle, PortInfo);
}


extern "C"
BOOL 
WINAPI WinFaxSetPortW(
  HANDLE FaxPortHandle,          // fax port handle
  CONST FAX_PORT_INFOW *PortInfo  // new port configuration data
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetPortW (FaxPortHandle, PortInfo);
}


extern "C"
BOOL 
WINAPI WinFaxSetRoutingInfoA(
  HANDLE FaxPortHandle,  // fax port handle
  LPCSTR RoutingGuid,   // GUID that identifies fax routing method
  CONST BYTE *RoutingInfoBuffer, 
                         // buffer with routing method data
  DWORD RoutingInfoBufferSize 
                         // size of buffer, in bytes
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetRoutingInfoA (FaxPortHandle, RoutingGuid, RoutingInfoBuffer, RoutingInfoBufferSize);
}


extern "C"
BOOL 
WINAPI WinFaxSetRoutingInfoW(
  HANDLE FaxPortHandle,  // fax port handle
  LPCWSTR RoutingGuid,   // GUID that identifies fax routing method
  CONST BYTE *RoutingInfoBuffer, 
                         // buffer with routing method data
  DWORD RoutingInfoBufferSize 
                         // size of buffer, in bytes
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxSetRoutingInfoW (FaxPortHandle, RoutingGuid, RoutingInfoBuffer, RoutingInfoBufferSize);
}


extern "C"
BOOL 
WINAPI WinFaxStartPrintJobA(
  LPCSTR PrinterName,        // printer for fax job
  CONST FAX_PRINT_INFOA *PrintInfo, 
                              // print job information structure
  LPDWORD FaxJobId,           // fax job identifier
  PFAX_CONTEXT_INFOA FaxContextInfo 
                              // pointer to device context structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxStartPrintJobA (PrinterName, PrintInfo, FaxJobId, FaxContextInfo);
}


extern "C"
BOOL 
WINAPI WinFaxStartPrintJobW(
  LPCWSTR PrinterName,        // printer for fax job
  CONST FAX_PRINT_INFOW *PrintInfo, 
                              // print job information structure
  LPDWORD FaxJobId,           // fax job identifier
  PFAX_CONTEXT_INFOW FaxContextInfo 
                              // pointer to device context structure
)
{
    if (!DynamicLoadFaxApi())
    {
        return FALSE;
    }
    return g_pFaxStartPrintJobW (PrinterName, PrintInfo, FaxJobId, FaxContextInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\client\bootstrap\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <tchar.h>
#include <faxreg.h>
#include <setuputil.h>
#include <shellapi.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\client\customactions\migration.cpp ===
#include "stdafx.h"
#include <routemapi.h>

#define USER_PROFILE_FILE_NAME      TEXT("FWSRVDLG.INI")
#define INITIAL_SIZE_ALL_PRINTERS       2000


#define DRIVER_SIGNATURE    'xafD'  // driver signature

#define MAX_BILLING_CODE        16
#define MAX_EMAIL_ADDRESS       128

#define USERNAMELEN             64          // Length of string for user logon name

#define SBS45_FAX_DRIVER_NAME       TEXT("Windows NT Fax Driver")
#define SBS45_QFE_FAX_DRIVER_NAME   TEXT("SBS Fax Driver")

#define WIN9X_UNINSTALL_EXE         TEXT("faxunins.exe")

#define COVERPAGE_DIR_W95           TEXT("\\spool\\fax\\coverpg")


#define OLD_REGKEY_FAX_SETUP        TEXT("Software\\Microsoft\\Fax\\Setup")
#define OLD_REGVAL_CP_LOCATION      TEXT("CoverPageDir")


typedef struct {

    WORD    hour;                   // hour: 0 - 23
    WORD    minute;                 // minute: 0 - 59

} FAXTIME, *PFAXTIME;


typedef struct {

    DWORD       signature;          // private devmode signature
    DWORD       flags;              // flag bits
    INT         sendCoverPage;      // whether to send cover page
    INT         whenToSend;         // "Time to send" option
    FAXTIME     sendAtTime;         // specific time to send
    DWORD       reserved[8];        // reserved

    //
    // Private fields used for passing info between kernel and user mode DLLs
    // pointer to user mode memory
    //

    PVOID       pUserMem;

    //
    // Billing code
    //

    WCHAR       billingCode[MAX_BILLING_CODE];

    //
    // Email address for delivery reports
    //

    WCHAR       emailAddress[MAX_EMAIL_ADDRESS];

} DMPRIVATE, *PDMPRIVATE;



BOOL
IsFaxClientInstalled()
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("IsFaxClientInstalled"), bRes);
    
    HKEY hKey = OpenRegistryKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_SBS45_W9X_ARP,
        FALSE,
        KEY_READ        
        );

    if (hKey)
    {
        VERBOSE (DBG_MSG, TEXT("Key %s was found"), REGKEY_SBS45_W9X_ARP);
        RegCloseKey(hKey);
        bRes = TRUE;
        return bRes;
    }
    VERBOSE (DBG_MSG, TEXT("Key %s was NOT found"), REGKEY_SBS45_W9X_ARP);
    return bRes;
}

#define   REGVAL_FAXINSTALLED                   TEXT("Installed")



BOOL
GetInstallationInfo
(
    IN LPCTSTR lpctstrRegKey,
    OUT LPDWORD Installed
)
{
    HKEY hKey;
    LONG rVal;
    DWORD RegType;
    DWORD RegSize;
    BOOL bRes = FALSE;

    DBG_ENTER(TEXT("GetInstallationInfo"), bRes);

    if (Installed == NULL) 
    {
        return bRes;
    }

    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        lpctstrRegKey,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) 
    {
        if (rVal != ERROR_FILE_NOT_FOUND)
        {
            VERBOSE (REGISTRY_ERR, 
                     TEXT("Fail to open setup registry key %s (ec=0x%08x)"), 
                     lpctstrRegKey,
                     rVal);
        }
        return bRes;
    }

    RegSize = sizeof(DWORD);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALLED,
        0,
        &RegType,
        (LPBYTE) Installed,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) 
    {
        VERBOSE (REGISTRY_ERR, 
                 TEXT("Could not query installed registry value %s, (ec=0x%08x)"), 
                 REGVAL_FAXINSTALLED,
                 rVal);
    }

    RegCloseKey( hKey );
    bRes = TRUE;
    return bRes;
}




VOID
GetUserStringFromIni(LPCTSTR SectionName, LPCTSTR  lptstrUserConfig, LPTSTR *ppString)
{
    TCHAR szBuffer[MAX_PATH] = {0}; 

    DBG_ENTER(TEXT("GetUserStringFromIni"), TEXT("%s, %s"), SectionName, lptstrUserConfig);

    GetPrivateProfileString(
        TEXT("UserConfig"),
        SectionName,
        TEXT(""),
        szBuffer,
        sizeof(szBuffer),
        USER_PROFILE_FILE_NAME
        );
    GetPrivateProfileString(
        lptstrUserConfig,  
        SectionName,
        szBuffer, 
        szBuffer, 
        sizeof(szBuffer), 
        USER_PROFILE_FILE_NAME
        );

    *ppString = StringDup(szBuffer);
}

VOID
GetUserStringFromRegistry(LPCTSTR SectionName, HKEY hUserKey, LPTSTR *ppString)
{
    (*ppString) = GetRegistryString(
        hUserKey,
        SectionName,
        TEXT("")
        );
}


VOID
GetBillingCodeForW9X(LPCTSTR lptstrUserName, LPTSTR *ppString)
{
    TCHAR szPrinters[INITIAL_SIZE_ALL_PRINTERS] = {0};
    TCHAR szBillingCode[2*MAX_BILLING_CODE] = {0};
    TCHAR szIniFileKey[INITIAL_SIZE_ALL_PRINTERS] = {0};

    DBG_ENTER(TEXT("GetBillingCodeForW9X"), TEXT("%s"), lptstrUserName);
    
    DWORD dwCount = GetPrivateProfileString(
        TEXT("Printers"),
        NULL,
        TEXT(""),
        szPrinters,
        sizeof(szPrinters), 
        USER_PROFILE_FILE_NAME
        );

    lstrcpy(szIniFileKey, TEXT("FaxConfig - "));
    lstrcat(szIniFileKey, szPrinters);
    if (lptstrUserName[0] != TEXT('\0'))
    {
        lstrcat(szIniFileKey, TEXT(","));
        lstrcat(szIniFileKey, lptstrUserName);
    }

    GetPrivateProfileString(
        szIniFileKey, 
        TEXT("BillingCode"), 
        TEXT(""), 
        szBillingCode, 
        sizeof(szBillingCode),
        USER_PROFILE_FILE_NAME
        );

    (*ppString) = StringDup(szBillingCode);

    VERBOSE (DBG_MSG, TEXT("Billing code (Win9x) is %s"), *ppString);
}



PDEVMODE
GetPerUserDevmode(
    LPTSTR lptstrPrinterName
    )
{
    PDEVMODE pDevMode = NULL;
    LONG Size;
    PRINTER_DEFAULTS PrinterDefaults;
    HANDLE hPrinter;

    DBG_ENTER(TEXT("GetPerUserDevmode"), TEXT("%s"), lptstrPrinterName);

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ;

    if (!OpenPrinter( lptstrPrinterName, &hPrinter, &PrinterDefaults )) 
    {
        VERBOSE (PRINT_ERR, 
                 TEXT("OpenPrinter(%s) failed, (ec=%ld)"), 
                 lptstrPrinterName,
                 GetLastError());
        return NULL;
    }

    Size = DocumentProperties(
                            NULL,
                            hPrinter,
                            lptstrPrinterName,
                            NULL,
                            NULL,
                            0
                            );

    if (Size < 0) 
    {
        VERBOSE (PRINT_ERR, 
                 TEXT("DocumentProperties failed Size=%d, (ec=%ld)"), 
                 Size,
                 GetLastError());
        goto exit;
    }
    
    pDevMode = (PDEVMODE) MemAlloc( Size );

    if (pDevMode == NULL) 
    {
        VERBOSE (MEM_ERR, 
                 TEXT("MemAlloc(%d) failed (ec: %ld)"), 
                 Size,
                 GetLastError());
        goto exit;
    }
    
    Size = DocumentProperties(
                            NULL,
                            hPrinter,
                            lptstrPrinterName,
                            pDevMode,
                            NULL,
                            DM_OUT_BUFFER
                            );

    if (Size < 0) 
    {
        VERBOSE (PRINT_ERR, 
                 TEXT("DocumentProperties failed Size=%d, (ec=%ld)"), 
                 Size,
                 GetLastError());
        MemFree( pDevMode );
        pDevMode = NULL;
        goto exit;
    }


exit:
    
    ClosePrinter( hPrinter );
    return pDevMode;
}

BOOL 
GetFirstFaxPrinterConnection(
    OUT LPTSTR lptstrPrinterName, 
    IN DWORD dwMaxLenInChars)
{
    PPRINTER_INFO_2 pPrinterInfo = NULL;
    DWORD dwNumPrinters = 0;
    DWORD dwPrinter = 0;
    DWORD ec = ERROR_SUCCESS;
    BOOL bRes = FALSE;

    DBG_ENTER(TEXT("GetFirstFaxPrinterConnection"), bRes, TEXT("%s, %d"), lptstrPrinterName, dwMaxLenInChars);

    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,
                                                    2,
                                                    &dwNumPrinters,
                                                    PRINTER_ENUM_CONNECTIONS
                                                    );
    if (!pPrinterInfo)
    {
        ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
            ec = ERROR_PRINTER_NOT_FOUND;
        }
        VERBOSE (PRINT_ERR, 
                 TEXT("MyEnumPrinters() failed (ec: %ld)"), 
                 ec);
        goto Exit;
    }

    for (dwPrinter=0; dwPrinter < dwNumPrinters; dwPrinter++)
    {
        if ( 
            (!_tcscmp(pPrinterInfo[dwPrinter].pDriverName,SBS45_FAX_DRIVER_NAME)) ||
            (!_tcscmp(pPrinterInfo[dwPrinter].pDriverName,SBS45_QFE_FAX_DRIVER_NAME)))
        {
            _tcsncpy(lptstrPrinterName,pPrinterInfo[dwPrinter].pPrinterName,dwMaxLenInChars);
            goto Exit;
        }
    }
    
    ec = ERROR_PRINTER_NOT_FOUND;

Exit:
    MemFree(pPrinterInfo);
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }
    bRes = (ERROR_SUCCESS == ec);
    return bRes;
}



VOID
GetBillingCodeForNT(
    LPTSTR *ppString    
    )
{
    TCHAR szFaxPrinterName[MAX_PATH+1] = {0};
    LPBYTE pDevMode;
    PDMPRIVATE pPrivateDevMode = NULL;

    DBG_ENTER(TEXT("GetBillingCodeForNT"));

    if (!ppString)
    {
        return;
    }

    if (!GetFirstFaxPrinterConnection(
        szFaxPrinterName,
        sizeof(szFaxPrinterName)/sizeof(TCHAR)))
    {
        VERBOSE (PRINT_ERR, 
                 TEXT("GetFirstFaxPrinterConnection() failed (ec: %ld)"), 
                 GetLastError());
        return;
    }


    pDevMode = (LPBYTE) GetPerUserDevmode( szFaxPrinterName );

    if (pDevMode) 
    {
        pPrivateDevMode = (PDMPRIVATE) (pDevMode + ((PDEVMODE) pDevMode)->dmSize);
    }
    
    if (pPrivateDevMode && pPrivateDevMode->signature == DRIVER_SIGNATURE) 
    {
#ifndef UNICODE
        *ppString = UnicodeStringToAnsiString(pPrivateDevMode->billingCode);
#else
        *ppString = StringDup(pPrivateDevMode->billingCode);
#endif

        VERBOSE (DBG_MSG, 
                 TEXT("Billing code (nt4) is %s"), 
                 *ppString);

    }

    if (pDevMode)
    {
        MemFree( pDevMode );
    }
}



BOOL
GetUserValues
(
    PFAX_PERSONAL_PROFILE pFaxPersonalProfiles, 
    BOOL fWin9X,
    LPCTSTR lpctstrRegKey
)
{

    TCHAR szUserConfig[USERNAMELEN + 15] = {0};
    TCHAR szUserName[USERNAMELEN] = {0};
    BOOL bRes = FALSE;

    DBG_ENTER(TEXT("GetUserValues"), bRes);
    ASSERTION(sizeof(FAX_PERSONAL_PROFILE) == pFaxPersonalProfiles->dwSizeOfStruct);

    VERBOSE (DBG_MSG, 
             TEXT("Getting user info from %s"),
             lpctstrRegKey);

    DWORD dwUserNameLen = sizeof(szUserName)/sizeof(TCHAR);
    if (!GetUserName(szUserName, &dwUserNameLen))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetUserName() failed, (ec=%ld)"), 
                 GetLastError() );
        return bRes;
    }
        
    
    // this will read the current values for the user from the INI file(s)

    if (fWin9X)
    {
        lstrcpy(szUserConfig, TEXT("UserConfig - "));
        lstrcat(szUserConfig, szUserName);
    
        GetUserStringFromIni(TEXT("Name"),           szUserConfig,  &(pFaxPersonalProfiles->lptstrName));
        GetUserStringFromIni(TEXT("FaxNo"),          szUserConfig,  &(pFaxPersonalProfiles->lptstrFaxNumber));
        GetUserStringFromIni(TEXT("Mailbox"),        szUserConfig,  &(pFaxPersonalProfiles->lptstrEmail));
        GetUserStringFromIni(TEXT("Title"),          szUserConfig,  &(pFaxPersonalProfiles->lptstrTitle));
        GetUserStringFromIni(TEXT("Company"),        szUserConfig,  &(pFaxPersonalProfiles->lptstrCompany));
        GetUserStringFromIni(TEXT("OfficeLocation"), szUserConfig,  &(pFaxPersonalProfiles->lptstrOfficeLocation));
        GetUserStringFromIni(TEXT("Department"),     szUserConfig,  &(pFaxPersonalProfiles->lptstrDepartment));
        GetUserStringFromIni(TEXT("HomePhone"),      szUserConfig,  &(pFaxPersonalProfiles->lptstrHomePhone));
        GetUserStringFromIni(TEXT("WorkPhone"),      szUserConfig,  &(pFaxPersonalProfiles->lptstrOfficePhone));
        GetUserStringFromIni(TEXT("Address"),        szUserConfig,  &(pFaxPersonalProfiles->lptstrStreetAddress));
        
        GetBillingCodeForW9X(szUserName, &(pFaxPersonalProfiles->lptstrBillingCode));
    }
    else 
    {
        // NT4 store the user information in the registry
        HKEY hUserKey = OpenRegistryKey(
            HKEY_CURRENT_USER,
            lpctstrRegKey,
            FALSE,
            KEY_READ
            );
        if (!hUserKey)
        {
            return bRes;
        }

        GetUserStringFromRegistry(TEXT("FullName"),       hUserKey, &(pFaxPersonalProfiles->lptstrName));
        GetUserStringFromRegistry(TEXT("FaxNumber"),      hUserKey, &(pFaxPersonalProfiles->lptstrFaxNumber));
        GetUserStringFromRegistry(TEXT("Mailbox"),        hUserKey, &(pFaxPersonalProfiles->lptstrEmail));
        GetUserStringFromRegistry(TEXT("Title"),          hUserKey, &(pFaxPersonalProfiles->lptstrTitle));
        GetUserStringFromRegistry(TEXT("Company"),        hUserKey, &(pFaxPersonalProfiles->lptstrCompany));
        GetUserStringFromRegistry(TEXT("Office"),         hUserKey, &(pFaxPersonalProfiles->lptstrOfficeLocation));
        GetUserStringFromRegistry(TEXT("Department"),     hUserKey, &(pFaxPersonalProfiles->lptstrDepartment));
        GetUserStringFromRegistry(TEXT("HomePhone"),      hUserKey, &(pFaxPersonalProfiles->lptstrHomePhone));
        GetUserStringFromRegistry(TEXT("OfficePhone"),    hUserKey, &(pFaxPersonalProfiles->lptstrOfficePhone));
        GetUserStringFromRegistry(TEXT("Address"),        hUserKey, &(pFaxPersonalProfiles->lptstrStreetAddress));

        GetBillingCodeForNT(&(pFaxPersonalProfiles->lptstrBillingCode));

        RegCloseKey(hUserKey);
    }

    bRes = TRUE;
    return bRes;
}




BOOL
SetSenderInformation(PFAX_PERSONAL_PROFILE pPersonalProfile)
/*++

Routine Description:

    Save the information about the sender in the registry

Arguments:
    
      pPersonalProfile - pointer to the sender information
    
Return Value:

    TRUE    - if success
    FALSE   - otherwise

--*/
{
    HKEY hRegKey = NULL;
    BOOL fRet = TRUE;

    DBG_ENTER(TEXT("SetSenderInformation"), fRet);
    //
    // Validate parameters
    //
    ASSERTION(pPersonalProfile);

    if (pPersonalProfile && pPersonalProfile->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Invalid parameter passed to function FaxSetSenderInformation"));
        fRet = FALSE;
        goto exit;
    }

    if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO,TRUE, KEY_ALL_ACCESS)))
    {
        SetRegistryString(hRegKey, REGVAL_FULLNAME,         pPersonalProfile->lptstrName);
        SetRegistryString(hRegKey, REGVAL_FAX_NUMBER,       pPersonalProfile->lptstrFaxNumber);
        SetRegistryString(hRegKey, REGVAL_COMPANY,          pPersonalProfile->lptstrCompany);
        SetRegistryString(hRegKey, REGVAL_ADDRESS,          pPersonalProfile->lptstrStreetAddress);
        //SetRegistryString(hRegKey, REGVAL_CITY,           pPersonalProfile->lptstrCity);
        //SetRegistryString(hRegKey, REGVAL_STATE,          pPersonalProfile->lptstrState);
        //SetRegistryString(hRegKey, REGVAL_ZIP,            pPersonalProfile->lptstrZip);
        //SetRegistryString(hRegKey, REGVAL_COUNTRY,        pPersonalProfile->lptstrCountry);
        SetRegistryString(hRegKey, REGVAL_TITLE,            pPersonalProfile->lptstrTitle);
        SetRegistryString(hRegKey, REGVAL_DEPT,             pPersonalProfile->lptstrDepartment);
        SetRegistryString(hRegKey, REGVAL_OFFICE,           pPersonalProfile->lptstrOfficeLocation);
        SetRegistryString(hRegKey, REGVAL_HOME_PHONE,       pPersonalProfile->lptstrHomePhone);
        SetRegistryString(hRegKey, REGVAL_OFFICE_PHONE,     pPersonalProfile->lptstrOfficePhone);       
        SetRegistryString(hRegKey, REGVAL_BILLING_CODE,     pPersonalProfile->lptstrBillingCode);
        SetRegistryString(hRegKey, REGVAL_MAILBOX,          pPersonalProfile->lptstrEmail);

        RegCloseKey(hRegKey);
    }
    else
    {
        VERBOSE (REGISTRY_ERR, 
                 TEXT("OpenRegistryKey(%s) failed"),
                 REGKEY_FAX_USERINFO);

        fRet = FALSE;
    }
exit:
    return fRet;
}



// 
// Function:    UninstallWin9XFaxClient
// Description: Execute faxunins.exe to unistall the fax client on win9x in unattended mode
// Returns:     TRUE for success, FALSE otherwise
//
// Remarks:     
//
// Args:        None
//
// Author:      AsafS

BOOL
UninstallWin9XFaxClient(VOID)
{
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    DWORD dwExitCode = 0;
    BOOL fRet = FALSE;

    DWORD dwWaitForObj;

    TCHAR szApplicationName[MAX_PATH+1] = {0};
    TCHAR szCommandLine[MAX_PATH+1] = {0};

    DBG_ENTER(TEXT("UninstallWin9XFaxClient"), fRet);

    GetStartupInfo(&si);
    ZeroMemory(&pi , sizeof(PROCESS_INFORMATION));

    if (!GetWindowsDirectory(szApplicationName, MAX_PATH))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetWindowsDirectory() failed, (ec=%ld)"), 
                 GetLastError() );
        goto error;
    }

    _tcsncat(
        szApplicationName, 
        TEXT("\\msapps\\fax\\"),
        (MAX_PATH-_tcslen(szApplicationName))
        );
    _tcsncat(
        szApplicationName,
        WIN9X_UNINSTALL_EXE,
        (MAX_PATH-_tcslen(szApplicationName))
        );

    _tcscpy(szCommandLine, szApplicationName);
    _tcsncat(
        szCommandLine, 
        TEXT(" -silent"),
        (MAX_PATH-_tcslen(szCommandLine))
        );
        
    VERBOSE (DBG_MSG, 
             TEXT("Call to CreateProcess with %s"),
             szCommandLine );

    if (!CreateProcess(
        szApplicationName,
        szCommandLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &si, // [cr] NULL ?
        &pi
        ))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("CreateProcess() failed, (ec=%ld)"), 
                 GetLastError() );
        goto error;
    }
    
        
    dwWaitForObj = WaitForSingleObject(
        pi.hProcess,
        INFINITE
        );

    if (WAIT_FAILED  == dwWaitForObj) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("WaitForSingleObject() failed, (ec=%ld)"), 
                 GetLastError() );
        goto error;
    }

    if (WAIT_TIMEOUT == dwWaitForObj) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("There was a timeout during uninstall"));
        ASSERTION(WAIT_TIMEOUT != dwWaitForObj);
        goto error;
    }


    if (!GetExitCodeProcess( pi.hProcess, &dwExitCode ))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetExitCodeProcess() failed, (ec=%ld)"), 
                 GetLastError() );
        goto error;
    }
    VERBOSE (DBG_MSG, 
             TEXT("GetExitCodeProcess returned with %d"), 
             dwExitCode );
    fRet = TRUE;

error:
    if (pi.hThread)
    {
        CloseHandle( pi.hThread );
    }
    if (pi.hProcess)
    {
        CloseHandle( pi.hProcess );
    }
    return fRet;
}



// 
// Function:    UninstallNTFaxClient
// Description: Execute faxsetup.exe or sbfsetup.exe to unistall the fax client on NT4/NT5
//              in unattended mode
// Returns:     TRUE for success, FALSE otherwise
//
// Remarks:     
//
// Args:        None
//
// Author:      AsafS

BOOL UninstallNTFaxClient(LPCTSTR lpctstrSetupImageName)
{
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    DWORD dwExitCode = 0;
    BOOL fRet = FALSE;

    DWORD dwWaitForObj;

    TCHAR szApplicationName[MAX_PATH+1] = {0};
    TCHAR szCommandLine[MAX_PATH+1] = {0};

    DBG_ENTER(TEXT("UninstallNTFaxClient"), fRet);

    CRouteMAPICalls rmcRouteMapiCalls;

    dwExitCode = rmcRouteMapiCalls.Init(lpctstrSetupImageName);
    if (dwExitCode!=ERROR_SUCCESS)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("CRouteMAPICalls::Init failed (ec: %ld)."), dwExitCode);
    }

    GetStartupInfo(&si);
    ZeroMemory(&pi , sizeof(PROCESS_INFORMATION));

    if (!GetSystemDirectory(szApplicationName, MAX_PATH))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetSystemDirectory() failed, (ec=%ld)"), 
                 GetLastError() );
        goto error;
    }

    _tcsncat(
        szApplicationName,
        TEXT("\\"),
        (MAX_PATH-_tcslen(szApplicationName))
        );
    _tcsncat(
        szApplicationName,
        lpctstrSetupImageName,
        (MAX_PATH-_tcslen(szApplicationName))
        );

    _tcscpy(szCommandLine, szApplicationName); 
    _tcsncat(
        szCommandLine,
        TEXT(" -ru"),
        (MAX_PATH-_tcslen(szCommandLine))
        );
    VERBOSE (DBG_MSG, 
             TEXT("Call to CreateProcess with %s"),
             szCommandLine );

    if (!CreateProcess(
        szApplicationName,
        szCommandLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &si, // [cr] NULL ?
        &pi
        ))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("CreateProcess() failed, (ec=%ld)"), 
                 GetLastError() );
        goto error;
    }
    
        
    dwWaitForObj = WaitForSingleObject(
        pi.hProcess,
        INFINITE
        );

    if (WAIT_FAILED  == dwWaitForObj) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("WaitForSingleObject() failed, (ec=%ld)"), 
                 GetLastError() );
        goto error;
    }

    if (WAIT_TIMEOUT == dwWaitForObj) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("There was a timeout during uninstall"));
        ASSERTION(WAIT_TIMEOUT != dwWaitForObj);
        goto error;
    }


    if (!GetExitCodeProcess( pi.hProcess, &dwExitCode ))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetExitCodeProcess() failed, (ec=%ld)"), 
                 GetLastError() );
        goto error;
    }
    VERBOSE (DBG_MSG, 
             TEXT("GetExitCodeProcess returned with %d"), 
             dwExitCode );

    fRet = TRUE;

error:
    if (pi.hThread)
    {
        CloseHandle( pi.hThread );
    }
    if (pi.hProcess)
    {
        CloseHandle( pi.hProcess );
    }
    return fRet;
}


BOOL
SaveDirectoryPathInRegistry(LPCTSTR lptstrCoverPagesPath)
{
    HKEY hKey = NULL;
    BOOL fRet = FALSE;
    
    DBG_ENTER(TEXT("SaveDirectoryPathInRegistry"), fRet, TEXT("%s"), lptstrCoverPagesPath);

    hKey = OpenRegistryKey(
        HKEY_CURRENT_USER,
        MIGRATION_KEY,
        TRUE,
        KEY_ALL_ACCESS
        );

    if (!hKey)
    {
        VERBOSE (REGISTRY_ERR, 
                 TEXT("OpenRegistryKey(HLU\\%s) failed, (ec=%ld)"), 
                 MIGRATION_KEY,
                 GetLastError());
        return FALSE;
    }

    fRet = SetRegistryString(
        hKey,
        MIGRATION_COVER_PAGES,
        lptstrCoverPagesPath
        );
    
    VERBOSE (DBG_MSG, 
             TEXT("SetRegistryString to save %s, ret value: %d"), 
             lptstrCoverPagesPath,
             fRet);
    RegCloseKey(hKey);
    return fRet;
}



// 
// Function:    GetUserCoverPageDirForNT4
// Description: Find the cover page directory on NT4, if the registry does not contain the entry
//              this function will *NOT* set the registry and return NULL.
// Returns:     Pointer to the full path to the cover page directory. NULL in case of an error or if not exist
//
// Remarks:     Use for NT4 with Fax Client only.
//              The user *MUST* call MemFree on the returned pointer if not NULL
//
// Args:        None
//
// Author:      AsafS


LPTSTR
GetUserCoverPageDirForNT4(
    VOID
    )
{
    DBG_ENTER(TEXT("GetUserCoverPageDirForNT4"));

    LPTSTR CpDir = NULL;
    HKEY hKey = NULL;
    
    hKey = OpenRegistryKey(
        HKEY_CURRENT_USER,
        OLD_REGKEY_FAX_SETUP,
        FALSE,
        KEY_READ
        );
    if (!hKey)
    {
        // There is no fax registry at all
        VERBOSE (DBG_MSG, 
            TEXT("No Fax registry was found"));
        return NULL;
    }

    CpDir = GetRegistryStringExpand(
        hKey, 
        OLD_REGVAL_CP_LOCATION,
        NULL
        );
    RegCloseKey(hKey);

    if (CpDir)
    {
        VERBOSE (DBG_MSG, 
                 TEXT("The Cover page directory is %s"), 
                 CpDir);
    }
    return CpDir;
}




// 
// Function:    DuplicateCoverPages
// Description: Copy cover pages from the old location to the new location
// Returns:     TRUE for success, FALSE otherwise
//              BOOL fWin9X       : TRUE if it is Win9X platform, FALSE if it is NT platform
//  
// Remarks:     
//              
//
// Args:        None
//
// Author:      AsafS

BOOL DuplicateCoverPages(BOOL fWin9X)
{
    TCHAR szOldCoverPagePath[MAX_PATH+1] = {0};
    TCHAR szNewCoverPagePath[MAX_PATH+1] = {0};
    
    DWORD cchValue = sizeof(szNewCoverPagePath)/sizeof(TCHAR);

    BOOL fRet = FALSE;
    UINT rc = ERROR_SUCCESS;

    DBG_ENTER(TEXT("DuplicateCoverPages"), fRet);

    SHFILEOPSTRUCT fileOpStruct;
    ZeroMemory(&fileOpStruct, sizeof(SHFILEOPSTRUCT));

    //
    // Get the OLD cover page directory
    //
    if (fWin9X)
    {
        if (!GetWindowsDirectory(szOldCoverPagePath, MAX_PATH))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("GetWindowsDirectory"), GetLastError());
            return FALSE;
        }
        _tcsncat(
            szOldCoverPagePath, 
            COVERPAGE_DIR_W95, 
            MAX_PATH - _tcslen(szOldCoverPagePath)
            );
    }
    else
    {
        DWORD dwFileAttribs = 0;
        LPTSTR lptstrNT4CoverPageDirectory = NULL;
        lptstrNT4CoverPageDirectory = GetUserCoverPageDirForNT4();
        if (NULL == lptstrNT4CoverPageDirectory)
        {
            // No cover page location was found in the registry for NT4
            goto error;
        }       
        // Copy the returned string to local buffer, and free the allocated memory.
        _tcsncpy(
            szOldCoverPagePath,
            lptstrNT4CoverPageDirectory,
            MAX_PATH
            );
        MemFree(lptstrNT4CoverPageDirectory);
    }

    // check that the path valid and exist
    if (GetFileAttributes(szOldCoverPagePath) == 0xffffffff)
    {
        // This means that the path is not a valid path,
        // It could be because we are on W2K and what we just got is the suffix only.
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetFileAttributes(): the path %s is invalid"), 
                 szOldCoverPagePath);
        goto error;
    }


    //
    // First, try to see if new cover page location exist in the registry (the suffix only)
    // If we upgrade on W2K we are using the cover page location of W2K
	
    // The is no new cover page location, lets calculate it and write it in the registry
    if (0 == LoadString(
        g_hModule,
        IDS_PERSONAL_CP_DIR,
        szNewCoverPagePath,
        cchValue
        ))
    {
        VERBOSE(GENERAL_ERR, 
             TEXT("LoadString(IDS_PERSONAL_CP_DIR) failed (ec: %ld)"),
             GetLastError ());
        goto error;
    }
    
    VERBOSE(
        DBG_MSG, 
        TEXT("LoadString(IDS_PERSONAL_CP_DIR) got %s."),
        szNewCoverPagePath);
        

	if(!SetClientCpDir(szNewCoverPagePath))
	{
        VERBOSE(GENERAL_ERR,
             TEXT("SetClientCpDir(%s) failed (ec: %ld)"),
             szNewCoverPagePath,
             GetLastError ());
        goto error;
	}

    // Now lets read the path (the function create folder in the file system if needed)
    // ATTENTION: MakeDirectory may fail, and we will not know about it.
    if(!GetClientCpDir(szNewCoverPagePath, cchValue))
    {
        VERBOSE(GENERAL_ERR,
             TEXT("GetClientCpDir (second call!) failed (ec: %ld)"),
             GetLastError ());
        goto error;
	}

    ///////////////////////////////

    //
    // Copy *.cov from old-dir to new-dir
    //
    _tcsncat(
        szOldCoverPagePath,
        TEXT("\\*.cov"),
        MAX_PATH - _tcslen(szOldCoverPagePath)
        );

    fileOpStruct.hwnd =                     NULL; 
    fileOpStruct.wFunc =                    FO_MOVE;
    fileOpStruct.pFrom =                    szOldCoverPagePath; 
    fileOpStruct.pTo =                      szNewCoverPagePath;
    fileOpStruct.fFlags =                   

        FOF_FILESONLY       |   // Perform the operation on files only if a wildcard file name (*.*) is specified. 
        FOF_NOCONFIRMMKDIR  |   // Do not confirm the creation of a new directory if the operation requires one to be created. 
        FOF_NOCONFIRMATION  |   // Respond with "Yes to All" for any dialog box that is displayed. 
        FOF_NORECURSION     |   // Only operate in the local directory. Don't operate recursively into subdirectories.
        FOF_SILENT          |   // Do not display a progress dialog box. 
        FOF_NOERRORUI;          // Do not display a user interface if an error occurs. 

    fileOpStruct.fAnyOperationsAborted =    FALSE;
    fileOpStruct.hNameMappings =            NULL;
    fileOpStruct.lpszProgressTitle =        NULL; 

    VERBOSE (DBG_MSG, 
             TEXT("Calling to SHFileOperation from %s to %s."),
             fileOpStruct.pFrom,
             fileOpStruct.pTo);
    if (0 != SHFileOperation(&fileOpStruct))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("SHFileOperation failed (ec: %ld)"),           
                 GetLastError());
        goto error;
    }

    fRet = TRUE;
error:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\client\customactions\resource.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    resource.h

Abstract:



Author:

    Asaf Shaar (asafs) 22-Dec-1999

Environment:

    User Mode

--*/


//
// string table
//
#define		IDS_FAXXP_DISPLAY_NAME		100
#define		IDS_BOSFAX_PRINTER_NAME     101
#define     IDS_PERSONAL_CP_DIR         102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\client\bootstrap\setup.cpp ===
// setup.cpp : Defines the entry point for the application.
//

#include "stdafx.h"

#define REBOOT_EQUALS_REALLY_SUPPRESS   _T("REBOOT=ReallySuppress")
                      

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    OSVERSIONINFO       osv;
    WIN32_FIND_DATA     FindFileData;
    TCHAR               szSystemDirectory[MAX_PATH+1]   = {0};
    TCHAR*              tpBuf                           = NULL;
    CHAR*               pcRebootPropInCmdLine           = NULL;
    HANDLE              hFind                           = INVALID_HANDLE_VALUE;
    int                 iRes                            = 1;
    LPCTSTR             lpctstrMsiDllName               = _T("\\MSI.DLL");
    HKEY                hKey                            = NULL;
    LONG                lRes                            = ERROR_SUCCESS;
    DWORD               dwData                          = 1;
    DWORD               dwWaitRes                       = 0;
    DWORD               dwExitCode                      = 0;
    BOOL                bCheckExitCode                  = FALSE;
	SHELLEXECUTEINFO    executeInfo                     = {0};

    DBG_ENTER(TEXT("WinMain"),iRes);

    // Check if this is Win98
    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        VERBOSE(GENERAL_ERR, 
                _T("GetVersionEx failed: (ec=%d)"),
                GetLastError());
        iRes = 0;
        goto exit;
    }

    if ((osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
        (osv.dwMinorVersion > 0))
    {
        VERBOSE (DBG_MSG, 
                 TEXT("This is Win98 OS"));
    }
    else
    {
        VERBOSE (DBG_MSG, 
                 TEXT("This is not Win98 OS, no need to force reboot"));
        iRes = 0;
        goto exit;
    }

    // check if msi.dll exists
    if (GetSystemDirectory(szSystemDirectory,MAX_PATH)==0)
    {
        VERBOSE(GENERAL_ERR, 
                _T("GetSystemDirectory failed: (ec=%d)"),
                GetLastError());
        iRes = 0;
        goto exit;
    }

    if (_tcslen(lpctstrMsiDllName)+_tcslen(szSystemDirectory)>=MAX_PATH-1)
    {
        VERBOSE(GENERAL_ERR, 
                _T("Path to msi.dll is too long"));
        iRes = 0;
        goto exit;
    }

    _tcscat(szSystemDirectory,lpctstrMsiDllName);

    VERBOSE (DBG_MSG, 
             TEXT("Looking for %s"),
             szSystemDirectory);


    hFind = FindFirstFile(szSystemDirectory, &FindFileData);

    if (hFind!=INVALID_HANDLE_VALUE) 
    {
        VERBOSE (DBG_MSG, 
                 TEXT("Msi.dll found, no need to force reboot"));

        FindClose(hFind);
        iRes = 0;
        goto exit;
    }

    // write registry DeferredBoot value
    lRes = RegCreateKey(HKEY_LOCAL_MACHINE,REGKEY_SETUP,&hKey);
    if (!((lRes==ERROR_SUCCESS) || (lRes==ERROR_ALREADY_EXISTS)))
    {
        VERBOSE(GENERAL_ERR, 
                _T("RegCreateKey failed: (ec=%d)"),
                GetLastError());
        iRes = 0;
        goto exit;
    }

    lRes = RegSetValueEx(   hKey,
                            DEFERRED_BOOT,
                            0,
                            REG_DWORD,
                            (LPBYTE) &dwData,
                            sizeof(DWORD)
                        );
    if (lRes!=ERROR_SUCCESS)
    {
        VERBOSE(GENERAL_ERR, 
                _T("RegSetValueEx failed: (ec=%d)"),
                GetLastError());
        iRes = 0;
        goto exit;
    }

    RegCloseKey(hKey);

exit:
    // launch Install Shield's setup.exe
    if (GetModuleFileName(NULL,szSystemDirectory,MAX_PATH)==0)
    {
        VERBOSE(GENERAL_ERR, 
                _T("GetModuleFileName failed: (ec=%d)"),
                GetLastError());
        return 0;
    }

    if ((tpBuf = _tcsrchr(szSystemDirectory,_T('\\')))==NULL)
    {
        VERBOSE(GENERAL_ERR, 
                _T("_tcsrchr failed"));
        return 0;
    }

    _tcscpy(_tcsinc(tpBuf),_T("_setup.exe"));
    VERBOSE (DBG_MSG, 
             TEXT("Running %s"),
             szSystemDirectory);


    // if the command line contains REBOOT=ReallySuppress we will check 
    // the return value of the Installer
    pcRebootPropInCmdLine = strstr(lpCmdLine,REBOOT_EQUALS_REALLY_SUPPRESS);
    if (pcRebootPropInCmdLine)
    {
        VERBOSE (DBG_MSG,TEXT("REBOOT=ReallySuppress is included in the command line, checking for reboot after setup"));
        bCheckExitCode = TRUE;
    }
    else
    {
        VERBOSE (DBG_MSG,TEXT("REBOOT=ReallySuppress is not included in the command line, ignoring exit code of setup"));
    }

	executeInfo.cbSize = sizeof(executeInfo);
	executeInfo.fMask  = SEE_MASK_NOCLOSEPROCESS;
	executeInfo.lpVerb = TEXT("open");
	executeInfo.lpFile = szSystemDirectory;
    executeInfo.lpParameters = (TCHAR*)lpCmdLine;
	executeInfo.nShow  = SW_RESTORE;
	//
	// Execute an aplication
	//
	if (!ShellExecuteEx(&executeInfo))
	{
        VERBOSE(GENERAL_ERR, 
                _T("ShellExecuteEx failed: (ec=%d)"),
                GetLastError());
		return 0;
	}

    if ((dwWaitRes=WaitForSingleObject(executeInfo.hProcess, INFINITE))==WAIT_FAILED)
    {
        VERBOSE(GENERAL_ERR, 
                _T("WaitForSingleObject failed: (ec=%d)"),
                GetLastError());
    }
    else if (dwWaitRes==WAIT_OBJECT_0)
    {
        VERBOSE(DBG_MSG, 
                _T("_Setup.exe terminated"));

        // now let's get the process's return code, see if we need a reboot.
        if (!GetExitCodeProcess( executeInfo.hProcess, &dwExitCode ))
        {
            VERBOSE (GENERAL_ERR,
                     TEXT("GetExitCodeProcess failed! (err=%ld)"),
                     GetLastError());
        }
        else
        {
            VERBOSE (DBG_MSG,
                     TEXT("GetExitCodeProcess returned %ld."),
                     dwExitCode);

            if ( bCheckExitCode && (dwExitCode==ERROR_SUCCESS_REBOOT_REQUIRED))
            {
                VERBOSE (DBG_MSG,
                         TEXT("Installation requires reboot, notify AppLauncher"));

                // notify AppLauncher that we need a reboot...
                lRes = RegCreateKey(HKEY_LOCAL_MACHINE,REGKEY_SETUP,&hKey);
                if ((lRes==ERROR_SUCCESS) || (lRes==ERROR_ALREADY_EXISTS))
                {
                    lRes = RegSetValueEx(   hKey,
                                            DEFERRED_BOOT,
                                            0,
                                            REG_DWORD,
                                            (LPBYTE) &dwData,
                                            sizeof(DWORD)
                                        );
                    if (lRes!=ERROR_SUCCESS)
                    {
                        VERBOSE(GENERAL_ERR, 
                                _T("RegSetValueEx failed: (ec=%d)"),
                                GetLastError());
                        iRes = 0;
                        RegCloseKey(hKey);
                        goto exit;
                    }

                    RegCloseKey(hKey);
                }
                else
                {
                    VERBOSE(GENERAL_ERR, 
                            _T("RegCreateKey failed: (ec=%d)"),
                            GetLastError());
                    iRes = 0;
                }
            }
            else if (dwExitCode!=ERROR_SUCCESS)
            {
                VERBOSE (GENERAL_ERR,
                         TEXT("Installation failed"));
            }
        }
    }
    else
    {
        VERBOSE(GENERAL_ERR, 
                _T("WaitForSingleObject returned unexpected result: (ec=%d)"),
                dwWaitRes);
    }

    if(!CloseHandle(executeInfo.hProcess))
    {
        VERBOSE(GENERAL_ERR, 
                _T("CloseHandle failed: (ec=%d)"),
                GetLastError());
    }

    return iRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\client\customactions\migration.h ===
// File Migration.h


extern HINSTANCE g_hModule;

BOOL
GetUserValues
(
    PFAX_PERSONAL_PROFILE pFaxPersonalProfiles, 
    BOOL fWin9X,
    LPCTSTR lpctstrRegKey
);

BOOL IsFaxClientInstalled(
	VOID
	);


BOOL SetSenderInformation(
	PFAX_PERSONAL_PROFILE pPersonalProfile
	);

BOOL UninstallWin9XFaxClient(
	VOID
	);

BOOL UninstallNTFaxClient(
    LPCTSTR lpctstrSetupImageName
    );

BOOL
GetInstallationInfo
(
    IN LPCTSTR lpctstrRegKey,
    OUT LPDWORD Installed
);

BOOL DuplicateCoverPages(	
	BOOL fWin9X
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\client\customactions\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

//#if _MSC_VER > 1000
#pragma once
//#endif // _MSC_VER > 1000

#include <windows.h>
#include <stdio.h>    // printf/wprintf
#include <shellapi.h>
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include <crtdbg.h>
#include <shlobj.h>
#include "MsiQuery.h" // must be in this directory or on INCLUDE path
#include "faxreg.h"
#include "WinSpool.h"
#include "faxutil.h"
#include "stdlib.h"
#include "resource.h"

#include "migration.h"
#include "setuputil.h"
#include "debugex.h"

#define DLL_API __declspec(dllexport)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\client\customactions\sources.inc ===
!IF 0
Copyright (c) 1996  Microsoft Corporation

!ENDIF

!ifndef FAXROOT
FAXROOT=$(BASEDIR)\private\fax
!endif


!include $(FAXROOT)\faxsrc.inc

INCLUDES=$(INCLUDES);.\..\;$(FAXROOT)\setup\inc;

C_DEFINES=$(C_DEFINES) -DDLL_EXPORTS=1
USECXX_FLAG=/Tp

TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=MSIClientCustomActions.DEF
UMTYPE= windows
DLLENTRY=_DllMainCRTStartup
!IF 0
NTPROFILEINPUT=yes
!ENDIF

USE_LIBCMT=1
NTKEEPRESOURCETMPFILES=1

PRECOMPILED_INCLUDE=..\StdAfx.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

INCLUDES=\
  $(INCLUDES); \

TARGETLIBS=\
  $(BASEDIR)\public\sdk\lib\*\msi.lib 	      \
  $(BASEDIR)\public\sdk\lib\*\gdi32.lib       \
  $(BASEDIR)\public\sdk\lib\*\user32.lib      \
  $(BASEDIR)\public\sdk\lib\*\kernel32.lib    \
  $(BASEDIR)\public\sdk\lib\*\advapi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\mapi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\winspool.lib    \
  $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
  $(BASEDIR)\public\sdk\lib\*\shfolder.lib     \
  $(BASEDIR)\public\sdk\lib\*\shell32.lib     \
  $(BASEDIR)\public\sdk\lib\*\uuid.lib        \
  $(FAXROOT)\util\$(ANSII_UNICODE)\obj\*\faxutil.lib \
  $(FAXROOT)\setup\util\$(ANSII_UNICODE)\obj\*\setuputil.lib \
  $(FAXROOT)\util\debugex\$(ANSII_UNICODE)\obj\*\debugex.lib \

C_DEFINES= $(C_DEFINES) -DENABLE_FRE_LOGGING

SOURCES=\
  ..\MSIClientCustomActions.cpp   \
  ..\Migration.cpp   \
  ..\MSIClientCustomActions.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\client\customactions\msiclientcustomactions.cpp ===
// Defines the entry point for the DLL application.
//
#include "stdafx.h"
#include <winver.h>
#include <shlwapi.h>
#include <mapix.h>
#include <routemapi.h>
#include <faxsetup.h>

HINSTANCE g_hModule = NULL;

DWORD GetDllVersion(LPCTSTR lpszDllName);
BOOL SetDefaultPrinter(LPTSTR pPrinterName);

BOOL APIENTRY DllMain( HINSTANCE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
                     )
{
    SET_DEBUG_MASK(DBG_ALL);

    g_hModule = hModule;
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
            {
                OPEN_DEBUG_LOG_FILE(SHARED_FAX_SERVICE_SETUP_LOG_FILE);
                DBG_ENTER(TEXT("DllMain called reason DLL_PROCESS_ATTACH."));
                if (!DisableThreadLibraryCalls(hModule))
                {
                    VERBOSE(GENERAL_ERR,
                            _T("DisableThreadLibraryCalls failed (ec=%d)"),
                            GetLastError());
                }
                break;
            }
        case DLL_PROCESS_DETACH:
            {
                DBG_ENTER(TEXT("DllMain called reason DLL_PROCESS_DETACH."));
                CLOSE_DEBUG_LOG_FILE;
                break;
            }
    }
    return TRUE;
}

///////////////////////////////
// VerifySpoolerIsRunning
//
// Start the Spooler service on NT4 & NT5
//
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD VerifySpoolerIsRunning()
{
    OSVERSIONINFO       osv;
    BOOL                bSuccess                    = FALSE;
    DWORD               dwReturn                    = NO_ERROR;
    SC_HANDLE           hSvcMgr                     = NULL;
    SC_HANDLE           hService                    = NULL;
    DWORD               i                           = 0;
    SERVICE_STATUS      Status;
    LPCTSTR             lpctstrSpoolerServiceName   = _T("Spooler");

    DBG_ENTER(_T("VerifySpoolerIsRunning"),dwReturn);

    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        dwReturn = GetLastError();
        VERBOSE(GENERAL_ERR, 
                _T("GetVersionEx failed: (ec=%d)"),
                dwReturn);
        goto exit;
    }

    // If Windows NT, use WriteProfileString for version 4.0 and earlier...
    if (osv.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        VERBOSE (DBG_MSG, 
                 TEXT("W9X OS, Skipping Spooler verification"));
        goto exit;
    }

    // open the service manager
    hSvcMgr = ::OpenSCManager(NULL,
                              NULL,
                              SC_MANAGER_CONNECT);

    if (hSvcMgr == NULL)
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR,
                _T("Failed to open the service manager, rc = 0x%lx"),
                dwReturn);
        goto exit;
    }

    hService = ::OpenService(hSvcMgr,
                             lpctstrSpoolerServiceName,
                             SERVICE_QUERY_STATUS|SERVICE_START);

    if (hService == NULL)
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR,
                _T("Failed to open service '%s', rc = 0x%lx"),
                lpctstrSpoolerServiceName,
                dwReturn);
        goto exit;
    }

    // Start the fax service.
    bSuccess = StartService(hService, 0, NULL);
    if (!bSuccess)
    {
        dwReturn = ::GetLastError();
        if (dwReturn == ERROR_SERVICE_ALREADY_RUNNING)
        {
            dwReturn = NO_ERROR;
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to start service '%s', rc = 0x%lx"),
                    lpctstrSpoolerServiceName, 
                    dwReturn);
            goto exit;
        }
    }

    do 
    {
        QueryServiceStatus(hService, &Status);
        i++;

        if (Status.dwCurrentState != SERVICE_RUNNING)
        {
            Sleep(1000);
        }

    } while ((i < 60) && (Status.dwCurrentState != SERVICE_RUNNING));

    if (Status.dwCurrentState != SERVICE_RUNNING)
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to start '%s' service"),
                lpctstrSpoolerServiceName);
        dwReturn = ERROR_SERVICE_REQUEST_TIMEOUT;
        goto exit;
    }


exit:
    if (hService)
    {
        CloseServiceHandle(hService);
    }

    if (hSvcMgr)
    {
        CloseServiceHandle(hSvcMgr);
    }

    return dwReturn;
}

// 
//
// Function:    ConnectW9XToRemotePrinter
// Platform:    This function intended to run on Win9X platforms
// Description: Add fax printer connection (driver + printer connection)
//              This function is exported by the DLL for use by the MSI as custom action to add printer connection.
//              In case of failure , returns ERROR_INSTALL_FAILURE
//              In case of success , returns ERROR_SUCCESS
//              GetLastError() to get the error code in case of failure.
//
// Remarks:     
//
// Args:        hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS


DLL_API UINT __stdcall ConnectW9XToRemotePrinter(MSIHANDLE hInstall)
{
    UINT rc = ERROR_SUCCESS;    
    DBG_ENTER(TEXT("ConnectW9XToRemotePrinter"), rc);

    TCHAR szFaxPrinterName[MAX_PATH] = {0};
    
    TCHAR szDisplayName[MAX_PATH] = {0};

    TCHAR szPrinterDriverFolder[MAX_PATH] = {0};
    DWORD dwNeededSize = 0;

    PRINTER_INFO_2 pi2;
    DRIVER_INFO_3 di3;
    HANDLE hPrinter = NULL;

    if (!GetPrinterDriverDirectory(
        NULL,
        TEXT("Windows 4.0"),
        1,
        (LPBYTE) szPrinterDriverFolder,
        sizeof(szPrinterDriverFolder)/sizeof(TCHAR),
        &dwNeededSize
        ))
    {
        VERBOSE (PRINT_ERR, 
                 TEXT("GetPrinterDriverDirectory failed or not enough space dwNeededSize %ld (ec: %ld)"),
                 dwNeededSize,
                 GetLastError ());
        goto error;
    }


    // Get the remote printer path
    
    if (!PrivateMsiGetProperty(hInstall,_T("CustomActionData"),szFaxPrinterName))
    {
        VERBOSE (SETUP_ERR, 
                 TEXT("PrivateMsiGetProperty failed (ec: %ld)"),
                 GetLastError());
        goto error;
    }


    ZeroMemory(&di3, sizeof(DRIVER_INFO_3 ));
    ZeroMemory(&pi2, sizeof(PRINTER_INFO_2));
    
    di3.cVersion     =       1024;
    di3.pName        =       FAX_DRIVER_NAME;
    di3.pEnvironment =       TEXT("Windows 4.0");
    di3.pDriverPath  =       FAX_DRV_WIN9X_16_MODULE_NAME;
    di3.pDataFile    =       FAX_DRV_WIN9X_16_MODULE_NAME;
    di3.pConfigFile  =       FAX_DRV_WIN9X_16_MODULE_NAME;
    di3.pDataFile    =       FAX_DRV_WIN9X_16_MODULE_NAME;
    di3.pConfigFile  =       FAX_DRV_WIN9X_16_MODULE_NAME;
    di3.pHelpFile    =       FAX_DRV_UNIDRV_HELP; // UNIDRV.HLP
    di3.pDependentFiles =    FAX_DRV_WIN9X_16_MODULE_NAME TEXT("\0")
                             FAX_DRV_WIN9X_32_MODULE_NAME TEXT("\0") // FXSDRV32.DLL
                             FAX_DRV_DEPEND_FILE TEXT("\0")          // FXSWZRD.DLL
                             FAX_API_MODULE_NAME TEXT("\0")          // FXSAPI.DLL
                             FAX_TIFF_FILE TEXT("\0")                // FXSTIFF.DLL
                             FAX_DRV_ICONLIB TEXT("\0")              // ICONLIB.DLL
                             FAX_DRV_UNIDRV_MODULE_NAME TEXT("\0");  // UNIDRV.DLL 
    di3.pMonitorName =       NULL;
    di3.pDefaultDataType =   TEXT("RAW");
    
    if (!AddPrinterDriver(NULL, 3, (LPBYTE)&di3))
    {
        VERBOSE (PRINT_ERR, 
                 TEXT("AddPrinterDriver failed (ec: %ld)"),
                 GetLastError());
        goto error;
    }

    if (!LoadString(
        g_hModule,
        IDS_BOSFAX_PRINTER_NAME,
        szDisplayName,
        sizeof(szDisplayName)/sizeof(TCHAR)
        )) goto error;
    
    pi2.pPrinterName    = szDisplayName;
    pi2.pPortName       = szFaxPrinterName;
    pi2.pDriverName     = FAX_DRIVER_NAME;
    pi2.pPrintProcessor = TEXT("WinPrint");
    pi2.pDatatype       = TEXT("RAW");
    
    hPrinter = AddPrinter(NULL, 2, (LPBYTE)&pi2);
    if (!hPrinter)
    {
        rc = GetLastError();
        if (rc==ERROR_PRINTER_ALREADY_EXISTS)
        {
            VERBOSE (DBG_MSG,TEXT("Printer already exists, continue..."));
            rc = ERROR_SUCCESS;
        }
        else
        {
            VERBOSE (PRINT_ERR, 
                     TEXT("AddPrinter failed (ec: %ld)"),
                     GetLastError());
            goto error;
        }
    }

    if (hPrinter)
    {
        ClosePrinter(hPrinter); 
        hPrinter = NULL;
    }
    
    return rc;

error:

    VERBOSE (GENERAL_ERR, 
             TEXT("CustomAction ConnectW9XToRemotePrinter() failed !"));
    rc = ERROR_INSTALL_FAILURE;
    return rc;
}



// 
//
// Function:    RemoveW9XPrinterConnection
// Platform:    This function intended to run on Win9X platforms
// Description: Remove the fax printer connection from the current machine.

//              This function is exported by the DLL for use by the MSI as custom action to delete printer connection.
//              In case of failure , returns ERROR_INSTALL_FAILURE
//              In case of success , returns ERROR_SUCCESS
//              GetLastError() to get the error code in case of failure, the error is of the first error that occured.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS


DLL_API UINT __stdcall RemoveW9XPrinterConnection(MSIHANDLE hInstall)
{
    UINT retVal = ERROR_INSTALL_FAILURE;
    DBG_ENTER(TEXT("RemoveW9XPrinterConnection"), retVal);
    HANDLE hPrinter = NULL;

    TCHAR szDisplayName[MAX_PATH] = {0};

    if (!LoadString(
        g_hModule,
        IDS_BOSFAX_PRINTER_NAME,
        szDisplayName,
        sizeof(szDisplayName)/sizeof(TCHAR)
        )) goto error;

    if (!OpenPrinter(
        szDisplayName,
        &hPrinter,
        NULL
        ))
    {
        VERBOSE (PRINT_ERR, 
                 TEXT("OpenPrinter() failed ! (ec: %ld)"),
                 GetLastError ());
        goto error;
    }

    if (!DeletePrinter(
        hPrinter
        ))
    {
        VERBOSE (PRINT_ERR, 
                 TEXT("DeletePrinter() failed ! (ec: %ld)"),
                 GetLastError ());
        goto error;
    }

    retVal = ERROR_SUCCESS;

error:
    if (hPrinter)
    {
        ClosePrinter(
            hPrinter
            );
        hPrinter = NULL;
    }

    return (retVal);
}



// 
//
// Function:    AddFaxPrinterConnection
// Platform:    This function intended to run on NT platforms (NT4 and Win2K)
// Description: Add fax printer connection
//              This function is exported by the DLL for use by the MSI as custom action to add printer connection.
//              In case of failure , returns ERROR_INSTALL_FAILURE
//              In case of success , returns ERROR_SUCCESS
//              GetLastError() to get the error code in case of failure.
//
// Remarks:     
//
// Args:        hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS

  
DLL_API UINT __stdcall AddFaxPrinterConnection(MSIHANDLE hInstall)
{
    UINT rc = ERROR_SUCCESS;
    DBG_ENTER(TEXT("AddFaxPrinterConnection"), rc);
    
    BOOL fFaxPrinterConnectionAdded = FALSE;
    
    TCHAR szFaxPrinterName[MAX_PATH]   = {0};

    if (!PrivateMsiGetProperty(hInstall,_T("PRINTER_NAME"),szFaxPrinterName))
    {
        VERBOSE (SETUP_ERR, 
                 TEXT("PrivateMsiGetProperty() failed ! (ec: %ld)"),
                 GetLastError ());
        goto error;
    }


   
    //////////////////////////////////////////
    // Add the printer connection on client //
    //////////////////////////////////////////
    
    fFaxPrinterConnectionAdded = AddPrinterConnection(szFaxPrinterName);
    if (!fFaxPrinterConnectionAdded) 
    {
        DWORD dwLastError = GetLastError();
        VERBOSE (PRINT_ERR, 
                 TEXT("AddPrinterConnection() failed ! (ec: %ld)"),
                 dwLastError);
        goto error;
    }
    else
    {
        VERBOSE (DBG_MSG, 
                 TEXT("Successfully added fax printer connection to %s"),
                 szFaxPrinterName);
    }

    
    if (!SetDefaultPrinter(szFaxPrinterName))
    {
        DWORD dwLastError = GetLastError();
        VERBOSE (PRINT_ERR, 
                 TEXT("SetDefaultPrinter() failed ! (ec: %ld)"),
                 dwLastError);
        goto error;
    }

    return rc;

error:

    VERBOSE (GENERAL_ERR, 
             TEXT("CustomAction AddFaxPrinterConnection() failed !"));
    rc = ERROR_INSTALL_FAILURE;
    return rc;
}


// 
//
// Function:    RemoveFaxPrinterConnection
// Platform:    This function intended to run on NT platforms (NT4 and Win2K)
// Description: Remove the fax printer connection from the current machine.
//              This function is exported by the DLL for use by the MSI as custom action to delete printer connection.
//              In case of failure , returns ERROR_INSTALL_FAILURE
//              In case of success , returns ERROR_SUCCESS
//              GetLastError() to get the error code in case of failure, the error is of the first error that occured.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS


DLL_API UINT __stdcall RemoveFaxPrinterConnection(MSIHANDLE hInstall)
{
    PPRINTER_INFO_2 pPrinterInfo    = NULL;
    DWORD dwNumPrinters             = 0;
    DWORD dwPrinter                 = 0;
    DWORD ec                        = ERROR_SUCCESS;

    DBG_ENTER(TEXT("RemoveFaxPrinterConnection"), ec);

    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,
                                                    2,
                                                    &dwNumPrinters,
                                                    PRINTER_ENUM_CONNECTIONS
                                                    );
    if (!pPrinterInfo)
    {
        ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
            ec = ERROR_PRINTER_NOT_FOUND;
        }
        VERBOSE (GENERAL_ERR, 
                 TEXT("MyEnumPrinters() failed (ec: %ld)"), 
                 ec);
        goto error;
    }

    for (dwPrinter=0; dwPrinter < dwNumPrinters; dwPrinter++)
    {
        if (IsPrinterFaxPrinter(pPrinterInfo[dwPrinter].pPrinterName))
        {
            if (!DeletePrinterConnection(pPrinterInfo[dwPrinter].pPrinterName))
            {
                VERBOSE (PRINT_ERR, 
                         TEXT("DeletePrinterConnection() %s failed ! (ec: %ld)"),
                         pPrinterInfo[dwPrinter].pPrinterName,
                         GetLastError ());
                goto error;
            
            }
            else
            {
                VERBOSE (DBG_MSG, 
                         TEXT("fax printer connection %s was deleted successfully"),
                         pPrinterInfo[dwPrinter].pPrinterName);
            } 
        }
    }

error:

    if (pPrinterInfo)
    {
        MemFree(pPrinterInfo);
    }

    if (ec!=ERROR_SUCCESS)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("CustomAction RemoveFaxPrinterConnection() failed !"));
    }
    return ec;
}


#define FXSEXTENSION    _T("FXSEXT32.DLL")

// 
//
// Function:    Create_FXSEXT_ECF_File
// Description: Creates FxsExt.ecf in <WindowsFolder>\addins
//              a default file will be installed there by Windows Installer
//              to enable it to keep track of install/remove
//              GetLastError() to get the error code in case of failure, the error is of the first error that occured.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall Create_FXSEXT_ECF_File(MSIHANDLE hInstall)
{
    // CustomActionData has the following format <WindowsFolder>;<INSTALLDIR>
    TCHAR szCustomActionData[2*MAX_PATH] = {0};
    TCHAR szWindowsFolder[MAX_PATH] = {0};
    TCHAR szExtensionPath[MAX_PATH] = {0};
    TCHAR* tpInstallDir = NULL;
    UINT uiRet = ERROR_SUCCESS;

    DBG_ENTER(_T("Create_FXSEXT_ECF_File"));

    // get the custom action data from Windows Installer (deffered action)
    if (!PrivateMsiGetProperty(hInstall,_T("CustomActionData"),szCustomActionData))
    {
        VERBOSE (GENERAL_ERR, 
                 _T("PrivateMsiGetProperty:CustomActionData failed (ec: %ld)."),
                 uiRet);
        goto error;
    }

    if (_tcstok(szCustomActionData,_T(";"))==NULL)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("_tcstok failed on first token."));
        uiRet = ERROR_INVALID_PARAMETER;
        goto error;
    }

    if ((tpInstallDir=_tcstok(NULL,_T(";\0")))==NULL)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("_tcstok failed on second token."));
        uiRet = ERROR_INVALID_PARAMETER;
        goto error;
    }
    _tcscpy(szWindowsFolder,szCustomActionData);

    // construct the full path to the file
    if (_tcslen(szWindowsFolder)+_tcslen(ADDINS_DIRECTORY)+_tcslen(FXSEXT_ECF_FILE)>=MAX_PATH)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("Path to <WindowsFolder>\\Addins\\fxsext.ecf is too long"));
        goto error;
    }
    _tcscat(szWindowsFolder,ADDINS_DIRECTORY);
    _tcscat(szWindowsFolder,FXSEXT_ECF_FILE);

    VERBOSE (DBG_MSG, 
             _T("Filename to create is: %s."),
             szWindowsFolder);

    if (_tcslen(tpInstallDir)+_tcslen(FXSEXTENSION)+2>=MAX_PATH)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("Path to <INSTALLDIR>\\Bin\\fxsext32.dll is too long"));
        goto error;
    }

    _tcscpy(szExtensionPath,_T("\""));
    _tcscat(szExtensionPath,tpInstallDir);
    _tcscat(szExtensionPath,FXSEXTENSION);
    _tcscat(szExtensionPath,_T("\""));

    VERBOSE (DBG_MSG, 
             _T("MAPI Extension dll path dir is: %s."),
             szExtensionPath);

    if (!WritePrivateProfileString( _T("General"), 
                                    _T("Path"),                 
                                    szExtensionPath, 
                                    szWindowsFolder)) 
    {
        uiRet = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 _T("WritePrivateProfileString failed (ec: %ld)."),
                 uiRet);
        goto error;
    }

    Assert(uiRet==ERROR_SUCCESS);
    return uiRet;

error:

    Assert(uiRet!=ERROR_SUCCESS);
    return uiRet;
}

// 
//
// Function:    ValidatePrinter
// Description: Validates that the printer name which was entered is a legitimate
//              Fax Printer, and that the server is available.
//              Uses the MSI Property 'ValidPrinterFormat' to notify MSI if the
//              name is valid or not.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall ValidatePrinter(MSIHANDLE hInstall)
{
    TCHAR szPrinterName[MAX_PATH] = {0};
    UINT uiRet = ERROR_SUCCESS;
    HANDLE hPrinterHandle = INVALID_HANDLE_VALUE;
    BOOL bValidPrinter = TRUE;
    DBG_ENTER(_T("ValidatePrinter"));

    // first get the PRINTER_NAME proterty from Windows Installer
    if (!PrivateMsiGetProperty(hInstall,_T("PRINTER_NAME"),szPrinterName))
    {
        VERBOSE (GENERAL_ERR, 
                 _T("PrivateMsiGetProperty:PRINTER_NAME failed (ec: %ld)."),
                 uiRet);
        goto error;
    }

    if (VerifySpoolerIsRunning()!=NO_ERROR)
    {
        uiRet = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 _T("VerifySpoolerIsRunning (ec:%d)"),
                 uiRet);
        goto error;
    }

    // we have a string with the PRINTER_NAME, let's try to open it...
    if (bValidPrinter=IsPrinterFaxPrinter(szPrinterName))
    {
        VERBOSE (DBG_MSG, 
                 _T("IsPrinterFaxPrinter: %s succeeded."),
                 szPrinterName);
    }
    else
    {
        uiRet = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 _T("IsPrinterFaxPrinter: %s failed (ec: %ld)."),
                 szPrinterName,
                 uiRet);
    }


    uiRet = MsiSetProperty( hInstall,
                            _T("ValidPrinterFormat"),
                            bValidPrinter ? _T("TRUE") : _T("FALSE"));
    if (uiRet!=ERROR_SUCCESS)
    {
        VERBOSE (DBG_MSG,
                 TEXT("MsiSetProperty failed."));
        goto error;
    }

    return ERROR_SUCCESS;

error:

    return ERROR_FUNCTION_FAILED;
}

// 
//
// Function:    GuessPrinterName
// Description: Tries to understand whether the installation is performed from the 
//              server's FaxClients share, and if it is tries to establish a default
//              printer to be used
// 
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall GuessPrinterName(MSIHANDLE hInstall)
{
    UINT    uiRet                   = ERROR_SUCCESS;
    TCHAR   szSourceDir[MAX_PATH]   = {0};
    TCHAR   szPrinterName[MAX_PATH] = {0};
    TCHAR*  tpClientShare           = NULL;
    PPRINTER_INFO_2 pPrinterInfo    = NULL;
    DWORD dwNumPrinters             = 0;
    DWORD dwPrinter                 = 0;

    DBG_ENTER(_T("GuessPrinterName"),uiRet);

    // get the source directory from Windows Installer
    if (!PrivateMsiGetProperty(hInstall,_T("SourceDir"),szSourceDir))
    {
        VERBOSE (GENERAL_ERR, 
                 _T("PrivateMsiGetProperty:SourceDir failed (ec: %ld)."),
                 uiRet);
        goto exit;
    }

    // check if we have a UNC path
    if (_tcsncmp(szSourceDir,_T("\\\\"),2))
    {
        VERBOSE (DBG_MSG, 
                 _T("SourceDir doesn't start with \\\\"));
        uiRet = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // find drive name (skip server name)
    if ((tpClientShare=_tcschr(_tcsninc(szSourceDir,2),_T('\\')))==NULL)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("_tcschr failed"));
        uiRet = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (VerifySpoolerIsRunning()!=NO_ERROR)
    {
        uiRet = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 _T("VerifySpoolerIsRunning (ec:%d)"),
                 uiRet);
        goto exit;
    }

    // extract the server's name
    *tpClientShare = 0;
    // szSourceDir now holds the server's name
    // enumerate the printers on the server
    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(szSourceDir,
                                                    2,
                                                    &dwNumPrinters,
                                                    PRINTER_ENUM_NAME
                                                    );

    if (!pPrinterInfo)
    {
        uiRet = GetLastError();
        if (uiRet == ERROR_SUCCESS)
        {
            uiRet = ERROR_PRINTER_NOT_FOUND;
        }
        VERBOSE (GENERAL_ERR, 
                 TEXT("MyEnumPrinters() failed (ec: %ld)"), 
                 uiRet);
        goto exit;
    }

    for (dwPrinter=0; dwPrinter < dwNumPrinters; dwPrinter++)
    {
        // check if we have a valid fax printer driver name
        if (_tcscmp(pPrinterInfo[dwPrinter].pDriverName,FAX_DRIVER_NAME ) == 0) 
        {
            if (    (pPrinterInfo[dwPrinter].pServerName==NULL)         ||
                    (_tcslen(pPrinterInfo[dwPrinter].pServerName)==0)   ||
                    (pPrinterInfo[dwPrinter].pShareName==NULL)          ||
                    (_tcslen(pPrinterInfo[dwPrinter].pShareName)==0)    )
            {
                // on win9x the printer name lives in the Port name field
                _tcscpy(szPrinterName,pPrinterInfo[dwPrinter].pPortName);
            }
            else
            {
                _tcscpy(szPrinterName,pPrinterInfo[dwPrinter].pServerName);
                _tcscat(szPrinterName,_T("\\"));
                _tcscat(szPrinterName,pPrinterInfo[dwPrinter].pShareName);
            }
            VERBOSE (DBG_MSG,
                     TEXT("Setting PRINTER_NAME to %s."),
                     szPrinterName);
            // set property to Installer
            uiRet = MsiSetProperty(hInstall,_T("PRINTER_NAME"),szPrinterName);
            if (uiRet!=ERROR_SUCCESS)
            {
                VERBOSE (GENERAL_ERR,
                         TEXT("MsiSetProperty failed."));
                goto exit;
            }
            break;
        }
        else
        {
            VERBOSE (DBG_MSG,
                     TEXT("%s is not a Fax printer - driver name is %s."),
                     pPrinterInfo[dwPrinter].pPrinterName,
                     pPrinterInfo[dwPrinter].pDriverName);
        }
    }

exit:

    if (pPrinterInfo)
    {
        MemFree(pPrinterInfo);
    }

    return uiRet;
}

// 
//
// Function:    Remove_FXSEXT_ECF_File
// Description: Removes FxsExt.ecf from <WindowsFolder>\addins
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall Remove_FXSEXT_ECF_File(MSIHANDLE hInstall)
{
    TCHAR szWindowsFolder[MAX_PATH] = {0};
    UINT uiRet = ERROR_SUCCESS;

    DBG_ENTER(_T("Remove_FXSEXT_ECF_File"));


    // check if the service is installed on this machine
    INSTALLSTATE currentInstallState = MsiQueryProductState(
        PRODCODE_SBS50SERVER
        );
    
    if (currentInstallState != INSTALLSTATE_UNKNOWN)
    {
        VERBOSE (DBG_MSG,
                 TEXT("The Microsoft Shared Fax Service is installed. returning without removing file."));
        return uiRet;
    }

    // get the <WindowsFolder> from Windows Installer
    if (!PrivateMsiGetProperty(hInstall,_T("WindowsFolder"),szWindowsFolder))
    {
        VERBOSE (GENERAL_ERR, 
                 _T("PrivateMsiGetProperty:WindowsFolder failed (ec: %ld)."),
                 uiRet);
        goto error;
    }

    // construct the full path to the file
    if (_tcslen(szWindowsFolder)+_tcslen(ADDINS_DIRECTORY)+_tcslen(FXSEXT_ECF_FILE)>=MAX_PATH)
    {
        VERBOSE (GENERAL_ERR, 
                 _T("Path to <WindowsFolder>\\Addins\\fxsext.ecf is too long"));
        goto error;
    }
    _tcscat(szWindowsFolder,ADDINS_DIRECTORY);
    _tcscat(szWindowsFolder,FXSEXT_ECF_FILE);

    VERBOSE (DBG_MSG, 
             _T("Filename to delete is: %s."),
             szWindowsFolder);

    if (DeleteFile(szWindowsFolder))
    {
        VERBOSE (DBG_MSG, 
                 _T("File %s was deleted successfully."),
                 szWindowsFolder);
    }
    else
    {
        VERBOSE (GENERAL_ERR, 
                 _T("DeleteFile %s failed (ec=%d)."),
                 szWindowsFolder,
                 GetLastError());
    }
    
    return ERROR_SUCCESS;

error:

    return ERROR_INSTALL_FAILURE;
}


// 
//
// Function:    RemoveTrasportProviderFromProfile
// Description: removes the Trasnport Provider from a MAPI profile
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
HRESULT RemoveTrasportProviderFromProfile(LPSERVICEADMIN  lpServiceAdmin)
{
    static SRestriction sres;
    static SizedSPropTagArray(2, Columns) =   {2,{PR_DISPLAY_NAME_A,PR_SERVICE_UID}};

    HRESULT         hr                          = S_OK;
    LPMAPITABLE     lpMapiTable                 = NULL;
    LPSRowSet       lpSRowSet                   = NULL;
    LPSPropValue    lpProp                      = NULL;
    ULONG           Count                       = 0;
    BOOL            bMapiInitialized            = FALSE;
    SPropValue      spv;
    MAPIUID         ServiceUID;
    
    DBG_ENTER(TEXT("RemoveTrasportProviderFromProfile"), hr);
    // get message service table
    hr = lpServiceAdmin->GetMsgServiceTable(0,&lpMapiTable);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetMsgServiceTable failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    // notify MAPI that we want PR_DISPLAY_NAME_A & PR_SERVICE_UID
    hr = lpMapiTable->SetColumns((LPSPropTagArray)&Columns, 0);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("SetColumns failed (ec: %ld)."),
                 hr);
        goto exit;
    }
 
    // restrict the search to our service provider
    sres.rt = RES_PROPERTY;
    sres.res.resProperty.relop = RELOP_EQ;
    sres.res.resProperty.ulPropTag = PR_SERVICE_NAME_A;
    sres.res.resProperty.lpProp = &spv;

    spv.ulPropTag = PR_SERVICE_NAME_A;
    spv.Value.lpszA = FAX_MESSAGE_SERVICE_NAME;

    // find it
    hr = lpMapiTable->FindRow(&sres, BOOKMARK_BEGINNING, 0);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("FindRow failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    // get our service provider's row
    hr = lpMapiTable->QueryRows(1, 0, &lpSRowSet);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    if (lpSRowSet->cRows != 1)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows returned %d rows, there should be only one."),
                 lpSRowSet->cRows);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    // get the MAPIUID of our service
    lpProp = &lpSRowSet->aRow[0].lpProps[1];

    if (lpProp->ulPropTag != PR_SERVICE_UID)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Property is %d, should be PR_SERVICE_UID."),
                 lpProp->ulPropTag);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    // Copy the UID into our member.
    memcpy(&ServiceUID.ab, lpProp->Value.bin.lpb,lpProp->Value.bin.cb);

    // finally, delete our service provider
    hr = lpServiceAdmin->DeleteMsgService(&ServiceUID);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("DeleteMsgService failed (ec: %ld)."),
                 hr);
        goto exit;
    }

exit:
    return hr;
}

// 
//
// Function:    RemoveTrasportProvider
// Description: delete FXSXP32.DLL from mapisvc.inf 
//              and removes the Trasnport Provider from MAPI
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB

DLL_API UINT __stdcall RemoveTrasportProvider(MSIHANDLE hInstall)
{
    TCHAR           szMapisvcFile[2 * MAX_PATH]     = {0};
    DWORD           err                             = 0;
    DWORD           rc                              = ERROR_SUCCESS;
    HRESULT         hr                              = S_OK;
    LPSERVICEADMIN  lpServiceAdmin                  = NULL;
    LPMAPITABLE     lpMapiTable                     = NULL;
    LPPROFADMIN     lpProfAdmin                     = NULL;
    LPMAPITABLE     lpTable                         = NULL;
    LPSRowSet       lpSRowSet                       = NULL;
    LPSPropValue    lpProp                          = NULL;
    ULONG           Count                           = 0;
    int             iIndex                          = 0;
    BOOL            bMapiInitialized                = FALSE;
    HINSTANCE       hMapiDll                        = NULL;
                                                    
    LPMAPIINITIALIZE      fnMapiInitialize          = NULL;
    LPMAPIADMINPROFILES   fnMapiAdminProfiles       = NULL;
    LPMAPIUNINITIALIZE    fnMapiUninitialize        = NULL;

    DBG_ENTER(TEXT("RemoveTrasportProvider"), rc);

    CRouteMAPICalls rmcRouteMapiCalls;

    // first remove ourselves from MAPISVC.INF
    if(!GetSystemDirectory(szMapisvcFile, sizeof(szMapisvcFile)/sizeof(TCHAR)))
    {
        rc = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetSystemDirectory failed (ec: %ld)."),
                 rc);
        goto exit;
    }
    _tcscat(szMapisvcFile, TEXT("\\mapisvc.inf"));

    VERBOSE (DBG_MSG, 
             TEXT("The mapi file is %s."),
             szMapisvcFile);

    if (!WritePrivateProfileString( TEXT("Default Services"), 
                                    FAX_MESSAGE_SERVICE_NAME_T,                 
                                    NULL, 
                                    szMapisvcFile 
                                    )) 
    {
        rc = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 rc);
        goto exit;
    }

    if (!WritePrivateProfileString( TEXT("Services"),
                                    FAX_MESSAGE_SERVICE_NAME_T,                 
                                    NULL, 
                                    szMapisvcFile
                                    )) 
    {
        rc = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 rc);
        goto exit;
    }

    if (!WritePrivateProfileString( FAX_MESSAGE_SERVICE_NAME_T,         
                                    NULL,
                                    NULL,
                                    szMapisvcFile
                                    )) 
    {
        rc = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 rc);
        goto exit;
    }

    if (!WritePrivateProfileString( FAX_MESSAGE_SERVICE_PROVIDER_NAME_T,        
                                    NULL,
                                    NULL, 
                                    szMapisvcFile                   
                                    )) 
    {
        rc = GetLastError();
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 rc);
        goto exit;
    }
    
    // now remove the MAPI Service provider
    rc = rmcRouteMapiCalls.Init(_T("msiexec.exe"));
    if (rc!=ERROR_SUCCESS)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("CRouteMAPICalls::Init failed (ec: %ld)."), rc);
        goto exit;
    }
    
    hMapiDll = LoadLibrary(_T("MAPI32.DLL"));
    if (NULL == hMapiDll)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadLibrary"), GetLastError()); 
        goto exit;
    }

    fnMapiInitialize = (LPMAPIINITIALIZE)GetProcAddress(hMapiDll, "MAPIInitialize");
    if (NULL == fnMapiInitialize)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(MAPIInitialize)"), GetLastError());  
        goto exit;
    }

    fnMapiAdminProfiles = (LPMAPIADMINPROFILES)GetProcAddress(hMapiDll, "MAPIAdminProfiles");
    if (NULL == fnMapiAdminProfiles)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(fnMapiAdminProfiles)"), GetLastError());  
        goto exit;
    }

    fnMapiUninitialize = (LPMAPIUNINITIALIZE)GetProcAddress(hMapiDll, "MAPIUninitialize");
    if (NULL == fnMapiUninitialize)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(MAPIUninitialize)"), GetLastError());  
        goto exit;
    }

    // get access to MAPI functinality
    hr = fnMapiInitialize(NULL);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("MAPIInitialize failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    bMapiInitialized = TRUE;

    // get admin profile object
    hr = fnMapiAdminProfiles(0,&lpProfAdmin);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("MAPIAdminProfiles failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    // get profile table
    hr = lpProfAdmin->GetProfileTable(0,&lpTable);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetProfileTable failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    // get profile rows
    hr = lpTable->QueryRows(4000, 0, &lpSRowSet);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    for (iIndex=0; iIndex<(int)lpSRowSet->cRows; iIndex++)
    {
        lpProp = &lpSRowSet->aRow[iIndex].lpProps[0];

        if (lpProp->ulPropTag != PR_DISPLAY_NAME_A)
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("Property is %d, should be PR_DISPLAY_NAME_A."),
                     lpProp->ulPropTag);
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_TABLE);
            goto exit;
        }

        hr = lpProfAdmin->AdminServices(LPTSTR(lpProp->Value.lpszA),NULL,0,0,&lpServiceAdmin);
        if (FAILED(hr))
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("AdminServices failed (ec: %ld)."),
                     rc = hr);
            goto exit;
        }
         
        hr = RemoveTrasportProviderFromProfile(lpServiceAdmin);
        if (FAILED(hr))
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("RemoveTrasportProviderFromProfile failed (ec: %ld)."),
                     rc = hr);
            goto exit;
        }
    }

exit:

    if (bMapiInitialized)
    {
        fnMapiUninitialize();
    }

    if (hMapiDll)
    {
        FreeLibrary(hMapiDll);
        hMapiDll = NULL;
    }

    return rc;
}

// 
//
// Function:    AddOutlookExtension
// Description: Add fax as outlook provider. Write into the MAPI file: 'mapisvc.inf'
//              This function is exported by the DLL for use by the MSI as custom action.
//              In case of failure , returns ERROR_INSTALL_FAILURE
//              In case of success , returns ERROR_SUCCESS
//              GetLastError() to get the error code in case of failure, the error is of the first error that occured.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS


DLL_API UINT __stdcall AddOutlookExtension(MSIHANDLE hInstall)
{
    TCHAR szMapisvcFile[2 * MAX_PATH] = {0};
    TCHAR szDisplayName[MAX_PATH] = {0};

    DWORD err = 0;
    DWORD rc = ERROR_SUCCESS;
    DBG_ENTER(TEXT("AddOutlookExtension"), rc);


    if(!GetSystemDirectory(szMapisvcFile, sizeof(szMapisvcFile)/sizeof(TCHAR)))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetSystemDirectory failed (ec: %ld)."),
                 GetLastError ());
        goto error;
    }
    _tcscat(szMapisvcFile, TEXT("\\mapisvc.inf"));

    VERBOSE (DBG_MSG, 
             TEXT("The mapi file is %s."),
             szMapisvcFile);
    if (!LoadString(
        g_hModule,
        IDS_FAXXP_DISPLAY_NAME,
        szDisplayName,
        sizeof(szDisplayName)/sizeof(TCHAR)
        )) goto error;
    err++;

    if (!WritePrivateProfileString( 
        TEXT("Default Services"), 
        FAX_MESSAGE_SERVICE_NAME_T,                 
        szDisplayName, 
        szMapisvcFile 
        )) goto error;
    err++;

    if (!WritePrivateProfileString( 
        TEXT("Services"),
        FAX_MESSAGE_SERVICE_NAME_T,                 
        szDisplayName, 
        szMapisvcFile
        )) goto error;
    err++;

    if (!WritePrivateProfileString(
        FAX_MESSAGE_SERVICE_NAME_T,         
        TEXT("PR_DISPLAY_NAME"),
        szDisplayName,
        szMapisvcFile
        )) goto error;
    err++;

    if (!WritePrivateProfileString(
        FAX_MESSAGE_SERVICE_NAME_T,
        TEXT("Providers"),
        FAX_MESSAGE_SERVICE_PROVIDER_NAME_T,
        szMapisvcFile
        )) goto error;
    err++;

    if (!WritePrivateProfileString(
        FAX_MESSAGE_SERVICE_NAME_T,
        TEXT("PR_SERVICE_DLL_NAME"),
        FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,
        szMapisvcFile
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString( 
        FAX_MESSAGE_SERVICE_NAME_T, 
        TEXT("PR_SERVICE_SUPPORT_FILES"),
        FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,
        szMapisvcFile
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString( 
        FAX_MESSAGE_SERVICE_NAME_T,         
        TEXT("PR_SERVICE_ENTRY_NAME"),
        TEXT("ServiceEntry"), 
        szMapisvcFile                
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString( 
        FAX_MESSAGE_SERVICE_NAME_T,         
        TEXT("PR_RESOURCE_FLAGS"),
        TEXT("SERVICE_SINGLE_COPY|SERVICE_NO_PRIMARY_IDENTITY"), 
        szMapisvcFile 
        )) goto error;
    err++;

    if (!WritePrivateProfileString(  
        FAX_MESSAGE_SERVICE_PROVIDER_NAME_T,        
        TEXT("PR_PROVIDER_DLL_NAME"),
        FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T, 
        szMapisvcFile                   
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString(  
        FAX_MESSAGE_SERVICE_PROVIDER_NAME_T,        
        TEXT("PR_RESOURCE_TYPE"),
        TEXT("MAPI_TRANSPORT_PROVIDER"), 
        szMapisvcFile     
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString(  
        FAX_MESSAGE_SERVICE_PROVIDER_NAME_T,        
        TEXT("PR_RESOURCE_FLAGS"),
        TEXT("STATUS_NO_DEFAULT_STORE"), 
        szMapisvcFile     
        )) goto error;
    err++;
    
    if (!WritePrivateProfileString( 
        FAX_MESSAGE_SERVICE_PROVIDER_NAME_T,        
        TEXT("PR_DISPLAY_NAME"), 
        szDisplayName, 
        szMapisvcFile 
        )) goto error;
    err++;

    if (!WritePrivateProfileString(
        FAX_MESSAGE_SERVICE_PROVIDER_NAME_T,      
        TEXT("PR_PROVIDER_DISPLAY"),
        szDisplayName,
        szMapisvcFile 
        )) goto error;
    err++;

    return rc;

error:

    VERBOSE (GENERAL_ERR, 
             TEXT("CustomAction AddOutlookExtension() failed ! (ec: %ld) (err = %ld)"),
             GetLastError(),
             err
             );
    rc = ERROR_INSTALL_FAILURE;
    return rc;
}

//////////////////////////////////////////////////////////////////////////////////
//                              Migration                                       //
//////////////////////////////////////////////////////////////////////////////////


// 
//
// Function:    MigrateSBS45ClientsOnWin9X
// Description: Get the user information from the SBS4.5 fax client on current machine.
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS


DLL_API UINT __stdcall MigrateSBS45ClientsOnWin9X(MSIHANDLE hInstall)
{
    DWORD rc = ERROR_SUCCESS;
    DBG_ENTER(TEXT("MigrateSBS45ClientsOnWin9X"), rc);
    
    FAX_PERSONAL_PROFILE faxPersonalProfiles;
    ZeroMemory((LPVOID) &faxPersonalProfiles, sizeof(FAX_PERSONAL_PROFILE));
    faxPersonalProfiles.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    BOOL  fRet = FALSE;

    if (!IsFaxClientInstalled())
    {
        VERBOSE (DBG_MSG, 
                 TEXT("Fax client is not installed on this Win9X machine."));
        return rc;
    }

    
    if (!GetUserValues(&faxPersonalProfiles,TRUE,NULL)) // TRUE means: Win9X user profile
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Could not GET the user information."));
        goto error;
    }

    fRet = SetSenderInformation(&faxPersonalProfiles);

    FreePersonalProfile(&faxPersonalProfiles, FALSE);

    if (!fRet)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Could not SET the user information."));
        goto error;
    }

    if (!DuplicateCoverPages(TRUE)) // TRUE means Win9X
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("DuplicateCoverPages for Win9X failed! (ec: %ld)."),
                 GetLastError ());
    }

    if (!UninstallWin9XFaxClient())
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Failed to uninstall the Win9X client (of SBS4.5)."));
        goto error;
    }

    return rc;

error:

    VERBOSE (GENERAL_ERR, 
             TEXT("CustomAction MigrateSBS45ClientsOnWin9X() failed ! (ec: %ld)"),
             GetLastError ());
    rc = ERROR_INSTALL_FAILURE;
    return rc;
}

#ifdef UNICODE

DWORD 
RemovePath (
    LPCWSTR lpcwstrPath
)
/*++

Routine name : RemovePath

Routine description:

	Removes a given path

Author:

	Eran Yariv (EranY),	Oct, 2000

Arguments:

	lpcwstrPath  [in]     - Path to remove

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER (TEXT("RemovePath"), dwRes, TEXT("%s"), lpcwstrPath);

    WCHAR wszFilesToFind[MAX_PATH * 2];
    wsprintf (wszFilesToFind, TEXT("%s\\*.*"), lpcwstrPath);

    WIN32_FIND_DATA FindInfo;
    HANDLE hFind = FindFirstFile (wszFilesToFind, &FindInfo);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        dwRes = GetLastError ();
        if (ERROR_NO_MORE_FILES == dwRes)
        {
            dwRes = ERROR_SUCCESS;
            return dwRes;
        }
        CALL_FAIL (FILE_ERR, TEXT("FindFirstFile"), dwRes);
        return dwRes;
    }
    for (;;)
    {
        if (FindInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (lstrcpy (TEXT("."), FindInfo.cFileName) &&
                lstrcpy (TEXT(".."), FindInfo.cFileName))
            {
                //
                // Ignore "." and ".."
                // Recursively remove directory
                //
                WCHAR wszNewPath [MAX_PATH * 2];
                lstrcpy (wszNewPath, lpcwstrPath);
                lstrcat (wszNewPath, TEXT("\\"));
                lstrcat (wszNewPath, FindInfo.cFileName);
                dwRes = RemovePath (wszNewPath);
            }
        }
        else
        {
            //
            // A real file
            //
            WCHAR wszFileToKill [MAX_PATH * 2];
            lstrcpy (wszFileToKill, lpcwstrPath);
            lstrcat (wszFileToKill, TEXT("\\"));
            lstrcat (wszFileToKill, FindInfo.cFileName);

            if (!DeleteFile (wszFileToKill))
            {
                dwRes = GetLastError ();
                VERBOSE (FILE_ERR, 
                         TEXT("DeleteFile(%s) failed with %ld"), 
                         wszFileToKill,
                         dwRes);
            }
        }
        if (!FindNextFile (hFind, &FindInfo))
        {
            dwRes = GetLastError ();
            if (ERROR_NO_MORE_FILES == dwRes)
            {
                dwRes = ERROR_SUCCESS;
                break;
            }
            CALL_FAIL (FILE_ERR, TEXT("FindNextFile"), dwRes);
            return dwRes;
        }
    }
    FindClose (hFind);
    if (!RemoveDirectory (lpcwstrPath))
    {
        dwRes = GetLastError ();
        VERBOSE (FILE_ERR, 
                 TEXT("RemoveDirectory(%s) failed with %ld"), 
                 lpcwstrPath,
                 dwRes);
    }
    return dwRes;
}   // RemovePath

DWORD
RemoveProgramGroup (MSIHANDLE hInstall)
/*++

Routine name : RemoveProgramGroup

Routine description:

	Removes a program group

Author:

	Eran Yariv (EranY),	Oct, 2000

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HRESULT hr;
    DBG_ENTER (TEXT("RemoveProgramGroup"), dwRes);

    WCHAR wszGroupName[MAX_PATH * 3];
    WCHAR wszGroupPath[MAX_PATH * 4];

    if (!PrivateMsiGetProperty(hInstall,_T("SBS45ProgramMenuEntry"),wszGroupName))
    {
        dwRes = GetLastError();
        VERBOSE (SETUP_ERR, 
                 TEXT("PrivateMsiGetProperty failed (ec: %ld)"),
                 dwRes);
        return dwRes;
    }
    hr = SHGetFolderPath (NULL,
                          CSIDL_COMMON_PROGRAMS,    // After upgrade, we're in <All users> programs group
                          NULL,
                          SHGFP_TYPE_CURRENT,
                          (WCHAR *)&wszGroupPath);

    if (S_OK != hr)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("SHGetFolderPath(CSIDL_PROGRAMS)"), hr);
        return (DWORD)(hr);
    }
    lstrcat (wszGroupPath, L"\\");
    lstrcat (wszGroupPath, wszGroupName);
    dwRes = RemovePath(wszGroupPath);
    return dwRes;
}   // RemoveProgramGroup

// we might be on a machine where an old SBS4.5 Fax client was installed
// and the machine was upgraded to W2K, which means that W2K Fax killed the
// old client (replaced the binaried) but there are still entries in the ARP 
// and in the program menu that indicate an old, non functioning fax
// we'll try to remove these.
// this will not cause us to fail setup.
BOOL RemoveSBS45ClientsLeftovers(MSIHANDLE hInstall)
{
    // this is what we remove:
    //
    // 1. the Program Menu entry 
    // 2. the ARP entry
    DWORD dwRes;
    DBG_ENTER (TEXT("RemoveSBS45ClientsLeftovers"));

    RemoveProgramGroup(hInstall);
    dwRes = RegDeleteKey(HKEY_LOCAL_MACHINE,REGKEY_SBS45_W9X_ARP);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL(REGISTRY_ERR,REGKEY_SBS45_W9X_ARP, dwRes);
    }
    if (!DeleteRegistryKey (HKEY_LOCAL_MACHINE, REGKEY_SBS45_W9X_CLIENT))
    {
        dwRes = GetLastError();
        CALL_FAIL(REGISTRY_ERR, REGKEY_SBS45_W9X_CLIENT, dwRes);
    }

    return TRUE;
}

#else   // UNICODE

    #define RemoveSBS45ClientsLeftovers(a) TRUE 

#endif  // UNICODE
// 
//
// Function:    MigrateSBS45ClientsOnNT4
// Description: 
//
// Remarks:     
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      AsafS

#define REGKEY_OLD_FAX_SETUP_NT4        TEXT("Software\\Microsoft\\Fax\\Setup")
#define REGKEY_OLD_FAX_SETUP_NT5        TEXT("Software\\Microsoft\\SBSFax\\Setup")

#define REGKEY_OLD_FAX_USERINFO_NT4     TEXT("Software\\Microsoft\\Fax\\UserInfo")
#define REGKEY_OLD_FAX_USERINFO_NT5     TEXT("Software\\Microsoft\\SBSFax\\UserInfo")

#define SETUP_IMAGE_NAME_NT4            TEXT("faxsetup.exe")
#define SETUP_IMAGE_NAME_NT5            TEXT("sbfsetup.exe")

DLL_API UINT __stdcall MigrateSBS45ClientsOnNT4(MSIHANDLE hInstall)
{
    DWORD rc = ERROR_SUCCESS;
    DWORD Installed;
    BOOL  fRet = FALSE;
    FAX_PERSONAL_PROFILE faxPersonalProfiles;
    OSVERSIONINFO   osv;
    LPCTSTR lpctstrRegKey = NULL;

    DBG_ENTER(TEXT("MigrateSBS45ClientsOnNT"), rc);
    
    ZeroMemory((LPVOID) &faxPersonalProfiles, sizeof(FAX_PERSONAL_PROFILE));
    faxPersonalProfiles.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        rc = GetLastError();
        VERBOSE(GENERAL_ERR, 
                _T("GetVersionEx failed: (ec=%d)"),
                rc);
        goto exit;
    }

    // If Windows NT, use WriteProfileString for version 4.0 and earlier...
    if (osv.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        VERBOSE (DBG_MSG, 
                 TEXT("W9X OS, This function should not be called on this platform"));
        goto exit;
    }
    
    VERBOSE(DBG_MSG,_T("This is %s"),(osv.dwMajorVersion>4)?_T("W2K"):_T("NT4"));

    lpctstrRegKey = (osv.dwMajorVersion>4) ? 
                    (&REGKEY_OLD_FAX_SETUP_NT5) : 
                    (&REGKEY_OLD_FAX_SETUP_NT4);

    if (!GetInstallationInfo(lpctstrRegKey,&Installed))
    {
        VERBOSE (DBG_MSG, 
                 TEXT("GetInstallationInfo failed!"));

        goto exit;
    }

    if (!Installed) 
    {
        VERBOSE (DBG_MSG, 
                 TEXT("Fax client is not installed on this NT machine."));

        goto exit;
    }

    VERBOSE(    DBG_MSG,
                _T("%s Client is installed on this machine"),
                (osv.dwMajorVersion>4)?_T("W2K"):_T("NT4"));

    lpctstrRegKey = (osv.dwMajorVersion>4) ? 
                    (&REGKEY_OLD_FAX_USERINFO_NT5) : 
                    (&REGKEY_OLD_FAX_USERINFO_NT4);

    if (!GetUserValues(&faxPersonalProfiles,FALSE,lpctstrRegKey))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Could not GET the user information on NT4."));
        rc = ERROR_INSTALL_FAILURE;
        goto exit;
    }

    // Duplicate the Old Cover pages to the new location.
    // The new location is fixed place. The only issue here is the suffix that
    // must be localaized, so we will use resource for that.
    if (!DuplicateCoverPages(FALSE)) // FALSE means NT4
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("DuplicateCoverPages for NT4 failed! (ec: %ld)."),
                 GetLastError ());
    }

    lpctstrRegKey = (osv.dwMajorVersion>4) ? 
                    (&SETUP_IMAGE_NAME_NT5) : 
                    (&SETUP_IMAGE_NAME_NT4);

    if (!UninstallNTFaxClient(lpctstrRegKey))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Failed to uninstall the NT client (of SBS4.5)."));
        rc = ERROR_INSTALL_FAILURE;
        goto exit;
    }

    fRet = SetSenderInformation(&faxPersonalProfiles);

    FreePersonalProfile(&faxPersonalProfiles, FALSE);

    if (!fRet)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Could not SET the user information on NT."));
        rc = ERROR_INSTALL_FAILURE;
        goto exit;
    }

exit:

    if (osv.dwMajorVersion>4)
    {
        // we might be on a machine where an old SBS4.5 Fax client was installed
        // and the machine was upgraded to W2K, which means that W2K Fax killed the
        // old client (replaced the binaried) but there are still entries in the ARP 
        // and in the program menu that indicate an old, non functioning fax
        // we'll try to remove these.
        // this will not cause us to fail setup.
        if (!RemoveSBS45ClientsLeftovers(hInstall))
        {
            VERBOSE (DBG_WARNING, TEXT("RemoveSBS45ClientsLeftovers failed"));
        }
    }
    return rc;
}


#define PACKVERSION(major,minor) MAKELONG(minor,major)
#define COMCTL32_401 PACKVERSION (4,72)

DLL_API UINT __stdcall IsComctlRequiresUpdate(MSIHANDLE hInstall)
{
    UINT uiRet = ERROR_SUCCESS;
    BOOL bRes = FALSE;
    DWORD dwVer = 0;

    DBG_ENTER(TEXT("IsComctlRequiresUpdate"), uiRet);
    
    dwVer = GetDllVersion(TEXT("comctl32.dll"));
    VERBOSE (DBG_MSG, 
             TEXT("Current COMCTL32 version is 0x%08X."),
             dwVer);

    if (COMCTL32_401 > dwVer)
    {
        VERBOSE (DBG_MSG, 
                 TEXT("COMCTL32.DLL requires update."));
        bRes = TRUE;
    }

    uiRet = MsiSetProperty( hInstall,
                            _T("IsComctlRequiresUpdate"),
                            bRes ? _T("TRUE") : _T("FALSE"));
    if (uiRet!=ERROR_SUCCESS)
    {
        VERBOSE (DBG_MSG,
                 TEXT("MsiSetProperty IsComctlRequiresUpdate failed."));   
    }

    return uiRet;
}





/*++

Routine Description:
    Returns the version information for a DLL exporting "DllGetVersion".
    DllGetVersion is exported by the shell DLLs (specifically COMCTRL32.DLL).

Arguments:

    lpszDllName - The name of the DLL to get version information from.

Return Value:

    The version is retuned as DWORD where:
    HIWORD ( version DWORD  ) = Major Version
    LOWORD ( version DWORD  ) = Minor Version
    Use the macro PACKVERSION to comapre versions.
    If the DLL does not export "DllGetVersion" the function returns 0.

--*/
DWORD GetDllVersion(LPCTSTR lpszDllName)
{

    HINSTANCE hinstDll;
    DWORD dwVersion = 0;

    DBG_ENTER(TEXT("GetDllVersion"), dwVersion, TEXT("%s"), lpszDllName);

    hinstDll = LoadLibrary(lpszDllName);

    if(hinstDll)
    {
        DLLGETVERSIONPROC pDllGetVersion;

        pDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hinstDll, "DllGetVersion");

    // Because some DLLs may not implement this function, you
    // must test for it explicitly. Depending on the particular
    // DLL, the lack of a DllGetVersion function may
    // be a useful indicator of the version.

        if(pDllGetVersion)
        {
            DLLVERSIONINFO dvi;
            HRESULT hr;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            hr = (*pDllGetVersion)(&dvi);

            if(SUCCEEDED(hr))
            {
                dwVersion = PACKVERSION(dvi.dwMajorVersion, dvi.dwMinorVersion);
            }
        }

        FreeLibrary(hinstDll);
    }
    return dwVersion;
}

typedef struct _TypeCommand 
{
    LPCTSTR lpctstrType;
    LPCTSTR lpctstrFolder;
    LPCTSTR lpctstrCommand;
} TypeCommand;

static TypeCommand tcWin9XCommand[] = 
{
    // Win9X PrintTo verbs
    { _T("txtfile"),    _T("WindowsFolder"),    _T("write.exe /pt \"%1\" \"%2\" \"%3\" \"%4")     },
    { _T("jpegfile"),   _T("WindowsFolder"),    _T("pbrush.exe /pt \"%1\" \"%2\" \"%3\" \"%4")    },
};

static TypeCommand tcWinMECommand[] = 
{
    // WinME PrintTo verbs
    { _T("txtfile"),        _T("WindowsFolder"),    _T("write.exe /pt \"%1\" \"%2\" \"%3\" \"%4")     },
    { _T("jpegfile"),       _T("WindowsFolder"),    _T("pbrush.exe /pt \"%1\" \"%2\" \"%3\" \"%4")    },
    { _T("giffile"),        _T("WindowsFolder"),    _T("pbrush.exe /pt \"%1\" \"%2\" \"%3\" \"%4")    },
    { _T("Paint.Picture"),  _T("WindowsFolder"),    _T("pbrush.exe /pt \"%1\" \"%2\" \"%3\" \"%4")    },
};

static TypeCommand tcWin2KCommand[] = 
{
    // NT4 PrintTo verbs
    { _T("txtfile"),    _T("SystemFolder"),     _T("write.exe /pt \"%1\" \"%2\" \"%3\" \"%4")     },
    { _T("jpegfile"),   _T("SystemFolder"),     _T("mspaint.exe /pt \"%1\" \"%2\" \"%3\" \"%4")   },
};

static int iCountWin9XCommands = sizeof(tcWin9XCommand)/sizeof(tcWin9XCommand[0]);
static int iCountWinMECommands = sizeof(tcWinMECommand)/sizeof(tcWinMECommand[0]);
static int iCountWin2KCommands = sizeof(tcWin2KCommand)/sizeof(tcWin2KCommand[0]);

// 
//
// Function:    CrearePrintToVerb
//
// Description: Creates the PrintTo verb for text files to associate it with wordpad
//              if the PrintTo verb already exists, this function does nothing.
//
// Remarks:     
//          on Win9x
//              txtfile  - PrintTo = <WindowsFolder>\write.exe /pt "%1" "%2" "%3" "%4"
//              jpegfile - PrintTo = <WindowsFolder>\pbrush.exe /pt "%1" "%2" "%3" "%4"
//
//          on WinME
//              txtfile         - PrintTo = <WindowsFolder>\write.exe /pt "%1" "%2" "%3" "%4"
//              jpegfile        - PrintTo = <WindowsFolder>\pbrush.exe /pt "%1" "%2" "%3" "%4"
//              giffile         - PrintTo = <WindowsFolder>\pbrush.exe /pt "%1" "%2" "%3" "%4"
//              Paint.Picture   - PrintTo = <WindowsFolder>\pbrush.exe /pt "%1" "%2" "%3" "%4"
//
//          on NT4
//              txtfile  - PrintTo = <SystemFolder>\write.exe /pt "%1" "%2" "%3" "%4"
//              jpegfile - PrintTo = <SystemFolder>\mspaint.exe /pt "%1" "%2" "%3" "%4"
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall CreatePrintToVerb(MSIHANDLE hInstall)
{
    UINT            uiRet                   = ERROR_SUCCESS;
    LPCTSTR         lpctstrPrintToCommand   = _T("\\shell\\printto\\command");
    int             iCount                  = 0;
    DWORD           cchValue                = MAX_PATH;
    TCHAR           szValueBuf[MAX_PATH]    = {0};
    TCHAR           szKeyBuf[MAX_PATH]      = {0};
    BOOL            bOverwriteExisting      = FALSE;
    LONG            rVal                    = 0;
    HKEY            hKey                    = NULL;
    HKEY            hCommandKey             = NULL;
    TypeCommand*    pTypeCommand            = NULL;
    int             iCommandCount           = 0;
    OSVERSIONINFO   osv;

    DBG_ENTER(TEXT("CreatePrintToVerb"),uiRet);

    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        uiRet = GetLastError();
        VERBOSE(GENERAL_ERR, 
                _T("GetVersionEx failed: (ec=%d)"),
                uiRet);
        goto exit;
    }

    if (osv.dwPlatformId==VER_PLATFORM_WIN32_NT)
    {
        VERBOSE (DBG_MSG, _T("This is NT4/NT5"));
        pTypeCommand = tcWin2KCommand;
        iCommandCount = iCountWin2KCommands;
    }
    else if (osv.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS)
    {
        if (osv.dwMinorVersion>=90)
        {
            VERBOSE (DBG_MSG, _T("This is WinME"));
            pTypeCommand = tcWinMECommand;
            iCommandCount = iCountWinMECommands;
            bOverwriteExisting = TRUE;
        }
        else
        {
            VERBOSE (DBG_MSG, _T("This is Win9X"));
            pTypeCommand = tcWin9XCommand;
            iCommandCount = iCountWin9XCommands;
        }
    }
    else
    {
        VERBOSE (GENERAL_ERR, _T("This is an illegal OS"));
        uiRet = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    for (iCount=0; iCount<iCommandCount; iCount++)
    {
        _tcscpy(szKeyBuf,pTypeCommand[iCount].lpctstrType);
        _tcscat(szKeyBuf,lpctstrPrintToCommand);

        // go get the appropriate folder from Windows Installer
        if (!PrivateMsiGetProperty( hInstall,
                                    pTypeCommand[iCount].lpctstrFolder,
                                    szValueBuf))
        {
            VERBOSE (SETUP_ERR, 
                     TEXT("PrivateMsiGetProperty failed (ec: %ld)"),
                     GetLastError());
            goto exit;
        }

        if (_tcslen(szValueBuf)+_tcslen(pTypeCommand[iCount].lpctstrCommand)>=MAX_PATH-1)
        {
            VERBOSE (SETUP_ERR, 
                     TEXT("command to create is too long"));
            uiRet = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        _tcscat(szValueBuf,pTypeCommand[iCount].lpctstrCommand);

        // if we should not replace existing keys, let's check if it exists
        if (!bOverwriteExisting)
        {
            uiRet = RegOpenKey( HKEY_CLASSES_ROOT,
                                szKeyBuf,
                                &hKey);
            if (uiRet==ERROR_SUCCESS) 
            {
                // this means we should skip this key
                RegCloseKey(hKey);
                VERBOSE(DBG_MSG, 
                        _T("RegOpenKey:PrintTo succedded, no change in PrintTo verb for %s"),
                        pTypeCommand[iCount].lpctstrType);
                continue;
            }
            else
            {
                if (uiRet==ERROR_FILE_NOT_FOUND)
                {
                    VERBOSE(DBG_MSG, 
                            _T("PrintTo verb does not exist for %s, creating..."),
                            pTypeCommand[iCount].lpctstrType);
                }
                else
                {
                    VERBOSE (REGISTRY_ERR, 
                             TEXT("Could not open registry key %s (ec=0x%08x)"), 
                             szKeyBuf,
                             uiRet);
                    goto exit;
                }
            }
        }
        // if we're here, we should create the key
        uiRet = RegCreateKey(   HKEY_CLASSES_ROOT,
                                szKeyBuf,
                                &hCommandKey);
        if (uiRet!=ERROR_SUCCESS) 
        {
            VERBOSE (REGISTRY_ERR, 
                     TEXT("Could not create registry key %s (ec=0x%08x)"), 
                     szKeyBuf,
                     uiRet);
            goto exit;
        }

        uiRet = RegSetValue(hCommandKey,
                            NULL,
                            REG_SZ,
                            szValueBuf,
                            sizeof(szValueBuf));
        if (uiRet==ERROR_SUCCESS) 
        {
            VERBOSE(DBG_MSG, 
                    _T("RegSetValue success: %s "),
                    szValueBuf);
        }
        else
        {
            VERBOSE (REGISTRY_ERR, 
                     TEXT("Could not set value registry key %s\\shell\\printto\\command to %s (ec=0x%08x)"), 
                     pTypeCommand[iCount].lpctstrType,
                     szValueBuf,
                     uiRet);
            goto exit;
        }

        if (hKey)
        {
            RegCloseKey(hKey);
        }
        if (hCommandKey)
        {
            RegCloseKey(hCommandKey);
        }
    }

exit:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    if (hCommandKey)
    {
        RegCloseKey(hCommandKey);
    }

    return uiRet;
}

/*-----------------------------------------------------------------*/ 
/* DPSetDefaultPrinter                                             */ 
/*                                                                 */ 
/* Parameters:                                                     */ 
/*   pPrinterName: Valid name of existing printer to make default. */ 
/*                                                                 */ 
/* Returns: TRUE for success, FALSE for failure.                   */ 
/*-----------------------------------------------------------------*/ 
BOOL SetDefaultPrinter(LPTSTR pPrinterName)
{
    OSVERSIONINFO   osv;
    DWORD           dwNeeded        = 0;
    HANDLE          hPrinter        = NULL;
    PPRINTER_INFO_2 ppi2            = NULL;
    LPTSTR          pBuffer         = NULL;
    BOOL            bRes            = TRUE;
    PPRINTER_INFO_2 pPrinterInfo    = NULL;
    DWORD dwNumPrinters             = 0;

    DBG_ENTER(TEXT("SetDefaultPrinter"),bRes);

    // What version of Windows are you running?
    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osv))
    {
        VERBOSE(GENERAL_ERR, 
                _T("GetVersionEx failed: (ec=%d)"),
                GetLastError());
        bRes = FALSE;
        goto exit;
    }

    // If Windows NT, use WriteProfileString for version 4.0 and earlier...
    if (osv.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        VERBOSE (DBG_MSG, 
                 TEXT("W9X OS, not setting default printer"));
        goto exit;
    }

    if (osv.dwMajorVersion >= 5) // Windows 2000 or later...
    {
        VERBOSE (DBG_MSG, 
                 TEXT("W2K OS, not setting default printer"));
        goto exit;
    }

    // are we the only printer installed?
    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,
                                                    2,
                                                    &dwNumPrinters,
                                                    PRINTER_ENUM_CONNECTIONS | PRINTER_ENUM_LOCAL
                                                    );
    if (!pPrinterInfo)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("MyEnumPrinters() failed (ec: %ld)"), 
                 GetLastError());

        bRes = FALSE;
        goto exit;
    }

    if (dwNumPrinters!=1)
    {
        VERBOSE (DBG_MSG, 
                 TEXT("More than one printer installed on NT4, not setting default printer"));
        goto exit;
    }
    // Open this printer so you can get information about it...
    if (!OpenPrinter(pPrinterName, &hPrinter, NULL))
    {
        VERBOSE(GENERAL_ERR, 
                _T("OpenPrinter failed: (ec=%d)"),
                GetLastError());
        bRes = FALSE;
        goto exit;
    }
    // The first GetPrinter() tells you how big our buffer should
    // be in order to hold ALL of PRINTER_INFO_2. Note that this will
    // usually return FALSE. This only means that the buffer (the 3rd
    // parameter) was not filled in. You don't want it filled in here...
    if (!GetPrinter(hPrinter, 2, 0, 0, &dwNeeded))
    {
        if (GetLastError()!=ERROR_INSUFFICIENT_BUFFER)
        {
            VERBOSE(GENERAL_ERR, 
                    _T("GetPrinter failed: (ec=%d)"),
                    GetLastError());
            bRes = FALSE;
            goto exit;
        }
    }

    // Allocate enough space for PRINTER_INFO_2...
    ppi2 = (PRINTER_INFO_2 *)MemAlloc(dwNeeded);
    if (!ppi2)
    {
        VERBOSE(GENERAL_ERR, 
                _T("MemAlloc failed"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bRes = FALSE;
        goto exit;
    }

    // The second GetPrinter() fills in all the current<BR/>
    // information...
    if (!GetPrinter(hPrinter, 2, (LPBYTE)ppi2, dwNeeded, &dwNeeded))
    {
        VERBOSE(GENERAL_ERR, 
                _T("GetPrinter failed: (ec=%d)"),
                GetLastError());
        bRes = FALSE;
        goto exit;
    }
    if ((!ppi2->pDriverName) || (!ppi2->pPortName))
    {
        VERBOSE(GENERAL_ERR, 
                _T("pDriverName or pPortNameare NULL"));
        SetLastError(ERROR_INVALID_PARAMETER);
        bRes = FALSE;
        goto exit;
    }

    // Allocate buffer big enough for concatenated string.
    // String will be in form "printername,drivername,portname"...
    pBuffer = (LPTSTR)MemAlloc( _tcslen(pPrinterName) +
                                _tcslen(ppi2->pDriverName) +
                                _tcslen(ppi2->pPortName) + 3);
    if (!pBuffer)
    {
        VERBOSE(GENERAL_ERR, 
                _T("MemAlloc failed"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bRes = FALSE;
        goto exit;
    }

    // Build string in form "printername,drivername,portname"...
    _tcscpy(pBuffer, pPrinterName);  
    _tcscat(pBuffer, _T(","));
    _tcscat(pBuffer, ppi2->pDriverName);  
    _tcscat(pBuffer, _T(","));
    _tcscat(pBuffer, ppi2->pPortName);

    // Set the default printer in Win.ini and registry...
    if (!WriteProfileString(_T("windows"), _T("device"), pBuffer))
    {
        VERBOSE(GENERAL_ERR, 
                _T("WriteProfileString failed: (ec=%d)"),
                GetLastError());
        bRes = FALSE;
        goto exit;
    }

    // Tell all open applications that this change occurred. 
    // Allow each app 1 second to handle this message.
    if (!SendMessageTimeout(    HWND_BROADCAST, 
                                WM_SETTINGCHANGE, 
                                0L, 
                                0L,
                                SMTO_NORMAL, 
                                1000, 
                                NULL))
    {
        VERBOSE(GENERAL_ERR, 
                _T("SendMessageTimeout failed: (ec=%d)"),
                GetLastError());
        bRes = FALSE;
        goto exit;
    }
  
exit:
    // Cleanup...
    if (pPrinterInfo)
    {
        MemFree(pPrinterInfo);
    }
    if (hPrinter)
    {
        ClosePrinter(hPrinter);
    }
    if (ppi2)
    {
        MemFree(ppi2);
    }
    if (pBuffer)
    {
        MemFree(pBuffer);
    }
  
    return bRes;
} 


// 
//
// Function:    CheckForceReboot
//
// Description: This function checks if the ForceReboot flag is set in the registry
//              if it is, signals WindowsInstaller that a reboot is needed
//
// Remarks:     
//              this is due to a bug in the Install Shield bootstrap which doesn't
//              force a reboot after initial installation of WindowsIsntaller.
//              this flag is set by our custom bootstrap before running the 
//              Install Shield bootstrap
//              if we are run from the Application Launcher then we need to leave 
//              this registry entry for the Launcher to reboot, we know this by 
//              using the property APPLAUNCHER=TRUE
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall CheckForceReboot(MSIHANDLE hInstall)
{
    UINT    uiRet   = ERROR_SUCCESS;
    TCHAR   szPropBuffer[MAX_PATH] = {0};
    HKEY    hKey    = NULL;
    DWORD   Size    = sizeof(DWORD);
    DWORD   Value   = 0;
    LONG    Rslt;
    DWORD   Type;

    DBG_ENTER(TEXT("CheckForceReboot"),uiRet);

    // check if we're running from the AppLauncher
    if (!PrivateMsiGetProperty(hInstall,_T("APPLAUNCHER"),szPropBuffer))
    {
        VERBOSE (SETUP_ERR, 
                 TEXT("PrivateMsiGetProperty failed (ec: %ld)"),
                 GetLastError());
        goto exit;
    }
    if (_tcscmp(szPropBuffer,_T("TRUE"))==0)
    {
        // we're running from the Application Launcher, the registry entry DeferredReboot
        // is sufficient.
         VERBOSE(DBG_MSG, 
                _T("AppLauncher will take care of any needed boot"));
        goto exit;
    }
   // open HKLM\\Software\\Microsoft\\SharedFax
    Rslt = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_SETUP,
        0,
        KEY_READ,
        &hKey
        );
    if (Rslt != ERROR_SUCCESS) 
	{
         VERBOSE(DBG_MSG, 
                _T("RegOpenKeyEx failed: (ec=%d)"),
                GetLastError());
        goto exit;
    }

    // check if ForceReboot flag exists
    Rslt = RegQueryValueEx(
        hKey,
        DEFERRED_BOOT,
        NULL,
        &Type,
        (LPBYTE) &Value,
        &Size
        );
    if (Rslt!=ERROR_SUCCESS) 
	{
         VERBOSE(DBG_MSG, 
                _T("RegQueryValueEx failed: (ec=%d)"),
                GetLastError());
        goto exit;
    }

    // tell WindowsInstaller a reboot is needed
    uiRet = MsiSetProperty(hInstall,_T("REBOOT"),_T("Force"));
    if (uiRet!=ERROR_SUCCESS) 
	{
         VERBOSE(DBG_MSG, 
                _T("MsiSetProperty failed: (ec=%d)"),
                uiRet);
        goto exit;
    }

    // delete ForceReboot flag
    Rslt = RegDeleteValue(hKey,DEFERRED_BOOT);
    if (Rslt!=ERROR_SUCCESS) 
	{
         VERBOSE(DBG_MSG, 
                _T("MsiSetMode failed: (ec=%d)"),
                Rslt);
        goto exit;
    }

exit:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    return uiRet;
}


#define KODAKPRV_EXE_NAME       _T("\\KODAKPRV.EXE")
#define TIFIMAGE_COMMAND_KEY    _T("TIFImage.Document\\shell\\open\\command")
#define TIFIMAGE_DDEEXEC_KEY    _T("TIFImage.Document\\shell\\open\\ddeexec")
// 
//
// Function:    ChangeTifAssociation
//
// Description: This function changes the open verb for TIF files 
//              on WinME from Image Preview to Kodak Imaging
//
// Remarks:     
//              this is due to bad quality of viewing TIF faxes in the Image Preview tool
//
// Args:
//
//              hInstall                : Handle from MSI, can get state of the current setup
//
// Author:      MoolyB
DLL_API UINT __stdcall ChangeTifAssociation(MSIHANDLE hInstall)
{
    UINT            uiRet                           = ERROR_SUCCESS;
    TCHAR           szWindowsDirectory[MAX_PATH]    = {0};
    HANDLE          hFind                           = INVALID_HANDLE_VALUE;
    HKEY            hKey                            = NULL;
    LONG            lRet                            = 0;
    OSVERSIONINFO   viVersionInfo;
    WIN32_FIND_DATA FindFileData;

    DBG_ENTER(TEXT("ChangeTifAssociation"),uiRet);

    viVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&viVersionInfo))
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("GetVersionEx failed (ec: %ld)"),
                 uiRet);
        goto exit;
   }

    // Is this millennium?
    if (!
        (   (viVersionInfo.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS) && 
            (viVersionInfo.dwMajorVersion==4) && 
            (viVersionInfo.dwMinorVersion>=90)
        )
       )
    {
        VERBOSE(DBG_MSG, 
                _T("This is not Windows Millenium, exit fucntion"));
        goto exit;
    }

    // find <WindowsFolder>\KODAKPRV.EXE 
    if (GetWindowsDirectory(szWindowsDirectory,MAX_PATH)==0)
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("GetWindowsDirectory failed (ec: %ld)"),
                 uiRet);
        goto exit;
    }

    if (_tcslen(KODAKPRV_EXE_NAME)+_tcslen(szWindowsDirectory)>=MAX_PATH-4)
    {
        VERBOSE( SETUP_ERR, 
                 TEXT("Path to Kodak Imaging too long"));
        uiRet = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    _tcscat(szWindowsDirectory,KODAKPRV_EXE_NAME);

    hFind = FindFirstFile(szWindowsDirectory, &FindFileData);

    if (hFind==INVALID_HANDLE_VALUE) 
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("FindFirstFile %s failed (ec: %ld)"),
                 szWindowsDirectory,
                 uiRet);
        goto exit;
    }

    FindClose(hFind);

    _tcscat(szWindowsDirectory,_T(" \"%1\""));

    // set open verb
    lRet = RegOpenKey(  HKEY_CLASSES_ROOT,
                        TIFIMAGE_COMMAND_KEY,
                        &hKey);
    if (lRet!=ERROR_SUCCESS)
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("RegOpenKey %s failed (ec: %ld)"),
                 TIFIMAGE_COMMAND_KEY,
                 uiRet);
        goto exit;
    }

    lRet = RegSetValueEx(   hKey,
                            NULL,
                            0,
                            REG_EXPAND_SZ,
                            (LPBYTE) &szWindowsDirectory,
                            sizeof(szWindowsDirectory)
                        );
    if (lRet!=ERROR_SUCCESS)
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("RegSetValueEx %s failed (ec: %ld)"),
                 szWindowsDirectory,
                 uiRet);

        goto exit;
    }

    lRet = RegDeleteKey(HKEY_CLASSES_ROOT,TIFIMAGE_DDEEXEC_KEY);
    if (lRet!=ERROR_SUCCESS)
    {
        uiRet = GetLastError();
        VERBOSE( SETUP_ERR, 
                 TEXT("RegDeleteKey %s failed (ec: %ld)"),
                 TIFIMAGE_DDEEXEC_KEY,
                 uiRet);

        goto exit;
    }


exit:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    return uiRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\inc\faxsetup.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

	faxSetup.h

Abstract:

	Header file for definitions common for the setup

Author:

	Iv Garber (IvG)	Mar, 2001

Revision History:

--*/

#ifndef _FXSETUP_H_
#define _FXSETUP_H_

#include "msi.h"

typedef INSTALLSTATE (WINAPI *PF_MSIQUERYPRODUCTSTATE) (LPCTSTR szProduct);


#define PRODCODE_SBS50CLIENT    _T("{E0ED877D-EA6A-4274-B0CB-99CD929A92C1}")
#define PRODCODE_XPDLCLIENT     _T("{BCF670F5-3034-4d11-9D7C-6092572EFD1E}")
#define PRODCODE_SBS50SERVER    _T("{A41E15DA-AD35-43EF-B9CC-FE948F1F04C0}")


#define FAX_INF_NAME        _T("FXSOCM.INF")
#define WINDOWS_INF_DIR     _T("INF")
#define FAX_INF_PATH        _T("\\") WINDOWS_INF_DIR _T("\\") FAX_INF_NAME


#define REGKEY_ACTIVE_SETUP_NT                      _T("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{8b15971b-5355-4c82-8c07-7e181ea07608}")
#define REGVAL_ACTIVE_SETUP_PER_USER_APP_UPGRADE    _T(".AppUpgrade")

//
//  Unattended Answer File Section and Keys
//
#define     UNATTEND_FAX_SECTION            _T("Fax")

//
//  Used in Migrate.DLL to write the fax applications that were installed before the upgrade blocked them.
//  Then used in OCM to know what was installed before the Upgrade and behave accordingly ( Where Did My Fax Go )
//
#define     UNINSTALLEDFAX_INFKEY           _T("UninstalledFaxApps")


//
//  Typedef used during the Migration and OCM parts of Upgrade to define which Fax Applications are/were installed
//
typedef enum fxState_UpgradeApp_e
{
    FXSTATE_UPGRADE_APP_NONE            = 0x00,
    FXSTATE_UPGRADE_APP_SBS50_CLIENT    = 0x01,
    FXSTATE_UPGRADE_APP_SBS50_SERVER    = 0x02,
    FXSTATE_UPGRADE_APP_XP_CLIENT       = 0x04
};


DWORD CheckInstalledFax(bool *pbSBSClient, bool *pbXPDLCient, bool *pbSBSServer);


#endif  // _FXSETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\inc\setuputil.h ===
//File: setuputil.h
#include <TCHAR.h>
#include <windows.h>
#include <stdio.h>
#include <Msi.h>
#include <DebugEx.h>

#define MIGRATION_KEY			TEXT("Software\\Microsoft\\Fax\\Migration")
#define SETUP_KEY			TEXT("Software\\Microsoft\\Fax\\Setup")
#define MIGRATION_COVER_PAGES		TEXT("CoverPagesDirectory")
#define NEW_COVER_PAGES			TEXT("CoverPageDir")
#define REGKEY_SBS45_W9X_ARP    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\FaxWizardDeinstKey")
#define REGKEY_SBS45_W9X_CLIENT TEXT("SOFTWARE\\Microsoft\\Microsoft Fax Server Client")

#define ADDINS_DIRECTORY    _T("Addins\\")
#define FXSEXT_ECF_FILE     _T("FXSEXT.ecf")
#define DEFERRED_BOOT       _T("DeferredBoot")
#define REGKEY_SETUP        REGKEY_FAXSERVER _T("\\Setup")

BOOL
IsTheSameFileAlreadyExist(
	LPCTSTR lpctstrSourceDirectory,
	LPCTSTR lpctstrDestinationDirectory,
	LPCTSTR lpctstrFileName			
	);

BOOL
CopyCoverPagesFiles(
	LPCTSTR lpctstrSourceDirectory,
	LPCTSTR lpctstrDestinationDirectory,
	LPCTSTR lpctstrPrefix,
	BOOL	fCheckIfExist
	);

BOOL
CompleteToFullPathInSystemDirectory(
	LPTSTR  lptstrFullPath,
	LPCTSTR lptstrFileName
	);

//
// fax common setup routines
//

BOOL PrivateMsiGetProperty
(
    MSIHANDLE hInstall,    // installer handle
    LPCTSTR szName,        // property identifier, case-sensitive
    LPTSTR szValueBuf      // buffer for returned property value
);


BOOL
DeleteFaxPrinter(
    LPCTSTR lptstrFaxPrinterName	// name of the printer to delete
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\client\ism\makefile.inc ===
all: ISM2MSI
ISM2MSI: ClientSetup.ism 
!ifdef LINKONLY
	ism2msi.cmd
!else
	ech Pass 1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\faxcontrol.cpp ===
// FaxControl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f FaxControlps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "FaxControl.h"

#include "FaxControl_i.c"
#include "IFaxControl.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_FaxControl, CFaxControl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL FaxControl_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_FAXCONTROLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\faxocm.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       faxocm.h
//
// Abstract:        Header file used by Faxocm source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FAXOCM_H_
#define _FAXOCM_H_

#include <windows.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <winspool.h>
#include <tapi.h>
#include <shlobj.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <sddl.h>
#include <advpub.h>

#include "fxsapip.h"

#define NO_FAX_LIST
#include "faxutil.h"
#include "faxreg.h"
#include "debugex.h"
#include "routemapi.h"

#include "resource.h"

// submodule include files
#include "fxconst.h"
#include "fxocDbg.h"
#include "fxocFile.h"
#include "fxocLink.h"
#include "fxState.h"
#include "fxocMapi.h"
#include "fxocPrnt.h"
#include "fxocReg.h"
#include "fxocSvc.h"
#include "fxocUtil.h"
#include "fxUnatnd.h"
#include "fxocUpgrade.h"

// some useful macros
#define SecToNano(_sec)             (DWORDLONG)((_sec) * 1000 * 1000 * 10)
#define MinToNano(_min)             SecToNano((_min)*60)


BOOL                faxocm_IsInited(void);
HINSTANCE           faxocm_GetAppInstance(void);
DWORD               faxocm_GetComponentID(TCHAR     *pszComponentID,
                                          DWORD     dwNumBufChars);
HINF                faxocm_GetComponentInf(void);
BOOL                faxocm_GetComponentInfName(TCHAR* szInfFileName);
HSPFILEQ            faxocm_GetComponentFileQueue(void);
DWORD               faxocm_GetComponentSetupMode(void);
DWORDLONG           faxocm_GetComponentFlags(void);
UINT                faxocm_GetComponentLangID(void);
DWORD               faxocm_GetComponentSourcePath(TCHAR *pszSourcePath,
                                                  DWORD dwNumBufChars);
DWORD               faxocm_GetComponentUnattendFile(TCHAR *pszUnattendFile,
                                                  DWORD dwNumBufChars);
DWORD               faxocm_GetProductType(void);
OCMANAGER_ROUTINES* faxocm_GetComponentHelperRoutines(void);
EXTRA_ROUTINES*     faxocm_GetComponentExtraRoutines(void);
void faxocm_GetVersionInfo(DWORD *pdwExpectedOCManagerVersion,
                           DWORD *pCurrentOCManagerVersion);

DWORD faxocm_HasSelectionStateChanged(LPCTSTR pszSubcomponentId,
                                      BOOL    *pbSelectionStateChanged,
                                      BOOL    *pbCurrentlySelected,
                                      BOOL    *pbOriginallySelected);

typedef enum
{
    REPORT_FAX_INSTALLED,       // Report fax is installed
    REPORT_FAX_UNINSTALLED,     // Report fax is uninstalled
    REPORT_FAX_DETECT           // Detect fax installation state and report it
} FaxInstallationReportType;

extern FaxInstallationReportType g_InstallReportType /* = REPORT_FAX_DETECT*/;

#endif  // _FAXOCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxconst.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxconst.cpp
//
// Abstract:        File containing constants used by Fax OCM.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 24-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////

#include "faxocm.h"

// used for determining the fax service's name
LPCTSTR INF_KEYWORD_ADDSERVICE                = _T("AddService");
LPCTSTR INF_KEYWORD_DELSERVICE                = _T("DelService");

// used for creating the Inbox and SentItems archive directories
LPCTSTR INF_KEYWORD_CREATEDIR                 = _T("CreateDir");
LPCTSTR INF_KEYWORD_DELDIR                    = _T("DelDir");

LPCTSTR INF_KEYWORD_CREATESHARE               = _T("CreateShare");
LPCTSTR INF_KEYWORD_DELSHARE                  = _T("DelShare");

LPCTSTR INF_KEYWORD_PATH                      = _T("Path");
LPCTSTR INF_KEYWORD_NAME                      = _T("Name");
LPCTSTR INF_KEYWORD_COMMENT                   = _T("Comment");
LPCTSTR INF_KEYWORD_PLATFORM                  = _T("Platform");
LPCTSTR INF_KEYWORD_ATTRIBUTES                = _T("Attributes");
LPCTSTR INF_KEYWORD_SECURITY                  = _T("Security");

LPCTSTR INF_KEYWORD_PROFILEITEMS_PLATFORM     = _T("ProfileItems_Platform");
LPCTSTR INF_KEYWORD_REGISTER_DLL_PLATFORM     = _T("RegisterDlls_Platform");
LPCTSTR INF_KEYWORD_UNREGISTER_DLL_PLATFORM   = _T("UnregisterDlls_Platform");
LPCTSTR INF_KEYWORD_ADDREG_PLATFORM           = _T("AddReg_Platform");
LPCTSTR INF_KEYWORD_COPYFILES_PLATFORM        = _T("CopyFiles_Platform");

// Returned by "GetInstallType"
// once the type of install has been determined, we search for 
// the appropriate section below to begin the type of install we need.
LPCTSTR INF_KEYWORD_INSTALLTYPE_UNINSTALL     = _T("FaxUninstall");
LPCTSTR INF_KEYWORD_INSTALLTYPE_CLEAN         = _T("FaxCleanInstall");
LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMWIN9X  = _T("FaxUpgradeFromWin9x");
LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMWINNT  = _T("FaxUpgradeFromWinNT");
LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMWIN2K  = _T("FaxUpgradeFromWin2K");
LPCTSTR INF_KEYWORD_INSTALLTYPE_CLIENT        = _T("FaxClientInstall");
LPCTSTR INF_KEYWORD_INSTALLTYPE_CLIENT_UNINSTALL = _T("FaxClientUninstall");
LPCTSTR INF_KEYWORD_RUN                       = _T("Run");
LPCTSTR INF_KEYWORD_COMMANDLINE               = _T("CommandLine");
LPCTSTR INF_KEYWORD_TICKCOUNT                 = _T("TickCount");

LPCTSTR INF_SECTION_FAX_CLIENT                = _T("Fax.Client");
LPCTSTR INF_SECTION_FAX                       = _T("Fax");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxconst.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxconst.h
//
// Abstract:        Contains extern'd constants for use by faxocm
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 24-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXCONST_H_
#define _FXCONST_H_

// used for determining the fax service's name
extern LPCTSTR INF_KEYWORD_ADDSERVICE;
extern LPCTSTR INF_KEYWORD_DELSERVICE;

// used for creating the Inbox and SentItems archive directories
extern LPCTSTR INF_KEYWORD_CREATEDIR;
extern LPCTSTR INF_KEYWORD_DELDIR;

extern LPCTSTR INF_KEYWORD_CREATESHARE;
extern LPCTSTR INF_KEYWORD_DELSHARE;

extern LPCTSTR INF_KEYWORD_PATH;
extern LPCTSTR INF_KEYWORD_NAME;
extern LPCTSTR INF_KEYWORD_COMMENT;
extern LPCTSTR INF_KEYWORD_PLATFORM;
extern LPCTSTR INF_KEYWORD_ATTRIBUTES;
extern LPCTSTR INF_KEYWORD_SECURITY;

extern LPCTSTR INF_KEYWORD_PROFILEITEMS_PLATFORM;
extern LPCTSTR INF_KEYWORD_REGISTER_DLL_PLATFORM;
extern LPCTSTR INF_KEYWORD_UNREGISTER_DLL_PLATFORM;
extern LPCTSTR INF_KEYWORD_ADDREG_PLATFORM;
extern LPCTSTR INF_KEYWORD_COPYFILES_PLATFORM;

// once the type of install has been determined, we search for 
// the appropriate section below to begin the type of install we need.
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_UNINSTALL;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_CLEAN;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMWIN9X;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMWINNT;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_UPGFROMWIN2K;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_CLIENT;
extern LPCTSTR INF_KEYWORD_INSTALLTYPE_CLIENT_UNINSTALL;
extern LPCTSTR INF_SECTION_FAX_CLIENT;
extern LPCTSTR INF_SECTION_FAX;

extern LPCTSTR INF_KEYWORD_RUN;
extern LPCTSTR INF_KEYWORD_COMMANDLINE;
extern LPCTSTR INF_KEYWORD_TICKCOUNT;


#endif  // _FXCONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\faxocm.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       faxocm.cpp
//
// Abstract:        This file implements the OCM setup for fax.
//
// Environment:     windows XP / User Mode
//
// Coding Style:    Any function, variable, or typedef preceded with the 
//                  "prv_" prefix (short for "local"), implies that 
//                  it is visible only within the scope of this file.
//                  For functions and variables, it implies they are 
//                  static.
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created from old faxocm.cpp by wesx
//////////////////////////////////////////////////////////////////////////////

#include "faxocm.h"

#pragma hdrstop

#include <shellapi.h>
#include <systrayp.h>
/////////////////////////////// Local Defines ////////////////////////////

#define prv_TOTAL_NUM_PROGRESS_BAR_TICKS    10

// These two are defined in %SDXROOT%\SHELL\EXT\SYSTRAY\DLL\systray.h too.
// This is a duplicate definition that has to remain in sync.
// We don't use the systray.h because we have local builds and we're
// not enlisted on the whole project.
#define FAX_STARTUP_TIMER_ID            7
#define FAX_SHUTDOWN_TIMER_ID          99


///////////////////////////////
// prv_Component_t
//
// Stores the information we 
// get from the OC Manager 
// for use by the rest of the
// faxocm.dll. 
//
typedef struct prv_Component_t
{
    DWORD                   dwExpectedOCManagerVersion;
    TCHAR                   szComponentID[255 + 1];
    HINF                    hInf;
    DWORD                   dwSetupMode;
    DWORDLONG               dwlFlags;
    UINT                    uiLanguageID;
    TCHAR                   szSourcePath[_MAX_PATH + _MAX_FNAME + 1];
    TCHAR                   szUnattendFile[_MAX_PATH + _MAX_FNAME + 1];
    OCMANAGER_ROUTINES      Helpers;
    EXTRA_ROUTINES          Extras;
    HSPFILEQ                hQueue;
    DWORD                   dwProductType;
} prv_Component_t;

///////////////////////////////
// prv_GVAR
//
// Global variables visible
// only within this file
// scope.
//
static struct prv_GVAR
{
    BOOL                    bInited;
    HINSTANCE               hInstance;
    DWORD                   dwCurrentOCManagerVersion;
    prv_Component_t         Component;
} prv_GVAR = 
{
    FALSE,          //  bInited
    NULL           //  hInstance
};

//
// Delay Load support
//
#include <delayimp.h>

EXTERN_C
FARPROC
WINAPI
DelayLoadFailureHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    );

PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;

//////////////////// Static Function Prototypes //////////////////////////////

static void prv_UpdateProgressBar(DWORD dwNumTicks);
static DWORD prv_GetSectionToProcess(const TCHAR *pszCurrentSection,
                                     TCHAR       *pszSectionToProcess,
                                     DWORD       dwNumBufChars);

static DWORD prv_ValidateVersion(SETUP_INIT_COMPONENT *pSetupInit);

static DWORD prv_SetSetupData(const TCHAR          *pszComponentId,
                              SETUP_INIT_COMPONENT *pSetupInit);

static DWORD prv_OnPreinitialize(void);
static DWORD prv_OnInitComponent(LPCTSTR               pszComponentId, 
                                 SETUP_INIT_COMPONENT  *pSetupInitComponent);
static DWORD prv_OnExtraRoutines(LPCTSTR            pszComponentId, 
                                 EXTRA_ROUTINES    *pExtraRoutines);
static DWORD prv_OnSetLanguage(UINT uiLanguageID);
static DWORD_PTR prv_OnQueryImage(void);
static DWORD prv_OnSetupRequestPages(UINT uiType, 
                                     void *pSetupRequestPages);
static DWORD prv_OnWizardCreated(void);
static DWORD prv_OnQuerySkipPage(void);
static DWORD prv_OnQuerySelStateChange(LPCTSTR pszComponentId,
                                       LPCTSTR pszSubcomponentId,
                                       UINT    uiState,
                                       UINT    uiFlags);
static DWORD prv_OnCalcDiskSpace(LPCTSTR   pszComponentId,
                                 LPCTSTR   pszSubcomponentId,
                                 DWORD     addComponent,
                                 HDSKSPC   dspace);
static DWORD prv_OnQueueFileOps(LPCTSTR    pszComponentId, 
                                LPCTSTR    pszSubcomponentId, 
                                HSPFILEQ   hQueue);
static DWORD prv_OnNotificationFromQueue(void);

static DWORD prv_OnQueryStepCount(LPCTSTR pszComponentId,
                                  LPCTSTR pszSubcomponentId);

static DWORD prv_OnCompleteInstallation(LPCTSTR pszComponentId, 
                                        LPCTSTR pszSubcomponentId);
static DWORD prv_OnCleanup(void);
static DWORD prv_OnQueryState(LPCTSTR pszComponentId,
                              LPCTSTR pszSubcomponentId,
                              UINT    uiState);
static DWORD prv_OnNeedMedia(void);
static DWORD prv_OnAboutToCommitQueue(LPCTSTR pszComponentId, 
                                      LPCTSTR pszSubcomponentId);
static DWORD prv_RunExternalProgram(LPCTSTR pszComponent,
                                    DWORD   state);
static DWORD prv_EnumSections(HINF          hInf,
                              const TCHAR   *component,
                              const TCHAR   *key,
                              DWORD         index,
                              INFCONTEXT    *pic,
                              TCHAR         *name);

static DWORD prv_CleanupNetShares(LPCTSTR   pszComponent,
                                  DWORD     state);

static DWORD prv_CompleteFaxInstall(const TCHAR *pszSubcomponentId,
                                    const TCHAR *pszInstallSection);

static DWORD prv_CompleteFaxUninstall(const TCHAR *pszSubcomponentId,
                                      const TCHAR *pszUninstallSection);

static DWORD prv_UninstallFax(const TCHAR *pszSubcomponentId,
                              const TCHAR *pszUninstallSection);

static DWORD prv_NotifyStatusMonitor(WPARAM wParam);

static DWORD prv_ShowUninstalledFaxShortcut(void);


///////////////////////////////
// faxocm_IsInited
//
// Returns TRUE if OCM is
// initialized, FALSE, otherwise
//
// Params:
//      - void
// Returns:
//      - TRUE if initialized.
//      - FALSE otherwise.
//
BOOL faxocm_IsInited(void)
{
    return prv_GVAR.bInited;
}

///////////////////////////////
// faxocm_GetAppInstance
//
// Returns the hInstance of
// this DLL.
//
// Params:
//      - void
// Returns:
//      - Instance of this DLL.
//
HINSTANCE faxocm_GetAppInstance(void)
{
    return prv_GVAR.hInstance;
}

///////////////////////////////
// faxocm_GetComponentID
//
// Returns the Component ID 
// passed to us via the OC
// Manager
//
// Params:
//      - pszComponentID - ID of top level component
//      - dwNumBufChars  - # chars pszComponentID can hold
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise
//
DWORD faxocm_GetComponentID(TCHAR     *pszComponentID,
                            DWORD     dwNumBufChars)
{
    DWORD dwReturn = NO_ERROR;

    if ((pszComponentID == NULL) ||
        (dwNumBufChars  == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    _tcsncpy(pszComponentID, prv_GVAR.Component.szComponentID, dwNumBufChars);

    return dwReturn;
}

///////////////////////////////
// faxocm_GetComponentFileQueue
//
// Returns the file queue 
// given to us by the OC Manager
//
// The file queue is used by
// the Setup API functions for
// copying/deleting files.
//
// Params:
//      - void
// Returns:
//      - Handle to file queue
//
HSPFILEQ faxocm_GetComponentFileQueue(void)
{
    return prv_GVAR.Component.hQueue;
}

///////////////////////////////
// faxocm_GetComponentInfName
//
// Returns the full path to the
// faxsetup.inf file.
//
// Params:
//      - buffer to fill with path, must be at least MAX_PATH long
// Returns:
//      - NO_ERROR - in case of success
//      - Win32 Error code - otherwise
//
BOOL faxocm_GetComponentInfName(TCHAR* szInfFileName)
{
    BOOL bRes = TRUE;

    DBG_ENTER(_T("faxocm_GetComponentInfName"),bRes);

    (*szInfFileName) = NULL;

    if (GetWindowsDirectory(szInfFileName,MAX_PATH)==0)
    {
        CALL_FAIL(SETUP_ERR,TEXT("GetWindowsDirectory"),GetLastError());
        bRes = FALSE;
        goto exit;
    }

    if (_tcslen(szInfFileName)+_tcslen(FAX_INF_PATH)>(MAX_PATH-1))
    {
        VERBOSE(SETUP_ERR,_T("MAX_PATH too short to create INF path"));
        bRes = FALSE;
        goto exit;
    }
    _tcscat(szInfFileName,FAX_INF_PATH);

exit:
    return bRes;
}

///////////////////////////////
// faxocm_GetComponentInf
//
// Returns the handle to the
// faxsetup.inf file.
//
// Params:
//      - void
// Returns:
//      - Handle to faxsetup.inf file
//
HINF faxocm_GetComponentInf(void)
{
    return prv_GVAR.Component.hInf;
}

///////////////////////////////
// faxocm_GetComponentSetupMode
//
// Returns the setup mode as 
// given to us by OC Manager.
//
// Params:
//      - void.
// Returns:
//      - Setup mode as given to us by OC Manager
//
DWORD faxocm_GetComponentSetupMode(void)
{
    return prv_GVAR.Component.dwSetupMode;
}

///////////////////////////////
// faxocm_GetComponentFlags
//
// Returns the flags as 
// given to us by OC Manager.
//
// Params:
//      - void
// Returns:
//      - Flags as given to us by OC Manager
//
DWORDLONG faxocm_GetComponentFlags(void)
{
    return prv_GVAR.Component.dwlFlags;
}

///////////////////////////////
// faxocm_GetComponentLangID
//
// Returns the Language ID
// given to us by OC Manager.
//
// Params:
//      - void.
// Returns:
//      - Language ID as given to us by OC Manager
//
UINT faxocm_GetComponentLangID(void)
{
    return prv_GVAR.Component.uiLanguageID;
}

///////////////////////////////
// faxocm_GetComponentSourcePath
//
// Returns the Source Path
// given to us by OC Manager.
//
// Params:
//      - pszSourcePath - OUT - buffer to hold source path
//      - dwNumBufChars - # of characters pszSourcePath can hold.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD faxocm_GetComponentSourcePath(TCHAR *pszSourcePath,
                                    DWORD dwNumBufChars)
{
    DWORD dwReturn = NO_ERROR;

    if ((pszSourcePath == NULL) ||
        (dwNumBufChars == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    _tcsncpy(pszSourcePath, prv_GVAR.Component.szSourcePath, dwNumBufChars);

    return dwReturn;
}

///////////////////////////////
// faxocm_GetComponentUnattendFile
//
// Returns the Unattend Path
// given to us by OC Manager.
//
// Params:
//      - pszUnattendFile - OUT - buffer to hold unattend path
//      - dwNumBufChars - # of characters pszSourcePath can hold.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD faxocm_GetComponentUnattendFile(TCHAR *pszUnattendFile,
                                      DWORD dwNumBufChars)
{
    DWORD dwReturn = NO_ERROR;

    if ((pszUnattendFile == NULL) ||
        (dwNumBufChars == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    _tcsncpy(pszUnattendFile, prv_GVAR.Component.szUnattendFile, dwNumBufChars);

    return dwReturn;
}

////////////////////////////////////
// faxocm_GetComponentHelperRoutines
//
// Returns the pointer to the Helper
// data and functions as given to us
// by OC Manager.
//
// Params:
//      - void.
// Returns:
//      - Ptr to helper routines as given to us by OC Manager.
//
OCMANAGER_ROUTINES* faxocm_GetComponentHelperRoutines(void)
{
    return &prv_GVAR.Component.Helpers;
}

////////////////////////////////////
// faxocm_GetComponentExtraRoutines
//
// Returns the pointer to the Helper
// data and functions as given to us
// by OC Manager.
//
// Params:
//      - void
// Returns:
//      - Ptr to extra info as given to us by OC Manager.
//
EXTRA_ROUTINES* faxocm_GetComponentExtraRoutines(void)
{
    return &prv_GVAR.Component.Extras;
}

////////////////////////////////////
// faxocm_GetProductType
//
// Returns the product type as given
// to us by OC Manager.
//
// Params:
//      - void.
// Returns:
//      - Product type as given to us by OC Manager.
//
DWORD faxocm_GetProductType(void)
{
    return prv_GVAR.Component.dwProductType;
}

////////////////////////////////////
// faxocm_GetVersionInfo
//
// Returns the version # as given
// to us by OC Manager.
//
// Params:
//      - pdwExpectedOCManagerVersion - OUT - self explanatory.
//      - pdwCurrentOCManagerVersion - OUT - self explanatory.
// Returns:
//      - void.
//
void faxocm_GetVersionInfo(DWORD *pdwExpectedOCManagerVersion,
                           DWORD *pdwCurrentOCManagerVersion)
{
    if (pdwExpectedOCManagerVersion)
    {
        *pdwExpectedOCManagerVersion = 
                            prv_GVAR.Component.dwExpectedOCManagerVersion;
    }

    if (pdwCurrentOCManagerVersion)
    {
        *pdwCurrentOCManagerVersion = prv_GVAR.dwCurrentOCManagerVersion;
    }

    return;
}

extern "C"
BOOL FaxControl_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

///////////////////////////////
// DllMain
//
// DLL Entry Point
//
// Params:
//      hInstance   - Instance handle
//      Reason      - Reason for the entrypoint being called
//      Context     - Context record
//
// Returns:
//      TRUE        - Initialization succeeded
//      FALSE       - Initialization failed
//
extern "C"
DWORD DllMain(HINSTANCE     hInst,
              DWORD         Reason,
              LPVOID        Context)
{
    DBG_ENTER(_T("DllMain"));
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
            // initialize our global variables
            memset(&prv_GVAR, 0, sizeof(prv_GVAR));

            prv_GVAR.hInstance = hInst;

            // Initialize Debug Support
            //
            VERBOSE(DBG_MSG,_T("FxsOcm.dll loaded - DLL_PROCESS_ATTACH"));
            DisableThreadLibraryCalls(hInst);
        break;

        case DLL_PROCESS_DETACH:

            // terminate Debug Support
            VERBOSE(DBG_MSG,_T("FxsOcm.dll unloaded - DLL_PROCESS_DETACH"));
        break;

        default:
            VERBOSE(DBG_MSG,_T("DllMain, received some weird 'Reason' ")
                            _T("for this fn, Reason = %lu"), Reason);
        break;
    }
    //
    // Pass DllMain call to ATL supplied DllMain
    //
    return FaxControl_DllMain (hInst, Reason, Context);
}


///////////////////////////////
// FaxOcmSetupProc
//
// Entry point for OC Manager.
// 
// The OC Manager calls this function
// to drive this DLL.
//
// Params:
//      - pszComponentId - major component 
//      - pszSubcomponentId - component found if user presses "Details"
//      - uiFunction - what stage of setup we are in.
//      - uiParam1 - dependent on uiFunction - could be anything.
//      - pParam2  - dependent on uiFunction - could be anything.
//
// Returns:
//      DWORD indicating error or success.
//
//
DWORD_PTR FaxOcmSetupProc(IN LPWSTR     pszComponentId,
                          IN LPWSTR     pszSubcomponentId,
                          IN UINT       uiFunction,
                          IN UINT       uiParam1,
                          IN OUT PVOID  pParam2)
{
    DWORD_PTR rc = 0;
    DBG_ENTER(  _T("FaxOcmSetupProc"),
                _T("%s - %s"),
                pszComponentId,
                pszSubcomponentId);

    VERBOSE(DBG_MSG,    _T("FaxOcmSetup proc called with function '%s'"), 
                        fxocDbg_GetOcFunction(uiFunction));

    switch(uiFunction) 
    {
        case OC_PREINITIALIZE:
            rc = prv_OnPreinitialize();
        break;

        case OC_INIT_COMPONENT:
            rc = prv_OnInitComponent(pszComponentId, 
                                     (PSETUP_INIT_COMPONENT) pParam2);
        break;

        case OC_EXTRA_ROUTINES:
            rc = prv_OnExtraRoutines(pszComponentId, (PEXTRA_ROUTINES)pParam2);
        break;

        case OC_SET_LANGUAGE:
            rc = prv_OnSetLanguage(uiParam1);
        break;

        case OC_QUERY_IMAGE:
            // Argh!  I hate casting handles to DWORDs
            rc = prv_OnQueryImage();
        break;

        case OC_REQUEST_PAGES:
            rc = prv_OnSetupRequestPages(uiParam1, pParam2);
        break;

        case OC_QUERY_CHANGE_SEL_STATE:
            rc = prv_OnQuerySelStateChange(pszComponentId, 
                                           pszSubcomponentId, 
                                           uiParam1, 
                                           (UINT)((UINT_PTR)pParam2));
        break;

        case OC_CALC_DISK_SPACE:
            rc = prv_OnCalcDiskSpace(pszComponentId, 
                                     pszSubcomponentId, 
                                     uiParam1, 
                                     pParam2);

            // sometimes the OC Manager gives us NULL subcomponent IDs,
            // so just ignore them.
            if (rc == ERROR_INVALID_PARAMETER)
            {
                rc = NO_ERROR;
            }
        break;

        case OC_QUEUE_FILE_OPS:
            rc = prv_OnQueueFileOps(pszComponentId, 
                                    pszSubcomponentId, 
                                    (HSPFILEQ)pParam2);

            // OC Manager calls us twice on this function.  Once with a subcomponent ID
            // of NULL, and the second time with a subcomponent ID of "Fax".  
            // Since we are going to be called a second time with a valid ID (i.e. "Fax")
            // disregard the first call and process the second call.

            if (rc == ERROR_INVALID_PARAMETER)
            {
                rc = NO_ERROR;
            }
        break;

        case OC_NOTIFICATION_FROM_QUEUE:
            rc = prv_OnNotificationFromQueue();
        break;

        case OC_QUERY_STEP_COUNT:
            rc = prv_OnQueryStepCount(pszComponentId, pszSubcomponentId);

            // OC Manager calls us twice on this function.  Once with a subcomponent ID
            // of NULL, and the second time with a subcomponent ID of "Fax".  
            // Since we are going to be called a second time with a valid ID (i.e. "Fax")
            // disregard the first call and process the second call.

            if (rc == ERROR_INVALID_PARAMETER)
            {
                rc = NO_ERROR;
            }
        break;

        case OC_COMPLETE_INSTALLATION:
            rc = prv_OnCompleteInstallation(pszComponentId, pszSubcomponentId);

            // OC Manager calls us twice on this function.  Once with a subcomponent ID
            // of NULL, and the second time with a subcomponent ID of "Fax".  
            // Since we are going to be called a second time with a valid ID (i.e. "Fax")
            // disregard the first call and process the second call.

            if (rc == ERROR_INVALID_PARAMETER)
            {
                rc = NO_ERROR;
            }
        break;

        case OC_CLEANUP:
            rc = prv_OnCleanup();

            // OC Manager calls us twice on this function.  Once with a subcomponent ID
            // of NULL, and the second time with a subcomponent ID of "Fax".  
            // Since we are going to be called a second time with a valid ID (i.e. "Fax")
            // disregard the first call and process the second call.

            if (rc == ERROR_INVALID_PARAMETER)
            {
                rc = NO_ERROR;
            }
        break;

        case OC_QUERY_STATE:
            rc = prv_OnQueryState(pszComponentId, pszSubcomponentId, uiParam1);
        break;

        case OC_NEED_MEDIA:
            rc = prv_OnNeedMedia();
        break;

        case OC_ABOUT_TO_COMMIT_QUEUE:
            rc = prv_OnAboutToCommitQueue(pszComponentId, pszSubcomponentId);
        break;

        case OC_QUERY_SKIP_PAGE:
            rc = prv_OnQuerySkipPage();
        break;

        case OC_WIZARD_CREATED:
            rc = prv_OnWizardCreated();
        break;

        default:
            rc = NO_ERROR;
        break;
    }

    return rc;
}

///////////////////////////////
// prv_ValidateVersion
//
// Validates that the version
// of OC Manager this DLL was written
// for is compatible with the version
// of OC Manager that is currently
// driving us.
//
// Params:
//      - pSetupInit - setup info as given to us by OC Manager.
//
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_ValidateVersion(SETUP_INIT_COMPONENT *pSetupInit)
{
    DWORD dwReturn = NO_ERROR;
    DBG_ENTER(TEXT("prv_ValidateVersion"), dwReturn);

    if (OCMANAGER_VERSION <= pSetupInit->OCManagerVersion) 
    {
        // the version we expect is lower or the same than the version
        // than OC Manager understands.  This means that a newer OC 
        // Manager should still be able to drive older components, so 
        // return the version we support to OC Manager, and it will decide
        // if it can drive this component or not.

        VERBOSE(    DBG_MSG, 
                    _T("OC Manager version: 0x%x, ")
                    _T("FaxOcm Expected Version: 0x%x, seems OK"),
                    pSetupInit->OCManagerVersion,
                    OCMANAGER_VERSION);

        pSetupInit->ComponentVersion = OCMANAGER_VERSION;
    } 
    else 
    {
        // we were written for a newer version of OC Manager than the 
        // OC Manager driving this component.  Fail.

        VERBOSE(    SETUP_ERR, 
                    _T("OC Manager version: 0x%x, ")
                    _T("FaxOcm Expected Version: 0x%x, unsupported, abort."),
                    pSetupInit->OCManagerVersion,
                    OCMANAGER_VERSION);

        dwReturn = ERROR_CALL_NOT_IMPLEMENTED;
    }

    return dwReturn;
}


///////////////////////////////
// prv_SetSetupData
//
// Initialize our global variable containing
// the prv_Component_t information.
//
// Params:
//      - pszComponentId - id as it appears in SysOc.inf
//      - pSetupInit - OC Manager setup info.
// 
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_SetSetupData(const TCHAR          *pszComponentId,
                              SETUP_INIT_COMPONENT *pSetupInit)
{
    DWORD dwReturn = NO_ERROR;
    DBG_ENTER(TEXT("prv_SetSetupData"), dwReturn, TEXT("%s"), pszComponentId);

    if ((pszComponentId == NULL) ||
        (pSetupInit     == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (dwReturn == NO_ERROR)
    {
        memset(&prv_GVAR.Component, 0, sizeof(prv_GVAR.Component));

        prv_GVAR.dwCurrentOCManagerVersion = pSetupInit->OCManagerVersion;
        
        _tcsncpy(prv_GVAR.Component.szComponentID, 
                 pszComponentId,
                 sizeof(prv_GVAR.Component.szComponentID) / sizeof(TCHAR));

        _tcsncpy(prv_GVAR.Component.szSourcePath, 
                 pSetupInit->SetupData.SourcePath,
                 sizeof(prv_GVAR.Component.szSourcePath) / sizeof(TCHAR));

        _tcsncpy(prv_GVAR.Component.szUnattendFile, 
                 pSetupInit->SetupData.UnattendFile,
                 sizeof(prv_GVAR.Component.szUnattendFile) / sizeof(TCHAR));

        prv_GVAR.Component.hInf          = pSetupInit->ComponentInfHandle;
        prv_GVAR.Component.dwlFlags      = pSetupInit->SetupData.OperationFlags;
        prv_GVAR.Component.dwProductType = pSetupInit->SetupData.ProductType;
        prv_GVAR.Component.dwSetupMode   = pSetupInit->SetupData.SetupMode;
        prv_GVAR.Component.dwExpectedOCManagerVersion = OCMANAGER_VERSION;

        memcpy(&prv_GVAR.Component.Helpers, 
               &pSetupInit->HelperRoutines, 
               sizeof(prv_GVAR.Component.Helpers));
    }

    return dwReturn;
}

///////////////////////////////
// prv_GetSectionToProcess
//
// This determines if we are 
// clean installing, upgrading,
// uninstalling, etc, and returns
// the correct install section in the
// faxsetup.inf to process.
//
// Params:
//      - pszCurrentSection
//      - pszSectionToProcess - OUT 
//      - dwNumBufChars - # of characters pszSectionToProcess can hold.
//
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_GetSectionToProcess(const TCHAR *pszCurrentSection,
                                     TCHAR       *pszSectionToProcess,
                                     DWORD       dwNumBufChars)
{
    DWORD dwReturn          = NO_ERROR;
    BOOL  bInstall          = TRUE;
    DBG_ENTER(  TEXT("prv_GetSectionToProcess"), 
                dwReturn,
                TEXT("%s"),
                pszCurrentSection);

    if ((pszCurrentSection   == NULL) ||
        (pszSectionToProcess == NULL) ||
        (dwNumBufChars       == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    const TCHAR *pszInfKeyword = fxState_GetInstallType(pszCurrentSection);

    // okay, get that section's value, which will be an install/uninstall
    // section in the INF.
    if (pszInfKeyword)
    {
        dwReturn = fxocUtil_GetKeywordValue(pszCurrentSection,
                                            pszInfKeyword,
                                            pszSectionToProcess,
                                            dwNumBufChars);
    }
    else
    {
        dwReturn = ::GetLastError();
        VERBOSE(SETUP_ERR, 
                _T("fxState_GetInstallType failed, rc = 0x%lx"),
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// prv_UpdateProgressBar
//
// Update the progress bar displayed in the
// OC Manager dialog.  This simply tells
// the OC Manager to increment the dialog by
// the specified # of ticks.
//
// Params:
//      - dwNumTicks - # of ticks to increment by.
// 
// Returns:
//      - void
//
static void prv_UpdateProgressBar(DWORD dwNumTicks)
{
    // update the progress bar based on the number of ticks the caller
    // would like to set.
    DBG_ENTER(TEXT("prv_UpdateProgressBar"), TEXT("%d"), dwNumTicks);
    if (prv_GVAR.Component.Helpers.TickGauge)
    {
        for (DWORD i = 0; i < dwNumTicks; i++)
        {
            prv_GVAR.Component.Helpers.TickGauge(
                                 prv_GVAR.Component.Helpers.OcManagerContext);
        }
    }
}

///////////////////////////////
// prv_OnPreinitialize()
//
// Handler for OC_PREINITIALIZE
// 
// Params:
// Returns:
//      - Either OCFLAG_UNICODE or
//        OCFLAG_ANSI, depending on
//        what this DLL supports.
//        This DLL supports both.

static DWORD prv_OnPreinitialize(VOID)
{
    return OCFLAG_UNICODE;
}

///////////////////////////////
// prv_OnInitComponent()
//
// Handler for OC_INIT_COMPONENT
//
// Params:
//      - pszComponentId - ID specified in SysOc.inf (probably "Fax")
//      - pSetupInitComponent - OC Manager Setup info 
//
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_OnInitComponent(LPCTSTR               pszComponentId, 
                                 SETUP_INIT_COMPONENT  *pSetupInitComponent)
{
    BOOL  bSuccess              = FALSE;
    DWORD dwReturn              = NO_ERROR;
    UINT  uiErrorAtLineNumber   = 0;

    DBG_ENTER(TEXT("prv_OnInitComponent"), dwReturn, TEXT("%s"), pszComponentId);

    if ((pszComponentId         == NULL) ||
        (pSetupInitComponent    == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // save the setup data.
    if (dwReturn == NO_ERROR)
    {
        dwReturn = prv_SetSetupData(pszComponentId, pSetupInitComponent);
    }

    // Initialize debug so that we can get the debug settings specified
    // in the faxocm.inf file.
    fxocDbg_Init((faxocm_GetComponentInf()));

    // Validate the version of OC Manager against the version we expect
    if (dwReturn == NO_ERROR)
    {
        dwReturn = prv_ValidateVersion(pSetupInitComponent);
    }

    // Notice we do NOT need to call 'SetupOpenAppendInfFile'
    // since OC Manager already appends the layout.inf to the hInf
    // for us.

    bSuccess = ::SetupOpenAppendInfFile(NULL, prv_GVAR.Component.hInf, NULL);

    if (!bSuccess)
    {
        dwReturn = ::GetLastError();
        VERBOSE(    DBG_MSG,
                    _T("SetupOpenAppendInfFile failed to append ")
                    _T("the layout inf to the component Inf"));
    }

    //
    // initialize all the subsystems and Upgrade
    //
    if (dwReturn == NO_ERROR)
    {
        fxState_Init();
        fxocUtil_Init();
        fxocFile_Init();
        fxocMapi_Init();
        fxocPrnt_Init();
        fxocReg_Init();
        fxocSvc_Init();
        fxUnatnd_Init();
        fxocUpg_Init();
    }

    // set our initialized flag.
    if (dwReturn == NO_ERROR)
    {
        prv_GVAR.bInited = TRUE;

        VERBOSE(    DBG_MSG,
                    _T("OnInitComponent, ComponentID: '%s', ")
                    _T("SourcePath: '%s', Component Inf Handle: 0x%0x"),
                    prv_GVAR.Component.szComponentID,
                    prv_GVAR.Component.szSourcePath,
                    prv_GVAR.Component.hInf);
    }
    else
    {
        // XXX - OrenR - 03/23/2000
        // We should probably clean up here

        prv_GVAR.bInited = FALSE;

        VERBOSE(    SETUP_ERR,
                    _T("OnInitComponent, ComponentID: '%s'", )
                    _T("SourcePath: '%s', Component Inf Handle: 0x%0x ")
                    _T("Failed to Append Layout.inf file, dwReturn = %lu"),
                    prv_GVAR.Component.szComponentID,
                    prv_GVAR.Component.szSourcePath,
                    prv_GVAR.Component.hInf,
                    dwReturn);
    }

    // Output to debug our current setup state.
    fxState_DumpSetupState();

    return dwReturn;
}

///////////////////////////////
// prv_OnCleanup
//
// Called just before this
// DLL is unloaded
//
// Params:
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_OnCleanup(void)
{
    DWORD dwReturn = NO_ERROR;
    DBG_ENTER(TEXT("prv_OnCleanup"), dwReturn);

    // terminate the subsystems in reverse order from which they we 
    // intialized.

    fxUnatnd_Term();
    fxocSvc_Term();
    fxocReg_Term();
    fxocPrnt_Term();
    fxocMapi_Term();
    fxocFile_Term();
    fxocUtil_Term();
    fxState_Term();
    // this closes the log file, so do this last...
    fxocDbg_Term();

    return dwReturn;
}

///////////////////////////////
// prv_OnCalcDiskSpace
//
// Handler for OC_CALC_DISK_SPACE
// OC Manager calls this function 
// so that it can determine how 
// much disk space we require.
//
// Params:
//      - pszComponentId - From SysOc.inf (usually "fax")
//      - pszSubcomponentId - 
//      - addComponent - non-zero if installing, 0 if uninstalling
//      - dspace - handle to disk space abstraction.
// 
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_OnCalcDiskSpace(LPCTSTR   pszComponentId,
                                 LPCTSTR   pszSubcomponentId,
                                 DWORD     addComponent,
                                 HDSKSPC   dspace)
{
    DWORD dwReturn          = NO_ERROR;
    DBG_ENTER(  TEXT("prv_OnCalcDiskSpace"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszComponentId, 
                pszSubcomponentId);

    if (dwReturn == NO_ERROR)
    {
        dwReturn = fxocFile_CalcDiskSpace(pszSubcomponentId,
                                          addComponent,
                                          dspace);
    }

    return dwReturn;
}


///////////////////////////////
// prv_OnQueueFileOps
//
// Handler for OC_QUEUE_FILE_OPS
// This fn will queue all the files
// specified for copying and deleting
// in the INF install section.
//
// Params:
//      - pszCompnentId
//      - pszSubcomponentId
//      - hQueue - Handle to queue abstraction.
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_OnQueueFileOps(LPCTSTR    pszComponentId, 
                                LPCTSTR    pszSubcomponentId, 
                                HSPFILEQ   hQueue)
{
    DWORD   dwReturn                = NO_ERROR;
    BOOL    bInstallSelected        = FALSE;
    BOOL    bSelectionStateChanged  = FALSE;

    DBG_ENTER(  TEXT("prv_OnQueueFileOps"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszComponentId, 
                pszSubcomponentId);

    if ((pszComponentId     == NULL) || 
        (pszSubcomponentId  == NULL) ||
        (hQueue             == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // save our Queue Handle.
    prv_GVAR.Component.hQueue = hQueue;

    dwReturn = faxocm_HasSelectionStateChanged(pszSubcomponentId,
                                               &bSelectionStateChanged,
                                               &bInstallSelected,
                                               NULL);

    if (dwReturn != NO_ERROR)
    {
        VERBOSE(    SETUP_ERR,
                    _T("HasSelectionStateChanged failed, rc = 0x%lx"),
                    dwReturn);

        return dwReturn;
    }

    // our selection state has changed, install or uninstall based on
    // the current selection state.
    if (bSelectionStateChanged == TRUE)
    {
        TCHAR szSectionToProcess[255 + 1] = {0};

        VERBOSE(    DBG_MSG,
                    _T("Beginning Queuing of Files: ComponentID: '%s', ")
                    _T("SubComponentID: '%s', Selection State has ")
                    _T("changed to %lu ==> Installing/Uninstalling"),
                    pszComponentId, pszSubcomponentId, 
                    bInstallSelected);

        if (dwReturn == NO_ERROR)
        {
            dwReturn = prv_GetSectionToProcess(
                                   pszSubcomponentId, 
                                   szSectionToProcess,
                                   sizeof(szSectionToProcess) / sizeof(TCHAR));

            if (dwReturn != NO_ERROR)
            {
                VERBOSE(SETUP_ERR, 
                        _T("Failed to get section to process ")
                        _T("rc = 0x%lx"),
                        dwReturn);
            }
        }

        if (dwReturn == NO_ERROR)
        {
            if (bInstallSelected)
            {
                // 
                // Install
                //

                //
                //  Prepare for the Upgrade : Save different Settings 
                //
                dwReturn = fxocUpg_SaveSettings();
                if (dwReturn != NO_ERROR)
                {
                    VERBOSE(DBG_WARNING,
                            _T("Failed to prepare for the Upgrade : save settings during upgrade to Windows-XP Fax. ")
                            _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                            dwReturn);
                    dwReturn = NO_ERROR;
                }

                //
                //  Perform the Upgrade itself : Uninstall these fax applications that Windows XP Fax comes to replace.
                //
                dwReturn = fxocUpg_Uninstall();
                if (dwReturn != NO_ERROR)
                {
                    VERBOSE(DBG_WARNING,
                            _T("Failed to uninstall previous fax applications that ")
                            _T("should be replaced by the Windows XP Fax. ")
                            _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                            dwReturn);
                    dwReturn = NO_ERROR;
                }

                // install files
                dwReturn = fxocFile_Install(pszSubcomponentId,
                                            szSectionToProcess);

                if (dwReturn != NO_ERROR)
                {
                    VERBOSE(DBG_MSG,
                            _T("Failed Fax File operations, ")
                            _T("for subcomponent '%s', section '%s', ")
                            _T("rc = 0x%lx"), pszSubcomponentId, 
                            szSectionToProcess, dwReturn);
                }
            }
            else
            {
                // 
                // Uninstall
                //
                dwReturn = prv_UninstallFax(pszSubcomponentId,
                                            szSectionToProcess);
            }
        }
    }
    else
    {
        VERBOSE(DBG_MSG,
                _T("End Queuing of Files, ComponentID: '%s', ")
                _T("SubComponentID: '%s', Selection State has NOT ")
                _T("changed, doing nothing, bInstallSelected=%lu"),
                pszComponentId, pszSubcomponentId, 
                bInstallSelected);

    }

    return dwReturn;
}

///////////////////////////////
// prv_OnCompleteInstallation
//
// Handler for OC_COMPLETE_INSTALLATION.
// This is called after the queue is 
// committed.  It is here that we
// make our registery changes, add 
// fax service, and create the fax printer.                                
//
// Params:
//      - pszComponentId
//      - pszSubcomponentId.
// Returns:
//      - NO_ERROR if success.
//      - error code otherwise.
//
static DWORD prv_OnCompleteInstallation(LPCTSTR pszComponentId, 
                                        LPCTSTR pszSubcomponentId)
{
    BOOL  bSelectionStateChanged = FALSE;
    BOOL  bInstallSelected       = FALSE;
    DWORD dwReturn               = NO_ERROR;

    DBG_ENTER(  TEXT("prv_OnCompleteInstallation"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszComponentId, 
                pszSubcomponentId);
    // Do post-installation processing in the cleanup section.
    // This way we know all components queued for installation
    // have beein installed before we do our stuff.

    if (!pszSubcomponentId || !*pszSubcomponentId)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwReturn = faxocm_HasSelectionStateChanged(pszSubcomponentId,
                                               &bSelectionStateChanged,
                                               &bInstallSelected,
                                               NULL);

    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR, 
                _T("HasSelectionStateChanged failed, rc = 0x%lx"),
                dwReturn);

        return dwReturn;
    }

    // if our selection state has changed, then install/uninstall
    if (bSelectionStateChanged)
    {
        TCHAR szSectionToProcess[255 + 1] = {0};

        //
        // Fake report to prevent re-entrancy
        //
        g_InstallReportType = bInstallSelected ? REPORT_FAX_UNINSTALLED : REPORT_FAX_INSTALLED;

        dwReturn = prv_GetSectionToProcess(
                                   pszSubcomponentId, 
                                   szSectionToProcess,
                                   sizeof(szSectionToProcess) / sizeof(TCHAR));


        if (dwReturn == NO_ERROR)
        {
            // if the Install checkbox is selected, then install
            if (bInstallSelected) 
            { 
                dwReturn = prv_CompleteFaxInstall(pszSubcomponentId,
                                                  szSectionToProcess);
            } 
            else 
            { 
                // if the install checkbox is not selected, then uninstall.
                dwReturn = prv_CompleteFaxUninstall(pszSubcomponentId,
                                                    szSectionToProcess);
            }
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to get section to process ")
                    _T("rc = 0x%lx"), dwReturn);
        }
        //
        // Report real installation state in case someone asks
        //
        g_InstallReportType = REPORT_FAX_DETECT;
        if (ERROR_SUCCESS == dwReturn)
        {
            //
            // Installation / Uninstallation is successfully complete.
            // Notify the 'Printers and Faxes' folder it should refresh itself.
            //
            RefreshPrintersAndFaxesFolder();
        }
    }
    return dwReturn;
}   // prv_OnCompleteInstallation

///////////////////////////////
// prv_CompleteFaxInstall
//
// Called by prv_OnCompleteInstallation
// this function creates the program
// groups/shortcuts, registry entries,
// fax service, fax printer, etc.
//
// Params:
//      - pszSubcomponentId
//      - pszSectionToProcess
//
static DWORD prv_CompleteFaxInstall(const TCHAR *pszSubcomponentId,
                                    const TCHAR *pszSectionToProcess)
{
    DWORD                       dwReturn = NO_ERROR;
    
    fxState_UpgradeType_e       UpgradeType = FXSTATE_UPGRADE_TYPE_NONE;

    DBG_ENTER(  TEXT("prv_CompleteFaxInstall"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszSubcomponentId, 
                pszSectionToProcess);

    if ((pszSubcomponentId   == NULL) ||
        (pszSectionToProcess == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    UpgradeType = fxState_IsUpgrade();
    // Create Program Group/Shortcuts
    // We create the shortcuts first because at the very worst case, if we
    // fail everything else, the applications should be somewhat robust enough
    // to be able to correct or notify the user of problems that could not
    // be notified during install.
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,_T("Creating program groups and shortcuts..."));

        dwReturn = fxocLink_Install(pszSubcomponentId,
                                    pszSectionToProcess);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to create program ")
                    _T("groups/shortcuts for fax.  This is a non-fatal ")
                    _T("error, continuing fax install...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    prv_UpdateProgressBar(1);

    // Load the unattended data if applicable
    if (dwReturn == NO_ERROR)
    {
        if ((fxState_IsUnattended()) || 
            (UpgradeType == FXSTATE_UPGRADE_TYPE_WIN9X))
        {
            VERBOSE(DBG_MSG,
                    _T("CompleteInstall, state is unattended ")
                    _T("or we are upgrading from Win9X, ")
                    _T("caching unattended data from INF file"));

            // load our unattended data
            dwReturn = fxUnatnd_LoadUnattendedData();

            if (dwReturn == NO_ERROR)
            {
                // set up the fax printer name
				fxocPrnt_SetFaxPrinterName(fxUnatnd_GetPrinterName());
            }
            else
            {
                VERBOSE(SETUP_ERR,
                        _T("Failed to load unattended data, ")
                        _T("non-fatal error, continuing anyway...")
                        _T("rc = 0x%lx"), dwReturn);

                dwReturn = NO_ERROR;
            }
        }
    }

    prv_UpdateProgressBar(1);

    // Install Registry

    if (dwReturn == NO_ERROR)
    {
        // install the registry settings as specified in the INF file

        VERBOSE(DBG_MSG,_T("Installing Registry..."));

        dwReturn = fxocReg_Install(pszSubcomponentId,
                                   pszSectionToProcess);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to install registry settings ")
                    _T("for fax installation.  This is a fatal ")
                    _T("error, abandoning fax install...rc=0x%lx"),
                    dwReturn);
        }
    }

    prv_UpdateProgressBar(1);

    // Install Fax Printer/Monitor support
    if (dwReturn == NO_ERROR)
    {
        // Create a fax printer and monitor

        VERBOSE(DBG_MSG,_T("Installing Fax Monitor and Printer..."));

        dwReturn = fxocPrnt_Install(pszSubcomponentId,
                                    pszSectionToProcess);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to install fax printer and ")
                    _T("fax monitor.  This is a fatal ")
                    _T("error, abandoning fax installation...rc=0x%lx"),
                    dwReturn);
        }
    }

    prv_UpdateProgressBar(1);

    // Install Services 
    if (dwReturn == NO_ERROR) 
    {
        // Install any services as specified in the section of the INF file

        VERBOSE(DBG_MSG,_T("Installing Fax Service..."));

        dwReturn = fxocSvc_Install(pszSubcomponentId,
                                   pszSectionToProcess);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to install fax service. ")
                    _T("This is a fatal ")
                    _T("error, abandoning fax install...rc=0x%lx"),
                    dwReturn);
        }
    }

    prv_UpdateProgressBar(1);

    // Install Exchange Support
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,_T("Installing Fax MAPI extension..."));

        dwReturn = fxocMapi_Install(pszSubcomponentId,
                                    pszSectionToProcess);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to install exchange support for ")
                    _T("fax.  This is a fatal ")
                    _T("error, abandoning fax installation...rc=0x%lx"),
                    dwReturn);
        }
    }

    prv_UpdateProgressBar(1);

    // Create/Delete Directories
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG, _T("Creating directories..."));

        //
        //  At upgrade, before deleting of directories, take care of their content
        //
        dwReturn = fxocUpg_MoveFiles();
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING,
                    _T("Failed to clear previous fax directories. ")
                    _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                    dwReturn);
            dwReturn = NO_ERROR;
        }

        dwReturn = fxocFile_ProcessDirectories(pszSectionToProcess);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to install create directories ")
                    _T("for fax.  This is a fatal ")
                    _T("error, abandoning fax installation...rc=0x%lx"),
                    dwReturn);
       }
    }

    prv_UpdateProgressBar(1);

    // create/delete the Shares
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG, _T("Create shares..."));

        dwReturn = fxocFile_ProcessShares(pszSectionToProcess);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to install shares ")
                    _T("for fax.  This is a fatal ")
                    _T("error, abandoning fax installation...rc=0x%lx"),
                    dwReturn);
        }
    }

    if (dwReturn == NO_ERROR)
    {
        if ((fxState_IsUnattended()) || 
            (UpgradeType == FXSTATE_UPGRADE_TYPE_WIN9X))
        {
            VERBOSE(DBG_MSG, _T("Saving unattended data to registry"));

            //
            //  this will read from the unattended file list of the uninstalled fax applications
            //  and update the fxocUpg.prvData, which is used later, in fxocUpg_GetUpgradeApp()
            //  to decide whether or not to show the "Where Did My Fax Go" shortcut.
            //
            dwReturn = fxUnatnd_SaveUnattendedData();
            if (dwReturn != NO_ERROR)
            {
                VERBOSE(SETUP_ERR,
                        _T("Failed to save unattended data")
                        _T("to the registry. This is a non-fatal ")
                        _T("error, continuing fax install...rc=0x%lx"),
                        dwReturn);

                dwReturn = NO_ERROR;
            }
        }
    }

    if (dwReturn == NO_ERROR)
    {
        dwReturn = prv_ShowUninstalledFaxShortcut();
    }

    prv_UpdateProgressBar(1);

    if (dwReturn == NO_ERROR)
    {
        dwReturn = prv_NotifyStatusMonitor(FAX_STARTUP_TIMER_ID);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to notify Status Monitor.")
                    _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                    dwReturn);
            dwReturn = NO_ERROR;
        }
    }

    prv_UpdateProgressBar(1);
    
    if (dwReturn == NO_ERROR)
    {
        //
        //  Complete the Upgrade : Restore settings that were saved at Preparation stage
        //
        dwReturn = fxocUpg_RestoreSettings();
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(DBG_WARNING,
                    _T("Failed to restore previous fax applications settings after their uninstall. ")
                    _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                    dwReturn);
            dwReturn = NO_ERROR;
        }
    }
    prv_UpdateProgressBar(1);

    if (dwReturn != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("Complete Fax Install failed, rc = 0x%lx"),
                dwReturn);

        // now we attemp a rollback, if we're here, things are quite bad as it is.
        // we'll try to remove shortcuts, remove the service, etc.
        // the files will remain on the machine.
        TCHAR szUninstallSection[MAX_PATH] = {0};
        if( fxocUtil_GetUninstallSection(pszSubcomponentId,szUninstallSection,MAX_PATH)==NO_ERROR)
        {
            VERBOSE(DBG_MSG,_T("Performing rollback, using section %s."),szUninstallSection);
            if (prv_UninstallFax(pszSubcomponentId,szUninstallSection)==NO_ERROR)
            {
                VERBOSE(DBG_MSG,_T("Rollback (prv_UninstallFax) successful..."));
            }
            else
            {
                // not setting dwReturn explicitly to preserve to original cause for failure.
                VERBOSE(SETUP_ERR,_T("Rollback (prv_UninstallFax) failed, rc = 0x%lx"),GetLastError());
            }
            if (prv_CompleteFaxUninstall(pszSubcomponentId,szUninstallSection)==NO_ERROR)
            {
                VERBOSE(DBG_MSG,_T("Rollback (prv_CompleteFaxUninstall) successful..."));
            }
            else
            {
                // not setting dwReturn explicitly to preserve to original cause for failure.
                VERBOSE(SETUP_ERR,_T("Rollback (prv_CompleteFaxUninstall) failed, rc = 0x%lx"),GetLastError());
            }
        }
        else
        {
            // not setting dwReturn explicitly to preserve to original cause for failure.
            VERBOSE(SETUP_ERR,_T("fxocUtil_GetUninstallSection failed, rc = 0x%lx"),GetLastError());
        }
    }
    return dwReturn;
}   // prv_CompleteFaxInstall

///////////////////////////////
// prv_CompleteFaxUninstall
//
// Called by prv_OnCompleteInstallation
// to uninstall the fax.  Since most
// of the work is done before we even
// queue our files to delete, the only
// thing we really do here is remove the
// program group/shortcuts.
//
// Params:
//      - pszSubcomponentId
//      - pszSectionToProcess
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
// 
static DWORD prv_CompleteFaxUninstall(const TCHAR *pszSubcomponentId,
                                      const TCHAR *pszSectionToProcess)
{
    DWORD dwReturn = NO_ERROR;

    DBG_ENTER(  TEXT("prv_CompleteFaxUninstall"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszSubcomponentId, 
                pszSectionToProcess);

    if ((pszSubcomponentId == NULL) ||
        (pszSectionToProcess == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Uninstall directories
    if (dwReturn == NO_ERROR)
    {
        dwReturn = fxocFile_ProcessDirectories(pszSectionToProcess);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall directories ")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }


    // uninstall subsystems in the reverse order they were installed in.
    if (dwReturn == NO_ERROR)
    {
        // notice we ignore the return codes, we will attempt to completely
        // uninstall even if something fails to uninstall.

        // Remove Program Group/Shortcuts
        dwReturn = fxocLink_Uninstall(pszSubcomponentId,
                                      pszSectionToProcess);
    }
    return dwReturn;
}   // prv_CompleteFaxUninstall

///////////////////////////////
// prv_UninstallFax
//
// Uninstalls fax from the user's
// computer.  This does everything
// except the program group delete.  It 
// will remove the fax printer,
// fax service, exchange updates,
// registry, and file deletion.

static DWORD prv_UninstallFax(const TCHAR *pszSubcomponentId,
                              const TCHAR *pszUninstallSection)
{
    DWORD dwReturn = NO_ERROR;

    DBG_ENTER(  TEXT("prv_UninstallFax"),
                dwReturn, 
                TEXT("%s - %s"), 
                pszSubcomponentId, 
                pszUninstallSection);

    if ((pszSubcomponentId      == NULL) ||
        (pszUninstallSection    == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Notice when we uninstall our files, we want to clean up
    // everything else first, to ensure that we can successfully
    // remove the files.

    // Uninstall shares
    if (dwReturn == NO_ERROR)
    {
        dwReturn = fxocFile_ProcessShares(pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall shares ")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    // Uninstall Fax Printer/Monitor support
    if (dwReturn == NO_ERROR)
    {
        dwReturn = fxocPrnt_Uninstall(pszSubcomponentId,
                                      pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall fax printer ")
                    _T("and monitor.  This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    // Uninstall Exchange Support
    if (dwReturn == NO_ERROR)
    {
        fxocMapi_Uninstall(pszSubcomponentId,pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall fax exchange support")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    // Notice we uninstall our service first before uninstalling
    // the files.

    if (dwReturn == NO_ERROR)
    {
        fxocSvc_Uninstall(pszSubcomponentId,
                          pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall fax service.  ")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    if (dwReturn == NO_ERROR)
    {
        // Uninstall Registry
        fxocReg_Uninstall(pszSubcomponentId,
                          pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall fax registry.  ")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    if (dwReturn == NO_ERROR)
    {
        dwReturn = prv_NotifyStatusMonitor(FAX_SHUTDOWN_TIMER_ID);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to notify Status Monitor.")
                    _T("This is a non-fatal error, continuing fax install...rc=0x%lx"),
                    dwReturn);
            dwReturn = NO_ERROR;
        }
    }

    if (dwReturn == NO_ERROR)
    {
        // uninstall files
        dwReturn = fxocFile_Uninstall(pszSubcomponentId,
                                      pszUninstallSection);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to uninstall fax files.  ")
                    _T("This is a non-fatal error, ")
                    _T("continuing with uninstall attempt...rc=0x%lx"),
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }

    return dwReturn;
}


///////////////////////////////
// prv_OnNotificationFromQueue
//
// Handler for OC_NOTIFICATION_FROM_QUEUE
// 
// NOTE: although this notification is defined,
// it is currently unimplemented in oc manager
//

static DWORD prv_OnNotificationFromQueue(void)
{
    return NO_ERROR;
}

///////////////////////////////
// prv_OnQueryStepCount
//
// This query by the OC Manager
// determines how many "ticks"
// on the progress bar we would
// like shown.  
//
// We only update the progress
// bar during an install (for 
// no good reason!).  It seems
// that all OC components do this.
//
// Params:
//      - pszComponentId
//      - pszSubcomponentId
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
static DWORD prv_OnQueryStepCount(LPCTSTR pszComponentId,
                                  LPCTSTR pszSubcomponentId)
{
    DWORD dwErr                  = 0;
    DWORD dwNumSteps             = 0;
    BOOL  bInstallSelected       = FALSE;
    BOOL  bSelectionStateChanged = FALSE;

    DBG_ENTER(  TEXT("prv_OnQueryStepCount"),
                dwNumSteps, 
                TEXT("%s - %s"), 
                pszComponentId, 
                pszSubcomponentId);

    if (!pszSubcomponentId || !*pszSubcomponentId)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = faxocm_HasSelectionStateChanged(pszSubcomponentId,
                                            &bSelectionStateChanged,
                                            &bInstallSelected,
                                            NULL);

    if (dwErr != NO_ERROR)
    {
        VERBOSE(SETUP_ERR,
                _T("HasSelectionStateChanged failed, rc = 0x%lx"),
                dwErr);

        return 0;
    }

    if (bSelectionStateChanged)
    {
        if (bInstallSelected)
        {
            dwNumSteps = prv_TOTAL_NUM_PROGRESS_BAR_TICKS;
        }
    }

    return dwNumSteps;
}

///////////////////////////////
// prv_OnExtraRoutines
//
// OC Manager giving us some
// extra routines.  Save them.
//
// Params:
//      - pszComponentId
//      - pExtraRoutines - pointer to extra OC Manager fns.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise
//
static DWORD prv_OnExtraRoutines(LPCTSTR            pszComponentId, 
                                 EXTRA_ROUTINES    *pExtraRoutines)
{
    DWORD dwResult = NO_ERROR;
    DBG_ENTER(  TEXT("prv_OnExtraRoutines"),
                dwResult, 
                TEXT("%s"), 
                pszComponentId);

    if ((pszComponentId == NULL) ||
        (pExtraRoutines == NULL))
    {
        dwResult = ERROR_INVALID_PARAMETER;
        return dwResult;
    }

    memcpy(&prv_GVAR.Component.Extras, 
           pExtraRoutines, 
           sizeof(prv_GVAR.Component.Extras));

    dwResult = NO_ERROR;
    return dwResult;
}


///////////////////////////////
// prv_OnSetLanguage
//
// Handler for OC_SET_LANGUAGE
// the OC Manager is requesting
// we change to the specified language.
// Since there is no GUI, this is not
// an issue.
//
// Params:
// Return:
//      - TRUE indicating successfully
//        changed language.
//
static DWORD prv_OnSetLanguage(UINT uiLanguageID)
{
//    return false;  // this is what OCGEN returns

    prv_GVAR.Component.uiLanguageID = uiLanguageID;

    return TRUE;
}

///////////////////////////////
// prv_OnQueryImage
//
// Handler for OC_QUERY_IMAGE
// this returns the handle to the
// loaded icon for displaying in the
// Add/Remove dialog.
// 
// Params:
// Returns:
//      - HBITMAP - handle to loaded bitmap
//
static DWORD_PTR prv_OnQueryImage(void)
{
    DWORD_PTR dwResult = (DWORD_PTR)INVALID_HANDLE_VALUE;
    DBG_ENTER(TEXT("prv_OnQueryImage"));

    dwResult = (DWORD_PTR) LoadBitmap(faxocm_GetAppInstance(),
                                  MAKEINTRESOURCE(IDI_FAX_ICON));  
    return dwResult;
}

///////////////////////////////
// prv_OnSetupRequestPages
//
// Handler for OC_REQUEST_PAGES.
// We don't have a GUI, so we
// return 0 pages.
//
// Params:
//      - uiType - specifies a type from the
//        WizardPagesType enumerator.
//      - Pointer to SETUP_REQUEST_PAGES 
//        structure.
// Returns:
//      - 0, no pages to display
//        
//
static DWORD prv_OnSetupRequestPages(UINT uiType, 
                                     void *pSetupRequestPages)
{
    // we do not have any wizard pages to display, so return 0 
    // indicating that we want to display zero wizard pages.
    return 0;
}

///////////////////////////////
// prv_OnWizardCreated
//
// Handler for OC_WIZARD_CREATED
// Do nothing.
//
static DWORD prv_OnWizardCreated(void)
{
    return NO_ERROR;
}

///////////////////////////////
// prv_OnQuerySelStateChange
//
// Handle for OC_QUERY_CHANGE_SEL_STATE
// OC Manager is asking us if it is
// okay for the user to select/unselect
// this component from the Add/Remove 
// list.  We want to allow the user
// to NOT install this as well, so 
// always allow the user to change the
// selection state.
//
// Params:
//      - pszComponentId
//      - pszSubcomponentId
//      - uiState - Specifies proposed new selection
//        state.  0 => not selected, 1 => selected.
//      - uiFlags - Could be OCQ_ACTUAL_SELECTION or 0.
//        If it is OCQ_ACTUAL_SELECTION then the user
//        actually selected/deselected the pszSubcomponentId.
//        If it is 0, it is being turned on or off
//        because the parent needs that subcomponent.
//        
// Returns:
//      - TRUE - allow selection change
// 
//
static DWORD prv_OnQuerySelStateChange(LPCTSTR pszComponentId,
                                       LPCTSTR pszSubcomponentId,
                                       UINT    uiState,
                                       UINT    uiFlags)
{
    // always allow the user to change the selection state of the component.
    return TRUE;
}

///////////////////////////////
// prv_OnQueryState
//
// Handler for OC_QUERY_STATE
// OC Manager is asking us if the 
// given subcomponent is installed or 
// not.  Since the OC Manager keeps a 
// record of this for itself, we rely
// on it to keep track of our installed
// state.
//
// Params:
//      - pszComponentId
//      - pszSubcomponentId
//      - uiState - Install state OC Manager thinks we are in.
// Returns:
//      - SubcompUseOCManagerDefault - use whatever state
//        OC Manager thinks we are in.
//

static DWORD prv_OnQueryState(LPCTSTR pszComponentId,
                              LPCTSTR pszSubcomponentId,
                              UINT    uiState)
{
    DWORD dwState = SubcompOff;

    DBG_ENTER(_T("prv_OnQueryState"));

    if (uiState==OCSELSTATETYPE_CURRENT)
    {
        // when asking about the current state, use the default (either user initiated or from answer file)
        dwState = SubcompUseOcManagerDefault;
    }
    else
    {
        HKEY hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_FAX_SETUP, FALSE,KEY_READ);
        if (hKey)
        {
            DWORD dwInstalled = 0;
            if (GetRegistryDwordEx(hKey,REGVAL_FAXINSTALLED,&dwInstalled)==NO_ERROR)
            {
                if (dwInstalled)
                {
                    VERBOSE(DBG_MSG,_T("REG_DWORD 'Installed' is set, assume component is installed"));
                    dwState = SubcompOn;
                }
                else
                {
                    VERBOSE(DBG_MSG,_T("REG_DWORD 'Installed' is zero, assume component is not installed"));
                }
            }
            else
            {
                VERBOSE(DBG_MSG,_T("REG_DWORD 'Installed' does not exist, assume component is not installed"));
            }
        }
        else
        {
            VERBOSE(DBG_MSG,_T("HKLM\\Software\\Microsoft\\Fax\\Setup does not exist, assume component is not installed"));
        }
        if (hKey)
        {
            RegCloseKey(hKey);
        }
    }
    return dwState;
}

///////////////////////////////
// prv_OnNeedMedia
//
// Handler for OC_NEED_MEDIA
// Allows us to fetch our own
// media - for example, from the 
// Internet.  We don't need anything
// so just move on.
//
// Params:
// Returns:
//      - FALSE - don't need any media
//      
//
static DWORD prv_OnNeedMedia(void)
{
    return FALSE;
}

///////////////////////////////
// prv_OnAboutToCommitQueue
//
// Handler for OC_ABOUT_TO_COMMIT_QUEUE
// Tells us that OC Manager is about
// to commit to queue.  We don't really
// care, do nothing.
//
// Params:
//      - pszComponentId
//      - pszSubcomponentId.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//

static DWORD prv_OnAboutToCommitQueue(LPCTSTR pszComponentId, 
                                      LPCTSTR pszSubcomponentId)
{
    DWORD dwReturn                  = NO_ERROR;

    // don't think we need to do anything here yet.

    return dwReturn;
}

///////////////////////////////
// prv_OnQuerySkipPage
//
// Handler for OC_QUERY_SKIP_PAGE
// 
// Params:
// Returns:
// 
//
static DWORD prv_OnQuerySkipPage(void)
{
    return FALSE;
}

///////////////////////////////
// faxocm_HasSelectionStateChanged
//
// This fn tells us if our selection
// state in the Add/Remove programs
// dialog box has changed since it
// was started, and it also tells us
// our current selection state.
//
// Params:
//      - pszSubcomponentId
//      - pbCurrentSelected - OUT
//      - pbOriginallySelected - OUT
// Returns:
//      - TRUE if selection state has changed
//      - FALSE otherwise.
//
DWORD faxocm_HasSelectionStateChanged(LPCTSTR pszSubcomponentId,
                                      BOOL    *pbSelectionStateChanged,
                                      BOOL    *pbCurrentlySelected,
                                      BOOL    *pbOriginallySelected)
{
    DWORD dwReturn              = NO_ERROR;
    BOOL bCurrentlySelected     = FALSE;
    BOOL bOriginallySelected    = FALSE;
    BOOL bSelectionChanged      = TRUE;
    PQUERYSELECTIONSTATE_ROUTINEW   pQuerySelectionState = NULL;

    DBG_ENTER(  TEXT("faxocm_HasSelectionStateChanged"),
                dwReturn, 
                TEXT("%s"), 
                pszSubcomponentId);

    // if pszSubcomponentId == NULL, we are hosed.
    Assert(pszSubcomponentId != NULL);
    Assert(pbSelectionStateChanged != NULL);

    if ((pszSubcomponentId          == NULL) ||
        (pbSelectionStateChanged    == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return dwReturn=ERROR_INVALID_PARAMETER;
    }

    pQuerySelectionState = prv_GVAR.Component.Helpers.QuerySelectionState;

    if (pQuerySelectionState)
    {
        // are we currently selected.

        bCurrentlySelected = pQuerySelectionState(
                        prv_GVAR.Component.Helpers.OcManagerContext,
                        pszSubcomponentId,
                        OCSELSTATETYPE_CURRENT);

        bOriginallySelected = pQuerySelectionState(
                        prv_GVAR.Component.Helpers.OcManagerContext,
                        pszSubcomponentId,
                        OCSELSTATETYPE_ORIGINAL);

        if (bOriginallySelected == bCurrentlySelected)
        {
            bSelectionChanged = FALSE;
        }
        else
        {
            bSelectionChanged = TRUE;
        }
    }

    // if we are not in stand alone mode, and we are upgrading the OS, then assume that
    // the selection state has changed.  We do this because we would like to force an 
    // install of fax during an upgrade from NT or W2K.  Currently (as of 05/02/2000)
    // OC Manager reports an upgrade type of WINNT when upgrading from W2K.  This is valid
    // because fax is always installed in W2K (the user could not uninstall it), and therefore
    // whenever we upgrade, bSelectionChanged will always be FALSE, which will prevent
    // the new fax from being installed.  NOT GOOD.  This fixes that.

    if ((fxState_IsStandAlone() == FALSE) && 
        ((fxState_IsUpgrade()   == FXSTATE_UPGRADE_TYPE_NT) ||
         (fxState_IsUpgrade()   == FXSTATE_UPGRADE_TYPE_W2K)))
    {
        if (bOriginallySelected && bCurrentlySelected)
        {
            // only if Fax was installed and is now marked for installation during OS upgrade
            // we force re-installation.
            // If both were false, this can't return true because it'll cause an uninstall
            // going and we'll try to uninstall a non existing Fax.
            // This happens when upgrading XP build without Fax to another.
            // This causes many setup error (in setupapi logs) and disturbes setup people.
            // this condition takes care of this problem.
            bSelectionChanged = TRUE;
        }
    }

    if (pbCurrentlySelected)
    {
        *pbCurrentlySelected = bCurrentlySelected;
    }

    if (pbOriginallySelected)
    {
        *pbOriginallySelected = bOriginallySelected;
    }

    *pbSelectionStateChanged = bSelectionChanged;

    return dwReturn;
}

///////////////////////////////
// prv_NotifyStatusMonitor
//
// This function notifies the shell
// to load FXSST.DLL (Status Monitor)
// It is done by sending a private message
// to STOBJECT.DLL window.
// 
//
// Params:
//      - WPARAM wParam - 
//              either  FAX_STARTUP_TIMER_ID or 
//                      FAX_SHUTDOWN_TIMER_ID
//      
// Returns:
//      - NO_ERROR if notification succeeded
//      - Win32 Error code otherwise.
//
static DWORD prv_NotifyStatusMonitor(WPARAM wParam)
{
    DWORD dwRet = NO_ERROR;
    HWND hWnd = NULL;
    DBG_ENTER(TEXT("prv_NotifyStatusMonitor"),dwRet);

    // We need to send a WM_TIMER to a window identified by the class name SYSTRAY_CLASSNAME
    // The timer ID should be FAX_STARTUP_TIMER_ID

    hWnd = FindWindow(SYSTRAY_CLASSNAME,NULL);
    if (hWnd==NULL)
    {
        dwRet = GetLastError();
        CALL_FAIL(SETUP_ERR,TEXT("FindWindow"),dwRet);
        goto exit;
    }

    SendMessage(hWnd,WM_TIMER,wParam,0);

exit:
    return dwRet;
}

static INT_PTR CALLBACK prv_dlgWhereDidMyFaxGoQuestion
(
  HWND hwndDlg,   
  UINT uMsg,     
  WPARAM wParam, 
  LPARAM lParam  
)
/*++

Routine name : prv_dlgWhereDidMyFaxGoQuestion

Routine description:

	Dialogs procedure for "Where did my fax go" dialog

Author:

	Mooly Beery (MoolyB),	Mar, 2001

Arguments:

	hwndDlg                       [in]    - Handle to dialog box
	uMsg                          [in]    - Message
	wParam                        [in]    - First message parameter
	parameter                     [in]    - Second message parameter

Return Value:

    Standard dialog return value

--*/
{
    INT_PTR iRes = IDIGNORE;
    DBG_ENTER(_T("prv_dlgWhereDidMyFaxGoQuestion"));

    switch (uMsg) 
    {
		case WM_INITDIALOG:
			SetFocus(hwndDlg);
			break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) 
            {
                case IDC_OK:
                    if (BST_CHECKED == ::SendMessage (::GetDlgItem (hwndDlg, IDC_REMOVE_LINK), BM_GETCHECK, 0, 0))
                    {
                        // we should remove the link.
                        // we do this by processing our INF in the section that deals
                        // with this link. This way we're sure it can be localized at will
                        // and we'll always remove the correct link.
                        TCHAR szInfFileName[2*MAX_PATH] = {0};
                        if (faxocm_GetComponentInfName(szInfFileName))
                        {
                            _tcscat(szInfFileName,_T(",Fax.UnInstall.PerUser.WhereDidMyFaxGo"));
                            if (LPSTR pszInfCommandLine = UnicodeStringToAnsiString(szInfFileName))
                            {
                                LaunchINFSection(hwndDlg,prv_GVAR.hInstance,pszInfCommandLine,1);
                                MemFree(pszInfCommandLine);
                            }
                        }
                    }
                    EndDialog (hwndDlg, iRes);
                    return TRUE;
            }
            break;
    }
    return FALSE;
}   // prv_dlgWhereDidMyFaxGoQuestion

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  WhereDidMyFaxGo
//
//  Purpose:        
//                  When a machine running SBS5.0 client was upgraded to Windows-XP
//                  We show a link called 'Where did my Fax go' in the start menu
//                  at the same location where the SBS5.0 shortcuts used to be.
//                  When clicking this link it calls this function that raises
//                  a dialog to explain to the user where the Windows-XP Fax's
//                  shortcuts are, and asks the user whether to delete this link.
//                  
//  Params:
//                  None
//
//  Return Value:
//                  NO_ERROR - in case of success
//                  Win32 Error code otherwise
//
//  Author:
//                  Mooly Beery (MoolyB) 17-Jan-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD WhereDidMyFaxGo(void)
{
    DWORD dwRet = NO_ERROR;
    DBG_ENTER(TEXT("WhereDidMyFaxGo"),dwRet);

    INT_PTR iResult = DialogBox (faxocm_GetAppInstance(),
                                 MAKEINTRESOURCE(IDD_WHERE_DID_MY_FAX_GO),
                                 NULL,
                                 prv_dlgWhereDidMyFaxGoQuestion);
    if (iResult==-1)
    {
        dwRet = GetLastError();
        CALL_FAIL (RESOURCE_ERR, TEXT("DialogBox(IDD_WHERE_DID_MY_FAX_GO)"), dwRet);
    }

    return dwRet;
}

DWORD prv_ShowUninstalledFaxShortcut(void)
/*++

Routine name : prv_ShowUninstalledFaxShortcut

Routine description:

	Show Shortcut of "Where Did My Fax Go ? " in the All Programs.

Author:

	Iv Garber (IvG),	Jun, 2001

Return Value:

    Standard Win32 error code

--*/
{
    DBG_ENTER(_T("prv_ShowUninstalledFaxShortcut"));

    //
    // In cases we upgraded from a machine running SBS2000 Client/Server or XP Client and we want to 
    // add a 'Where did my Fax go' shortcut.
    // we want to add it to the current user as well as every user.
    //
    if (fxocUpg_GetUpgradeApp()!=FXSTATE_UPGRADE_APP_NONE)
    {
        //
        // first add the shortcut to the current user.
        //
        TCHAR szInfFileName[2*MAX_PATH] = {0};
        if (faxocm_GetComponentInfName(szInfFileName))
        {
            _tcscat(szInfFileName,_T(",Fax.Install.PerUser.AppUpgrade"));
            if (LPSTR pszInfCommandLine = UnicodeStringToAnsiString(szInfFileName))
            {
                LaunchINFSection(NULL,prv_GVAR.hInstance,pszInfCommandLine,1);
                MemFree(pszInfCommandLine);
            }
        }
        else
        {
            CALL_FAIL(SETUP_ERR,TEXT("faxocm_GetComponentInfName"),GetLastError());
        }

        //
        // now change the PerUserStub to point to the section that creates the link for every user.
        //
        HKEY hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_ACTIVE_SETUP_NT, FALSE,KEY_ALL_ACCESS);
        if (hKey)
        {
            if (LPTSTR lptstrPerUser = GetRegistryString(hKey,_T("StubPath"),NULL))
            {
                TCHAR szLocalPerUserStub[MAX_PATH*2] = {0};
                _tcscpy(szLocalPerUserStub,lptstrPerUser);
                _tcscat(szLocalPerUserStub,REGVAL_ACTIVE_SETUP_PER_USER_APP_UPGRADE);
                if (!SetRegistryString(hKey,_T("StubPath"),szLocalPerUserStub))
                {
                    CALL_FAIL(SETUP_ERR,TEXT("SetRegistryString"),GetLastError());
                }
                MemFree(lptstrPerUser);
            }
            else
            {
                CALL_FAIL(SETUP_ERR,TEXT("GetRegistryString"),GetLastError());
            }
            RegCloseKey(hKey);
        }
        else
        {
            CALL_FAIL(SETUP_ERR,TEXT("OpenRegistryKey"),GetLastError());
        }
    }

    return NO_ERROR;
}


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocfile.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocFile.cpp
//
// Abstract:        This provides the file/directory routines used in the 
//                  FaxOCM code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 21-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"
#pragma hdrstop

#define MAX_NUM_CHARS_INF_VALUE     255

//////////////////////// Static Function Prototypes //////////////////////////

static BOOL prv_ProcessDirectories(const TCHAR *pszSection,const TCHAR *pszDirAction);
static BOOL prv_ProcessShares(const TCHAR *pszSection,const TCHAR *pszShareAction);

static DWORD prv_DoSetup(const TCHAR *pszSection,
                         BOOL        bInstall,
                         const TCHAR *pszFnName,
                         HINF        hInf,
                         const TCHAR *pszSourceRootPath,
                         HSPFILEQ     hQueue,
                         DWORD       dwFlags);



FAX_SHARE_Description::FAX_SHARE_Description() 
:   iPlatform(PRODUCT_SKU_UNKNOWN),
    pSD(NULL)
{
}

FAX_SHARE_Description::~FAX_SHARE_Description()
{
    if (pSD)
    {
        LocalFree(pSD);
    }
}

FAX_FOLDER_Description::FAX_FOLDER_Description() 
:   iPlatform(PRODUCT_SKU_UNKNOWN),
    pSD(NULL),
    iAttributes(FILE_ATTRIBUTE_NORMAL)
{
}

FAX_FOLDER_Description::~FAX_FOLDER_Description()
{
    if (pSD)
    {
        LocalFree(pSD);
    }
}


///////////////////////////////
// fxocFile_Init
//
// Initialize this File queuing
// subsystem
// 
// Params:
//      - void
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocFile_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init File Module"), dwRes);

    return dwRes;
}

///////////////////////////////
// fxocFile_Term
//
// Terminate this file queuing subsystem.
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocFile_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term File Module"), dwRes);

    return dwRes;
}


///////////////////////////////
// fxocFile_Install
//
// Installs files listed in
// the INF setup file into their
// specified location.
//
// Params:
//      - pszSubcomponentId
//      - pszInstallSection - install section in INF file (e.g. Fax.CleanInstall)
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocFile_Install(const TCHAR  *pszSubcomponentId,
                       const TCHAR  *pszInstallSection)
                       
{
    HINF        hInf     = NULL;
    HSPFILEQ    hQueue   = NULL;
    DWORD       dwReturn = NO_ERROR;
    BOOL        bSuccess = FALSE;

    DBG_ENTER(  _T("fxocFile_Install"), 
                dwReturn,   
                _T("%s - %s"), 
                pszSubcomponentId, 
                pszInstallSection);

    if (pszInstallSection == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // get the INF handle for our component inf file
    hInf = faxocm_GetComponentInf();

    // get the file queue handle 
    hQueue = faxocm_GetComponentFileQueue();

    // unregister platform specific DLLs first - this can happen during an upgrade from XP Beta -> XP RC1 and XP RTM
    dwReturn = fxocUtil_SearchAndExecute(pszInstallSection,INF_KEYWORD_UNREGISTER_DLL_PLATFORM,SPINST_UNREGSVR,NULL);
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully Unregistered Fax DLLs - platform dependent")
                _T("from INF file, section '%s'"), 
                pszInstallSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to Unregister Fax DLLs - platform dependent")
                _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                pszInstallSection, 
                dwReturn);
    }

    dwReturn = prv_DoSetup(pszInstallSection,
                           TRUE,
                           _T("fxocFile_Install"),
                           hInf,
                           NULL,
                           hQueue,
                           SP_COPY_NEWER);

    // now attemp to install platform specific files
    dwReturn = fxocUtil_SearchAndExecute(pszInstallSection,INF_KEYWORD_COPYFILES_PLATFORM,SP_COPY_NEWER,hQueue);
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully Queued Files - platform dependent")
                _T("from INF file, section '%s'"), 
                pszInstallSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to Queued Files  - platform dependent")
                _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                pszInstallSection, 
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// fxocFile_Uninstall
//
// Uninstalls files listed in
// the INF setup file.
//
// Params:
//      - pszSubcomponentId
//      - pszUninstallSection - section in INF (e.g. Fax.Uninstall)
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocFile_Uninstall(const TCHAR    *pszSubcomponentId,
                         const TCHAR    *pszUninstallSection)
{
    HINF        hInf     = NULL;
    HSPFILEQ    hQueue   = NULL;
    DWORD       dwReturn = NO_ERROR;
    BOOL        bSuccess = FALSE;

    DBG_ENTER(  _T("fxocFile_Install"), 
                dwReturn,   
                _T("%s - %s"), 
                pszSubcomponentId, 
                pszUninstallSection);

    if (pszUninstallSection == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // get the INF handle for our component inf file
    hInf = faxocm_GetComponentInf();

    // get the file queue handle 
    hQueue = faxocm_GetComponentFileQueue();

    // unregister all our DLLs first
    if (::SetupInstallFromInfSection(NULL,hInf,pszUninstallSection,SPINST_UNREGSVR,NULL,NULL,0,NULL,NULL,NULL,NULL))
    {
        VERBOSE(DBG_MSG,
                _T("Successfully processed SPINST_UNREGSVR from INF file, section '%s'"),
                pszUninstallSection);
    }
    else
    {
        dwReturn = GetLastError();
        VERBOSE(SETUP_ERR,
                _T("Failed to process SPINST_UNREGSVR, section '%s', dwReturn = 0x%lx"),
                pszUninstallSection, 
                dwReturn);
    }

    // Now delete the files.
    // this function will uninstall if the section retrieved above
    // contains the 'DelFiles' keyword.
    dwReturn = prv_DoSetup(pszUninstallSection,
                           FALSE,
                           _T("fxocFile_Uninstall"),
                           hInf,
                           NULL,
                           hQueue,
                           0);
    return dwReturn;
}

///////////////////////////////
// prv_DoSetup
//
// Generic routine to call the appropriate
// Setup API fn, depending on if we are installing
// or uninstalling.
//
// Params:
//      - pszSection - section we are processing
//      - bInstall   - TRUE if installing, FALSE if uninstalling
//      - pszFnName  - name of calling fn (for debug)
//      - hInf       - handle to faxsetup.inf.
//      - pszSourceRootPath - path we are installing from.
//      - hQueue     - handle to file queue given to us by OC Manager
//      - dwFlags    - flags to pass to setup API.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
static DWORD prv_DoSetup(const TCHAR  *pszSection,
                         BOOL         bInstall,
                         const TCHAR  *pszFnName,
                         HINF         hInf,
                         const TCHAR  *pszSourceRootPath,
                         HSPFILEQ     hQueue,
                         DWORD        dwFlags)
{
    DWORD dwReturn = NO_ERROR;
    BOOL  bSuccess = FALSE;

    DBG_ENTER(  _T("prv_DoSetup"), 
                dwReturn,   
                _T("%s - %s - %s"), 
                pszSection, 
                pszFnName,
                pszSourceRootPath);
    // this function will search the INF for the 'CopyFiles' keyword
    // and copy all files referenced by it.
    bSuccess = ::SetupInstallFilesFromInfSection(hInf,
                                                 NULL,
                                                 hQueue,
                                                 pszSection,
                                                 pszSourceRootPath,
                                                 dwFlags);

    if (bSuccess)
    {
        VERBOSE(DBG_MSG,
                _T("%s, Successfully queued files ")
                _T("from Section: '%s'"), 
                pszFnName, 
                pszSection);
    }
    else
    {
        dwReturn = GetLastError();

        VERBOSE(DBG_MSG,
                _T("%s, Failed to queue files ")
                _T("from Section: '%s', Error Code = 0x%lx"), 
                pszFnName, 
                pszSection, 
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// fxocFile_CalcDiskSpace
//
// Calculate the disk space requirements
// of fax.  This is done by the Setup APIs
// based on the files we are copying and
// deleting as specified in faxsetup.inf.
//
// Params:
//      - pszSubcomponentId
//      - bIsBeingAdded - are we installing or uninstalling.
//      - hDiskSpace - handle to diskspace abstraction.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise                             
//
DWORD fxocFile_CalcDiskSpace(const TCHAR  *pszSubcomponentId,
                             BOOL         bIsBeingAdded,
                             HDSKSPC      hDiskSpace)
{
    HINF  hInf     = faxocm_GetComponentInf();
    DWORD dwReturn = NO_ERROR;
    BOOL  bSuccess = FALSE;
    TCHAR szSectionToProcess[255 + 1];

    DBG_ENTER(  _T("fxocFile_CalcDiskSpace"), 
                dwReturn,   
                _T("%s"), 
                pszSubcomponentId);

    if ((hInf              == NULL) ||
        (pszSubcomponentId == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // since disk space calc needs to be consistent, select the clean install
    // section for the disk space calculation section.  This is a good
    // estimate.
    if (dwReturn == NO_ERROR)
    {
        dwReturn = fxocUtil_GetKeywordValue(pszSubcomponentId,
                                   INF_KEYWORD_INSTALLTYPE_CLEAN,
                                   szSectionToProcess,
                                   sizeof(szSectionToProcess) / sizeof(TCHAR));
    }


    if (dwReturn == NO_ERROR)
    {
        if (bIsBeingAdded)
        {
            bSuccess = ::SetupAddInstallSectionToDiskSpaceList(
                                                    hDiskSpace, 
                                                    hInf,
                                                    NULL, 
                                                    szSectionToProcess,
                                                    0,
                                                    0);
        }
        else
        {
            bSuccess = ::SetupRemoveInstallSectionFromDiskSpaceList(
                                                    hDiskSpace,
                                                    hInf,
                                                    NULL,
                                                    szSectionToProcess,
                                                    0,
                                                    0);
        }

        if (!bSuccess)
        {
            dwReturn = GetLastError();

            VERBOSE(SETUP_ERR,
                    _T("fxocFile_CalcDiskSpace, failed to calculate ")
                    _T("disk space, error code = 0x%lx"), dwReturn);
        }
        else
        {
            VERBOSE(DBG_MSG,
                    _T("fxocFile_CalcDiskSpace, ")
                    _T("SubComponentID: '%s', Section: '%s', ")
                    _T("bIsBeingAdded: '%lu', ")
                    _T("rc=0x%lx"), pszSubcomponentId, szSectionToProcess,
                    bIsBeingAdded, 
                    dwReturn);
        }
    }

    return dwReturn;
}

///////////////////////////////
// fxocFile_ProcessDirectories
//
// Create and/or Delete the directories
// in the given section, 
//
DWORD fxocFile_ProcessDirectories(const TCHAR  *pszSection)
{
    DWORD dwReturn                                    = NO_ERROR;

    DBG_ENTER(  _T("fxocFile_ProcessDirectories"), 
                dwReturn,   
                _T("%s"), 
                pszSection);

    // first, delete all the shares specified in the 
    // INF section.
    if (!prv_ProcessDirectories(pszSection,INF_KEYWORD_DELDIR))
    {
        VERBOSE(DBG_WARNING,_T("Problems deleting directories...."));
    }


    // next, create all the shares specified in the 
    // INF section.
    if (!prv_ProcessDirectories(pszSection,INF_KEYWORD_CREATEDIR))
    {
        VERBOSE(DBG_WARNING,_T("Problems creating directories...."));
    }

    return dwReturn;
}


///////////////////////////////
// fxocFile_ProcessShares
//
// Create and/or Delete shares 
// directories/printers specfiied
// in the given section.
// 
// Params:
//      - pszSection - section containing the 'CreateShare'/'DelShare'
//        keyword
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocFile_ProcessShares(const TCHAR  *pszSection)
{
    DWORD dwReturn                                    = NO_ERROR;

    DBG_ENTER(  _T("fxocFile_ProcessShares"), 
                dwReturn,   
                _T("%s"), 
                pszSection);

    // first, delete all the shares specified in the 
    // INF section.
    if (!prv_ProcessShares(pszSection,INF_KEYWORD_DELSHARE))
    {
        VERBOSE(DBG_WARNING,_T("Problems deleting shares...."));
    }


    // next, create all the shares specified in the 
    // INF section.
    if (!prv_ProcessShares(pszSection,INF_KEYWORD_CREATESHARE))
    {
        VERBOSE(DBG_WARNING,_T("Problems creating shares...."));
    }

    return dwReturn;
}


static BOOL prv_FillFolderDescriptionFromInf(const TCHAR *pszFolderSection,FAX_FOLDER_Description& fsdFolder)
{
    INFCONTEXT  Context;
    BOOL        bSuccess                    = TRUE;
    HINF        hInf                        = NULL;
    TCHAR       szStringSd[MAX_PATH*3]      = {0};

    DBG_ENTER(  _T("prv_FillFolderDescriptionFromInf"), 
                bSuccess,   
                _T("%s"), 
                pszFolderSection);

    hInf = faxocm_GetComponentInf();
    memset(&Context, 0, sizeof(Context));

    // get the Path line in the section.
    if (!::SetupFindFirstLine(hInf,pszFolderSection,INF_KEYWORD_PATH,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_PATH,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,fsdFolder.szPath,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_PATH,GetLastError());
        return FALSE;
    }

    // get the Platform line in the section.
    if (!::SetupFindFirstLine(hInf,pszFolderSection,INF_KEYWORD_PLATFORM,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_PLATFORM,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetIntField(&Context, 1, &fsdFolder.iPlatform);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_PLATFORM,GetLastError());
        return FALSE;
    }

    // get the attributes line if it exists.
    if (::SetupFindFirstLine(hInf,pszFolderSection,INF_KEYWORD_ATTRIBUTES,&Context))
    {
        bSuccess = ::SetupGetIntField(&Context, 1, &fsdFolder.iAttributes);
        if (!bSuccess)
        {
            VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_PLATFORM,GetLastError());
            return FALSE;
        }
    }
    else
    {
        VERBOSE(    DBG_MSG,
                    _T("SetupFindFirstLine failed (%s) (ec=%d), ")
                    _T("this is an optional field assuming non-existant"),
                    INF_KEYWORD_ATTRIBUTES,
                    GetLastError());
    }
    // get the Security line in the section.
    if (!::SetupFindFirstLine(hInf,pszFolderSection,INF_KEYWORD_SECURITY,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_SECURITY,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,szStringSd,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_SECURITY,GetLastError());
        return FALSE;
    }
    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(szStringSd,SDDL_REVISION_1,&fsdFolder.pSD,NULL))
    {
        VERBOSE(SETUP_ERR,_T("ConvertStringSecurityDescriptorToSecurityDescriptor failed (%s) (ec=%d)"),szStringSd,GetLastError());
        return FALSE;
    }

    return TRUE; 
}

static BOOL prv_FillShareDescriptionFromInf(const TCHAR *pszShareSection,FAX_SHARE_Description& fsdShare)
{
    INFCONTEXT  Context;
    BOOL        bSuccess                    = TRUE;
    HINF        hInf                        = NULL;
    TCHAR       szStringSd[MAX_PATH*3]      = {0};

    DBG_ENTER(  _T("prv_FillShareDescriptionFromInf"), 
                bSuccess,   
                _T("%s"), 
                pszShareSection);

    hInf = faxocm_GetComponentInf();
    memset(&Context, 0, sizeof(Context));

    // get the Path line in the section.
    if (!::SetupFindFirstLine(hInf,pszShareSection,INF_KEYWORD_PATH,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_PATH,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,fsdShare.szPath,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_PATH,GetLastError());
        return FALSE;
    }

    // get the Name line in the section.
    if (!::SetupFindFirstLine(hInf,pszShareSection,INF_KEYWORD_NAME,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_NAME,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,fsdShare.szName,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_NAME,GetLastError());
        return FALSE;
    }

    // get the Comment line in the section.
    if (!::SetupFindFirstLine(hInf,pszShareSection,INF_KEYWORD_COMMENT,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_COMMENT,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,fsdShare.szComment,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_COMMENT,GetLastError());
        return FALSE;
    }

    // get the Platform line in the section.
    if (!::SetupFindFirstLine(hInf,pszShareSection,INF_KEYWORD_PLATFORM,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_PLATFORM,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetIntField(&Context, 1, &fsdShare.iPlatform);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_PLATFORM,GetLastError());
        return FALSE;
    }

    // get the Security line in the section.
    if (!::SetupFindFirstLine(hInf,pszShareSection,INF_KEYWORD_SECURITY,&Context))
    {
        VERBOSE(SETUP_ERR,_T("SetupFindFirstLine failed (%s) (ec=%d)"),INF_KEYWORD_SECURITY,GetLastError());
        return FALSE;
    }
    bSuccess = ::SetupGetStringField(&Context,1,szStringSd,MAX_PATH,NULL);
    if (!bSuccess)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (%s) (ec=%d)"),INF_KEYWORD_SECURITY,GetLastError());
        return FALSE;
    }
    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(szStringSd,SDDL_REVISION_1,&fsdShare.pSD,NULL))
    {
        VERBOSE(SETUP_ERR,_T("ConvertStringSecurityDescriptorToSecurityDescriptor failed (%s) (ec=%d)"),szStringSd,GetLastError());
        return FALSE;
    }

    return TRUE; 
}

///////////////////////////////
// prv_ProcessDirectories
//
// Enumerates through the specified
// INF file in the specified section
// and gets the value of the next
// keyword 'CreateDir', or 'DelDir'
//
// This function looks for the following lines
// in the INF section
//
// CreateDir    = [1st dir section],[2nd dir section],...
// or
// DelDir       = [1st dir section],[2nd dir section],...
//
// [dir section]      - is built in the following format:
//                          Path = <path to folder to create>
//                          Platform = <one of the PRODUCT_SKU_* below>
//                          Security = <DACL in string format>
// 
// Params:
//      - pszSection - section in the file to iterate through.
//      - pszShareAction - one of INF_KEYWORD_CREATEDIR, INF_KEYWORD_DELDIR
//
// Returns:
//      - TRUE if folders were processed successfully
//      - FALSE otherwise
//
static BOOL prv_ProcessDirectories(const TCHAR *pszSection,const TCHAR *pszDirAction)
{
    INFCONTEXT  Context;
    BOOL        bSuccess                    = TRUE;
    HINF        hInf                        = NULL;
    DWORD       dwFieldCount                = 0;
    DWORD       dwIndex                     = 0;
    DWORD       dwNumChars                  = MAX_PATH;
    DWORD       dwNumRequiredChars          = 0;
    TCHAR       pszFolderSection[MAX_PATH]  = {0};

    DBG_ENTER(  _T("prv_ProcessDirectories"), 
                bSuccess,   
                _T("%s - %s"), 
                pszSection,
                pszDirAction);

    if  ((pszDirAction != INF_KEYWORD_CREATEDIR) && 
         (pszDirAction != INF_KEYWORD_DELDIR))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pszSection == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hInf = faxocm_GetComponentInf();
    memset(&Context, 0, sizeof(Context));
    
    // get the first CreateDir or DelDir in the section.
    bSuccess = ::SetupFindFirstLine(hInf,
                                    pszSection, 
                                    pszDirAction,
                                    &Context);

    if (!bSuccess)
    {
        VERBOSE(DBG_WARNING,
                _T("Did not find '%s' keyword in ")
                _T("section '%s'.  No action will be taken."),
                pszDirAction, 
                pszSection);

        return FALSE;
    }
    
    // Found the CreateDir or DelDir
    // now let's see how many dirs to create/delete
    dwFieldCount = SetupGetFieldCount(&Context);
    if (dwFieldCount==0)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetFieldCount failed (ec=%d)"),GetLastError());
        return FALSE;
    }

    for (dwIndex=0; dwIndex<dwFieldCount; dwIndex++)
    {
        FAX_FOLDER_Description ffdFolder;
        // iterate through fields, get the share section and process it.
        bSuccess = ::SetupGetStringField(&Context, dwIndex+1, pszFolderSection, dwNumChars, &dwNumRequiredChars);
        if (!bSuccess)
        {
            VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (ec=%d)"),GetLastError());
            return FALSE;
        }
        // we have the share name in pszShareSection, fill out the FAX_SHARE_Description structure
        if (!prv_FillFolderDescriptionFromInf(pszFolderSection,ffdFolder))
        {
            VERBOSE(SETUP_ERR,_T("prv_FillFolderDescriptionFromInf failed (ec=%d)"),GetLastError());
            return FALSE;
        }

        // now we have all the data
        // check if we should act on this platform...
        if (!(ffdFolder.iPlatform & GetProductSKU()))
        {
            VERBOSE(DBG_MSG,_T("Folder should not be processed on this Platform, skipping..."));
            continue;
        }

        if (pszDirAction == INF_KEYWORD_CREATEDIR)
        {
            // create the folder
            bSuccess = MakeDirectory(ffdFolder.szPath);
            if (!bSuccess)
            {
                DWORD dwReturn = ::GetLastError();
                if (dwReturn != ERROR_ALREADY_EXISTS)
                {
                    VERBOSE(SETUP_ERR,_T("MakeDirectory failed (ec=%d)"),dwReturn);
                }
            }
            // set the folder's security
            if (!SetFileSecurity(   ffdFolder.szPath,
                                    DACL_SECURITY_INFORMATION,
                                    ffdFolder.pSD))
            {
                VERBOSE(SETUP_ERR, _T("SetFileSecurity"), GetLastError());
            }
            
            // set the folder's attributes
            if (ffdFolder.iAttributes!=FILE_ATTRIBUTE_NORMAL)
            {
                // no sense in setting normal attributes, since this is the default
                // the attributes member is initialized to FILE_ATTRIBUTE_NORMAL so
                // if we failed to read it from the INF it's still the same
                // and if someone specifies it in the INF it'll be set by default.
                DWORD dwFileAttributes = GetFileAttributes(ffdFolder.szPath);
                if (dwFileAttributes!=-1)
                {
                    dwFileAttributes |= ffdFolder.iAttributes;

                    if (!SetFileAttributes(ffdFolder.szPath,dwFileAttributes))
                    {
                        VERBOSE(SETUP_ERR, TEXT("SetFileAttributes"), GetLastError());
                    }
                }
                else
                {
                    VERBOSE(SETUP_ERR, TEXT("GetFileAttributes"), GetLastError());
                }
            }
        }
        else
        {
            // delete the directory
            DeleteDirectory(ffdFolder.szPath);
        }
    }

    return TRUE;
}

///////////////////////////////
// prv_ProcessShares
//
// Enumerates through the specified
// INF file in the specified section
// and gets the value of the next
// keyword 'CreateShare', or 'DelShare'
//
// This function looks for the following lines
// in the INF section
//
// CreateShare  = [1st share section],[2nd share section],...
// or
// DelShare     = [1st share section],[2nd share section],...
//
// [share section] - is built in the following format:
//                      Path = <path to folder on which share is created>
//                      Name = <name of share as it appears to the user>
//                      Comment = <share comment as it appears to the user>
//                      Platform = <one of the below platform specifiers>
//                      Security = <DACL in string format>
// 
// Params:
//      - pszSection - section in the file to iterate through.
//      - pszShareAction - one of INF_KEYWORD_CREATESHARE, INF_KEYWORD_DELSHARE
//
// Returns:
//      - TRUE if shares were processed successfully
//      - FALSE otherwise
//
static BOOL prv_ProcessShares(const TCHAR *pszSection,const TCHAR *pszShareAction)
{
    INFCONTEXT  Context;
    BOOL        bSuccess                    = TRUE;
    HINF        hInf                        = NULL;
    DWORD       dwFieldCount                = 0;
    DWORD       dwIndex                     = 0;
    DWORD       dwNumChars                  = MAX_PATH;
    DWORD       dwNumRequiredChars          = 0;
    TCHAR       pszShareSection[MAX_PATH]   = {0};

    DBG_ENTER(  _T("prv_ProcessShares"), 
                bSuccess,   
                _T("%s - %s"), 
                pszSection,
                pszShareAction);

    if  ((pszShareAction != INF_KEYWORD_CREATESHARE) && 
         (pszShareAction != INF_KEYWORD_DELSHARE))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pszSection == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hInf = faxocm_GetComponentInf();
    memset(&Context, 0, sizeof(Context));
    
    // get the first CreateShare or DelShare in the section.
    bSuccess = ::SetupFindFirstLine(hInf,
                                    pszSection, 
                                    pszShareAction,
                                    &Context);

    if (!bSuccess)
    {
        VERBOSE(DBG_WARNING,
                _T("Did not find '%s' keyword in ")
                _T("section '%s'.  No action will be taken."),
                pszShareAction, 
                pszSection);

        return FALSE;
    }
    
    // Found the CreateShare or DelShare.
    // now let's see how many shares to create/delete
    dwFieldCount = SetupGetFieldCount(&Context);
    if (dwFieldCount==0)
    {
        VERBOSE(SETUP_ERR,_T("SetupGetFieldCount failed (ec=%d)"),GetLastError());
        return FALSE;
    }

    for (dwIndex=0; dwIndex<dwFieldCount; dwIndex++)
    {
        FAX_SHARE_Description fsdShare;
        // iterate through fields, get the share section and process it.
        bSuccess = ::SetupGetStringField(&Context, dwIndex+1, pszShareSection, dwNumChars, &dwNumRequiredChars);
        if (!bSuccess)
        {
            VERBOSE(SETUP_ERR,_T("SetupGetStringField failed (ec=%d)"),GetLastError());
            return FALSE;
        }
        // we have the share name in pszShareSection, fill out the FAX_SHARE_Description structure
        if (!prv_FillShareDescriptionFromInf(pszShareSection,fsdShare))
        {
            VERBOSE(SETUP_ERR,_T("prv_FillShareDescriptionFromInf failed (ec=%d)"),GetLastError());
            return FALSE;
        }

        // now we have all the data
        // check if we should act on this platform...
        if (!(fsdShare.iPlatform & GetProductSKU()))
        {
            VERBOSE(DBG_MSG,_T("Share should not be processed on this Platform, skipping..."));
            continue;
        }

        if (pszShareAction == INF_KEYWORD_CREATESHARE)
        {
            // create the share...
            bSuccess = fxocUtil_CreateNetworkShare(&fsdShare);
            if (!bSuccess)
            {
                VERBOSE(SETUP_ERR,
                        _T("Failed to create share name '%s', path '%s', ")
                        _T("comment '%s', rc=0x%lx"), 
                        fsdShare.szName, 
                        fsdShare.szPath, 
                        fsdShare.szComment,
                        GetLastError());
            }
        }
        else
        {
            // delete the share..
            bSuccess = fxocUtil_DeleteNetworkShare(fsdShare.szName);
            if (!bSuccess)
            {
                VERBOSE(SETUP_ERR,
                        _T("Failed to delete share name '%s', ")
                        _T("rc=0x%lx"), 
                        fsdShare.szPath, 
                        GetLastError());
            }
        }
    }

    return TRUE;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocdbg.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocDbg.h
//
// Abstract:        Header file used by Debug source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCDBG_H_
#define _FXOCDBG_H_

///////////////////////////////
// fxocDbg_Init
//
// Initialize debug subsystem,
// call at start of app
//
void fxocDbg_Init(HINF hInf = NULL);

///////////////////////////////
// fxocDbg_Term
//
// Terminate debug subsystem
// Call on app shutdown.
//
void fxocDbg_Term(void);

///////////////////////////////
// fxocDbg_GetOcFunction
//
// Returns pointer to string
// equivalent of uiFunction
//
const TCHAR* fxocDbg_GetOcFunction(UINT uiFunction);

#endif  // _FXOCDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocdbg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocDbg.cpp
//
// Abstract:        This provides the debug routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////

#include "faxocm.h"
#pragma hdrstop

#define prv_SECTION_FAXOCMDEBUG     _T("FaxOcmDebug")
#define prv_KEY_DEBUGLEVEL          _T("DebugLevel")
#define prv_KEY_DEBUGFORMAT         _T("DebugFormat")

#define prv_DEBUG_FILE_NAME         _T("%windir%\\FaxSetup.log")

///////////////////////////////
// prv_OC_Function
//
// Type containing text description
// of stage of OC Manager
// setup.
//
typedef struct prv_OC_Function
{
    UINT        uiFunction;
    TCHAR       *pszFunctionDesc;
} prv_OC_Function;

///////////////////////////////
// prv_OC_FunctionTable
//
// This table contains the various
// stages of the OC Manager setup,
// and their text equivalent.  This
// allows us to output to debug the
// stage of setup, rather than the 
// numerical equivalent.
// 
//
static prv_OC_Function prv_OC_FunctionTable[] = 
{
    {OC_PREINITIALIZE,              _T("OC_PREINITIALIZE")},
    {OC_INIT_COMPONENT,             _T("OC_INIT_COMPONENT")},
    {OC_SET_LANGUAGE,               _T("OC_SET_LANGUAGE")},
    {OC_QUERY_IMAGE,                _T("OC_QUERY_IMAGE")},
    {OC_REQUEST_PAGES,              _T("OC_REQUEST_PAGES")},
    {OC_QUERY_CHANGE_SEL_STATE,     _T("OC_QUERY_CHANGE_SEL_STATE")},
    {OC_CALC_DISK_SPACE,            _T("OC_CALC_DISK_SPACE")},
    {OC_QUEUE_FILE_OPS,             _T("OC_QUEUE_FILE_OPS")},
    {OC_NOTIFICATION_FROM_QUEUE,    _T("OC_NOTIFICATION_FROM_QUEUE")},
    {OC_QUERY_STEP_COUNT,           _T("OC_QUERY_STEP_COUNT")},
    {OC_COMPLETE_INSTALLATION,      _T("OC_COMPLETE_INSTALLATION")},
    {OC_CLEANUP,                    _T("OC_CLEANUP")},
    {OC_QUERY_STATE,                _T("OC_QUERY_STATE")},
    {OC_NEED_MEDIA,                 _T("OC_NEED_MEDIA")},
    {OC_ABOUT_TO_COMMIT_QUEUE,      _T("OC_ABOUT_TO_COMMIT_QUEUE")},
    {OC_QUERY_SKIP_PAGE,            _T("OC_QUERY_SKIP_PAGE")},
    {OC_WIZARD_CREATED,             _T("OC_WIZARD_CREATED")},
    {OC_FILE_BUSY,                  _T("OC_FILE_BUSY")},
    {OC_EXTRA_ROUTINES,             _T("OC_EXTRA_ROUTINES")}
};
#define NUM_OC_FUNCTIONS (sizeof(prv_OC_FunctionTable) / sizeof(prv_OC_FunctionTable[0]))

////////////////////////////////
// fxocDbg_InitDebug
//
// Initialize the FaxOcm
// debug subsystem.
// 
// We can be turned on either
// via the [FaxOcmDebug] section
// in the faxsetup.inf, or via the 
// the "DebugLevelEx" and "DebugFormatEx"
// under HKLM\Software\Microsoft\Fax
// If both are specified, the registry wins.
//
// In faxocm.inf, we look for
// [FaxOcmDebug]
// ============================
// [DebugLevel] can be one of the following:
//	0 - no debug output
//	1 - see errors only
//	2 - see errors & warnings
//	3 - see all the debug output 
//
// [DebugFormat] can be one of the following:
//	0 - print to std output
//	1 - print to file ("FaxSetup.log" in %windir%\system32 directory)
//	2 - print to both
// ============================
//
// Params:
//      - hFaxSetupInfHandle - handle to faxsetup.inf 
//        if applicable.
// Returns:
//      - void.
//
void fxocDbg_Init(HINF hFaxSetupInfHandle)
{
    BOOL bSuccess = FALSE;
    INFCONTEXT Context;
    INT iDebugLevel = 0;
    INT iDebugFormat = 0;

    DBG_ENTER(_T("fxocDbg_Init"),bSuccess);
    memset(&Context, 0, sizeof(Context));

    if (hFaxSetupInfHandle)
    {
        // initialize via the INF file.

        // We are looking for:
        // [FaxOcmDebug]
        // DebugLevel = x (0 -> no debug, up to and including 3->full debug)

        // find the section in the INF file and the DebugLevel key.
        bSuccess = ::SetupFindFirstLine(hFaxSetupInfHandle, 
                                        prv_SECTION_FAXOCMDEBUG, 
                                        prv_KEY_DEBUGLEVEL,
                                        &Context);

        if (bSuccess)
        {
            // we found the DebugLevel key, so get its value.
            bSuccess = ::SetupGetIntField(&Context, 1, &iDebugLevel);
            if (bSuccess)
            {
                iDebugLevel = max(iDebugLevel,0);
                iDebugLevel = min(iDebugLevel,3);
                if (!IS_DEBUG_SESSION_FROM_REG)
                {
                    switch (iDebugLevel)
                    {
                    case 0: SET_DEBUG_MASK(ASSERTION_FAILED);
                            break;
                    case 1: SET_DEBUG_MASK(DBG_ERRORS_ONLY);
                            break;
                    case 2: SET_DEBUG_MASK(DBG_ERRORS_WARNINGS);
                            break;
                    case 3: SET_DEBUG_MASK(DBG_ALL);
                            break;
                    }
                }
            }
        }

        memset(&Context, 0, sizeof(Context));
        // find the section in the INF file and the DebugFormat key.
        bSuccess = ::SetupFindFirstLine(hFaxSetupInfHandle, 
                                        prv_SECTION_FAXOCMDEBUG, 
                                        prv_KEY_DEBUGFORMAT,
                                        &Context);

        if (bSuccess)
        {
            // we found the DebugLevel key, so get its value.
            bSuccess = ::SetupGetIntField(&Context, 1, &iDebugFormat);
            if (bSuccess)
            {
                iDebugLevel = max(iDebugFormat,0);
                iDebugLevel = min(iDebugFormat,2);
                if (!IS_DEBUG_SESSION_FROM_REG)
                {
                    switch (iDebugFormat)
                    {
                    case 0: SET_FORMAT_MASK(DBG_PRNT_ALL_TO_STD);
                            break;
                    case 1: SET_FORMAT_MASK(DBG_PRNT_ALL_TO_FILE);
                            OPEN_DEBUG_LOG_FILE(prv_DEBUG_FILE_NAME);
                            break;
                    case 2: SET_FORMAT_MASK(DBG_PRNT_ALL);
                            OPEN_DEBUG_LOG_FILE(prv_DEBUG_FILE_NAME);
                            break;
                    }
                }
            }
        }
    }
}

////////////////////////////////
// fxocDbg_TermDebug
//
// Terminate the debug subsystem
// 
// Params:
//      - void.
// Returns:
//      - void.
//
void fxocDbg_Term(void)
{
    DBG_ENTER(_T("fxocDbg_Term"));
    CLOSE_DEBUG_LOG_FILE;
}

///////////////////////////////
// fxocDbg_GetOcFunction
//
// This looks up the uiFunction
// in the prv_OC_Function table
// defined above and returns a
// pointer to the text equivalent.
// 
// Params:
//      - uiFunction - function OC Manager wants us to perform.
// Returns:
//      - text equivalent of uiFunction.
// 
//
const TCHAR* fxocDbg_GetOcFunction(UINT uiFunction)
{
    TCHAR   *pszString = _T("");

    // NOTE:  This function assumes that the table above contains a 
    //        numerically sorted array with the numerical value of 
    //        "uiFunction" equal to its index position in the 
    //        prv_OC_FunctionTable array.  We assume this for performance
    //        purposes.

    if (uiFunction < NUM_OC_FUNCTIONS)
    {
        pszString = prv_OC_FunctionTable[uiFunction].pszFunctionDesc;
    }

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocfile.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocFile.h
//
// Abstract:        Header file used by Fax File source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCFILE_H_
#define _FXOCFILE_H_

struct FAX_SHARE_Description
{
    TCHAR                   szPath[MAX_PATH];       // <path to folder on which share is created>
    TCHAR                   szName[MAX_PATH];       // <name of share as it appears to the user>
    TCHAR                   szComment[MAX_PATH];    // <share comment as it appears to the user>
    INT                     iPlatform;              // <platform on which share should be created>
    PSECURITY_DESCRIPTOR    pSD;                    // <Security Descriptor to apply to share>

    FAX_SHARE_Description();
    ~FAX_SHARE_Description();
};

struct FAX_FOLDER_Description
{
    TCHAR                   szPath[MAX_PATH];       // <path to folder to create>
    INT                     iPlatform;              // <platform on which share should be created>
    PSECURITY_DESCRIPTOR    pSD;                    // <Security Descriptor to apply to share>
    INT                     iAttributes;            // <attributes to apply to the folder - optional>

    FAX_FOLDER_Description();
    ~FAX_FOLDER_Description();
};


DWORD fxocFile_Init(void);
DWORD fxocFile_Term(void);

DWORD fxocFile_Install(const TCHAR   *pszSubcomponentId,
                       const TCHAR   *pszInstallSection);
DWORD fxocFile_Uninstall(const TCHAR *pszSubcomponentId,
                         const TCHAR *pszUninstallSection);

DWORD fxocFile_CalcDiskSpace(const TCHAR  *pszSubcomponentId,
                             BOOL         bIsBeingAdded,
                             HDSKSPC      DiskSpace);

DWORD fxocFile_ProcessDirectories(const TCHAR  *pszSection);
DWORD fxocFile_ProcessShares(const TCHAR  *pszSection);

#endif  // _FAXOCM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocmapi.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocMapi.h
//
// Abstract:        Header file used by Mapi source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCMAPI_H_
#define _FXOCMAPI_H_

BOOL fxocMapi_Init(void);
DWORD fxocMapi_Term(void);

DWORD fxocMapi_Install(const TCHAR   *pszSubcomponentId,
                       const TCHAR   *pszInstallSection);
DWORD fxocMapi_Uninstall(const TCHAR *pszSubcomponentId,
                         const TCHAR *pszUninstallSection);

#endif  // _FXOCMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxoclink.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocLink.h
//
// Abstract:        Header file used to create Program Groups/Shortcuts
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 24-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCLINK_H_
#define _FXOCLINK_H_


DWORD fxocLink_Init(void);
DWORD fxocLink_Term(void);
DWORD fxocLink_Install(const TCHAR   *pszSubcomponentId,
                       const TCHAR   *pszInstallSection);
DWORD fxocLink_Uninstall(const TCHAR *pszSubcomponentId,
                         const TCHAR *pszUninstallSection);

#endif  // _FXOCLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxoclink.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocLink.cpp
//
// Abstract:        This code install the program groups and shortcut links
//                  to the fax executables.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 24-Mar-2000  Oren Rosenbloom (orenr)   Created file, cleanup routines
//////////////////////////////////////////////////////////////////////////////

#include "faxocm.h"
#pragma hdrstop

///////////////////////// Static Function Prototypes ////////////////////////

///////////////////////////////
// fxocLink_Init
//
// Initialize the link subsystem
//
// Params:
//      - void
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocLink_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Link Module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocLink_Term
//
// Terminate the link subsystem
// 
// Params:
//      - void
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocLink_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Link Module"),dwRes);

    return dwRes;
}

///////////////////////////////
// fxocLink_Install
//
// Creates the program group and 
// shortcuts as specified in the
// ProfileItem keyword in the given
// install section
//
// Params:
//      - pszSubcomponentId
//      - pszInstallSection - section containing link creation/deletion info.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocLink_Install(const TCHAR     *pszSubcomponentId,
                       const TCHAR     *pszInstallSection)
{
    DWORD       dwReturn = NO_ERROR;
    BOOL        bNextCreateShortcutFound = TRUE;
    HINF        hInf     = faxocm_GetComponentInf();
 
    DBG_ENTER(  _T("fxocLink_Install"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszInstallSection);

    if ((hInf              == NULL) ||
        (pszInstallSection == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // first let's process all the ProfileItems in the section...
    dwReturn = fxocUtil_DoSetup(hInf, 
                                pszInstallSection, 
                                TRUE, 
                                SPINST_PROFILEITEMS,
                                _T("fxocLink_Install"));

    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully installed Fax Shortcuts ")
                _T("from INF file, section '%s'"), 
                pszInstallSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install Fax Shortcuts ")
                _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                pszInstallSection, 
                dwReturn);
    }

    // now let's look for CreateShortcuts directives which are shortcuts with a platform specification
    dwReturn = fxocUtil_SearchAndExecute(pszInstallSection,INF_KEYWORD_PROFILEITEMS_PLATFORM,SPINST_PROFILEITEMS,NULL);
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully installed Fax Shortcuts - platform dependent")
                _T("from INF file, section '%s'"), 
                pszInstallSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to install Fax Shortcuts - platform dependent")
                _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                pszInstallSection, 
                dwReturn);
    }

    return dwReturn;
}

///////////////////////////////
// fxocLink_Uninstall
//
// Deletes the program group and 
// shortcuts as specified in the
// ProfileItem keyword in the given
// install section
//
// Params:
//      - pszSubcomponentId
//      - pszInstallSection - section containing link creation/deletion info.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocLink_Uninstall(const TCHAR     *pszSubcomponentId,
                         const TCHAR     *pszUninstallSection)
{
    DWORD dwReturn = NO_ERROR;
    HINF  hInf     = faxocm_GetComponentInf();

    DBG_ENTER(  _T("fxocLink_Uninstall"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszUninstallSection);

    if ((hInf                == NULL) ||
        (pszUninstallSection == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwReturn = fxocUtil_DoSetup(hInf, 
                                pszUninstallSection, 
                                FALSE, 
                                SPINST_PROFILEITEMS,
                                _T("fxocLink_Uninstall"));

    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully uninstalled Fax Shortcuts ")
                _T("from INF file, section '%s'"), 
                pszUninstallSection);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to uninstall Fax Shortcuts ")
                _T("from INF file, section '%s', dwReturn = 0x%lx"), 
                pszUninstallSection, 
                dwReturn);
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocprnt.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocPrnt.h
//
// Abstract:        Header file used by Fax Printer source files
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 15-Mar-2000  Oren Rosenbloom (orenr)   Created
//////////////////////////////////////////////////////////////////////////////
#ifndef _FXOCPRNT_H_
#define _FXOCPRNT_H_

DWORD fxocPrnt_Init(void);
DWORD fxocPrnt_Term(void);
DWORD fxocPrnt_Install(const TCHAR   *pszSubcomponentId,
                       const TCHAR   *pszInstallSection);
DWORD fxocPrnt_Uninstall(const TCHAR *pszSubcomponentId,
                         const TCHAR *pszUninstallSection);

DWORD fxocPrnt_CreateLocalFaxPrinter(TCHAR   *pszFaxPrinterName);

void fxocPrnt_SetFaxPrinterName(const TCHAR* pszFaxPrinterName);
DWORD fxocPrnt_GetFaxPrinterName(TCHAR* pszFaxPrinterName,
                                 DWORD  dwNumBufChars);


#endif  // _FXOCPRNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocmapi.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocMapi.cpp
//
// Abstract:        This file implements wrappers for all mapi apis.
//                  The wrappers are necessary because mapi does not
//                  implement unicode and this code must be non-unicode.
//
// Environment:     WIN32 User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 7-Aug-1996   Wesley Witt (wesw)        Created (used to be mapi.c)
// 23-Mar-2000  Oren Rosenbloom (orenr)   Minimal cleanup, no change in logic
//
//////////////////////////////////////////////////////////////////////////////
#include "faxocm.h"

#pragma warning (disable : 4200)

#include <mapiwin.h>
#include <mapix.h>
#include <stdio.h>

#pragma warning (default : 4200)


///////////////////////// Static Function Prototypes //////////////////////
static DWORD RemoveTransportProvider(LPSTR lpstrMessageServiceName,LPCTSTR lpctstrProcessName);

#define SYSOCMGR_IMAGE_NAME     _T("sysocmgr.exe")
#define RUNDLL_IMAGE_NAME       _T("rundll32.exe")

///////////////////////////////
// fxocMapi_Init
//
// Initialize the exchange update
// subsystem
// 
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
BOOL fxocMapi_Init(void)
{
    BOOL bRslt = TRUE;
    DBG_ENTER(_T("Init MAPI Module"), bRslt);

    return bRslt;
}

///////////////////////////////
// fxocMapi_Term
//
// Terminate the exchange update
// subsystem
// 
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
// 
DWORD fxocMapi_Term(void)
{
    BOOL bRslt = TRUE;
    DBG_ENTER(_T("Term MAPI Module"),bRslt);

    return bRslt;
}

/*
HOWTO: Find the Correct Path to MAPISVC.INF Under Outlook 2000 

Q229700


SUMMARY
Outlook exposes a function, FGetComponentPath(), in the Mapistub.dll file that helps us find the path to the Mapisvc.inf file. 
This article contains a code sample demonstrating how to do this.

Prior to Outlook 2000, the Mapisvc.inf file was always installed under the system directory (as returned by the Win32 API GetSystemDirectory()). 

Note that the following code sample is also backward compatible with all prior versions of Outlook. 
It will find the path to the Mapisvc.inf file whether it exists under the system directory or not. 
*/

typedef BOOL (STDAPICALLTYPE FGETCOMPONENTPATH)
    (LPSTR szComponent,
    LPSTR szQualifier,
    LPSTR szDllPath,
    DWORD cchBufferSize,
    BOOL fInstall);
typedef FGETCOMPONENTPATH FAR * LPFGETCOMPONENTPATH;

static CHAR s_szMSIApplicationLCID[]   =    "Microsoft\\Office\\9.0\\Outlook\0LastUILanguage\0";
static CHAR s_szMSIOfficeLCID[]        =    "Microsoft\\Office\\9.0\\Common\\LanguageResources\0UILanguage\0InstallLanguage\0";

/////////////////////////////////////////////////////////////////////////////// 
// Function name    : GetMapiSvcInfPath
// Description      : For Outlook 2000 compliance. This will get the correct path to the
//       :              MAPISVC.INF file.
// Return type      : void 
// Argument         : LPSTR szMAPIDir - Buffer to hold the path to the MAPISVC file.
void GetMapiSvcInfPath(LPTSTR szINIFileName)
{
    // Get the mapisvc.inf filename.  
    // The MAPISVC.INF file can live in the system directory.
    // and/or "\Program Files\Common Files\SYSTEM\Mapi"
    UINT                cchT;
    static const TCHAR  szMapiSvcInf[] = TEXT("\\mapisvc.inf");
    LPFGETCOMPONENTPATH pfnFGetComponentPath;

    DBG_ENTER(_T("GetMapiSvcInfPath"));

    // Char array for private mapisvc.inf.
    CHAR szPrivateMAPIDir[MAX_PATH] = {0};

    HINSTANCE hinstStub = NULL;

    // Get Windows System Directory.
    if(!(cchT = GetSystemDirectory(szINIFileName, MAX_PATH)))
        goto Done; //return MAPI_E_CALL_FAILED;

    // Append Filename to the Path.
    _tcscat(szINIFileName, szMapiSvcInf);

    // Call common code in mapistub.dll.
    hinstStub = LoadLibrary(_T("mapistub.dll"));
    if (!hinstStub)
    {
        VERBOSE (DBG_WARNING,_T("LoadLibrary MAPISTUB.DLL failed (ec: %ld)."),GetLastError());
        // Try stub mapi32.dll if mapistub.dll missing.
        hinstStub = LoadLibrary(_T("mapi32.dll"));
        if (!hinstStub)
        {
            VERBOSE (DBG_WARNING,_T("LoadLibrary MAPI32.DLL failed (ec: %ld)."),GetLastError());
            goto Done;
        }
    }

    if(hinstStub)
    {
        pfnFGetComponentPath = (LPFGETCOMPONENTPATH)GetProcAddress(hinstStub, "FGetComponentPath");

        if (!pfnFGetComponentPath)
        {
            VERBOSE (DBG_WARNING,_T("GetProcAddress FGetComponentPath failed (ec: %ld)."),GetLastError());
            goto Done;
        }

        // we know this private MAPI function crashes on ARA machines when called with 
        // NULL as the second parameter.
        // this works on USA and GER and actually, we've never seen this happen anywhere 
        // else. 
        // since we're too close to RTM (XP client) we'll just guard against possible exceptions
        // in this function call.
        // if this crashes, we go on with the path to mapisvc.inf that's in system32.
        // this was our behavior before we encorporated this KB code.
        __try
        {
            if ((pfnFGetComponentPath("{FF1D0740-D227-11D1-A4B0-006008AF820E}",
                    s_szMSIApplicationLCID, szPrivateMAPIDir, MAX_PATH, TRUE) ||
                pfnFGetComponentPath("{FF1D0740-D227-11D1-A4B0-006008AF820E}",
                    s_szMSIOfficeLCID, szPrivateMAPIDir, MAX_PATH, TRUE) ||
                pfnFGetComponentPath("{FF1D0740-D227-11D1-A4B0-006008AF820E}",
                    NULL, szPrivateMAPIDir, MAX_PATH, TRUE)) &&
                    szPrivateMAPIDir[0] != '\0')
            {
                szPrivateMAPIDir[strlen(szPrivateMAPIDir) - 13] = 0;    // Strip "\msmapi32.dll"
            }
            else
            {
                szPrivateMAPIDir[0] = '\0'; // Terminate String at pos 0.
            }

            // Write private mapisvc.inf in szINIFileName if it exists
            if (*szPrivateMAPIDir)
            {
                CHAR szPathToIni[MAX_PATH];
                strcpy(szPathToIni, szPrivateMAPIDir);
                if (MultiByteToWideChar(CP_ACP,
                                        MB_PRECOMPOSED,
                                        szPathToIni,
                                        -1,
                                        szINIFileName,
                                        MAX_PATH)==0)
                {
                    VERBOSE (DBG_WARNING,_T("MultiByteToWideChar failed (ec: %ld)."),GetLastError());
                    goto Done;
                }
                _tcscat(szINIFileName, szMapiSvcInf);
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            VERBOSE(SETUP_ERR,TEXT("FGetComponentPath crashed with error %ld"),GetExceptionCode());
        }

    }

Done:
    VERBOSE (DBG_MSG,_T("Path to MAPISVC.INF is %s"),szINIFileName);

    if (hinstStub) 
    {
        FreeLibrary(hinstStub);
    }
}
 
///////////////////////////////
// fxocMapi_Install
//
// Make changes to exchange to
// allow for integration with fax.
// 
// Params:
//      - pszSubcomponentId.
//      - pszInstallSection - section in INF to install from
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocMapi_Install(const TCHAR   *pszSubcomponentId,
                       const TCHAR   *pszInstallSection)
{
    BOOL  bSuccess                      = FALSE;
    DWORD dwReturn                      = NO_ERROR;
    TCHAR szPathToMapiSvcInf[MAX_PATH]  = {0};

    DBG_ENTER(  _T("fxocMapi_Install"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszInstallSection);

    // we have to find the 'real' MAPISVC.INF somewhere on the system
    GetMapiSvcInfPath(szPathToMapiSvcInf);

    // following section is done to fix the W2K transport provider in MAPISVC.INF
    
    // Under [MSFAX XP] section change PR_SERVICE_DLL_NAME from FAXXP.DLL to FXSXP.DLL
    if (!WritePrivateProfileString( FAX_MESSAGE_SERVICE_NAME_T,
                                    _T("PR_SERVICE_DLL_NAME"),
                                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,
                                    szPathToMapiSvcInf))
    {
        VERBOSE (   GENERAL_ERR, 
                    _T("WritePrivateProfileString (%s %s) failed (ec: %ld)."),
                    _T("PR_SERVICE_DLL_NAME"),
                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,                    
                    GetLastError());
    }
    // Under [MSFAX XP] section change PR_SERVICE_SUPPORT_FILES from FAXXP.DLL to FXSXP.DLL
    if (!WritePrivateProfileString( FAX_MESSAGE_SERVICE_NAME_T,
                                    _T("PR_SERVICE_SUPPORT_FILES"),
                                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,
                                    szPathToMapiSvcInf))
    {
        VERBOSE (   GENERAL_ERR, 
                    _T("WritePrivateProfileString (%s %s) failed (ec: %ld)."),
                    _T("PR_SERVICE_SUPPORT_FILES"),
                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,                    
                    GetLastError());
    }
    // Under [MSFAX XPP] section change PR_PROVIDER_DLL_NAME from FAXXP.DLL to FXSXP.DLL
    if (!WritePrivateProfileString( FAX_MESSAGE_PROVIDER_NAME_T,
                                    _T("PR_PROVIDER_DLL_NAME"),
                                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,
                                    szPathToMapiSvcInf))
    {
        VERBOSE (   GENERAL_ERR, 
                    _T("WritePrivateProfileString (%s %s) failed (ec: %ld)."),
                    _T("PR_PROVIDER_DLL_NAME"),
                    FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T,                    
                    GetLastError());
    }

    // following section is done to remove SBS2000 transport provider from MAPISVC.INF

    if (!WritePrivateProfileString( TEXT("Default Services"), 
                                    FAX_MESSAGE_SERVICE_NAME_SBS50_T,                 
                                    NULL, 
                                    szPathToMapiSvcInf)) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 GetLastError());
    }

    if (!WritePrivateProfileString( TEXT("Services"),
                                    FAX_MESSAGE_SERVICE_NAME_SBS50_T,                 
                                    NULL, 
                                    szPathToMapiSvcInf)) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 GetLastError());
    }

    if (!WritePrivateProfileString( FAX_MESSAGE_SERVICE_NAME_SBS50_T,         
                                    NULL,
                                    NULL,
                                    szPathToMapiSvcInf)) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 GetLastError());
    }

    if (!WritePrivateProfileString( FAX_MESSAGE_PROVIDER_NAME_SBS50_T,        
                                    NULL,
                                    NULL, 
                                    szPathToMapiSvcInf)) 
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("WritePrivateProfileString failed (ec: %ld)."),
                 GetLastError());
    }

    return dwReturn;
}

///////////////////////////////
// fxocMapi_Uninstall
//
// Used to be "DeleteFaxMsgServices"
// in old FaxOCM.dll, it was in
// "mapi.c" file
//
// Params:
//      - pszSubcomponentId.
//      - pszInstallSection - section in INF to install from
//
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocMapi_Uninstall(const TCHAR *pszSubcomponentId,
                         const TCHAR *pszUninstallSection)
{    
    DWORD               dwReturn   = NO_ERROR;

    DBG_ENTER(  _T("fxocMapi_Uninstall"),
                dwReturn,
                _T("%s - %s %d"),
                pszSubcomponentId,
                pszUninstallSection);

    VERBOSE(DBG_MSG,_T("Removing the MSFAX XP51 service provider"));
    if( RemoveTransportProvider(FAX_MESSAGE_SERVICE_NAME,SYSOCMGR_IMAGE_NAME)!=NO_ERROR)
    {
        dwReturn = GetLastError();
        VERBOSE(DBG_WARNING,_T("Cannot delete XP Transport Provider %d"),dwReturn);
    }

    return dwReturn;
}



///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  RemoveTransportProviderFromProfile
//
//  Purpose:        removes the Trasnport Provider from a specific MAPI profile
//
//  Params:
//                  LPSERVICEADMIN lpServiceAdmin - profile to remove the provider from
//                  LPSTR lpstrMessageServiceName - service name to remove
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 13-dec-2000
///////////////////////////////////////////////////////////////////////////////////////
HRESULT RemoveTransportProviderFromProfile(LPSERVICEADMIN lpServiceAdmin,LPSTR lpstrMessageServiceName)
{
    static SRestriction sres;
    static SizedSPropTagArray(2, Columns) =   {2,{PR_DISPLAY_NAME_A,PR_SERVICE_UID}};

    HRESULT         hr                          = S_OK;
    LPMAPITABLE     lpMapiTable                 = NULL;
    LPSRowSet       lpSRowSet                   = NULL;
    LPSPropValue    lpProp                      = NULL;
    ULONG           Count                       = 0;
    BOOL            bMapiInitialized            = FALSE;
    SPropValue      spv;
    MAPIUID         ServiceUID;
    
    DBG_ENTER(TEXT("RemoveTransportProviderFromProfile"), hr);
    // get message service table
    hr = lpServiceAdmin->GetMsgServiceTable(0,&lpMapiTable);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetMsgServiceTable failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    // notify MAPI that we want PR_DISPLAY_NAME_A & PR_SERVICE_UID
    hr = lpMapiTable->SetColumns((LPSPropTagArray)&Columns, 0);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("SetColumns failed (ec: %ld)."),
                 hr);
        goto exit;
    }
 
    // restrict the search to our service provider
    sres.rt = RES_PROPERTY;
    sres.res.resProperty.relop = RELOP_EQ;
    sres.res.resProperty.ulPropTag = PR_SERVICE_NAME_A;
    sres.res.resProperty.lpProp = &spv;

    spv.ulPropTag = PR_SERVICE_NAME_A;
    spv.Value.lpszA = lpstrMessageServiceName;

    // find it
    hr = lpMapiTable->FindRow(&sres, BOOKMARK_BEGINNING, 0);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("FindRow failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    // get our service provider's row
    hr = lpMapiTable->QueryRows(1, 0, &lpSRowSet);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    if (lpSRowSet->cRows != 1)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows returned %d rows, there should be only one."),
                 lpSRowSet->cRows);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    // get the MAPIUID of our service
    lpProp = &lpSRowSet->aRow[0].lpProps[1];

    if (lpProp->ulPropTag != PR_SERVICE_UID)
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("Property is %d, should be PR_SERVICE_UID."),
                 lpProp->ulPropTag);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    // Copy the UID into our member.
    memcpy(&ServiceUID.ab, lpProp->Value.bin.lpb,lpProp->Value.bin.cb);

    // finally, delete our service provider
    hr = lpServiceAdmin->DeleteMsgService(&ServiceUID);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("DeleteMsgService failed (ec: %ld)."),
                 hr);
        goto exit;
    }

exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  RemoveTransportProvider
//
//  Purpose:        removes the Trasnport Provider from MAPI profiles
//
//  Params:
//                  LPSTR lpstrMessageServiceName - service name to remove
//                  LPCTSTR lpctstrProcessName - process for which MAPI calls are routed
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 13-dec-2000
///////////////////////////////////////////////////////////////////////////////////////
DWORD RemoveTransportProvider(LPSTR lpstrMessageServiceName,LPCTSTR lpctstrProcessName)
{
    DWORD           err                             = 0;
    DWORD           rc                              = ERROR_SUCCESS;
    HRESULT         hr                              = S_OK;
    LPSERVICEADMIN  lpServiceAdmin                  = NULL;
    LPMAPITABLE     lpMapiTable                     = NULL;
    LPPROFADMIN     lpProfAdmin                     = NULL;
    LPMAPITABLE     lpTable                         = NULL;
    LPSRowSet       lpSRowSet                       = NULL;
    LPSPropValue    lpProp                          = NULL;
    ULONG           Count                           = 0;
    int             iIndex                          = 0;
    BOOL            bMapiInitialized                = FALSE;
    HINSTANCE       hMapiDll                        = NULL;
                                                    
    LPMAPIINITIALIZE      fnMapiInitialize          = NULL;
    LPMAPIADMINPROFILES   fnMapiAdminProfiles       = NULL;
    LPMAPIUNINITIALIZE    fnMapiUninitialize        = NULL;

    DBG_ENTER(TEXT("RemoveTransportProvider"), rc);

    CRouteMAPICalls rmcRouteMapiCalls;

    
    // now remove the MAPI Service provider
    rc = rmcRouteMapiCalls.Init(lpctstrProcessName);
    if (rc!=ERROR_SUCCESS)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("CRouteMAPICalls::Init failed (ec: %ld)."), rc);
        goto exit;
    }
    
    hMapiDll = LoadLibrary(_T("MAPI32.DLL"));
    if (NULL == hMapiDll)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadLibrary"), GetLastError()); 
        goto exit;
    }

    fnMapiInitialize = (LPMAPIINITIALIZE)GetProcAddress(hMapiDll, "MAPIInitialize");
    if (NULL == fnMapiInitialize)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(MAPIInitialize)"), GetLastError());  
        goto exit;
    }

    fnMapiAdminProfiles = (LPMAPIADMINPROFILES)GetProcAddress(hMapiDll, "MAPIAdminProfiles");
    if (NULL == fnMapiAdminProfiles)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(fnMapiAdminProfiles)"), GetLastError());  
        goto exit;
    }

    fnMapiUninitialize = (LPMAPIUNINITIALIZE)GetProcAddress(hMapiDll, "MAPIUninitialize");
    if (NULL == fnMapiUninitialize)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(MAPIUninitialize)"), GetLastError());  
        goto exit;
    }

    // get access to MAPI functinality
    hr = fnMapiInitialize(NULL);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("MAPIInitialize failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    bMapiInitialized = TRUE;

    // get admin profile object
    hr = fnMapiAdminProfiles(0,&lpProfAdmin);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("MAPIAdminProfiles failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    // get profile table
    hr = lpProfAdmin->GetProfileTable(0,&lpTable);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("GetProfileTable failed (ec: %ld)."),
                 rc = hr);
        goto exit;
    }

    // get profile rows
    hr = lpTable->QueryRows(4000, 0, &lpSRowSet);
    if (FAILED(hr))
    {
        VERBOSE (GENERAL_ERR, 
                 TEXT("QueryRows failed (ec: %ld)."),
                 hr);
        goto exit;
    }

    for (iIndex=0; iIndex<(int)lpSRowSet->cRows; iIndex++)
    {
        lpProp = &lpSRowSet->aRow[iIndex].lpProps[0];

        if (lpProp->ulPropTag != PR_DISPLAY_NAME_A)
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("Property is %d, should be PR_DISPLAY_NAME_A."),
                     lpProp->ulPropTag);
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_TABLE);
            goto exit;
        }

        hr = lpProfAdmin->AdminServices(LPTSTR(lpProp->Value.lpszA),NULL,0,0,&lpServiceAdmin);
        if (FAILED(hr))
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("AdminServices failed (ec: %ld)."),
                     rc = hr);
            goto exit;
        }
         
        hr = RemoveTransportProviderFromProfile(lpServiceAdmin,lpstrMessageServiceName);
        if (FAILED(hr))
        {
            VERBOSE (GENERAL_ERR, 
                     TEXT("RemoveTransportProviderFromProfile failed (ec: %ld)."),
                     rc = hr);
            goto exit;
        }
    }

exit:

    if (bMapiInitialized)
    {
        fnMapiUninitialize();
    }

    if (hMapiDll)
    {
        FreeLibrary(hMapiDll);
        hMapiDll = NULL;
    }

    return rc;
}

#define prv_DEBUG_FILE_NAME         _T("%windir%\\FaxSetup.log")

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  AWF_UninstallProvider
//
//  Purpose:        removes the AWF Trasnport Provider from MAPI profiles
//                  called from Active Setup key for every new user once.
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 01-Jun-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD AWF_UninstallProvider()
{    
    DWORD dwReturn = NO_ERROR;
    SET_FORMAT_MASK(DBG_PRNT_ALL_TO_FILE);
    SET_DEBUG_MASK(DBG_ALL);
    OPEN_DEBUG_LOG_FILE(prv_DEBUG_FILE_NAME);
    {
        DBG_ENTER(_T("AWF_UninstallProvider"),dwReturn);

        // this is an upgrade from W9X, we should remove the AWF transport.
        VERBOSE(DBG_MSG,_T("Removing the AWFAX service provider"));
        if( RemoveTransportProvider(FAX_MESSAGE_SERVICE_NAME_W9X,RUNDLL_IMAGE_NAME)!=NO_ERROR)
        {
            VERBOSE(DBG_WARNING,_T("Cannot delete W9X Transport Provider %d"),GetLastError());
        }
    }
    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  PFW_UninstallProvider
//
//  Purpose:        removes the PFW Trasnport Provider from MAPI profiles
//                  called from Active Setup key for every new user once.
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 01-Jun-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD PFW_UninstallProvider()
{    
    DWORD dwReturn = NO_ERROR;

    SET_FORMAT_MASK(DBG_PRNT_ALL_TO_FILE);
    SET_DEBUG_MASK(DBG_ALL);
    OPEN_DEBUG_LOG_FILE(prv_DEBUG_FILE_NAME);
    {
        DBG_ENTER(_T("PFW_UninstallProvider"),dwReturn);

        // this is an upgrade from W2K, we should remove the PFW transport.
        VERBOSE(DBG_MSG,_T("Removing the MSFAX XP service provider"));
        if( RemoveTransportProvider(FAX_MESSAGE_SERVICE_NAME_W2K,RUNDLL_IMAGE_NAME)!=NO_ERROR)
        {
            VERBOSE(DBG_WARNING,_T("Cannot delete W2K Transport Provider %d"),GetLastError());
        }
    }
    return dwReturn;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  XP_UninstallProvider
//
//  Purpose:        removes the Windows XP Trasnport Provider from MAPI profiles
//                  called from Active Setup key for every new user once.
//
//  Params:
//                  None
//
//  Return Value:
//                  Win32 Error code
//
//  Author:
//                  Mooly Beery (MoolyB) 01-Jun-2001
///////////////////////////////////////////////////////////////////////////////////////
DWORD XP_UninstallProvider()
{    
    DWORD dwReturn = NO_ERROR;

    SET_FORMAT_MASK(DBG_PRNT_ALL_TO_FILE);
    SET_DEBUG_MASK(DBG_ALL);
    OPEN_DEBUG_LOG_FILE(prv_DEBUG_FILE_NAME);
    {
        DBG_ENTER(_T("XP_UninstallProvider"),dwReturn);

        VERBOSE(DBG_MSG,_T("Removing the MSFAX XP service provider"));
        if( RemoveTransportProvider(FAX_MESSAGE_SERVICE_NAME,RUNDLL_IMAGE_NAME)!=NO_ERROR)
        {
            VERBOSE(DBG_WARNING,_T("Cannot delete XP Transport Provider %d"),GetLastError());
        }
    }
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\setup\ocm\fxocprnt.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File Name:       fxocPrnt.cpp
//
// Abstract:        This provides the printer routines used in the FaxOCM
//                  code base.
//
// Environment:     Windows XP / User Mode
//
// Copyright (c) 2000 Microsoft Corporation
//
// Revision History:
//
// Date:        Developer:                Comments:
// -----        ----------                ---------
// 17-Feb-1996  Wesley Witt (wesw)        Created routines originally from util.cpp
// 21-Mar-2000  Oren Rosenbloom (orenr)   Cleaned up, renamed, re-organized fns
// 17-Jul-2000  Eran Yariv (erany)        Added CoClassInstalled code
// 08-Jan-2001  Mooly Beery (moolyb)      Modified CoClassInstaller (wizard integration)
//////////////////////////////////////////////////////////////////////////////

#include "faxocm.h"
#pragma hdrstop
#include <shellapi.h> 
#include <winsprlp.h>
  

// W2K Printer defines
#define prv_W2K_FAX_PORT_NAME           _T("MSFAX:")                        // Win2K Fax printer port name
#define prv_W2K_FAX_DRIVER_NAME         _T("Windows NT Fax Driver")         // Win2K Fax printer driver name
#define prv_W2K_FAX_MONITOR_NAME        _T("Windows NT Fax Monitor")        // Win2K Fax printer monitor name

#define prv_SYSTEM32_PATH               _T("%windir%\\system32")
#define prv_SERVER_SERVICE_NAME         _T("LanmanServer")
#define prv_SPOOLER_SERVICE_NAME        _T("Spooler")

//////////////////////// Static Function Prototypes /////////////////////////
static DWORD prv_DeleteFaxPrinter(LPCTSTR lpctstrDriverName, LPCTSTR lpctstrPortName);

static DWORD prv_CreatePrintMonitor(const TCHAR   *pszMonitorName,
                                    const TCHAR   *pszMonitorFile);

static DWORD prv_DeletePrintMonitor(const TCHAR   *pszMonitorName);

static DWORD prv_DeleteFaxPrinterDrivers(LPTSTR lptstrDriverName,DWORD dwVersionFlag);

static DWORD prv_AddFaxPrinterDriver(LPCTSTR lpctstrDriverSourcePath);

DWORD IsFaxInstalled (LPBOOL lpbInstalled);

DWORD 
InstallFaxUnattended ();

static INT_PTR CALLBACK prv_dlgInstallFaxQuestion(HWND, UINT, WPARAM, LPARAM);

///////////////////////////////
// prv_GVAR
//
//
static struct prv_GVAR
{
    TCHAR szFaxPrinterName[255 + 1];
} prv_GVAR;

static bool bIsPnpInstallation = true;

///////////////////////////////
// fxocPrnt_Init
//
// Initialize the fax printer
// subsystem.
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocPrnt_Init(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Init Print Module"),dwRes);
    return dwRes;
}

///////////////////////////////
// fxocPrnt_Term
//
// Terminate the fax printer
// subsystem.
//
// Params:
//      - void.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocPrnt_Term(void)
{
    DWORD dwRes = NO_ERROR;
    DBG_ENTER(_T("Term Print Module"),dwRes);
    return dwRes;
}


///////////////////////////////
// fxocPrnt_Install
//
// Create a fax printer on this 
// machine if one doesn't already
// exists.
//
// Params:
//      - pszSubcomponentId
//      - pszInstallSection
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
//
DWORD fxocPrnt_Install(const TCHAR  *pszSubcomponentId,
                       const TCHAR  *pszInstallSection)
{
    DWORD           dwReturn      = NO_ERROR;
    DWORD           dwFaxDevicesCount = 0;

    DBG_ENTER(  _T("fxocPrnt_Install"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszInstallSection);
    //
    // Before we do anything related to the printer, make sure that the 'LanManServer'
    // service is started.
    // The AddPrinter() code in the spooler service requires the LanManServer (SMB file sharing service)
    // service to be running.  
    // For some reason LanManServer is not running yet when doing a system install (GUI mode) of 
    // Windows XP Professional (in Server it does).
    //

    // it's possible that LanmanServer is not installed on Desktop SKUs
    if (!IsDesktopSKU())
    {
        dwReturn = fxocSvc_StartService(prv_SERVER_SERVICE_NAME);
        if (dwReturn == NO_ERROR)
        {
            VERBOSE(DBG_MSG,
                    _T("Successfully started '%s' service, continuing Printer Install"),
                    prv_SERVER_SERVICE_NAME);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to start '%s' service, rc = 0x%lx, abandoning ")
                    _T("fax printer installation"),
                    prv_SERVER_SERVICE_NAME,
                    dwReturn);

            return dwReturn;
        }
    }

    // verify that the spooler is up
    dwReturn = fxocSvc_StartService(prv_SPOOLER_SERVICE_NAME);
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully started '%s' service, continuing Printer Install"),
                prv_SPOOLER_SERVICE_NAME);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to start '%s' service, rc = 0x%lx, abandoning ")
                _T("fax printer installation"),
                prv_SPOOLER_SERVICE_NAME,
                dwReturn);

        return dwReturn;
    }
    //
    // always attemp to remove W2K fax printer 
    dwReturn = prv_DeleteFaxPrinter(prv_W2K_FAX_DRIVER_NAME, prv_W2K_FAX_PORT_NAME);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Failed to delete W2K fax printer, rc = 0x%lx"),
                dwReturn);

        dwReturn = NO_ERROR;
    }
    //
    // delete the W2K printer driver files
    //
    dwReturn = prv_DeleteFaxPrinterDrivers(prv_W2K_FAX_DRIVER_NAME,3);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Failed to delete W2K fax drivers, rc = 0x%lx"),
                dwReturn);
        dwReturn = NO_ERROR;
    }
    //
    // delete the W2K fax print monitor.
    //
    dwReturn = prv_DeletePrintMonitor(prv_W2K_FAX_MONITOR_NAME);
    if (dwReturn != NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Failed to delete W2K fax monitor, rc = 0x%lx"),
                dwReturn);
        dwReturn = NO_ERROR;
    }
    //
    // okay lets go and create a fax printer monitor.
    //
    if (dwReturn == NO_ERROR)
    {
        // create the print monitor
        dwReturn = prv_CreatePrintMonitor(FAX_MONITOR_NAME,
                                          FAX_MONITOR_FILE);
        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Fax Printer Install, ")
                    _T("failed to create fax printer monitor, rc=0x%lx"),
                    dwReturn);

        }
    }
    //
    // Copy the fax printer driver files
    //
    if (dwReturn == NO_ERROR)
    {
        dwReturn = prv_AddFaxPrinterDriver(prv_SYSTEM32_PATH);

        if (dwReturn != NO_ERROR)
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to copy Fax Printer Drivers from '%s', ")
                    _T("attempting to install fax printer anyway..., rc=0x%lx"),
                    prv_SYSTEM32_PATH,
                    dwReturn);

            dwReturn = NO_ERROR;
        }
    }
    //
    // Count the number of Fax-capable modems the system has
    //
    dwReturn = GetFaxCapableTapiLinesCount(&dwFaxDevicesCount, FAX_MODEM_PROVIDER_NAME);
    if (ERROR_SUCCESS != dwReturn)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetFaxCapableTapiLinesCount"), dwReturn);
        //
        // Assume no fax-capable devices exist
        //
        dwFaxDevicesCount = 0;
        dwReturn = NO_ERROR;
    }
    //
    // We do not create the printer by default unless;
    //    1. There are now fax-capable modems in the system or
    //    2. a fax printer was already there.
    //
    // Otherwise, only the monitor and drivers are installed.
    // The printer itself will be added either when an FSP / EFSP is registered or 
    // when a modem is installed.
    //
    if (dwFaxDevicesCount && (dwReturn == NO_ERROR))
    {
        TCHAR szFaxPrinterName[255 + 1] = {0};

        dwReturn = fxocPrnt_GetFaxPrinterName(szFaxPrinterName, 
                                              sizeof(szFaxPrinterName) / sizeof(TCHAR));
        if (ERROR_SUCCESS != dwReturn)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("fxocPrnt_GetFaxPrinterName"), dwReturn);
            return dwReturn;
        }
        //    
        // Create the fax printer.
        //
        dwReturn = AddLocalFaxPrinter (szFaxPrinterName, NULL);
        if (dwReturn == NO_ERROR)
        {
            VERBOSE(DBG_MSG,
                    _T("Fax Printer Install, created fax printer ")
                    _T("Name = '%s', Driver Name = '%s'"),
                    szFaxPrinterName, 
                    FAX_DRIVER_NAME);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("fxocPrnt_Install, ")
                    _T("failed to create fax printer, rc = 0x%lx"),
                    dwReturn);
        }
    }
    return dwReturn;
}

///////////////////////////////
// fxocPrnt_Uninstall
//
// Remove all fax printers on this
// machine.
//
// Params:
//      - pszSubcomponentId
//      - pszUninstallSection.
// Returns:
//      - NO_ERROR on success.
//      - error code otherwise.
// 
//
DWORD fxocPrnt_Uninstall(const TCHAR  *pszSubcomponentId,
                         const TCHAR  *pszUninstallSection)
{
    DWORD dwReturn = NO_ERROR;

    // before we do anything related to the printer, make sure that the 'Server'
    // service is started.
    DBG_ENTER(  _T("fxocPrnt_Uninstall"),
                dwReturn,
                _T("%s - %s"),
                pszSubcomponentId,
                pszUninstallSection);

    // it's possible that LanmanServer is not installed on Desktop SKUs
    if (!IsDesktopSKU())
    {
        dwReturn = fxocSvc_StartService(prv_SERVER_SERVICE_NAME);
        if (dwReturn == NO_ERROR)
        {
            VERBOSE(DBG_MSG,
                    _T("Successfully started '%s' service, continuing Printer uninstall"),
                    prv_SERVER_SERVICE_NAME);
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("Failed to start '%s' service, rc = 0x%lx, abandoning ")
                    _T("fax printer uninstall"),
                    prv_SERVER_SERVICE_NAME,
                    dwReturn);

            return dwReturn;
        }
    }
    // verify that the spooler is up
    dwReturn = fxocSvc_StartService(prv_SPOOLER_SERVICE_NAME);
    if (dwReturn == NO_ERROR)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully started '%s' service, continuing Printer Install"),
                prv_SPOOLER_SERVICE_NAME);
    }
    else
    {
        VERBOSE(SETUP_ERR,
                _T("Failed to start '%s' service, rc = 0x%lx, abandoning ")
                _T("fax printer installation"),
                prv_SPOOLER_SERVICE_NAME,
                dwReturn);

        return dwReturn;
    }

    // remove the fax printer
    prv_DeleteFaxPrinter(FAX_DRIVER_NAME, FAX_MONITOR_PORT_NAME);

    // remove fax printer monitor
    prv_DeletePrintMonitor(FAX_MONITOR_NAME);

    // remove all fax printer drivers
    prv_DeleteFaxPrinterDrivers(FAX_DRIVER_NAME,3);

    return dwReturn;
}

///////////////////////////////
// fxocPrnt_SetFaxPrinterName
//
// Sets the name of the fax printer.
// This must be called prior to the
// creation of the fax printer via
// fxocPrnt_Install.
// 
// Params:
//      - pszFaxPrinterName - new name for fax printer.
// Returns:
//      - void.
//
void fxocPrnt_SetFaxPrinterName(const TCHAR* pszFaxPrinterName)
{
    DBG_ENTER(  _T("fxocPrnt_SetFaxPrinterName"),
                _T("%s"),
                pszFaxPrinterName);

    if (pszFaxPrinterName)
    {
        _tcsncpy(prv_GVAR.szFaxPrinterName, 
                 pszFaxPrinterName,
                 sizeof(prv_GVAR.szFaxPrinterName) / sizeof(TCHAR));
    }
    else
    {
        memset(prv_GVAR.szFaxPrinterName, 
               0, 
               sizeof(prv_GVAR.szFaxPrinterName));
    }

    return;
}

///////////////////////////////
// fxocPrnt_GetFaxPrinterName
//
// Returns the current name of the 
// fax printer.
//
// Params:
//      - pszFaxPrinterName - OUT 
//      - dwNumBufChars
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
DWORD fxocPrnt_GetFaxPrinterName(TCHAR* pszFaxPrinterName,
                                 DWORD  dwNumBufChars)
{
    DWORD dwReturn = NO_ERROR;
    DBG_ENTER(  _T("fxocPrnt_GetFaxPrinterName"), dwReturn);

    if ((pszFaxPrinterName == NULL) ||
        (dwNumBufChars     == 0))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        return dwReturn;
    }

    if (prv_GVAR.szFaxPrinterName[0] != 0)
    {
        _tcsncpy(pszFaxPrinterName, 
                 prv_GVAR.szFaxPrinterName,
                 dwNumBufChars);
    }
    else
    {
        //
		// nobody set the fax printer name, so return the default
        // table.
        _tcsncpy(pszFaxPrinterName, 
                 FAX_PRINTER_NAME,
                 dwNumBufChars);
    }

    return dwReturn;
}   // fxocPrnt_GetFaxPrinterName

///////////////////////////////////
// prv_AddFaxPrinterDriver
//
// Add printer driver to the server machine.
// In case of failure, do clean-up and returns FALSE.
// Temp files are deleted allways.
//              
// Params:
//      - lpctstrDriverSourcePath  : The directory where the printer's 
//        driver files are located (put there by the setup)
//
static DWORD prv_AddFaxPrinterDriver(LPCTSTR lpctstrDriverSourcePath)
{
    DWORD   dwReturn                           = NO_ERROR;
    BOOL    bSuccess                           = FALSE;
    DWORD   dwNeededSize                       = 0;
    TCHAR   szPrinterDriverDirectory[MAX_PATH] = {0};
    TCHAR   szSourceDir[MAX_PATH]              = {0};
    DWORD   dwNumChars                         = 0;

    DBG_ENTER(  _T("prv_AddFaxPrinterDriver"),
                dwReturn,
                _T("%s"),
                lpctstrDriverSourcePath);

    if (!GetPrinterDriverDirectory(NULL,
                                   NULL,
                                   1,
                                   (LPBYTE)szPrinterDriverDirectory,
                                   sizeof(szPrinterDriverDirectory),
                                   &dwNeededSize))
    {
        dwReturn = GetLastError();
        VERBOSE(SETUP_ERR,
                TEXT("AddW2KFaxPrinterDriver: ")
                TEXT("GetPrinterDriverDirectory failed - %d."),
                dwReturn);
        return dwReturn;
    }

    bSuccess = TRUE;

    VERBOSE(DBG_MSG,
            _T("Printer driver directory is %s\n"),
            szPrinterDriverDirectory);

    ////////////////////////////////////////////////////////////////////////
    //
    // Copy the WIN2K driver files to where it should be before calling
    // AddPrinterDriver().
    //
    ////////////////////////////////////////////////////////////////////////
    
    LPCTSTR filesToCopy[] = 
    {
        FAX_UI_MODULE_NAME,
        FAX_DRV_MODULE_NAME,
        FAX_WZRD_MODULE_NAME,
        FAX_TIFF_MODULE_NAME,
        FAX_API_MODULE_NAME,
        FAX_RES_FILE
    };

    if (bSuccess)
    {
        dwNumChars = ExpandEnvironmentStrings(lpctstrDriverSourcePath,
                                              szSourceDir,
                                              sizeof(szSourceDir) / sizeof(TCHAR));
        if (dwNumChars == 0)
        {
            VERBOSE(SETUP_ERR,
                     _T("ExpandEnvironmentStrings failed, rc = 0x%lx"),
                     ::GetLastError());

            bSuccess = FALSE;
        }
    }

    if (bSuccess)
    {
        bSuccess = MultiFileCopy(sizeof(filesToCopy)/sizeof(LPCTSTR),
                                 filesToCopy,
                                 szSourceDir,
                                 szPrinterDriverDirectory);

        if (!bSuccess)
        {
            VERBOSE(SETUP_ERR,
                    _T("MultiFileCopy failed (ec: %ld)"),
                    GetLastError());
        }
    }

    if (bSuccess)
    {
        ///////////////////////////////////////////////////////////////////////   
        //
        // Add the WIN2K fax printer driver.
        //
        ///////////////////////////////////////////////////////////////////////   

        DRIVER_INFO_3 DriverInfo3;
        ZeroMemory(&DriverInfo3,sizeof(DRIVER_INFO_3));

        DriverInfo3.cVersion         = 3;
        DriverInfo3.pName            = FAX_DRIVER_NAME;
        DriverInfo3.pEnvironment     = NULL;
        DriverInfo3.pDriverPath      = FAX_DRV_MODULE_NAME;
        DriverInfo3.pDataFile        = FAX_UI_MODULE_NAME;
        DriverInfo3.pConfigFile      = FAX_UI_MODULE_NAME;
        DriverInfo3.pDependentFiles  = FAX_WZRD_MODULE_NAME TEXT("\0") 
                                       FAX_TIFF_MODULE_NAME TEXT("\0")
                                       FAX_RES_FILE TEXT("\0")
                                       FAX_API_MODULE_NAME TEXT("\0");
        DriverInfo3.pMonitorName     = NULL;
        DriverInfo3.pHelpFile        = NULL;
        DriverInfo3.pDefaultDataType = TEXT("RAW");

        bSuccess = AddPrinterDriverEx(NULL,
                                      3,
                                      (LPBYTE)&DriverInfo3,
                                      APD_COPY_NEW_FILES|APD_DONT_SET_CHECKPOINT);

        if (bSuccess)
        {
            VERBOSE(DBG_MSG,_T("Successfully added new fax printer drivers"));
        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("AddPrinterDriverEx failed (ec: %ld)"),
                    GetLastError());
        }
    }

    //
    // Delete the temporary fax DLL files.
    //
    if (!MultiFileDelete(sizeof(filesToCopy)/sizeof(LPCTSTR),
                         filesToCopy,
                         szPrinterDriverDirectory))
    {
        VERBOSE(SETUP_ERR,
                _T("MultiFileDelete() failed (ec: %ld)"),
                GetLastError());
    }

    if (!bSuccess)
    {
        dwReturn = ::GetLastError();
    }

    return dwReturn;
}



///////////////////////////////
// prv_DeletePrinter
//
// Delete printer by name. The driver name and the port name are just for debug print.
//
// Params:
//      - pszPrinterName - name of printer to delete
//      - pszFaxDriver   - name of associated driver 
//      - pszPortName    - name of associated port.
//
static DWORD prv_DeletePrinter(const TCHAR   *pszPrinterName,
                               const TCHAR   *pszFaxDriver,
                               const TCHAR   *pszPortName)
{
    DWORD   dwReturn = NO_ERROR;
    BOOL    bSuccess = FALSE;
    HANDLE  hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = 
    {
        NULL,
        NULL,
        PRINTER_ALL_ACCESS
    };

    DBG_ENTER(  _T("prv_DeletePrinter"),
                dwReturn,
                _T("%s - %s - %s"),
                pszPrinterName,
                pszFaxDriver,
                pszPortName);

    if ((pszPrinterName == NULL) ||
        (pszFaxDriver   == NULL) ||
        (pszPortName    == NULL))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        return dwReturn;
    }

    bSuccess = ::OpenPrinter((TCHAR*) pszPrinterName,
                             &hPrinter,
                             &PrinterDefaults);

    if (bSuccess)
    {
        VERBOSE(DBG_MSG,
                _T("prv_DeletePrinter, deleting ")
                _T("printer '%s' with Driver Name = '%s', ")
                _T("Port Name = '%s'"), 
                pszPrinterName,
                pszFaxDriver, 
                pszPortName);

        if (!SetPrinter(hPrinter,0,NULL,PRINTER_CONTROL_PURGE))
        {
            // Don't let a failure here keep us from attempting the delete
            VERBOSE(PRINT_ERR,TEXT("SetPrinter failed (purge jobs before uninstall) ec=%d"),GetLastError());
        }

        bSuccess = ::DeletePrinter(hPrinter);

        if (!bSuccess)
        {
            dwReturn = ::GetLastError();

            VERBOSE(SETUP_ERR,
                    _T("prv_DeletePrinter, failed to delete ")
                    _T("fax printer '%s', rc = 0x%lx"),
                    pszPrinterName,
                    dwReturn);
        }

        bSuccess = ::ClosePrinter(hPrinter);

        if (!bSuccess)
        {
            dwReturn = ::GetLastError();

            VERBOSE(SETUP_ERR,
                    _T("prv_DeletePrinter, failed to Close ")
                    _T("fax printer '%s', rc = 0x%lx"),
                    pszPrinterName,
                    dwReturn);
        }

        hPrinter = NULL;
    }

    return dwReturn;
}

///////////////////////////////
// prv_DeleteFaxPrinter
//
// Delete fax printer with driver name and port as passed in params
//
// Params: 
//              LPCTSTR lpctstrDriverName   - printer driver name to delete
//              LPCTSTR lpctstrPortName     - printer port name

//
//
//
static DWORD prv_DeleteFaxPrinter(LPCTSTR lpctstrDriverName, LPCTSTR lpctstrPortName)
{
    BOOL            bSuccess        = FALSE;
    DWORD           dwReturn        = NO_ERROR;
    DWORD           dwCount         = 0;
    DWORD           i               = 0;
    PPRINTER_INFO_2 pPrinterInfo    = NULL;

    DBG_ENTER(_T("prv_DeleteFaxPrinter"),dwReturn);

    pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL, 
                                                    2, 
                                                    &dwCount, 
                                                    PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS);

    VERBOSE(DBG_MSG,
            _T("DeleteFaxPrinter, found %lu printers installed ")
            _T("on this computer"), 
            dwCount);

    if (pPrinterInfo)
    {
        for (i=0; i < dwCount; i++) 
        {
            // Check if printer has same driver same port name
            if (_tcsicmp(pPrinterInfo[i].pDriverName, lpctstrDriverName)    == 0  &&
                _tcsicmp(pPrinterInfo[i].pPortName,   lpctstrPortName)   == 0)
                 
            {
                // We can have a Local printer here or a Printer connection.
                // we differentiate between the two by the ServerName field of
                // PRINTER_INFO_2
                if (pPrinterInfo[i].pServerName==NULL)
                {
                    // this is a local printer.
                    dwReturn = prv_DeletePrinter(pPrinterInfo[i].pPrinterName,
                                                 lpctstrDriverName,
                                                 lpctstrPortName);
                    if (dwReturn != NO_ERROR)
                    {
                        VERBOSE(SETUP_ERR,
                                _T("Failed to delete printer '%s', rc = 0x%lx, ")
                                _T("continuing anyway..."),
                                pPrinterInfo[i].pPrinterName,
                                dwReturn);

                        dwReturn = NO_ERROR;
                    }
                }
                else
                {
                    // this is a printer connection
                    if (!DeletePrinterConnection(pPrinterInfo[i].pPrinterName))
                    {
                        dwReturn = GetLastError();
                        VERBOSE(SETUP_ERR,
                                _T("Failed to delete printer connection '%s', rc = 0x%lx, ")
                                _T("continuing anyway..."),
                                pPrinterInfo[i].pPrinterName,
                                dwReturn);

                        dwReturn = NO_ERROR;
                    }
                }
            }
        }

        MemFree(pPrinterInfo);
    }

    return dwReturn;
}

///////////////////////////////
// prv_CreatePrintMonitor
//
// Create the printer monitor
//
// Params:
//      - pszMonitorName - name of printer monitor
//      - pszMonitorFile - name of print monitor file
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
static DWORD prv_CreatePrintMonitor(const TCHAR   *pszMonitorName,
                                    const TCHAR   *pszMonitorFile)
{
    BOOL            bSuccess = TRUE;
    DWORD           dwReturn = NO_ERROR;
    MONITOR_INFO_2  MonitorInfo;

    DBG_ENTER(  _T("prv_CreatePrintMonitor"),
                dwReturn,
                _T("%s - %s"),
                pszMonitorName,
                pszMonitorFile);

    if ((pszMonitorName == NULL) ||
        (pszMonitorFile == NULL))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        return dwReturn;
    }

    MonitorInfo.pName         = (TCHAR*) pszMonitorName;
    MonitorInfo.pDLLName      = (TCHAR*) pszMonitorFile;
    MonitorInfo.pEnvironment  = NULL;

    bSuccess = ::AddMonitor(NULL, 2, (LPBYTE) &MonitorInfo);

    if (bSuccess)
    {
        VERBOSE(DBG_MSG,
                _T("Successfully created fax monitor '%s', ")
                _T("File Name '%s'"), 
                pszMonitorName,
                pszMonitorFile);
    }
    else
    {
        dwReturn = ::GetLastError();

        if (dwReturn == ERROR_PRINT_MONITOR_ALREADY_INSTALLED)
        {
            VERBOSE(DBG_MSG,
                    _T("AddMonitor, failed because '%s' monitor already ")
                    _T("exists.  This is fine, let's continue..."),
                    pszMonitorName);

            dwReturn = NO_ERROR;

        }
        else
        {
            VERBOSE(SETUP_ERR,
                    _T("CreatePrinterMonitor, failed to ")
                    _T("add new print monitor '%s', rc = 0x%lx"), 
                    pszMonitorName, 
                    dwReturn);
        }
    }

    return dwReturn;
}


///////////////////////////////
// prv_DeletePrintMonitor
//
// Delete the printer monitor
//
// Params:
//      - pszMonitorName - name of print monitor to delete
// Returns:
//      - NO_ERROR on success
//      - error code otherwise.
//
static DWORD prv_DeletePrintMonitor(const TCHAR   *pszMonitorName)
                                    
{
    BOOL            bSuccess = TRUE;
    DWORD           dwReturn = NO_ERROR;
    DBG_ENTER(  _T("prv_DeletePrintMonitor"),
                dwReturn,
                _T("%s"),
                pszMonitorName);

    if (pszMonitorName == NULL)
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        return dwReturn;
    }

    bSuccess = ::DeleteMonitor(NULL, NULL, (LPTSTR) pszMonitorName);

    if (bSuccess)
    {
        VERBOSE(DBG_MSG,
                _T("DeletePrinterMonitor, successfully ")
                _T("deleted print monitor name '%s'"), 
                pszMonitorName);
    }
    else
    {
        dwReturn = ::GetLastError();

        if (dwReturn != ERROR_UNKNOWN_PRINT_MONITOR)
        {
            VERBOSE(SETUP_ERR,
                    _T("DeletePrinterMonitor, failed to ")
                    _T("remove print monitor '%s', rc = 0x%lx"), 
                    pszMonitorName, 
                    dwReturn);
        }
        else
        {
            dwReturn = NO_ERROR;
        }
    }

    return dwReturn;
}

////////////////////////////
// prv_DeleteFaxPrinterDrivers
//
// Delete fax printer driver from current machine
// In case of failure, log it and returns FALSE.
//
// Params:
//      - LPTSTR lptstrDriverName   -   Driver name to delete
//      - DWORD dwVersionFlag       -   The version of the driver that should be deleted. 
//                                      Valid valuse {0,1,2,3} only.
// Returns;
//      - Returns ERROR_SUCCESS on success, on failue retuen the error code. 
//
static DWORD prv_DeleteFaxPrinterDrivers(LPTSTR lptstrDriverName,DWORD dwVersionFlag)
{
    BOOL    bSuccess = TRUE;
    DWORD   ec       = ERROR_SUCCESS;

    DBG_ENTER(_T("prv_DeleteFaxPrinterDrivers"),ec);

    ASSERTION(dwVersionFlag<=3);

    // delete driver.
    bSuccess = DeletePrinterDriverEx(NULL,
                                     NULL,
                                     lptstrDriverName,
                                     DPD_DELETE_SPECIFIC_VERSION|DPD_DELETE_ALL_FILES,
                                     dwVersionFlag);
    if (!bSuccess)
    {
        ec = GetLastError();
        VERBOSE(DBG_MSG,
                TEXT("DeletePrinterDriverEx() for driver %s, version %ld failed (ec: %ld)"),
                lptstrDriverName,
                dwVersionFlag,
                ec);
    } 
    else
    {
        VERBOSE(DBG_MSG,
                TEXT("DeletePrinterDriverEx() for driver %s, version %ld succeeded"),
                lptstrDriverName,
                dwVersionFlag);
    }

    return ec;
}



/***************************************************************************************
**                                                                                    **
**              C o C l a s s I n s t a l l e r   s e c t i o n                       **
**                                                                                    **
***************************************************************************************/


#ifdef ENABLE_LOGGING

typedef struct _DIF_DEBUG {
    DWORD DifValue;
    LPTSTR DifString;
} DIF_DEBUG, *PDIF_DEBUG;

DIF_DEBUG DifDebug[] =
{
    { 0,                                    L""                                     },  //  0x00000000
    { DIF_SELECTDEVICE,                     L"DIF_SELECTDEVICE"                     },  //  0x00000001
    { DIF_INSTALLDEVICE,                    L"DIF_INSTALLDEVICE"                    },  //  0x00000002
    { DIF_ASSIGNRESOURCES,                  L"DIF_ASSIGNRESOURCES"                  },  //  0x00000003
    { DIF_PROPERTIES,                       L"DIF_PROPERTIES"                       },  //  0x00000004
    { DIF_REMOVE,                           L"DIF_REMOVE"                           },  //  0x00000005
    { DIF_FIRSTTIMESETUP,                   L"DIF_FIRSTTIMESETUP"                   },  //  0x00000006
    { DIF_FOUNDDEVICE,                      L"DIF_FOUNDDEVICE"                      },  //  0x00000007
    { DIF_SELECTCLASSDRIVERS,               L"DIF_SELECTCLASSDRIVERS"               },  //  0x00000008
    { DIF_VALIDATECLASSDRIVERS,             L"DIF_VALIDATECLASSDRIVERS"             },  //  0x00000009
    { DIF_INSTALLCLASSDRIVERS,              L"DIF_INSTALLCLASSDRIVERS"              },  //  0x0000000A
    { DIF_CALCDISKSPACE,                    L"DIF_CALCDISKSPACE"                    },  //  0x0000000B
    { DIF_DESTROYPRIVATEDATA,               L"DIF_DESTROYPRIVATEDATA"               },  //  0x0000000C
    { DIF_VALIDATEDRIVER,                   L"DIF_VALIDATEDRIVER"                   },  //  0x0000000D
    { DIF_MOVEDEVICE,                       L"DIF_MOVEDEVICE"                       },  //  0x0000000E
    { DIF_DETECT,                           L"DIF_DETECT"                           },  //  0x0000000F
    { DIF_INSTALLWIZARD,                    L"DIF_INSTALLWIZARD"                    },  //  0x00000010
    { DIF_DESTROYWIZARDDATA,                L"DIF_DESTROYWIZARDDATA"                },  //  0x00000011
    { DIF_PROPERTYCHANGE,                   L"DIF_PROPERTYCHANGE"                   },  //  0x00000012
    { DIF_ENABLECLASS,                      L"DIF_ENABLECLASS"                      },  //  0x00000013
    { DIF_DETECTVERIFY,                     L"DIF_DETECTVERIFY"                     },  //  0x00000014
    { DIF_INSTALLDEVICEFILES,               L"DIF_INSTALLDEVICEFILES"               },  //  0x00000015
    { DIF_UNREMOVE,                         L"DIF_UNREMOVE"                         },  //  0x00000016
    { DIF_SELECTBESTCOMPATDRV,              L"DIF_SELECTBESTCOMPATDRV"              },  //  0x00000017
    { DIF_ALLOW_INSTALL,                    L"DIF_ALLOW_INSTALL"                    },  //  0x00000018
    { DIF_REGISTERDEVICE,                   L"DIF_REGISTERDEVICE"                   },  //  0x00000019
    { DIF_NEWDEVICEWIZARD_PRESELECT,        L"DIF_NEWDEVICEWIZARD_PRESELECT"        },  //  0x0000001A
    { DIF_NEWDEVICEWIZARD_SELECT,           L"DIF_NEWDEVICEWIZARD_SELECT"           },  //  0x0000001B
    { DIF_NEWDEVICEWIZARD_PREANALYZE,       L"DIF_NEWDEVICEWIZARD_PREANALYZE"       },  //  0x0000001C
    { DIF_NEWDEVICEWIZARD_POSTANALYZE,      L"DIF_NEWDEVICEWIZARD_POSTANALYZE"      },  //  0x0000001D
    { DIF_NEWDEVICEWIZARD_FINISHINSTALL,    L"DIF_NEWDEVICEWIZARD_FINISHINSTALL"    },  //  0x0000001E
    { DIF_UNUSED1,                          L"DIF_UNUSED1"                          },  //  0x0000001F
    { DIF_INSTALLINTERFACES,                L"DIF_INSTALLINTERFACES"                },  //  0x00000020
    { DIF_DETECTCANCEL,                     L"DIF_DETECTCANCEL"                     },  //  0x00000021
    { DIF_REGISTER_COINSTALLERS,            L"DIF_REGISTER_COINSTALLERS"            },  //  0x00000022
    { DIF_ADDPROPERTYPAGE_ADVANCED,         L"DIF_ADDPROPERTYPAGE_ADVANCED"         },  //  0x00000023
    { DIF_ADDPROPERTYPAGE_BASIC,            L"DIF_ADDPROPERTYPAGE_BASIC"            },  //  0x00000024
    { DIF_RESERVED1,                        L"DIF_RESERVED1"                        },  //  0x00000025
    { DIF_TROUBLESHOOTER,                   L"DIF_TROUBLESHOOTER"                   },  //  0x00000026
    { DIF_POWERMESSAGEWAKE,                 L"DIF_POWERMESSAGEWAKE"                 },  //  0x00000027
    { DIF_ADDREMOTEPROPERTYPAGE_ADVANCED,   L"DIF_ADDREMOTEPROPERTYPAGE_ADVANCED"   }   //  0x00000028
};

#endif

/*
///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  InSystemSetup
//
//  Purpose:        
//                  Find out if we're running in system setup or standalone
//
//  Params:
//                  See CoClassInstaller documentation in DDK
//
//  Return Value:
//                  TRUE - running in system setup.
//                  FALSE - standalone (or error)
//
//  Author:
//                  Mooly Beery (MoolyB) 05-Apr-2001
///////////////////////////////////////////////////////////////////////////////////////
static BOOL InSystemSetup
(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
)
{
    SP_DEVINSTALL_PARAMS dip;
    BOOL bRet = FALSE;

    DBG_ENTER(_T("InSystemSetup"), bRet);

    ZeroMemory(&dip, sizeof(SP_DEVINSTALL_PARAMS));
    dip.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &dip)) 
    {
        VERBOSE(DBG_MSG,TEXT("Flags %x, FlagEx %x"),dip.Flags,dip.FlagsEx);
        if ((dip.Flags & DI_QUIETINSTALL) || (dip.FlagsEx & DI_FLAGSEX_IN_SYSTEM_SETUP)) 
        {
            VERBOSE(DBG_MSG,TEXT("Flags indicate that we're in System setup"));
            bRet = TRUE;
        }
        else 
        {
            VERBOSE(DBG_MSG,TEXT("Flags indicate that we're not in System setup"));
        }
    }
    else 
    {
        CALL_FAIL(GENERAL_ERR,TEXT("SetupDiGetDeviceInstallParams"), GetLastError());
    }
    return bRet;
}
*/


DWORD
IsFaxInstalled (
    LPBOOL lpbInstalled
    )
/*++

Routine name : IsFaxInstalled

Routine description:

    Determines if the fax service is installed by looking into the OCM registry

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    lpbInstalled                  [out]    - Result flag

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwVal;
    HKEY  hKey;
    DBG_ENTER(_T("IsFaxInstalled"), dwRes);

    hKey = OpenRegistryKey (HKEY_LOCAL_MACHINE,
                            REGKEY_FAX_SETUP,
                            FALSE,
                            KEY_READ);
    if (!hKey)
    {
        dwRes = GetLastError ();
        CALL_FAIL (GENERAL_ERR, TEXT("OpenRegistryKey"), dwRes);
        //
        // Key couldn't be opened => Fax isn't installed
        //
        *lpbInstalled = FALSE;
        dwRes = ERROR_SUCCESS;
        return dwRes;
    }
    dwVal = GetRegistryDword (hKey, REGVAL_FAXINSTALLED);
    RegCloseKey (hKey);
    VERBOSE (DBG_MSG, L"Fax is%s installed on the system", dwVal ? L" " : L" not");
    *lpbInstalled = dwVal ? TRUE : FALSE;
    return dwRes;
}   // IsFaxInstalled


DWORD
InstallFaxUnattended ()
/*++

Routine name : InstallFaxUnattended

Routine description:

    Performs an unattended installation of fax and waits for it to end

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    struct _InfInfo
    {   
        LPCWSTR     lpcwstrName;
        LPCSTR      lpcstrContents;
    } Infs[2];

    Infs[0].lpcwstrName = L"FaxOc.inf";
    Infs[0].lpcstrContents = "[Version]\n"
                             "Signature=\"$Windows NT$\"\n"
                             "[Components]\n"
                             "Fax=fxsocm.dll,FaxOcmSetupProc,fxsocm.inf\n";
    Infs[1].lpcwstrName = L"FaxUnattend.inf";
    Infs[1].lpcstrContents = "[Components]\n"
                             "Fax=on\n\n"
                             "[Fax]\n"
                             "SuppressConfigurationWizard=False\n";

    DBG_ENTER(_T("InstallFaxUnattended"), dwRes);
    //
    // Get temp directory path
    //
    WCHAR wszTempDir[MAX_PATH+1];
    dwRes = GetTempPath (sizeof (wszTempDir) / sizeof (wszTempDir[0]), wszTempDir);
    if (!dwRes || dwRes > sizeof (wszTempDir) / sizeof (wszTempDir[0]))
    {
        dwRes = GetLastError();
        CALL_FAIL (FILE_ERR, TEXT("GetTempPath"), dwRes);
        return dwRes;
    }
    //
    // Create the files needed for unattended fax setup
    //
    for (DWORD dw = 0; dw < sizeof (Infs) / sizeof (Infs[0]); dw++)
    {
        WCHAR wszFileName[MAX_PATH * 2];
        DWORD dwBytesWritten;
        swprintf (wszFileName, TEXT("%s%s"), wszTempDir, Infs[dw].lpcwstrName);
        HANDLE hFile = CreateFile ( wszFileName,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            dwRes = GetLastError ();
            CALL_FAIL (FILE_ERR, TEXT("CreateFile"), dwRes);
            return dwRes;
        }
        if (!WriteFile (hFile,
                        (LPVOID)Infs[dw].lpcstrContents,
                        strlen (Infs[dw].lpcstrContents),
                        &dwBytesWritten,
                        NULL))
        {
            dwRes = GetLastError ();
            CALL_FAIL (FILE_ERR, TEXT("WriteFile"), dwRes);
            CloseHandle (hFile);
            return dwRes;
        }
        CloseHandle (hFile);
    }
    //
    // Compose the command line parameters
    //
    WCHAR wszCmdLineParams[MAX_PATH * 3];
    if (0 >= _sntprintf (wszCmdLineParams, 
                         sizeof (wszCmdLineParams) / sizeof (wszCmdLineParams[0]),
                         TEXT("/y /i:%s%s /unattend:%s%s"),
                         wszTempDir,
                         Infs[0].lpcwstrName,
                         wszTempDir,
                         Infs[1].lpcwstrName))
    {
        dwRes = ERROR_BUFFER_OVERFLOW;
        CALL_FAIL (GENERAL_ERR, TEXT("_sntprintf"), dwRes);
        return dwRes;
    }

    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof (SHELLEXECUTEINFO);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;

    sei.lpVerb = TEXT("open");
    sei.lpFile = TEXT("SysOcMgr.exe");
    sei.lpParameters = wszCmdLineParams;
    sei.lpDirectory  = TEXT(".");
    sei.nShow  = SW_SHOWNORMAL;

    //
    // Execute SysOcMgr.exe and wait for it to end
    //
    if(!ShellExecuteEx(&sei))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("ShellExecuteEx"), dwRes);
        return dwRes;
    }
    //
    // Set hourglass cursor and wait for setup to finish
    //
    HCURSOR hOldCursor = ::SetCursor (::LoadCursor(NULL, IDC_WAIT));
    
    dwRes = WaitForSingleObject(sei.hProcess, INFINITE);
    switch(dwRes)
    {
        case WAIT_OBJECT_0:
            //
            // Shell execute completed successfully
            //
            dwRes = ERROR_SUCCESS;
            break;

        default:
            CALL_FAIL (GENERAL_ERR, TEXT("WaitForSingleObject"), dwRes);
            break;
    }
    //
    // Restore previous cursor
    //
    ::SetCursor (hOldCursor);
    return dwRes;
}   // InstallFaxUnattended

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  SaveDontShowMeThisAgain
//
//  Purpose:        
//                  Check if the user checked the 'Don't show me this again'
//                  If he did, set the registry key
//                  
//  Params:
//                  Handle to window
