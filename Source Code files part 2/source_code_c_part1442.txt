 {

        if( CheckControlC() ) {
            goto cleanup;
        }

        //
        // Read the heap entry, invoke the enumeration proc.
        //

        if( !ReadMemory(
                (ULONG_PTR)remoteHeapEntry,
                &localHeapEntry,
                sizeof(localHeapEntry),
                NULL
                ) ) {
           goto cleanup;
        }

        if( !EnumProc(
                Param,
                &localHeapEntry,
                remoteHeapEntry
                ) ) {
            break;
        }

        //
        // Advance to the next entry.
        //

        remoteHeapEntry = (PHEAP_ENTRY)( (PUCHAR)remoteHeapEntry +
            ( localHeapEntry.Size << HEAP_GRANULARITY_SHIFT ) );

        //
        // If this is the last entry in this run, then we'll need
        // some special handling to skip over the uncommitted ranges
        // (if any).
        //

        if( localHeapEntry.Flags & HEAP_ENTRY_LAST_ENTRY ) {

            if( remoteUCR == NULL ) {
                break;
            }

            //
            // Skip the uncommitted range, then read the next uncommitted
            // range descriptor if available.
            //

            remoteHeapEntry = (PHEAP_ENTRY)( (PUCHAR)remoteHeapEntry +
                localUCR.Size );

            remoteUCR = localUCR.Next;

            if( remoteUCR != NULL ) {
                if( !ReadMemory(
                        (ULONG_PTR)remoteUCR,
                        &localUCR,
                        sizeof(localUCR),
                        NULL
                        ) ) {
                   goto cleanup;
                }
            }

        }

    }

    result = TRUE;

cleanup:

    return result;

}   // EnumHeapSegmentEntries


BOOLEAN
EnumHeapFreeLists(
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN PFN_ENUMHEAPFREELISTS EnumProc,
    IN PVOID Param
    )
{

    BOOLEAN result = FALSE;
    ULONG i;
    PLIST_ENTRY nextEntry;
    PHEAP_FREE_ENTRY remoteFreeHeapEntry;
    HEAP_FREE_ENTRY localFreeHeapEntry;

    //
    // Scan the free lists.
    //

    for( i = 0 ; i < HEAP_MAXIMUM_FREELISTS ; i++ ) {

        if( CheckControlC() ) {
            goto cleanup;
        }

        nextEntry = LocalHeap->FreeLists[i].Flink;

        while( nextEntry != &RemoteHeap->FreeLists[i] ) {

            if( CheckControlC() ) {
                goto cleanup;
            }

            remoteFreeHeapEntry = CONTAINING_RECORD(
                                      nextEntry,
                                      HEAP_FREE_ENTRY,
                                      FreeList
                                      );

            //
            // Read the heap entry, invoke the enumerator.
            //

            if( !ReadMemory(
                    (ULONG_PTR)remoteFreeHeapEntry,
                    &localFreeHeapEntry,
                    sizeof(localFreeHeapEntry),
                    NULL
                    ) ) {
                goto cleanup;
            }

            if( !EnumProc(
                    Param,
                    &localFreeHeapEntry,
                    remoteFreeHeapEntry
                    ) ) {
                break;
            }

        }

    }

    result = TRUE;

cleanup:

    return result;

}   // EnumHeapFreeLists
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbgwxin.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    dbgwxin.cxx

Abstract:

    This module contains the default ntsd debugger extensions for
    IIS - WAM

Author:

    DaveK  3-Oct-1997

Revision History:

--*/

#include "inetdbgp.h"
#include <wamxbase.hxx>
//
//  undef these macros, which otherwise would break compile
//  UNDONE remove these macros from inetdbgp.h
//
#undef malloc
#undef calloc
#undef realloc
#undef free
#include <isapip.hxx>
#include <wamobj.hxx>

# undef DBG_ASSERT


VOID
PrintWamExecInfo( WAM_EXEC_BASE * pwxinOriginal,
                  WAM_EXEC_BASE * pwxin,
                  CHAR Verbosity );

VOID
PrintWamExecInfoThunk( PVOID pwxDebuggee,
                      PVOID pwxDebugger,
                      CHAR  verbosity,
                      DWORD iCount)
{

    //
    //  NOTE we must thunk through this function because
    //  EnumLinkedList expects a PFN_LIST_ENUMERATOR,
    //  which is what this function is
    //

    PrintWamExecInfo(
        (WAM_EXEC_BASE *) pwxDebuggee
        , (WAM_EXEC_BASE *) pwxDebugger
        , verbosity
    );


    return;

} // PrintWamRequestThunk()



VOID
DumpWamExecInfoList(
    char * lpArgumentString
    , PFN_LIST_ENUMERATOR pfnWX
)
{
    CHAR Verbosity;
    LIST_ENTRY * pwxListHead;

    //
    // set verbosity to character immediately after the 'l'
    // or to '0' if none
    //

    lpArgumentString++;
    Verbosity = (*lpArgumentString == ' ')
                ? '0'
                : *lpArgumentString
                ;
    lpArgumentString++;

    //
    // move past spaces - bail if we reach end of string
    //

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if ( !*lpArgumentString ) {
        PrintUsage( "wxin" );
        return;
    }


    //
    // remainder of argument string is wam address
    // in debuggee process
    //

    WAM * pwam = (WAM *) GetExpression( lpArgumentString );

    if ( !pwam ) {

        dprintf(
            "inetdbg.wxin: Unable to evaluate \"%s\"\n"
            , lpArgumentString
        );

        return;
    }

    //
    //  address of list head within debuggee process
    //  = (wam address) + (offset of list head entry within WAM struct)
    //

    pwxListHead
        = (LIST_ENTRY *)
          ( ((BYTE *) pwam) + FIELD_OFFSET(WAM, m_WamExecInfoListHead) );

    if ( NULL == pwxListHead) {

        dprintf( " Unable to get WamExecInfo list \n");
        return;
    }

    EnumLinkedList(
        pwxListHead
        , pfnWX
        , Verbosity
        , sizeof( WAM_EXEC_BASE)
        , FIELD_OFFSET( WAM_EXEC_BASE, _ListEntry )
    );

    return;

} // DumpWamExecInfoList()




DECLARE_API( wxin )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    DEFINE_CPP_VAR( WAM_EXEC_BASE, wxin );
    WAM_EXEC_BASE * pwxin;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "wxin" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( "wxin" );
            return;
        }

        if ( *lpArgumentString == 'l' ) {

            DumpWamExecInfoList(
                lpArgumentString
                , PrintWamExecInfoThunk
            );

            return;
        }

    } // if

    //
    //  Treat the argument as the address of a WAM_EXEC_BASE
    //

    pwxin = (WAM_EXEC_BASE * ) GetExpression( lpArgumentString );

    if ( !pwxin )
    {
        dprintf( "inetdbg.wxin: Unable to evaluate \"%s\"\n",
                 lpArgumentString );

        return;
    }

    move( wxin, pwxin );
    PrintWamExecInfo( pwxin, GET_CPP_VAR_PTR( WAM_EXEC_BASE, wxin), '2');

    return;

} // DECLARE_API( wxin )



VOID
PrintWamExecInfo( WAM_EXEC_BASE * pwxinOriginal,
                  WAM_EXEC_BASE * pwxin,
                  CHAR Verbosity )
/*++
  Description:
    This function takes the WAM_EXEC_BASE object and prints out
    the details for the same in the debugger. The granularity of the
    deatils are controlled by the verbosity flag

  Arguments:
    pwxinOriginal - pointer to the location where the original WAM_EXEC_BASE
                  object is located.
                  Note: pwxinOriginal points to object inside debuggee process
    pwxin         - pointer to the WAM_EXEC_BASE object that is a copy
                  of the contents located at [pwxinOriginal]
                  Note: pwxin points to object inside the debugger process
    Verbostiy   - level of details requested.

  Returns:
    None
--*/
{


    if ( Verbosity >= '0') {

        //
        //  Print basic info for the WAM_EXEC_BASE object
        //

        dprintf(
            "WAM_EXEC_BASE: %08p   m_pWam = %08p   m_fInProcess = %08x\n"
            "\tRef count = %d  \n"
            "\t m_pIWamReqIIS       = %08p   m_pIWamReqInproc   = %08p \n"
            "\t m_pIWamReqSmartISA  = %08p   m_gipIWamRequest   = %08x \n"
            "\t m_dwThreadIdIIS     = %08x   m_dwThreadIdISA    = %08x \n"

            , pwxinOriginal
            , pwxin->m_pWam
            , pwxin->m_fInProcess
            , pwxin->_cRefs
            , pwxin->m_pIWamReqIIS
            , pwxin->m_pIWamReqInproc
            , pwxin->m_pIWamReqSmartISA
            , pwxin->m_gipIWamRequest
            , pwxin->m_dwThreadIdIIS
            , pwxin->m_dwThreadIdISA
        );

    }

    if ( Verbosity >= '1') {

        //
        //  Print more details for the WAM_EXEC_BASE object
        //

        dprintf(
            "\t _FirstThread        = %08x   _psExtension       = %08p \n"
            "\t _dwFlags            = %08x   _dwChildExecFlags  = %08x \n"

            "\t _ListEntry.Flink    = %08p   _ListEntry.Blink   = %08p \n"

            "\tASYNC_IO_INFO embedded structure: \n"
            "\t _dwOutstandingIO    = %d     _cbLastAsyncIO     = %d \n"
            "\t _pfnHseIO           = %08p   _pvHseIOContext    = %08p \n"

            , 0
            , pwxin->_psExtension
            , pwxin->_dwFlags
            , pwxin->_dwChildExecFlags

            , pwxin->_ListEntry.Flink
            , pwxin->_ListEntry.Blink

            , pwxin->_AsyncIoInfo._dwOutstandingIO
            , pwxin->_AsyncIoInfo._cbLastAsyncIO
            , pwxin->_AsyncIoInfo._pfnHseIO
            , pwxin->_AsyncIoInfo._pvHseIOContext
        );

    }

    if ( Verbosity >= '2') {

        //
        //  UNDONE print strings?
        //  Print all details for the WAM_EXEC_INFO object
        //

    }

    return;

} // PrintWamExecInfo()




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\enummod.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    enummod.cxx

Abstract:

    This module implements a remote module enumerator.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include "inetdbgp.h"


BOOLEAN
EnumModules(
    IN PFN_ENUMMODULES EnumProc,
    IN PVOID Param
    )

/*++

Routine Description:

    Enumerates all loaded modules in the debugee.

Arguments:

    EnumProc - An enumeration proc that will be invoked for each module.

    Param - An uninterpreted parameter passed to the enumeration proc.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    PROCESS_BASIC_INFORMATION basicInfo;
    NTSTATUS status;
    PPEB peb;
    PPEB_LDR_DATA ldr;
    PLIST_ENTRY ldrHead, ldrNext;
    PLDR_DATA_TABLE_ENTRY ldrEntry;
    LDR_DATA_TABLE_ENTRY ldrEntryData;
    WCHAR tmpName[MAX_PATH];
    MODULE_INFO moduleInfo;

    //
    // Get the process info.
    //

    status = NtQueryInformationProcess(
                 ExtensionCurrentProcess,
                 ProcessBasicInformation,
                 &basicInfo,
                 sizeof(basicInfo),
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        return FALSE;
    }

    peb = basicInfo.PebBaseAddress;

    if( peb == NULL ) {
        return FALSE;
    }

    //
    // ldr = peb->Ldr
    //

    if( !ReadMemory(
            (ULONG_PTR)&peb->Ldr,
            &ldr,
            sizeof(ldr),
            NULL
            ) ) {
        return FALSE;
    }

    ldrHead = &ldr->InMemoryOrderModuleList;

    //
    // ldrNext = ldrHead->Flink;
    //

    if( !ReadMemory(
            (ULONG_PTR)&ldrHead->Flink,
            &ldrNext,
            sizeof(ldrNext),
            NULL
            ) ) {
        return FALSE;
    }

    while( ldrNext != ldrHead ) {

        if( CheckControlC() ) {
            break;
        }

        //
        // Read the LDR_DATA_TABLE_ENTRY structure and the module name.
        //

        ldrEntry = CONTAINING_RECORD(
                       ldrNext,
                       LDR_DATA_TABLE_ENTRY,
                       InMemoryOrderLinks
                       );

        if( !ReadMemory(
                (ULONG_PTR)ldrEntry,
                &ldrEntryData,
                sizeof(ldrEntryData),
                NULL
                ) ) {
            return FALSE;
        }

        if( !ReadMemory(
                (ULONG_PTR)ldrEntryData.BaseDllName.Buffer,
                tmpName,
                ldrEntryData.BaseDllName.MaximumLength,
                NULL
                ) ) {
            return FALSE;
        }

        wsprintfA(
            moduleInfo.BaseName,
            "%ws",
            tmpName
            );

        if( !ReadMemory(
                (ULONG_PTR)ldrEntryData.FullDllName.Buffer,
                tmpName,
                ldrEntryData.FullDllName.MaximumLength,
                NULL
                ) ) {
            return FALSE;
        }

        wsprintfA(
            moduleInfo.FullName,
            "%ws",
            tmpName
            );

        moduleInfo.DllBase = (ULONG_PTR)ldrEntryData.DllBase;
        moduleInfo.EntryPoint = (ULONG_PTR)ldrEntryData.EntryPoint;
        moduleInfo.SizeOfImage = (ULONG)ldrEntryData.SizeOfImage;

        //
        // Invoke the callback.
        //

        if( !(EnumProc)(
                Param,
                &moduleInfo
                ) ) {
            break;
        }

        ldrNext = ldrEntryData.InMemoryOrderLinks.Flink;

    }

    return TRUE;

}   // EnumModules
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dumpoff.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dumpoff.cxx

Abstract:

    Structure dumper

Author:

    Bilal Alam      (balam)     Oct-17-1998 Initial Revision

--*/

#include "inetdbgp.h"
#include "oemdbi.h"
#include "cvinfo.h"
#include "imagehlp.h"

#define INVALID_LENGTH              ((DWORD)-1)

#define MAX_MEMBERNAME_LENGTH       256
#define MAX_TYPENAME_LENGTH         256
#define MAX_ARG_SIZE                256

typedef DWORD (*PFN_READ_MEMORY) (
    VOID * address, 
    DWORD cbBytes, 
    VOID *pBuffer 
);

typedef DWORD (*PFN_PRINTF) (
    CHAR * pszBuffer,
    DWORD cbBytes
);

typedef struct _STRUCTURE_MEMBER {
    CHAR                    achMemberName[ MAX_MEMBERNAME_LENGTH + 1 ];
    DWORD                   cbOffset;
    DWORD                   cbMaxSize;
} STRUCTURE_MEMBER, *PSTRUCTURE_MEMBER;

typedef struct _STRUCTURE_TEMPLATE {
    CHAR                    achName[ MAX_TYPENAME_LENGTH + 1 ];
    PSTRUCTURE_MEMBER       pMembers;
    DWORD                   cMembers;
    DWORD                   cUseful;
    DWORD                   cbTotalSize;
    DWORD                   Type;
} STRUCTURE_TEMPLATE, *PSTRUCTURE_TEMPLATE;

DWORD
GetOffset(
    BYTE *              pBuffer,
    DWORD *             pcbOffset
);

DWORD
ReadFieldList(
    TPI *               pTypeInterface,
    STRUCTURE_TEMPLATE* pStructure,
    lfFieldList *       pFieldList, 
    DWORD               cbLen,
    DWORD               dwFlags
);

DWORD
ReadBClass(
    TPI *               pTypeInterface,
    lfBClass *          pBClass, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadMember(
    lfMember*           pMember, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadNestType(
    lfNestType*         pNestType, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadOneMethod(
    lfOneMethod*        pOneMethod, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadMethod(
    lfMethod*           pMethod, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadVTable(
    lfVFuncTab*         pVTable, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
ReadStaticMember(
    lfSTMember*         pStaticMember, 
    DWORD *             pcbReturnSize, 
    DWORD *             pcbOffset,
    CHAR *              pszBuffer,
    DWORD               cbBuffer
);

DWORD
InitializeStructureTemplate(
    PSTRUCTURE_TEMPLATE pTemplate
);

DWORD
TerminateStructureTemplate(
    PSTRUCTURE_TEMPLATE pTemplate
);

VOID
DumpoffUsage(
    VOID
);

DWORD
OutputTemplate(
    STRUCTURE_TEMPLATE *    pTemplate,
    CHAR *                  pszMemberName,
    DWORD                   dwFlags,
    PVOID                   pvAddress,
    PFN_READ_MEMORY         pfnReadMemory,
    PFN_PRINTF              pfnPrintf 
);

DWORD
BuildMemberList(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN TPI *                pTypeInterface,
    IN TI                   tiType,
    IN BOOL                 fTypeSizeOnly
);

DWORD
BuildMemberListForTypeName(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN PDB *                pPDB,
    IN LPSTR                pszTypeName
);

DWORD
FindMembersOfTypeSize(
    IN PDB *                pPDB,
    IN DWORD                cbSize,
    IN PFN_PRINTF           pfnPrintf
);

DWORD
OutputTemplate(
    STRUCTURE_TEMPLATE *    pTemplate,
    CHAR *                  pszMemberName,
    DWORD                   dwFlags,
    PVOID                   pvAddress,
    PFN_READ_MEMORY         pfnReadMemory,
    PFN_PRINTF              pfnPrintf 
)
/*++

Routine Description:

    Output a structure template.
    
    If pvAddress is NULL, then this function will output a general template
    of the structure, listing each member along with its offset from the 
    start of the structure.
    
    If pvAddress is non-NULL, then this function will output the structure
    with the memory at pvAddress cast as this type.  
    
    If pszMemberName is NULL, then the above two statements apply to all 
    members of the structure.  If pszMember is not NULL, then the statements
    apply only the member whose name is pszMember.
    
Arguments:

    pTemplate - Template to dump
    pszMemberName - Optional member name filter
    dwFlags - Flags describing Output() details.  Currently not supported
    pvAddress - Optional address of memory to cast as type
    pfnReadMemory - Provides read memory functionality
    pfnPrintf - Provides printf functionality

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    DWORD                   cCounter;
    BOOL                    fDidSomething = FALSE;
    PBYTE                   pBuffer = NULL;
    DWORD                   dwError = ERROR_SUCCESS;
    CHAR                    achFormat[ 256 ];
    DWORD                   cbRunningLength;
    BOOL                    fLastBitField = FALSE;
    DWORD                   cBitField = 0;
    DWORD                   dwTotalMask;
    DWORD                   cbSize;
    INT                     i;
    
    pBuffer = (PBYTE) LocalAlloc( LPTR, pTemplate->cbTotalSize );
    if ( pBuffer == NULL )
    {
        dwError = GetLastError();
        goto Finished;
    }

    // 
    // If address is specified, then read the amount required for this 
    // structure.  Otherwise, we are simply dumping the template and thus
    // output the size of the type 
    //
    
    if ( pvAddress )
    {
        dwError = pfnReadMemory( pvAddress, pTemplate->cbTotalSize, pBuffer );
        if ( dwError != ERROR_SUCCESS )
        {
            goto Finished;
        }
    }
    else
    {
        _snprintf( achFormat,
                   sizeof( achFormat ),
                   "sizeof( %s %s ) = 0x%X bytes (%d bytes)\n",
                   pTemplate->Type == LF_CLASS ? "class" : "struct",
                   pTemplate->achName,
                   pTemplate->cbTotalSize,
                   pTemplate->cbTotalSize );
        pfnPrintf( achFormat, -1 );
    }
    
    //
    // Iterate through consequential members of type
    //
   
    for( cCounter = 0;
         cCounter < pTemplate->cUseful;
         cCounter++ )
    {
    
        //
        // Do filtering on member name if specified
        //
    
        if ( pszMemberName )
        {
            if ( fDidSomething )
            {
                break;
            }
            
            if ( strcmp( pTemplate->pMembers[ cCounter ].achMemberName,
                         pszMemberName ) )
            {
                continue;
            }
        }
        
        //
        // Dump member name
        //
        
        cbRunningLength = pfnPrintf( pTemplate->pMembers[ cCounter ].achMemberName,
                                     -1 );
        
        //
        // Formatting junk
        //
        
        for ( i = cbRunningLength;
              i < 25;
              i++ )
        {
            cbRunningLength += pfnPrintf( " ", -1 );
        }
        
        cbRunningLength += pfnPrintf( " = ", -1 );
        
        achFormat[ 0 ] = '\0';
        cbSize = pTemplate->pMembers[ cCounter ].cbMaxSize;
       
        if ( !pvAddress )
        {
            //
            // Just dumping template.  Output the offset from the start of 
            // the type
            //
        
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "+%8X",
                       pTemplate->pMembers[ cCounter ].cbOffset );
        }
        else if ( !cbSize ||
             ( ( cbSize == sizeof( DWORD ) ) && fLastBitField ) ) 
        {
            //
            // If the maxsize is 0, then this must be a bitfield
            // If the maxsize is 4, and the last item was a bit field, then
            // this must be the last bit of the bit field.
            //
            // TODO:  Need to make this work for bit fields larger than 32
            //
            
            if ( !fLastBitField )
            {
                fLastBitField = TRUE;
            }
            cBitField++;
            
            dwTotalMask = (DWORD) *(DWORD*) ((PBYTE)pBuffer+
                             pTemplate->pMembers[ cCounter ].cbOffset);
            
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "%s",
                       (dwTotalMask & (1 << ( cBitField - 1 ))) ? "TRUE" : "FALSE" );
            
            if ( cbSize == sizeof( DWORD ) )
            {
                fLastBitField = FALSE;
                cBitField = 0;
            }
        }
        else if ( cbSize != sizeof( DWORD ) )
        {
            //
            // If this structure is not a DWORD in size, then assume we don't 
            // know how to dump it affectly.  In this case, we will simply
            // dump out the address at which the member data starts
            //
            
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "%016p..",
                       (PBYTE) pvAddress +
                         pTemplate->pMembers[ cCounter ].cbOffset );
        }
        else
        {
            //
            // This is a DWORD sized member.  We can dump out the value
            // effectively -> so we do it
            //
            
            _snprintf( achFormat,
                       sizeof( achFormat ),
                       "%08X",
                       (DWORD) *(DWORD*) ((PBYTE)pBuffer+ 
                         pTemplate->pMembers[ cCounter ].cbOffset ) );
        }
        
        cbRunningLength += pfnPrintf( achFormat, -1 );
        
        //
        // Two column display.  Given 80 columns, seems like the only 
        // reasonable setting (maybe 1 column is useful?)
        //
        
        if ( pszMemberName ||
             ( cCounter % 2 ) )
        {
            pfnPrintf( "\n", -1 );
        }
        else
        {
            for ( i = cbRunningLength;
                  i < 40;
                  i++ )
            {
                pfnPrintf( " ", -1 );
            }
        }
        
        //
        // Keep tabs on whether we actually dumped something 
        //
        
        fDidSomething = TRUE;
    }
    
    if ( !fDidSomething )
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }
    
    pfnPrintf( "\n", -1 );

Finished:
    if ( pBuffer != NULL )
    {
        LocalFree( pBuffer );
    }
    return dwError;
}

DWORD
BuildMemberListForTypeName(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN PDB *                pPDB,
    IN LPSTR                pszTypeName
)
/*++

Routine Description:

    Build the structure template for a given type
    
Arguments:

    pTemplate - Template to populate (must have been previously inited)
    pPDB - PDB structure opened using MSDBI!PDBOpen
    pszTypeName - Name of type

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    TPI *                   pTypeInterface = NULL;
    TI                      RootTI;
    DWORD                   dwError = ERROR_SUCCESS;
    PB                      pb;
    
    if ( !pTemplate || !pPDB || !pszTypeName )
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Finished;
    }

    //
    // Get the type interface
    //
    
    if ( !PDBOpenTpi( pPDB,
                      pdbRead,
                      &pTypeInterface ) )
    {
        dwError = GetLastError();
        goto Finished;
    }

    //
    // Does this PDB have the necessary type information?
    //

    if ( TypesQueryTiMinEx( pTypeInterface ) ==
         TypesQueryTiMacEx( pTypeInterface ) )
    {
        dwError = ERROR_NOT_SUPPORTED;
        goto Finished;
    }
    
    //
    // Lookup with specified type
    //
    
    if ( !TypesQueryTiForUDTEx( pTypeInterface,
                                pszTypeName,
                                TRUE,
                                &RootTI) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Finished;
    }
    
    strncpy( pTemplate->achName,
             pszTypeName,
             sizeof( pTemplate->achName ) - 1 );
    
    dwError = BuildMemberList( pTemplate,
                               pTypeInterface,
                               RootTI,
                               FALSE );

Finished:

    if ( pTypeInterface != NULL )
    {
        TypesClose( pTypeInterface );
    }
    return dwError;
}

DWORD
FindMembersOfTypeSize(
    IN PDB *                pPDB,
    IN DWORD                cbSize,
    IN PFN_PRINTF           pfnPrintf
)
/*++

Routine Description:

    Find members of a certain size.  Output these types
    
Arguments:

    pPDB - PDB structure opened using MSDBI!PDBOpen
    cbSize - Size in question
    pfnPrintf - Output routine

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    STRUCTURE_TEMPLATE      Template;
    TPI *                   pTypeInterface = NULL;
    DWORD                   dwError = ERROR_SUCCESS;
    TI                      tiMin;
    TI                      tiMax;
    TI                      tiCursor;
    CHAR                    achLast[ MAX_TYPENAME_LENGTH ];
    CHAR                    achBuffer[ 256 ];

    if ( !pPDB || !pfnPrintf || !cbSize )
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Finished;
    }

    //
    // Get the type interface
    //
    
    if ( !PDBOpenTpi( pPDB,
                      pdbRead,
                      &pTypeInterface ) )
    {
        dwError = GetLastError();
        goto Finished;
    }

    //
    // Get min/max type indices
    //

    tiMin = TypesQueryTiMinEx( pTypeInterface );
    tiMax = TypesQueryTiMacEx( pTypeInterface );

    if ( tiMin == tiMax )
    {
        //
        // Probably no type info available in PDB
        //

        dwError = ERROR_NOT_SUPPORTED;
        goto Finished;
    }

    //
    // Cursor thru
    //

    achLast[ 0 ] = '\0';

    for ( tiCursor = tiMin;
          tiCursor < tiMax;
          tiCursor++ )
    {
        dwError = BuildMemberList( &Template,
                                   pTypeInterface,
                                   tiCursor,
                                   TRUE );
        if ( dwError != ERROR_SUCCESS )
        {
            if ( dwError == ERROR_NOT_SUPPORTED )
            {
                //
                // Not a struct/class. Ignore
                //

                dwError = ERROR_SUCCESS;
                continue;
            }
            else
            {
                break;
            }
        }

        if ( Template.cbTotalSize == cbSize &&
             strcmp( Template.achName, achLast ) )
        {
            pfnPrintf( Template.Type == LF_CLASS ? "class " : "struct ", -1 );
            pfnPrintf( Template.achName, -1 );
            pfnPrintf( "\n", -1 );

            strncpy( achLast,
                     Template.achName,
                     sizeof( achLast ) );
        }
        
    }
    
Finished:

    if ( pTypeInterface != NULL )
    {
        TypesClose( pTypeInterface );
    }
    return dwError;
}

DWORD
BuildMemberList(
    IN PSTRUCTURE_TEMPLATE  pTemplate,
    IN TPI *                pTypeInterface,
    IN TI                   tiType,
    IN BOOL                 fTypeSizeOnly
)
/*++

Routine Description:

    Build a template describing the given type.  This template contains
    an array of members representing the member of the type.
    
Arguments:

    pTemplate - Template to populate (must have been previously inited)
    pTypeInterface - Type interface
    tiType - Type ID to retrieve
    fStructSizeOnly - TRUE if we only need type size (and not the members)

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    TYPTYPE *               pType = NULL;
    lfStructure *           pStructure;
    lfFieldList *           pFieldList;
    PB                      pb;
    DWORD                   dwError = ERROR_SUCCESS;
    DWORD                   cbTotalSize = 0;
    DWORD                   cbStructSize = 0;
    DWORD                   cUseful;
    DWORD                   cbNameOffset;
    TI                      RootTI;

    if ( !pTypeInterface || !pTemplate )
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Finished;
    }

    RootTI = tiType;
    
    //
    // Parse root record of the type, verifying that it is of type 
    // STRUCTURE or CLASS
    //
    
    if ( !TypesQueryPbCVRecordForTiEx( pTypeInterface,
                                       RootTI,
                                       &pb ) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Finished;
    }
    
    pType = (TYPTYPE*) pb;

    if ( ( pType->leaf != LF_CLASS ) && 
         ( pType->leaf != LF_STRUCTURE ) )
    {
        dwError = ERROR_NOT_SUPPORTED;
        goto Finished;
    }
    pTemplate->Type = pType->leaf;
    
    pStructure = (lfStructure*) &(pType->leaf);

    cbNameOffset = GetOffset( pStructure->data, &cbStructSize );

    //
    // If we only need the overall structure size, then we can exit out now
    //

    if ( fTypeSizeOnly )
    {
        pTemplate->cbTotalSize = cbStructSize;

        memset( pTemplate->achName,
                0,
                sizeof( pTemplate->achName ) );

        strncpy( pTemplate->achName,
                 (LPSTR) pStructure->data + cbNameOffset + 1,
                 min( (DWORD) *(CHAR*)(pStructure->data + cbNameOffset),
                      sizeof( pTemplate->achName ) ) );

        goto Finished;
    }
    
    //
    // In allocating # of members for the structure, get upper bound by 
    // taking structure member count.
    //
    // OPTIMIZATION:  Dynamically grow the list to avoid gross overestimation.
    //
    
    if ( pTemplate->cMembers < pStructure->count )
    {
        pTemplate->pMembers = (PSTRUCTURE_MEMBER) LocalAlloc( LPTR,
                                          sizeof( STRUCTURE_MEMBER ) *
                                            pStructure->count );
        if ( pTemplate->pMembers == NULL )
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto Finished;
        }

        pTemplate->cMembers = pStructure->count;
    }
    
    if ( !TypesQueryPbCVRecordForTi( pTypeInterface,
                                     pStructure->field,
                                     &pb ) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Finished;
    }
    
    pType = (TYPTYPE*)pb;
    pFieldList = (lfFieldList*) &(pType->leaf);

    //
    // Read the list of the fields in the type
    //
    
    dwError = ReadFieldList( pTypeInterface,
                             pTemplate,
                             pFieldList,
                             pType->len,
                             0 );

    cUseful = pTemplate->cUseful;

    if ( cUseful && ( dwError == ERROR_SUCCESS ) )
    {
        pTemplate->pMembers[ cUseful - 1 ].cbMaxSize =
            cbStructSize - pTemplate->pMembers[ cUseful - 1 ].cbOffset;

        pTemplate->cbTotalSize = cbStructSize;
    }                                

Finished:

    return dwError;    
}

DWORD
ReadFieldList(
    IN TPI *                        pTypeInterface,
    IN STRUCTURE_TEMPLATE *         pTemplate,
    IN lfFieldList *                pFieldList,
    IN DWORD                        cbLen,
    IN DWORD                        dwFlags
)
/*++

Routine Description:

    Read the elements of the field list which represents the class/struct
    
Arguments:

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    DWORD               cbBytes = 0;
    PBYTE               pBuffer;
    DWORD               cbReturnSize = 0;
    BOOL                fExit = FALSE;
    CHAR                achMemberBuffer[ 256 ];
    DWORD               cbMemberBuffer;
    DWORD               dwError = ERROR_SUCCESS;
    DWORD               cFields = 0;
    DWORD               cbLastOffset = 0;

    while ( cbBytes < cbLen )
    {
        //
        // Account for padding the field list blob
        //
        
        for ( ; ; )
        {
            pBuffer = (PBYTE) pFieldList->data + cbBytes;
            if ( *(BYTE*)pBuffer < LF_PAD0 )
            {
                break;
            }
            cbBytes++;
        }
        
        //
        // After each padding block (if any), the first SHORT will contain
        // the field type of the next field in the struct/class.  Handle
        // each type accordingly.  If the handle function (Read*) returns 
        // a cbReturnSize of -1 then this type will not contribute to the
        // offsets in the struct/class.  For example, member functions.  
        //
        
        achMemberBuffer[ 0 ] = '\0';
        cbReturnSize = 0;
        cbMemberBuffer = sizeof( achMemberBuffer );
        
        switch ( *(USHORT*) pBuffer ) 
        {
        case LF_BCLASS:
            dwError = ReadBClass( pTypeInterface,
                                  (lfBClass*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
    
        case LF_MEMBER:
            dwError = ReadMember( (lfMember*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
            
        case LF_NESTTYPE:
            dwError = ReadNestType( (lfNestType*) pBuffer,
                                    &cbReturnSize,
                                    &cbBytes,
                                    achMemberBuffer,
                                    cbMemberBuffer );
            break;     
        
        case LF_ONEMETHOD:
            dwError = ReadOneMethod( (lfOneMethod*) pBuffer,
                                     &cbReturnSize,
                                     &cbBytes,
                                     achMemberBuffer,
                                     cbMemberBuffer );
            break;

        case LF_METHOD:
            dwError = ReadMethod( (lfMethod*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
       
        case LF_STMEMBER:
            dwError = ReadStaticMember( (lfSTMember*) pBuffer,
                                        &cbReturnSize,
                                        &cbBytes,
                                        achMemberBuffer,
                                        cbMemberBuffer );
            break;

        case LF_VFUNCTAB:
            dwError = ReadVTable( (lfVFuncTab*) pBuffer,
                                  &cbReturnSize,
                                  &cbBytes,
                                  achMemberBuffer,
                                  cbMemberBuffer );
            break;
            
        default:
            fExit = TRUE;
            break;
        }
        
        if ( fExit )
        {
            break;
        }
        
        if ( dwError != ERROR_SUCCESS ||
             cbReturnSize == INVALID_LENGTH )
        {
            continue;
        }
        
        //
        // We got a useful member of the struct/class.  Add it to the 
        // template.
        //
        
        pTemplate->cUseful++;

        strncpy( pTemplate->pMembers[ cFields ].achMemberName,
                 achMemberBuffer,
                 sizeof( pTemplate->pMembers[ cFields ].achMemberName ) - 1 );

        pTemplate->pMembers[ cFields ].cbOffset = cbReturnSize;
        
        //
        // Calculate the maximum size of the previous member by taking the 
        // difference between the start offset of the member and the start 
        // offset of the previous member.  Note that this is not necessarily
        // the exact size because of potential alignment padding.  It is only
        // an upper bound on the size of the previous member.
        //
        
        if ( cFields )
        {
            pTemplate->pMembers[ cFields - 1 ].cbMaxSize =
                                            cbReturnSize - cbLastOffset;
        }
        
        cbLastOffset = cbReturnSize;
        
        cFields++;
    }
    
    return dwError;
}

DWORD
ReadBClass(
    IN TPI *                    pTypeInterface,
    IN lfBClass*                pBClass,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    OUT CHAR *                  pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of base class field
    
Arguments:

    pTypeInterface - MSDBI type interface
    pBClass - Points to a base class descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    PB                      pb;
    DWORD                   Offset;
    TYPTYPE*                pType;
    lfStructure *           pStructure;
    DWORD                   cbUnused;
    
    Offset = GetOffset( pBClass->offset, pcbReturnSize );
    *pcbOffset += sizeof( lfBClass ) + Offset;
    
    //
    // We have to lookup the name of the base class explicitly by using the 
    // index type in the base class descriptor
    //

    if ( !TypesQueryPbCVRecordForTiEx( pTypeInterface,
                                       pBClass->index,
                                       &pb ) )
    {
        return ERROR_FILE_NOT_FOUND;
    }
    
    //
    // Process/munge/extract
    // 
    
    pType = (TYPTYPE*)pb;
    pStructure = (lfStructure*) &(pType->leaf );

    Offset = GetOffset( pStructure->data, &cbUnused );
    
    memset( pszBuffer, 0, cbBuffer );
    memcpy( pszBuffer,
            (CHAR*) pStructure->data + Offset + 1,
            min( (DWORD) *(CHAR*) ( pStructure->data + Offset ), cbBuffer ) );
            
    return ERROR_SUCCESS;
}

DWORD
ReadMember(
    IN lfMember *               pMember,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of a member
    
Arguments:

    pMember - Points to a member descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    DWORD Offset = GetOffset( pMember->offset, pcbReturnSize );

    memset( pszBuffer, 0, cbBuffer );
    memcpy( pszBuffer,
            (CHAR*) pMember->offset + Offset + 1,
            min( (DWORD) *(CHAR*) ( pMember->offset + Offset ), cbBuffer ) );
            
    *pcbOffset += sizeof( lfMember ) + Offset +  pMember->offset[Offset] + 1;

    return ERROR_SUCCESS;
}

DWORD
ReadOneMethod(
    IN lfOneMethod *            pOneMethod,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of a non-overloaded member function.  
    We process this only to up the offset within the field list for 
    traversal purposes.  Member methods themselves have no affect on 
    the offsets/size of the data structure 
    
Arguments:

    pOneMethod - Method type descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    CHAR *              pszSource = NULL;
    
    pszSource = (CHAR*) pOneMethod + sizeof( lfOneMethod );
    *pcbOffset += sizeof( lfOneMethod );
    if ( ( pOneMethod->attr.mprop == CV_MTintro ) ||
         ( pOneMethod->attr.mprop == CV_MTpureintro ) )
    {
        *pcbOffset += sizeof( LONG );
        pszSource += sizeof( LONG );
    }
    *pcbOffset += *(CHAR*)pszSource + 1;
    *pcbReturnSize = INVALID_LENGTH;

    return ERROR_SUCCESS;
}

DWORD
ReadMethod(
    IN lfMethod *               pMethod,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the type info of a member function.  We process this only to 
    up the offset within the field list for traversal purposes.  Member
    methods themselves have no affect on the offsets/size of the data 
    structure 
    
Arguments:

    pMethod - Method type descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    *pcbOffset += sizeof( lfMethod ) + pMethod->Name[ 0 ];
    *pcbReturnSize = INVALID_LENGTH;
    return ERROR_SUCCESS;
}

DWORD
ReadVTable(
    IN lfVFuncTab *             pVTable,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
/*++

Routine Description:

    Read the vtable of the structure.
    
Arguments:

    pVTable - Vtable type descriptor
    pcbReturnSize - Filled with offset from start of original type
    pcbOffset - Filled with new offset to result field traversal in 
                field list handler
    pszBuffer - Filled with name of base class
    cbBuffer - Size of pszBuffer

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    *pcbOffset += sizeof( lfVFuncTab );
    
    strncpy( pszBuffer,
             "'vftable'",
             cbBuffer - 1 );

    //
    // Assume at the beginning of the data structure.  
    // 

    *pcbReturnSize = 0;
    
    return ERROR_SUCCESS;
}


DWORD
ReadStaticMember(
    IN lfSTMember *             pStaticMember,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
{
    *pcbOffset += sizeof( lfSTMember ) + pStaticMember->Name[ 0 ];
    *pcbReturnSize = INVALID_LENGTH;
    return ERROR_SUCCESS;
}


DWORD
ReadNestType(
    IN lfNestType *             pNestType,
    OUT DWORD *                 pcbReturnSize,
    OUT DWORD *                 pcbOffset,
    IN CHAR *                   pszBuffer,
    IN DWORD                    cbBuffer
)
{
    *pcbOffset += sizeof( lfNestType ) + pNestType->Name[ 0 ];
    *pcbReturnSize = INVALID_LENGTH;
    return ERROR_SUCCESS;
}

DWORD
GetOffset(
    BYTE *              pBuffer,
    DWORD *             pcbOffset
)
/*++

Routine Description:

    Read the offset for the type record.  Then advance the cursor.
    
Arguments:

    pBuffer - Points to current position in field list buffer
    pcbOffset - Filled with offset of field member
    
Return Value:

    Amount to advance cursor to next field member

--*/
{
    USHORT leaf = *(USHORT*)pBuffer;
    
    if ( leaf < LF_NUMERIC )
    {
        *pcbOffset = leaf;
        return sizeof( leaf );
    }
    else
    {
        switch( leaf )
        {
        case LF_CHAR:
            *pcbOffset = *((char*)pBuffer);
            return sizeof(leaf) + sizeof(char);
        case LF_SHORT:
            *pcbOffset = *(short*)pBuffer;
            return sizeof(leaf) + sizeof(short);
        case LF_USHORT:
            *pcbOffset = *(USHORT*)pBuffer;
            return sizeof(leaf) + sizeof(USHORT);
        case LF_LONG:
            *pcbOffset = *(long*)pBuffer;
            return sizeof(leaf) + sizeof(long);
        case LF_ULONG:
            *pcbOffset = *(ULONG*)pBuffer;
            return sizeof(leaf) + sizeof(ULONG);
        }
    }
    return 0;
}

DWORD
InitializeStructureTemplate(
    IN PSTRUCTURE_TEMPLATE      pTemplate
)
/*++

Routine Description:

    Initialize structure template
    
Arguments:

    pTemplate - Template buffer to be initialized
    
Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    if ( pTemplate == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pTemplate->pMembers       = NULL;
    pTemplate->cMembers       = 0;
    pTemplate->achName[ 0 ]   = '\0';
    pTemplate->cUseful        = 0;
    pTemplate->cbTotalSize    = 0;
    pTemplate->Type           = 0xFFFFFFFF;

    return ERROR_SUCCESS;
}

DWORD
TerminateStructureTemplate(
    IN PSTRUCTURE_TEMPLATE      pTemplate
)
/*++

Routine Description:

    Terminate structure template
    
Arguments:

    pTemplate - Template buffer to be terminated
    
Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    if ( pTemplate == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( pTemplate->pMembers )
    {
        LocalFree( pTemplate->pMembers );
        pTemplate->pMembers = NULL;
        pTemplate->cMembers = 0;
    }

    return ERROR_SUCCESS;
}

DWORD
OutputStructure(
    IN PDB *                    pDebug,
    IN CHAR *                   pszStructureType,
    IN CHAR *                   pszMemberName,
    IN DWORD                    dwFlags,
    IN VOID *                   pvAddress,
    IN PFN_READ_MEMORY          pfnReadMemory,
    IN PFN_PRINTF               pfnPrintf
)
/*++

Routine Description:

    Top level call to output a structure
    
Arguments:

    pDebug - PDB handle
    pszStructureType - Name of structure/class to dump
    pszMemberName - (optional) Name of particular member of structure to dump
    dwFlags - (not supported) 
    pvAddress - (optional) Address of start of structure
    pfnReadMemory - (optional) Function to read memory.  Not needed if 
                    pvAddress==NULL
    pfnPrintf - Output function

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    STRUCTURE_TEMPLATE          Template;
    DWORD                       dwError;
    
    if ( !pDebug || 
         !pszStructureType || 
         !pfnReadMemory || 
         !pfnPrintf )
    {
        return ERROR_INVALID_PARAMETER;    
    }

    dwError = InitializeStructureTemplate( &Template );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = BuildMemberListForTypeName( &Template,
                                          pDebug,
                                          pszStructureType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = OutputTemplate( &Template,
                              pszMemberName,
                              dwFlags,
                              pvAddress,
                              pfnReadMemory,
                              pfnPrintf );

    //
    // CODEWORK:  Cache the templates
    //

    TerminateStructureTemplate( &Template );

    return dwError;
}

DWORD
DoPrintf(
   CHAR *                   pszBuffer,
   DWORD                    cbBytes
)
/*++

Routine Description:

    Print out buffer
    
Arguments:

    pszBuffer - buffer to print
    cbBytes - Bytes to print

Return Value:

    Number of bytes printed

--*/
{
    dprintf( "%s", pszBuffer );
    return strlen( pszBuffer );
} 

DWORD
DoReadMemory(
    VOID *                  pvAddress,
    DWORD                   cbBytes,
    VOID *                  pBuffer 
)
/*++

Routine Description:

    Read debuggee memory into buffer
    
Arguments:

    pvAddress - Address to read
    cbBytes - # of bytes to read
    pBuffer - Buffer to be filled

Return Value:

    If successful ERROR_SUCCESS, else Win32 Error Code

--*/
{
    if ( ReadMemory( pvAddress, pBuffer, cbBytes, NULL ) )
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return GetLastError();
    }
}

VOID
DumpoffUsage(
    VOID
)
/*++

Routine Description:

    !dumpoff usage message
    
Arguments:

    None

Return Value:

    None

--*/
{
    dprintf(
        "Usage:  !dumpoff <pdb_file>!<type_name>[.<member_name>] [expression]\n"
        "        !dumpoff -s [<pdb_search_path>]\n"
        "\n"
        "pdb_file          Un-qualified name of PDB file (eg. KERNEL32, NTDLL)\n"
        "type_name         Name of type (struct/class) to dump, OR \n"
        "                  ==<cbHexSize> to dump struct/classes of size cbHexSize\n"
        "member_name       (optional) Name of member in type_name to dump\n"
        "expression        (optional) Address of memory to dump as type_name\n"
        "                  if not present, offset(s) are dumped\n"
        "pdb_search_path   Set the search path for PDBs\n"
        "\n"
        "Examples:  !dumpoff ntdll!_RTL_CRITICAL_SECTION 14d4d0\n"
        "           !dumpoff w3svc!HTTP_REQUEST._dwSignature w3svc!g_GlobalObj\n"
        "           !dumpoff ntdll!_RTL_CRITICAL_SECTION\n"
        "           !dumpoff w3svc!==840\n"
        "           !dumpoff -s \\\\mydrive\\pdbs;c:\\local\\pdbs\n"
    );
}

#if defined( _X86_ )
CHAR g_achPDBSearchPath[ 1024 ] = "\\\\x86fre\\symbols.pri\\retail\\dll";
#else
CHAR g_achPDBSearchPath[ 1024 ] = "\\\\alphafre\\symbols.pri\\retail\\dll";
#endif

DECLARE_API( dumpoff )

/*++

Routine Description:

    This function is called as an NTSD extension to dump a structure
    based on debug info in PDB

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    CHAR *              pszPdb = NULL;
    CHAR *              pszType = NULL;
    CHAR *              pszAddress = NULL;
    CHAR *              pszMember = NULL;
    CHAR *              pszCursor = NULL;
    CHAR *              pszNext = NULL;
    CHAR                achArg1[ MAX_ARG_SIZE ];
    CHAR                achArg2[ MAX_ARG_SIZE ];
    CHAR                achBuffer[ MAX_ARG_SIZE ] = "";
    CHAR                achFileName[ MAX_PATH + 1 ];
    CHAR                achFullPath[ MAX_PATH + 1 ];
    CHAR                achSymPath[ MAX_PATH + 1 ];
    BOOL                fRet;
    EC                  ec;
    PDB *               pDebug = NULL;
    DWORD               dwError;
    CHAR *              pszError = NULL;
    DWORD               cArguments;
    DWORD               cbSize;
    BOOL                fRetry = TRUE;

    INIT_API();

    //
    // get the debugger symbol path
    //

    fRet = SymGetSearchPath( hCurrentProcess,
                             achSymPath,
                             sizeof( achSymPath ) );
    if (!fRet )
    {
        //
        // If we couldn't get the default sym path, just use the SYSTEMROOT
        //

        dwError = GetEnvironmentVariable( "SYSTEMROOT",
                                          achSymPath,
                                          sizeof( achSymPath ) );

        if ( dwError == 0 )
        {
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "Unable to determine symbol path.  Error = %d\n",
                       GetLastError() );
            goto Finished;
        }
    }

    //
    // parse out the argument style
    // <pdbfile>!<type>[.member] [address]
    //

    cArguments = sscanf( (CHAR*) lpArgumentString, 
                         "%256s%256s", 
                         achArg1, 
                         achArg2 );
    
    if ( cArguments == EOF || cArguments == 0 )
    {
        DumpoffUsage();
        goto Finished;
    }

    //
    // Handle the !dumpoff -s [sympath] case
    //

    if ( ( achArg1[ 0 ] == '-' || achArg1[ 0 ] == '/' ) &&
         ( achArg1[ 1 ] == 's' || achArg1[ 1 ] == 'S' ) )
    {
        if ( cArguments == 2 )
        {
            strncpy( g_achPDBSearchPath,
                     achArg2,
                     sizeof( g_achPDBSearchPath ) );
        }

        dprintf( "PDB search path set to\n%s%s%s\n",
                 g_achPDBSearchPath,
                 *g_achPDBSearchPath ? "\n" : "",
                 achSymPath );
                 
        goto Finished;
    }

    //
    // Parse the regular !dumpoff command
    //
    
    pszPdb = achArg1;

    pszCursor = strchr( achArg1, '!' );
    if ( pszCursor == NULL )
    {
        DumpoffUsage();
        goto Finished;
    }
    *pszCursor = '\0';

    pszType = pszCursor + 1;
    
    pszCursor = strchr( pszType, '.' );
    if ( pszCursor != NULL )
    {
        *pszCursor = '\0';
        pszMember = pszCursor + 1;
    } 
    
    if ( cArguments > 1 )
    {
        pszAddress = achArg2;
    }

    //
    // done parsing, now get the PDB 
    //
    
    strncpy( achFileName,
             pszPdb,
             MAX_ARG_SIZE );
    strcat( achFileName,
            ".pdb");

    //
    // Look for the PDB file.  First in the PDB search path, then sympath
    //

    pszCursor = g_achPDBSearchPath;

Retry:
    while ( pszCursor )
    {
        pszNext = strchr( pszCursor, ';' );
        if ( pszNext != NULL )
        {
            *pszNext = '\0';
        }
        
        fRet = SearchTreeForFile( pszCursor,
                                  achFileName,
                                  achFullPath );
        if ( fRet )
        {
            break;
        }
        
        if ( pszNext )
        {
            pszCursor = pszNext + 1;
        }
        else
        {
            pszCursor = NULL;
        }
    }

    if ( !pszCursor && fRetry )
    {
        fRetry = FALSE;
        
        // now try the debugger sympath

        pszCursor = achSymPath;
        goto Retry;
    }
    
    if ( !pszCursor )
    {
        _snprintf( achBuffer,
                   sizeof( achBuffer ),
                   "Couldn't find PDB file %s\n",
                   achFileName );
        goto Finished;
    }
    
    //
    // Open the PDB file
    //
    
    if ( !PDBOpen( achFullPath,
                   pdbRead,
                   0,
                   &ec,
                   achBuffer,
                   &pDebug ) )
    {
        _snprintf( achBuffer,
                   sizeof( achBuffer ),
                   "Error opening PDB file.  Error = %d\n",
                   ec );
        goto Finished;
    }

    if ( pszType[ 0 ] == '=' && pszType[ 1 ] == '=' )
    {
        //
        // Find all types of size after ==
        //

        cbSize = strtoul( pszType + 2,
                          NULL,
                          16 );

        dwError = FindMembersOfTypeSize( pDebug,
                                         cbSize,
                                         DoPrintf );
    }
    else
    {
        dwError = OutputStructure( pDebug,
                                   pszType,
                                   pszMember,
                                   0,
                                   pszAddress ? (VOID*) GetExpression( pszAddress ) : NULL, 
                                   DoReadMemory,
                                   DoPrintf );
    }

    if ( dwError != ERROR_SUCCESS )
    {
        switch ( dwError )
        {
        case ERROR_FILE_NOT_FOUND:
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "Could not find type '%s' in PDB file '%s'\n",
                       pszType,
                       achFullPath );
            break;
        case ERROR_NOT_SUPPORTED:
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "PDB file '%s' does not contain necessary type info\n",
                       achFullPath );
            break;
        default:
            _snprintf( achBuffer,
                       sizeof( achBuffer ),
                       "Error dumping structure.  Error = %d\n", 
                       dwError );
        }

        goto Finished;
    }

Finished:

    if ( achBuffer[ 0 ] )
    {
        dprintf( "%s", achBuffer );
    }

    if ( pDebug )
    {
        PDBClose( pDebug );
    }
  
} // DECLARE_API( dumpoff )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\dbgwreq.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    dbgwreq.cxx

Abstract:

    This module contains the default ntsd debugger extensions for
    IIS - W3SVC WAM_REQUEST

Author:

    David Kaplan (DaveK)  6-Oct-1997

Revision History:

--*/

#include "inetdbgp.h"

# undef DBG_ASSERT



/***********************************************************************
 *   WAM_REQUEST functions
 **********************************************************************/

VOID
PrintWamRequestThunk( PVOID pccDebuggee,
                      PVOID pccDebugger,
                      CHAR  verbosity,
                      DWORD iCount);

VOID
PrintWamRequest( WAM_REQUEST * pwreqOriginal,
                  WAM_REQUEST * pwreq,
                  CHAR Verbosity );



VOID
PrintWamRequestThunk( PVOID pccDebuggee,
                      PVOID pccDebugger,
                      CHAR  verbosity,
                      DWORD iCount)
{

    //
    //  'local'  ==> inetdbg process
    //  'remote' ==> inetinfo process
    //

    DEFINE_CPP_VAR( HTTP_REQUEST, hreq );   // local HTTP_REQUEST
    DEFINE_CPP_VAR( WAM_REQUEST, wreq );    // local WAM_REQUEST

    HTTP_REQUEST * phreq;                   // remote HTTP_REQUEST ptr
    WAM_REQUEST * pwreq;                    // remote WAM_REQUEST ptr

    //
    //  get local CLIENT_CONN ptr from caller
    //
    //

    CLIENT_CONN * pcc = (CLIENT_CONN *) pccDebugger;

    //
    //  get remote HTTP_REQUEST ptr from CLIENT_CONN
    //  and copy its contents into local HTTP_REQUEST
    //

    phreq = (HTTP_REQUEST *) pcc->_phttpReq;
    move( hreq, phreq);

    //
    //  get remote WAM_REQUEST ptr from local HTTP_REQUEST
    //
    //  if non-null, copy its contents into local WAM_REQUEST
    //  and print it
    //

    pwreq = (WAM_REQUEST *) ( ((HTTP_REQUEST *) &hreq)->_pWamRequest );

    if ( pwreq != NULL) {

        move( wreq, pwreq);

        PrintWamRequest(
            pwreq
            , GET_CPP_VAR_PTR( WAM_REQUEST, wreq)
            , verbosity
        );

    }

} // PrintWamRequestThunk()




DECLARE_API( wreq )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    an object attributes structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/
{
    DEFINE_CPP_VAR( WAM_REQUEST, wreq );
    WAM_REQUEST * pwreq;

    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if ( !*lpArgumentString )
    {
        PrintUsage( "wreq" );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( "wreq" );
            return;
        }


        if ( *lpArgumentString == 'l' ) {

            DumpClientConnList( lpArgumentString[1],
                                PrintWamRequestThunk);
            return;
        }

    } // if

    //
    //  Treat the argument as the address of an AtqContext
    //

    pwreq = (WAM_REQUEST * ) GetExpression( lpArgumentString );

    if ( !pwreq )
    {
        dprintf( "inetdbg.wreq: Unable to evaluate \"%s\"\n",
                 lpArgumentString );

        return;
    }

    move( wreq, pwreq );
    PrintWamRequest( pwreq, GET_CPP_VAR_PTR( WAM_REQUEST, wreq), '2');

    return;
} // DECLARE_API( hreq )



VOID
PrintWamRequest( WAM_REQUEST * pwreqOriginal,
                  WAM_REQUEST * pwreq,
                  CHAR Verbosity )
/*++
  Description:
    This function takes the WAM_REQUEST object and prints out
    the details for the same in the debugger. The granularity of the
    deatils are controlled by the verbosity flag

  Arguments:
    pwreqOriginal - pointer to the location where the original WAM_REQUEST
                  object is located.
                  Note: pwreqOriginal points to object inside debuggee process
    pwreq         - pointer to the WAM_REQUEST object that is a copy
                  of the contents located at [pwreqOriginal]
                  Note: pwreq points to object inside the debugger process
    Verbostiy   - level of details requested.

  Returns:
    None
--*/
{

    if ( Verbosity >= '0') {

        //
        // print Brief information about the WAM_REQUEST
        //

        dprintf(
            "WAM_REQUEST: %p   m_pHttpRequest = %p   m_pExec = %p\n"
            "Ref count = %d  m_dwRequestID = %d\n"
            , pwreqOriginal
            , pwreq->m_pHttpRequest
            , pwreq->m_pExec
            , pwreq->m_cRefs
            , pwreq->m_dwRequestID
        );

    }

    if ( Verbosity >= '1' ) {

        //
        //  Print all details for the WAM_REQUEST object
        //
        //  UNDONE add support for strings
        //

        dprintf(
//          "\t Path-translated = %s \n"
//          "\t    ISA DLL path = %s \n"
            "\t m_pWamInfo          = %p   m_dwWamVersion  = %08x\n"
            "\t m_pWamExecInfo      = %p   m_hFileTfi      = %p\n"
            "\t m_fFinishWamRequest = %08x   m_fWriteHeaders = %08x\n"
            "\t m_leOOP.Flink       = %p   m_leOOP.Blink   = %p \n"
//          , pwreq->m_strPathTrans
//          , pwreq->m_strISADllPath
            , pwreq->m_pWamInfo
            , pwreq->m_dwWamVersion
            , pwreq->m_pWamExecInfo
            , pwreq->m_hFileTfi
            , pwreq->m_fFinishWamRequest
            , pwreq->m_fWriteHeaders
            , pwreq->m_leOOP.Flink
            , pwreq->m_leOOP.Blink
        );

    }


    if ( Verbosity >= '2' ) {

        //
        //  UNDONE
        //
    }

    return;
} // PrintWamRequest()



/************* end of file ********************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\exec.cxx ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    exec.cxx

Abstract:

    This module contains an NTSD debugger extension for executing
    external commands.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "inetdbgp.h"


/************************************************************
 * Execute
 ************************************************************/


DECLARE_API( exec )

/*++

Routine Description:

    This function is called as an NTSD extension to ...

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    BOOL result;
    STARTUPINFO startInfo;
    PROCESS_INFORMATION processInfo;

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    //
    // Use "cmd.exe" by default.
    //

    if( *lpArgumentString == '\0' ) {
        lpArgumentString = "cmd";
    }

    //
    // Set the prompt environment variable so the user will have clue.
    //

    SetEnvironmentVariable(
        "PROMPT",
        "!inetdbg.exec - $p$g"
        );

    //
    // Launch it.
    //

    ZeroMemory(
        &startInfo,
        sizeof(startInfo)
        );

    ZeroMemory(
        &processInfo,
        sizeof(processInfo)
        );

    startInfo.cb = sizeof(startInfo);

    result = CreateProcess(
                 NULL,                          // lpszImageName
                 lpArgumentString,              // lpszCommandLine
                 NULL,                          // lpsaProcess
                 NULL,                          // lpsaThread
                 TRUE,                          // fInheritHandles
                 0,                             // fdwCreate
                 NULL,                          // lpvEnvironment
                 NULL,                          // lpszCurDir
                 &startInfo,                    // lpsiStartInfo
                 &processInfo                   // lppiProcessInfo
                 );

    if( result ) {

        //
        // Wait for the child process to terminate, then cleanup.
        //

        WaitForSingleObject( processInfo.hProcess, INFINITE );
        CloseHandle( processInfo.hProcess );
        CloseHandle( processInfo.hThread );

    } else {

        //
        // Could not launch the process.
        //

        dprintf(
            "cannot launch \"%s\", error %lu\n",
            lpArgumentString,
            GetLastError()
            );

    }

}   // DECLARE_API( exec )



/*
  CallExtension allows one extension to call another extension in a
  different DLL. From TomCan.

  DECLARE_API(test)
  {
      NTSTATUS status = ERROR_SUCCESS; 
      status = DO_EXTENSION("kdextx86.dll", "pool", args);
      dprintf("\n\nStatus: %08X\n", status);
  } 
*/

NTSTATUS
CallExtension(
    PCSTR szModuleName,
    PCSTR szFunction,
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    ULONG dwCurrentPc,
    ULONG dwProcessor,
    PCSTR args)
{
    PWINDBG_EXTENSION_FUNCTION pFn = NULL;
    HINSTANCE hlib = NULL;
    NTSTATUS status = ERROR_SUCCESS; 
    hlib = LoadLibrary(szModuleName);
    if (hlib != NULL)
    {
        pFn = (PWINDBG_EXTENSION_FUNCTION)GetProcAddress(hlib, szFunction);
        if (pFn != NULL)
        {
            (pFn)(hCurrentProcess, hCurrentThread, dwCurrentPc,
                  dwProcessor, args);
        } 
        FreeLibrary(hlib);
    } 
    status = GetLastError();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\heapfind.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    heapfind.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    bits of heap information.

Author:

    Keith Moore (keithmo) 01-Nov-1997

Revision History:

--*/

#include "inetdbgp.h"

typedef struct _ENUM_CONTEXT {

    ULONG SizeToDump;
    ULONG DumpCount;
    PUCHAR BlockToSearchFor;
    BOOLEAN ContinueEnum;

} ENUM_CONTEXT, *PENUM_CONTEXT;


/************************************************************
 * Dump Heap Info
 ************************************************************/


BOOLEAN
CALLBACK
HfpEnumHeapSegmentEntriesProc(
    IN PVOID Param,
    IN PHEAP_ENTRY LocalHeapEntry,
    IN PHEAP_ENTRY RemoteHeapEntry
    )

/*++

Routine Description:

    Callback invoked for each heap entry within a heap segment.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapEntry - Pointer to a local copy of the HEAP_ENTRY structure.

    RemoteHeapEntry - The remote address of the HEAP_ENTRY structure
        in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;
    PUCHAR entryStart;
    ULONG entryLength;
    BOOLEAN dumpBlock = FALSE;

    //
    // allow user to break out of lengthy enumeration
    //
    
    if( CheckControlC() ) {
        context->ContinueEnum = FALSE;
        return TRUE;
    }

    //
    // Ignore free blocks.
    //

    if( !( LocalHeapEntry->Flags & HEAP_ENTRY_BUSY ) ) {
        return TRUE;
    }

    //
    // Calculate the start & length of the heap block.
    //

    entryStart = (PUCHAR)RemoteHeapEntry + sizeof(HEAP_ENTRY);

    entryLength = ( (ULONG)LocalHeapEntry->Size << HEAP_GRANULARITY_SHIFT ) -
        (ULONG)LocalHeapEntry->UnusedBytes;

    //
    // Decide how to handle this request.
    //

    if( context->BlockToSearchFor != NULL ) {

        //
        // The user is looking for the heap block that contains a
        // specific address. If the current block is a match, then
        // dump it and terminate the enumeration.
        //

        if( context->BlockToSearchFor >= entryStart &&
            context->BlockToSearchFor < ( entryStart + entryLength ) ) {

            dumpBlock = TRUE;
            context->ContinueEnum = FALSE;

        }

    } else {

        //
        // The user is looking for blocks of a specific size. If the
        // size matches, or the user is looking for "big" blocks and
        // the current block is >= 64K, then dump it.
        //

        if( context->SizeToDump == entryLength ||
            ( context->SizeToDump == 0xFFFFFFFF && entryLength >= 65536 ) ) {

            dumpBlock = TRUE;

        }

    }

    if( dumpBlock ) {
        context->DumpCount++;
        dprintf(
            "HeapEntry @ %08lp [%08lp], flags = %02x, length = %lx\n",
            RemoteHeapEntry,
            entryStart,
            (ULONG)LocalHeapEntry->Flags,
            entryLength
            );
    }

    return context->ContinueEnum;

}   // HfpEnumHeapSegmentEntriesProc


BOOLEAN
CALLBACK
HfpEnumHeapSegmentsProc(
    IN PVOID Param,
    IN PHEAP_SEGMENT LocalHeapSegment,
    IN PHEAP_SEGMENT RemoteHeapSegment,
    IN ULONG HeapSegmentIndex
    )

/*++

Routine Description:

    Callback invoked for each heap segment within a heap.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapSegment - Pointer to a local copy of the HEAP_SEGMENT
        structure.

    RemoteHeapSegment - The remote address of the HEAP_SEGMENT
        structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;

    //
    // Enumerate the entries for the specified segment.
    //

    if( !EnumHeapSegmentEntries(
            LocalHeapSegment,
            RemoteHeapSegment,
            HfpEnumHeapSegmentEntriesProc,
            (PVOID)context
            ) ) {
        dprintf( "error retrieving heap segment entries\n" );
        return FALSE;
    }

    return context->ContinueEnum;

}   // HfpEnumHeapSegmentsProc


BOOLEAN
CALLBACK
HfpEnumHeapsProc(
    IN PVOID Param,
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN ULONG HeapIndex
    )

/*++

Routine Description:

    Callback invoked for each heap within a process.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeap - Pointer to a local copy of the HEAP structure.

    RemoteHeap - The remote address of the HEAP structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;

    //
    // Enumerate the segments for the specified heap.
    //

    if( !EnumHeapSegments(
            LocalHeap,
            RemoteHeap,
            HfpEnumHeapSegmentsProc,
            (PVOID)context
            ) ) {
        dprintf( "error retrieving heap segments\n" );
        return FALSE;
    }

    return context->ContinueEnum;

}   // HfpEnumHeapsProc


DECLARE_API( heapfind )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    heap information.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ENUM_CONTEXT context;

    INIT_API();

    //
    // Setup.
    //

    RtlZeroMemory(
        &context,
        sizeof(context)
        );

    context.ContinueEnum = TRUE;

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' || *lpArgumentString != '-' ) {
        PrintUsage( "heapfind" );
        return;
    }

    lpArgumentString++;

    //
    // Interpret the command-line switch.
    //

    switch( *lpArgumentString ) {
    case 'a' :
    case 'A' :
        lpArgumentString++;
        context.BlockToSearchFor = (PUCHAR)strtoul( lpArgumentString, NULL, 16 );
        break;

    case 's' :
    case 'S' :
        lpArgumentString++;
        context.SizeToDump = (ULONG)strtoul( lpArgumentString, NULL, 16 );
        break;

    default :
        PrintUsage( "heapfind" );
        return;
    }

    //
    // Enumerate the heaps, which will enumerate the segments, which
    // will enumerate the entries, which will search for the specified
    // address or specified size.
    //

    if( !EnumProcessHeaps(
            HfpEnumHeapsProc,
            (PVOID)&context
            ) ) {
        dprintf( "error retrieving process heaps\n" );
    } else {
        if (context.DumpCount > 0) {
            dprintf( "Total count: %08lx\n", context.DumpCount);
        }
    }

}   // DECLARE_API( heapfind )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\findmod.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    findmod.cxx

Abstract:

    Locates module in the debugee containing a specific address.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "inetdbgp.h"

typedef struct _ENUM_CONTEXT {
    ULONG_PTR ModuleAddress;
    PMODULE_INFO ModuleInfo;
    BOOLEAN Successful;
} ENUM_CONTEXT, *PENUM_CONTEXT;


BOOLEAN
CALLBACK
FmpEnumProc(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    )
{

    PENUM_CONTEXT context;

    context = (PENUM_CONTEXT)Param;

    if( context->ModuleAddress >= ModuleInfo->DllBase &&
        context->ModuleAddress < ( ModuleInfo->DllBase + ModuleInfo->SizeOfImage ) ) {

        CopyMemory(
            context->ModuleInfo,
            ModuleInfo,
            sizeof(*ModuleInfo)
            );

        context->Successful = TRUE;

    }

    return !context->Successful;

}   // FmpEnumProc


BOOLEAN
FindModuleByAddress(
    IN ULONG_PTR ModuleAddress,
    OUT PMODULE_INFO ModuleInfo
    )

/*++

Routine Description:

    Finds a module in the debugee that contains the specified address.

Arguments:

    ModuleAddress - The module address to search for.

    ModuleInfo - If successful, receives information describing the
        module found.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    BOOLEAN result;
    ENUM_CONTEXT context;

    context.ModuleAddress = ModuleAddress;
    context.ModuleInfo = ModuleInfo;
    context.Successful = FALSE;

    result = EnumModules(
                 FmpEnumProc,
                 (PVOID)&context
                 );

    if( result )  {
        result = context.Successful;
    }

    return result;

}   // FindModuleByAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\heapstat.cxx ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    heapstat.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    heap statistics.

Author:

    Keith Moore (keithmo) 01-Nov-1997

Revision History:

--*/

#include "inetdbgp.h"


#define MAX_SIZE    65536

// Large busy block (size exceeds MAX_SIZE)
#define MAX_LBBSIZE 1024


typedef struct _ENUM_CONTEXT {

    BOOLEAN ContinueEnum;
    ULONG FreeJumbo;
    ULONG BusyJumbo;
    ULONG FreeJumboBytes;
    ULONG BusyJumboBytes;
    ULONG BusyOverhead;
    ULONG FreeOverhead;
    ULONG FreeCounters[MAX_SIZE];
    ULONG BusyCounters[MAX_SIZE];
    ULONG LargeBusyBlock[MAX_LBBSIZE];

} ENUM_CONTEXT, *PENUM_CONTEXT;

#define BYTES_TO_K(cb) ( ( (cb) + 512 ) / 1024 )


/************************************************************
 * Dump Heap Info
 ************************************************************/


BOOLEAN
CALLBACK
HspEnumHeapSegmentEntriesProc(
    IN PVOID Param,
    IN PHEAP_ENTRY LocalHeapEntry,
    IN PHEAP_ENTRY RemoteHeapEntry
    )

/*++

Routine Description:

    Callback invoked for each heap entry within a heap segment.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapEntry - Pointer to a local copy of the HEAP_ENTRY structure.

    RemoteHeapEntry - The remote address of the HEAP_ENTRY structure
        in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    PENUM_CONTEXT context = (PENUM_CONTEXT)Param;
    ULONG entryLength;
    ULONG allocLength;

    //
    // Calculate the total length of this entry, including the heap
    // header and any "slop" at the end of the block.
    //

    entryLength = (ULONG)LocalHeapEntry->Size << HEAP_GRANULARITY_SHIFT;

    //
    // From that, compute the number of bytes in use. This is the size
    // of the allocation request as received from the application.
    //

    allocLength = entryLength - (ULONG)LocalHeapEntry->UnusedBytes;

    //
    // Adjust the appropriate accumulators.
    //

    if( LocalHeapEntry->Flags & HEAP_ENTRY_BUSY ) {

        context->BusyOverhead += entryLength;

        if( allocLength < MAX_SIZE ) {
            context->BusyCounters[allocLength] += 1;
        } else {
            context->BusyJumbo += 1;
            context->BusyJumboBytes += allocLength;

            if (context->LargeBusyBlock[MAX_LBBSIZE-1] == 0) {
                BOOL fFound = FALSE;
                UINT  i = 0;
                for (; context->LargeBusyBlock[i] != 0 && i < MAX_LBBSIZE; i++) {
                    if( CheckControlC() ) {
                        context->ContinueEnum = FALSE;
                        return FALSE;
                    }

                    if (allocLength == context->LargeBusyBlock[i]) {
                        fFound = TRUE;  
                        break;
                    }
                }
                if (!fFound && i < MAX_LBBSIZE-1) {
                   context->LargeBusyBlock[i] = allocLength; 
                }
            }
        }

    } else {

        context->FreeOverhead += entryLength;

        if( allocLength < MAX_SIZE ) {
            context->FreeCounters[allocLength] += 1;
        } else {
            context->FreeJumbo += 1;
            context->FreeJumboBytes += allocLength;
        }

    }

    return TRUE;

}   // HspEnumHeapSegmentEntriesProc


BOOLEAN
CALLBACK
HspEnumHeapSegmentsProc(
    IN PVOID Param,
    IN PHEAP_SEGMENT LocalHeapSegment,
    IN PHEAP_SEGMENT RemoteHeapSegment,
    IN ULONG HeapSegmentIndex
    )

/*++

Routine Description:

    Callback invoked for each heap segment within a heap.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeapSegment - Pointer to a local copy of the HEAP_SEGMENT
        structure.

    RemoteHeapSegment - The remote address of the HEAP_SEGMENT
        structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    //
    // Enumerate the entries for the specified segment.
    //

    if( !EnumHeapSegmentEntries(
            LocalHeapSegment,
            RemoteHeapSegment,
            HspEnumHeapSegmentEntriesProc,
            Param
            ) ) {
        dprintf( "error retrieving heap segment entries\n" );
        return FALSE;
    }

    return TRUE;

}   // HspEnumHeapSegmentsProc


BOOLEAN
CALLBACK
HspEnumHeapsProc(
    IN PVOID Param,
    IN PHEAP LocalHeap,
    IN PHEAP RemoteHeap,
    IN ULONG HeapIndex
    )

/*++

Routine Description:

    Callback invoked for each heap within a process.

Arguments:

    Param - An uninterpreted parameter passed to the enumerator.

    LocalHeap - Pointer to a local copy of the HEAP structure.

    RemoteHeap - The remote address of the HEAP structure in the debugee.

Return Value:

    BOOLEAN - TRUE if the enumeration should continue, FALSE if it
        should be terminated.

--*/

{

    //
    // Enumerate the segments for the specified heap.
    //

    if( !EnumHeapSegments(
            LocalHeap,
            RemoteHeap,
            HspEnumHeapSegmentsProc,
            Param
            ) ) {
        dprintf( "error retrieving heap segments\n" );
        return FALSE;
    }

    return TRUE;

}   // HspEnumHeapsProc


DECLARE_API( heapstat )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    heap statistics.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    PENUM_CONTEXT context;
    ULONG i;
    ULONG busyBytes;
    ULONG totalBusy;
    ULONG totalFree;
    ULONG totalBusyBytes;
    ULONG lowerNoiseBound;

    INIT_API();

    //
    // Setup.
    //

    context = (PENUM_CONTEXT)malloc( sizeof(*context) );

    if( context == NULL ) {
        dprintf( "out of memory\n" );
        return;
    }

    RtlZeroMemory(
        context,
        sizeof(*context)
        );

    context->ContinueEnum = TRUE;

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        lowerNoiseBound = 1;
    } else {
        lowerNoiseBound = strtoul( lpArgumentString, NULL, 16 );
    }

    //
    // Enumerate the heaps, which will enumerate the segments, which
    // will enumerate the entries, which will accumulate the statistics.
    //

    if( !EnumProcessHeaps(
            HspEnumHeapsProc,
            (PVOID)context
            ) ) {
        dprintf( "error retrieving process heaps\n" );
        free( context );
        return;
    }

    //
    // Dump 'em.
    //

    dprintf(
        "  Size :  NumBusy :  NumFree : BusyBytes\n"
        );

    totalBusy = 0;
    totalFree = 0;
    totalBusyBytes = 0;

    for( i = 0 ; i < MAX_SIZE ; i++ ) {

        if (CheckControlC())
            goto cleanup;

        busyBytes = i * context->BusyCounters[i];

        if( context->BusyCounters[i] >= lowerNoiseBound ||
            context->FreeCounters[i] >= lowerNoiseBound ) {

            dprintf(
                " %5lx : %8lx : %8lx :  %8lx (%10ldK)\n",
                i,
                context->BusyCounters[i],
                context->FreeCounters[i],
                busyBytes,
                BYTES_TO_K( busyBytes )
                );

        }

        totalBusy += context->BusyCounters[i];
        totalBusyBytes += busyBytes;
        totalFree += context->FreeCounters[i];

    }

    if( context->BusyJumbo >= lowerNoiseBound ||
        context->FreeJumbo >= lowerNoiseBound ) {

        dprintf(
            ">%5lx : %8lx : %8lx :  %8lx (%10ldK)\n",
            MAX_SIZE,
            context->BusyJumbo,
            context->FreeJumbo,
            context->BusyJumboBytes,
            BYTES_TO_K( context->BusyJumboBytes )
            );

        totalBusy += context->BusyJumbo;
        totalFree += context->FreeJumbo;
        totalBusyBytes += context->BusyJumboBytes;

    }

    if (context->LargeBusyBlock[0] != 0) {
        for (i = 0; i < MAX_LBBSIZE && context->LargeBusyBlock[i] != 0; i++) {
            dprintf("%8lx : \n", context->LargeBusyBlock[i]);
        }
    }

    dprintf(
        " Total : %8lx : %8lx :  %8lx (%10ldK)\n"
        "\n"
        " Total Heap Impact from Busy Blocks = %8lx (%10ldK)\n"
        " Total Heap Impact from Free Blocks = %8lx (%10ldK)\n",
        totalBusy,
        totalFree,
        totalBusyBytes,
        BYTES_TO_K( totalBusyBytes ),
        context->BusyOverhead,
        BYTES_TO_K( context->BusyOverhead ),
        context->FreeOverhead,
        BYTES_TO_K( context->FreeOverhead )
        );

  cleanup:
    free( context );

}   // DECLARE_API( heapstat )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\fcache.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    fcache.cxx

Abstract:

    This module contains the cache-related ntsd debugger extensions for
    Internet Information Server

Author:

    Keith Moore (keithmo)         12-Aug-1997

Revision History:

    Michael Courage (mcourage)    06-Feb-1998 Updated for rewritten cache
--*/


#include "inetdbgp.h"


//
// Worker routines.
//


PSTR
DemuxToString(
    IN ULONG Demux
    )

/*++

Routine Description:

    Converts the specified demux value to a printable string.

Arguments:

    Demux - The demux value to map.

Return Value:

    PSTR - The printable string.

--*/

{

    switch( Demux ) {
    case RESERVED_DEMUX_START :
        return "RESERVED_DEMUX_START";

    case RESERVED_DEMUX_DIRECTORY_LISTING :
        return "RESERVED_DEMUX_DIRECTORY_LISTING";

    case RESERVED_DEMUX_ATOMIC_DIRECTORY_GUARD :
        return "RESERVED_DEMUX_ATOMIC_DIRECTORY_GUARD";

    case RESERVED_DEMUX_OPEN_FILE :
        return "RESERVED_DEMUX_OPEN_FILE";

    case RESERVED_DEMUX_URI_INFO :
        return "RESERVED_DEMUX_URI_INFO";

    case RESERVED_DEMUX_PHYSICAL_OPEN_FILE :
        return "RESERVED_DEMUX_PHYSICAL_OPEN_FILE";

    default :
        return "Unknown";
    }

}   // DemuxToString


PSTR
SignatureToString(
    IN DWORD CurrentSignature,
    IN DWORD ValidSignature,
    IN DWORD FreedSignature
    )

/*++

Routine Description:

    Determines an appropriate display string for the given signature.
    If the current signature matches the expected valid signature,
    then the string "OK" is returned. If the current signature matches
    the freed signature, then "FREED" is returned. Otherwise, "INVALID"
    is returned.

Arguments:

    CurrentSignature - The current signature as retrieved from the
        object/structure.

    ValidSignature - The expected signature for a valid, in-use
        object/structure.

    FreedSignature - The signature assigned to the object/structure
        just before it is freed.

Return Value:

    PSTR - "OK", "FREED", or "INVALID" as appropriate.

--*/

{

    if( CurrentSignature == ValidSignature ) {
        return "OK";
    }

    if( CurrentSignature == FreedSignature ) {
        return "FREED";
    }

    return "INVALID";

}   // SignatureToString


PSTR
BoolToString(
    IN BOOL Flag
    )

/*++

Routine Description:

    Maps the given BOOL to a displayable string.

Arguments:

    Flag - The BOOL flag to map.

Return Value:

    PSTR - "TRUE", "FALSE", or "INVALID" as appropriate.

--*/

{

    //
    // In general, explicit testing for TRUE is a Bad Thing, but in
    // this case, it's useful for catching invalid data.
    //

    if( Flag == TRUE ) {
        return "TRUE";
    }

    if( Flag == FALSE ) {
        return "FALSE";
    }

    return "INVALID";

}   // BoolToString


PSTR
FIStateToString(
    FI_STATE state
    )

/*++

Routine Description:

    Maps the given BOOL to a displayable string.

Arguments:

    Flag - The BOOL flag to map.

Return Value:

    PSTR - "TRUE", "FALSE", or "INVALID" as appropriate.

--*/

{
    switch (state) {
    case FI_UNINITIALIZED:
        return "FI_UNINITIALIZED";
        break;
    case FI_OPEN:
        return "FI_OPEN";
        break;
    case FI_FLUSHED:
        return "FI_FLUSHED";
        break;
    case FI_FLUSHED_UNINIT:
        return "FI_FLUSHED_UNINIT";
        break;
    case FI_CLOSED:
        return "FI_CLOSED";
        break;
    default:
        return "INVALID";
    }
}   // FIStateToString


VOID
DumpBlobHeader(
    IN PSTR Prefix,
    IN PBLOB_HEADER BlobHeader,
    IN ULONG_PTR ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a specific BLOB_HEADER structure.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    BlobHeader - Points to a local copy of the structure.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    ULONG_PTR offset;
    UCHAR symbol[MAX_SYMBOL_LEN];
    CHAR renderedSymbol[MAX_SYMBOL_LEN+30];

    GetSymbol(
        (ULONG_PTR) BlobHeader->pfnFreeRoutine,
        symbol,
        &offset
        );

    if( symbol[0] == '\0' ) {
        renderedSymbol[0] = '\0';
    } else if( offset == 0 ) {
        sprintf(
            renderedSymbol,
            " (%s)",
            symbol
            );
    } else {
        sprintf(
            renderedSymbol,
            " (%s+0x%lx)",
            symbol,
            offset
            );
    }

    dprintf(
        "%sBLOB_HEADER @ %p\n"
        "%s    IsCached       = %s\n"
        "%s    pfnFreeRoutine = %08lp\n"
        "%s    blobKey        @ %08lp\n"
        "%s    dwRefCount     = %08lx\n"
        "%s    TTL            = %08lx\n"
        "%s    pSecDesc       = %08lp\n"
        "%s    hLastSuccessAccessToken = %08lp%s\n"
        "\n",
        Prefix,
        ActualAddress,
        Prefix,
        BoolToString( BlobHeader->IsCached ),
        Prefix,
        BlobHeader->pfnFreeRoutine,
        Prefix,
        BlobHeader->pBlobKey,
        Prefix,
        BlobHeader->lRefCount,
        Prefix,
        BlobHeader->TTL,
        Prefix,
        BlobHeader->pSecDesc,
        Prefix,
        BlobHeader->hLastSuccessAccessToken,
        renderedSymbol
        );

}   // DumpBlobHeader


VOID
DumpOpenFileInfo(
    IN PSTR Prefix,
    IN LPTS_OPEN_FILE_INFO OpenFileInfo,
    IN ULONG_PTR ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a specific TS_OPEN_FILE_INFO structure.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    OpenFileInfo - Points to a local copy of the structure.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    dprintf(
        "%sTS_OPEN_FILE_INFO @ %p %s\n"
        "%s    m_hFile                  = %08lp\n"
        "%s    m_hUser                  = %08lp\n"
        "%s    m_CastratedLastWriteTime @ %p\n",
        Prefix,
        ActualAddress,
        SignatureToString(OpenFileInfo->m_Signature,
                          TS_FILE_INFO_SIGNATURE,
                          TS_FREE_FILE_INFO_SIGNATURE),
        Prefix,
        OpenFileInfo->m_hFile,
        Prefix,
        OpenFileInfo->m_hUser,
        Prefix,
        ActualAddress + FIELD_OFFSET( TS_OPEN_FILE_INFO, m_CastratedLastWriteTime )
        );

    dprintf(
        "%s    m_cbSecDescMaxSize       = %08lx\n"
        "%s    m_pSecurityDescriptor    = %08lp\n"
        "%s    m_fSecurityDescriptor    = %s\n",
        Prefix,
        OpenFileInfo->m_cbSecDescMaxSize,
        Prefix,
        OpenFileInfo->m_pSecurityDescriptor,
        Prefix,
        BoolToString( OpenFileInfo->m_fSecurityDescriptor ) );

    dprintf(
        "%s    m_achHttpInfo            @ %p (%s)\n"
        "%s    m_cchHttpInfo            = %lu\n"
        "%s    m_achETag                @ %p (%s)\n"
        "%s    m_cchETag                = %lu\n"
        "%s    m_ETagIsWeak             = %s\n"
        "\n",
        Prefix,
        ActualAddress + FIELD_OFFSET( TS_OPEN_FILE_INFO, m_achHttpInfo ),
        OpenFileInfo->m_achHttpInfo,
        Prefix,
        OpenFileInfo->m_cchHttpInfo,
        Prefix,
        ActualAddress + FIELD_OFFSET( TS_OPEN_FILE_INFO, m_achETag ),
        OpenFileInfo->m_achETag,
        Prefix,
        OpenFileInfo->m_cchETag,
        Prefix,
        BoolToString( OpenFileInfo->m_ETagIsWeak )
        );

    if ( (ULONG_PTR) OpenFileInfo->m_FileKey.m_pszFileName == ActualAddress
                                        + FIELD_OFFSET(TS_OPEN_FILE_INFO, m_FileKey)
                                        + FIELD_OFFSET(CFileKey, m_achFileNameBuf) ) {

        //
        // Just print the internal buffer
        //
        dprintf(
            "%s    m_FileKey.m_achFileNameBuf = %s\n",
            Prefix,
            OpenFileInfo->m_FileKey.m_achFileNameBuf
            );
    } else {
        //
        // print address of the real string
        //
        dprintf(
            "%s    m_FileKey.m_pszFileName  = %p\n",
            Prefix,
            OpenFileInfo->m_FileKey.m_pszFileName
            );
    }


    dprintf(
        "%s    m_FileKey.m_cbFileName   = %d\n"
        "%s    m_bIsCached              = %s\n"
        "%s    m_bState                 = %s\n"
        "%s    m_dwIORefCount           = %08lx\n"
        "%s    m_lRefCount              = %08lx\n",
        Prefix,
        OpenFileInfo->m_FileKey.m_cbFileName,
        Prefix,
        BoolToString( OpenFileInfo->m_bIsCached ),
        Prefix,
        FIStateToString( OpenFileInfo->m_state ),
        Prefix,
        OpenFileInfo->m_dwIORefCount,
        Prefix,
        OpenFileInfo->m_lRefCount );


}   // DumpOpenFileInfo


VOID
DumpUriInfo(
    IN PSTR Prefix,
    IN PW3_URI_INFO UriInfo,
    IN ULONG_PTR ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a specific W3_URI_INFO structure.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    UriInfo - Points to a local copy of the structure.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    CHAR name[MAX_PATH];
    CHAR unmappedName[MAX_PATH];

    if( UriInfo->pszName == NULL ) {
        strcpy( name, "<null>" );
    } else if( !ReadMemory(
            (ULONG_PTR)UriInfo->pszName,
            name,
            sizeof(name),
            NULL
            ) ) {
        strcpy( name, "<unreadable>" );
    }

    if( UriInfo->pszUnmappedName == NULL ) {
        strcpy( unmappedName, "<null>" );
    } else if( !ReadMemory(
            (ULONG_PTR)UriInfo->pszUnmappedName,
            unmappedName,
            sizeof(unmappedName),
            NULL
            ) ) {
        strcpy( unmappedName, "<unreadable>" );
    }

    dprintf(
        "%sW3_URI_INFO @ %p\n"
        "%s    bIsCached       = %s\n"
        "%s    pOpenFileInfo   = %08lp\n",
        Prefix,
        ActualAddress,
        Prefix,
        BoolToString( UriInfo->bIsCached ),
        Prefix,
        UriInfo->pOpenFileInfo
        );

    dprintf(
        "%s    dwFileOpenError = %lu\n"
        "%s    cchName         = %lu\n"
        "%s    pszName         = %08lp (%s)\n"
        "%s    pszUnmappedName = %08lp (%s)\n"
        "%s    pMetaData       = %08lp\n"
        "\n",
        Prefix,
        UriInfo->dwFileOpenError,
        Prefix,
        UriInfo->cchName,
        Prefix,
        UriInfo->pszName,
        name,
        Prefix,
        UriInfo->pszUnmappedName,
        unmappedName,
        Prefix,
        UriInfo->pMetaData
        );

}   // DumpUriInfo




VOID
DumpUriInfoBlob(
    IN PSTR Prefix,
    IN PBLOB_HEADER BlobHeader,
    IN ULONG_PTR ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a W3_URI_INFO blob.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    BlobHeader - Points to a local copy of the blob.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    W3_URI_INFO localUriInfo;

    if( !ReadMemory(
            ActualAddress + sizeof(*BlobHeader),
            &localUriInfo,
            sizeof(localUriInfo),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read W3_URI_INFO @ %p\n",
            ActualAddress + sizeof(*BlobHeader)
            );

        return;

    }

    DumpBlobHeader(
        Prefix,
        BlobHeader,
        ActualAddress
        );

    DumpUriInfo(
        Prefix,
        &localUriInfo,
        ActualAddress + sizeof(*BlobHeader)
        );

}   // DumpUriInfoBlob








VOID
DumpFileCacheTable(
    IN CFileHashTable * fht,
    IN ULONG_PTR ActualAddress,
    IN CFileCacheStats * fcs,
    IN BOOLEAN DumpEntries,
    IN BOOLEAN Verbose
    )

/*++

Routine Description:

    Formats and dumps the entire cache table.

Arguments:

    fht - Points to a local copy of the cache table.

    fcs - Points to the place where the cache statistics live

    ActualAddress - The virtual address of the cache table in the debugee.

    DumpEntries - Dump all the file info entries.

    Verbose - If TRUE, then be verbose.

Return Value:

    None.

--*/

{

    LONG i;

    //
    // Dump simple data.
    //

    dprintf(
        "CFileHashTable @ %p\n",
        ActualAddress
        );


    //
    // If requested, dump the individual entries
    //

    if (DumpEntries) {
        //
        // this will be GeorgeRe's problem
        //
    }

}   // DumpFileCacheTable


//
// NTSD extension entrypoints.
//


DECLARE_API( fcache )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the entire open file cache or a single cache object.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG_PTR address;
    ULONG_PTR address2;
    CFileHashTable * cacheTable;
    BOOLEAN dumpBin;
    BOOLEAN dumpMru;
    BOOLEAN verbose;

    INIT_API();

    //
    // Establish defaults.
    //

    dumpBin = FALSE;
    dumpMru = FALSE;
    verbose = FALSE;

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    //
    // Process switches.
    //

    while( *lpArgumentString == '-' ) {

        lpArgumentString++;

        while( *lpArgumentString != ' ' &&
               *lpArgumentString != '\t' &&
               *lpArgumentString != '\0' ) {

            switch( *lpArgumentString ) {
            case 'v' :
            case 'V' :
                verbose = !verbose;
                break;

            case 'b' :
            case 'B' :
                dumpBin = !dumpBin;
                break;

            case 'm' :
            case 'M' :
                dumpMru = !dumpMru;
                break;

            case '-' :  // Set the switches the way I like them. --keithmo
                verbose = TRUE;
                dumpBin = TRUE;
                dumpMru = FALSE;
                break;

            default :
                PrintUsage( "fcache" );
                return;

            }

            lpArgumentString++;

        }

        while( *lpArgumentString == ' ' ||
               *lpArgumentString == '\t' ) {
            lpArgumentString++;
        }

    }

    if( *lpArgumentString != '\0' ) {

        //
        // Dump a single object.
        //

        address = GetExpression( lpArgumentString );

        if( address == 0 ) {

            dprintf(
                "inetdbg: cannot evaluate \"%s\"\n",
                lpArgumentString
                );

            return;

        }


        return;

    }

    //
    // Dump the entire cache table.
    //

    address = GetExpression( "infocomm!g_pFileInfoTable" );

    if( address == 0 ) {

        dprintf(
            "inetdbg: cannot find infocomm!g_pFileInfoTable\n"
            );

        return;

    }

    address2 = GetExpression( "infocomm!g_pFileCacheStats" );

    if( address2 == 0 ) {

        dprintf(
            "inetdbg: cannot find infocomm!g_pFileCacheStats\n"
            );

        return;

    }

    if( !ReadMemory(
            address,
            &cacheTable,
            sizeof(cacheTable),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read CACHE_TABLE @ 0x%p\n",
            address
            );

        return;

    }


} // DECLARE_API( fcache )


DECLARE_API( open )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a specific TS_OPEN_FILE_INFO structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG_PTR address;
    BYTE openFileInfo[sizeof(TS_OPEN_FILE_INFO)];

    INIT_API();

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( "open" );
        return;
    }

    address = GetExpression( lpArgumentString );

    if( address == 0 ) {

        dprintf(
            "inetdbg: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the object.
    //

    if( !ReadMemory(
            (ULONG_PTR)address,
            &openFileInfo,
            sizeof(openFileInfo),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read TS_OPEN_FILE_INFO @ %lp\n",
            address
            );

        return;

    }

    DumpOpenFileInfo(
        "",
        (TS_OPEN_FILE_INFO *) &openFileInfo,
        address
        );

} // DECLARE_API( open )


DECLARE_API( uri )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a specific W3_URI_INFO structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG_PTR address;
    W3_URI_INFO uriInfo;

    INIT_API();

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( "uri" );
        return;
    }

    address = GetExpression( lpArgumentString );

    if( address == 0 ) {

        dprintf(
            "inetdbg: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the object.
    //

    if( !ReadMemory(
            address,
            &uriInfo,
            sizeof(uriInfo),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read W3_URI_INFO @ %lp\n",
            address
            );

        return;

    }

    DumpUriInfo(
        "",
        &uriInfo,
        address
        );

} // DECLARE_API( uri )





DECLARE_API( blob )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a specific BLOB_HEADER structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG_PTR address;
    BLOB_HEADER blobHeader;

    INIT_API();

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( "blob" );
        return;
    }

    address = GetExpression( lpArgumentString );

    if( address == 0 ) {

        dprintf(
            "inetdbg: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the object.
    //

    if( !ReadMemory(
            address,
            &blobHeader,
            sizeof(blobHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read BLOB_HEADER @ %lp\n",
            address
            );

        return;

    }

    DumpBlobHeader(
        "",
        &blobHeader,
        address
        );

} // DECLARE_API( blob )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\help.cxx ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    help.cxx

Abstract:

    This module contains the help text for all commands supported by this
    NTSD debugger extension.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "inetdbgp.h"

//
// The following structure defines the text displayed in response
// to the "!help" command. This text may also be displayed if invalid
// arguments are passed to a command.
//

typedef struct _HELP_MAP {

    //
    // This is the name of the command.
    //

    PSTR Command;

    //
    // This is a "one-liner" displayed when the user executes "!help".
    //

    PSTR OneLiner;

    //
    // This is the full help text displayed when the user executes
    // "!help <cmd>".
    //

    PSTR FullHelp;

} HELP_MAP, *PHELP_MAP;

HELP_MAP HelpMaps[] =
    {
        {
            "help",
            "Dump this list or help for specific command",
            "help [<cmd>] - Dump help for command\n"
            "  If no <cmd> is given, a list of all available commands is displayed\n"
        },

        {
            "atq",
            "Dump ATQ structures",
            "!atq <addr>    - Dump ATQ_CONTEXT at <addr>\n"
            "!atq -p <addr> - Dump ATQ_ENDPOINT at <addr>\n"
            "!atq -g        - Dump atq globals\n"
            "!atq -c[0|1|2|3][0|1]  - Dump atq client list at verbosity [n]\n"
            "  Verbosity Levels\n"
            "      0x - Traverse list, print number on list, confirm signatures\n"
            "      1x - Active Only\n"
            "      2x - All Atq contexts\n"
            "      x0 - Print one line summary of Atq Context\n"
            "      x1 - Print full Atq context\n"
            "!atq -e[0|1|2|3][0|1] <endpoint-addr> - \n"
            "     Dump atq client list at verbosity for given endpoint\n"
            "!atq -l           - Dump atq Endpoint list\n"
        },

        {
            "asp",
            "Dump ASP structures",
            "!asp -g              - Dump ASP globals\n"
			"!asp -tl             - Show items in template cache\n"
            "!asp [-v#] -e  <addr> - Dump information about script engine\n"
            "!asp [-v#] -h  <addr> - Dump CHitObj at <addr>\n"
            "!asp [-v#] -t  <addr> - Dump CTemplate at <addr>\n"
            "!asp [-v#] -tf <addr> - Dump CTemplate::CFileMap at <addr>\n"
            "!asp [-v#] -s  <addr> - Dump CSession at <addr>\n"
            "!asp [-v#] -a  <addr> - Dump CAppln at <addr>\n"
                        "!asp [-v#] -o  <addr> - Dump CComponentObject at <addr>\n"
                        "!asp -l <addr>       - VERY BRIEF Display of Object Collection at <addr>\n"
            "\n"
            "Some options can be prefixed with \"-v\" for more verbosity.  Example:\n"
            "     !inetdbg.asp -v -t <addr>\n"
            "\n"
            "An integer between 0 and 2 may follow the \"-v\" flag.\n"
            "   \"-v0\"  is equivalent to no \"-v\" option specified.\n"
            "   \"-v1\"  is equivalent to plain \"-v\"\n"
            "   \"-v2\"  specifies yet even more verbosity. (provides everything)\n"
            "\n"
            "Example:\n"
            "      !inetdbg.asp -v2 -o <addr>\n"
                        "\n"
                        "Pointers are displayed in hex.  Everything else is decimal unless prefixed with \"0x\".\n"
        },

        {
            "sched",
            "Dump scheduler structures",
            "!sched <addr>    - Dump Scheduler Item at <addr>\n"
            "!sched -S <addr> - Dump CSchedData at <addr>\n"
            "!sched -T <addr> - Dump CThreadData at <addr>\n"
            "!sched -s[0|1|2] - Dump global list of schedulers at verbosity [n]\n"
            "!sched -l[0|1]   - Dump Scheduler Item list at verbosity [n]\n"
        },

        {
            "acache",
            "Dump allocation cache structures",
            "!acache <addr>  - Dump Allocation Cache Handler at <addr>\n"
            "!acache -g      - Dump Allocation Cache global information\n"
            "!acache -l[0|1] - Dump Allocation Cache list at verbosity [v]\n"
        },

        {
            "ds",
            "Dump stack with symbols",
            "!ds [-v] <addr>  - Dump symbols on stack\n"
            "      -v == print valid symbols only\n"
            "      default addr == current stack pointer\n"
        },

        {
            "ref",
            "Dump reference trace log",
            "!ref <addr> [<context>...] - Dump reference trace log at <addr>\n"
        },

        {
            "rref",
            "Dump reference trace log in reverse order",
            "!rref <addr> [<context>...] - Same as ref, except dumps backwards\n"
        },

        {
            "resetref",
            "Reset reference trace log",
            "!resetref <addr> - Reset reference trace log at <addr>\n"
        },

        {
            "st",
            "Dump string trace log",
            "!st [-l[0|1]] <addr> - Dump string trace log at <addr>\n"
        },

        {
            "rst",
            "Dump string trace log in reverse order",
            "!rst [-l[0|1]] <addr> - Same as st, except dumps backwards\n"
        },

        {
            "resetst",
            "Reset string trace log",
            "!resetst <addr> - Reset string trace log at <addr>\n"
        },

        {
            "wstats",
            "Dump W3 server statistics",
            "!wstats [<addr>] - Dump w3svc:W3_SERVER_STATISTICS at <addr>\n"
        },

        {
            "cc",
            "Dump W3 CLIENT_CONN structures",
            "!cc <addr>  - Dump w3svc:CLIENT_CONN at <addr>\n"
            "!cc -l[0|1] - Dump w3svc:CLIENT_CONN list at verbosity [v]\n"
        },

        {
            "hreq",
            "Dump W3 HTTP_REQUEST structures",
            "!hreq <addr>  - Dump w3svc:HTTP_REQUEST object at <addr>\n"
            "!hreq -l[0|1] - Dump HTTP_REQUEST list at verbosity [n]\n"
        },

        {
            "wreq",
            "Dump W3 WAM_REQUEST structures",
            "!wreq <addr>  - Dump w3svc:WAM_REQUEST object at <addr>\n"
            "!wreq -l[0|1] - Dump WAM_REQUEST list at verbosity [n]\n"
        },

        {
            "wxin",
            "Dump WAM_EXEC_INFO structures",
            "!wxin <addr>             - Dump wam:WAM_EXEC_INFO object at <addr>\n"
            "!wxin -l[0|1] <WAM addr> - Dump WAM's list of WAM_EXEC_INFOs at verbosity [n]\n"
        },

        {
            "rpcoop",
            "Find process/thread ID buried in RPC parameters",
            "!rpcoop <addr> - given RPC param finds the process id for OOP\n"
            "  Verbosity Levels [v]\n"
            "      0 - Print one line summary\n"
            "      1 - Print level 1 information\n"
            "      2 - Print level 2 information\n"
        },

        {
            "fcache",
            "Dump IIS file cache structures",
            "!fcache [options] - Dump entire File Cache\n"
             "     -b == dump bin lists\n"
             "     -m == dump mru list\n"
             "     -v == verbose\n"
            "!fcache <addr>    - Dump File Cache entry at <addr>\n"
        },

        {
            "lkrhash",
            "Dump LKRhash table structures",
            "!lkrhash [options] <addr>    - Dump LKRhash table at <addr>\n"
             "     -l[0-2] == verbosity level\n"
             "     -v      == very verbose\n"
             "     -g[0-2] == dump global list of LKRhashes at verbosity level\n"
        },

        {
            "open",
            "Dump TS_OPEN_FILE_INFO structures",
            "!open <addr> - Dump TS_OPEN_FILE_INFO @ <addr>\n"
        },

        {
            "uri",
            "Dump W3_URI_INFO structures",
            "!uri <addr> - Dump W3_URI_INFO @ <addr>\n"
        },

        {
            "phys",
            "Dump PHYS_OPEN_FILE_INFO structures",
            "!phys <addr> - Dump PHYS_OPEN_FILE_INFO @ <addr>\n"
        },

        {
            "oplock",
            "Dump OPLOCK_OBJECT structures",
            "!oplock <addr> - Dump OPLOCK_OBJECT @ <addr>\n"
        },

        {
            "blob",
            "Dump BLOB_HEADER structures",
            "!blob <addr> - Dump BLOB_HEADER @ <addr>\n"
        },

        {
            "mod",
            "Dump module info",
            "!mod [<addr>] - Dump module info\n"
            "  If <addr> is specified, only module containing <addr> is dumped\n"
        },

        {
            "ver",
            "Dump module version resources",
            "!ver [<module>] - Dump version resource for specified module\n"
            "  <module> may be either a module base address or name\n"
            "  If no <module> is specified, then all modules are dumped\n"
        },

        {
            "heapfind",
            "Find heap block by size or address",
            "!heapfind -a<addr> - Find heap block containing <addr>\n"
            "!heapfind -s<size> - Find all heap blocks of length <size>\n"
        },

        {
            "heapstat",
            "Dump heap statistics",
            "!heapstat <min> - Dump heap statistics\n"
            "  If <min> is present, then only those heap blocks with counts >= <min>\n"
            "  are displayed. Note that *all* heap blocks are included in the totals,\n"
            "  even if those blocks had counts too small to display.\n"
            "  If <min> is not present, all heap blocks are displayed\n"
        },

        {
            "waminfo",
            "Dump WAM Dictator info",
            "!waminfo -g[0|1]              - Dump WamDictator info\n"
            "           0                  - Dump WamDictator info only\n"
            "           1                  - Dump WamDictator's Dying List\n"
            "!waminfo -d <WamInfoAddr>     - Dump WamInfo (InProc or OutProc)\n"
            "!waminfo -l <OOPListHeadAddr> - Dump WamInfoOutProc WamRequest OOP List\n"
        },

        {
            "spud",
            "Dump SPUD counters",
            "!spud - Dump SPUD counters\n"
        },

        {
            "gem",
            "Get current error mode",
            "!gem - Get current error mode\n"
        },

        {
            "exec",
            "Execute external command",
            "!exec [<cmd>] - Execute external command\n"
            "  Default <cmd> is CMD.EXE\n"
        },

        {
            "llc",
            "Counts items on a standard linked-list",
            "!llc <list_head> - Counts the LIST_ENTRYs present on the specified list head\n"
        },

        {
            "dumpoff",
            "Dump structure/class information base on debug info in PDB",
            "!dumpoff <pdb_file>!<type_name>[.<member_name>] [expression]\n"
            "!dumpoff -s [<pdb_search_path>]\n\n"
            "pdb_file          Un-qualified name of PDB file (eg. KERNEL32, NTDLL)\n"
            "type_name         Name of type (struct/class) to dump, OR \n"
            "                  ==<cbHexSize> to dump struct/classes of size cbHexSize\n"
            "member_name       (optional) Name of member in type_name to dump\n"
            "expression        (optional) Address of memory to dump as type_name\n"
            "                  if not present, offset(s) are dumped\n"
            "pdb_search_path   Set the search path for PDBs\n\n"
            "Examples:  !dumpoff ntdll!_RTL_CRITICAL_SECTION 14d4d0\n"
            "           !dumpoff w3svc!HTTP_REQUEST._dwSignature w3svc!g_GlobalObj\n"
            "           !dumpoff ntdll!_RTL_CRITICAL_SECTION\n"
            "           !dumpoff w3svc!==840\n"
            "           !dumpoff -s \\\\mydrive\\pdbs;c:\\local\\pdbs\n"
        },

        {
            "vmstat",
            "Dump virtual memory statistics",
            "!vmstat - Dump virtual memory statistics"
        },

        {
            "vmmap",
            "Dump virtual memory map",
            "!vmmap - Dump virtual memory map"
        }

#ifndef _NO_TRACING_
        ,{
            "trace",
            "Configure WMI Tracing",
            "!trace -o <LoggerName> <LoggerFileName> Toggle tracing active state\n"
            "!trace -d <Module_Name|all> 0|1 Set OutputDebugString generation state\n"
            "!trace -s [Module_Name] List module status\n"
            "!trace -a <Module_Name|all> <LoggerName> [Level] [Flags] Set active state of specified module\n"
            "!trace -f <Module_Name|all> <Flag> Set control flag for a specific module\n\n"
            "Notes: -o does not activate any modules, you must use the -a option for that\n"
            "       -a can not notify WMI, this may cause odd results when using \"tracelog\"\n"
            "       The level & flag are hexadecimal\n"
        }

#endif
    };

#define NUM_HELP_MAPS ( sizeof(HelpMaps) / sizeof(HelpMaps[0]) )


PSTR
FindHelpForCommand(
    IN PSTR CommandName
    )
{

    PHELP_MAP helpMap;
    ULONG i;

    for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
        if( _stricmp( helpMap->Command, CommandName ) == 0 ) {
            return helpMap->FullHelp;
        }
    }

    return NULL;

}   // FindHelpForCommand

VOID
PrintUsage(
    IN PSTR CommandName
    )
{

    PSTR cmdHelp;
    PHELP_MAP helpMap;
    ULONG i;
    ULONG maxLength;
    ULONG length;

    dprintf( "IIS debugging extension for IIS Version 5.0\n" );

    if( CommandName == NULL ) {

        //
        // We'll display the one-liners for each command. Start by
        // scanning the commands to find the longest length. This makes the
        // output much prettier without having to manually tweak the
        // columns.
        //

        maxLength = 0;

        for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
            length = (ULONG)strlen( helpMap->Command );
            if( length > maxLength ) {
                maxLength = length;
            }
        }

        //
        // Now actually display the one-liners.
        //

        for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
            dprintf(
                "!%-*s - %s\n",
                maxLength,
                helpMap->Command,
                helpMap->OneLiner
                );
        }

    } else {

        //
        // Find a specific command and display the full help.
        //

        cmdHelp = FindHelpForCommand( CommandName );

        if( cmdHelp == NULL ) {
            dprintf( "unrecognized command %s\n", CommandName );
        } else {
            dprintf( "%s", cmdHelp );
        }

    }

} // PrintUsage()


DECLARE_API( help )
{

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( !strcmp( lpArgumentString, "?" ) ) {
        lpArgumentString = "help";
    }

    if( *lpArgumentString == '\0' ) {
        lpArgumentString = NULL;
    }

    PrintUsage( lpArgumentString );

} // DECLARE_API( help )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\inetdbgp.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    inetdbgp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Murali Krishnan (MuraliK) 22-Aug-1996

Revision History:

--*/

# ifndef _INETDBGP_H_
# define _INETDBGP_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef IF_DEBUG

#include <windows.h>
#include <ntsdexts.h>
// TODO: use wdbgexts.h instead of ntsdexts.h
// #include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <stdlib.h>


//
// To obtain the private & protected members of C++ class,
// let me fake the "private" keyword
//
# define private    public
# define protected  public


//
// Turn off dllexp et al so this DLL won't export tons of unnecessary garbage.
//

#define dllexp

#undef _NTDDK_
#undef _WMIKM_

#define IRTL_DLLEXP
#define IRTL_EXPIMP
#define DLL_IMPLEMENTATION  
#define IMPLEMENTATION_EXPORT

# include <dbgutil.h>

// undef these so that we can avoid linking with iisrtl
# undef  DBG_ASSERT
# define DBG_ASSERT(exp)                         ((void)0) /* Do Nothing */
# undef  SET_CRITICAL_SECTION_SPIN_COUNT
# define SET_CRITICAL_SECTION_SPIN_COUNT(lpCS, dwSpins) \
         SetCriticalSectionSpinCount(lpCS, dwSpins)
# undef  INITIALIZE_CRITICAL_SECTION
# define INITIALIZE_CRITICAL_SECTION(lpCS) \
         InitializeCriticalSection(lpCS)
# undef  INITIALIZE_CRITICAL_SECTION_SPIN
# define INITIALIZE_CRITICAL_SECTION_SPIN(lpCS, dwSpin) \
         InitializeCriticalSectionAndSpinCount(lpCS, dwSpin)

#include <lkrhash.h>

# include <reftrace.h>
# include <strlog.hxx>

# include <atq.h>
# include <atqtypes.hxx>
# include <acache.hxx>

# include <iistypes.hxx>
# include <iis64.h>

# include <timer.h>
# include <issched.hxx>
# include <sched.hxx>

# include <w3p.hxx>

# define _IIS_TYPES_HXX_
typedef class IIS_SERVER_INSTANCE *PIIS_SERVER_INSTANCE;
# include <tsunamip.hxx>
# include <filehash.hxx>
# include <filecach.hxx>

/************************************************************
 *   Macro Definitions
 ************************************************************/

// Set IISRTL_NAME to the name of the DLL hosting the IIS RunTime Library
#define IISRTL_NAME "iisrtl"
// #define IISRTL_NAME "misrtl"
// #define IISRTL_NAME "gisrtl"

// TODO: make this variable configurable
extern CHAR g_szIisRtlName[MAX_PATH];

LPSTR
IisRtlVar(
    LPCSTR pszFormat);

// For use as arguments to '%c%c%c%c'
#define DECODE_SIGNATURE(dw) \
    isprint(((dw) >>  0) & 0xFF) ? (((dw) >>  0) & 0xFF) : '?', \
    isprint(((dw) >>  8) & 0xFF) ? (((dw) >>  8) & 0xFF) : '?', \
    isprint(((dw) >> 16) & 0xFF) ? (((dw) >> 16) & 0xFF) : '?', \
    isprint(((dw) >> 24) & 0xFF) ? (((dw) >> 24) & 0xFF) : '?'

#define move(dst, src)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#define MoveWithRet(dst, src, retVal)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return  retVal;\
}

#define MoveBlockWithRet(dst, src, size, retVal)\
__try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} __except (EXCEPTION_EXECUTE_HANDLER) {\
    return retVal;\
}

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#ifndef DECLARE_API
# define DECLARE_API(s)                         \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PNTSD_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )
#endif

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disasm                  (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )

#ifndef malloc
# define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif

#ifndef calloc
# define calloc( n , s) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (n)*(s) )
#endif

#ifndef realloc
# define realloc( p, n ) HeapReAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (p), (n) )
#endif

#ifndef free
# define free( p ) HeapFree( GetProcessHeap(), 0, (p) )
#endif


#define NUM_STACK_SYMBOLS_TO_DUMP   48

#define MAX_SYMBOL_LEN            1024


# define BoolValue( b) ((b) ? "    TRUE" : "   FALSE")


#define DumpDword( symbol )                                     \
        {                                                       \
            ULONG_PTR dw = GetExpression( "&" symbol );         \
            ULONG_PTR dwValue = 0;                              \
                                                                \
            if ( dw )                                           \
            {                                                   \
                if ( ReadMemory( (LPVOID) dw,                   \
                                 &dwValue,                      \
                                 sizeof(dwValue),               \
                                 NULL ))                        \
                {                                               \
                    dprintf( "\t" symbol "   = %8d (0x%p)\n",   \
                             dwValue,                           \
                             dwValue );                         \
                }                                               \
            }                                                   \
        }


//
// C++ Structures typically require the constructors and most times
//  we may not have default constructors
//  => trouble in defining a copy of these struct/class inside the
//     Debugger extension DLL for debugger process
// So we will define them as CHARACTER arrays with appropriate sizes.
// This is okay, since we are not really interested in structure as is,
//  however, we will copy over data block from the debuggee process to
//  these structure variables in the debugger process.
//
# define DEFINE_CPP_VAR( className, classVar) \
   CHAR  classVar[sizeof(className)]

# define GET_CPP_VAR_PTR( className, classVar) \
   (className * ) &classVar



/************************************************************
 *   Prototype Definitions
 ************************************************************/

extern NTSD_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;

VOID dstring( CHAR * pszName, PVOID pvString, DWORD cbLen);

VOID PrintLargeInteger( CHAR * pszName, LARGE_INTEGER * pli);

VOID Print2Dwords( CHAR * pszN1, DWORD d1,
                   CHAR * pszN2, DWORD d2
                   );

VOID PrintUsage( IN PSTR CommandName );

//
// Determine if a linked list is empty.
//

#define IS_LIST_EMPTY( localaddr, remoteaddr, type, fieldname )             \
    ( ((type *)(localaddr))->fieldname.Flink ==                             \
        (PLIST_ENTRY)( (remoteaddr) +                                       \
              FIELD_OFFSET( type, fieldname ) ) )

//
// Module enumerator.
//

typedef struct _MODULE_INFO {
    ULONG_PTR DllBase;
    ULONG_PTR EntryPoint;
    ULONG SizeOfImage;
    CHAR BaseName[MAX_PATH];
    CHAR FullName[MAX_PATH];
} MODULE_INFO, *PMODULE_INFO;

typedef
BOOLEAN
(CALLBACK * PFN_ENUMMODULES)(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    );

BOOLEAN
EnumModules(
    IN PFN_ENUMMODULES EnumProc,
    IN PVOID Param
    );

BOOLEAN
FindModuleByAddress(
    IN ULONG_PTR ModuleAddress,
    OUT PMODULE_INFO ModuleInfo
    );

//
// Enumerator for NT's standard doubly linked list LIST_ENTRY
//
//  PFN_LIST_ENUMERATOR
//     This is the callback function for printing the CLIENT_CONN object.
//
//  Arguments:
//    pvDebuggee  - pointer to object in the debuggee process
//    pvDebugger  - pointer to object in the debugger process
//    verbosity   - character indicating the verbosity level desired
//
typedef
VOID
(CALLBACK * PFN_LIST_ENUMERATOR)(
    IN PVOID pvDebugee,
    IN PVOID pvDebugger,
    IN CHAR  chVerbosity,         //verbosity value supplied for the enumerator
    IN DWORD iCount               //index for the item being enumerated
    );

BOOL
EnumLinkedList(
    IN LIST_ENTRY  *       pListHead,
    IN PFN_LIST_ENUMERATOR pfnListEnumerator,
    IN CHAR                chVerbosity,
    IN DWORD               cbSizeOfStructure,
    IN DWORD               cbListEntryOffset
    );

// Enumerator for an LKRhash table node entry

class CLKRLinearHashTable;
class CLKRHashTable;

typedef
BOOL
(CALLBACK * PFN_ENUM_LKRHASH)(
    IN const void* pvParam,
    IN DWORD       dwSignature,
    IN INT         nVerbose);

BOOL
EnumerateLKRhashTable(
    IN PFN_ENUM_LKRHASH  pfnEnum,
    IN CLKRHashTable*    pht,
    IN INT               nVerbose);

BOOL
EnumerateLKRLinearHashTable(
    IN PFN_ENUM_LKRHASH     pfnEnum,
    IN CLKRLinearHashTable* plht,
    IN INT                  nVerbose);


// Functions from dbglocks.cxx

const char*
LockName(
    LOCK_LOCKTYPE lt);

int
LockSize(
    LOCK_LOCKTYPE lt);

BOOL
PrintLock(
    LOCK_LOCKTYPE lt,
    IN PVOID      pvLock,
    IN INT        nVerbose);


// Call debugger extension in other extension DLL

typedef VOID (_stdcall *PWINDBG_EXTENSION_FUNCTION)(
    HANDLE, HANDLE, ULONG, ULONG, PCSTR); 
#define DO_EXTENSION(szModule, szCommand, szArgs)                          \
    CallExtension((szModule), (szCommand), hCurrentProcess, hCurrentThread,\
                  dwCurrentPc, dwProcessor, (szArgs))

NTSTATUS
CallExtension(
    PCSTR szModuleName,
    PCSTR szFunction,
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    ULONG dwCurrentPc,
    ULONG dwProcessor,
    PCSTR args);

/***********************************************************************
 * w3svc's CLIENT_CONN functions needed by other objects
 **********************************************************************/

// Walks and dumps information for the client-conn list
VOID DumpClientConnList( CHAR Verbosity, PFN_LIST_ENUMERATOR pfnCC);


# endif //  _INETDBGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\ntstuff.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    ntstuff.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    NT-specific properties.

Author:

    Keith Moore (keithmo) 08-Nov-1997

Revision History:

--*/

#include "inetdbgp.h"



/************************************************************
 * Dump Current Error Mode
 ************************************************************/

DECLARE_API( gem )

/*++

Routine Description:

    This function is called as an NTSD extension to display the
    current error mode of the debugee.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    NTSTATUS status;
    UINT errorMode;

    INIT_API();

    status = NtQueryInformationProcess(
                 ExtensionCurrentProcess,
                 ProcessDefaultHardErrorMode,
                 (PVOID)&errorMode,
                 sizeof(errorMode),
                 NULL
                 );

    if( !NT_SUCCESS(status) ) {
        dprintf( "Cannot query error mode, error %08lx\n", status );
        return;
    }

    if( errorMode & 1 ) {
        errorMode &= ~SEM_FAILCRITICALERRORS;
    } else {
        errorMode |= SEM_FAILCRITICALERRORS;
    }

    dprintf(
        "Current error mode = %08lx\n",
        errorMode
        );

    if( errorMode & SEM_FAILCRITICALERRORS ) {
        dprintf( "    SEM_FAILCRITICALERRORS\n" );
    }

    if( errorMode & SEM_NOGPFAULTERRORBOX ) {
        dprintf( "    SEM_NOGPFAULTERRORBOX\n" );
    }

    if( errorMode & SEM_NOALIGNMENTFAULTEXCEPT ) {
        dprintf( "    SEM_NOALIGNMENTFAULTEXCEPT\n" );
    }

    if( errorMode & SEM_NOOPENFILEERRORBOX ) {
        dprintf( "    SEM_NOOPENFILEERRORBOX\n" );
    }

}   // DECLARE_API( gem )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\mod.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    mod.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping module
    information.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include "inetdbgp.h"

typedef struct _ENUM_CONTEXT {
    BOOLEAN FirstTime;
} ENUM_CONTEXT, *PENUM_CONTEXT;


/************************************************************
 * Dump Module Info
 ************************************************************/


BOOLEAN
CALLBACK
ModpEnumProc(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    )
{

    PENUM_CONTEXT context;

    context = (PENUM_CONTEXT)Param;

    if( context->FirstTime ) {
        context->FirstTime = FALSE;
        dprintf( "Start    End      Entry    Path\n" );
    }

    dprintf(
        "%08lp %08lp %08lp %s\n",
        ModuleInfo->DllBase,
        ModuleInfo->DllBase + ModuleInfo->SizeOfImage,
        ModuleInfo->EntryPoint,
        ModuleInfo->FullName
        );

    return TRUE;

}   // ModpEnumProc


DECLARE_API( mod )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    module information.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ENUM_CONTEXT context;
    MODULE_INFO modInfo;
    ULONG address;
    PSTR endPointer;

    INIT_API();

    context.FirstTime = TRUE;

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        //
        // No argument passed, dump all modules.
        //

        if( !EnumModules(
                ModpEnumProc,
                (PVOID)&context
                ) ) {
            dprintf( "error retrieving module list\n" );
        }

    } else {

        //
        // Try to find the module containing the specified address.
        //

        address = strtoul( lpArgumentString, &endPointer, 16 );

        if( *endPointer != ' ' && *endPointer != '\t' && *endPointer != '\0' ) {
            PrintUsage( "mod" );
            return;
        }

        if( FindModuleByAddress( address, &modInfo ) ) {
            ModpEnumProc( (PVOID)&context, &modInfo );
        } else {
            dprintf( "Cannot find %08lp\n", address );
        }

    }

}   // DECLARE_API( mod )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\oemdbi.h ===
// Debug Information API
// VC++5.0 Read-Only OEM Edition
// Copyright (C) 1993-1997, Microsoft Corp.  All Rights Reserved.

#ifndef __OEMDBI_INCLUDED__
#define __OEMDBI_INCLUDED__

typedef int             BOOL;
typedef unsigned        UINT;
typedef unsigned char   BYTE;
typedef unsigned long   ULONG;
typedef unsigned short  USHORT;
typedef unsigned long   DWORD;
typedef short           SHORT;
typedef long            LONG;
typedef char *          SZ;

typedef unsigned long   CV_typ_t;
typedef CV_typ_t        TI;     // PDB name for type index
typedef ULONG           INTV;   // interface version number
typedef ULONG           IMPV;   // implementation version number
typedef ULONG           SIG;    // unique (across PDB instances) signature
typedef ULONG           AGE;    // no. of times this instance has been updated
typedef BYTE*           PB;     // pointer to some bytes
typedef LONG            CB;     // count of bytes
typedef char*           SZ;     // zero terminated string
typedef char*           PCH;    // char ptr
typedef USHORT          IFILE;  // file index
typedef USHORT          IMOD;   // module index
typedef USHORT          ISECT;  // section index
typedef USHORT          LINE;   // line number
typedef LONG            OFF;    // offset
typedef BYTE            ITSM;   // type server map index

enum {
    PDBIntv50a  = 19970116,
    PDBIntv50   = 19960502,
    PDBIntv41   = 920924,
    PDBIntvAlt  = PDBIntv50,   // Alternate (backward compatible) supported interface
    PDBIntv     = PDBIntv50a,
};

enum {
    PDB_MAX_PATH = 260,
    cbErrMax     = 1024,    // max. length of error message
};

typedef CV_typ_t TI;        // type index
struct PDB;                 // program database
struct DBI;                 // debug information within the PDB
struct Mod;                 // a module within the DBI
struct TPI;                 // type info within the DBI
struct GSI;
struct Enum;                // generic enumerator
struct EnumContrib;         // enumerate contributions
struct Dbg;                 // misc debug data (FPO, OMAP, etc)

typedef struct PDB PDB;
typedef struct DBI DBI;
typedef struct Mod Mod;
typedef struct TPI TPI;
typedef struct GSI GSI;
typedef struct Enum Enum;
typedef struct EnumContrib EnumContrib;
typedef struct Dbg Dbg;

typedef long EC;            // error code
enum PDBErrors {
    EC_OK,                  // -, no problemo
    EC_USAGE,               // -, invalid parameter or call order
    EC_OUT_OF_MEMORY,       // -, out of RAM
    EC_FILE_SYSTEM,         // "pdb name", can't write file, out of disk, etc.
    EC_NOT_FOUND,           // "pdb name", PDB file not found
    EC_INVALID_SIG,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_INVALID_AGE,         // "pdb name", PDB::OpenValidate() and its clients only
    EC_PRECOMP_REQUIRED,    // "obj name", Mod::AddTypes() only
    EC_OUT_OF_TI,           // "pdb name", TPI::QueryTiForCVRecord() only
    EC_NOT_IMPLEMENTED,     // -
    EC_V1_PDB,              // "pdb name", PDB::Open* only
    EC_FORMAT,              // accessing pdb with obsolete format
    EC_LIMIT,
    EC_CORRUPT,             // cv info corrupt, recompile mod
    EC_TI16,                // no 16-bit type interface present
    EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
    EC_MAX
};

#ifndef PDBCALL
#define PDBCALL  __cdecl
#endif

#define PDB_IMPORT_EXPORT(RTYPE)    __declspec(dllimport) RTYPE PDBCALL

#define PDBAPI PDB_IMPORT_EXPORT

#define IN                  /* in parameter, parameters are IN by default */
#define OUT                 /* out parameter */

struct _tagSEARCHDEBUGINFO;
typedef BOOL (__stdcall * pfnFindDebugInfoFile) ( struct _tagSEARCHDEBUGINFO* );
typedef BOOL (__stdcall * PFNVALIDATEDEBUGINFOFILE) (const char* szFile, ULONG * errcode );

typedef struct _tagSEARCHDEBUGINFO {
    DWORD   cb;                         // doubles as version detection
    BOOL    fMainDebugFile;             // indicates "core" or "ancillary" file
                                        // eg: main.exe has main.pdb and foo.lib->foo.pdb
    SZ      szMod;                      // exe/dll
    SZ      szLib;                      // lib if appropriate
    SZ      szObj;                      // object file
    SZ *    rgszTriedThese;             // list of ones that were tried,
                                        // NULL terminated list of LSZ's
    char    szValidatedFile[PDB_MAX_PATH]; // output of validated filename,
    PFNVALIDATEDEBUGINFOFILE
            pfnValidateDebugInfoFile;   // validation function
} SEARCHDEBUGINFO, *PSEARCHDEBUGINFO;

enum DBGTYPE {
    dbgtypeFPO,
    dbgtypeException,
    dbgtypeFixup,
    dbgtypeOmapToSrc,
    dbgtypeOmapFromSrc,
    dbgtypeSectionHdr,
};

typedef enum DBGTYPE DBGTYPE;

// ANSI C Binding

#if __cplusplus
extern "C" {
#endif

PDBAPI( BOOL )
PDBOpenValidate(
    SZ szPDB,
    SZ szExeDir,
    SZ szMode,
    SIG sig,
    AGE age,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

PDBAPI( BOOL )
PDBOpen(
    SZ szPDB,
    SZ szMode,
    SIG sigInitial,
    OUT EC* pec,
    OUT char szError[cbErrMax],
    OUT PDB** pppdb);

// a dbi client should never call PDBExportValidateInterface directly - use PDBValidateInterface
PDBAPI( BOOL )
PDBExportValidateInterface(
    INTV intv);

__inline BOOL PDBValidateInterface()
{
    return PDBExportValidateInterface(PDBIntv);
}

PDBAPI( EC )    PDBQueryLastError(PDB* ppdb, OUT char szError[cbErrMax]);
PDBAPI( INTV )  PDBQueryInterfaceVersion(PDB* ppdb);
PDBAPI( IMPV )  PDBQueryImplementationVersion(PDB* ppdb);
PDBAPI( SZ )    PDBQueryPDBName(PDB* ppdb, OUT char szPDB[PDB_MAX_PATH]);
PDBAPI( SIG )   PDBQuerySignature(PDB* ppdb);
PDBAPI( AGE )   PDBQueryAge(PDB* ppdb);
PDBAPI( BOOL )  PDBOpenDBI(PDB* ppdb, SZ szMode, SZ szTarget, OUT DBI** ppdbi);
PDBAPI( BOOL )  PDBOpenTpi(PDB* ppdb, SZ szMode, OUT TPI** pptpi);
PDBAPI( BOOL )  PDBClose(PDB* ppdb);
PDBAPI( BOOL )  PDBOpenDBIEx(PDB* ppdb, const char* szTarget, const char* szMode, OUT DBI** ppdbi, pfnFindDebugInfoFile srchfcn);

PDBAPI( BOOL )  DBIOpenMod(DBI* pdbi, SZ szModule, SZ szFile, OUT Mod** ppmod);
PDBAPI( BOOL )  DBIQueryNextMod(DBI* pdbi, Mod* pmod, Mod** ppmodNext);
PDBAPI( BOOL )  DBIOpenGlobals(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI( BOOL )  DBIOpenPublics(DBI* pdbi, OUT GSI **ppgsi);
PDBAPI( BOOL )  DBIQueryModFromAddr(DBI* pdbi, ISECT isect, OFF off, OUT Mod** ppmod, OUT ISECT* pisect, OUT OFF* poff, OUT CB* pcb);
PDBAPI( BOOL )  DBIQuerySecMap(DBI* pdbi, OUT PB pb, CB* pcb);
PDBAPI( BOOL )  DBIQueryFileInfo(DBI* pdbi, OUT PB pb, CB* pcb);
PDBAPI( BOOL )  DBIClose(DBI* pdbi);
PDBAPI( BOOL )  DBIGetEnumContrib(DBI* pdbi, OUT Enum** ppenum);
PDBAPI( BOOL )  DBIQueryTypeServer(DBI* pdbi, ITSM itsm, OUT TPI** pptpi );
PDBAPI( BOOL )  DBIQueryItsmForTi(DBI* pdbi, TI ti, OUT ITSM* pitsm );
PDBAPI( BOOL )  DBIQueryLazyTypes(DBI* pdbi);
PDBAPI( BOOL )  DBIFindTypeServers( DBI* pdbi, OUT EC* pec, OUT char szError[cbErrMax] );
PDBAPI( BOOL )  DBIOpenDbg(DBI* pdbi, DBGTYPE dbgtype, OUT Dbg **ppdbg);
PDBAPI( BOOL )  DBIQueryDbgTypes(DBI* pdbi, OUT DBGTYPE *pdbgtype, OUT long* pcDbgtype);

PDBAPI( BOOL )  ModQueryCBName(Mod* pmod, OUT CB* pcb);
PDBAPI( BOOL )  ModQueryName(Mod* pmod, OUT char szName[PDB_MAX_PATH], OUT CB* pcb);
PDBAPI( BOOL )  ModQuerySymbols(Mod* pmod, PB pbSym, CB* pcb);
PDBAPI( BOOL )  ModQueryLines(Mod* pmod, PB pbLines, CB* pcb);
PDBAPI( BOOL )  ModSetPvClient(Mod* pmod, void *pvClient);
PDBAPI( BOOL )  ModGetPvClient(Mod* pmod, OUT void** ppvClient);
PDBAPI( BOOL )  ModQuerySecContrib(Mod* pmod, OUT ISECT* pisect, OUT OFF* poff, OUT CB* pcb, OUT ULONG* pdwCharacteristics);
PDBAPI( BOOL )  ModQueryImod(Mod* pmod, OUT IMOD* pimod);
PDBAPI( BOOL )  ModQueryDBI(Mod* pmod, OUT DBI** ppdbi);
PDBAPI( BOOL )  ModClose(Mod* pmod);
PDBAPI( BOOL )  ModQueryCBFile(Mod* pmod, OUT long* pcb);
PDBAPI( BOOL )  ModQueryFile(Mod* pmod, OUT char szFile[PDB_MAX_PATH], OUT long* pcb);
PDBAPI( BOOL )  ModQueryTpi(Mod* pmod, OUT TPI** pptpi);

PDBAPI( void )  EnumContribRelease(EnumContrib* penum);
PDBAPI( void )  EnumContribReset(EnumContrib* penum);
PDBAPI( BOOL )  EnumContribNext(EnumContrib* penum);
PDBAPI( void )  EnumContribGet(EnumContrib* penum, OUT USHORT* pimod, OUT USHORT* pisect, OUT long* poff, OUT long* pcb, OUT ULONG* pdwCharacteristics);

PDBAPI( BOOL )  DbgClose(Dbg *pdbg);
PDBAPI( long )  DbgQuerySize(Dbg *pdbg);
PDBAPI( void )  DbgReset(Dbg *pdbg);
PDBAPI( BOOL )  DbgSkip(Dbg *pdbg, ULONG celt);
PDBAPI( BOOL )  DbgQueryNext(Dbg *pdbg, ULONG celt, OUT void *rgelt);
PDBAPI( BOOL )  DbgFind(Dbg *pdbg, IN OUT void *pelt);

// can't use the same api's for 32-bit TIs.
PDBAPI(BOOL)    TypesQueryCVRecordForTiEx(TPI* ptpi, TI ti, OUT PB pb, IN OUT CB* pcb);
PDBAPI(BOOL)    TypesQueryPbCVRecordForTiEx(TPI* ptpi, TI ti, OUT PB* ppb);
PDBAPI(TI)      TypesQueryTiMinEx(TPI* ptpi);
PDBAPI(TI)      TypesQueryTiMacEx(TPI* ptpi);
PDBAPI(CB)      TypesQueryCb(TPI* ptpi);
PDBAPI(BOOL)    TypesClose(TPI* ptpi);
PDBAPI(BOOL)    TypesQueryTiForUDTEx(TPI* ptpi, char* sz, BOOL fCase, OUT TI* pti);
PDBAPI(BOOL)    TypesSupportQueryTiForUDT(TPI*);

// Map all old ones to new ones for new compilands.
#define TypesQueryCVRecordForTi     TypesQueryCVRecordForTiEx
#define TypesQueryPbCVRecordForTi   TypesQueryPbCVRecordForTiEx
#define TypesQueryTiMin             TypesQueryTiMinEx
#define TypesQueryTiMac             TypesQueryTiMacEx

PDBAPI( PB )    GSINextSym (GSI* pgsi, PB pbSym);
PDBAPI( PB )    GSIHashSym (GSI* pgsi, SZ szName, PB pbSym);
PDBAPI( PB )    GSINearestSym (GSI* pgsi, ISECT isect, OFF off,OUT OFF* pdisp);//currently only supported for publics
PDBAPI( BOOL )  GSIClose(GSI* pgsi);

#if __cplusplus
};
#endif

#define tsNil   ((TPI*)0)
#define tiNil   ((TI)0)
#define imodNil ((IMOD)(-1))

#define pdbRead                 "r"
#define pdbGetRecordsOnly       "c"         /* open PDB for type record access */

#endif // __OEMDBI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\spud.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    spud.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping the
    SPUD counters.

Author:

    Keith Moore (keithmo) 21-Oct-1997

Revision History:

--*/

#include "inetdbgp.h"

extern "C" {
#include <tdikrnl.h>
#include <afd.h>
#include <uspud.h>
}   // extern "C"


/************************************************************
 * Dump SPUD Counters
 ************************************************************/


DECLARE_API( spud )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the SPUD counters.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    SPUD_COUNTERS counters;
    NTSTATUS status;

    INIT_API();

    status = SPUDGetCounts( &counters );

    if( NT_SUCCESS(status) ) {
        dprintf(
            "CtrTransmitfileAndRecv = %lu\n"
            "CtrTrasnRecvFastTrans  = %lu\n"
            "CtrTransRecvFastRecv   = %lu\n"
            "CtrTransRecvSlowTrans  = %lu\n"
            "CtrTransRecvSlowRecv   = %lu\n"
            "CtrSendAndRecv         = %lu\n"
            "CtrSendRecvFastSend    = %lu\n"
            "CtrSendRecvFastRecv    = %lu\n"
            "CtrSendRecvSlowSend    = %lu\n"
            "CtrSendRecvSlowRecv    = %lu\n",
            counters.CtrTransmitfileAndRecv,
            counters.CtrTransRecvFastTrans,
            counters.CtrTransRecvFastRecv,
            counters.CtrTransRecvSlowTrans,
            counters.CtrTransRecvSlowRecv,
            counters.CtrSendAndRecv,
            counters.CtrSendRecvFastSend,
            counters.CtrSendRecvFastRecv,
            counters.CtrSendRecvSlowSend,
            counters.CtrSendRecvSlowRecv
            );
    } else {
        dprintf( "error %08lx retrieving SPUD counters\n", status );
    }

}   // DECLARE_API( spud )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\strlog.cxx ===
/*++

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    strlog.cxx

Abstract:

    CStringTraceLog support

Author:

    George V. Reilly (GeorgeRe)  22-Jun-1998

Revision History:

--*/

#include "inetdbgp.h"


/************************************************************
 * Dump String Trace Logs
 ************************************************************/


// Dummy implementations so that we can link
CStringTraceLog::CStringTraceLog(
    UINT cchEntrySize /* = 80 */,
    UINT cLogSize /* = 100 */)
{}



CStringTraceLog::~CStringTraceLog()
{}



VOID
DumpStringTraceLog(
    IN PSTR lpArgumentString,
    IN BOOLEAN fReverse
    )

/*++

Routine Description:

    Dumps the specified print trace log either forwards (fReverse == FALSE)
    or backwards (fReverse == TRUE).

Arguments:

    lpArgumentString - An expression specifying the print trace log to dump.

    fReverse - The dump direction.

Return Value:

    None.

--*/

{
    ULONG_PTR stlLogAddress = 0;
    ULONG_PTR entryAddress;
    LONG numEntries;
    CStringTraceLog stlHeader;
    TRACE_LOG tlogHeader;
    CStringTraceLog::CLogEntry logEntry;
    LONG i;
    DWORD offset;
    PCHAR format;
    LONG index;
    LONG direction;
    PSTR cmdName;
    UCHAR symbol[MAX_PATH];
    INT nVerbose = 0;

    direction = fReverse ? -1 : 1;
    cmdName = fReverse ? "rst" : "st";

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( cmdName );
        return;
    }

    if ( *lpArgumentString == '-' )
    {
        lpArgumentString++;

        if ( *lpArgumentString == 'h' )
        {
            PrintUsage( cmdName );
            return;
        }

        if ( *lpArgumentString == 'l' ) {
            lpArgumentString++;
            if ('0' <= *lpArgumentString  &&  *lpArgumentString <= '9' ) {
                nVerbose = *lpArgumentString++ - '0';
            }
        }

    }

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    stlLogAddress = (ULONG_PTR)GetExpression( lpArgumentString );

    if( stlLogAddress == 0 ) {

        dprintf(
            "inetdbg.%s: cannot evaluate \"%s\"\n",
            cmdName,
            lpArgumentString
            );

        return;

    }

    //
    // Skip to end of expression, then skip any blanks.
    //

    while( *lpArgumentString != ' ' &&
           *lpArgumentString != '\t' &&
           *lpArgumentString != '\0' ) {
        lpArgumentString++;
    }

    //
    // Read the log header, perform some sanity checks.
    //

    if( !ReadMemory(
            stlLogAddress,
            &stlHeader,
            sizeof(stlHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg.%s: cannot read memory @ %p\n",
            cmdName,
            (PVOID)stlLogAddress
            );

        return;
    }

    if( !ReadMemory(
            stlHeader.m_ptlog,
            &tlogHeader,
            sizeof(tlogHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg.%s: cannot read tracelog memory @ %p\n",
            cmdName,
            (PVOID)stlHeader.m_ptlog
            );

        return;
    }

    dprintf(
        "inetdbg.%s: log @ %p:\n"
        "    String Trace Log Signature = %08lx (%s)\n"
        "    Trace Log Signature = %08lx (%s)\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %lu\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %p\n",
        cmdName,
        (PVOID)stlLogAddress,
        stlHeader.m_Signature,
        stlHeader.m_Signature == CStringTraceLog::SIGNATURE
            ? "OK"
            : stlHeader.m_Signature == CStringTraceLog::SIGNATURE_X
              ? "FREED"
              : "INVALID",
        tlogHeader.Signature,
        tlogHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : tlogHeader.Signature == TRACE_LOG_SIGNATURE_X
              ? "FREED"
              : "INVALID",
        tlogHeader.LogSize,
        tlogHeader.NextEntry,
        tlogHeader.EntrySize,
        tlogHeader.LogBuffer
        );

    if( tlogHeader.LogBuffer
        > ( (PUCHAR)stlHeader.m_ptlog + sizeof(tlogHeader) ) )
    {
        dprintf(
            "    Extra Data @ %p\n",
            (PVOID)( stlLogAddress + sizeof(tlogHeader) )
            );
    }

    if( stlHeader.m_Signature != CStringTraceLog::SIGNATURE &&
        stlHeader.m_Signature != CStringTraceLog::SIGNATURE_X ) {

        dprintf(
            "inetdbg.%s: log @ %p has invalid signature: %08lx\n",
            cmdName,
            (PVOID)stlLogAddress,
            stlHeader.m_Signature
            );

        return;
    }

    if( (UINT) tlogHeader.EntrySize
        != sizeof(CStringTraceLog::CLogEntry) - CStringTraceLog::MAX_CCH + stlHeader.m_cch ) {

        dprintf(
            "inetdbg.%s: log @ %p is not a print trace log\n",
            cmdName,
            (PVOID)stlLogAddress
            );

        return;

    }

    if( tlogHeader.NextEntry == -1 ) {

        dprintf(
            "inetdbg.%s: empty log @ %p\n",
            cmdName,
            (PVOID)stlLogAddress
            );

        return;

    }

    //
    // Calculate the starting address and number of entries.
    //

    if( fReverse ) {
        if( tlogHeader.NextEntry < tlogHeader.LogSize ) {
            numEntries = tlogHeader.NextEntry + 1;
            index = tlogHeader.NextEntry;
        } else {
            numEntries = tlogHeader.LogSize;
            index = tlogHeader.NextEntry % tlogHeader.LogSize;
        }
    } else {
        if( tlogHeader.NextEntry < tlogHeader.LogSize ) {
            numEntries = tlogHeader.NextEntry + 1;
            index = 0;
        } else {
            numEntries = tlogHeader.LogSize;
            index = ( tlogHeader.NextEntry + 1 ) % tlogHeader.LogSize;
        }
    }

    entryAddress = (ULONG_PTR)tlogHeader.LogBuffer + (ULONG_PTR)( index * tlogHeader.EntrySize );

    if( entryAddress >=
        ( (ULONG_PTR)tlogHeader.LogBuffer + (ULONG_PTR)( numEntries * tlogHeader.EntrySize ) ) ) {

        dprintf(
            "inetdbg.%s: log @ %p has invalid data\n",
            cmdName,
            (PVOID)stlLogAddress
            );

        return;

    }

    //
    // Dump the log, which is stored in a circular buffer.
    //

    for( ;
         numEntries > 0 ;
         index += direction,
         numEntries--,
         entryAddress += ( direction * tlogHeader.EntrySize ) )
    {

        if( CheckControlC() ) {
            break;
        }

        if( index >= tlogHeader.LogSize ) {
            index = 0;
            entryAddress = (ULONG_PTR)tlogHeader.LogBuffer;
        } else if( index < 0 ) {
            index = tlogHeader.LogSize - 1;
            entryAddress = (ULONG_PTR)tlogHeader.LogBuffer
                + (ULONG_PTR)( index * tlogHeader.EntrySize );
        }

        if( !ReadMemory(
                entryAddress,
                &logEntry,
                tlogHeader.EntrySize,
                NULL
                ) ) {

            dprintf(
                "inetdbg.%s: cannot read memory @ %p\n",
                cmdName,
                (ULONG_PTR)entryAddress
                );

            return;

        }

        if (nVerbose == 0)
        {
            dprintf(
                "%04x: %s\n",
                logEntry.m_nThread,
                logEntry.m_ach
                );
        } else if (nVerbose == 1) {
            dprintf(
                "\n%6d: Thread = %04x, TimeStamp = %04x %04x %04x %04x\n"
                "%s\n",
                index,
                logEntry.m_nThread,
                HIWORD(logEntry.m_liTimeStamp.HighPart),
                LOWORD(logEntry.m_liTimeStamp.HighPart),
                HIWORD(logEntry.m_liTimeStamp.LowPart),
                LOWORD(logEntry.m_liTimeStamp.LowPart),
                logEntry.m_ach
                );
        }
    }

} // DumpStringTraceLog


DECLARE_API( st )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a print trace log.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    INIT_API();
    DumpStringTraceLog( lpArgumentString, FALSE );

} // DECLARE_API( st )


DECLARE_API( rst )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a print trace log backwards.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    INIT_API();
    DumpStringTraceLog( lpArgumentString, TRUE );

} // DECLARE_API( rst )


DECLARE_API( resetst )

/*++

Routine Description:

    This function is called as an NTSD extension to reset a print
    trace log back to its initial state.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG_PTR stlLogAddress = 0;
    CStringTraceLog stlHeader;
    TRACE_LOG tlogHeader;
    CStringTraceLog::CLogEntry logEntry;

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( "resetst" );
        return;
    }

    stlLogAddress = GetExpression( lpArgumentString );

    if( stlLogAddress == 0 ) {

        dprintf(
            "inetdbg.resetst: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the log header, perform some sanity checks.
    //

    if( !ReadMemory(
            stlLogAddress,
            &stlHeader,
            sizeof(stlHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg.resetst: cannot read memory @ %p\n",
            stlLogAddress
            );

        return;

    }

    if( !ReadMemory(
            stlHeader.m_ptlog,
            &tlogHeader,
            sizeof(tlogHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg.resetst: cannot read tracelog memory @ %p\n",
            (PVOID)stlHeader.m_ptlog
            );

        return;
    }

    dprintf(
        "inetdbg.resetst: log @ %p:\n"
        "    String Trace Log Signature = %08lx (%s)\n"
        "    Trace Log Signature = %08lx (%s)\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %lu\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %08lp\n",
        (PVOID) stlLogAddress,
        stlHeader.m_Signature,
        stlHeader.m_Signature == CStringTraceLog::SIGNATURE
            ? "OK"
            : stlHeader.m_Signature == CStringTraceLog::SIGNATURE_X
              ? "FREED"
              : "INVALID",
        tlogHeader.Signature,
        tlogHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : tlogHeader.Signature == TRACE_LOG_SIGNATURE_X
              ? "FREED"
              : "INVALID",
        tlogHeader.LogSize,
        tlogHeader.NextEntry,
        tlogHeader.EntrySize,
        tlogHeader.LogBuffer
        );

    if( tlogHeader.LogBuffer
        > ( (PUCHAR)stlHeader.m_ptlog + sizeof(tlogHeader) ) )
    {
        dprintf(
            "    Extra Data @ %p\n",
            (PVOID)( stlLogAddress + sizeof(tlogHeader) )
            );
    }

    if( stlHeader.m_Signature != CStringTraceLog::SIGNATURE &&
        stlHeader.m_Signature != CStringTraceLog::SIGNATURE_X ) {

        dprintf(
            "inetdbg.resetst: log @ %p has invalid signature %08lx:\n",
            (PVOID) stlLogAddress,
            stlHeader.m_Signature
            );

        return;

    }

    if( (UINT) tlogHeader.EntrySize
        != sizeof(CStringTraceLog::CLogEntry) - CStringTraceLog::MAX_CCH + stlHeader.m_cch ) {

        dprintf(
            "inetdbg.resetst: log @ %p is not a print trace log\n",
            (PVOID) stlLogAddress
            );

        return;

    }

    //
    // Reset it.
    //

    tlogHeader.NextEntry = -1;

    if( !WriteMemory(
            stlHeader.m_ptlog,
            &tlogHeader,
            sizeof(tlogHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg.resetst: cannot write memory @ %p\n",
            (PVOID) stlHeader.m_ptlog
            );

        return;

    }

    dprintf(
        "inetdbg.resetst: log @ %p reset\n",
        (PVOID) stlHeader.m_ptlog
        );

} // DECLARE_API( resetst )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\ref.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    ref.cxx

Abstract:

    This module contains the default ntsd debugger extensions for
    Internet Information Server.

Author:

    Keith Moore (keithmo) 27-Aug-1997

Revision History:

--*/

#include "inetdbgp.h"

//
// The maximum number of contexts that may be passed to the "ref"
// extension command on the command line.
//

#define MAX_REF_CONTEXT 64


/************************************************************
 * Dump Reference Traces
 ************************************************************/


BOOL
IsContextInList(
    IN PVOID Context,
    IN PVOID * ContextList,
    IN LONG NumContextsInList
    )

/*++

Routine Description:

    Scans the given context list looking for the specified context value.

Arguments:

    Context - The context value to look for.

    ContextList - The context list to scan.

    NumContextsInList - The number of contexts in the context list.

Return Value:

    BOOL - TRUE if the context value is in the list, FALSE if not.

--*/

{
    while( NumContextsInList > 0 ) {
        if( *ContextList == Context ) {
            return TRUE;
        }

        ContextList++;
        NumContextsInList--;
    }

    return FALSE;
}


VOID
DumpReferenceLog(
    IN PSTR lpArgumentString,
    IN BOOLEAN fReverse
    )

/*++

Routine Description:

    Dumps the specified reference log either forwards (fReverse == FALSE)
    or backwards (fReverse == TRUE).

Arguments:

    lpArgumentString - An expression specifying the reference log to
        dump.

    fReverse - The dump direction.

Return Value:

    None.

--*/

{
    ULONG_PTR refLogAddress = 0;
    ULONG_PTR entryAddress;
    LONG numEntries;
    TRACE_LOG logHeader;
    REF_TRACE_LOG_ENTRY logEntry;
    LONG i;
    DWORD_PTR offset;
    PCHAR format;
    PVOID specificContexts[MAX_REF_CONTEXT];
    LONG numSpecificContexts = 0;
    LONG index;
    LONG direction;
    PSTR cmdName;
    UCHAR symbol[MAX_SYMBOL_LEN];

    direction = fReverse ? -1 : 1;
    cmdName = fReverse ? "rref" : "ref";

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( cmdName );
        return;
    }

    refLogAddress = (ULONG_PTR)GetExpression( lpArgumentString );

    if( refLogAddress == 0 ) {

        dprintf(
            "inetdbg.%s: cannot evaluate \"%s\"\n",
            cmdName,
            lpArgumentString
            );

        return;

    }

    //
    // Skip to end of expression, then skip any blanks.
    //

    while( *lpArgumentString != ' ' &&
           *lpArgumentString != '\t' &&
           *lpArgumentString != '\0' ) {
        lpArgumentString++;
    }

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    //
    // If we have context values, use them.
    //

    while( *lpArgumentString != '\0' && numSpecificContexts < MAX_REF_CONTEXT ) {

        specificContexts[numSpecificContexts++] =
            (PVOID)GetExpression( lpArgumentString );

        while( *lpArgumentString != ' ' &&
               *lpArgumentString != '\t' &&
               *lpArgumentString != '\0' ) {
            lpArgumentString++;
        }

        while( *lpArgumentString == ' ' ||
               *lpArgumentString == '\t' ) {
            lpArgumentString++;
        }

    }

    //
    // Read the log header, perform some sanity checks.
    //

    if( !ReadMemory(
            refLogAddress,
            &logHeader,
            sizeof(logHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg.%s: cannot read memory @ %p\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    dprintf(
        "inetdbg.%s: log @ %p:\n"
        "    Signature = %08lx (%s)\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %lu\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %p\n",
        cmdName,
        (PVOID)refLogAddress,
        logHeader.Signature,
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
              ? "FREED"
              : "INVALID",
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.LogBuffer
        );

    if( logHeader.LogBuffer > ( (PUCHAR)refLogAddress + sizeof(logHeader) ) ) {
        dprintf(
            "    Extra Data @ %p\n",
            (PVOID)( refLogAddress + sizeof(logHeader) )
            );
    }

    if( logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X ) {

        dprintf(
            "inetdbg.%s: log @ %p has invalid signature %08lx:\n",
            cmdName,
            (PVOID)refLogAddress,
            logHeader.Signature
            );

        return;

    }

    if( logHeader.EntrySize != sizeof(logEntry) ) {

        dprintf(
            "inetdbg.%s: log @ %p is not a ref count log\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    if( logHeader.NextEntry == -1 ) {

        dprintf(
            "inetdbg.%s: empty log @ %p\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    //
    // Calculate the starting address and number of entries.
    //

    if( fReverse ) {
        if( logHeader.NextEntry < logHeader.LogSize ) {
            numEntries = logHeader.NextEntry + 1;
            index = logHeader.NextEntry;
        } else {
            numEntries = logHeader.LogSize;
            index = logHeader.NextEntry % logHeader.LogSize;
        }
    } else {
        if( logHeader.NextEntry < logHeader.LogSize ) {
            numEntries = logHeader.NextEntry + 1;
            index = 0;
        } else {
            numEntries = logHeader.LogSize;
            index = ( logHeader.NextEntry + 1 ) % logHeader.LogSize;
        }
    }

    entryAddress = (ULONG_PTR)logHeader.LogBuffer + (ULONG_PTR)( index * sizeof(logEntry) );

    if( entryAddress >=
        ( (ULONG_PTR)logHeader.LogBuffer + (ULONG_PTR)( numEntries * sizeof(logEntry) ) ) ) {

        dprintf(
            "inetdbg.%s: log @ %p has invalid data\n",
            cmdName,
            (PVOID)refLogAddress
            );

        return;

    }

    //
    // Dump the log.
    //

    for( ;
         numEntries > 0 ;
         index += direction,
         numEntries--,
         entryAddress += ( direction * sizeof(logEntry) ) ) {

        if( CheckControlC() ) {
            break;
        }

        if( index >= logHeader.LogSize ) {
            index = 0;
            entryAddress = (ULONG_PTR)logHeader.LogBuffer;
        } else if( index < 0 ) {
            index = logHeader.LogSize - 1;
            entryAddress = (ULONG_PTR)logHeader.LogBuffer + (ULONG_PTR)( index * sizeof(logEntry) );
        }

        if( !ReadMemory(
                entryAddress,
                &logEntry,
                sizeof(logEntry),
                NULL
                ) ) {

            dprintf(
                "inetdbg.%s: cannot read memory @ %p\n",
                cmdName,
                (ULONG_PTR)entryAddress
                );

            return;

        }

        if( ( numSpecificContexts == 0 ) ||
            IsContextInList(
                logEntry.Context,
                specificContexts,
                numSpecificContexts
                ) ) {

            dprintf(
                "\nThread = %08p, Context = %08p, NewRefCount = %-10ld : %ld\n",
                logEntry.Thread,
                logEntry.Context,
                logEntry.NewRefCount,
                index
                );

            if (    logEntry.Context1 != REF_TRACE_EMPTY_CONTEXT
                 || logEntry.Context2 != REF_TRACE_EMPTY_CONTEXT
                 || logEntry.Context3 != REF_TRACE_EMPTY_CONTEXT
                 ) {

                //
                //  if the caller passed extended context values,
                //  write them to the log
                //
                //  NOTE we use REF_TRACE_EMPTY_CONTEXT in all extended
                //  contexts as the signal that a caller does not use
                //  extended context - avoids spew for callers who don't care.
                //

                dprintf(
                    "Context1 = %08p, Context2 = %08p, Context3 = %08p\n",
                    logEntry.Context1,
                    logEntry.Context2,
                    logEntry.Context3
                    );
            }

            for( i = 0 ; i < REF_TRACE_LOG_STACK_DEPTH ; i++ ) {

                if( logEntry.Stack[i] == NULL ) {
                    break;
                }

                GetSymbol(
                    (ULONG_PTR) logEntry.Stack[i],
                    symbol,
                    &offset
                    );

                if( symbol[0] == '\0' ) {
                    format = "    %08p\n";
                } else
                if( offset == 0 ) {
                    format = "    %08p : %s\n";
                } else {
                    format = "    %08p : %s+0x%lx\n";
                }

                dprintf(
                    format,
                    logEntry.Stack[i],
                    symbol,
                    offset
                    );

            }

        }

    }

} // DumpReferenceLog


DECLARE_API( ref )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a reference trace log.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    INIT_API();
    DumpReferenceLog( lpArgumentString, FALSE );

} // DECLARE_API( ref )


DECLARE_API( rref )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a reference trace log backwards.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    INIT_API();
    DumpReferenceLog( lpArgumentString, TRUE );

} // DECLARE_API( rref )


DECLARE_API( resetref )

/*++

Routine Description:

    This function is called as an NTSD extension to reset a reference
    trace log back to its initial state.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{
    ULONG_PTR refLogAddress = 0;
    TRACE_LOG logHeader;

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {
        PrintUsage( "resetref" );
        return;
    }

    refLogAddress = GetExpression( lpArgumentString );

    if( refLogAddress == 0 ) {

        dprintf(
            "inetdbg.resetref: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the log header, perform some sanity checks.
    //

    if( !ReadMemory(
            refLogAddress,
            &logHeader,
            sizeof(logHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg.resetref: cannot read memory @ %p\n",
            refLogAddress
            );

        return;

    }

    dprintf(
        "inetdbg.resetref: log @ %p:\n"
        "    Signature = %08lx (%s)\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %lu\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %08lp\n",
        (PVOID) refLogAddress,
        logHeader.Signature,
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
              ? "FREED"
              : "INVALID",
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.LogBuffer
        );

    if( logHeader.LogBuffer > ( (PUCHAR)refLogAddress + sizeof(logHeader) ) ) {
        dprintf(
            "    Extra Data @ %08p\n",
            (PVOID) (refLogAddress + sizeof(logHeader))
            );
    }

    if( logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X ) {

        dprintf(
            "inetdbg.resetref: log @ %p has invalid signature %08lx:\n",
            (PVOID) refLogAddress,
            logHeader.Signature
            );

        return;

    }

    if( logHeader.EntrySize != sizeof(REF_TRACE_LOG_ENTRY) ) {

        dprintf(
            "inetdbg.resetref: log @ %p is not a ref count log\n",
            (PVOID) refLogAddress
            );

        return;

    }

    //
    // Reset it.
    //

    logHeader.NextEntry = -1;

    if( !WriteMemory(
            refLogAddress,
            &logHeader,
            sizeof(logHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg.resetref: cannot write memory @ %p\n",
            (PVOID) refLogAddress
            );

        return;

    }

    dprintf(
        "inetdbg.resetref: log @ %p reset\n",
        (PVOID) refLogAddress
        );

} // DECLARE_API( resetref )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\template.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    template.cxx

Abstract:

    This is just a template for creating new NTSD extension commands.

Author:

    Keith Moore (keithmo) 12-Nov-1997

Revision History:

--*/

#include "inetdbgp.h"


// Don't forget to add 'template' to inetdbg.def

DECLARE_API( template )

/*++

Routine Description:

    This function is called as an NTSD extension to ...

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        //
        // ???
        //

    } else {

        //
        // ???
        //

    }

}   // DECLARE_API( template )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\ver.cxx ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    ver.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping module
    version resources.

Author:

    Keith Moore (keithmo) 16-Sep-1997

Revision History:

--*/

#include "inetdbgp.h"

PSTR VersionLabels[] =
     {
         "CompanyName",
         "FileDescription",
         "FileVersion",
         "InternalName",
         "LegalCopyright",
         "OriginalFilename",
         "ProductName",
         "ProductVersion"
     };
#define NUM_LABELS ( sizeof(VersionLabels) / sizeof(VersionLabels[0]) )

typedef struct _ENUM_CONTEXT {
    PSTR ModuleName;
    INT NameLength;
} ENUM_CONTEXT, *PENUM_CONTEXT;


/************************************************************
 * Dump File Version Info
 ************************************************************/

PIMAGE_RESOURCE_DIRECTORY
FindResourceDir(
    IN PIMAGE_RESOURCE_DIRECTORY BaseResourceDir,
    IN PIMAGE_RESOURCE_DIRECTORY TargetResourceDir,
    IN USHORT ResourceId
    )

/*++

Routine Description:

    Finds the specified resource directory.

Arguments:

    BaseResourceDir - The (remote) address of the *start* of the resource
        section.

    TargetResourceDir - The (remote) address of the resource directory
        to search.

    ResourceId - The resource ID we're looking for.

Return Value:

    PIMAGE_RESOURCE_DIRECTORY - Pointer to the resource directory
        corresponding to ResourceId if successful, NULL otherwise.

--*/

{

    IMAGE_RESOURCE_DIRECTORY localDir;
    IMAGE_RESOURCE_DIRECTORY_ENTRY localEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY remoteEntry;
    USHORT i;

    //
    // Read the target resource directory.
    //

    if( !ReadMemory(
            (ULONG_PTR)TargetResourceDir,
            &localDir,
            sizeof(localDir),
            NULL
            ) ) {
        return NULL;
    }

    //
    // Scan it.
    //

    remoteEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( TargetResourceDir + 1 );

    for( i = localDir.NumberOfNamedEntries + localDir.NumberOfIdEntries ;
         i > 0 ;
         i--, remoteEntry++ ) {

        //
        // Read the directory entry.
        //

        if( !ReadMemory(
                (ULONG_PTR)remoteEntry,
                &localEntry,
                sizeof(localEntry),
                NULL
                ) ) {
            return NULL;
        }

        //
        // If the entry is a directory and the IDs match, then return it.
        //

        if( localEntry.DataIsDirectory == 0 ) {
            continue;
        }

        if( localEntry.NameIsString == 0 &&
            localEntry.Id == ResourceId ) {

            return (PIMAGE_RESOURCE_DIRECTORY)
                       ( (ULONG_PTR)BaseResourceDir + localEntry.OffsetToDirectory );

        }

    }

    return NULL;

}   // FindResourceDir

PIMAGE_RESOURCE_DATA_ENTRY
FindResourceData(
    IN PIMAGE_RESOURCE_DIRECTORY BaseResourceDir,
    IN PIMAGE_RESOURCE_DIRECTORY TargetResourceDir,
    IN USHORT ResourceId
    )

/*++

Routine Description:

    Finds the specified resource data item.

Arguments:

    BaseResourceDir - The (remote) address of the *start* of the resource
        section.

    TargetResourceDir - The (remote) address of the resource directory
        to search.

    ResourceId - The resource ID we're looking for. This may be zero
        to return any resource.

Return Value:

    PIMAGE_RESOURCE_DATA_ENTRY - Pointer to the resource data entry
        corresponding to ResourceId if successful, NULL otherwise.

--*/

{

    IMAGE_RESOURCE_DIRECTORY localDir;
    IMAGE_RESOURCE_DIRECTORY_ENTRY localEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY remoteEntry;
    USHORT i;

    //
    // Read the target resource directory.
    //

    if( !ReadMemory(
            (ULONG_PTR)TargetResourceDir,
            &localDir,
            sizeof(localDir),
            NULL
            ) ) {
        return NULL;
    }

    //
    // Scan it.
    //

    remoteEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)( TargetResourceDir + 1 );

    for( i = localDir.NumberOfNamedEntries + localDir.NumberOfIdEntries ;
         i > 0 ;
         i--, remoteEntry++ ) {

        //
        // Read the directory entry.
        //

        if( !ReadMemory(
                (ULONG_PTR)remoteEntry,
                &localEntry,
                sizeof(localEntry),
                NULL
                ) ) {
            return NULL;
        }

        //
        // If the entry is not a directory and the IDs match (or the
        // requested ID is zero, meaning any ID) then return it.
        //

        if( localEntry.DataIsDirectory != 0 ) {
            continue;
        }

        if( localEntry.NameIsString == 0 &&
            ( localEntry.Id == ResourceId ||
              ResourceId == 0 ) ) {

            return (PIMAGE_RESOURCE_DATA_ENTRY)
                       ( (ULONG_PTR)BaseResourceDir + localEntry.OffsetToDirectory );

        }

    }

    return NULL;

}   // FindResourceData


BOOL
DumpVersionResource(
    IN PVOID VersionResource
    )

/*++

Routine Description:

    Dumps a version resource block.

Arguments:

    VersionResource - The version resource to dump.

Return Value:

    BOOL - TRUE if successful, FALSE if the version resource block
        was corrupt or unreadable.

--*/

{

    ULONG charSet;
    LPVOID version;
    UINT versionLength;
    INT i;
    VS_FIXEDFILEINFO * fixedFileInfo;
    CHAR label[MAX_PATH];

    //
    // Get the language/character-set pair.
    //

    if( !VerQueryValueA(
            VersionResource,
            "\\VarFileInfo\\Translation",
            &version,
            &versionLength
            ) ) {
        return FALSE;
    }

    charSet = *(LPDWORD)version;
    charSet = (DWORD)MAKELONG( HIWORD(charSet), LOWORD(charSet) );

    //
    // Get the root block so we can determine if this is a free or
    // checked build.
    //

    if( !VerQueryValue(
             VersionResource,
             "\\",
             &version,
             &versionLength
             ) ) {
        return FALSE;
    }

    fixedFileInfo = (VS_FIXEDFILEINFO *)version;

    dprintf(
        "%-19s = 0x%08lx (%s)\n",
        "dwFileFlags",
        fixedFileInfo->dwFileFlags,
        ( ( fixedFileInfo->dwFileFlags & VS_FF_DEBUG ) != 0 )
            ? "CHECKED"
            : "FREE"
        );

    //
    // Dump the various version strings.
    //

    for( i = 0 ; i < NUM_LABELS ; i++ ) {

        wsprintfA(
            label,
            "\\StringFileInfo\\%08lX\\%s",
            charSet,
            VersionLabels[i]
            );

        if( VerQueryValue(
                VersionResource,
                label,
                &version,
                &versionLength
                ) ) {
            dprintf(
                "%-19s = %s\n",
                VersionLabels[i],
                version
                );
        }

    }

    dprintf( "\n" );

    return TRUE;

}   // DumpVersionResource


VOID
FindAndDumpVersionResourceByAddress(
    IN ULONG_PTR ModuleAddress,
    IN PSTR ModuleName
    )

/*++

Routine Description:

    Locates and dumps the version resource for the module based at
    the specified address.

Arguments:

    ModuleAddress - The base address of the module to dump.

    ModuleName - The module name, for display purposes.

Return Value:

    None.

--*/

{

    IMAGE_DOS_HEADER dosHeader;
    IMAGE_NT_HEADERS ntHeaders;
    PIMAGE_OPTIONAL_HEADER optionalHeader;
    PIMAGE_DATA_DIRECTORY dataDir;
    PIMAGE_RESOURCE_DIRECTORY baseResourceDir;
    PIMAGE_RESOURCE_DIRECTORY tmpResourceDir;
    PIMAGE_RESOURCE_DATA_ENTRY dataEntry;
    IMAGE_RESOURCE_DATA_ENTRY localDataEntry;
    PVOID versionResource;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    versionResource = NULL;

    //
    // Read & validate the image headers.
    //

    if( !ReadMemory(
            ModuleAddress,
            &dosHeader,
            sizeof(dosHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg.ver: cannot read DOS header @ 0x%p\n",
            ModuleAddress
            );

        goto cleanup;

    }

    if( dosHeader.e_magic != IMAGE_DOS_SIGNATURE ) {

        dprintf(
            "inetdbg.ver: module @ 0x%p has invalid DOS header\n",
            ModuleAddress
            );

        goto cleanup;

    }

    if( !ReadMemory(
            ModuleAddress + dosHeader.e_lfanew,
            &ntHeaders,
            sizeof(ntHeaders),
            NULL
            ) ) {

        dprintf(
            "inetdbg.ver: cannot read NT headers @ 0x%p\n",
            ModuleAddress
            );

        goto cleanup;

    }

    if( ntHeaders.Signature != IMAGE_NT_SIGNATURE ) {

        dprintf(
            "inetdbg.ver: module @ 0x%p has invalid NT headers\n",
            ModuleAddress
            );

        goto cleanup;

    }

    optionalHeader = &ntHeaders.OptionalHeader;

    if( optionalHeader->Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC ) {

        dprintf(
            "inetdbg.ver: module @ 0x%p has invalid optional header\n",
            ModuleAddress
            );

        goto cleanup;

    }

    //
    // Locate the resource.
    //

    dataDir = &optionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE];

    if( dataDir->VirtualAddress == 0 ||
        dataDir->Size == 0 ) {

        dprintf(
            "inetdbg.ver: module @ 0x%p has no resource information\n",
            ModuleAddress
            );

        goto cleanup;

    }

    baseResourceDir = (PIMAGE_RESOURCE_DIRECTORY)
                          ( ModuleAddress + dataDir->VirtualAddress );

    //
    // Now go and find the resource in the image. Since resources are
    // stored heirarchally, we're basically for the resource path:
    //
    //     VS_FILE_INFO\VS_VERSION_INFO\LanguageId
    //
    // For the language ID, we'll first try 0x409 (English) and if
    // that fails, we'll take any language.
    //

    dataEntry = NULL;

    tmpResourceDir = FindResourceDir(
                         baseResourceDir,
                         baseResourceDir,
                         (USHORT)VS_FILE_INFO
                         );

    if( tmpResourceDir != NULL ) {

        tmpResourceDir = FindResourceDir(
                             baseResourceDir,
                             tmpResourceDir,
                             (USHORT)VS_VERSION_INFO
                             );

        if( tmpResourceDir != NULL ) {

            dataEntry = FindResourceData(
                            baseResourceDir,
                            tmpResourceDir,
                            0x409
                            );

            if( dataEntry == NULL ) {

                dataEntry = FindResourceData(
                                baseResourceDir,
                                tmpResourceDir,
                                0
                                );

            }

        }

    }

    if( dataEntry == NULL ) {

        dprintf(
            "inetdbg.ver: cannot find version resource\n"
            );

        goto cleanup;

    }

    //
    // Actually read the dir entry.
    //

    if( !ReadMemory(
            (ULONG_PTR)dataEntry,
            &localDataEntry,
            sizeof(localDataEntry),
            NULL
            ) ) {

        dprintf(
            "inetdbg.ver: error reading resource\n"
            );

        goto cleanup;

    }

    //
    // Now we can allocate & read the resource.
    //

    versionResource = malloc( localDataEntry.Size );

    if( versionResource == NULL ) {

        dprintf(
            "inetdbg.ver: not enough memory\n"
            );

        goto cleanup;

    }

    if( !ReadMemory(
            ModuleAddress + localDataEntry.OffsetToData,
            versionResource,
            localDataEntry.Size,
            NULL
            ) ) {

        dprintf(
            "inetdbg.ver: error reading resource\n"
            );

        goto cleanup;

    }

    //
    // Dump it.
    //

    dprintf(
        "Module @ 0x%p = %s\n",
        ModuleAddress,
        ModuleName
        );

    if( !DumpVersionResource( versionResource ) ) {

        dprintf(
            "Cannot interpret version resource\n"
            );

        goto cleanup;

    }

cleanup:

    if( versionResource != NULL ) {
        free( versionResource );
    }

}   // FindAndDumpVersionResourceByAddress


BOOLEAN
CALLBACK
VerpEnumProc(
    IN PVOID Param,
    IN PMODULE_INFO ModuleInfo
    )
{

    PENUM_CONTEXT context;
    INT baseNameLength;

    context = (PENUM_CONTEXT)Param;
    baseNameLength = strlen( ModuleInfo->BaseName );

    //
    // If the user wants all modules, or if the specified module matches
    // the "tail" of the module name, dump it.
    //

    if( context->ModuleName == NULL ||
        ( baseNameLength >= context->NameLength &&
          !_stricmp(
              context->ModuleName,
              ModuleInfo->BaseName + baseNameLength - context->NameLength
              ) ) ) {

        FindAndDumpVersionResourceByAddress(
            ModuleInfo->DllBase,
            ModuleInfo->BaseName
            );

    }

    return TRUE;

}   // VerpEnumProc


VOID
FindAndDumpVersionResourceByName(
    IN PSTR ModuleName
    )

/*++

Routine Description:

    Locates and dumps the version resource for the specified module.

Arguments:

    ModuleName - The name of the module to dump. If this is NULL then
        all modules are dumped.

Return Value:

    None.

--*/

{

    ENUM_CONTEXT context;

    context.ModuleName = ModuleName;

    if( ModuleName == NULL ) {
        context.NameLength = 0;
    } else {
        context.NameLength = strlen( ModuleName );
    }

    if( !EnumModules(
            VerpEnumProc,
            (PVOID)&context
            ) ) {
        dprintf( "error retrieving module list\n" );
    }

}   // FindAndDumpVersionResourceByName


DECLARE_API( ver )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    module version info.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG module;
    PSTR endPointer;

    INIT_API();

    //
    // Skip leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        //
        // No argument passed, dump all modules.
        //

        FindAndDumpVersionResourceByName( NULL );

    } else {

        module = strtoul( lpArgumentString, &endPointer, 16 );

        if( *endPointer != ' ' && *endPointer != '\t' && *endPointer != '\0' ) {

            //
            // Assume the argument is actually a module name, not
            // a base address.
            //

            FindAndDumpVersionResourceByName( lpArgumentString );

        } else {

            FindAndDumpVersionResourceByAddress( module, NULL );

        }

    }

}   // DECLARE_API( ver )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\oplock\fcache.cxx ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    fcache.cxx

Abstract:

    This module contains the cache-related ntsd debugger extensions for
    Internet Information Server

Author:

    Keith Moore (keithmo)         12-Aug-1997

Revision History:

--*/


#include "inetdbgp.h"


//
// Worker routines.
//


PSTR
DemuxToString(
    IN ULONG Demux
    )

/*++

Routine Description:

    Converts the specified demux value to a printable string.

Arguments:

    Demux - The demux value to map.

Return Value:

    PSTR - The printable string.

--*/

{

    switch( Demux ) {
    case RESERVED_DEMUX_START :
        return "RESERVED_DEMUX_START";

    case RESERVED_DEMUX_DIRECTORY_LISTING :
        return "RESERVED_DEMUX_DIRECTORY_LISTING";

    case RESERVED_DEMUX_ATOMIC_DIRECTORY_GUARD :
        return "RESERVED_DEMUX_ATOMIC_DIRECTORY_GUARD";

    case RESERVED_DEMUX_OPEN_FILE :
        return "RESERVED_DEMUX_OPEN_FILE";

    case RESERVED_DEMUX_URI_INFO :
        return "RESERVED_DEMUX_URI_INFO";

    case RESERVED_DEMUX_PHYSICAL_OPEN_FILE :
        return "RESERVED_DEMUX_PHYSICAL_OPEN_FILE";

    default :
        return "Unknown";
    }

}   // DemuxToString


PSTR
SignatureToString(
    IN DWORD CurrentSignature,
    IN DWORD ValidSignature,
    IN DWORD FreedSignature
    )

/*++

Routine Description:

    Determines an appropriate display string for the given signature.
    If the current signature matches the expected valid signature,
    then the string "OK" is returned. If the current signature matches
    the freed signature, then "FREED" is returned. Otherwise, "INVALID"
    is returned.

Arguments:

    CurrentSignature - The current signature as retrieved from the
        object/structure.

    ValidSignature - The expected signature for a valid, in-use
        object/structure.

    FreedSignature - The signature assigned to the object/structure
        just before it is freed.

Return Value:

    PSTR - "OK", "FREED", or "INVALID" as appropriate.

--*/

{

    if( CurrentSignature == ValidSignature ) {
        return "OK";
    }

    if( CurrentSignature == FreedSignature ) {
        return "FREED";
    }

    return "INVALID";

}   // SignatureToString


PSTR
BoolToString(
    IN BOOL Flag
    )

/*++

Routine Description:

    Maps the given BOOL to a displayable string.

Arguments:

    Flag - The BOOL flag to map.

Return Value:

    PSTR - "TRUE", "FALSE", or "INVALID" as appropriate.

--*/

{

    //
    // In general, explicit testing for TRUE is a Bad Thing, but in
    // this case, it's useful for catching invalid data.
    //

    if( Flag == TRUE ) {
        return "TRUE";
    }

    if( Flag == FALSE ) {
        return "FALSE";
    }

    return "INVALID";

}   // BoolToString


VOID
DumpBlobHeader(
    IN PSTR Prefix,
    IN PBLOB_HEADER BlobHeader,
    IN ULONG ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a specific BLOB_HEADER structure.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    BlobHeader - Points to a local copy of the structure.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    ULONG offset;
    UCHAR symbol[MAX_PATH];
    CHAR renderedSymbol[MAX_PATH];

    GetSymbol(
        (PVOID)BlobHeader->pfnFreeRoutine,
        symbol,
        &offset
        );

    if( symbol[0] == '\0' ) {
        renderedSymbol[0] = '\0';
    } else if( offset == 0 ) {
        sprintf(
            renderedSymbol,
            " (%s)",
            symbol
            );
    } else {
        sprintf(
            renderedSymbol,
            " (%s+0x%lx)",
            symbol,
            offset
            );
    }

    dprintf(
        "%sBLOB_HEADER @ %08lx\n"
        "%s    IsCached       = %s\n"
        "%s    pCache         = %08lx\n"
        "%s    PFList         @ %08lx%s\n"
        "%s    pfnFreeRoutine = %08lx%s\n"
        "\n",
        Prefix,
        ActualAddress,
        Prefix,
        BoolToString( BlobHeader->IsCached ),
        Prefix,
        BlobHeader->pCache,
        Prefix,
        ActualAddress + FIELD_OFFSET( BLOB_HEADER, PFList ),
        IS_LIST_EMPTY( BlobHeader, ActualAddress, BLOB_HEADER, PFList )
            ? " (EMPTY)"
            : "",
        Prefix,
        BlobHeader->pfnFreeRoutine,
        renderedSymbol
        );

}   // DumpBlobHeader


VOID
DumpOpenFileInfo(
    IN PSTR Prefix,
    IN LPTS_OPEN_FILE_INFO OpenFileInfo,
    IN ULONG ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a specific TS_OPEN_FILE_INFO structure.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    OpenFileInfo - Points to a local copy of the structure.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    dprintf(
        "%sTS_OPEN_FILE_INFO @ %08lx\n"
        "%s    m_hOpeningUser           = %08lx\n"
        "%s    m_PhysFileInfo           = %08lx\n"
        "%s    m_FileInfo               @ %08lx\n"
        "%s    m_CastratedLastWriteTime @ %08lx\n",
        Prefix,
        ActualAddress,
        Prefix,
        OpenFileInfo->m_hOpeningUser,
        Prefix,
        OpenFileInfo->m_PhysFileInfo,
        Prefix,
        ActualAddress + FIELD_OFFSET( TS_OPEN_FILE_INFO, m_FileInfo ),
        Prefix,
        ActualAddress + FIELD_OFFSET( TS_OPEN_FILE_INFO, m_CastratedLastWriteTime )
        );

    dprintf(
        "%s    m_achHttpInfo            @ %08lx (%s)\n"
        "%s    m_cchHttpInfo            = %lu\n"
        "%s    m_achETag                @ %08lx (%s)\n"
        "%s    m_cchETag                = %lu\n"
        "%s    m_ETagIsWeak             = %s\n"
        "%s    m_fIsCached              = %s\n"
        "\n",
        Prefix,
        ActualAddress + FIELD_OFFSET( TS_OPEN_FILE_INFO, m_achHttpInfo ),
        OpenFileInfo->m_achHttpInfo,
        Prefix,
        OpenFileInfo->m_cchHttpInfo,
        Prefix,
        ActualAddress + FIELD_OFFSET( TS_OPEN_FILE_INFO, m_achETag ),
        OpenFileInfo->m_achETag,
        Prefix,
        OpenFileInfo->m_cchETag,
        Prefix,
        BoolToString( OpenFileInfo->m_ETagIsWeak ),
        Prefix,
        BoolToString( OpenFileInfo->m_fIsCached )
        );

}   // DumpOpenFileInfo


VOID
DumpUriInfo(
    IN PSTR Prefix,
    IN PW3_URI_INFO UriInfo,
    IN ULONG ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a specific W3_URI_INFO structure.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    UriInfo - Points to a local copy of the structure.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    CHAR name[MAX_PATH];
    CHAR unmappedName[MAX_PATH];

    if( UriInfo->pszName == NULL ) {
        strcpy( name, "<null>" );
    } else if( !ReadMemory(
            (ULONG)UriInfo->pszName,
            name,
            sizeof(name),
            NULL
            ) ) {
        strcpy( name, "<unreadable>" );
    }

    if( UriInfo->pszUnmappedName == NULL ) {
        strcpy( unmappedName, "<null>" );
    } else if( !ReadMemory(
            (ULONG)UriInfo->pszUnmappedName,
            unmappedName,
            sizeof(unmappedName),
            NULL
            ) ) {
        strcpy( unmappedName, "<unreadable>" );
    }

    dprintf(
        "%sW3_URI_INFO @ %08lx\n"
        "%s    bFileInfoValid  = %lu\n"
        "%s    bIsCached       = %s\n"
        "%s    hFileEvent      = %08lx\n"
        "%s    pOpenFileInfo   = %08lx\n",
        Prefix,
        ActualAddress,
        Prefix,
        UriInfo->bFileInfoValid,
        Prefix,
        BoolToString( UriInfo->bIsCached ),
        Prefix,
        UriInfo->hFileEvent,
        Prefix,
        UriInfo->pOpenFileInfo
        );

    dprintf(
        "%s    dwFileOpenError = %lu\n"
        "%s    cchName         = %lu\n"
        "%s    pszName         = %08lx (%s)\n"
        "%s    pszUnmappedName = %08lx (%s)\n"
        "%s    pMetaData       = %08lx\n"
        "\n",
        Prefix,
        UriInfo->dwFileOpenError,
        Prefix,
        UriInfo->cchName,
        Prefix,
        UriInfo->pszName,
        name,
        Prefix,
        UriInfo->pszUnmappedName,
        unmappedName,
        Prefix,
        UriInfo->pMetaData
        );

}   // DumpUriInfo


VOID
DumpPhysOpenFileInfo(
    IN PSTR Prefix,
    IN PPHYS_OPEN_FILE_INFO PhysOpenFileInfo,
    IN ULONG ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a specific PHYS_OPEN_FILE_INFO structure.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    PhysOpenFileInfo - Points to a local copy of the structure.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    dprintf(
        "%sPHYS_OPEN_FILE_INFO @ %08lx\n"
        "%s    Signature            = %08lx (%s)\n"
        "%s    hOpenFile            = %08lx\n"
        "%s    hOpenEvent           = %08lx\n",
        Prefix,
        ActualAddress,
        Prefix,
        PhysOpenFileInfo->Signature,
        SignatureToString(
            PhysOpenFileInfo->Signature,
            PHYS_OBJ_SIGNATURE,
            PHYS_OBJ_SIGNATURE_X
            ),
        Prefix,
        PhysOpenFileInfo->hOpenFile,
        Prefix,
        PhysOpenFileInfo->hOpenEvent
        );

    dprintf(
        "%s    OpenReferenceList    @ %08lx%s\n"
        "%s    fSecurityDescriptor  = %s\n"
        "%s    fIsCached            = %s\n",
        Prefix,
        ActualAddress + FIELD_OFFSET( PHYS_OPEN_FILE_INFO, OpenReferenceList ),
        IS_LIST_EMPTY( PhysOpenFileInfo, ActualAddress, PHYS_OPEN_FILE_INFO, OpenReferenceList )
            ? " (EMPTY)"
            : "",
        Prefix,
        BoolToString( PhysOpenFileInfo->fSecurityDescriptor ),
        Prefix,
        BoolToString( PhysOpenFileInfo->fIsCached )
        );

    dprintf(
        "%s    dwLastError          = %lu\n"
        "%s    cbSecDescMaxSize     = %lu\n"
        "%s    abSecurityDescriptor = %08lx\n"
        "%s    pOplock              = %08lx\n"
        "\n",
        Prefix,
        PhysOpenFileInfo->dwLastError,
        Prefix,
        PhysOpenFileInfo->cbSecDescMaxSize,
        Prefix,
        PhysOpenFileInfo->abSecurityDescriptor,
        Prefix,
        PhysOpenFileInfo->pOplock
        );

}   // DumpPhysOpenFileInfo


VOID
DumpOplockObject(
    IN PSTR Prefix,
    IN POPLOCK_OBJECT OplockObject,
    IN ULONG ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a specific OPLOCK_OBJECT structure.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    OplockObject - Points to a local copy of the structure.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    dprintf(
        "%sOPLOCK_OBJECT @ %08lx\n"
        "%s    Signature           = %08lx (%s)\n"
        "%s    lpPFInfo            = %08lx\n"
        "%s    hOplockInitComplete = %08lx\n"
        "\n",
        Prefix,
        ActualAddress,
        Prefix,
        OplockObject->Signature,
        SignatureToString(
            OplockObject->Signature,
            OPLOCK_OBJ_SIGNATURE,
            OPLOCK_OBJ_SIGNATURE_X
            ),
        Prefix,
        OplockObject->lpPFInfo,
        Prefix,
        OplockObject->hOplockInitComplete
        );

}   // DumpOplockObject


VOID
DumpOpenFileInfoBlob(
    IN PSTR Prefix,
    IN PBLOB_HEADER BlobHeader,
    IN ULONG ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a TS_OPEN_FILE_INFO blob.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    BlobHeader - Points to a local copy of the blob.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    TS_OPEN_FILE_INFO localOpenFileInfo;

    if( !ReadMemory(
            ActualAddress + sizeof(*BlobHeader),
            &localOpenFileInfo,
            sizeof(localOpenFileInfo),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read TS_OPEN_FILE_INFO @ %08lx\n",
            ActualAddress + sizeof(*BlobHeader)
            );

        return;

    }

    DumpBlobHeader(
        Prefix,
        BlobHeader,
        ActualAddress
        );

    DumpOpenFileInfo(
        Prefix,
        &localOpenFileInfo,
        ActualAddress + sizeof(*BlobHeader)
        );

}   // DumpOpenFileInfoBlob


VOID
DumpUriInfoBlob(
    IN PSTR Prefix,
    IN PBLOB_HEADER BlobHeader,
    IN ULONG ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a W3_URI_INFO blob.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    BlobHeader - Points to a local copy of the blob.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    W3_URI_INFO localUriInfo;

    if( !ReadMemory(
            ActualAddress + sizeof(*BlobHeader),
            &localUriInfo,
            sizeof(localUriInfo),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read W3_URI_INFO @ %08lx\n",
            ActualAddress + sizeof(*BlobHeader)
            );

        return;

    }

    DumpBlobHeader(
        Prefix,
        BlobHeader,
        ActualAddress
        );

    DumpUriInfo(
        Prefix,
        &localUriInfo,
        ActualAddress + sizeof(*BlobHeader)
        );

}   // DumpUriInfoBlob


VOID
DumpPhysOpenFileInfoBlob(
    IN PSTR Prefix,
    IN PBLOB_HEADER BlobHeader,
    IN ULONG ActualAddress
    )

/*++

Routine Description:

    Formats and dumps a PHYS_OPEN_FILE_INFO blob.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    BlobHeader - Points to a local copy of the blob.

    ActualAddress - The virtual address of the object in the debugee.

Return Value:

    None.

--*/

{

    PHYS_OPEN_FILE_INFO localPhysOpenFileInfo;

    if( !ReadMemory(
            ActualAddress + sizeof(*BlobHeader),
            &localPhysOpenFileInfo,
            sizeof(localPhysOpenFileInfo),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read PHYS_OPEN_FILE_INFO @ %08lx\n",
            ActualAddress + sizeof(*BlobHeader)
            );

        return;

    }

    DumpBlobHeader(
        Prefix,
        BlobHeader,
        ActualAddress
        );

    DumpPhysOpenFileInfo(
        Prefix,
        &localPhysOpenFileInfo,
        ActualAddress + sizeof(*BlobHeader)
        );

}   // DumpPhysOpenFileInfo


VOID
DumpCacheObject(
    IN PSTR Prefix,
    IN PCACHE_OBJECT CacheObject,
    IN ULONG ActualAddress,
    IN BOOLEAN Verbose
    )

/*++

Routine Description:

    Formats and dumps a specific CACHE_OBJECT structure.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    CacheObject - Points to a local copy of the structure.

    ActualAddress - The virtual address of the object in the debugee.

    Verbose - If TRUE, then also dumps the blob associated with the object.

Return Value:

    None.

--*/

{

    BLOB_HEADER localBlob;
    CHAR path[MAX_PATH+1];

    path[0] = '\0';

    if( CacheObject->cchLength < MAX_PATH ) {
        ReadMemory(
            ActualAddress + FIELD_OFFSET( CACHE_OBJECT, szPath ),
            path,
            CacheObject->cchLength,
            NULL
            );
        path[CacheObject->cchLength] = '\0';
    }

    dprintf(
        "%sCACHE_OBJECT @ %08lx\n"
        "%s    Signature               = %08lx (%s)\n"
        "%s    BinList                 @ %08lx%s\n"
        "%s    MruList                 @ %08lx%s\n"
        "%s    DirChangeList           @ %08lx%s\n",
        Prefix,
        ActualAddress,
        Prefix,
        CacheObject->Signature,
        SignatureToString(
            CacheObject->Signature,
            CACHE_OBJ_SIGNATURE,
            CACHE_OBJ_SIGNATURE_X
            ),
        Prefix,
        ActualAddress + FIELD_OFFSET( CACHE_OBJECT, BinList ),
        IS_LIST_EMPTY( CacheObject, ActualAddress, CACHE_OBJECT, BinList )
            ? " (EMPTY)"
            : "",
        Prefix,
        ActualAddress + FIELD_OFFSET( CACHE_OBJECT, MruList ),
        IS_LIST_EMPTY( CacheObject, ActualAddress, CACHE_OBJECT, MruList )
            ? " (EMPTY)"
            : "",
        Prefix,
        ActualAddress + FIELD_OFFSET( CACHE_OBJECT, DirChangeList ),
        IS_LIST_EMPTY( CacheObject, ActualAddress, CACHE_OBJECT, DirChangeList )
            ? " (EMPTY)"
            : ""
        );

    dprintf(
        "%s    pbhBlob                 = %08lx\n"
        "%s    references              = %lu\n"
        "%s    TTL                     = %lu\n"
        "%s    hash                    = %08lx\n",
        Prefix,
        CacheObject->pbhBlob,
        Prefix,
        CacheObject->references,
        Prefix,
        CacheObject->TTL,
        Prefix,
        CacheObject->hash
        );

    dprintf(
        "%s    cchLength               = %lu\n"
        "%s    iDemux                  = %08lx (%s)\n"
        "%s    dwService               = %08lx\n"
        "%s    dwInstance              = %08lx\n",
        Prefix,
        CacheObject->cchLength,
        Prefix,
        CacheObject->iDemux,
        DemuxToString( CacheObject->iDemux ),
        Prefix,
        CacheObject->dwService,
        Prefix,
        CacheObject->dwInstance
        );

    dprintf(
        "%s    pSecDesc                = %08lx\n"
        "%s    hLastSuccessAccessToken = %08lx\n"
        "%s    fZombie                 = %s\n"
        "%s    szPath                  = %s\n"
        "\n",
        Prefix,
        CacheObject->pSecDesc,
        Prefix,
        CacheObject->hLastSuccessAccessToken,
        Prefix,
        BoolToString( CacheObject->fZombie ),
        Prefix,
        path
        );

    if( Verbose ) {
        CHAR prefix[80];

        sprintf(
            prefix,
            "    %s",
            Prefix
            );

        if( !ReadMemory(
                (ULONG)CacheObject->pbhBlob,
                &localBlob,
                sizeof(localBlob),
                NULL
                ) ) {

            dprintf(
                "inetdbg: cannot read blob header @ %08lx\n",
                CacheObject->pbhBlob
                );

            return;

        }

        switch( CacheObject->iDemux ) {
        case RESERVED_DEMUX_OPEN_FILE :
            DumpOpenFileInfoBlob(
                prefix,
                &localBlob,
                (ULONG)CacheObject->pbhBlob
                );
            break;

        case RESERVED_DEMUX_URI_INFO :
            DumpUriInfoBlob(
                prefix,
                &localBlob,
                (ULONG)CacheObject->pbhBlob
                );
            break;

        case RESERVED_DEMUX_PHYSICAL_OPEN_FILE :
            DumpPhysOpenFileInfoBlob(
                prefix,
                &localBlob,
                (ULONG)CacheObject->pbhBlob
                );
            break;
        }
    }

}   // DumpCacheObject


VOID
DumpCacheObjectList(
    IN PSTR ListName,
    IN PLIST_ENTRY LocalListHead,
    IN PLIST_ENTRY RemoteListHead,
    IN BOOLEAN MruList,
    IN BOOLEAN Verbose
    )

/*++

Routine Description:

    Formats and dumps a linked list of CACHE_OBJECTs.

Arguments:

    Prefix - The prefix to use before each printed line. This makes
        hierarchical object displays much prettier.

    LocalListHead - Points to a local copy of the linked list head.

    RemoteListHead - The virtual address of the linked list head in
        the debugee.

    MruList - TRUE if we're dumping the Mru list, FALSE if we're
        dumping the Bin list.

    Verbose - If TRUE, then be verbose.

Return Value:

    None.

--*/

{

    PLIST_ENTRY nextEntry;
    PCACHE_OBJECT cacheObject;
    CACHE_OBJECT localCacheObject;

    dprintf(
        "%s @ %08lx\n\n",
        ListName,
        RemoteListHead
        );

    nextEntry = LocalListHead->Flink;

    while( nextEntry != RemoteListHead ) {

        if( CheckControlC() ) {
            break;
        }

        if( MruList ) {
            cacheObject = CONTAINING_RECORD(
                              nextEntry,
                              CACHE_OBJECT,
                              MruList
                              );
        } else {
            cacheObject = CONTAINING_RECORD(
                              nextEntry,
                              CACHE_OBJECT,
                              BinList
                              );
        }

        if( !ReadMemory(
                (ULONG)cacheObject,
                &localCacheObject,
                sizeof(localCacheObject),
                NULL
                ) ) {

            dprintf(
                "inetdbg: cannot read CACHE_OBJECT @ %08lx\n",
                cacheObject
                );

            return;

        }

        DumpCacheObject(
            "    ",
            &localCacheObject,
            (ULONG)cacheObject,
            Verbose
            );

        if( MruList ) {
            nextEntry = localCacheObject.MruList.Flink;
        } else {
            nextEntry = localCacheObject.BinList.Flink;
        }

    }

}   // DumpCacheObjectList


VOID
DumpCacheTable(
    IN PCACHE_TABLE CacheTable,
    IN ULONG ActualAddress,
    IN BOOLEAN DumpBin,
    IN BOOLEAN DumpMru,
    IN BOOLEAN Verbose
    )

/*++

Routine Description:

    Formats and dumps the entire cache table.

Arguments:

    CacheTable - Points to a local copy of the cache table.

    ActualAddress - The virtual address of the cache table in the debugee.

    DumpBin - If TRUE, then dump the bin lists hanging off the cache table.

    DumpMru - If TRUE, then dump the Mru list hanging off the cache table.

    Verbose - If TRUE, then be verbose.

Return Value:

    None.

--*/

{

    LONG i;

    //
    // Dump simple data.
    //

    dprintf(
        "CACHE_TABLE @ %08lx\n"
        "    CriticalSection    @ %08lx\n",
        ActualAddress,
        ActualAddress + FIELD_OFFSET( CACHE_TABLE, CriticalSection )
        );

    if( CacheTable->CriticalSection.LockCount == -1 ) {
        dprintf(
            "        LockCount          = NOT LOCKED\n"
            );
    } else {
        dprintf(
            "        LockCount          = %lu\n",
            CacheTable->CriticalSection.LockCount
            );
    }

    dprintf(
        "        RecursionCount     = %lu\n"
        "        OwningThread       = %08lx\n",
        CacheTable->CriticalSection.RecursionCount,
        CacheTable->CriticalSection.OwningThread
        );

    //
    // Only display the non-empty bins.
    //

    for( i = 0 ; i < MAX_BINS ; i++ ) {
        CHAR tmp[sizeof("Items[1234567890]")];

        if( !IS_LIST_EMPTY( CacheTable, ActualAddress, CACHE_TABLE, Items[i] ) ) {
            sprintf(
                tmp,
                "Items[%lu]",
                i
                );

            dprintf(
                "    %-18s @ %08lx\n",
                tmp,
                ActualAddress + FIELD_OFFSET( CACHE_TABLE, Items[i] )
                );
        }
    }

    dprintf(
        "    MruList            @ %08lx%s\n"
        "    OpenFileInUse      = %ld\n"
        "    MaxOpenFileInUse   = %ld\n"
        "\n",
        ActualAddress + FIELD_OFFSET( CACHE_TABLE, MruList ),
        IS_LIST_EMPTY( CacheTable, ActualAddress, CACHE_TABLE, MruList )
            ? " (EMPTY)"
            : "",
        CacheTable->OpenFileInUse,
        CacheTable->MaxOpenFileInUse
        );

    //
    // If requested, dump the individual entries in the bin & mru lists.
    //

    if( DumpBin ) {

        for( i = 0 ; i < MAX_BINS ; i++ ) {
            CHAR tmp[sizeof("Items[1234567890]")];

            if( !IS_LIST_EMPTY( CacheTable, ActualAddress, CACHE_TABLE, Items[i] ) ) {
                sprintf(
                    tmp,
                    "Items[%lu]",
                    i
                    );

                DumpCacheObjectList(
                    tmp,
                    &CacheTable->Items[i],
                    (PLIST_ENTRY)( ActualAddress + FIELD_OFFSET( CACHE_TABLE, Items[i] ) ),
                    FALSE,
                    Verbose
                    );

            }
        }

    }

    if( DumpMru ) {

        if( !IS_LIST_EMPTY( CacheTable, ActualAddress, CACHE_TABLE, MruList ) ) {
            DumpCacheObjectList(
                "MruList",
                &CacheTable->MruList,
                (PLIST_ENTRY)( ActualAddress + FIELD_OFFSET( CACHE_TABLE, MruList ) ),
                TRUE,
                Verbose
                );
        }

    }

}   // DumpCacheTable


//
// NTSD extension entrypoints.
//


DECLARE_API( fcache )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the entire open file cache or a single cache object.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG address;
    CACHE_OBJECT cacheObject;
    CACHE_TABLE cacheTable;
    BOOLEAN dumpBin;
    BOOLEAN dumpMru;
    BOOLEAN verbose;

    INIT_API();

    //
    // Establish defaults.
    //

    dumpBin = FALSE;
    dumpMru = FALSE;
    verbose = FALSE;

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    //
    // Process switches.
    //

    while( *lpArgumentString == '-' ) {

        lpArgumentString++;

        while( *lpArgumentString != ' ' &&
               *lpArgumentString != '\t' &&
               *lpArgumentString != '\0' ) {

            switch( *lpArgumentString ) {
            case 'v' :
            case 'V' :
                verbose = !verbose;
                break;

            case 'b' :
            case 'B' :
                dumpBin = !dumpBin;
                break;

            case 'm' :
            case 'M' :
                dumpMru = !dumpMru;
                break;

            case '-' :  // Set the switches the way I like them. --keithmo
                verbose = TRUE;
                dumpBin = TRUE;
                dumpMru = FALSE;
                break;

            default :
                dprintf(
                    "use: inetdbg.fcache [options] [address]\n"
                    );
                return;

            }

            lpArgumentString++;

        }

        while( *lpArgumentString == ' ' ||
               *lpArgumentString == '\t' ) {
            lpArgumentString++;
        }

    }

    if( *lpArgumentString != '\0' ) {

        //
        // Dump a single object.
        //

        address = GetExpression( lpArgumentString );

        if( address == 0 ) {

            dprintf(
                "inetdbg: cannot evaluate \"%s\"\n",
                lpArgumentString
                );

            return;

        }

        //
        // Read the cache object.
        //

        if( !ReadMemory(
                (ULONG)address,
                &cacheObject,
                sizeof(cacheObject),
                NULL
                ) ) {

            dprintf(
                "inetdbg: cannot read CACHE_OBJECT @ %lx\n",
                address
                );

            return;

        }

        DumpCacheObject(
            "",
            &cacheObject,
            address,
            verbose
            );

        return;

    }

    //
    // Dump the entire cache table.
    //

    address = GetExpression( "infocomm!CacheTable" );

    if( address == 0 ) {

        dprintf(
            "inetdbg: cannot find infocomm!CacheTable\n"
            );

        return;

    }

    if( !ReadMemory(
            (ULONG)address,
            &cacheTable,
            sizeof(cacheTable),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read CACHE_TABLE @ %08lx\n",
            address
            );

        return;

    }

    DumpCacheTable(
        &cacheTable,
        address,
        dumpBin,
        dumpMru,
        verbose
        );

} // DECLARE_API( fcache )


DECLARE_API( open )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a specific TS_OPEN_FILE_INFO structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG address;
    TS_OPEN_FILE_INFO openFileInfo;

    INIT_API();

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        dprintf(
            "use: inetdbg.open address\n"
            );

        return;

    }

    address = GetExpression( lpArgumentString );

    if( address == 0 ) {

        dprintf(
            "inetdbg: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the object.
    //

    if( !ReadMemory(
            (ULONG)address,
            &openFileInfo,
            sizeof(openFileInfo),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read TS_OPEN_FILE_INFO @ %lx\n",
            address
            );

        return;

    }

    DumpOpenFileInfo(
        "",
        &openFileInfo,
        address
        );

} // DECLARE_API( open )


DECLARE_API( uri )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a specific W3_URI_INFO structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG address;
    W3_URI_INFO uriInfo;

    INIT_API();

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        dprintf(
            "use: inetdbg.uri address\n"
            );

        return;

    }

    address = GetExpression( lpArgumentString );

    if( address == 0 ) {

        dprintf(
            "inetdbg: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the object.
    //

    if( !ReadMemory(
            (ULONG)address,
            &uriInfo,
            sizeof(uriInfo),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read W3_URI_INFO @ %lx\n",
            address
            );

        return;

    }

    DumpUriInfo(
        "",
        &uriInfo,
        address
        );

} // DECLARE_API( uri )


DECLARE_API( phys )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a specific PHYS_OPEN_FILE_INFO structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG address;
    PHYS_OPEN_FILE_INFO physOpenFileInfo;

    INIT_API();

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        dprintf(
            "use: inetdbg.phys address\n"
            );

        return;

    }

    address = GetExpression( lpArgumentString );

    if( address == 0 ) {

        dprintf(
            "inetdbg: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the object.
    //

    if( !ReadMemory(
            (ULONG)address,
            &physOpenFileInfo,
            sizeof(physOpenFileInfo),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read PHYS_OPEN_FILE_INFO @ %lx\n",
            address
            );

        return;

    }

    DumpPhysOpenFileInfo(
        "",
        &physOpenFileInfo,
        address
        );

} // DECLARE_API( phys )


DECLARE_API( oplock )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a specific OPLOCK_OBJECT structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG address;
    OPLOCK_OBJECT oplockObject;

    INIT_API();

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        dprintf(
            "use: inetdbg.oplock address\n"
            );

        return;

    }

    address = GetExpression( lpArgumentString );

    if( address == 0 ) {

        dprintf(
            "inetdbg: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the object.
    //

    if( !ReadMemory(
            (ULONG)address,
            &oplockObject,
            sizeof(oplockObject),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read OPLOCK_OBJECT @ %lx\n",
            address
            );

        return;

    }

    DumpOplockObject(
        "",
        &oplockObject,
        address
        );

} // DECLARE_API( oplock )


DECLARE_API( blob )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    a specific BLOB_HEADER structure.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    ULONG address;
    BLOB_HEADER blobHeader;

    INIT_API();

    //
    // Skip any leading blanks.
    //

    while( *lpArgumentString == ' ' ||
           *lpArgumentString == '\t' ) {
        lpArgumentString++;
    }

    if( *lpArgumentString == '\0' ) {

        dprintf(
            "use: inetdbg.blob address\n"
            );

        return;

    }

    address = GetExpression( lpArgumentString );

    if( address == 0 ) {

        dprintf(
            "inetdbg: cannot evaluate \"%s\"\n",
            lpArgumentString
            );

        return;

    }

    //
    // Read the object.
    //

    if( !ReadMemory(
            (ULONG)address,
            &blobHeader,
            sizeof(blobHeader),
            NULL
            ) ) {

        dprintf(
            "inetdbg: cannot read BLOB_HEADER @ %lx\n",
            address
            );

        return;

    }

    DumpBlobHeader(
        "",
        &blobHeader,
        address
        );

} // DECLARE_API( blob )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\dbgext\vm.cxx ===
/*++

Copyright (c) 1999-1999  Microsoft Corporation

Module Name:

    vm.cxx

Abstract:

    This module contains an NTSD debugger extension for dumping various
    virtual memory statistics.

Author:

    Keith Moore (keithmo) 15-Jan-1999

Revision History:

--*/

#include "inetdbgp.h"


//
// Private constants.
//

#define SMALL_REGION        (64 * 1024)
#define MEDIUM_REGION       (1 * 1024 * 1024)

#define IS_SMALL(c)         ((c) <= SMALL_REGION)
#define IS_MEDIUM(c)        (((c) > SMALL_REGION) && ((c) <= MEDIUM_REGION))
#define IS_LARGE(c)         ((c) > MEDIUM_REGION)

#define PRINTF_FORMAT       "%-7s %*s %*s %*s %*s\n"

#define CCH_ULONG_COMMAS    sizeof("4,294,967,296")


//
// Private types.
//

typedef struct _INDIVIDUAL_STAT
{
    SIZE_T MinimumSize;
    SIZE_T MaximumSize;
    SIZE_T TotalSize;
    SIZE_T BlockCount;

} INDIVIDUAL_STAT, *PINDIVIDUAL_STAT;

typedef struct _VM_STATS
{
    INDIVIDUAL_STAT Summary;
    INDIVIDUAL_STAT Small;
    INDIVIDUAL_STAT Medium;
    INDIVIDUAL_STAT Large;

} VM_STATS, *PVM_STATS;

typedef struct PROTECT_MASK
{
    DWORD Bit;
    PSTR Name;

} PROTECT_MASK, *PPROTECT_MASK;


//
// Private globals.
//

PROTECT_MASK ProtectMasks[] =
    {
        {
            PAGE_NOACCESS,
            "NA"
        },

        {
            PAGE_NOCACHE,
            "NC"
        },

        {
            PAGE_GUARD,
            "G"
        },

        {
            PAGE_READONLY,
            "Rd"
        },

        {
            PAGE_READWRITE,
            "RdWr"
        },

        {
            PAGE_WRITECOPY,
            "WrCp"
        },

        {
            PAGE_EXECUTE,
            "Ex"
        },

        {
            PAGE_EXECUTE_READ,
            "ExRd"
        },

        {
            PAGE_EXECUTE_READWRITE,
            "ExRdWr"
        },

        {
            PAGE_EXECUTE_WRITECOPY,
            "ExWrCp"
        }
    };

#define NUM_PROTECT_MASKS (sizeof(ProtectMasks) / sizeof(ProtectMasks[0]))


//
// Private functions.
//

PSTR
ULongLongToString(
    IN ULONGLONG Value,
    OUT PSTR Buffer
    )
{

    PSTR p1;
    PSTR p2;
    CHAR ch;
    INT digit;
    INT count;
    BOOL needComma;
    INT length;

    //
    // Handling zero specially makes everything else a bit easier.
    //

    if( Value == 0 ) {
        Buffer[0] = '0';
        Buffer[1] = '\0';
        return Buffer;
    }

    //
    // Pull the least signifigant digits off the value and store them
    // into the buffer. Note that this will store the digits in the
    // reverse order.
    //

    p1 = p2 = Buffer;
    count = 3;
    needComma = FALSE;

    while( Value != 0 ) {

        if( needComma ) {
            *p1++ = ',';
            needComma = FALSE;
        }

        digit = (INT)( Value % 10 );
        Value = Value / 10;

        *p1++ = '0' + digit;

        count--;
        if( count == 0 ) {
            count = 3;
            needComma = TRUE;
        }

    }

    length = DIFF(p1 - Buffer);

    //
    // Reverse the digits in the buffer.
    //

    *p1-- = '\0';

    while( p1 > p2 ) {

        ch = *p1;
        *p1 = *p2;
        *p2 = ch;

        p2++;
        p1--;

    }

    return Buffer;

}   // ULongLongToString

VOID
InitVmStats(
    OUT PVM_STATS Stats
    )
{
    ZeroMemory( Stats, sizeof(*Stats) );
    Stats->Summary.MinimumSize = (SIZE_T)-1L;
    Stats->Small.MinimumSize = (SIZE_T)-1L;
    Stats->Medium.MinimumSize = (SIZE_T)-1L;
    Stats->Large.MinimumSize = (SIZE_T)-1L;

}   // InitVmStats

VOID
UpdateIndividualStat(
    IN OUT PINDIVIDUAL_STAT Stat,
    IN SIZE_T BlockSize
    )
{
    Stat->BlockCount++;
    Stat->TotalSize += BlockSize;

    if( BlockSize > Stat->MaximumSize ) {
        Stat->MaximumSize = BlockSize;
    }

    if( BlockSize < Stat->MinimumSize ) {
        Stat->MinimumSize = BlockSize;
    }

}   // UpdateIndividualStat

VOID
UpdateVmStats(
    IN OUT PVM_STATS Stats,
    IN SIZE_T BlockSize
    )
{
    UpdateIndividualStat( &Stats->Summary, BlockSize );

    if( IS_SMALL(BlockSize) ) {
        UpdateIndividualStat( &Stats->Small, BlockSize );
    }

    if( IS_MEDIUM(BlockSize) ) {
        UpdateIndividualStat( &Stats->Medium, BlockSize );
    }

    if( IS_LARGE(BlockSize) ) {
        UpdateIndividualStat( &Stats->Large, BlockSize );
    }

}   // UpdateVmStats

VOID
PrintVmStatsHeader(
    VOID
    )
{
    dprintf(
        PRINTF_FORMAT,
        "TYPE",
        CCH_ULONG_COMMAS,
        "MINIMUM",
        CCH_ULONG_COMMAS,
        "MAXIMUM",
        CCH_ULONG_COMMAS,
        "AVERAGE",
        CCH_ULONG_COMMAS,
        "BLK COUNT"
        );

    printf(
        PRINTF_FORMAT,
        "~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~",
        CCH_ULONG_COMMAS,
        "~~~~~~~~~"
        );

}   // PrintVmStatsHeader

VOID
PrintIndividualStat(
    IN PSTR Name,
    IN PINDIVIDUAL_STAT Stat
    )
{
    SIZE_T average;
    SIZE_T minsize;
    CHAR minStr[CCH_ULONG_COMMAS];
    CHAR maxStr[CCH_ULONG_COMMAS];
    CHAR avgStr[CCH_ULONG_COMMAS];
    CHAR countStr[CCH_ULONG_COMMAS];

    if( Stat->BlockCount == 0 ) {
        average = 0;
        minsize = 0;
    } else {
        average = Stat->TotalSize / Stat->BlockCount;
        minsize = Stat->MinimumSize;
    }

    dprintf(
        PRINTF_FORMAT,
        Name,
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)minsize,
            minStr
            ),
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)Stat->MaximumSize,
            maxStr
            ),
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)average,
            avgStr
            ),
        CCH_ULONG_COMMAS,
        ULongLongToString(
            (ULONGLONG)Stat->BlockCount,
            countStr
            )
        );

}   // PrintIndividualStat

VOID
PrintVmStats(
    IN PSTR Name,
    IN PVM_STATS Stats
    )
{
    dprintf( "%s:\n", Name );

    PrintIndividualStat( "Small", &Stats->Small );
    PrintIndividualStat( "Medium", &Stats->Medium );
    PrintIndividualStat( "Large", &Stats->Large );
    PrintIndividualStat( "Summary", &Stats->Summary );

    dprintf( "\n" );

}   // PrintVmStats

PSTR
VmProtectToString(
    IN DWORD Protect,
    OUT PSTR Buffer
    )
{
    INT i;
    PPROTECT_MASK mask;

    Buffer[0] = '\0';

    for( i = 0, mask = &ProtectMasks[0] ;
        (i < NUM_PROTECT_MASKS) && (Protect != 0) ;
        i++, mask++ ) {
        if( mask->Bit & Protect ) {
            Protect &= ~mask->Bit;
            if( Buffer[0] != '\0' ) {
                strcat( Buffer, "|" );
            }
            strcat( Buffer, mask->Name );
        }
    }

    if( Protect != 0 ) {
        if( Buffer[0] != '\0' ) {
            strcat( Buffer, "|" );
        }
        sprintf( Buffer + strlen(Buffer), "%08lx", Protect );
    }

    return Buffer;

}   // VmProtectToString

PSTR
VmStateToString(
    IN DWORD State,
    OUT PSTR Buffer
    )
{
    PSTR result;
    CHAR invalidStr[sizeof("12345678")];

    switch( State )
    {
    case MEM_COMMIT:
        result = "Commit";
        break;

    case MEM_RESERVE:
        result = "Reserve";
        break;

    case MEM_FREE:
        result = "Free";
        break;

    default:
        sprintf( invalidStr, "%08lx", State );
        result = invalidStr;
        break;
    }

    strcpy( Buffer, result );
    return Buffer;

}   // VmStateToString

PSTR
VmTypeToString(
    IN DWORD Type,
    OUT PSTR Buffer
    )
{
    PSTR result;
    CHAR invalidStr[sizeof("12345678")];

    switch( Type )
    {
    case MEM_PRIVATE:
        result = "Private";
        break;

    case MEM_MAPPED:
        result = "Mapped";
        break;

    case MEM_IMAGE:
        result = "Image";
        break;

    case 0:
        result = "";
        break;

    default:
        sprintf( invalidStr, "%08lx", Type );
        result = invalidStr;
        break;
    }

    strcpy( Buffer, result );
    return Buffer;

}   // VmTypeToString


/************************************************************
 * Dump Virtual Memory Info
 ************************************************************/


DECLARE_API( vmstat )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    virtual memory statistics.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    NTSTATUS status;
    ULONG_PTR address;
    MEMORY_BASIC_INFORMATION memInfo;
    VM_STATS freeStats;
    VM_STATS reserveStats;
    VM_STATS commitStats;
    VM_STATS privateStats;
    VM_STATS mappedStats;
    VM_STATS imageStats;

    INIT_API();

    //
    // Setup.
    //

    InitVmStats( &freeStats );
    InitVmStats( &reserveStats );
    InitVmStats( &commitStats );
    InitVmStats( &privateStats );
    InitVmStats( &mappedStats );
    InitVmStats( &imageStats );

    address = 0;

    //
    // Scan the virtual address space.
    //

    for( ; ; ) {
        status = NtQueryVirtualMemory(
                     hCurrentProcess,
                     (PVOID)address,
                     MemoryBasicInformation,
                     &memInfo,
                     sizeof(memInfo),
                     NULL
                     );

        if( !NT_SUCCESS(status) ) {
            break;
        }

        //
        // Interpret the memory state.
        //

        switch( memInfo.State ) {
        case MEM_FREE:
            UpdateVmStats( &freeStats, memInfo.RegionSize );
            break;

        case MEM_RESERVE:
            UpdateVmStats( &reserveStats, memInfo.RegionSize );
            break;

        case MEM_COMMIT:
            UpdateVmStats( &commitStats, memInfo.RegionSize );
            break;
        }

        //
        // Interpret the memory type.
        //

        switch( memInfo.Type ) {
        case MEM_PRIVATE:
            UpdateVmStats( &privateStats, memInfo.RegionSize );
            break;

        case MEM_MAPPED:
            UpdateVmStats( &mappedStats, memInfo.RegionSize );
            break;

        case MEM_IMAGE:
            UpdateVmStats( &imageStats, memInfo.RegionSize );
            break;
        }

        //
        // Advance to the next block.
        //

        address += memInfo.RegionSize;
    }

    //
    // Dump it.
    //

    PrintVmStatsHeader();
    PrintVmStats( "Free", &freeStats );
    PrintVmStats( "Reserve", &reserveStats );
    PrintVmStats( "Commit", &commitStats );
    PrintVmStats( "Private", &privateStats );
    PrintVmStats( "Mapped", &mappedStats );
    PrintVmStats( "Image", &imageStats );

}   // DECLARE_API( vmstat )


DECLARE_API( vmmap )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the debugee's virtual memory address space.

Arguments:

    hCurrentProcess - Supplies a handle to the current process (at the
        time the extension was called).

    hCurrentThread - Supplies a handle to the current thread (at the
        time the extension was called).

    CurrentPc - Supplies the current pc at the time the extension is
        called.

    lpExtensionApis - Supplies the address of the functions callable
        by this extension.

    lpArgumentString - Supplies the asciiz string that describes the
        ansi string to be dumped.

Return Value:

    None.

--*/

{

    NTSTATUS status;
    ULONG_PTR address;
    MEMORY_BASIC_INFORMATION memInfo;
    CHAR protectStr[32];
    CHAR aprotectStr[32];
    CHAR stateStr[16];
    CHAR typeStr[16];

    INIT_API();

    //
    // Setup.
    //

    address = 0;

    dprintf(
        "%-*s %-*s %-*s  %-13s %-13s %-8s %-8s\n",
        sizeof(PVOID) * 2,
        "Start",
        sizeof(PVOID) * 2,
        "Stop",
        sizeof(PVOID) * 2,
        "Length",
        "AllocProtect",
        "Protect",
        "State",
        "Type"
        );

    //
    // Scan the virtual address space.
    //

    for( ; ; ) {
        status = NtQueryVirtualMemory(
                     hCurrentProcess,
                     (PVOID)address,
                     MemoryBasicInformation,
                     &memInfo,
                     sizeof(memInfo),
                     NULL
                     );

        if( !NT_SUCCESS(status) ) {
            break;
        }

        //
        // Dump the current entry.
        //

        dprintf(
            "%p-%p %p  %-13s %-13s %-8s %-8s\n",
            memInfo.BaseAddress,
            (ULONG_PTR)memInfo.BaseAddress + memInfo.RegionSize - 1,
            memInfo.RegionSize,
            VmProtectToString( memInfo.AllocationProtect, aprotectStr ),
            VmProtectToString( memInfo.Protect, protectStr ),
            VmStateToString( memInfo.State, stateStr ),
            VmTypeToString( memInfo.Type, typeStr )
            );

        //
        // Advance to the next block.
        //

        address += memInfo.RegionSize;
    }

}   // DECLARE_API( vmmap )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\apitest\ftpt.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <lm.h>
#include <inetcom.h>
#include <iisinfo.h>
#include <lmapibuf.h>



/*****************************************************************************

    globals

*****************************************************************************/
UINT _cchNumberPadding;



/*****************************************************************************

    prototypes

*****************************************************************************/
INT __cdecl main( INT    cArgs,
                   char * pArgs[] );

VOID Usage();

VOID DoEnum( WCHAR * pszServer );

VOID DoQuery( WCHAR * pszServer );

VOID DoSet( WCHAR * pszServer,
            CHAR * pszPassword );

VOID DoNuke( WCHAR * pszServer,
             CHAR  * pszUserId );

VOID DoStats( WCHAR * pszServer );

VOID DoClear( WCHAR * pszServer );

CHAR * MakeCommaString( CHAR * pszNumber );

CHAR * MakeCommaNumber( DWORD  dwNumber  );



/*****************************************************************************

    main

*****************************************************************************/
INT __cdecl main( INT    cArgs,
                   char * pArgs[] )
{
    WCHAR   szServer[MAX_PATH];
    WCHAR * pszServer = NULL;
    INT     iArg;

    if( cArgs < 2 )
    {
        Usage();
        return 1;
    }

    iArg = 1;

    if( *pArgs[iArg] == '\\' )
    {
        wsprintfW( szServer, L"%S", pArgs[iArg++] );
        pszServer = szServer;
        cArgs--;
    }

    if( _stricmp( pArgs[iArg], "stats" ) == 0 )
    {
        if( cArgs != 2 )
        {
            printf( "use: ftpt stats\n" );
            return 1;
        }

        DoStats( pszServer );
    }
    else
    if( _stricmp( pArgs[iArg], "clear" ) == 0 )
    {
        if( cArgs != 2 )
        {
            printf( "use: ftpt clear\n" );
            return 1;
        }

        DoClear( pszServer );
    }
    else
    if( _stricmp( pArgs[iArg], "enum" ) == 0 )
    {
        if( cArgs != 2 )
        {
            printf( "use: ftpt enum\n" );
            return 1;
        }

        DoEnum( pszServer );
    }
    else
    if( _stricmp( pArgs[iArg], "query" ) == 0 )
    {
        if( cArgs != 2 )
        {
            printf( "use: ftpt query\n" );
            return 1;
        }

        DoQuery( pszServer );
    }
    else
    if( _stricmp( pArgs[iArg], "set" ) == 0 )
    {
        CHAR * pszPassword;

        if ( cArgs == 3 )
        {
            pszPassword = pArgs[++iArg];
        }
        else
            pszPassword = NULL;

        DoSet( pszServer,
               pszPassword );


    }
    else
    if( _stricmp( pArgs[iArg], "nuke" ) == 0 )
    {
        CHAR * pszUserId;

        if( cArgs != 3 )
        {
            printf( "use: ftpt nuke user_id\n" );
            return 1;
        }

        pszUserId = pArgs[++iArg];

        DoNuke( pszServer,
                pszUserId );
    }
    else
    {
        Usage();
        return 1;
    }

    return 0;

}   // main



/*****************************************************************************

    Usage

*****************************************************************************/
VOID Usage( VOID )
{
    printf( "use: ftpt [\\\\server] command [options]\n" );
    printf( "Valid commands are:\n" );
    printf( "        enum  - Enumerates connected users.\n" );
    printf( "        query - Queries volume security masks.\n" );
    printf( "        set [Catapult user password]  - Sets admin info.\n" );
    printf( "        nuke  - Disconnect a user.\n" );
    printf( "        stats - Display server statistics.\n" );
    printf( "        clear - Clear server statistics.\n" );

}   // Usage



/*****************************************************************************

    DoEnum

*****************************************************************************/
VOID DoEnum( WCHAR * pszServer )
{
    NET_API_STATUS      err;
    LPIIS_USER_INFO_1   pUserInfo;
    DWORD               cEntries;

    printf( "Invoking FtpEnumerateUsers..." );

    err = IISEnumerateUsers(
                        pszServer,
                        1,
                        INET_FTP_SVC_ID,
                        1,
                        &cEntries,
                        (LPBYTE*)&pUserInfo );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
    }
    else
    {
        printf( "done\n" );
        printf( "read %lu connected users\n", cEntries );

        while( cEntries-- )
        {
            IN_ADDR addr;

            addr.s_addr = (u_long)pUserInfo->inetHost;

            printf( "idUser     = %lu\n", pUserInfo->idUser     );
            printf( "pszUser    = %S\n",  pUserInfo->pszUser    );
            printf( "fAnonymous = %lu\n", pUserInfo->fAnonymous );
            printf( "inetHost   = %s\n",  inet_ntoa( addr )     );
            printf( "tConnect   = %lu\n", pUserInfo->tConnect   );
            printf( "\n" );

            pUserInfo++;
        }
    }

}   // DoEnum



/*****************************************************************************

    DoQuery

*****************************************************************************/
VOID DoQuery( WCHAR * pszServer )
{
    NET_API_STATUS   err;
    LPFTP_CONFIG_INFO_1 pConfig;
    DWORD            i;

    printf( "Invoking FtpGetAdminInformation..." );


    err = FtpGetAdminInformation2(
                            pszServer,
                            1,
                            1,
                            (LPBYTE*)&pConfig
                            );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
        return;
    }

    printf("fAllowAnonymous = %d\n", pConfig->fAllowAnonymous );
    printf("fAllowGuestAccess = %d\n", pConfig->fAllowGuestAccess );
    printf("fAnnotateDirectories = %d\n", pConfig->fAnnotateDirectories );
    printf("fAnonymous only = %d\n", pConfig->fAnonymousOnly );
    printf("lpszExitMessage  = %S\n", pConfig->lpszExitMessage );
    printf("lpszGreetingMessage = %S\n", pConfig->lpszGreetingMessage );
    printf("lpszHomeDirectory = %S\n", pConfig->lpszHomeDirectory );
    printf("lpszMaxClientsMessage = %S\n", pConfig->lpszMaxClientsMessage );
    printf("dwListenBacklog = %d\n", pConfig->dwListenBacklog );
    printf("fLowerCaseFiles = %d\n", pConfig->fLowercaseFiles );
    printf("fMsdosDirOutput = %d\n", pConfig->fMsdosDirOutput );

}   // DoQuery


/*****************************************************************************

    DoSet

*****************************************************************************/
VOID DoSet( WCHAR * pszServer, CHAR * pszPassword )
{
    NET_API_STATUS   err;
    FTP_CONFIG_INFO_1 * pConfig;
    WCHAR            achPassword[PWLEN+1];

    printf( "Invoking FtpGetAdminInformation..." );

    err = FtpGetAdminInformation2(
                            pszServer,
                            1,
                            1,
                            (LPBYTE*)&pConfig );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
        return;
    }

    printf( "Invoking FtpSetAdminInformation..." );

    err = FtpSetAdminInformation2(
                                pszServer,
                                1,
                                1,
                                (LPBYTE)pConfig
                                );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
        return;
    }

    printf( "done!\n" );

    NetApiBufferFree( pConfig );

}   // DoSet



/*****************************************************************************

    DoNuke

*****************************************************************************/
VOID DoNuke( WCHAR * pszServer,
             CHAR  * pszUserId )
{
    NET_API_STATUS   err;
    DWORD            idUser;

    idUser = (DWORD)strtoul( pszUserId, NULL, 0 );

    printf( "Invoking FtpDisconnectUser..." );

    err = IISDisconnectUser(
                        pszServer,
                        INET_FTP_SVC_ID,
                        1,
                        idUser
                        );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
    }
    else
    {
        printf( "done\n" );
    }

}   // DoNuke



/*****************************************************************************

    DoStats

*****************************************************************************/
VOID DoStats( WCHAR * pszServer )
{
    NET_API_STATUS    err;
    FTP_STATISTICS_0 * pstats;

    printf( "Invoking FtpQueryStatistics..." );

    err = FtpQueryStatistics2( pszServer,
                                0,
                                INET_INSTANCE_GLOBAL,
                                0,
                                (LPBYTE *)&pstats
                                );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
    }
    else
    {
        CHAR szLargeInt[64];

        printf( "done\n" );

        _cchNumberPadding = 13;

        if( ( pstats->TotalBytesSent.HighPart != 0 ) ||
            ( pstats->TotalBytesReceived.HighPart != 0 ) )
        {
            _cchNumberPadding = 26;
        }

        RtlLargeIntegerToChar( &pstats->TotalBytesSent,
                               10,
                               sizeof(szLargeInt),
                               szLargeInt );

        printf( "TotalBytesSent           = %s\n",
                MakeCommaString( szLargeInt )                              );

        RtlLargeIntegerToChar( &pstats->TotalBytesReceived,
                               10,
                               sizeof(szLargeInt),
                               szLargeInt );

        printf( "TotalBytesReceived       = %s\n",
                MakeCommaString( szLargeInt )                              );

        printf( "TotalFilesSent           = %s\n",
                MakeCommaNumber( pstats->TotalFilesSent )                  );

        printf( "TotalFilesReceived       = %s\n",
                MakeCommaNumber( pstats->TotalFilesReceived )              );

        printf( "CurrentAnonymousUsers    = %s\n",
                MakeCommaNumber( pstats->CurrentAnonymousUsers )           );

        printf( "CurrentNonAnonymousUsers = %s\n",
                MakeCommaNumber( pstats->CurrentNonAnonymousUsers )        );

        printf( "TotalAnonymousUsers      = %s\n",
                MakeCommaNumber( pstats->TotalAnonymousUsers )             );

        printf( "TotalNonAnonymousUsers   = %s\n",
                MakeCommaNumber( pstats->TotalNonAnonymousUsers )          );

        printf( "MaxAnonymousUsers        = %s\n",
                MakeCommaNumber( pstats->MaxAnonymousUsers )               );

        printf( "MaxNonAnonymousUsers     = %s\n",
                MakeCommaNumber( pstats->MaxNonAnonymousUsers )            );

        printf( "CurrentConnections       = %s\n",
                MakeCommaNumber( pstats->CurrentConnections )              );

        printf( "MaxConnections           = %s\n",
                MakeCommaNumber( pstats->MaxConnections )                  );

        printf( "ConnectionAttempts       = %s\n",
                MakeCommaNumber( pstats->ConnectionAttempts )              );

        printf( "LogonAttempts            = %s\n",
                MakeCommaNumber( pstats->LogonAttempts )                   );

        printf( "TimeOfLastClear          = %s\n",
                asctime( localtime( (time_t *)&pstats->TimeOfLastClear ) ) );
    }

}   // DoStats



/*****************************************************************************

    DoClear

*****************************************************************************/
VOID DoClear( WCHAR * pszServer )
{
    NET_API_STATUS   err;

    printf( "Invoking FtpClearStatistics..." );

    err = FtpClearStatistics2( pszServer, 0 );

    if( err != NERR_Success )
    {
        printf( "ERROR %lu (%08lX)\n", err, err );
    }
    else
    {
        printf( "done\n" );
    }

}   // DoClear



/*****************************************************************************

    MakeCommaString

*****************************************************************************/
CHAR * MakeCommaString( CHAR * pszNumber )
{
    static CHAR   szBuffer[26];
    CHAR        * psz;
    UINT          cchNumber;
    UINT          cchNextComma;

    cchNumber  = strlen( pszNumber );
    pszNumber += cchNumber - 1;

    psz = szBuffer + _cchNumberPadding;

    *psz-- = '\0';

    cchNextComma = 3;

    while( cchNumber-- )
    {
        if( cchNextComma-- == 0 )
        {
            *psz-- = ',';
            cchNextComma = 2;
        }

        *psz-- = *pszNumber--;
    }

    while( psz >= szBuffer )
    {
        *psz-- = ' ';
    }

    return szBuffer;

}   // MakeCommaString



/*****************************************************************************

    MakeCommaNumber

*****************************************************************************/
CHAR * MakeCommaNumber( DWORD  dwNumber  )
{
    CHAR szBuffer[32];

    wsprintf( szBuffer, "%lu", dwNumber );

    return MakeCommaString( szBuffer );

}   // MakeCommaNumber
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\client\ftpbind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ftpbind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the FTP Daemon
    service.

Author:

    Murali R. Krishnan (MuraliK) 15-Nov-1995  (completely rewritten)

Environment:

    User Mode -Win32

Revision History:

   MuraliK  21-Dec-1995   Support for TCP/IP binding added.

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <ftpsvc.h>
#include "apiutil.h"




handle_t
FTP_IMPERSONATE_HANDLE_bind(
    FTP_IMPERSONATE_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the FTP Daemon client stubs when
    it is necessary create an RPC binding to the server end with
    impersonation level of security

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindingHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindingHandle,
                                       ServerName,
                                       FTP_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );

    return BindingHandle;
} // FTP_IMPERSONATE_HANDLE_bind()



handle_t
FTP_IDENTIFY_HANDLE_bind(
    FTP_IDENTIFY_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the FTP Daemon client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindingHandle;
    RPC_STATUS RpcStatus;


    RpcStatus = RpcBindHandleForServer(&BindingHandle,
                                       ServerName,
                                       FTP_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );

    return BindingHandle;
} // FTP_IDENTIFY_HANDLE_bind()



void
FTP_IMPERSONATE_HANDLE_unbind(
    FTP_IMPERSONATE_HANDLE ServerName,
    handle_t BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the FTP Daemon client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID ) RpcBindHandleFree(&BindingHandle);

    return;
} // FTP_IMPERSONATE_HANDLE_unbind()



void
FTP_IDENTIFY_HANDLE_unbind(
    FTP_IDENTIFY_HANDLE ServerName,
    handle_t BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the FTP Daemon client stubs when it is
    necessary to unbind from a server.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID ) RpcBindHandleFree(&BindingHandle);

    return;
} // FTP_IDENTIFY_HANDLE_unbind()


/****************************** End Of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\client\ftpadmin.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        ftpadmin.cxx

   Abstract:
        main program to test the working of RPC APIs of ftp server

   Author:

           Murali R. Krishnan    ( MuraliK )     25-July-1995

   Project:

          FTP server Admin Test Program

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include <time.h>
# include <winsock2.h>
# include "inetinfo.h"
# define _INETASRV_H_
# include "ftpd.h"
# include "apiutil.h"

//
//  size of half dword in bits
//
# define HALF_DWORD_SIZE    ( sizeof(DWORD) * 8 / 2)

//
//  To Avoid overflows I multiply using two parts
//
# define LargeIntegerToDouble( li)      \
        ( ( 1 << HALF_DWORD_SIZE) * \
           (( double) (li).HighPart) * ( 1 << HALF_DWORD_SIZE) + \
          ((li).LowPart) \
        )


static LPWSTR g_lpszServerAddress = NULL;

//
// Prototypes of Functions
//

BOOL GenUsageMessage( int argc, char * argv[]);

BOOL TestGetCommonStatistics( int argc, char * argv[] );

BOOL TestGetStatistics( int argc, char * argv[]);

BOOL TestClearStatistics( int argc, char * argv[]);

BOOL TestGetAdminInfo( int argc, char * argv[]);

BOOL TestSetAdminInfo( int argc, char * argv[]);

BOOL TestInetGetAdminInfo( int argc, char * argv[]);

BOOL TestInetSetAdminInfo( int argc, char * argv[]);

BOOL TestEnumUserInfo( int argc, char * argv[]);

BOOL TestDisconnectUser( int argc, char * argv[]);


//
//  The following DefineAllCommands() defines a template for all commands.
//  Format: CmdCodeName     CommandName         Function Pointer   Comments
//
//  To add addditional test commands, add just another line to the list
//  Dont touch any macros below, they are all automatically generated.
//  Always the first entry should be usage function.
//

#define  DefineAllCommands()    \
 Cmd( CmdUsage,             "usage",                GenUsageMessage,    \
        " Commands Available" )                                         \
 Cmd( CmdGetStatistics,     "getstatistics",        TestGetStatistics,  \
        " Get Server Statistics " )                          \
 Cmd( CmdGetStatisticsShort, "getstats",             TestGetStatistics,  \
        " Get Server Statistics " )                          \
 Cmd( CmdGetStats,          "stats",                TestGetStatistics,  \
        " Get Server Statistics " )                          \
 Cmd( CmdGetCommonStats,    "istats",               TestGetCommonStatistics,  \
        " Get Common Statistics " )                           \
 Cmd( CmdClearStatistics,   "clearstatistics",      TestClearStatistics,\
        " Clear Server Statistics" )                             \
 Cmd( CmdGetAdminInfo,      "getadmininfo",         TestGetAdminInfo,   \
        " Get Administrative Information" )                             \
 Cmd( CmdSetAdminInfo,      "setadmininfo",         TestSetAdminInfo,   \
        " Set Administrative Information" )           \
 Cmd( CmdEnumUserInfo,      "enumusers",            TestEnumUserInfo,   \
        " Enumerate connected users" )           \
 Cmd( CmdKillUser,          "killuser",             TestDisconnectUser,   \
        " Disconnects a specified user" )           \
 Cmd( CmdInetGetAdminInfo,  "igetadmininfo",        TestInetGetAdminInfo, \
        " Get common Internet Administrative Information" )    \
 Cmd( CmdInetSetAdminInfo,  "isetadmininfo",        TestInetSetAdminInfo, \
        " Set common Internet Administrative Information" )    \
 Cmd( CmdDebugFlags,        "debug",                NULL,               \
        " isetadmininfo: Set Debugging flags for the server" )          \
 Cmd( CmdPortNumber,        "port",                 NULL,               \
        " isetadmininfo: Set the port number for server")               \
 Cmd( CmdMaxConnections,    "maxconn",              NULL,               \
        " isetadmininfo: Set the max connections allowed in server")    \
 Cmd( CmdConnectionTimeout, "timeout",              NULL,               \
        " isetadmininfo: Set the Connection Timeout interval( in seconds)") \
 Cmd( CmdLogAnonymous,      "loganon",              NULL,               \
        " isetadmininfo: Set the LogAnonymous Flag")                    \
 Cmd( CmdLogNonAnonymous,   "lognonanon",           NULL,               \
        " isetadmininfo: Set the LogNonAnonymous Flag")                 \
 Cmd( CmdAnonUserName,      "anonuser",             NULL,               \
        " isetadmininfo: Set the Anonymous User Name ")                 \
 Cmd( CmdAdminName,         "adminname",            NULL,               \
        " isetadmininfo: Set the Administrator name ")                  \
 Cmd( CmdAdminEmail,        "adminemail",           NULL,               \
        " isetadmininfo: Set the Administrator Email ")                 \
 Cmd( CmdServerComment,     "servercomment",        NULL,               \
        " isetadmininfo: Set the Server Comments for server ")          \
 Cmd( CmdGreetingMessage,    "greeting",          NULL,               \
        " setadmininfo: Sets the Greeting Message ")   \
 Cmd( CmdExitMessage,       "exitmsg",            NULL,               \
        " setadmininfo: Sets the Exit Message ")       \
 Cmd( CmdMaxClientsMessage, "maxclientsmsg",      NULL,               \
        " setadmininfo: Sets the Max Clients Message ")         \
 Cmd( CmdAllowAnonymous, "allowanon",      NULL,                \
        " setadmininfo: Sets the allow anonymous flag ")        \
 Cmd( CmdAllowGuest,     "allowguest",      NULL,               \
        " setadmininfo: Sets the allow guest access flag ")     \
 Cmd( CmdAllowAnonOnly,  "allowanononly",      NULL,               \
        " setadmininfo: Sets the allow anonymous only flag ")     \
 Cmd( CmdAnnotateDirs,   "annotatedirs",      NULL,               \
        " setadmininfo: Sets the Annotate Directories flag ")     \
 Cmd( CmdListenBacklog,  "listenbacklog",      NULL,              \
        " setadmininfo: Sets the Listen Backlog value ")          \
 Cmd( CmdMsdosDir,       "msdosdir",      NULL,                   \
        " setadmininfo: Sets the MsDos Directory listing flag ")  \


// Define command codes

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)       CmdCode,

typedef enum  _CmdCodes {
    DefineAllCommands()
    maxCmdCode
} CmdCodes;

#undef Cmd

// Define the functions and array of mappings

// General command function type
typedef BOOL ( * CMDFUNC)( int argc, char * argv[]);

typedef  struct _CmdStruct {
    CmdCodes    cmdCode;
    char *      pszCmdName;
    CMDFUNC     cmdFunc;
    char *      pszCmdComments;
} CmdStruct;


// Define Prototypes of command functions
# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)    \
    BOOL CmdFunc(int argc, char * argv[]);

// Cause an expansion to generate prototypes
// DefineAllCommands()
// Automatic generation causes a problem when we have NULL in Function ptrs :(
// Let the user explicitly define the prototypes

#undef Cmd

//
// Define the global array of commands
//

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)        \
    { CmdCode, CmdName, CmdFunc, CmdComments},

static CmdStruct   g_cmds[] = {

    DefineAllCommands()
    { maxCmdCode, NULL, NULL}       // sentinel command
};

#undef Cmd



/************************************************************
 *    Functions
 ************************************************************/

BOOL
GenUsageMessage( int argc, char * argv[])
{
    CmdStruct * pCmd;

    printf( " Usage:\n %s <server-name/address> <cmd name> <cmd arguments>\n",
            argv[0]);
    for( pCmd = g_cmds; pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {
        printf( "\t%s\t%s\n", pCmd->pszCmdName, pCmd->pszCmdComments);
    }

    return ( TRUE);
} // GenUsageMessage()



static
CmdStruct * DecodeCommand( char * pszCmd)
{
    CmdStruct * pCmd;
    if ( pszCmd != NULL) {

        for( pCmd = g_cmds;
             pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {

            if ( _stricmp( pszCmd, pCmd->pszCmdName) == 0) {
                 return ( pCmd);
            }
        } // for
    }

    return ( &g_cmds[0]);      // No match found, return usage message
} // DecodeCommand()



static
LPWSTR
ConvertToUnicode( char * psz)
/*++
    Converts a given string into unicode string (after allocating buffer space)
    Returns NULL on failure. Use GetLastError() for details.
--*/
{
    LPWSTR  pszUnicode;
    int     cch;

    cch = strlen( psz) + 1;
    pszUnicode = ( LPWSTR ) malloc( cch * sizeof( WCHAR));

    if ( pszUnicode != NULL) {

       // Success. Copy the string now
       int iRet;

       iRet = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                                   psz,    cch,
                                   pszUnicode,  cch);

       if ( iRet == 0 || iRet != cch) {

            free( pszUnicode);      // failure so free the block
            pszUnicode = NULL;
       }
    } else {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    }

    return ( pszUnicode);
} // ConvertToUnicode()


static
VOID
PrintStatisticsInfo( IN FTP_STATISTICS_0 * pStat)
{
    if ( pStat == NULL) {

        return ;
    }

    printf( " Printing Statistics Information: \n");

    printf( "%20s = %10.3g\n", "BytesSent",
           LargeIntegerToDouble(pStat->TotalBytesSent));
    printf( "%20s = %4.3g\n", "BytesReceived",
           LargeIntegerToDouble(pStat->TotalBytesReceived));
    printf( "%20s = %ld\n", "Files Sent ", pStat->TotalFilesSent);
    printf( "%20s = %ld\n", "Files Received ", pStat->TotalFilesReceived);

    printf( "%20s = %ld\n", "Current Anon Users",pStat->CurrentAnonymousUsers);
    printf( "%20s = %ld\n", "Current NonAnon",
           pStat->CurrentNonAnonymousUsers);

    printf( "%20s = %ld\n", "Total Anon Users", pStat->TotalAnonymousUsers);
    printf( "%20s = %ld\n", "Total NonAnon Users",
           pStat->TotalNonAnonymousUsers);

    printf( "%20s = %ld\n", "Max Anon Users", pStat->MaxAnonymousUsers);
    printf( "%20s = %ld\n", "Max NonAnon Users", pStat->MaxNonAnonymousUsers);

    printf( "%20s = %ld\n", "Current Connections", pStat->CurrentConnections);
    printf( "%20s = %ld\n", "Max Connections", pStat->MaxConnections);
    printf( "%20s = %ld\n", "Connection Attempts", pStat->ConnectionAttempts);
    printf( "%20s = %ld\n", "Logon Attempts", pStat->LogonAttempts);

    printf( "%20s = %s\n", "Time of Last Clear",
           asctime( localtime( (time_t *)&pStat->TimeOfLastClear ) ) );

    return;

} // PrintStatisticsInfo()



static
VOID
PrintStatsForTime( IN FTP_STATISTICS_0 *    pStatStart,
                   IN FTP_STATISTICS_0 *    pStatEnd,
                   IN DWORD sInterval)
/*++
  Print the statistics information over a time interval sInterval seconds.
  Arguments:
    pStatStart  pointer to statistics information for starting sample
    pStatEnd    pointer to statistics information for ending sample
    sInterval   Time interval in seconds for the sample

  Returns:
     None

--*/
{
    LARGE_INTEGER  liDiff;
    double dDiff;

    if ( pStatStart == NULL || pStatEnd == NULL || sInterval == 0 ) {

        return ;
    }

    printf( "Statistics  for Interval = %u seconds\n", sInterval);
    printf( "%20s\t %10s\t%10s\t%10s\t%6s\n\n",
           "Item   ", "Start Sample", "End Sample", "Difference", "Rate/s");

    liDiff.QuadPart = ( pStatEnd->TotalBytesSent.QuadPart -
                        pStatStart->TotalBytesSent.QuadPart);
    dDiff = LargeIntegerToDouble( liDiff);
    printf( "%20s\t %10.3g\t %10.3g\t %10.3g\t%6.3g\n",
           "Bytes Sent",
           LargeIntegerToDouble( pStatStart->TotalBytesSent),
           LargeIntegerToDouble( pStatEnd->TotalBytesSent),
           dDiff,
           dDiff/sInterval
           );

    liDiff.QuadPart = ( pStatEnd->TotalBytesReceived.QuadPart -
                        pStatStart->TotalBytesReceived.QuadPart);
    dDiff = LargeIntegerToDouble( liDiff);
    printf( "%20s\t %10.3g\t %10.3g\t %10.3g\t%6.3g\n",
           "Bytes Received",
           LargeIntegerToDouble(pStatStart->TotalBytesReceived),
           LargeIntegerToDouble(pStatEnd->TotalBytesReceived),
           dDiff,
           dDiff/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Files Sent ",
           pStatStart->TotalFilesSent,
           pStatEnd->TotalFilesSent,
           pStatEnd->TotalFilesSent - pStatStart->TotalFilesSent,
           (pStatEnd->TotalFilesSent - pStatStart->TotalFilesSent)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Files Received ",
           pStatStart->TotalFilesReceived,
           pStatEnd->TotalFilesReceived,
           pStatEnd->TotalFilesReceived - pStatStart->TotalFilesReceived,
           (pStatEnd->TotalFilesReceived -
            pStatStart->TotalFilesReceived)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Anon Users",
           pStatStart->CurrentAnonymousUsers,
           pStatEnd->CurrentAnonymousUsers,
           pStatEnd->CurrentAnonymousUsers - pStatStart->CurrentAnonymousUsers,
           (int ) (pStatEnd->CurrentAnonymousUsers -
                   pStatStart->CurrentAnonymousUsers)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current NonAnon Users",
           pStatStart->CurrentNonAnonymousUsers,
           pStatEnd->CurrentNonAnonymousUsers,
           (pStatStart->CurrentNonAnonymousUsers -
            pStatEnd->CurrentNonAnonymousUsers),
           (int ) (pStatStart->CurrentNonAnonymousUsers -
                   pStatEnd->CurrentNonAnonymousUsers)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Anon Users",
           pStatStart->TotalAnonymousUsers,
           pStatEnd->TotalAnonymousUsers,
           pStatEnd->TotalAnonymousUsers - pStatStart->TotalAnonymousUsers,
           (pStatEnd->TotalAnonymousUsers - pStatStart->TotalAnonymousUsers)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total NonAnon Users",
           pStatStart->TotalNonAnonymousUsers,
           pStatEnd->TotalNonAnonymousUsers,
           (pStatEnd->TotalNonAnonymousUsers -
            pStatStart->TotalNonAnonymousUsers),
           (pStatEnd->TotalNonAnonymousUsers -
            pStatStart->TotalNonAnonymousUsers)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Max Anon Users",
           pStatStart->MaxAnonymousUsers,
           pStatEnd->MaxAnonymousUsers,
           pStatEnd->MaxAnonymousUsers - pStatStart->MaxAnonymousUsers,
           (pStatEnd->MaxAnonymousUsers - pStatStart->MaxAnonymousUsers)
           /sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Max NonAnon Users",
           pStatStart->MaxNonAnonymousUsers,
           pStatEnd->MaxNonAnonymousUsers,
           pStatEnd->MaxNonAnonymousUsers - pStatStart->MaxNonAnonymousUsers,
           (pStatEnd->MaxNonAnonymousUsers - pStatStart->MaxNonAnonymousUsers)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Connections",
           pStatStart->CurrentConnections,
           pStatEnd->CurrentConnections,
           pStatEnd->CurrentConnections - pStatStart->CurrentConnections,
           (int )
           (pStatEnd->CurrentConnections - pStatStart->CurrentConnections)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Max Connections",
           pStatStart->MaxConnections,
           pStatEnd->MaxConnections,
           pStatEnd->MaxConnections - pStatStart->MaxConnections,
           (pStatEnd->MaxConnections - pStatStart->MaxConnections)/sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Connection Attempts",
           pStatStart->ConnectionAttempts,
           pStatEnd->ConnectionAttempts,
           pStatEnd->ConnectionAttempts - pStatStart->ConnectionAttempts,
           (pStatEnd->ConnectionAttempts - pStatStart->ConnectionAttempts)/
           sInterval
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Logon Attempts",
           pStatStart->LogonAttempts,
           pStatEnd->LogonAttempts,
           pStatEnd->LogonAttempts - pStatStart->LogonAttempts,
           (pStatEnd->LogonAttempts - pStatStart->LogonAttempts)/sInterval
           );


    printf( "%20s = %s\n", "Time of Last Clear",
           asctime( localtime( (time_t *)&pStatStart->TimeOfLastClear ) ) );

    return;

} // PrintStatsForTime()





static
VOID
PrintCommonStatisticsInfo( IN INET_INFO_STATISTICS_0 * pStat)
{
    DWORD i;

    if ( pStat == NULL) {

        return ;
    }

    printf( " Printing Common Statistics Information: \n");

    printf( "%20s = %d\n", "Cache Bytes Total",
           (pStat->CacheCtrs.CacheBytesTotal));
    printf( "%20s = %d\n", "Cache Bytes In Use",
           (pStat->CacheCtrs.CacheBytesInUse));
    printf( "%20s = %ld\n", "CurrentOpenFileHandles ",
           pStat->CacheCtrs.CurrentOpenFileHandles);
    printf( "%20s = %ld\n", "CurrentDirLists ",
           pStat->CacheCtrs.CurrentDirLists);
    printf( "%20s = %ld\n", "CurrentObjects ",
           pStat->CacheCtrs.CurrentObjects);
    printf( "%20s = %ld\n", "CurrentObjects ",
           pStat->CacheCtrs.CurrentObjects);
    printf( "%20s = %ld\n", "Cache Flushes ",
           pStat->CacheCtrs.FlushesFromDirChanges);
    printf( "%20s = %ld\n", "CacheHits ",
           pStat->CacheCtrs.CacheHits);
    printf( "%20s = %ld\n", "CacheMisses ",
           pStat->CacheCtrs.CacheMisses);


    printf( "%20s = %ld\n", "Atq Allowed Requests ",
           pStat->AtqCtrs.TotalAllowedRequests);
    printf( "%20s = %ld\n", "Atq Blocked Requests ",
           pStat->AtqCtrs.TotalBlockedRequests);
    printf( "%20s = %ld\n", "Atq Rejected Requests ",
           pStat->AtqCtrs.TotalRejectedRequests);
    printf( "%20s = %ld\n", "Atq Current Blocked Requests ",
           pStat->AtqCtrs.CurrentBlockedRequests);
    printf( "%20s = %ld\n", "Atq Measured Bandwidth ",
           pStat->AtqCtrs.MeasuredBandwidth);


#ifndef NO_AUX_PERF

    printf( " Auxiliary Counters # = %u\n",
           pStat->nAuxCounters);

    for ( i = 0; i < pStat->nAuxCounters; i++) {

        printf( "Aux Counter[%u] = %u\n", i, pStat->rgCounters[i]);

    } //for

#endif // NO_AUX_PERF

    return;

} // PrintStatisticsInfo()



static
VOID
PrintCommonStatsForTime( IN INET_INFO_STATISTICS_0 *    pStatStart,
                        IN INET_INFO_STATISTICS_0 *    pStatEnd,
                        IN DWORD sInterval)
/*++
  Print the statistics information over a time interval sInterval seconds.
  Arguments:
    pStatStart  pointer to statistics information for starting sample
    pStatEnd    pointer to statistics information for ending sample
    sInterval   Time interval in seconds for the sample

  Returns:
     None

--*/
{
    DWORD dwDiff;

    if ( pStatStart == NULL || pStatEnd == NULL || sInterval == 0 ) {

        return ;
    }

    printf( "Statistics  for Interval = %u seconds\n", sInterval);
    printf( "%20s\t %10s\t%10s\t%10s\t%6s\n\n",
           "Item   ", "Start Sample", "End Sample", "Difference", "Rate/s");

    dwDiff = (pStatEnd->CacheCtrs.CacheBytesTotal -
              pStatStart->CacheCtrs.CacheBytesTotal);
    printf( "%20s\t %10.3g\t %10ld\t %10ld\t%6ld\n",
           "Cache Bytes Total",
           (pStatStart->CacheCtrs.CacheBytesTotal),
           (pStatEnd->CacheCtrs.CacheBytesTotal),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CacheBytesInUse -
              pStatStart->CacheCtrs.CacheBytesInUse);
    printf( "%20s\t %10.3g\t %10ld\t %10ld\t%6ld\n",
           "Cache Bytes In Use",
           (pStatStart->CacheCtrs.CacheBytesInUse),
           (pStatEnd->CacheCtrs.CacheBytesInUse),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CurrentOpenFileHandles -
              pStatStart->CacheCtrs.CurrentOpenFileHandles);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "File Handle Cached ",
           (pStatStart->CacheCtrs.CurrentOpenFileHandles),
           (pStatEnd->CacheCtrs.CurrentOpenFileHandles),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CurrentDirLists -
              pStatStart->CacheCtrs.CurrentDirLists);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Dir Lists ",
           (pStatStart->CacheCtrs.CurrentDirLists),
           (pStatEnd->CacheCtrs.CurrentDirLists),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CurrentObjects -
              pStatStart->CacheCtrs.CurrentObjects);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Objects Cached",
           (pStatStart->CacheCtrs.CurrentObjects),
           (pStatEnd->CacheCtrs.CurrentObjects),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.FlushesFromDirChanges -
              pStatStart->CacheCtrs.FlushesFromDirChanges);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Cache Flushes",
           (pStatStart->CacheCtrs.FlushesFromDirChanges),
           (pStatEnd->CacheCtrs.FlushesFromDirChanges),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CacheHits -
              pStatStart->CacheCtrs.CacheHits);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Cache Hits",
           (pStatStart->CacheCtrs.CacheHits),
           (pStatEnd->CacheCtrs.CacheHits),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CacheMisses -
              pStatStart->CacheCtrs.CacheMisses);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Cache Misses",
           (pStatStart->CacheCtrs.CacheMisses),
           (pStatEnd->CacheCtrs.CacheMisses),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.TotalAllowedRequests -
              pStatStart->AtqCtrs.TotalAllowedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Atq Allowed Requests",
           (pStatStart->AtqCtrs.TotalAllowedRequests),
           (pStatEnd->AtqCtrs.TotalAllowedRequests),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.TotalBlockedRequests -
              pStatStart->AtqCtrs.TotalBlockedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Atq Blocked Requests",
           (pStatStart->AtqCtrs.TotalBlockedRequests),
           (pStatEnd->AtqCtrs.TotalBlockedRequests),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.TotalRejectedRequests -
              pStatStart->AtqCtrs.TotalRejectedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Atq Rejected Requests",
           (pStatStart->AtqCtrs.TotalRejectedRequests),
           (pStatEnd->AtqCtrs.TotalRejectedRequests),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.CurrentBlockedRequests -
              pStatStart->AtqCtrs.CurrentBlockedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Atq Blocked Requests",
           (pStatStart->AtqCtrs.CurrentBlockedRequests),
           (pStatEnd->AtqCtrs.CurrentBlockedRequests),
           dwDiff,
           dwDiff/sInterval
           );


    dwDiff = (pStatEnd->AtqCtrs.MeasuredBandwidth -
              pStatStart->AtqCtrs.MeasuredBandwidth);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Measured Bandwidth",
           (pStatStart->AtqCtrs.MeasuredBandwidth),
           (pStatEnd->AtqCtrs.MeasuredBandwidth),
           dwDiff,
           dwDiff/sInterval
           );

    return;

} // PrintStatisticsInfo()



BOOL
TestGetStatistics( int argc, char * argv[] )
/*++
   Gets Statistics from server and prints it.
   If the optional time information is given, then this function
   obtains the statistics, sleeps for specified time interval and then
    again obtains new statistics and prints the difference, neatly formatted.

   Arguments:
      argc = count of arguments
      argv  array of strings for command
            argv[0] = stats or getstatistics
            argv[1] = time interval if specified in seconds
--*/
{
    DWORD   err;
    DWORD   timeToSleep = 0;
    FTP_STATISTICS_0 *  pStat1 = NULL;  // this should be freed ? NYI

    if ( argc > 1 && argv[1] != NULL) {

        timeToSleep = atoi( argv[1]);
    }

    err = I_FtpQueryStatistics(g_lpszServerAddress,
                               0,
                               (LPBYTE *) &pStat1);

    if ( err == NO_ERROR) {

        if ( timeToSleep <= 0) {

            PrintStatisticsInfo( pStat1);
        } else {

            FTP_STATISTICS_0  *  pStat2 = NULL;

            printf( "Statistics For Time Interval %u seconds\n\n",
                   timeToSleep);

            Sleep( timeToSleep * 1000);   // sleep for the interval
            err = I_FtpQueryStatistics(g_lpszServerAddress,
                                       0,
                                       (LPBYTE *) &pStat2);

            if ( err == NO_ERROR) {

                PrintStatsForTime( pStat1, pStat2, timeToSleep);
            }

            if ( pStat2 != NULL) {

                MIDL_user_free( pStat2);
            }
        }
    }

    if ( pStat1 != NULL) {

        MIDL_user_free( pStat1);
    }

    SetLastError( err);
    return ( err == NO_ERROR);
} // TestGetStatistics()



BOOL
TestClearStatistics( int argc, char * argv[])
{
    DWORD   err;

    err = I_FtpClearStatistics(  g_lpszServerAddress);

    printf( "Cleared the statistics Err = %d\n", err);

    SetLastError( err);
    return ( err == NO_ERROR);
} // TestClearStatistics()



BOOL
TestGetCommonStatistics( int argc, char * argv[] )
/*++
   Gets common Statistics from server and prints it.
   If the optional time information is given, then this function
   obtains the statistics, sleeps for specified time interval and then
    again obtains new statistics and prints the difference, neatly formatted.

   Arguments:
      argc = count of arguments
      argv  array of strings for command
            argv[0] = stats or getstatistics
            argv[1] = time interval if specified in seconds
--*/
{
    DWORD   err;
    DWORD   timeToSleep = 0;
    INET_INFO_STATISTICS_0 *  pStat1 = NULL;

    if ( argc > 1 && argv[1] != NULL) {

        timeToSleep = atoi( argv[1]);
    }

    err = InetInfoQueryStatistics(g_lpszServerAddress,
                                  0,
                                  0,
                                  (LPBYTE *) &pStat1);

    if ( err == NO_ERROR) {

        if ( timeToSleep <= 0) {

            PrintCommonStatisticsInfo( pStat1);
        } else {

            INET_INFO_STATISTICS_0  *  pStat2 = NULL;

            printf( "Statistics For Time Interval %u seconds\n\n",
                   timeToSleep);

            Sleep( timeToSleep * 1000);   // sleep for the interval
            err = InetInfoQueryStatistics(g_lpszServerAddress,
                                       0,
                                       0,
                                       (LPBYTE *) &pStat2);

            if ( err == NO_ERROR) {

                PrintCommonStatsForTime( pStat1, pStat2, timeToSleep);
            }

            if ( pStat2 != NULL) {

                MIDL_user_free( pStat2);
            }
        }
    }

    if ( pStat1 != NULL) {

        MIDL_user_free( pStat1);
    }

    SetLastError( err);
    return ( err == NO_ERROR);
} // TestGetCommonStatistics()




static VOID
PrintAdminInformation( IN FTP_CONFIG_INFO * pConfigInfo)
{
    if ( pConfigInfo == NULL)
        return;

    printf( "\n Printing Config Information in %08x\n", pConfigInfo);
    printf( "%20s= %08x\n", "Field Control", pConfigInfo->FieldControl);

    printf( "%20s= %u\n", "AllowAnonymous",  pConfigInfo->fAllowAnonymous);
    printf( "%20s= %u\n", "AllowGuestAccess",pConfigInfo->fAllowGuestAccess);
    printf( "%20s= %u\n", "AnnotateDirectories",
           pConfigInfo->fAnnotateDirectories);
    printf( "%20s= %u\n", "Anonymous Only",  pConfigInfo->fAnonymousOnly);
    printf( "%20s= %u\n", "Listen Backlog",  pConfigInfo->dwListenBacklog);
    printf( "%20s= %u\n", "Lowercase files", pConfigInfo->fLowercaseFiles);
    printf( "%20s= %u\n", "MsDos Dir Output", pConfigInfo->fMsdosDirOutput);

    printf( "%20s= %S\n", "Home Directory",  pConfigInfo->lpszHomeDirectory);
    printf( "%20s= %S\n", "Greetings Message",
           pConfigInfo->lpszGreetingMessage);
    printf( "%20s= %S\n", "Exit Message",    pConfigInfo->lpszExitMessage);
    printf( "%20s= %S\n", "Max Clients Message",
           pConfigInfo->lpszMaxClientsMessage);

    return;
} // PrintAdminInformation()




static BOOL
TestGetAdminInfo( int argc, char * argv[] )
{
    DWORD err;
    FTP_CONFIG_INFO * pConfig = NULL;

    err = FtpGetAdminInformation( g_lpszServerAddress, &pConfig);

    printf( "FtpGetAdminInformation returned Error Code = %d\n", err);

    if ( err == NO_ERROR) {
        PrintAdminInformation( pConfig);
        MIDL_user_free( ( LPVOID) pConfig);
    }


    SetLastError( err);
    return ( err == NO_ERROR);
} // TestGetAdminInfo()


DWORD
SetAdminField(
    IN FTP_CONFIG_INFO  * pConfigIn,
    IN char * pszSubCmd,
    IN char * pszValue)
{
    DWORD err = NO_ERROR;
    CmdStruct * pCmd = DecodeCommand( pszSubCmd); // get command struct

    if ( pCmd == NULL) {
        // ignore invalid commands
        printf( " Invalid SubCommand for set admin info %s. Ignoring...\n",
                pszSubCmd);
        return ( ERROR_INVALID_PARAMETER);
    }

    switch ( pCmd->cmdCode) {

      case CmdMaxClientsMessage:
        SetField( pConfigIn->FieldControl, FC_FTP_MAX_CLIENTS_MESSAGE);
        pConfigIn->lpszMaxClientsMessage = ConvertToUnicode( pszValue);
        if ( pConfigIn->lpszMaxClientsMessage == NULL) {
            err = GetLastError();
        }
        break;

      case CmdExitMessage:
        SetField( pConfigIn->FieldControl, FC_FTP_EXIT_MESSAGE);
        pConfigIn->lpszExitMessage = ConvertToUnicode( pszValue);
        if ( pConfigIn->lpszExitMessage == NULL) {
            err = GetLastError();
        }
        break;

      case CmdGreetingMessage:
        SetField( pConfigIn->FieldControl, FC_FTP_GREETING_MESSAGE);
        pConfigIn->lpszGreetingMessage = ConvertToUnicode( pszValue);
        if ( pConfigIn->lpszGreetingMessage == NULL) {
            err = GetLastError();
        }
        break;

      case CmdAllowAnonymous:
        SetField( pConfigIn->FieldControl, FC_FTP_ALLOW_ANONYMOUS);
        pConfigIn->fAllowAnonymous = (atoi(pszValue) == 1);
        break;

      case CmdAllowGuest:
        SetField( pConfigIn->FieldControl, FC_FTP_ALLOW_GUEST_ACCESS);
        pConfigIn->fAllowGuestAccess = (atoi(pszValue) == 1);
        break;

      case CmdAllowAnonOnly:
        SetField( pConfigIn->FieldControl, FC_FTP_ANONYMOUS_ONLY);
        pConfigIn->fAnonymousOnly = (atoi(pszValue) == 1);
        break;

      case CmdAnnotateDirs:
        SetField( pConfigIn->FieldControl, FC_FTP_ANNOTATE_DIRECTORIES);
        pConfigIn->fAnnotateDirectories = (atoi(pszValue) == 1);
        break;

      case CmdListenBacklog:
        SetField( pConfigIn->FieldControl, FC_FTP_LISTEN_BACKLOG);
        pConfigIn->dwListenBacklog = atoi(pszValue);
        break;

      case CmdMsdosDir:
        SetField( pConfigIn->FieldControl, FC_FTP_MSDOS_DIR_OUTPUT);
        pConfigIn->fMsdosDirOutput = (atoi(pszValue) == 1);
        break;


      default:
        printf( " Invalid Sub command %s for SetConfigInfo(). Ignoring.\n",
               pszSubCmd);
        err = ERROR_INVALID_PARAMETER;
        break;

    }  // switch


    return ( err);
} // SetAdminField()




BOOL
TestSetAdminInfo( int argc, char * argv[])
/*++
    Arguments:
        argc = count of arguments
        argv  array of strings for command
            argv[0] = setadmininfo
            argv[1] = sub function within set info for testing
            argv[2] = value for sub function
 for all information to be set, give <sub command name> <value>
--*/
{
    DWORD err = ERROR_CALL_NOT_IMPLEMENTED;
    FTP_CONFIG_INFO * pConfigOut = NULL;  // config value obtained from server

    if ( argc < 1 || ( (argc & 0x1) != 0x1 ) ) {  // argc should be > 1 and odd

        printf( "Invalid Number of arguments for %s\n", argv[0]);
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    // Get the config from server to start with
    err = FtpGetAdminInformation( g_lpszServerAddress, &pConfigOut);
    if ( err != NO_ERROR) {

        printf( " GetAdminInformation()  failed with error = %u\n",
               err);
        SetLastError( err);
        return (FALSE);
    }

    // extract each field and value to set in configIn

    for( ; --argc > 1; argc -= 2) {

        if ( (err = SetAdminField( pConfigOut, argv[argc - 1], argv[argc]) )
             != NO_ERROR)  {

            break;
        }

    } // for() to extract and set all fields

    if ( err == NO_ERROR) {
        // Now make RPC call to set the fields
        err = FtpSetAdminInformation( g_lpszServerAddress,
                                     pConfigOut);
    }

    MIDL_user_free( pConfigOut);
    SetLastError( err );
    return ( err == NO_ERROR );
} // TestSetAdminInfo()




static VOID
PrintInetAdminInformation( IN LPINETA_CONFIG_INFO  pConfigInfo)
{
    if ( pConfigInfo == NULL)
        return;

    printf( "\n Printing InetA Config Information in %08x\n", pConfigInfo);
    printf( "%20s= %d\n", "LogAnonymous",   pConfigInfo->fLogAnonymous);
    printf( "%20s= %d\n", "LogNonAnonymous",pConfigInfo->fLogNonAnonymous);
    printf( "%20s= %08x\n", "Authentication Flags",
           pConfigInfo->dwAuthentication);

    printf( "%20s= %d\n", "Port",           pConfigInfo->sPort);
    printf( "%20s= %d\n", "Connection Timeout",
           pConfigInfo->dwConnectionTimeout);
    printf( "%20s= %d\n",  "Max Connections",
           pConfigInfo->dwMaxConnections);

    printf( "%20s= %S\n", "AnonUserName",
           pConfigInfo->lpszAnonUserName);
    printf( "%20s= %S\n", "AnonPassword",
           pConfigInfo->szAnonPassword);

    printf( "%20s= %S\n", "Admin Name",
           pConfigInfo->lpszAdminName);
    printf( "%20s= %S\n", "Admin Email",
           pConfigInfo->lpszAdminEmail);
    printf( "%20s= %S\n", "Server Comments",
           pConfigInfo->lpszServerComment);

    //
    // IP lists and Grant lists, Virtual Roots are not included now. Later.
    //

    return;
} // PrintInetAdminInformation()


static DWORD
GetServiceIdFromString( IN LPCSTR pszService)
{
    if ( pszService != NULL) {

        if ( !_stricmp(pszService, "HTTP")) {
            return ( INET_HTTP_SVC_ID);

        } else if (!_stricmp( pszService, "GOPHER")) {

            return (INET_GOPHER_SVC_ID);
        } else if ( !_stricmp( pszService, "FTP")) {

            return (INET_FTP_SVC_ID);
        } else if ( !_stricmp( pszService, "DNS")) {

            return (INET_DNS_SVC_ID);
        }
    }

    return ( INET_HTTP_SVC_ID);
} // GetServiceIdFromString()



static BOOL
TestInetGetAdminInfo( int argc, char * argv[] )
/*++
   Gets the configuration information using InetInfoGetAdminInformation()
   argv[0] = igetadmininfo
   argv[1] = service name  ( gopher, http, ftp, catapult)

--*/
{
    DWORD err;
    LPINETA_CONFIG_INFO  pConfig = NULL;
    DWORD dwServiceId;

    printf( " InetInfoGetAdminInformation() called at: Time = %d\n",
            GetTickCount());

    dwServiceId = (argc > 1) ? GetServiceIdFromString( argv[1]) : INET_HTTP_SVC_ID;

    err = InetInfoGetAdminInformation( g_lpszServerAddress,
                                    dwServiceId,
                                   &pConfig);

    printf( "Finished at Time = %d\n", GetTickCount());
    printf( "InetInfoGetAdminInformation returned Error Code = %d\n", err);

    if ( err == NO_ERROR) {
        PrintInetAdminInformation( pConfig);
        MIDL_user_free( ( LPVOID) pConfig);
    }


    SetLastError( err);
    return ( err == NO_ERROR);
} // TestInetGetAdminInfo()


DWORD
SetInetAdminField(
    IN LPINETA_CONFIG_INFO  pConfigIn,
    IN char * pszSubCmd,
    IN char * pszValue)
{
    DWORD err = NO_ERROR;
    CmdStruct * pCmd = DecodeCommand( pszSubCmd); // get command struct

    if ( pCmd == NULL) {
        // ignore invalid commands
        printf( " Invalid SubCommand for set admin info %s. Ignoring...\n",
                pszSubCmd);
        return ( ERROR_INVALID_PARAMETER);
    }

    switch ( pCmd->cmdCode) {

        case CmdPortNumber:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_PORT_NUMBER);
            pConfigIn->sPort = atoi( pszValue);
            break;

        case CmdConnectionTimeout:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_CONNECTION_TIMEOUT);
            pConfigIn->dwConnectionTimeout = atoi( pszValue);
            break;

        case CmdMaxConnections:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_MAX_CONNECTIONS);
            pConfigIn->dwMaxConnections = atoi( pszValue);
            break;

          case CmdLogAnonymous:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_LOG_ANONYMOUS);
            pConfigIn->fLogAnonymous = atoi( pszValue);
            break;

          case CmdLogNonAnonymous:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_LOG_NONANONYMOUS);
            pConfigIn->fLogNonAnonymous = atoi( pszValue);
            break;

          case CmdAnonUserName:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_ANON_USER_NAME);
            pConfigIn->lpszAnonUserName = ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszAnonUserName == NULL) {
                err = GetLastError();
            }
            break;

          case CmdAdminName:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_ADMIN_NAME);
            pConfigIn->lpszAdminName =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszAdminName == NULL) {
                err = GetLastError();
            }
            break;

          case CmdAdminEmail:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_ADMIN_EMAIL);
            pConfigIn->lpszAdminEmail =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszAdminEmail == NULL) {
                err = GetLastError();
            }
            break;

          case CmdServerComment:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_SERVER_COMMENT);
            pConfigIn->lpszServerComment =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszServerComment == NULL) {
                err = GetLastError();
            }
            break;


        default:
            printf( " Invalid Sub command %s for SetConfigInfo(). Ignoring.\n",
                    pszSubCmd);
            err = ERROR_INVALID_PARAMETER;
            break;

    }  // switch


    return ( err);
} // SetAdminField()


static VOID
FreeBuffer( IN PVOID * ppBuffer)
{
    if ( *ppBuffer != NULL) {
        free( * ppBuffer);
        *ppBuffer = NULL;       // reset the old value
    }
    return;
} // FreeBuffer()

VOID
FreeStringsInInetConfigInfo( IN OUT LPINETA_CONFIG_INFO pConfigInfo)
{
    FreeBuffer( (PVOID *) & pConfigInfo->lpszAnonUserName);

} // FreeStringsInInetConfigInfo()


BOOL
TestInetSetAdminInfo( int argc, char * argv[])
/*++
    Arguments:
        argc = count of arguments
        argv  array of strings for command
            argv[0] = isetadmininfo
            argv[1] = sub function within set info for testing
            argv[2] = value for sub function
 for all information to be set, give <sub command name> <value>
--*/
{
    DWORD err = ERROR_CALL_NOT_IMPLEMENTED;
    LPINETA_CONFIG_INFO  * ppConfigOut = NULL;
    INETA_CONFIG_INFO  configIn;   // config values that are set

    if ( argc < 1 || ( (argc & 0x1) != 0x1 ) ) {  // argc should be > 1 and odd

        printf( "Invalid Number of arguments for %s\n", argv[0]);
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // form the admin info block to set the information
    //
    memset( ( LPVOID) &configIn, 0, sizeof( configIn)); // init to Zeros

    // extract each field and value to set in configIn

    for( ; --argc > 1; argc -= 2) {

        if ( SetInetAdminField( &configIn, argv[argc - 1], argv[argc])
             != NO_ERROR)  {

            break;
        }

    } // for() to extract and set all fields

    if ( err != NO_ERROR) {
        // Now make RPC call to set the fields
        err = InetInfoSetAdminInformation( g_lpszServerAddress,
                                          INET_HTTP_SVC_ID,
                                          &configIn);
    }

    // Need to free all the buffers allocated for the strings
    FreeStringsInInetConfigInfo( &configIn);

    SetLastError( err );
    return ( err == NO_ERROR );
} // TestSetInetAdminInfo()



BOOL
TestEnumUserInfo( int argc, char * argv[])
{

    DWORD   err;
    FTP_USER_INFO  * pUserInfo;
    DWORD           cEntries;

    printf( "Invoking FtpEnumerateUsers..." );

    err = I_FtpEnumerateUsers(g_lpszServerAddress,
                              &cEntries,
                              &pUserInfo );

    if( err == NO_ERROR )
    {
        printf( " %lu connected users\n", cEntries );

        while( cEntries-- )
        {
            IN_ADDR addr;
            DWORD   tConn;

            addr.s_addr = (u_long)pUserInfo->inetHost;

            printf( "idUser     = %lu\n"
                   "pszUser    = %S\n"
                   "fAnonymous = %lu\n"
                   "inetHost   = %s\n",
                   pUserInfo->idUser,
                   pUserInfo->pszUser,
                   pUserInfo->fAnonymous,
                   inet_ntoa( addr ));
            tConn = pUserInfo->tConnect;

            printf( " tConnect = %lu:%lu:%lu (%lu seconds)\n",
                   tConn/3600,
                   (tConn%3600)/60,
                   tConn % 60,
                   tConn);

            pUserInfo++;
        }
    }

    SetLastError( err);
    return ( err == NO_ERROR);

} // TestEnumUserInfo()



BOOL
TestDisconnectUser( int argc, char * argv[])
{
    DWORD  idUser;
    DWORD  err;
    LPCSTR pszUserId = argv[1];

    idUser = (DWORD ) strtoul( pszUserId, NULL, 0);

    err = I_FtpDisconnectUser( g_lpszServerAddress, idUser);

    SetLastError(err);
    return (err == NO_ERROR);

} // TestDisconnectUser()


int __cdecl
main( int argc, char * argv[])
{
    DWORD err = NO_ERROR;
    char ** ppszArgv;       // arguments for command functions
    int     cArgs;           // arg count for command functions
    char * pszCmdName;
    CmdStruct  * pCmd;
    CMDFUNC pCmdFunc = NULL;

    if ( argc < 3 || argv[1] == NULL ) {

      // Insufficient arguments
       GenUsageMessage( argc, argv);
       return ( 1);
    }

    pszCmdName = argv[2];
    if (( pCmd = DecodeCommand( pszCmdName)) == NULL || pCmd->cmdFunc == NULL) {
        printf( "Internal Error: Invalid Command %s\n", pszCmdName);
        GenUsageMessage( argc, argv);
        return ( 1);
    }

    g_lpszServerAddress = ConvertToUnicode( argv[1]);   // get server address

    cArgs = argc - 2;
    ppszArgv = argv + 2;     // position at the start of the command name

    if ( !(*pCmd->cmdFunc)( cArgs, ppszArgv)) {     // call the test function

        // Test function failed.
        printf( "Command %s failed. Error = %d\n", pszCmdName, GetLastError());
        return ( 1);
    }

    printf( " Command %s succeeded\n", pszCmdName);
    return ( 0);        // success

} // main()





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\client\ftpsvc_c_stub.c ===
#include "ftpsvc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\mib\mib.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mib.h

Abstract:

    SNMP Extension Agent for Windows NT.

Created:

    18-Feb-1995

Revision History:

--*/

#ifndef _MIB_H_
#define _MIB_H_


//
//  Required include files.
//

#include <windows.h>
#include <snmp.h>

#include <lm.h>
#include <iisinfo.h>
#include <iis64.h>


//
//  MIB Specifics.
//

#define MIB_PREFIX_LEN            MIB_OidPrefix.idLength


//
//  MIB function actions.
//

#define MIB_GET         ASN_RFC1157_GETREQUEST
#define MIB_SET         ASN_RFC1157_SETREQUEST
#define MIB_GETNEXT     ASN_RFC1157_GETNEXTREQUEST
#define MIB_GETFIRST    (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0)


//
//  MIB Variable access privileges.
//

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS           3


//
//  Macro to determine number of sub-oid's in array.
//

#define OID_SIZEOF( Oid )      ( sizeof Oid / sizeof(UINT) )


//
//  Prefix to every variable in the MIB.
//

extern AsnObjectIdentifier MIB_OidPrefix;


//
//  Function Prototypes.
//

UINT
ResolveVarBind(
    RFC1157VarBind     * VarBind,
    UINT                 PduAction,
    LPVOID               Statistics
    );

#endif  // _MIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\client\ftpstub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ftpstub.c

Abstract:

    Client stubs of the FTP Daemon APIs.

Author:

    Dan Hinsley (DanHi) 23-Mar-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "ftpsvc.h" // FTP_USER_ENUM_STRUCT


NET_API_STATUS
I_FtpEnumerateUsers(
    IN LPWSTR   Server OPTIONAL,
    OUT LPDWORD  EntriesRead,
    OUT LPFTP_USER_INFO * Buffer
    )
{
    NET_API_STATUS status;
    FTP_USER_ENUM_STRUCT EnumStruct;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = I_FtprEnumerateUsers(
                     Server,
                     &EnumStruct
                     );
        *EntriesRead = EnumStruct.EntriesRead;
        *Buffer = EnumStruct.Buffer;

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

}


NET_API_STATUS
I_FtpDisconnectUser(
    IN LPWSTR  Server OPTIONAL,
    IN DWORD   User
    )

{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = I_FtprDisconnectUser(
                     Server,
                     User
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

}


NET_API_STATUS
I_FtpQueryVolumeSecurity(
    IN LPWSTR  Server OPTIONAL,
    OUT LPDWORD ReadAccess,
    OUT LPDWORD WriteAccess
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = I_FtprQueryVolumeSecurity(
                     Server,
                     ReadAccess,
                     WriteAccess
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

}


NET_API_STATUS
I_FtpSetVolumeSecurity(
    IN LPWSTR Server OPTIONAL,
    IN DWORD  ReadAccess,
    IN DWORD  WriteAccess
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = I_FtprSetVolumeSecurity(
                     Server,
                     ReadAccess,
                     WriteAccess
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

}


NET_API_STATUS
I_FtpQueryStatistics(
    IN LPWSTR Server OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE * Buffer
    )
{
    NET_API_STATUS status;

    *Buffer = NULL;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = I_FtprQueryStatistics(
                     Server,
                     Level,
                     (LPSTATISTICS_INFO)Buffer
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

}


NET_API_STATUS
I_FtpClearStatistics(
    IN LPWSTR Server OPTIONAL
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = I_FtprClearStatistics(
                     Server
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

}


NET_API_STATUS
NET_API_FUNCTION
FtpGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    OUT LPFTP_CONFIG_INFO *   ppConfig
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        //  Try RPC (local or remote) version of API.
        //
        status = FtprGetAdminInformation(
                     pszServer,
                     ppConfig
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);
}

NET_API_STATUS
NET_API_FUNCTION
FtpSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  LPFTP_CONFIG_INFO   pConfig
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        //  Try RPC (local or remote) version of API.
        //
        status = FtprSetAdminInformation(
                     pszServer,
                     pConfig
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\perfmon\debug.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    debug.c

    This module contains debug support routines for the FTPD Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.

*/


#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"


#if DBG

//
//  Private constants.
//

#define MAX_PRINTF_OUTPUT       1024            // characters
#define FTPD_OUTPUT_LABEL       "FTPD"


//
//  Private types.
//


//
//  Private globals.
//


//
//  Public functions.
//

/*******************************************************************

    NAME:       FtpdAssert

    SYNOPSIS:   Called if an assertion fails.  Displays the failed
                assertion, file name, and line number.  Gives the
                user the opportunity to ignore the assertion or
                break into the debugger.

    ENTRY:      pAssertion - The text of the failed expression.

                pFileName - The containing source file.

                nLineNumber - The guilty line number.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
void FtpdAssert( void  * pAssertion,
                 void  * pFileName,
                 long    nLineNumber )
{
    char szOutput[MAX_PRINTF_OUTPUT];

    sprintf( szOutput,
             "\n*** Assertion failed: %s\n***   Source File: %s, line %ld\n\n",
             pAssertion,
             pFileName,
             nLineNumber );

    OutputDebugString( szOutput );
    DebugBreak();

}   // FtpdAssert

/*******************************************************************

    NAME:       FtpdPrintf

    SYNOPSIS:   Customized debug output routine.

    ENTRY:      Usual printf-style parameters.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
void FtpdPrintf( char * pszFormat,
                 ... )
{
    char    szOutput[MAX_PRINTF_OUTPUT];
    va_list ArgList;

    sprintf( szOutput,
             "%s (%lu): ",
             FTPD_OUTPUT_LABEL,
             GetCurrentThreadId() );

    va_start( ArgList, pszFormat );
    vsprintf( szOutput + strlen(szOutput), pszFormat, ArgList );
    va_end( ArgList );

    IF_DEBUG( OUTPUT_TO_DEBUGGER )
    {
        OutputDebugString( szOutput );
    }

}   // FtpdPrintf


//
//  Private functions.
//

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

!INCLUDE $(NTMAKEENV)\makefile.plt

IDL_NAME = ftpsvc

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

C_DEFINES=-D_INETASRV_H_

SDKINC = $(BASEDIR)\public\sdk\inc
INETINC = ..\..\..\inc
SDKCRTINC = $(BASEDIR)\public\sdk\inc\crt

INCS  = -I$(SDKINC)  -I$(SDKCRTINC) -I$(INETINC)

# Treat warnings as errors
MSC_WARNING_LEVEL = /W3 /WX

CLIENT_TARGETS =   $(O)\$(IDL_NAME)_c.c\
                   $(O)\$(IDL_NAME).h

SERVER_TARGETS =   $(O)\$(IDL_NAME)_s.c


EXTRN_DEPENDS = $(IDL_NAME).acf                         \
                $(INETINC)\infoimp.h                     \
                $(INETINC)\ftpd.h                        \
                $(INETINC)\inetinfo.h                    \
                $(INETINC)\inetcom.h

CPP = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES)

#
# Define Products and Dependencies
#

all:    $(CLIENT_TARGETS) $(SERVER_TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF


#
# MIDL COMPILE
#

$(CLIENT_TARGETS) : .\$(IDL_NAME).idl $(EXTRN_DEPENDS)
    midl -Oicf -robust -server none -oldnames -error allocation -error ref -out .\$(O) -ms_ext -c_ext $(CPP) .\$(IDL_NAME).idl $(INCS)

$(SERVER_TARGETS) : .\$(IDL_NAME).idl $(EXTRN_DEPENDS)
    midl -Oicf -robust -client none -oldnames -error allocation -error ref -out .\$(O) -ms_ext -c_ext $(CPP) .\$(IDL_NAME).idl $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\mib\main.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    main.c

Abstract:

    SNMP Extension Agent for Windows NT.

Created:

    18-Feb-1995

Revision History:

    Murali R. Krishnan (MuraliK) 16-Nov-1995  Removed undoc apis

--*/

#include "mib.h"
#include "apiutil.h"


//
//  Extension Agent DLLs need access to elapsed time agent has been active.
//  This is implemented by initializing the Extension Agent with a time zero
//  reference, and allowing the agent to compute elapsed time by subtracting
//  the time zero reference from the current system time.  This example
//  Extension Agent implements this reference with dwTimeZero.
//

DWORD dwTimeZero = 0;


//
//  Extension Agent DLLs provide the following entry point to coordinate the
//  initializations of the Extension Agent and the Extendible Agent.  The
//  Extendible Agent provides the Extension Agent with a time zero reference;
//  and the Extension Agent provides the Extendible Agent with an Event handle
//  for communicating occurence of traps, and an object identifier representing
//  the root of the MIB subtree that the Extension Agent supports.
//

BOOL
SnmpExtensionInit(
    DWORD                 dwTimeZeroReference,
    HANDLE              * hPollForTrapEvent,
    AsnObjectIdentifier * supportedView
    )
{
    //
    //  Record the time reference provided by the Extendible Agent.
    //

    dwTimeZero = dwTimeZeroReference;

    //
    //  Indicate the MIB view supported by this Extension Agent, an object
    //  identifier representing the sub root of the MIB that is supported.
    //

    *supportedView = MIB_OidPrefix; // NOTE!  structure copy

    //
    //  Indicate that Extension Agent initialization was sucessfull.
    //

    return TRUE;

}   // SnmpExtensionInit

//
//  Extension Agent DLLs provide the following entry point to communcate traps
//  to the Extendible Agent.  The Extendible Agent will query this entry point
//  when the trap Event (supplied at initialization time) is asserted, which
//  indicates that zero or more traps may have occured.  The Extendible Agent
//  will repetedly call this entry point until FALSE is returned, indicating
//  that all outstanding traps have been processed.
//

BOOL
SnmpExtensionTrap(
    AsnObjectIdentifier * enterprise,
    AsnInteger          * genericTrap,
    AsnInteger          * specificTrap,
    AsnTimeticks        * timeStamp,
    RFC1157VarBindList  * variableBindings
    )
{
    //
    //  We don't support traps (yet).
    //

    return FALSE;

}   // SnmpExtensionTrap

//
//  Extension Agent DLLs provide the following entry point to resolve queries
//  for MIB variables in their supported MIB view (supplied at initialization
//  time).  The requestType is Get/GetNext/Set.
//

BOOL
SnmpExtensionQuery(
    BYTE                 requestType,
    RFC1157VarBindList * variableBindings,
    AsnInteger         * errorStatus,
    AsnInteger         * errorIndex
    )
{
    LPFTP_STATISTICS_0 Statistics = NULL;
    NET_API_STATUS     Status;
    UINT               i;

    //
    //  Try to query the statistics now so we'll have a consitent
    //  view across all variable bindings.
    //

    Status = FtpQueryStatistics2( NULL,                    // pszServer
                                  0,                       // Level,
                                  INET_INSTANCE_GLOBAL,
                                  0,
                                  (LPBYTE *)&Statistics );

    try
    {
        //
        //  Iterate through the variable bindings list to resolve individual
        //  variable bindings.
        //

        for( i = 0 ; i < variableBindings->len ; i++ )
        {
            *errorStatus = ResolveVarBind( &variableBindings->list[i],
                                           requestType,
                                           Statistics );

            //
            //  Test and handle case where Get Next past end of MIB view
            //  supported by this Extension Agent occurs.  Special
            //  processing is required to communicate this situation to
            //  the Extendible Agent so it can take appropriate action,
            //  possibly querying other Extension Agents.
            //

            if( ( *errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ) &&
                ( requestType == MIB_GETNEXT ) )
            {
                *errorStatus = SNMP_ERRORSTATUS_NOERROR;

                //
                //  Modify variable binding of such variables so the OID
                //  points just outside the MIB view supported by this
                //  Extension Agent.  The Extendible Agent tests for this,
                //  and takes appropriate action.
                //

               SNMP_oidfree( &variableBindings->list[i].name );
               SNMP_oidcpy( &variableBindings->list[i].name, &MIB_OidPrefix );
               variableBindings->list[i].name.ids[MIB_PREFIX_LEN-1]++;
            }

            //
            //  If an error was indicated, communicate error status and error
            //  index to the Extendible Agent.  The Extendible Agent will
            //  ensure that the origional variable bindings are returned in
            //  the response packet.

            if( *errorStatus != SNMP_ERRORSTATUS_NOERROR )
            {
                *errorIndex = i+1;
            }
            else
            {
                *errorIndex = 0;
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  For now do nothing.
        //
    }

    //
    //  Free the statistics structure if we managed to actually get one.
    //

    if( Statistics != NULL )
    {
        MIDL_user_free( (LPVOID)Statistics );
    }

    return SNMPAPI_NOERROR;

}   // SnmpExtensionQuery
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\mib\mib.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mib.c

Abstract:

    SNMP Extension Agent for Windows NT.

Created:

    18-Feb-1995

Revision History:

--*/

#include "mib.h"


//
//  Private constants & macros.
//

//
//  This macro creates a MIB_ENTRY for a MIB group header.
//

#define MIB_ENTRY_HEADER(oid)                           \
            {                                           \
                { OID_SIZEOF(oid), (oid) },             \
                -1,                                     \
                MIB_NOACCESS,                           \
                NULL,                                   \
                ASN_RFC1155_OPAQUE,                     \
            }

//
//  This macro creates a generic MIB_ENTRY for a MIB variable.
//

#define MIB_ENTRY_ITEM(oid,field,type)                  \
            {                                           \
                { OID_SIZEOF(oid), (oid) },             \
                FIELD_OFFSET(FTP_STATISTICS_0,field),   \
                MIB_ACCESS_READ,                        \
                MIB_Stat,                               \
                (type),                                 \
            }

//
//  These macros create COUNTER and INTEGER type MIB_ENTRYs.
//

#define MIB_COUNTER(oid,field)              \
            MIB_ENTRY_ITEM(oid, field, ASN_RFC1155_COUNTER)

#define MIB_INTEGER(oid,field)              \
            MIB_ENTRY_ITEM(oid, field, ASN_INTEGER)


//
//  Private types.
//

typedef UINT (*LPMIBFUNC)( UINT                 Action,
                           struct _MIB_ENTRY  * MibPtr,
                           RFC1157VarBind     * VarBind,
                           LPVOID               Statistics
                           );

typedef struct _MIB_ENTRY
{
    //
    //  The OID for this MIB variable.
    //

    AsnObjectIdentifier Oid;

    //
    //  The offset within the statistics structure for this
    //  variable.
    //

    LONG                FieldOffset;

    //
    //  Access type (read, write, read-write, none).
    //

    UINT                Access;

    //
    //  Pointer to a function that manages this variable.
    //

    LPMIBFUNC           MibFunc;

    //
    //  Type (integer, counter, gauge, etc.)
    //

    BYTE                Type;

} MIB_ENTRY;


//
//  Private globals.
//

//
//  The InternetServer section of the OID tree is organized as follows:
//
//      iso(1)
//          org(3)
//              dod(6)
//                  internet(1)
//                      private(4)
//                          enterprises(1)
//                              microsoft(311)
//                                  software(1)
//                                      InternetServer(7)
//                                          InetSrvCommon(1)
//                                              InetSrvStatistics(1)
//                                          FtpServer(2)
//                                              FtpStatistics(1)
//                                          W3Server(3)
//                                              W3Statistics(1)
//                                          GopherServer(4)
//                                              GopherStatistics(1)
//

UINT                OID_Prefix[]  = { 1, 3, 6, 1, 4, 1, 311, 1, 7, 2 };
AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };


//
//  OID definitions.
//
//  All leaf variables have a zero appended to their OID to indicate
//  that it is the only instance of this variable and that it exists.
//

UINT MIB_Statistics[]                   = { 1 };
UINT MIB_TotalBytesSent_HighWord[]      = { 1,  1, 0 };
UINT MIB_TotalBytesSent_LowWord[]       = { 1,  2, 0 };
UINT MIB_TotalBytesReceived_HighWord[]  = { 1,  3, 0 };
UINT MIB_TotalBytesReceived_LowWord[]   = { 1,  4, 0 };
UINT MIB_TotalFilesSent[]               = { 1,  5, 0 };
UINT MIB_TotalFilesReceived[]           = { 1,  6, 0 };
UINT MIB_CurrentAnonymousUsers[]        = { 1,  7, 0 };
UINT MIB_CurrentNonAnonymousUsers[]     = { 1,  8, 0 };
UINT MIB_TotalAnonymousUsers[]          = { 1,  9, 0 };
UINT MIB_TotalNonAnonymousUsers[]       = { 1, 10, 0 };
UINT MIB_MaxAnonymousUsers[]            = { 1, 11, 0 };
UINT MIB_MaxNonAnonymousUsers[]         = { 1, 12, 0 };
UINT MIB_CurrentConnections[]           = { 1, 13, 0 };
UINT MIB_MaxConnections[]               = { 1, 14, 0 };
UINT MIB_ConnectionAttempts[]           = { 1, 15, 0 };
UINT MIB_LogonAttempts[]                = { 1, 16, 0 };


//
//  Private prototypes.
//

UINT
MIB_leaf_func(
    UINT                 Action,
    MIB_ENTRY          * MibPtr,
    RFC1157VarBind     * VarBind,
    LPVOID               Statistics
    );


UINT
MIB_Stat(
    UINT                 Action,
    MIB_ENTRY          * MibPtr,
    RFC1157VarBind     * VarBind,
    LPVOID               Statistics
    );

UINT
GetNextVar(
    RFC1157VarBind     * VarBind,
    MIB_ENTRY          * MibPtr,
    LPVOID               Statistics
    );


//
//  MIB definiton
//

MIB_ENTRY Mib[] =
    {
        //
        //  Statistics.
        //

        MIB_ENTRY_HEADER( MIB_Statistics ),
        MIB_COUNTER( MIB_TotalBytesSent_HighWord,     TotalBytesSent.HighPart ),
        MIB_COUNTER( MIB_TotalBytesSent_LowWord,      TotalBytesSent.LowPart ),
        MIB_COUNTER( MIB_TotalBytesReceived_HighWord, TotalBytesReceived.HighPart ),
        MIB_COUNTER( MIB_TotalBytesReceived_LowWord,  TotalBytesReceived.LowPart ),
        MIB_COUNTER( MIB_TotalFilesSent,              TotalFilesSent ),
        MIB_COUNTER( MIB_TotalFilesReceived,          TotalFilesReceived ),
        MIB_INTEGER( MIB_CurrentAnonymousUsers,       CurrentAnonymousUsers ),
        MIB_INTEGER( MIB_CurrentNonAnonymousUsers,    CurrentNonAnonymousUsers ),
        MIB_COUNTER( MIB_TotalAnonymousUsers,         TotalAnonymousUsers ),
        MIB_COUNTER( MIB_TotalNonAnonymousUsers,      TotalNonAnonymousUsers ),
        MIB_COUNTER( MIB_MaxAnonymousUsers,           MaxAnonymousUsers ),
        MIB_COUNTER( MIB_MaxNonAnonymousUsers,        MaxNonAnonymousUsers ),
        MIB_INTEGER( MIB_CurrentConnections,          CurrentConnections ),
        MIB_COUNTER( MIB_MaxConnections,              MaxConnections ),
        MIB_COUNTER( MIB_ConnectionAttempts,          ConnectionAttempts ),
        MIB_COUNTER( MIB_LogonAttempts,               LogonAttempts )
    };

#define NUM_MIB_ENTRIES ( sizeof(Mib) / sizeof(MIB_ENTRY) )


//
//  Public functions.
//

UINT
ResolveVarBind(
    RFC1157VarBind     * VarBind,
    UINT                 PduAction,
    LPVOID               Statistics
    )
//
// ResolveVarBind
//    Resolves a single variable binding.  Modifies the variable on a GET
//    or a GET-NEXT.
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
{
    MIB_ENTRY            *MibPtr;
    AsnObjectIdentifier  TempOid;
    int                  CompResult;
    UINT                 i;
    UINT                 nResult;
    DWORD TableIndex;
    BOOL  fTableMatch = FALSE;

    //
    //  Search for a varbind name in the MIB.
    //

    MibPtr = NULL;

    for( i = 0 ; i < NUM_MIB_ENTRIES ; i++ )
    {
        //
        //  Create a fully qualified OID for the current item in the MIB.
        //

        SNMP_oidcpy( &TempOid, &MIB_OidPrefix );
        SNMP_oidappend( &TempOid, &Mib[i].Oid );

        //
        //  See if the given OID is in the MIB.
        //

        CompResult = SNMP_oidcmp( &VarBind->name, &TempOid );
        SNMP_oidfree( &TempOid );

        //
        //  If result is negative, only valid operation is GET-NEXT.
        //

        if( CompResult < 0 )
        {
            //
            //  This could be the OID of a leaf (without a trailing 0) or
            //  it could be an invalid OID (between two valid OIDs).
            //

            if( PduAction == MIB_GETNEXT )
            {
                MibPtr = &Mib[i];

                SNMP_oidfree( &VarBind->name );
                SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
                SNMP_oidappend( &VarBind->name, &MibPtr->Oid );

                if( ( MibPtr->Type != ASN_RFC1155_OPAQUE ) &&
                    ( MibPtr->Type != ASN_SEQUENCE ) )
                {
                    PduAction = MIB_GET;
                }
            }
            else
            {
                nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                goto Exit;
            }

            break;
        }
        else
        if( CompResult == 0 )
        {
            //
            //  Found one!
            //

            MibPtr = &Mib[i];
            break;
        }
    }

    if( i < NUM_MIB_ENTRIES )
    {
        //
        //  The associated function pointer will be NULL only if the
        //  match was with a group OID.
        //

        if( MibPtr->MibFunc == NULL )
        {
            if( PduAction == MIB_GETNEXT )
            {
                nResult = GetNextVar( VarBind, MibPtr, Statistics );
            }
            else
            {
                nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            }

            goto Exit;
        }
    }
    else
    {
        nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
        goto Exit;
    }

    //
    //  Call the associated function to process the request.
    //

    nResult = (MibPtr->MibFunc)( PduAction, MibPtr, VarBind, Statistics );

Exit:

    return nResult;

}   // ResolveVarBind


//
//  Private functions.
//

//
//  MIB_leaf_func
//      Performs generic actions on LEAF variables in the MIB.
//
//  Notes:
//
//  Return Codes:
//      Standard PDU error codes.
//
//  Error Codes:
//      None.
//
UINT
MIB_leaf_func(
    UINT                 Action,
    MIB_ENTRY          * MibPtr,
    RFC1157VarBind     * VarBind,
    LPVOID               Statistics
    )
{
    UINT  Result;
    DWORD Value;

    switch( Action )
    {
    case MIB_GETNEXT :
        //
        //  Determine if we're at the end of our MIB.
        //

        if( ( MibPtr - Mib ) >= NUM_MIB_ENTRIES )
        {
            Result = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
        }

        Result = GetNextVar( VarBind, MibPtr, Statistics );

        if (Result != SNMP_ERRORSTATUS_NOERROR)
        {
            goto Exit;
        }
        break;

    case MIB_GETFIRST :
    case MIB_GET :

        //
        //  Make sure that this variable's ACCESS is GET'able.
        //

        if( ( MibPtr->Access != MIB_ACCESS_READ ) &&
            ( MibPtr->Access != MIB_ACCESS_READWRITE ) )
        {
            Result = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
        }

        //
        //  Setup varbind's return value.
        //

        VarBind->value.asnType = MibPtr->Type;

        Value = *(LPDWORD)( (LPBYTE)Statistics + MibPtr->FieldOffset );

        switch( VarBind->value.asnType )
        {
        case ASN_RFC1155_COUNTER:
            VarBind->value.asnValue.number = (AsnCounter)Value;
            break;

        case ASN_RFC1155_GAUGE:
        case ASN_INTEGER:
            VarBind->value.asnValue.number = (AsnInteger)Value;
            break;

        case ASN_RFC1155_IPADDRESS:
        case ASN_OCTETSTRING:
            //
            //  Not supported for this MIB (yet).
            //

            Result = SNMP_ERRORSTATUS_GENERR;
            goto Exit;

        default:
            Result = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
        }
        break;

    case MIB_SET:

        //
        //  We don't support settable variables (yet).
        //

        Result = SNMP_ERRORSTATUS_NOSUCHNAME;
        goto Exit;

    default:
        Result = SNMP_ERRORSTATUS_GENERR;
        goto Exit;
    }

    Result = SNMP_ERRORSTATUS_NOERROR;

Exit:

    return Result;

}   // MIB_leaf_func

//
//  MIB_Stat
//      Performs specific actions on the different MIB variable.
//
//  Notes:
//
//  Return Codes:
//      Standard PDU error codes.
//
//  Error Codes:
//      None.
//
UINT
MIB_Stat(
    UINT                 Action,
    MIB_ENTRY          * MibPtr,
    RFC1157VarBind     * VarBind,
    LPVOID               Statistics
    )
{
    UINT Result;

    switch( Action )
    {
    case MIB_SET :
    case MIB_GETNEXT :
        Result = MIB_leaf_func( Action, MibPtr, VarBind, Statistics );
        break;

    case MIB_GETFIRST :
    case MIB_GET :
        //
        //  If we have no statistics structure, bail.
        //

        if( Statistics == NULL )
        {
            Result = SNMP_ERRORSTATUS_GENERR;
            break;
        }

        //
        //  If there's no field offset associated with the current
        //  entry, also bail.
        //

        if( MibPtr->FieldOffset == -1 )
        {
            Result = SNMP_ERRORSTATUS_GENERR;
            break;
        }

        //
        //  Call the generic leaf function to perform the action.
        //

        Result = MIB_leaf_func( Action, MibPtr, VarBind, Statistics );
        break;

    default :
        Result = SNMP_ERRORSTATUS_GENERR;
        break;
    }

    return Result;

}   // MIB_Stat

UINT
GetNextVar(
    RFC1157VarBind     * VarBind,
    MIB_ENTRY          * MibPtr,
    LPVOID               Statistics
    )
{
    UINT Result;
    INT  i;

    //
    //  Calculate the current index within the MIB array.
    //

    i = DIFF( MibPtr - Mib );

    //
    //  Validate we have a reasonable value.
    //

    if( ( i < 0 ) || ( i >= NUM_MIB_ENTRIES ) )
    {
        return SNMP_ERRORSTATUS_NOSUCHNAME;
    }

    //
    //  Scan through the remaining MIB entries.
    //

    for( i++ ; i < NUM_MIB_ENTRIES ; i++ )
    {
        MIB_ENTRY * NextMib;

        NextMib = &Mib[i];

        //
        //  Setup varbind name of next MIB variable.
        //

        SNMP_oidfree( &VarBind->name );
        SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
        SNMP_oidappend( &VarBind->name, &NextMib->Oid );

        //
        //  If the function pointer is not NULL and the type of the MIB
        //  variable is anything but OPAQUE, then call the function to
        //  process the MIB variable.
        //

        if( ( NextMib->MibFunc != NULL ) &&
            ( NextMib->Type != ASN_RFC1155_OPAQUE ) )
        {
            Result = (NextMib->MibFunc)( MIB_GETFIRST,
                                         NextMib,
                                         VarBind,
                                         Statistics );
            break;
        }
    }

    if( i >= NUM_MIB_ENTRIES )
    {
        Result = SNMP_ERRORSTATUS_NOSUCHNAME;
    }

    return Result;

}   // GetNextVar
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\perfmon\debug.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    debug.h

    This file contains a number of debug-dependent definitions for
    the FTPD Service.


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.

*/


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG

//
//  Debug output control flags.
//

#define FTPD_DEBUG_ENTRYPOINTS          0x00000001L     // DLL entrypoints
#define FTPD_DEBUG_OPEN                 0x00000002L     // OpenPerformanceData
#define FTPD_DEBUG_CLOSE                0x00000004L     // CollectPerformanceData
#define FTPD_DEBUG_COLLECT              0x00000008L     // ClosePerformanceData
// #define FTPD_DEBUG_                     0x00000010L
// #define FTPD_DEBUG_                     0x00000020L
// #define FTPD_DEBUG_                     0x00000040L
// #define FTPD_DEBUG_                     0x00000080L
// #define FTPD_DEBUG_                     0x00000100L
// #define FTPD_DEBUG_                     0x00000200L
// #define FTPD_DEBUG_                     0x00000400L
// #define FTPD_DEBUG_                     0x00000800L
// #define FTPD_DEBUG_                     0x00001000L
// #define FTPD_DEBUG_                     0x00002000L
// #define FTPD_DEBUG_                     0x00004000L
// #define FTPD_DEBUG_                     0x00008000L
// #define FTPD_DEBUG_                     0x00010000L
// #define FTPD_DEBUG_                     0x00020000L
// #define FTPD_DEBUG_                     0x00040000L
// #define FTPD_DEBUG_                     0x00080000L
// #define FTPD_DEBUG_                     0x00100000L
// #define FTPD_DEBUG_                     0x00200000L
// #define FTPD_DEBUG_                     0x00400000L
// #define FTPD_DEBUG_                     0x00800000L
// #define FTPD_DEBUG_                     0x01000000L
// #define FTPD_DEBUG_                     0x02000000L
// #define FTPD_DEBUG_                     0x04000000L
// #define FTPD_DEBUG_                     0x08000000L
// #define FTPD_DEBUG_                     0x10000000L
// #define FTPD_DEBUG_                     0x20000000L
#define FTPD_DEBUG_OUTPUT_TO_DEBUGGER   0x40000000L
// #define FTPD_DEBUG_                     0x80000000L

extern DWORD FtpdDebug;

#define IF_DEBUG(flag) if ( (FtpdDebug & FTPD_DEBUG_ ## flag) != 0 )


//
//  Debug output function.
//

VOID FtpdPrintf( CHAR * pszFormat,
                 ... );

#define FTPD_PRINT(args) FtpdPrintf args


//
//  Assert & require.
//

VOID FtpdAssert( VOID  * pAssertion,
                 VOID  * pFileName,
                 LONG    nLineNumber );

#define FTPD_ASSERT(exp) if (!(exp)) FtpdAssert( #exp, __FILE__, __LINE__ )
#define FTPD_REQUIRE FTPD_ASSERT

#else   // !DBG

//
//  No debug output.
//

#define IF_DEBUG(flag) if (0)


//
//  Null debug output function.
//

#define FTPD_PRINT(args)


//
//  Null assert & require.
//

#define FTPD_ASSERT(exp)
#define FTPD_REQUIRE(exp) ((VOID)(exp))

#endif  // DBG


#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\perfmon\ftpctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpctrs.h

    Offset definitions for the FTP Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    FtpOpenPerformanceData procecedure, they will be added to the
    FTP Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the FTPCTRS.DLL DLL code as well as the
    FTPCTRS.INI definition file.  FTPCTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        KestutiP    15-May-1999 Added uptime counter

*/


#ifndef _FTPCTRS_H_
#define _FTPCTRS_H_


//
//  The FTP Server counter object.
//

#define FTPD_COUNTER_OBJECT                     0


//
//  The individual counters.
//

#define FTPD_BYTES_SENT_COUNTER                 2
#define FTPD_BYTES_RECEIVED_COUNTER             4
#define FTPD_BYTES_TOTAL_COUNTER                6
#define FTPD_FILES_SENT_COUNTER                 8
#define FTPD_FILES_RECEIVED_COUNTER             10
#define FTPD_FILES_TOTAL_COUNTER                12
#define FTPD_CURRENT_ANONYMOUS_COUNTER          14
#define FTPD_CURRENT_NONANONYMOUS_COUNTER       16
#define FTPD_TOTAL_ANONYMOUS_COUNTER            18
#define FTPD_TOTAL_NONANONYMOUS_COUNTER         20
#define FTPD_MAX_ANONYMOUS_COUNTER              22
#define FTPD_MAX_NONANONYMOUS_COUNTER           24
#define FTPD_CURRENT_CONNECTIONS_COUNTER        26
#define FTPD_MAX_CONNECTIONS_COUNTER            28
#define FTPD_CONNECTION_ATTEMPTS_COUNTER        30
#define FTPD_LOGON_ATTEMPTS_COUNTER             32
#define FTPD_SERVICE_UPTIME_COUNTER             34

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
#define FTPD_TOTAL_ALLOWED_REQUESTS_COUNTER     34
#define FTPD_TOTAL_REJECTED_REQUESTS_COUNTER    36
#define FTPD_TOTAL_BLOCKED_REQUESTS_COUNTER     38
#define FTPD_CURRENT_BLOCKED_REQUESTS_COUNTER   40
#define FTPD_MEASURED_BANDWIDTH_COUNTER         42
*/
#endif  // _FTPCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\perfmon\ftpdata.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpdata.c

    Constant data structures for the FTP Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#include <windows.h>
#include <winperf.h>
#include <ftpctrs.h>
#include <ftpdata.h>


//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

FTPD_DATA_DEFINITION FtpdDataDefinition =
{
    {   // FtpdObjectType
        sizeof(FTPD_DATA_DEFINITION) + sizeof( FTPD_COUNTER_BLOCK) ,
        sizeof(FTPD_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        FTPD_COUNTER_OBJECT,
        0,
        FTPD_COUNTER_OBJECT,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_FTPD_COUNTERS,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // FtpdBytesSent
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_BYTES_SENT_COUNTER,
        0,
        FTPD_BYTES_SENT_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        0
    },

    {   // FtpdBytesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_BYTES_RECEIVED_COUNTER,
        0,
        FTPD_BYTES_RECEIVED_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        0
    },

    {   // FtpdBytesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_BYTES_TOTAL_COUNTER,
        0,
        FTPD_BYTES_TOTAL_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        0
    },

    {   // FtpdFilesSent
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_FILES_SENT_COUNTER,
        0,
        FTPD_FILES_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FtpdFilesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_FILES_RECEIVED_COUNTER,
        0,
        FTPD_FILES_RECEIVED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FtpdFilesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_FILES_TOTAL_COUNTER,
        0,
        FTPD_FILES_TOTAL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdCurrentAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_CURRENT_ANONYMOUS_COUNTER,
        0,
        FTPD_CURRENT_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdCurrentNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_CURRENT_NONANONYMOUS_COUNTER,
        0,
        FTPD_CURRENT_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdTotalAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_TOTAL_ANONYMOUS_COUNTER,
        0,
        FTPD_TOTAL_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdTotalNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_TOTAL_NONANONYMOUS_COUNTER,
        0,
        FTPD_TOTAL_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdMaxAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_MAX_ANONYMOUS_COUNTER,
        0,
        FTPD_MAX_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdMaxNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_MAX_NONANONYMOUS_COUNTER,
        0,
        FTPD_MAX_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdCurrentConnections
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_CURRENT_CONNECTIONS_COUNTER,
        0,
        FTPD_CURRENT_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdMaxConnections
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_MAX_CONNECTIONS_COUNTER,
        0,
        FTPD_MAX_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdConnectionAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_CONNECTION_ATTEMPTS_COUNTER,
        0,
        FTPD_CONNECTION_ATTEMPTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdLogonAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_LOGON_ATTEMPTS_COUNTER,
        0,
        FTPD_LOGON_ATTEMPTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdServiceUptime
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_SERVICE_UPTIME_COUNTER,
        0,
        FTPD_SERVICE_UPTIME_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
    {   // FtpdTotalAllowedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_TOTAL_ALLOWED_REQUESTS_COUNTER,
        0,
        FTPD_TOTAL_ALLOWED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FtpdTotalRejectedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_TOTAL_REJECTED_REQUESTS_COUNTER,
        0,
        FTPD_TOTAL_REJECTED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FtpdTotalBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_TOTAL_BLOCKED_REQUESTS_COUNTER,
        0,
        FTPD_TOTAL_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdCurrentBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        FTPD_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdMeasuredBandwidth
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_MEASURED_BANDWIDTH_COUNTER,
        0,
        FTPD_MEASURED_BANDWIDTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },
*/
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\perfmon\makefile.inc ===
MY_BINPLACE = -binplace -P $(BINPLACE_PLACEFILE)

copyini:
    $(MY_BINPLACE) ftpctrs.ini
    $(MY_BINPLACE) ftpctrs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\perfmon\ftpdata.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpdata.h

    Extensible object definitions for the FTP Server's counter
    objects & counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#ifndef _FTPDATA_H_
#define _FTPDATA_H_

#pragma pack(8) 

//
//  The counter structure returned.
//

typedef struct _FTPD_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            FtpdObjectType;

    PERF_COUNTER_DEFINITION     FtpdBytesSent;
    PERF_COUNTER_DEFINITION     FtpdBytesReceived;
    PERF_COUNTER_DEFINITION     FtpdBytesTotal;

    PERF_COUNTER_DEFINITION     FtpdFilesSent;
    PERF_COUNTER_DEFINITION     FtpdFilesReceived;
    PERF_COUNTER_DEFINITION     FtpdFilesTotal;

    PERF_COUNTER_DEFINITION     FtpdCurrentAnonymous;
    PERF_COUNTER_DEFINITION     FtpdCurrentNonAnonymous;
    PERF_COUNTER_DEFINITION     FtpdTotalAnonymous;
    PERF_COUNTER_DEFINITION     FtpdTotalNonAnonymous;
    PERF_COUNTER_DEFINITION     FtpdMaxAnonymous;
    PERF_COUNTER_DEFINITION     FtpdMaxNonAnonymous;

    PERF_COUNTER_DEFINITION     FtpdCurrentConnections;
    PERF_COUNTER_DEFINITION     FtpdMaxConnections;
    PERF_COUNTER_DEFINITION     FtpdConnectionAttempts;
    PERF_COUNTER_DEFINITION     FtpdLogonAttempts;
    PERF_COUNTER_DEFINITION     FtpdServiceUptime;

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
    PERF_COUNTER_DEFINITION     FtpdAllowedRequests;
    PERF_COUNTER_DEFINITION     FtpdRejectedRequests;
    PERF_COUNTER_DEFINITION     FtpdBlockedRequests;
    PERF_COUNTER_DEFINITION     FtpdCurrentBlockedRequests;
    PERF_COUNTER_DEFINITION     FtpdMeasuredBandwidth;
*/
} FTPD_DATA_DEFINITION;

typedef struct _FTPD_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK  PerfCounterBlock;
    LONGLONG            BytesSent;
    LONGLONG            BytesReceived;
    LONGLONG            BytesTotal;

    DWORD               FilesSent;
    DWORD               FilesReceived;
    DWORD               FilesTotal;

    DWORD               CurrentAnonymous;
    DWORD               CurrentNonAnonymous;
    DWORD               TotalAnonymous;
    DWORD               TotalNonAnonymous;

    DWORD               MaxAnonymous;
    DWORD               MaxNonAnonymous;
    DWORD               CurrentConnections;
    DWORD               MaxConnections;

    DWORD               ConnectionAttempts;
    DWORD               LogonAttempts;
    DWORD               ServiceUptime;

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
    DWORD               AllowedRequests;
    DWORD               RejectedRequests;
    DWORD               BlockedRequests;
    DWORD               CurrentBlockedRequests;
    DWORD               MeasuredBandwidth;
*/
} FTPD_COUNTER_BLOCK;


//
//  The routines that load these structures assume that all fields
//  are DWORD packed & aligned.
//

extern  FTPD_DATA_DEFINITION    FtpdDataDefinition;

#define NUMBER_OF_FTPD_COUNTERS ((sizeof(FTPD_DATA_DEFINITION) -        \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))


//
//  Restore default packing & alignment.
//

#pragma pack()

#endif  // _FTPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\perfmon\perfftp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfftp.cxx

    This file implements the Extensible Performance Objects for
    the FTP Server service.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.

        MuraliK     16-Nov-1995 Modified dependencies and removed NetApi
        SophiaC     06-Nov-1996 Supported mutlitiple instances
*/

#define INITGUID

#include <windows.h>
#include <winperf.h>
#include <lm.h>
#include <string.h>
#include <stdlib.h>
#include <ole2.h>

#include "iis64.h"
#include "dbgutil.h"
#include "iisinfo.h"
#include "ftpd.h"
#include "ftpctrs.h"
#include "ftpmsg.h"
#include "iadm.h"

extern "C" {
#include "perfutil.h"
#include "apiutil.h"
#include "ftpdata.h"
} // extern "C"

#define APP_NAME                     (TEXT("FTPCtrs"))
#define MAX_SIZEOF_INSTANCE_NAME     METADATA_MAX_NAME_LEN
#define TOTAL_INSTANCE_NAME          L"_Total"

//
//  Private globals.
//

DWORD   cOpens    = 0;                  // Active "opens" reference count.
BOOL    fInitOK   = FALSE;              // TRUE if DLL initialized OK.

HANDLE  hEventLog = NULL;               // event log handle

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenFtpPerformanceData;
PM_COLLECT_PROC CollectFtpPerformanceData;
PM_CLOSE_PROC   CloseFtpPerformanceData;

//
//  Private prototypes.
//
VOID
CopyStatisticsData(
    IN FTP_STATISTICS_0         * pFTPStats,
    OUT FTPD_COUNTER_BLOCK      * pCounterBlock
    );

VOID
Update_TotalStatisticsData(
    IN FTPD_COUNTER_BLOCK       * pCounterBlock,
    OUT FTPD_COUNTER_BLOCK      * pTotal
    );

//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenFtpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD OpenFtpPerformanceData( LPWSTR lpDeviceNames )
{
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    PERF_COUNTER_DEFINITION * pctr;
    FTPD_COUNTER_BLOCK        ftpc;
    DWORD                     i;

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    if( !fInitOK )
    {

        //
        //  This is the *first* open.
        //

        // open event log interface

        if (hEventLog == NULL){
            hEventLog = RegisterEventSource ((LPTSTR)NULL,            // Use Local Machine
                                             APP_NAME);               // event log app name to find in registry
            if (hEventLog == NULL)
            {
                return GetLastError();
            }
        }

        //
        //  Open the FTP Server service's Performance key.
        //

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            FTPD_PERFORMANCE_KEY,
                            0,
                            KEY_READ,
                            &hkey );

        if( err == NO_ERROR )
        {
            //
            //  Read the first counter DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( hkey,
                                   "First Counter",
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwFirstCounter,
                                   &size );
            if( err == NO_ERROR )
            {
                //
                //  Read the first help DWORD.
                //

                size = sizeof(DWORD);

                err = RegQueryValueEx( hkey,
                                    "First Help",
                                    NULL,
                                    &type,
                                    (LPBYTE)&dwFirstHelp,
                                    &size );

                if ( err == NO_ERROR )
                {
                    //
                    //  Update the object & counter name & help indicies.
                    //

                    FtpdDataDefinition.FtpdObjectType.ObjectNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdObjectType.ObjectHelpTitleIndex
                        += dwFirstHelp;

                    FtpdDataDefinition.FtpdBytesSent.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdBytesSent.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdBytesSent.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.BytesSent - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdBytesReceived.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdBytesReceived.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdBytesReceived.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.BytesReceived - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdBytesTotal.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdBytesTotal.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdBytesTotal.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.BytesTotal - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdFilesSent.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdFilesSent.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdFilesSent.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.FilesSent - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdFilesReceived.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdFilesReceived.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdFilesReceived.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.FilesReceived - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdFilesTotal.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdFilesTotal.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdFilesTotal.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.FilesTotal - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdCurrentAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdCurrentAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdCurrentAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.CurrentAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdCurrentNonAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdCurrentNonAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdCurrentNonAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.CurrentNonAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdTotalAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdTotalAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdTotalAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.TotalAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdTotalNonAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdTotalNonAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdTotalNonAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.TotalNonAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdMaxAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdMaxAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdMaxAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.MaxAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdMaxNonAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdMaxNonAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdMaxNonAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.MaxNonAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdCurrentConnections.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdCurrentConnections.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdCurrentConnections.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.CurrentConnections - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdMaxConnections.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdMaxConnections.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdMaxConnections.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.MaxConnections - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdConnectionAttempts.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdConnectionAttempts.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdConnectionAttempts.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.ConnectionAttempts - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdLogonAttempts.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdLogonAttempts.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdLogonAttempts.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.LogonAttempts - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdServiceUptime.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdServiceUptime.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdServiceUptime.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.ServiceUptime - (LPBYTE)&ftpc);

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
                    FtpdDataDefinition.FtpdBlockedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdBlockedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdBlockedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.BlockedRequests - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdAllowedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdAllowedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdAllowedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.AllowedRequests - (LPBYTE)&ftpc);


                    FtpdDataDefinition.FtpdRejectedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdRejectedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdRejectedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.RejectedRequests - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdCurrentBlockedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdCurrentBlockedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdCurrentBlockedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.CurrentBlockedRequests - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdMeasuredBandwidth.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdMeasuredBandwidth.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdMeasuredBandwidth.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.MeasuredBandwidth - (LPBYTE)&ftpc);

*/

                    //
                    //  Remember that we initialized OK.
                    //

                    fInitOK = TRUE;
                } else {
                    ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                                 0, FTP_UNABLE_QUERY_DATA,
                                 (PSID)NULL, 0,
                                 sizeof(err), NULL,
                                 (PVOID)(&err));
                }
            } else {
                ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                             0, FTP_UNABLE_QUERY_DATA,
                             (PSID)NULL, 0,
                             sizeof(err), NULL,
                             (PVOID)(&err));
            }

            //
            //  Close the registry if we managed to actually open it.
            //

            if( hkey != NULL )
            {
                RegCloseKey( hkey );
                hkey = NULL;
            }
        } else {
            ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                         0, FTP_UNABLE_QUERY_DATA,
                         (PSID)NULL, 0,
                         sizeof(err), NULL,
                         (PVOID)(&err));
        }
    }

    //
    //  Bump open counter.
    //

    InterlockedIncrement((LPLONG )&cOpens);

    return err;

}   // OpenFTPPerformanceData

/*******************************************************************

    NAME:       CollectFtpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectFtpPerformanceData( LPWSTR    lpValueName,
                                 LPVOID  * lppData,
                                 LPDWORD   lpcbTotalBytes,
                                 LPDWORD   lpNumObjectTypes )
{
    PERF_INSTANCE_DEFINITION * pPerfInstanceDefinition;
    DWORD                   dwInstanceIndex = 0;
    DWORD                   dwInstanceCount = 0;
    DWORD                   i = 0;
    DWORD                   dwQueryType;
    ULONG                   cbRequired;
    DWORD                   * pdwCounter;
    LARGE_INTEGER           * pliCounter;
    FTPD_COUNTER_BLOCK      * pCounterBlock;
    FTPD_COUNTER_BLOCK      * pTotal;
    FTPD_DATA_DEFINITION    * pFtpdDataDefinition;
    FTP_STATISTICS_0        * pFTPStats;
    NET_API_STATUS          neterr;
    HRESULT                 hresErr;
    DWORD                   dwBufferSize = 0;

    LPINET_INFO_SITE_LIST   pSites;


    //
    //  No need to even try if we failed to open...
    //

    if( !fInitOK )
    {

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if (( dwQueryType == QUERY_FOREIGN ) || (dwQueryType == QUERY_COSTLY))
    {
        //
        //  We don't do foreign queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        FtpdDataDefinition.FtpdObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return NO_ERROR;
        }
    }

    //
    //  Enumerate and get total number of instances count.
    //

    neterr = InetInfoGetSites(
                NULL,
                INET_FTP_SVC_ID,
                &pSites
                );
    

    if( neterr != NERR_Success )
    {
        //
        //  Only event log once for each server down
        //

        // if the server is down, we don't log an error.
		if ( !( neterr == RPC_S_SERVER_UNAVAILABLE ||
                neterr == RPC_S_UNKNOWN_IF         ||
                neterr == ERROR_SERVICE_NOT_ACTIVE ||
                neterr == RPC_S_CALL_FAILED_DNE ))
        {
            //
            //  Error retrieving statistics.
            //
            
            ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE,
                        0, FTP_UNABLE_QUERY_DATA,
                        (PSID)NULL, 0,
                        sizeof(neterr), NULL,
                        (PVOID)(&neterr));

        }

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }
        
    //
    //  add 1 to dwInstanceCount for _Total instance
    //

    dwInstanceCount = pSites->cEntries + 1;

    //
    //  always return an "instance sized" buffer after the definition
    //  blocks to prevent perfmon from reading bogus data. This is strictly
    //  a hack to accomodate how PERFMON handles the "0" instance case.
    //  By doing this, perfmon won't choke when there are no instances
    //  and the counter object & counters will be displayed in the list
    //  boxes, even though no instances will be listed.
    //

    pFtpdDataDefinition = (FTPD_DATA_DEFINITION *)*lppData;

    cbRequired = sizeof(FTPD_DATA_DEFINITION) +
                 (dwInstanceCount * (sizeof(PERF_INSTANCE_DEFINITION) +
                 MAX_SIZEOF_INSTANCE_NAME +
                 sizeof (FTPD_COUNTER_BLOCK)));

    //
    //  See if there's enough space.
    //

    if( *lpcbTotalBytes < cbRequired )
    {
        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        MIDL_user_free(pSites);
        return ERROR_MORE_DATA;
    }

    //
    //  Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pFtpdDataDefinition,
             &FtpdDataDefinition,
             sizeof(FTPD_DATA_DEFINITION) );

    //
    //  Create data for return for each instance
    //

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pFtpdDataDefinition[1];

    //
    // Set first block of Buffer for _Total
    //

    MonBuildInstanceDefinition(
        pPerfInstanceDefinition,
        (PVOID *)&pCounterBlock,
        0,
        0,
        (DWORD)-1, // use name
        TOTAL_INSTANCE_NAME );   // pass in instance name

    pTotal = pCounterBlock;
    memset( pTotal, 0, sizeof(FTPD_COUNTER_BLOCK ));
    pTotal->PerfCounterBlock.ByteLength = sizeof (FTPD_COUNTER_BLOCK);
    pPerfInstanceDefinition =
        (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock +
         sizeof(FTPD_COUNTER_BLOCK));


    neterr = FtpQueryStatistics2(
                            NULL,
                            0,
                            0,  // instance id, 0 for global stats
                            0,
                            (LPBYTE *)&pFTPStats );

    if( neterr == NERR_Success )
    {
        pTotal->ServiceUptime = pFTPStats->ServiceUptime;
    }

    MIDL_user_free( pFTPStats );

    for ( i = 0; i < pSites->cEntries; i++)
    {
        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pCounterBlock,
            0,
            0,
            (DWORD)-1,                          // use name
            pSites->aSiteEntry[i].pszComment    // pass in instance name
            );

        //
        // query for statistics info
        //

        neterr = FtpQueryStatistics2(
                            NULL,
                            0,
                            pSites->aSiteEntry[i].dwInstance,  // instance id
                            0,
                            (LPBYTE *)&pFTPStats );

        if( neterr != NERR_Success )
        {
            //
            //  Only event log once for each server down
            //

            // if the server is down, we don't log an error.
	        if ( !( neterr == RPC_S_SERVER_UNAVAILABLE ||
                    neterr == RPC_S_UNKNOWN_IF         ||
                    neterr == ERROR_SERVICE_NOT_ACTIVE ||
                    neterr == RPC_S_CALL_FAILED_DNE ))
            {
                //
                //  Error retrieving statistics.
                //
                ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                    0, FTP_UNABLE_QUERY_DATA,
                    (PSID)NULL, 0,
                    sizeof(neterr), NULL,
                    (PVOID)(&neterr));
            }

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            MIDL_user_free(pSites);
            return NO_ERROR;
        }

        //
        //  Format the FTP Server data.
        //

        CopyStatisticsData( pFTPStats,
                            pCounterBlock );

        //
        //  update _total instance counters
        //

        Update_TotalStatisticsData( pCounterBlock,
                                    pTotal );

        pPerfInstanceDefinition =
            (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock +
             sizeof(FTPD_COUNTER_BLOCK));

        //
        //  Free the API buffer.
        //

        MIDL_user_free( pFTPStats );
    }

    if (dwInstanceCount == 1) {

        //
        //  zero fill one instance sized block of data if there's no data
        //  instances
        //

        memset (pPerfInstanceDefinition, 0,
            (sizeof(PERF_INSTANCE_DEFINITION) +
            MAX_SIZEOF_INSTANCE_NAME +
            sizeof(FTPD_COUNTER_BLOCK)));

        // adjust pointer to point to end of zeroed block
        pPerfInstanceDefinition += (sizeof(PERF_INSTANCE_DEFINITION) +
            MAX_SIZEOF_INSTANCE_NAME +
            sizeof(FTPD_COUNTER_BLOCK));
    }

    //
    //  Update arguments for return.
    //

    *lppData          = (PVOID)(pPerfInstanceDefinition);

    *lpNumObjectTypes = 1;

    pFtpdDataDefinition->FtpdObjectType.NumInstances = dwInstanceCount;

    pFtpdDataDefinition->FtpdObjectType.TotalByteLength =
        *lpcbTotalBytes   = DIFF((PBYTE)pPerfInstanceDefinition -
                                 (PBYTE)pFtpdDataDefinition);

    //
    //  Success!  Honest!!
    //

    MIDL_user_free(pSites);
    
    return NO_ERROR;

}   // CollectFTPPerformanceData

/*******************************************************************

    NAME:       CloseFtpPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseFtpPerformanceData( VOID )
{

    DWORD dwCount = InterlockedDecrement((LPLONG )&cOpens);
    
    if ((dwCount) == 0) {
        if (hEventLog != NULL) 
        { 
            DeregisterEventSource (hEventLog);
            hEventLog = NULL;
        };
    }

    return NO_ERROR;

}   // CloseFTPPerformanceData


VOID
CopyStatisticsData(
    IN FTP_STATISTICS_0          * pFTPStats,
    OUT FTPD_COUNTER_BLOCK       * pCounterBlock
    )
{
    //
    //  Format the FTP Server data.
    //

    pCounterBlock->PerfCounterBlock.ByteLength = sizeof (FTPD_COUNTER_BLOCK);

    pCounterBlock->BytesSent       = pFTPStats->TotalBytesSent.QuadPart;
    pCounterBlock->BytesReceived   = pFTPStats->TotalBytesReceived.QuadPart;
    pCounterBlock->BytesTotal      = pFTPStats->TotalBytesSent.QuadPart +
                                     pFTPStats->TotalBytesReceived.QuadPart;

    pCounterBlock->FilesSent        = pFTPStats->TotalFilesSent;
    pCounterBlock->FilesReceived    = pFTPStats->TotalFilesReceived;
    pCounterBlock->FilesTotal       = pFTPStats->TotalFilesSent +
                                      pFTPStats->TotalFilesReceived;

    pCounterBlock->CurrentAnonymous = pFTPStats->CurrentAnonymousUsers;
    pCounterBlock->CurrentNonAnonymous = pFTPStats->CurrentNonAnonymousUsers;

    pCounterBlock->TotalAnonymous   = pFTPStats->TotalAnonymousUsers;
    pCounterBlock->TotalNonAnonymous = pFTPStats->TotalNonAnonymousUsers;

    pCounterBlock->MaxAnonymous     = pFTPStats->MaxAnonymousUsers;
    pCounterBlock->MaxNonAnonymous  = pFTPStats->MaxNonAnonymousUsers;

    pCounterBlock->CurrentConnections = pFTPStats->CurrentConnections;
    pCounterBlock->MaxConnections   = pFTPStats->MaxConnections;
    pCounterBlock->ConnectionAttempts = pFTPStats->ConnectionAttempts;

    pCounterBlock->LogonAttempts    = pFTPStats->LogonAttempts;

    pCounterBlock->ServiceUptime    = pFTPStats->ServiceUptime;

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
    pCounterBlock->BlockedRequests  = pFTPStats->TotalBlockedRequests;
    pCounterBlock->AllowedRequests  = pFTPStats->TotalAllowedRequests;
    pCounterBlock->RejectedRequests = pFTPStats->TotalRejectedRequests;
    pCounterBlock->MeasuredBandwidth= pFTPStats->MeasuredBandwidth;
    pCounterBlock->CurrentBlockedRequests = pFTPStats->CurrentBlockedRequests;
*/
}   // CopyStatisticsData


VOID
Update_TotalStatisticsData(
    IN FTPD_COUNTER_BLOCK        * pCounterBlock,
    OUT FTPD_COUNTER_BLOCK       * pTotal
    )
{
    //
    //  update _total instance counters
    //

    pTotal->BytesSent += pCounterBlock->BytesSent;
    pTotal->BytesReceived += pCounterBlock->BytesReceived;
    pTotal->BytesTotal += pCounterBlock->BytesTotal;

    pTotal->FilesSent += pCounterBlock->FilesSent;
    pTotal->FilesReceived += pCounterBlock->FilesReceived;
    pTotal->FilesTotal += pCounterBlock->FilesTotal;
    pTotal->CurrentAnonymous += pCounterBlock->CurrentAnonymous;
    pTotal->CurrentNonAnonymous += pCounterBlock->CurrentNonAnonymous;
    pTotal->TotalAnonymous += pCounterBlock->TotalAnonymous;
    pTotal->TotalNonAnonymous += pCounterBlock->TotalNonAnonymous;

    pTotal->MaxAnonymous += pCounterBlock->MaxAnonymous;
    pTotal->MaxNonAnonymous += pCounterBlock->MaxNonAnonymous;

    pTotal->CurrentConnections += pCounterBlock->CurrentConnections;
    pTotal->MaxConnections += pCounterBlock->MaxConnections;
    pTotal->ConnectionAttempts = pCounterBlock->ConnectionAttempts;

    pTotal->LogonAttempts += pCounterBlock->LogonAttempts;

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
    pTotal->BlockedRequests += pCounterBlock->BlockedRequests;
    pTotal->RejectedRequests += pCounterBlock->RejectedRequests;
    pTotal->AllowedRequests += pCounterBlock->AllowedRequests;
    pTotal->MeasuredBandwidth += pCounterBlock->MeasuredBandwidth;
    pTotal->CurrentBlockedRequests += pCounterBlock->CurrentBlockedRequests;
*/

}   // Update_TotalStatisticsData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for FTP server

   Author:

       Murali R. Krishnan    ( MuraliK )    06-Feb-1996

   Environment:

       Windows NT - User Mode

   Project:

       FTP Server DLL

   Revision History:

--*/

# ifndef _FTP_AUX_COUNTERS_HXX_
# define _FTP_AUX_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

typedef enum  {   // Fac - stands for Ftp Aux Counters

    FacUnknownCommands = 0,           // cumulative counter
    CacTimeoutWhenProcessing,         // cumulative
    CacTimeoutInDisconnect,           // cumulative
    FacPassiveDataListens,            // active counter
    FacSimulatedAborts,               // cumulative counter
    FacPassiveDataConnections,        // cumulative counter
    FacActiveDataConnections,         // cumulative counter
    FacFilesOpened,                   // cumulative counter
    FacFilesClosed,                   // cumulative counter
    FacFilesInvalid,                  // cumulative counter

    FacMaxCounters
} ENUM_FTP_AUX_COUNTER;



#ifdef FTP_AUX_COUNTERS

# define NUM_AUX_COUNTERS    (FacMaxCounters)

//
// Macros for operating on these counters
//

# define FacIncrement( facCounter)   \
 (((facCounter) < FacMaxCounters) ?  \
  InterlockedIncrement( g_AuxCounters+(facCounter)) : \
  0)

# define FacDecrement( facCounter)   \
 (((facCounter) < FacMaxCounters) ?  \
  InterlockedDecrement( g_AuxCounters+(facCounter)) : \
  0)

# define FacCounter( facCounter)   \
 (((facCounter) < FacMaxCounters) ? g_AuxCounters[facCounter] : 0)


extern LONG g_AuxCounters[];


# else // FTP_AUX_COUNTERS

# define NUM_AUX_COUNTERS          (0)

# define FacIncrement( facCounter)       (0)    /* do nothing */
# define FacDecrement( facCounter)       (0)    /* do nothing */
# define FacCounter(facCounter)          (0)    /* do nothing */

#endif // FTP_AUX_COUNTERS


# endif // _FTP_AUX_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\acptctxt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    acptctxt.cxx

    This file contains the implementations of the PASV_ACCEPT_CONTEXT and ACCEPT_CONTEXT_ENTRY
    classes used to deal with async PASV connections

*/

#include "ftpdp.hxx"
#include "auxctrs.h"
#include "acptctxt.hxx"



PASV_ACCEPT_CONTEXT::PASV_ACCEPT_CONTEXT() :
m_dwErr( ERROR_SUCCESS ),
m_dwNumEvents( 0 ),
m_hWatchThread( NULL ),
m_dwThreadId( 0 ),
m_dwSignature( ACCEPT_CONTEXT_GOOD_SIG )
/*++

    Constructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{

    if ( ( m_ahEvents[NEEDUPDATE_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT ||
         ( m_ahEvents[CANUPDATE_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT  ||
         ( m_ahEvents[HAVEUPDATED_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT ||
         ( m_ahEvents[EXITTHREAD_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT )
                                                                                       
    {
        m_dwErr = WSAGetLastError();
        
        DBGWARN((DBG_CONTEXT,
                   "WSACreateEvent failed : 0x%x\n",
                   m_dwErr));

        return;
    }

    m_dwNumEvents = 4;

    INITIALIZE_CRITICAL_SECTION( &m_csLock );

    //
    // Create the watching thread
    //
    m_hWatchThread = CreateThread( NULL,
                                   0,
                                   AcceptThreadFunc,
                                   this,
                                   0,
                                   &m_dwThreadId );

    if ( !m_hWatchThread )
    {
        m_dwErr = GetLastError();

        DBGERROR((DBG_CONTEXT,
                   "Failed to create thread to watch for PASV accept events : 0x%x\n",
                   m_dwErr));
    }
}

PASV_ACCEPT_CONTEXT::~PASV_ACCEPT_CONTEXT()
/*++

    Destructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{
    DWORD dwRet = 0;


    //
    // Tell watch thread to shut down
    //
    if ( !WSASetEvent( m_ahEvents[EXITTHREAD_INDEX] ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WSASetEvent failed : 0x%x\n",
                   WSAGetLastError()));
    }

    //
    // wait for thread to shut down
    //
    if ( WaitForSingleObject( m_hWatchThread,
                              INFINITE ) == WAIT_FAILED )
    {
        DBGWARN((DBG_CONTEXT,
                   "Waiting for thread shutdown failed : 0x%x\n",
                   GetLastError()));
    }

    CloseHandle( m_hWatchThread );

    DeleteCriticalSection( &m_csLock );

    m_dwSignature = ACCEPT_CONTEXT_BAD_SIG;
}

BOOL PASV_ACCEPT_CONTEXT::RemoveAcceptEvent( IN WSAEVENT hEvent,
                                             IN USER_DATA *pUserData,
                                             OUT PBOOL pfFound )
/*++

   Removes the event to be signalled when a socket is accept()'able

  Arguments:
     hEvent - event to be removed
     pUserData - USER_DATA attached to signalled event
     pfFound - BOOL set to TRUE if event was found, FALSE if not 

  Returns:
    BOOL indicating success or failure 
--*/
{
    *pfFound = FALSE; 
    DWORD dwIndex = 0;
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwWait = 0;

    //
    // Look for the wanted event
    //
    for ( DWORD i = LASTPREALLOC_INDEX; i < m_dwNumEvents; i++ )
    {
        if ( m_ahEvents[i] == hEvent )
        {
            DBG_ASSERT( m_apUserData[i] == pUserData );

            *pfFound = TRUE;
            dwIndex = i;
            break;
        }
    }

    //
    // Didn't find the event, but function succeeded
    //
    if ( !*pfFound )
    {
        return TRUE;
    }

    //
    // Signal that we want to update the list of events
    //
    if ( !WSASetEvent( m_ahEvents[NEEDUPDATE_INDEX] ) )
    {
        dwRet = WSAGetLastError();

        DBGPRINTF((DBG_CONTEXT,
                   "WSASetEvent failed : 0x%x\n",
                   dwRet));

        goto exit;
    }
        
    //
    // Wait until we can update the list
    //
    dwWait = WSAWaitForMultipleEvents( 1,
                                       &(m_ahEvents[CANUPDATE_INDEX]),
                                       TRUE,
                                       900000, // 15 minutes should do it....
                                       FALSE );
    switch (dwWait) 
    {
    case WSA_WAIT_EVENT_0:
    {
        //
        // Remove the data associated with the socket 
        //

        //
        // we're not going to use the context any more, so remove the reference we hold to it
        //
        m_apUserData[dwIndex]->DeReference();

        memmove( (PVOID) (m_ahEvents + dwIndex),
                 (PVOID) (m_ahEvents + (dwIndex + 1) ),
                 sizeof(WSAEVENT) * (m_dwNumEvents - dwIndex - 1) );

        memmove( (PVOID) ( m_apUserData + dwIndex ),
                 (PVOID) (m_apUserData + (dwIndex + 1) ),
                 sizeof(LPUSER_DATA) * (m_dwNumEvents - dwIndex - 1) );

        memmove( (PVOID) (m_adwNumTimeouts + dwIndex),
                 (PVOID) (m_adwNumTimeouts + (dwIndex + 1) ),
                 sizeof(DWORD) * (m_dwNumEvents - dwIndex - 1) );
            
        m_dwNumEvents--;
        
        //
        // reset to known state
        //
        if ( !WSAResetEvent( m_ahEvents[CANUPDATE_INDEX] ) )
        {
            dwRet = WSAGetLastError();

            DBGWARN((DBG_CONTEXT,
                       "WSAResetEvent failed : 0x%x\n",
                       GetLastError()));

            goto exit;
        }

        //
        // signal that watch thread can start watching again
        //
        if ( !WSASetEvent( m_ahEvents[HAVEUPDATED_INDEX] ) )
        {
            dwRet = WSAGetLastError();

            DBGPRINTF((DBG_CONTEXT,
                       "WSASetEvent failed : 0x%x\n",
                       GetLastError()));

            goto exit;
        }
    }
    break;

    case WSA_WAIT_TIMEOUT:
    {
        IF_DEBUG( PASV )
        {
            DBGWARN((DBG_CONTEXT,
                       "Wait timed out ... \n"));
        }

        dwRet = ERROR_TIMEOUT;
        goto exit;
    }
    break;

    default:
    {
        DBGERROR((DBG_CONTEXT,
                   "Invalid return from WSAWaitForMultipleEvents : 0x%x\n",
                   dwWait));
        
        dwRet = ERROR_INVALID_PARAMETER;
    }

    }

exit:

    return ( dwRet == ERROR_SUCCESS ? TRUE : FALSE );
}

DWORD PASV_ACCEPT_CONTEXT::AddAcceptEvent( WSAEVENT hEvent,
                                           LPUSER_DATA pUserData )
/*++

    Adds an event to be signalled when a socket is accept()'able

  Arguments:
     hEvent - event that will be signalled
     pUserData - USER_DATA context to attach to signalled event

  Returns:
     Error code 
--*/
{
    DWORD dwRet = 0;
    DWORD dwWait = 0;

    if ( m_dwNumEvents == WSA_MAXIMUM_WAIT_EVENTS )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Signal that we want to update the list of events
    //
    if ( !WSASetEvent( m_ahEvents[NEEDUPDATE_INDEX] ) )
    {
        dwRet = WSAGetLastError();

        DBGWARN((DBG_CONTEXT,
                   "WSASetEvent failed : 0x%x\n",
                   dwRet));

        goto exit;
    }
        
    //
    // Wait until we can update the list
    //
    dwWait = WSAWaitForMultipleEvents( 1,
                                       &(m_ahEvents[CANUPDATE_INDEX]),
                                       TRUE,
                                       10000, //10 secs seems like a reasonable time to wait
                                       FALSE );
    switch (dwWait) 
    {
    case WSA_WAIT_EVENT_0:
    {
        //
        // cool, we can update the list
        //
        m_ahEvents[m_dwNumEvents] = hEvent;

        //
        // add a reference to make sure nobody deletes the context out from under us
        //
        pUserData->Reference();
        m_apUserData[m_dwNumEvents] = pUserData;

        m_adwNumTimeouts[m_dwNumEvents] = 0;
        m_dwNumEvents++;


        //
        // reset to known state
        //
        if ( !WSAResetEvent( m_ahEvents[CANUPDATE_INDEX] ) )
        {
            pUserData->DeReference();

            m_dwNumEvents--; //make sure event isn't still seen as valid  

            dwRet = WSAGetLastError();


            DBGWARN((DBG_CONTEXT,
                       "WSAResetEvent failed : 0x%x\n",
                       GetLastError()));

            goto exit;
        }

        //
        // signal that watch thread can start watching again
        //
        if ( !WSASetEvent( m_ahEvents[HAVEUPDATED_INDEX] ) )
        {
            pUserData->DeReference();

            m_dwNumEvents--; //make sure event isn't still seen as valid 

            dwRet = WSAGetLastError();

            DBGWARN((DBG_CONTEXT,
                       "WSASetEvent failed : 0x%x\n",
                       GetLastError()));

            goto exit;
        }

        IF_DEBUG ( PASV )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Added event for context 0x%x at index %d\n",
                       pUserData, m_dwNumEvents - 1));
        }
    }
    break;

    case WSA_WAIT_TIMEOUT:
    {
        IF_DEBUG( PASV )
        {
            DBGWARN((DBG_CONTEXT,
                       "Timed out waiting for permission to update PASV event list ... \n"));
        }

        dwRet = ERROR_TIMEOUT;
        goto exit;
    }
    break;

    default:
    {
        DBGERROR((DBG_CONTEXT,
                   "Invalid return from WSAWaitForMultipleEvents : 0x%x\n",
                   dwWait));
        
        dwRet = ERROR_INVALID_PARAMETER;
    }

    }

exit:

    return dwRet;
}



ACCEPT_CONTEXT_ENTRY::ACCEPT_CONTEXT_ENTRY()
/*++

    Constructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{
    m_pAcceptContext = new PASV_ACCEPT_CONTEXT();

    if ( !m_pAcceptContext )
    {
        DBGERROR((DBG_CONTEXT,
                   "Failed to allocate new PASV_ACCEPT_CONTEXT !\n"));
    }
}

ACCEPT_CONTEXT_ENTRY::~ACCEPT_CONTEXT_ENTRY()
/*++

    Destructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{
    if ( m_pAcceptContext )
    {
        delete m_pAcceptContext;
    }
}



DWORD CreateInitialAcceptContext()
/*++

    Creates the first PASV_ACCEPT_CONTEXT object 

  Arguments:
     None

  Returns:
     Error indicating success/failure
--*/
{
    ACCEPT_CONTEXT_ENTRY *pEntry =  NULL;
    DWORD dwRet = ERROR_SUCCESS;

    if ( !(pEntry = new ACCEPT_CONTEXT_ENTRY() ) )
    {
        DBGERROR((DBG_CONTEXT,
                   "Failed to allocate new ACCEPT_CONTEXT_ENTRY !\n"));
        
        return ERROR_OUTOFMEMORY;
    }

    if ( NULL == pEntry->m_pAcceptContext )
    {
        DBGERROR((DBG_CONTEXT,
                   "Failed to allocate new ACCEPT_CONTEXT_ENTRY::m_pAcceptContext !\n"));

        delete pEntry;
        return ERROR_OUTOFMEMORY;
    }
    if ( ( dwRet = pEntry->m_pAcceptContext->ErrorStatus() ) != ERROR_SUCCESS )
    {
        DBGERROR((DBG_CONTEXT,
                   "Error occurred constructing PASV_ACCEPT_CONTEXT : 0x%x\n",
                   pEntry->m_pAcceptContext->ErrorStatus()));

        delete pEntry;
        return dwRet;
    }

    InsertHeadList( &g_AcceptContextList, &pEntry->ListEntry );

    return dwRet;
}

VOID DeleteAcceptContexts()
/*++

    Deletes all of the PASV_ACCEPT_CONTEXT objects

  Arguments:
     None

  Returns:
     Nothing 
--*/

{
    while ( !IsListEmpty( &g_AcceptContextList ) )
    {
        ACCEPT_CONTEXT_ENTRY *pEntry = CONTAINING_RECORD( g_AcceptContextList.Flink,
                                                          ACCEPT_CONTEXT_ENTRY,
                                                          ListEntry );
        RemoveEntryList( &(pEntry->ListEntry) );

        delete pEntry;
    }
}

DWORD AddAcceptEvent( WSAEVENT hEvent,
                      LPUSER_DATA pUserData )
/*++

    Adds an accept event to an available PASV_ACCEPT_CONTEXT 

  Arguments:
      hEvent - handle to event to be added 
      pUserData - USER_DATA context to attach to event 

  Returns:
     Error code indicating success/failure
--*/
{
    LIST_ENTRY *pEntry = NULL;
    PPASV_ACCEPT_CONTEXT pAcceptContext = NULL;
    PACCEPT_CONTEXT_ENTRY pContextEntry = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL fFoundOne = FALSE;

    pUserData->FakeIOTimes = 0;

    //
    // Walk the list of contexts looking for one that can handle an additional
    // event. 
    // 
    // NB : currently [9/20/98], that list contains only a -single- context, so we can handle
    // up to a maximum of (WSA_MAXIMUM_WAIT_EVENTS - 4) events. If we want to get really 
    // fancy, we could add the necessary code to create a new PASV_ACCEPT_CONTEXT as necessary,
    // but that also creates a new thread, and actually opens us up even more to a Denial Of
    // Service attack, which is partly what this code is trying to avoid
    //
    for ( pEntry = g_AcceptContextList.Flink;
          pEntry != &g_AcceptContextList;
          pEntry = pEntry->Flink )
    {
        pContextEntry =  CONTAINING_RECORD( pEntry, ACCEPT_CONTEXT_ENTRY , ListEntry );
        pAcceptContext = pContextEntry->m_pAcceptContext;

        pAcceptContext->Lock();

        if ( pAcceptContext->QueryNumEvents() < WSA_MAXIMUM_WAIT_EVENTS )
        {
            dwRet = pAcceptContext->AddAcceptEvent( hEvent,
                                                    pUserData );
            
            fFoundOne = TRUE;
        }
        
        pAcceptContext->Unlock();
        
        if ( fFoundOne )
            break;
    }
    
    if (!fFoundOne )
    {
        dwRet = ERROR_OUTOFMEMORY; //not quite the right error 
    }

    return dwRet;
}

BOOL RemoveAcceptEvent( WSAEVENT hEvent,
                        LPUSER_DATA pUserData )
/*++

    Removes an accept event from the appropriate PASV_ACCEPT_CONTEXT 

  Arguments:
      hEvent - handle to event to be removed
      pUserData - USER_DATA context attached to event

  Returns:
      BOOL indicating success/failure
--*/
{
    LIST_ENTRY *pEntry = NULL;
    PPASV_ACCEPT_CONTEXT pAcceptContext = NULL;
    PACCEPT_CONTEXT_ENTRY pContextEntry = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL fFound = FALSE;
    BOOL fSuccess = FALSE;

    //
    // Walk the list of contexts looking for the one that holds the event 
    // event. 
    // 
    for ( pEntry = g_AcceptContextList.Flink;
          pEntry != &g_AcceptContextList;
          pEntry = pEntry->Flink )
    {
        pContextEntry =  CONTAINING_RECORD( pEntry, ACCEPT_CONTEXT_ENTRY , ListEntry );
        pAcceptContext = pContextEntry->m_pAcceptContext;

        pAcceptContext->Lock();

        fSuccess = pAcceptContext->RemoveAcceptEvent( hEvent,
                                                      pUserData,
                                                      &fFound );

        if ( fFound )
        {
            pAcceptContext->Unlock();
            return fSuccess;
        }

        pAcceptContext->Unlock();
    }

    return TRUE;
}

DWORD WINAPI PASV_ACCEPT_CONTEXT::AcceptThreadFunc( LPVOID pvContext )
/*++

      Thread function for the thread that waits on the accept events

  Arguments:
      pvContext - context pointer (pointer to PASV_ACCEPT_CONTEXT object)

  Returns:
     Nothing useful
--*/

{
    PPASV_ACCEPT_CONTEXT pAcceptContext = NULL;
    WSAEVENT *phAcceptEvents = NULL;
    DWORD dwNumEvents = 0;
    DWORD dwRet = 0;
    WSAEVENT *phNeedUpdate = NULL;
    WSAEVENT *phCanUpdate = NULL;
    WSAEVENT *phHaveUpdated = NULL;
    WSAEVENT *phExitThread = NULL;

    DBG_ASSERT( pvContext );

    pAcceptContext = (PPASV_ACCEPT_CONTEXT) pvContext;
    phAcceptEvents = pAcceptContext->m_ahEvents;
    dwNumEvents = pAcceptContext->m_dwNumEvents;
    phNeedUpdate = &phAcceptEvents[NEEDUPDATE_INDEX];
    phCanUpdate = &phAcceptEvents[CANUPDATE_INDEX];
    phHaveUpdated = &phAcceptEvents[HAVEUPDATED_INDEX];
    phExitThread = &phAcceptEvents[EXITTHREAD_INDEX];

loop:

    // wait timeout should be fairly small, so we can go through list and purge all
    // sockets that have been inactive a given # of timeouts

    dwRet = WSAWaitForMultipleEvents( dwNumEvents,
                                      phAcceptEvents,
                                      FALSE,
                                      PASV_TIMEOUT_INTERVAL,
                                      FALSE );

    if ( dwRet <= (WSA_WAIT_EVENT_0 + dwNumEvents - 1) )
    {
        //
        // One of the events was signalled
        //
        DWORD dwIndex = dwRet - WSA_WAIT_EVENT_0;

        switch (dwIndex)
        {
        case (NEEDUPDATE_INDEX):
        {
            //
            // Somebody wants to update the list of events to watch for, so signal that
            // they can do so and wait for them to tell us they're done with the update
            //
            if ( !WSAResetEvent( *phNeedUpdate ) ) //back to known state 
            {
                DBGWARN((DBG_CONTEXT,
                           "WSAResetEvent failed : 0x%x\n",
                           WSAGetLastError()));
            }

            if ( !WSASetEvent( *phCanUpdate ) )
            {
                DBGWARN((DBG_CONTEXT,
                           "WSASetEvent failed : 0x%x\n",
                           WSAGetLastError()));
            }

            if ( WSAWaitForMultipleEvents( 1,
                                           phHaveUpdated,
                                           TRUE,
                                           INFINITE,
                                           FALSE )  == WSA_WAIT_FAILED )
            {
                DBGERROR((DBG_CONTEXT,
                           "WSAWaitForMultipleEvents failed : 0x%x\n",
                           WSAGetLastError()));
            }

            if ( !WSAResetEvent( *phHaveUpdated ) ) //back to known state
            {
                DBGWARN((DBG_CONTEXT,
                           "WSAResetEvent failed : 0x%x\n",
                           WSAGetLastError()));
            }

            dwNumEvents = pAcceptContext->m_dwNumEvents;

            goto loop;
        }
        break;

        case (CANUPDATE_INDEX):
        case (HAVEUPDATED_INDEX):
        {
            //
            // Should never happen !
            //
            IF_DEBUG ( PASV )
            {
                DBGERROR((DBG_CONTEXT,
                           "Invalid event signalled !\n"));
            }
        }
        break;

        case (EXITTHREAD_INDEX):
        {
            //
            // We're all done 
            //
            IF_DEBUG ( PASV )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Exiting thread watching for PASV events....\n"));
            }

            return 0;
        }
        break;

        default:
        {
            LPUSER_DATA pUserData = NULL;

            //
            // One of the sockets has become accept()'able.
            //
            IF_DEBUG ( PASV )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Got an acceptable socket, index : %i, context : 0x%x\n",
                           dwIndex, pAcceptContext->m_apUserData[dwIndex]));
            }

            pUserData = pAcceptContext->m_apUserData[dwIndex];

            //
            // Remove the data associated with the socket 
            //
            memmove( (PVOID) (pAcceptContext->m_ahEvents + dwIndex),
                     (PVOID) (pAcceptContext->m_ahEvents + (dwIndex + 1) ),
                     sizeof(WSAEVENT) * (dwNumEvents - dwIndex - 1) );

            memmove( (PVOID) ( pAcceptContext->m_apUserData + dwIndex ),
                     (PVOID) (pAcceptContext->m_apUserData + (dwIndex + 1) ),
                     sizeof(LPUSER_DATA) * (dwNumEvents - dwIndex - 1) );

            memmove( (PVOID) (pAcceptContext->m_adwNumTimeouts + dwIndex),
                     (PVOID) (pAcceptContext->m_adwNumTimeouts + (dwIndex + 1) ),
                     sizeof(DWORD) * (dwNumEvents - dwIndex - 1) );
            
            pAcceptContext->m_dwNumEvents--;

            dwNumEvents = pAcceptContext->m_dwNumEvents;

            //
            // deal with restarting processing
            // 
            SignalAcceptableSocket( pUserData );

            goto loop;
        }
        }
    }
    else if ( dwRet == WSA_WAIT_TIMEOUT )
    {
        //
        // wait timed out, so go through the list of events and remove those that have
        // timed out too often
        //
        for ( DWORD i = LASTPREALLOC_INDEX;//skip the events that don't have a fixed # of timeouts
              i < dwNumEvents; 
              i++ )
        {
            if ( pAcceptContext->m_adwNumTimeouts[i] == MAX_PASV_TIMEOUTS )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "timing out socket at index %i, context 0x%x \n",
                           i,
                           pAcceptContext->m_apUserData[i]));

                CleanupTimedOutSocketContext( pAcceptContext->m_apUserData[i] );

                memmove( (PVOID) (pAcceptContext->m_ahEvents + i),
                         (PVOID) (pAcceptContext->m_ahEvents + (i+1) ),
                         sizeof(WSAEVENT) * (dwNumEvents - i - 1) );

                memmove( (PVOID) ( pAcceptContext->m_apUserData + i ),
                         (PVOID) (pAcceptContext->m_apUserData + (i+1) ),
                         sizeof(LPUSER_DATA) * (dwNumEvents - i - 1) );

                memmove( (PVOID) (pAcceptContext->m_adwNumTimeouts + i),
                         (PVOID) (pAcceptContext->m_adwNumTimeouts + (i+1) ),
                         sizeof(DWORD) * (dwNumEvents - i - 1) );

                //
                // need to readjust the index and number of items in the array
                //
                i--;
                dwNumEvents--;

                pAcceptContext->m_dwNumEvents--;
            }
            else
            {
                pAcceptContext->m_adwNumTimeouts[i]++;
            }
        }

        dwNumEvents = pAcceptContext->m_dwNumEvents;

        goto loop;
    }
    else if ( dwRet == WAIT_IO_COMPLETION )
    {
        DBGWARN((DBG_CONTEXT,
                   "Invalid value from WSAWaitForMultipleEvents !\n"));


        goto loop;
    }
    else 
    {
        DBGERROR((DBG_CONTEXT,
                   "WSAWaitForMultipleEvents returned 0x%x, error : 0x%x\n", 
                   dwRet, WSAGetLastError()));

        goto loop;
    }

    return 0;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\asyncio.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

       asyncio.cxx

   Abstract:

       This module implements functions for ASYNC_IO_CONNECTION Object.

   Author:

       Murali R. Krishnan    ( MuraliK )    27-March-1995

   Environment:

      User Mode -- Win32

   Project:

      Internet Services DLL

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
// need to include ftpdp.hxx here since precompiled header used.
# include "ftpdp.hxx"

# include "dbgutil.h"
# include "asyncio.hxx"
# include "..\..\infocomm\atq\atqtypes.hxx"


/************************************************************
 *   Functions
 ************************************************************/



ASYNC_IO_CONNECTION::ASYNC_IO_CONNECTION(
   IN  PFN_ASYNC_IO_COMPLETION  pfnAioCompletion,
   IN  SOCKET sClient OPTIONAL
   )
:   m_pAioContext      ( NULL),
    m_pfnAioCompletion ( pfnAioCompletion),
    m_sClient          ( sClient),
    m_sTimeout         ( DEFAULT_CONNECTION_IO_TIMEOUT),
    m_pAtqContext      ( NULL),
    m_endpointObject   ( NULL)
{
    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Created a new ASYNC_IO_CONNECTION object ( %08x)\n",
                    this
                    ));
    }

} // ASYNC_IO_CONNECTION::ASYNC_IO_CONNECTION()




ASYNC_IO_CONNECTION::~ASYNC_IO_CONNECTION( VOID)
/*++
  This function cleans up the ASYNC_IO_CONNECTION object. It also frees
  up sockets and ATQ context embedded in this object.

  THIS IS NOT MULTI_THREAD safe!

--*/
{

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Deleting the ASYNC_IO_CONNECTION object ( %08x) \n",
                    this
                    ));
    }

    if ( m_sClient != INVALID_SOCKET) {

        //
        // Shut and Close the socket. This can fail, if the socket is already
        //  closed by some other thread before this operation completes
        //

        StopIo( NO_ERROR);
    }

    if ( m_pAtqContext != NULL) {

       AtqFreeContext( m_pAtqContext, TRUE );
       m_pAtqContext = NULL;
    }

    DBG_ASSERT( m_sClient == INVALID_SOCKET);

} // ASYNC_IO_CONNECTION::~ASYN_IO_CONNECTION()





BOOL
ASYNC_IO_CONNECTION::ReadFile(
    OUT LPVOID   pvBuffer,
    IN DWORD     cbSize
    )
/*++
  This starts off an Asynchronous read operation for data from client
   into the supplied buffer.

  Arguments:
     pvBuffer         pointer to byte buffer which on successful
                        return will contain the data read from client
     cbSize           count of bytes of data available in the buffer.
                        ( limits the size of data that can be read)

  Returns:
    TRUE on success and FALSE if there is a failure in setting up read.
--*/
{
    BOOL fReturn = TRUE;

    DBG_ASSERT( pvBuffer != NULL);

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "ReadFile( %08x, %u)\n",
                    this, pvBuffer, cbSize
                    ));
    }

    if (( m_pAtqContext == NULL && !AddToAtqHandles()) ||
        !AtqReadFile( m_pAtqContext, pvBuffer, cbSize, NULL )) {

        IF_DEBUG( ASYNC_IO) {

            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::WriteFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::ReadFile()





BOOL
ASYNC_IO_CONNECTION::WriteFile(
    OUT LPVOID   pvBuffer,
    IN DWORD     cbSize
    )
/*++
  This starts off an Asynchronous write operation to send data to the client
    sending data from the supplied buffer. The buffer may not be freed
    until the data is sent out.

  Arguments:
     pvBuffer         pointer to byte buffer which contains the data to be sent
                       to the client.
     cbSize           count of bytes of data to be sent.

  Returns:
    TRUE on success and FALSE if there is a failure in setting up write.
--*/
{
    BOOL fReturn = TRUE;
    DBG_ASSERT( pvBuffer != NULL);

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "WriteFile( %08x, %u)\n",
                    this, pvBuffer, cbSize
                    ));
    }

    //
    // Check and add to create an atq context as well as perform
    //  the write operation.
    //
    if ( (m_pAtqContext == NULL && !AddToAtqHandles()) ||
        !AtqWriteFile( m_pAtqContext, pvBuffer, cbSize, NULL )) {

        IF_DEBUG( ASYNC_IO) {
            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::WriteFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::WriteFile()





BOOL
ASYNC_IO_CONNECTION::TransmitFile(
    IN HANDLE  hFile,
    IN LARGE_INTEGER & liSize,
    IN DWORD   dwOffset,
    IN LPTRANSMIT_FILE_BUFFERS   lpTransmitBuffers OPTIONAL
    )
/*++
  This starts off an Asynchronous TransmitFile operation to send file data
   to the client.

  Arguments:
    hFile            handle for the file to be transmitted.
    liSize           large integer containing size of file to be sent.
    Offset           Offset within the file to begin transmitting.
    lpTransmitBuffers pointer to File Transmit Buffers

  Returns:
    TRUE on success and FALSE if there is a failure in setting up read.
--*/
{
    BOOL fReturn = TRUE;
    DBG_ASSERT( hFile != INVALID_HANDLE_VALUE);

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "TransmitFile( %08x, %l, %ul, %08x)\n",
                    this, hFile, liSize.HighPart, liSize.LowPart,
                    lpTransmitBuffers
                    ));
    }

    if ( m_pAtqContext == NULL )
    {
        if (!AddToAtqHandles())
        {
            IF_DEBUG( ASYNC_IO)
            {
                DWORD dwError = GetLastError();
                DBGPRINTF(( DBG_CONTEXT,
                           "ASYNC_IO_CONNECTION(%08x)::AddToAtqHandles() failed."
                           " Error = %u\n",
                           this, dwError));
                SetLastError( dwError);
            }

            return FALSE;
        }
    }

    m_pAtqContext->Overlapped.Offset = dwOffset;

    if (!AtqTransmitFile( m_pAtqContext,
                          hFile,
                          ((liSize.HighPart == 0) ? liSize.LowPart : 0),
                          lpTransmitBuffers,
                          TF_DISCONNECT )
        )
    {

        IF_DEBUG( ASYNC_IO) {
            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::TransmitFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::TransmitFile()



BOOL
ASYNC_IO_CONNECTION::TransmitFileTs(
    IN TS_OPEN_FILE_INFO * pOpenFile,
    IN LARGE_INTEGER &     liSize,
    IN DWORD               dwOffset
    )
/*++
  This starts off an Asynchronous TransmitFile operation to send file data
   to the client.

  Arguments:
    hFile            handle for the file to be transmitted.
    liSize           large integer containing size of file to be sent.
    Offset           Offset within the file to begin transmitting.

  Returns:
    TRUE on success and FALSE if there is a failure in setting up read.
--*/
{
    BOOL   fReturn = TRUE;
    PBYTE  pFileBuffer = NULL;
    HANDLE hFile = NULL;
    TRANSMIT_FILE_BUFFERS TransmitBuffers;

    DBG_ASSERT( pOpenFile );

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "TransmitFile( %p, %p, %ul, %08x)\n",
                    this, pOpenFile, liSize.HighPart, liSize.LowPart
                    ));
    }

    if ( m_pAtqContext == NULL )
    {
        if (!AddToAtqHandles())
        {
            IF_DEBUG( ASYNC_IO)
            {
                DWORD dwError = GetLastError();
                DBGPRINTF(( DBG_CONTEXT,
                           "ASYNC_IO_CONNECTION(%08x)::AddToAtqHandles() failed."
                           " Error = %u\n",
                           this, dwError));
                SetLastError( dwError);
            }

            return FALSE;
        }
    }

    pFileBuffer = pOpenFile->QueryFileBuffer();
    if (pFileBuffer) {
        //
        // Transmit from memory
        //

        DBG_ASSERT( liSize.HighPart == 0 );

        TransmitBuffers.Head       = pFileBuffer + dwOffset;
        TransmitBuffers.HeadLength = liSize.LowPart;
        TransmitBuffers.Tail       = NULL;
        TransmitBuffers.TailLength = 0;
    } else {
        //
        // Transmit from a file
        //
        hFile = pOpenFile->QueryFileHandle();
        m_pAtqContext->Overlapped.Offset = dwOffset;

        if (liSize.HighPart != 0)
        {
            LARGE_INTEGER liTimeOut;
            ULONG Remainder;

            liTimeOut =
                RtlExtendedLargeIntegerDivide(
                liSize,
                (ULONG) 1024,
                &Remainder);

            if (liTimeOut.HighPart != 0)
            {
                ((PATQ_CONT) m_pAtqContext)->TimeOut = ATQ_INFINITE;
            } else
            {
                ((PATQ_CONT) m_pAtqContext)->TimeOut = liTimeOut.LowPart;
            }
        }
    }

    if (!AtqTransmitFile( m_pAtqContext,
                          hFile,
                          ((liSize.HighPart == 0) ? liSize.LowPart : 0),
                          pFileBuffer ? &TransmitBuffers : NULL,
                          TF_DISCONNECT )
        )
    {

        IF_DEBUG( ASYNC_IO) {
            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::TransmitFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::TransmitFile()




BOOL
ASYNC_IO_CONNECTION::StopIo( IN DWORD  dwErrorCode OPTIONAL)
/*++
  This function stops the io connection by performing a hard close on
  the socket that is used for IO. that is the only way one can easily kill the
  IO that is in progress.

  Arguments:
    dwErrorCode   DWORD containing the error code for stopping IO

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
{
    INT serr = 0;

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ASYNC_IO_CONNECTION( %08x)::StopIo( %u)\n",
                    this, dwErrorCode
                    ));
    }

    //
    // NYI! dwErrorCode is not at present used.
    //

    if ( m_sClient != INVALID_SOCKET) {

        SOCKET sOld = m_sClient;
        m_sClient = INVALID_SOCKET;

        // MuraliK  07/25/95  Shutdown causes problems in sending last msg.
# ifdef ENABLE_SHUT_DOWN

        // Shut the socket and close it
        // even if shut fails, still go ahead and close

        if ( shutdown( sOld, 0) == SOCKET_ERROR) {

            IF_DEBUG( ASYNC_IO) {
                DBGPRINTF((DBG_CONTEXT,
                           " ASYNC_IO_CONNECTION( %08x)::StopIo( %u)."
                           "shutdown(%08x,1) failed. Error = %d\n",
                           this, dwErrorCode, sOld, WSAGetLastError()));
            }

            DBGERROR((DBG_CONTEXT, "shutdown(%u, 0) failed. Error=%u\n",
                      sOld, WSAGetLastError()));
        }
#endif // ENABLE_SHUT_DOWN

        //
        // patch added on 11/2/95
        //  After AcceptEx addition, closing the ATQ'ed socket is
        //   is to be done by ATQ module.
        //

        if ( sOld != INVALID_SOCKET) {

            if (m_pAtqContext != NULL) {

                //
                // per the FTP RFC, the server must close the socket when killing a data
                // channel.
                //

                if (!AtqCloseSocket( m_pAtqContext, TRUE)) {

                    serr = GetLastError();
                }
            } else {

                // Ignore failures in Shutdown and close socket.
                if (closesocket( sOld) == SOCKET_ERROR) {

                    serr = WSAGetLastError();
                }
            }

            if ( serr != 0 ) {

                SetLastError( serr);
            }
        }
    }

    return ( serr == 0);
} // ASYNC_IO_CONNECTION::StopIo()




BOOL
ASYNC_IO_CONNECTION::SetNewSocket(IN SOCKET sNewSocket,
                                  IN PATQ_CONTEXT pNewAtqContext, // = NULL
                                  IN PVOID EndpointObject )
/*++

  This function changes the socket maintained for given ASYNC_IO_CONNECTION
  object. It changes it only if the current socket in the object is already
   freed (by calling StopIo()).

  If the Atq Context in this object is a valid one corresponding to old
   socket, it is also freed. So any new operation will create a new AtqContext.
  (This is essential, since there is a one-to-one-relationship between socket
   and ATQ context)


  Arguments:
    sNewSocket   new socket for the connection
     If sNewSocket == INVALID_SOCKET then this function does
       cleanup of old information.

    pNewAtqContext  new ATQ Context for the socket

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = TRUE;

    if ( m_sClient == INVALID_SOCKET) {

        //
        // Free the Atq Context if one already exists.
        //  ==> Reason: There is a one-to-one correspondence b/w ATQ Context
        //               and socket. The atq context if valid was created
        //               for old connection.
        //

        // To avoid race conditions, we exchange pointer with NULL
        //  and later on free the object as need be.
        // Should we necessarily use InterlockedExchange() ???
        //  Isn't it costly? NYI

        PATQ_CONTEXT pAtqContext =
          (PATQ_CONTEXT ) InterlockedExchangePointer( (PVOID *) &m_pAtqContext,
                                              (PVOID) pNewAtqContext);

        if ( pAtqContext != NULL) {

            AtqFreeContext( pAtqContext, TRUE );
        }

        m_sClient = sNewSocket;
        m_endpointObject = EndpointObject;

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::SetNewSocket()



# if DBG

VOID ASYNC_IO_CONNECTION::Print( VOID) const
{

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing ASYNC_IO_CONNECTION( %08x)\n"
                " CallBackFunction = %08x; Context = %08x\n"
                " Client Socket = %u; AtqContext = %08x;"
                " Timeout = %u sec; \n",
                this, m_pfnAioCompletion, m_pAioContext,
                m_sClient, m_pAtqContext, m_sTimeout));

    return;
} // ASYNC_IO_CONNECTION::Print()


# endif // DBG





VOID
ProcessAtqCompletion(IN LPVOID       pContext,
                     IN DWORD        cbIo,
                     IN DWORD        dwCompletionStatus,
                     IN OVERLAPPED * lpo
                     )
/*++

  This function processes the completion of an atq operation.
  It also sends a call back to the owner of this object ( ASYNC_IO_CONNECTION)
    object, once the operation is completed or if it is in error.

  ATQ module sends 2 messages whenever there is a timeout.
  Reason: The timeout itself is sent by a separate thread and completion port
   API does not support removal of a socket from the completion port. Combining
   these together, ATQ sends a separate timeout message and then when the
   application blows off the socket/handle, ATQ sends another error message
   implying failure of the connection.
    We handle this as follows:
      At timeout ATQ sends fIOCompletion == FALSE and
         dwCompletionStatus == ERROR_SEM_TIMEOUT.
      We send this as fTimedOut in call back.
      The application can check if it is fTimedOut and hence refrain from
       blowing the object completely away.

  Arguments:
     pContext     pointer to User supplied context information
                   ( here: pointer to ASYNC_IO_CONNECTION associated with
                           the IO completed)
     cbIo         count of bytes of IO performed
     dwCompletionStatus  DWORD containing error code if any
     lpo - !NULL if completion from IO

  Returns:
     None
--*/
{
    LPASYNC_IO_CONNECTION   pConn = (LPASYNC_IO_CONNECTION ) pContext;
    BOOL  fTimedOut = FALSE;

    if ( pConn == NULL) {

        // This should not happen....

        SetLastError( ERROR_INVALID_PARAMETER);

        DBG_ASSERT( pConn == NULL);
        return ;
    }

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "ProcessAtqCompletion(Aio=%08x, cb=%u, Status=%u,"
                    "IO Compltion=%s).\n",
                    pConn,  cbIo, dwCompletionStatus,
                    lpo != NULL ? "TRUE" : "FALSE" ));
    }

    if ( lpo != NULL ||
         (fTimedOut = (
                       lpo == NULL &&
                       dwCompletionStatus == ERROR_SEM_TIMEOUT))
        ) {

        //
        //  This is the right Atq object. Process the response by passing it
        //    to the owner of this object.
        //

        DBG_ASSERT( pConn->QueryPfnAioCompletion() != NULL);

        //
        // Invoke the call back function for completion of IO.
        //

        ( *pConn->QueryPfnAioCompletion())
          (pConn->QueryAioContext(), cbIo, dwCompletionStatus,
           pConn, fTimedOut);

    }

    return;

} // ProcessAtqCompletion()





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\aap.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    aap.cxx

    This module contains implementation of the Asynchronous Accept Pool
    package.

    Functions exported by this module:

        AapInitialize
        AapTerminate
        AapAcquire
        AapRelease
        AapAccept
        AapAbort


    FILE HISTORY:
        KeithMo     01-Mar-1995 Created.

*/


#include "ftpdp.hxx"


//
//  Private constants.
//

#define MAX_IDLE_THREADS        10

#define AapLockLists()          EnterCriticalSection( &p_AapListLock )
#define AapUnlockLists()        LeaveCriticalSection( &p_AapListLock )


//
//  Private types.
//

typedef enum _AAP_STATE
{
    AapStateFirst = -1,                 // Must be first aap state!

    AapStateIdle,                       // Idle.
    AapStateActive,                     // Waiting for incoming connection.
    AapStateAbort,                      // Aborting, return to idle.
    AapStateShutdown,                   // Shutting down.

    AapStateLast                        // Must be last aap state!

} AAP_STATE;

#define IS_VALID_AAP_STATE(x)   (((x) > AapStateFirst) && ((x) < AapStateLast))

typedef struct _AAP_CONTEXT
{
    //
    //  Structure signature, for safety's sake.
    //

    DEBUG_SIGNATURE

    //
    //  Links onto a list of idle/active contexts.
    //

    LIST_ENTRY          ContextList;

    //
    //  Current state.
    //

    AAP_STATE           State;

    //
    //  The listening socket.
    //

    SOCKET              ListeningSocket;

    //
    //  An event object for synchronizing with the worker thread.
    //

    HANDLE              EventHandle;

    //
    //  A handle to the worker thread for synchronizing shutdown.
    //

    HANDLE              ThreadHandle;

    //
    //  The callback associated with this context.
    //

    LPAAP_CALLBACK      AapCallback;

    //
    //  A user-definable context.
    //

    LPVOID              UserContext;

} AAP_CONTEXT, * LPAAP_CONTEXT;

#if DBG
#define AAP_SIGNATURE           (DWORD)'cPaA'
#define AAP_SIGNATURE_X         (DWORD)'paaX'
#define INIT_AAP_SIG(p)         ((p)->Signature = AAP_SIGNATURE)
#define KILL_AAP_SIG(p)         ((p)->Signature = AAP_SIGNATURE_X)
#define IS_VALID_AAP_CONTEXT(p) (((p) != NULL) && ((p)->Signature == AAP_SIGNATURE))
#else   // !DBG
#define INIT_AAP_SIG(p)         ((void)(p))
#define KILL_AAP_SIG(p)         ((void)(p))
#define IS_VALID_AAP_CONTEXT(p) (((void)(p)), TRUE)
#endif  // DBG


//
//  Private globals.
//

LIST_ENTRY              p_AapIdleList;
LIST_ENTRY              p_AapActiveList;
CRITICAL_SECTION        p_AapListLock;
DWORD                   p_AapIdleCount;


//
//  Private prototypes.
//

LPAAP_CONTEXT
AappCreateContext(
    VOID
    );

VOID
AappFreeResources(
    LPAAP_CONTEXT AapContext
    );

DWORD
AappWorkerThread(
    LPVOID Param
    );


//
//  Public functions.
//

/*******************************************************************

    NAME:       AapInitialize

    SYNOPSIS:   Initializes the AAP package.

    EXIT:       APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
APIERR
AapInitialize(
    VOID
    )
{
    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "in AapInitialize\n" ));
    }

    //
    //  Initialize the critical section.
    //

    INITIALIZE_CRITICAL_SECTION( &p_AapListLock );

    //
    //  Initialize the worker lists.
    //

    InitializeListHead( &p_AapIdleList );
    InitializeListHead( &p_AapActiveList );

    p_AapIdleCount   = 0;

    //
    //  Success!
    //

    return 0;

}   // AapInitialize

/*******************************************************************

    NAME:       AapTerminate

    SYNOPSIS:   Terminates the AAP package.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
VOID
AapTerminate(
    VOID
    )
{
    PLIST_ENTRY Entry;

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "in AapTerminate\n" ));
    }

    //
    //  Lock the lists.
    //

    AapLockLists();

    //
    //  Scan the idle list and blow them away.
    //

    Entry = p_AapIdleList.Flink;

    while( Entry != &p_AapIdleList )
    {
        LPAAP_CONTEXT AapContext;

        AapContext = CONTAINING_RECORD( Entry, AAP_CONTEXT, ContextList );
        Entry      = Entry->Flink;
        DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );
        DBG_ASSERT( AapContext->State == AapStateIdle );

        IF_DEBUG( AAP )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AapTerminate: killing idle context @ %08lX\n",
                        AapContext ));
        }

        //
        //  Set the state to closing so the thread will know to exit.
        //

        AapContext->State = AapStateShutdown;

        //
        //  Signal the event to wake up the thread.
        //

        DBG_ASSERT( AapContext->EventHandle != NULL );
        TCP_REQUIRE( SetEvent( AapContext->EventHandle ) );
    }

    //
    //  Scan the active list and blow them away.
    //

    Entry = p_AapActiveList.Flink;

    while( Entry != &p_AapActiveList )
    {
        LPAAP_CONTEXT AapContext;
        SOCKET        Socket;

        AapContext = CONTAINING_RECORD( Entry, AAP_CONTEXT, ContextList );
        Entry      = Entry->Flink;
        DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );
        DBG_ASSERT( AapContext->State == AapStateActive );

        IF_DEBUG( AAP )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AapTerminate: killing active context @ %08lX\n",
                        AapContext ));
        }

        //
        //  Set the state to closing so the thread will know to exit.
        //

        AapContext->State = AapStateShutdown;

        //
        //  Close the listening socket to wake up the thread.
        //

        Socket = AapContext->ListeningSocket;
        DBG_ASSERT( Socket != INVALID_SOCKET );
        AapContext->ListeningSocket = INVALID_SOCKET;

        TCP_REQUIRE( closesocket( Socket ) == 0 );

        DBG_ASSERT( AapContext->EventHandle != NULL );
        TCP_REQUIRE( SetEvent( AapContext->EventHandle ) );
    }

    //
    //  Wait for the worker threads to exit.  Note that the list
    //  lock is currently held.
    //

    for( ; ; )
    {
        LPAAP_CONTEXT AapContext;

        //
        //  Find a thread to wait on.  If both lists are empty,
        //  then we're done.
        //

        if( IsListEmpty( &p_AapIdleList ) )
        {
            if( IsListEmpty( &p_AapActiveList ) )
            {
                break;
            }

            AapContext = CONTAINING_RECORD( p_AapActiveList.Flink,
                                            AAP_CONTEXT,
                                            ContextList );
        }
        else
        {
            AapContext = CONTAINING_RECORD( p_AapIdleList.Flink,
                                            AAP_CONTEXT,
                                            ContextList );
        }

        DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );
        DBG_ASSERT( AapContext->State == AapStateShutdown );

        //
        //  Unlock the lists, wait for the thread to exit, then
        //  relock the lists.
        //

        AapUnlockLists();
        WaitForSingleObject( AapContext->ThreadHandle, INFINITE );
        AapLockLists();

        //
        //  Note that worker threads will neither close their thread
        //  handles nor free their AAP_CONTEXT structures during shutdown.
        //  This is our responsibility.
        //

        AappFreeResources( AapContext );
    }

    DBG_ASSERT( p_AapIdleCount == 0 );

    //
    //  Unlock the lists.
    //

    AapUnlockLists();

}   // AapTerminate

/*******************************************************************

    NAME:       AapAcquire

    SYNOPSIS:   Acquires an AAP socket/thread pair for a future
                asynchronous accept request.

    ENTRY:      AapCallback - Pointer to a callback function to be
                    invoked when the accept() completes.

                UserContext - An uninterpreted context value passed
                    into the callback.

    EXIT:       AAP_HANDLE - A valid AAP handle if !NULL, NULL if
                    an error occurred.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
AAP_HANDLE
AapAcquire(
    LPAAP_CALLBACK AapCallback,
    LPVOID         UserContext
    )
{
    PLIST_ENTRY   Entry;
    LPAAP_CONTEXT AapContext;

    //
    //  Sanity check.
    //

    DBG_ASSERT( AapCallback != NULL );

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AapAcquire: callback @ %08lX, context = %08lX\n",
                    AapCallback,
                    UserContext ));
    }

    //
    //  See if there's something available on the idle list.
    //

    AapLockLists();

    if( !IsListEmpty( &p_AapIdleList ) )
    {
        Entry      = RemoveHeadList( &p_AapIdleList );
        AapContext = CONTAINING_RECORD( Entry, AAP_CONTEXT, ContextList );
        DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );
        DBG_ASSERT( AapContext->State == AapStateIdle );

        DBG_ASSERT( p_AapIdleCount > 0 );
        p_AapIdleCount--;

        IF_DEBUG( AAP )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AapAcquire: got idle context @ %08lX\n",
                        AapContext ));
        }
    }
    else
    {
        //
        //  Create a new one.
        //

        AapContext = AappCreateContext();
    }

    if( AapContext != NULL )
    {
        //
        //  Initialize it.
        //

        AapContext->AapCallback = AapCallback;
        AapContext->UserContext = UserContext;
        AapContext->State       = AapStateActive;

        //
        //  Put it on the active list.
        //

        InsertHeadList( &p_AapActiveList, &AapContext->ContextList );
    }

    //
    //  Unlock the lists & return the (potentially NULL) context.
    //

    AapUnlockLists();

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AapAcquire: returning context @ %08lX\n",
                    AapContext ));
    }

    return AapContext;

}   // AapAcquire

/*******************************************************************

    NAME:       AapRelease

    SYNOPSIS:   Releases an open AAP handle and makes the associated
                socket/thread pair available for use.

    ENTRY:      AapHandle - A valid AAP handle returned by AapAcquire().
                    After this API completes, the handle is no longer
                    valid.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
VOID
AapRelease(
    AAP_HANDLE AapHandle
    )
{
    //
    //  Sanity check.
    //

    DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapHandle ) );
    DBG_ASSERT( AapHandle->State == AapStateActive );

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AapRelease: releasing context @ %08lX\n",
                    AapHandle ));
    }

    //
    //  Lock the lists.
    //

    AapLockLists();

    //
    //  let it decide how to handle this.
    //

    AapHandle->State = AapStateAbort;

    DBG_ASSERT( AapHandle->EventHandle != NULL );
    TCP_REQUIRE( SetEvent( AapHandle->EventHandle ) );

    //
    //  Unlock the lists.
    //

    AapUnlockLists();

}   // AapRelease

/*******************************************************************

    NAME:       AapAccept

    SYNOPSIS:   Initiates an accept().  The callback associated with
                the AAP handle will be invoked when the accept()
                completes.

    ENTRY:      AapHandle - A valid AAP handle returned by AapAcquire().

    EXIT:       APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
APIERR
AapAccept(
    AAP_HANDLE AapHandle
    )
{
    //
    //  Sanity check.
    //

    DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapHandle ) );
    DBG_ASSERT( AapHandle->State == AapStateActive );

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AapAccept: context @ %08lX\n",
                    AapHandle ));
    }

    //
    //  Release the worker thread.
    //

    TCP_REQUIRE( SetEvent( AapHandle->EventHandle ) );

    return 0;

}   // AapAccept

/*******************************************************************

    NAME:       AapAbort

    SYNOPSIS:   Aborts a pending accept().

    ENTRY:      AapHandle - A valid AAP handle returned by AapAcquire().

    EXIT:       APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
APIERR
AapAbort(
    AAP_HANDLE AapHandle
    )
{
    //
    //  Sanity check.
    //

    DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapHandle ) );
    DBG_ASSERT( AapHandle->State == AapStateActive );

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AapAbort: context @ %08lX\n",
                    AapHandle ));
    }

    //
    //  Just zap the listening handle.  The worker thread will clean
    //  up after itself.
    //

    TCP_REQUIRE( closesocket( AapHandle->ListeningSocket ) == 0 );

    return 0;

}   // AapAbort


//
//  Private functions.
//

/*******************************************************************

    NAME:       AappCreateContext

    SYNOPSIS:   Creates a new AAP context, including the associated
                thread, socket, and synchronization objects.

    RETURNS:    LPAAP_CONTEXT - The newly created context if successful,
                    NULL otherwise.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
LPAAP_CONTEXT
AappCreateContext(
    VOID
    )
{
    LPAAP_CONTEXT AapContext;
    SOCKADDR_IN   LocalAddress;
    DWORD         ThreadId;

    //
    //  Create the context structure.
    //

    AapContext = (LPAAP_CONTEXT)TCP_ALLOC( sizeof(AAP_CONTEXT) );

    if( AapContext == NULL )
    {
        DBGERROR(( DBG_CONTEXT,
                    "AappCreateContext: allocation failure\n" ));

        goto FatalExit0;
    }

    RtlZeroMemory( AapContext, sizeof(AAP_CONTEXT) );
    INIT_AAP_SIG( AapContext );

    //
    //  Create the listening socket.
    //

    AapContext->ListeningSocket = socket( AF_INET, SOCK_STREAM, 0 );

    if( AapContext->ListeningSocket == INVALID_SOCKET)
    {
        DBGERROR(( DBG_CONTEXT,
                    "AappCreateContext: socket() failure %d\n",
                    WSAGetLastError() ));

        goto FatalExit1;
    }

    LocalAddress.sin_family      = AF_INET;
    LocalAddress.sin_port        = 0;
    LocalAddress.sin_addr.s_addr = 0;

    if( bind( AapContext->ListeningSocket,
              (LPSOCKADDR)&LocalAddress,
              sizeof(LocalAddress) ) != 0 )
    {
        DBGERROR(( DBG_CONTEXT,
                    "AappCreateContext: bind() failure %d\n",
                    WSAGetLastError() ));

        goto FatalExit2;
    }

    if( listen( AapContext->ListeningSocket, 2 ) != 0 )
    {
        DBGERROR(( DBG_CONTEXT,
                    "AappCreateContext: listen() failure %d\n",
                    WSAGetLastError() ));

        goto FatalExit2;
    }

    //
    //  Create the event object.
    //

    AapContext->EventHandle = CreateEvent( NULL,        // lpEventAttributes
                                           FALSE,       // bManualReset
                                           FALSE,       // bInitialState
                                           NULL );      // lpName

    if( AapContext->EventHandle == NULL )
    {
        DBGWARN(( DBG_CONTEXT,
                    "AappCreateContext: CreateEvent() failure %d\n",
                    GetLastError() ));

        goto FatalExit2;
    }

    //
    //  Create the worker thread.
    //

    AapContext->ThreadHandle = CreateThread( NULL,              // lpsa
                                             0,                 // cbStack
                                             AappWorkerThread,  // lpStartAddr
                                             AapContext,        // lpvThreadParm
                                             0,                 // fdwCreate
                                             &ThreadId );       // lpIDThread

    if( AapContext->ThreadHandle == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AappCreateContext: CreateThread() failure %d\n",
                    GetLastError() ));

        goto FatalExit3;
    }

    //
    //  Success!
    //

    return AapContext;

    //
    //  Cleanup from various levels of fatal error.
    //

FatalExit3:

    CloseHandle( AapContext->EventHandle );

FatalExit2:

    closesocket( AapContext->ListeningSocket );

FatalExit1:

    TCP_FREE( AapContext );

FatalExit0:

    return NULL;

}   // AappCreateContext

/*******************************************************************

    NAME:       AappFreeResources

    SYNOPSIS:   Frees the system resources associated with a given
                AAP_CONTEXT structure, then frees the structure
                itself.

                NOTE: This routine MUST be called with the list lock
                held!

    ENTRY:      AapContext - The AAP_CONTEXT structure to free.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
VOID
AappFreeResources(
    LPAAP_CONTEXT AapContext
    )
{
    //
    //  Sanity check.
    //

    DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );

    IF_DEBUG( AAP )
    {
        DBGWARN(( DBG_CONTEXT,
                    "AappFreeResource: context @ %08lX\n",
                    AapContext ));
    }

    //
    //  Close the thread handle if open.
    //

    if( AapContext->ThreadHandle != NULL )
    {
        CloseHandle( AapContext->ThreadHandle );
    }

    //
    //  Remove this structure from the list.
    //

    RemoveEntryList( &AapContext->ContextList );

    //
    //  Free the structure.
    //

    KILL_AAP_SIG( AapContext );
    TCP_FREE( AapContext );

}   // AappFreeResources

/*******************************************************************

    NAME:       AappWorkerThread

    SYNOPSIS:   Worker thread for accept()ing incoming connections.

    ENTRY:      Param - Actually the LPAAP_CONTEXT structure for this
                    thread.

    RETURNS:    DWORD - Thread exit code (ignored).

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
DWORD
AappWorkerThread(
    LPVOID Param
    )
{
    LPAAP_CONTEXT  AapContext;
    AAP_STATE      AapState;
    LPAAP_CALLBACK AapCallback;
    LPVOID         UserContext;
    DWORD          WaitResult;
    BOOL           CallbackResult;
    SOCKET         ListeningSocket;
    SOCKET         AcceptedSocket;
    SOCKERR        SocketStatus;
    INT            RemoteAddressLength;
    SOCKADDR_IN    RemoteAddress;

    //
    //  Grab the context structure.
    //

    AapContext = (LPAAP_CONTEXT)Param;
    DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AappWorkerThread: starting, context @ %08lX\n",
                    AapContext ));
    }

    //
    //  Capture some fields from the structure.
    //

    AapCallback     = AapContext->AapCallback;
    UserContext     = AapContext->UserContext;
    ListeningSocket = AapContext->ListeningSocket;

    //
    //  Loop forever, or at least until we're told to shutdown.
    //

    for( ; ; )
    {
        //
        //  Wait for a request.
        //

        WaitResult = WaitForSingleObject( AapContext->EventHandle,
                                          INFINITE );

        if( WaitResult != WAIT_OBJECT_0 )
        {
            DBGWARN(( DBG_CONTEXT,
                        "AappWorkerThread: wait failure %lu : %d\n",
                        WaitResult,
                        GetLastError() ));

            break;
        }

        //
        //  Check our state.
        //

        AapLockLists();
        AapState = AapContext->State;
        AapUnlockLists();

        if( AapState == AapStateShutdown )
        {
            IF_DEBUG( AAP )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "AappWorkerThread: context @ %08lX state == %d, exiting\n",
                            AapContext,
                            AapState ));
            }

            break;
        }

        for( ; ; )
        {
            //
            //  Wait for an incoming connection.
            //

            RemoteAddressLength = sizeof(RemoteAddress);

            AcceptedSocket = accept( ListeningSocket,
                                     (LPSOCKADDR)&RemoteAddress,
                                     &RemoteAddressLength );

            SocketStatus = ( AcceptedSocket == INVALID_SOCKET )
                                ? WSAGetLastError()
                                : 0;

            IF_DEBUG( AAP )
            {
                if( SocketStatus != 0 )
                {
                    DBGERROR(( DBG_CONTEXT,
                                "AappWorkerThread: accept() failure %d\n",
                                SocketStatus ));
                }
            }

            //
            //  Invoke the callback.
            //

            IF_DEBUG( AAP )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "AappWorkerThread: context @ %08lX calling %08lX[%08lX]\n",
                            AapContext,
                            AapCallback,
                            UserContext ));
            }

            CallbackResult = AapCallback( UserContext,
                                          SocketStatus,
                                          AcceptedSocket,
                                          (LPSOCKADDR)&RemoteAddress,
                                          RemoteAddressLength );

            //
            //  If the callback returned FALSE (indicating that it wants no
            //  further callbacks) OR if the accept() failed for any reason,
            //  then exit the accept() loop.
            //

            if( !CallbackResult || ( SocketStatus != 0 ) )
            {
                break;
            }
        }

        //
        //  If we hit a socket error, then bail.
        //

        if( SocketStatus != 0 )
        {
            IF_DEBUG( AAP )
            {
                DBGWARN(( DBG_CONTEXT,
                            "AappWorkerThread: context @ %08lX, exiting\n",
                            AapContext ));
            }

            break;
        }

        //
        //  If we haven't exhausted the idle thread quota, then add
        //  ourselves to the idle list.  Otherwise, exit the main
        //  processing loop & terminate this thread.
        //

        AapLockLists();

        if( ( AapContext->State == AapStateShutdown ) ||
            ( p_AapIdleCount >= MAX_IDLE_THREADS ) )
        {
            AapUnlockLists();
            break;
        }

        RemoveEntryList( &AapContext->ContextList );

        AapContext->State = AapStateIdle;
        InsertHeadList( &p_AapIdleList, &AapContext->ContextList );
        p_AapIdleCount++;


        IF_DEBUG( AAP )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AappWorkerThread: context @ %08lX put on idle list\n",
                        AapContext ));
        }

        AapUnlockLists();
    }

    //
    //  We only make it this far if it's time to die.
    //

    AapLockLists();

    if( AapContext->State != AapStateShutdown )
    {
        TCP_REQUIRE( CloseHandle( AapContext->EventHandle ) );
        TCP_REQUIRE( CloseHandle( AapContext->ThreadHandle ) );
        TCP_REQUIRE( closesocket( AapContext->ListeningSocket ) == 0 );

        AappFreeResources( AapContext );
    }

    AapUnlockLists();

    return 0;

}   // AappWorkerThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\connect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    connect.cxx

    This module contains the main function for handling new connections.
    After receiving a new connection this module creates a new USER_DATA
    object to contain the information about a connection for processing.


    Functions exported by this module:

        FtpdNewConnction
        FtpdNewConnectionEx


    FILE HISTORY:
        KeithMo     08-Mar-1993 Created.
        MuraliK     03-April-1995
           Rewrote to separate the notion of one thread/control connection +
           other mods.
        MuraliK    11-Oct-1995
           Completely rewrote to support AcceptEx connections

*/


#include "ftpdp.hxx"


static CHAR PSZ_SERVICE_NOT_AVAILABLE[] =
  "Service not available, closing control connection.";


//
//  Private prototypes.
//



VOID
FtpReqResolveCallback(
    ADDRCHECKARG pArg,
    BOOL fSt,
    LPSTR pName
    )
{
    // ignore fSt : DNS name is simply unavailable

    //((LPUSER_DATA)pArg)->Reference();

    if ( !AtqPostCompletionStatus( ((LPUSER_DATA)pArg)->QueryControlAio()->QueryAtqContext(),
                                   0 ))
    {
        DereferenceUserDataAndKill( ((LPUSER_DATA)pArg) );
    }
}



BOOL
ProcessNewClient(
    IN SOCKET       sNew,
    IN PVOID        EndpointObject,
    IN FTP_SERVER_INSTANCE *pInstance,
    IN BOOL         fMaxConnExceeded,
    IN PSOCKADDR_IN psockAddrRemote,
    IN PSOCKADDR_IN psockAddrLocal = NULL,
    IN PATQ_CONTEXT patqContext    = NULL,
    IN PVOID        pvBuff         = NULL,
    IN DWORD        cbWritten      = 0,
    OUT LPBOOL      pfAtqToBeFreed = NULL
    )
{
    LPUSER_DATA     pUserData = NULL;

    DWORD           err     = NO_ERROR;
    BOOL            fReturn  = FALSE;
    DBG_CODE( CHAR  pchAddr[32];);
    BOOL            fSockToBeFreed = TRUE;
    BOOL            fDereferenceInstance = FALSE;
    AC_RESULT       acIpAccess;
    BOOL            fNeedDnsCheck = FALSE;
    BOOL            fValid;
    BOOL            fUnbindOnFail;

    DBG_CODE( InetNtoa( psockAddrRemote->sin_addr, pchAddr));

    if ( pfAtqToBeFreed != NULL) {
        *pfAtqToBeFreed = TRUE;
    }

    //
    // Create a new connection object
    //

    if ( !fMaxConnExceeded ) {
        pUserData = pInstance->AllocNewConnection();
    }

    if ( pUserData != NULL) {

        pUserData->QueryAccessCheck()->BindAddr( (PSOCKADDR)psockAddrRemote );
        if ( !pUserData->BindInstanceAccessCheck() ) {
            fValid = FALSE;
            fUnbindOnFail = FALSE;
        }
        else {
            fUnbindOnFail = TRUE;
            acIpAccess = pUserData->QueryAccessCheck()->CheckIpAccess( &fNeedDnsCheck );

            if ( (acIpAccess == AC_IN_DENY_LIST) ||
                 ((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) ) {

                SockPrintf2(
                    NULL,
                    sNew,
                    "%u Connection refused, unknown IP address.",
                    REPLY_NOT_LOGGED_IN
                    );

                fValid = FALSE;
            }
            else {
                fValid = TRUE;
            }
        }

        //
        // Start off processing this client connection.
        //
        //  Once we make a reset call, the USER_DATA object is created
        //    with the socket and atq context.
        //  From now on USER_DATA will take care of freeing
        // ATQ context & socket
        //

        fSockToBeFreed = FALSE;

        if ( fValid && pUserData->Reset(sNew,
                              EndpointObject,
                              psockAddrRemote->sin_addr,
                              psockAddrLocal,
                              patqContext,
                              pvBuff,
                              cbWritten,
                              acIpAccess )
            ) {

#ifndef _NO_TRACING_
            IF_CHKDEBUG( CLIENT) {

                CHKINFO( ( DBG_CONTEXT,
                            " Established a new connection to %s"
                            " ( Socket = %d)\n",
                            pchAddr,
                            sNew));
#else
            IF_DEBUG( CLIENT) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Established a new connection to %s"
                            " ( Socket = %d)\n",
                            pchAddr,
                            sNew));
#endif
            }

            //
            // At this point we have the context for the AcceptExed socket.
            //  Set the context in the AtqContext if need be.
            //

            if ( patqContext != NULL) {

                //
                // Associate client connection object with this control socket
                //  handle for future completions.
                //

                AtqContextSetInfo(patqContext,
                                  ATQ_INFO_COMPLETION_CONTEXT,
                                  (ULONG_PTR) pUserData->QueryControlAio());
            }

            if ( fNeedDnsCheck )
            {
                if ( !pUserData->QueryAccessCheck()->IsDnsResolved() ) {

                    BOOL fSync;
                    LPSTR pDns;

                    pUserData->SetNeedDnsCheck( TRUE );

                    if ( pUserData->QueryAccessCheck()->QueryDnsName( &fSync,
                            (ADDRCHECKFUNCEX)FtpReqResolveCallback,
                            (ADDRCHECKARG)pUserData,
                            &pDns )
                         && !fSync ) {

                        return TRUE;
                    }
                }
            }
            else {
                pUserData->UnbindInstanceAccessCheck();
            }

            DBG_REQUIRE( pUserData->Reference() > 0);

            fReturn = pUserData->ProcessAsyncIoCompletion(0, NO_ERROR,
                                                          pUserData->
                                                          QueryControlAio()
                                                          );

            if ( !fReturn) {

                err = GetLastError();

#ifndef _NO_TRACING_
                IF_CHKDEBUG( ERROR) {

                    CHKINFO(( DBG_CONTEXT,
                               " Unable to start off a read to client(%s,%d)."
                               " Error = %lu\n",
                               pchAddr,
                               sNew,
                               err ));
#else
                IF_DEBUG( ERROR) {

                    DBGPRINTF(( DBG_CONTEXT,
                               " Unable to start off a read to client(%s,%d)."
                               " Error = %lu\n",
                               pchAddr,
                               sNew,
                               err ));
#endif
                }
            }

            //
            // Decrement the ref count and free the connection.
            //

            DBG_ASSERT( (err == NO_ERROR) || pUserData->QueryReference() == 1);

            DereferenceUserDataAndKill( pUserData);

        } else {

            if ( fUnbindOnFail )
            {
                pUserData->UnbindInstanceAccessCheck();
            }

            // reset operation failed. relase memory and exit.
            err = GetLastError();

            pUserData->Cleanup();
            pInstance->RemoveConnection( pUserData);
            pUserData = NULL;
        }

    } else {

        err = GetLastError();
        fDereferenceInstance = TRUE;
    }

    if ( (pUserData == NULL) || (err != NO_ERROR) ) {

        //
        // Failed to allocate new connection
        // Reasons:
        //   1) Max connecitons might have been exceeded.
        //   2) Not enough memory is available.
        //   3) Access check failed
        //
        //  handle the failures and notify client.
        //

        if ( fMaxConnExceeded) {

            CHAR rgchBuffer[MAX_REPLY_LENGTH];
            DWORD len;

            //
            // Unable to insert new connection.
            //  The maxConnections may have exceeded.
            // Destroy the client connection object and return.
            // Possibly need to send an error message.
            //

#ifndef _NO_TRACING_
            IF_CHKDEBUG( ERROR) {

                CHKINFO( ( DBG_CONTEXT,
                            " MaxConnections Exceeded. "
                            " Connection from %s refused at socket %d\n",
                            pchAddr, sNew));
#else
            IF_DEBUG( ERROR) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " MaxConnections Exceeded. "
                            " Connection from %s refused at socket %d\n",
                            pchAddr, sNew));
#endif
            }

            // Format a message to send for the error case.

            pInstance->LockConfig();

            LPCSTR  pszMsg = pInstance->QueryMaxClientsMsg();
            pszMsg = (pszMsg == NULL) ? PSZ_SERVICE_NOT_AVAILABLE : pszMsg;

            len = FtpFormatResponseMessage(REPLY_SERVICE_NOT_AVAILABLE,
                                           pszMsg,
                                           rgchBuffer,
                                           MAX_REPLY_LENGTH);

            pInstance->UnLockConfig();
            DBG_ASSERT( len < MAX_REPLY_LENGTH);

            // Send the formatted message
            // Ignore error in sending this message.
            SockSend( NULL, sNew, rgchBuffer, len);

        } else {

            // not enough memory for running this client connection

            const CHAR * apszSubStrings[1];
            CHAR pchAddr2[32];

            InetNtoa( psockAddrRemote->sin_addr, pchAddr2 );

            apszSubStrings[0] = pchAddr2;

            g_pInetSvc->LogEvent(FTPD_EVENT_CANNOT_CREATE_CLIENT_THREAD,
                                  1,
                                  apszSubStrings,
                                  err );

#ifndef _NO_TRACING_
            IF_CHKDEBUG( ERROR) {

                CHKINFO(( DBG_CONTEXT,
                           "Cannot create Client Connection for %s,"
                           " Error %lu\n",
                           pchAddr,
                           err ));
#else
            IF_DEBUG( ERROR) {

                DBGPRINTF(( DBG_CONTEXT,
                           "Cannot create Client Connection for %s,"
                           " Error %lu\n",
                           pchAddr,
                           err ));
#endif
            }

            //
            // Send a message to client if the socket is to be freed.
            // If it is already freed, then we cannot send message
            //

            if ( fSockToBeFreed) {

                SockPrintf2(NULL, sNew,
                            "%u Service not available,"
                            " closing control connection.",
                            REPLY_SERVICE_NOT_AVAILABLE );
            } else {

                IF_DEBUG( CLIENT) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                " Unable to send closed error message to "
                                " %s (%d)\n",
                                pchAddr2, sNew
                                ));
                }
            }
        }


        //
        // Unable to create a new connection object.
        //  Report error and shut this.
        //

#ifndef _NO_TRACING_
        IF_CHKDEBUG( ERROR) {

            CHKINFO( ( DBG_CONTEXT,
                        "Cannot create new FTP Request object to %s."
                        " Error= %u\n",
                        pchAddr,
                        err));
#else
        IF_DEBUG( ERROR) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Cannot create new FTP Request object to %s."
                        " Error= %u\n",
                        pchAddr,
                        err));
#endif
        }

        if ( fSockToBeFreed ) {

            if ( patqContext != NULL) {

                // ensure that socket is shut down.
                DBG_REQUIRE( AtqCloseSocket( patqContext, TRUE));
            } else {

                CloseSocket( sNew);
            }
        }

        fReturn = (FALSE);

    }  // if ( pcc == NULL)


    if ( pfAtqToBeFreed != NULL) {

        *pfAtqToBeFreed = fSockToBeFreed;
    }

    if ( fDereferenceInstance ) {

        pInstance->DecrementCurrentConnections();
        pInstance->Dereference();
    }

    return (fReturn);

} // ProcessNewClient()



//
//  Public functions.
//



VOID
FtpdNewConnection(
    IN SOCKET sNew,
    IN SOCKADDR_IN * psockaddr,
    IN PVOID EndpointContext,
    IN PVOID EndpointObject
    )
/*++

  Call back function for processing the connections from clients.
  This function creates a new UserData object if permitted for the new
   client request and starts off a receive for the given connection
   using Async read on control channel established.

  Arguments:
     sNew       control socket for the new client connection
     psockAddr  pointer to the client's address.

  Returns:
     None

  History:
        KeithMo     08-Mar-1993 Created.
        MuraliK     04-April-1995
                         ReCreated for using async Io threading model.
--*/
{
    SOCKERR         serr;
    BOOL            fProcessed;
    BOOL            fMaxConnExceeded;
    INT             cbAddr = sizeof(SOCKADDR);
    SOCKADDR_IN     sockaddr;

    FTP_SERVER_INSTANCE *pInstance;

    DBG_ASSERT( sNew != INVALID_SOCKET );
    DBG_ASSERT( psockaddr != NULL );
    DBG_ASSERT( psockaddr->sin_family == AF_INET );     // temporary

    g_pFTPStats->IncrConnectionAttempts();

    if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {

#ifndef _NO_TRACING_
        IF_CHKDEBUG( ERROR) {
#else
        IF_DEBUG( ERROR) {
#endif

            DBG_CODE( CHAR pchAddr[32];);

            DBG_CODE( InetNtoa(((SOCKADDR_IN *) psockaddr)->sin_addr,
                               pchAddr));

#ifndef _NO_TRACING_
            CHKINFO( ( DBG_CONTEXT,
                        "Service is not running or AccessCheck failed for"
                        " Connection from %s\n",
                        pchAddr));
#else
            DBGPRINTF( ( DBG_CONTEXT,
                        "Service is not running or AccessCheck failed for"
                        " Connection from %s\n",
                        pchAddr));
#endif
        }

        SockPrintf2(NULL,
                    sNew,
                    "%u %s",  // the blank after %u is essential
                    REPLY_SERVICE_NOT_AVAILABLE,
                    "Service not available, closing control connection." );

        goto error_exit;

    }

    if (getsockname( sNew, (PSOCKADDR)&sockaddr, &cbAddr ) != 0) {
        goto error_exit;
    }

    //
    // Find Instance
    //

    pInstance = (FTP_SERVER_INSTANCE *)
        ((PIIS_ENDPOINT)EndpointContext)->FindAndReferenceInstance(
                                (LPCSTR)NULL,
                                sockaddr.sin_addr.s_addr,
                                &fMaxConnExceeded
                                );

    if ( pInstance == NULL ) {

        //
        //  Site is not permitted to access this server.
        //  Dont establish this connection. We should send a message.
        //

        SockPrintf2(NULL, sNew,
                    "%u Connection refused, unknown IP address.",
                    REPLY_NOT_LOGGED_IN);

        goto error_exit;
    }

    fProcessed = ProcessNewClient( sNew,
                                   EndpointObject,
                                   pInstance,
                                   fMaxConnExceeded,
                                   psockaddr);

    if ( fProcessed) {
        pInstance->QueryStatsObj()->CheckAndSetMaxConnections();
    }

    return;

error_exit:

    CloseSocket( sNew);
    return;

} // FtpdNewConnection()



VOID
FtpdNewConnectionEx(
   IN VOID *       patqContext,
   IN DWORD        cbWritten,
   IN DWORD        dwError,
   IN OVERLAPPED * lpo
   )
/*++
    Description:

        Callback function for new connections when using AcceptEx.
        This function verifies if this is a valid connection
         ( maybe using IP level authentication)
         and creates a new connection object

        The connection object is added to list of active connections.
        If the max number of connections permitted is exceeded,
          the client connection object is destroyed and
          connection is rejected.

    Arguments:

       patqContext:   pointer to ATQ context for the IO operation
       cbWritten:     count of bytes available from first read operation
       dwError:       error if any from initial operation
       lpo:           indicates if this function was called as a result
                       of IO completion or due to some error.

    Returns:

        None.

--*/
{
    DWORD           err = NO_ERROR;
    BOOL            fProcessed = FALSE;
    BOOL            fAtqContextToBeFreed = TRUE;
    BOOL            fMaxConnExceeded;
    PSOCKADDR_IN    psockAddrLocal  = NULL;
    PSOCKADDR_IN    psockAddrRemote = NULL;
    SOCKET          sNew   = INVALID_SOCKET;
    PVOID           pvBuff = NULL;
    PIIS_ENDPOINT   pEndpoint;
    FTP_SERVER_INSTANCE *pInstance;

    if ( (dwError != NO_ERROR) || !lpo) {

        DBGPRINTF(( DBG_CONTEXT, "FtpdNewConnectionEx() completion failed."
                   " Error = %d. AtqContext=%08x\n",
                   dwError, patqContext));

        //
        // For now free up the resources.
        //

        goto exit;
    }

    g_pFTPStats->IncrConnectionAttempts();

    DBG_ASSERT( patqContext != NULL);

    AtqGetAcceptExAddrs( (PATQ_CONTEXT ) patqContext,
                         &sNew,
                         &pvBuff,
                         (PVOID*)&pEndpoint,
                         (PSOCKADDR *)&psockAddrLocal,
                         (PSOCKADDR *)&psockAddrRemote);

    DBG_ASSERT( pEndpoint != NULL );
    IF_DEBUG( CONNECTION ) {

        DBGPRINTF(( DBG_CONTEXT,
                   " New connection. AtqCont=%08x, buff=%08x, cb=%d\n",
                   patqContext, pvBuff, cbWritten));
    }

    if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {

        DBGPRINTF((DBG_CONTEXT,"Connection attempt on inactive service\n"));

        SockPrintf2(NULL,
                    sNew,
                    "%u %s",  // the blank after %u is essential
                    REPLY_SERVICE_NOT_AVAILABLE,
                    "Service not available, closing control connection." );

        goto exit;
    }

    //
    // Find Instance
    //

    pInstance = (FTP_SERVER_INSTANCE*)pEndpoint->FindAndReferenceInstance(
                                (LPCSTR)NULL,
                                psockAddrLocal->sin_addr.s_addr,
                                &fMaxConnExceeded
                                );

    if (pInstance == NULL ) {

        //
        //  Site is not permitted to access this server.
        //  Dont establish this connection. We should send a message.
        //

        DBGPRINTF((DBG_CONTEXT,
            "Unable to find instance [err %d]\n",GetLastError()));
        goto exit;
    }

    //
    //  Set the timeout for future IOs on this context
    //

    AtqContextSetInfo( (PATQ_CONTEXT) patqContext,
                       ATQ_INFO_TIMEOUT,
                       (ULONG_PTR) pInstance->QueryConnectionTimeout()
                       );

    if ( pInstance->QueryBandwidthInfo() )
    {
        AtqContextSetInfo( (PATQ_CONTEXT) patqContext,
                           ATQ_INFO_BANDWIDTH_INFO,
                           (ULONG_PTR) pInstance->QueryBandwidthInfo() );
    }

    fProcessed = ProcessNewClient( sNew,
                                   NULL,
                                   pInstance,
                                   fMaxConnExceeded,
                                   psockAddrRemote,
                                   psockAddrLocal,
                                   (PATQ_CONTEXT ) patqContext,
                                   pvBuff,
                                   cbWritten,
                                   &fAtqContextToBeFreed);

    if ( fProcessed) {
        pInstance->QueryStatsObj()->CheckAndSetMaxConnections();
    }

exit:

    if ( !fProcessed && fAtqContextToBeFreed ) {

        //
        // We failed to process this connection. Free up resources properly
        //

        DBG_REQUIRE( AtqCloseSocket( (PATQ_CONTEXT )patqContext, FALSE));
        AtqFreeContext( (PATQ_CONTEXT ) patqContext, TRUE );
    }

    return;

} // FtpdNewConnectionEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\dbgutil.h ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

        Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Revision History:

       MuraliK   21-March-1995    Made local copy from template for FTP server
                                     This replaces old "debug.hxx" of FTPsvc.
       MuraliK   1-Npv-1996       Updated dbgutil.h 
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_

/************************************************************
 *     Include Headers
 ************************************************************/

// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

# include <pudebug.h>

//
//  Define the debugging constants
//

# define DEBUG_VIRTUAL_IO                 0x00001000
# define DEBUG_CLIENT                     0x00002000
# define DEBUG_ASYNC_IO                   0x00004000
# define DEBUG_DIR_LIST                   0x00008000

# define DEBUG_SOCKETS                    0x00010000
# define DEBUG_SEND                       0x00020000
# define DEBUG_RECV                       0x00040000
# define DEBUG_CONFIG                     0x00080000

# define DEBUG_INSTANCE                   0x00100000

# define DEBUG_SERVICE_CTRL               0x01000000
# define DEBUG_SECURITY                   0x02000000
# define DEBUG_USER_DATABASE              0x04000000
# define DEBUG_RPC                        0x08000000

# define DEBUG_CONNECTION                 0x10000000
# define DEBUG_PARSING                    0x20000000
# define DEBUG_COMMANDS                   0x40000000
# define DEBUG_CRITICAL_PATH              0x80000000

# define DEBUG_PASV                        0x00200000

# define IF_SPECIAL_DEBUG( arg)      IF_DEBUG( arg)


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\engine.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993-1995           **/
/**********************************************************************/

/*
    engine.cxx

    Command parser & execution for FTPD Service.  This module parses
    and executes the commands received from the control socket.

    Functions exported by this module:
      All function for processing FTP commands

    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     21-March-1995  Modified to use common TsLogonUser()
                                      supporting anonymous logon.
        MuraliK     27-Mar - April 1995
              Cleaning up FTP server engine for
                 - to support new Internet services interface.
                 - to support Async Io Transfers
                 - split and move the command tables to ftpcmd.cxx
                 - to replace USER_DATA::DataSocket with
                       USER_DATA::m_AioDataConnection
                 - moved SiteSTATS and statistics to ftpcmd.cxx
                 - replaced SockReply2 with ReplyToUser()
                 - modified MainREIN and MainQUIT to use
                       new USER_DATA functions.
                 - modified usage of listing functions.
                 - SendErrorToClient() used for managing and sending
                       error message to client.
                 - message strings removed to be top of the file and defined.
                 - size of file sent along before file is transferred.
        terryk      18-Sep-1996 add MainSize
*/

#include "ftpdp.hxx"
#include "ftpcmd.hxx"
#include <stdlib.h>
#include <limits.h>

//
//  Private constants.
//


//
// Since the default RFC port for ftp is 21, we calculate the Data port
//   value from it.
// However, an admin at a site may change the port number to something else
//  ==> this will create PROBLEMS..... NYI
//

/**************************************************
 *  Constant Message Strings used by this Module
 **************************************************/

//
// Below is a list of strings, which are in
//   CStrM( StringName,  ActualString)  format
// The following table contains globally all strings used within this module
//  Advantage:  One place to look for various strings
//               + possible internationalization
//  Be careful. None of these messages may be modified. Protocol may break.
//  This will be expanded into
//  const char  PSZ_StringName[] = ActualString;   and
//  enumerated value  LEN_StringName = sizeof( ActualString).
//
# define ConstantStringsForThisModule()            \
  CStrM( CANNOT_OPEN_DATA_CONNECTION, "Can't open data connection.")   \
  CStrM( TRANSFER_ABORTED,    "Connection closed; transfer aborted.")  \
  CStrM( USER_NOT_LOGGED_IN,          "User %s cannot log in.")        \
  CStrM( INSUFFICIENT_RESOURCES, "Insufficient system resources.")     \
  CStrM( REQUEST_ID_FOR_ANONYMOUS,                                     \
         "Anonymous access allowed, send identity (e-mail name) as password.")\
  CStrM( REQUEST_PASSWORD_FOR_USER,  "Password required for %s.")      \
  CStrM( COMMAND_NOT_IMPLEMENTED,    "%s command not implemented." )   \
  CStrM( COMMAND_SUCCESSFUL,         "%s command successful." )        \
  CStrM( SERVICE_READY,              "Service ready for new user.")    \
  CStrM( ENTERING_PASSIVE_MODE,      \
        "Entering Passive Mode (%d,%d,%d,%d,%d,%d).")                  \
  CStrM( FORM_MESSAGE,                "Form must be N or T." )         \
  CStrM( TYPE_NOT_IMPLEMENTED,        "Type %c not implemented.")      \
  CStrM( BYTE_SIZE_SPEC,              "Byte size must be 8." )         \
  CStrM( TYPE_SET_TO,                 "Type set to %c.")               \
  CStrM( UNIMPLEMENTED_STRU_TYPE,     "Unimplemented STRU type." )     \
  CStrM( INVALID_STRU_TYPE,           "Invalid STRU type." )     \
  CStrM( STRU_TYPE_OK,                "STRU %c ok.")                   \
  CStrM( UNIMPLEMENTED_MODE,          "Unimplemented MODE type.")      \
  CStrM( MODE_OK,                     "Mode %c ok.")                   \
  CStrM( REPLY_MARKER_SPEC,           "Reply marker is invalid.")       \
  CStrM( REPLY_RESTARTING,            "Restarting at %s." )             \
  CStrM( READY_FOR_DEST_FILE, "File exists, ready for destination name" )   \
  CStrM( BAD_COMMAND_SEQUENCE,        "Bad sequence of commands." )    \
  CStrM( CURRENT_DIRECTORY,           "\"%s\" is current directory.")  \
  CStrM( VERSION_INFO,                "Windows_NT")                    \
  CStrM( SERVER_STATUS_BEGIN,         " %s Windows NT FTP Server status:")  \
  CStrM( SERVER_STATUS_END,           "End of status.")                \
  CStrM( FILE_STATUS,                 "status of %s:")                 \
  CStrM( MSDOS_DIRSTYLE,              "MSDOS-like directory output is %s") \
  CStrM( DIRECTORY_ANNOTATION,        "directory annotation is %s")    \
  CStrM( LOGGED_IN_USER_MESSAGE,      "Anonymous user logged in%s.") \
  CStrM( USER_LOGGED_IN,              "User %s logged in%s.")          \
  CStrM( USER_CANNOT_LOG_IN,          "User %s cannot log in.")        \
  CStrM( INACCESSIBLE_HOME_DIR,                                        \
        "User %s cannot log in, home directory inaccessible.")         \
  CStrM( LICENSE_QUOTA_EXCEEDED,                                       \
        "User %s cannot log in, license quota exceeded.")              \
  CStrM( NO_GUEST_ACCESS,                                              \
        "User %s cannot log in, guest access not allowed.")            \
  CStrM( ANONYMOUS_NAME,              "Anonymous")                     \
  CStrM( FTP_NAME,                    "Ftp")                           \
  CStrM( ARGS_DELIMITER,              " \t")                           \
  CStrM( NO_FILE_OR_DIRECTORY,        "No such file or directory.")    \
  CStrM( DIRECTORY_CREATE,            "\"%s\" directory created.")     \
  CStrM( CANNOT_CREATE_FILE,          "Cannot create file.")           \
  CStrM( CANNOT_CREATE_UNIQUE_FILE,   "Cannot create unique file.")    \
  CStrM( INVALID_COMMAND,             "Invalid %s Command.")           \
  CStrM( RESPONSE_ON,                 "on")                            \
  CStrM( RESPONSE_OFF,                "off")                           \
  CStrM( GUEST_ACCESS,                " (guest access)" )              \
  CStrM( CREATE_VERB,                 "created" )                      \
  CStrM( APPEND_VERB,                 "appended" )                     \
  CStrM( USER_VERB,                   "USER" )                         \
  CStrM( PASSWORD_VERB,               "PASS" )                         \
  CStrM( QUIT_VERB,                   "QUIT" )                         \
  CStrM( ABORT_VERB,                  "ABORT" )                        \
  CStrM( REIN_VERB,                   "REIN" )                         \
  CStrM( DESTINATION_FILE_EXISTS,     "Destination file already exists.") \
  CStrM( RNFR_VERB,                   "RNFR" )                         \
  CStrM( RNTO_VERB,                   "RNTO" )                         \
  CStrM( DELE_VERB,                   "DELE" )                         \
  CStrM( RMD_VERB,                    "RMD" )                          \
  CStrM( MKD_VERB,                    "MKD" )                          \
  CStrM( DUMMY_END,  "DummyMsg. Add string before this one")


//
// Generate the strings ( these are private globals of this module).
//

# define CStrM( StringName, ActualString)   \
     const char PSZ_ ## StringName[] = ActualString ;

ConstantStringsForThisModule()

# undef CStrM



//
//  Private prototypes.
//

BOOL
ParseStringIntoAddress(
    LPSTR     pszString,
    LPIN_ADDR pinetAddr,
    LPPORT    pport
    );

DWORD
ReceiveFileFromUserAndClose(
    LPUSER_DATA pUserData,
    LPSTR       pszFileName,
    LPHANDLE    phFile
    );

BOOL
MyLogonUser(
    LPUSER_DATA pUserData,
    LPSTR       pszPassword,
    LPBOOL      pfAsGuest,
    LPBOOL      pfHomeDirFailure,
    LPBOOL      pfLicenseExceeded
    );

DWORD
DetermineUserAccess(FTP_SERVER_INSTANCE *pInstance);

//
//  Public functions.
//



//
//  Functions Implementing FTP functionality.
//


BOOL
MainUSER(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  Implements the USER command.
  Format:    USER <userName>

  Arguments:
    pUserData  - the user initiating the request.
    pszArg     - Command arguments. Will be NULL if no arguments given.

  Returns:
    BOOL - TRUE if arguments are OK; FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    LPFTP_SERVER_STATISTICS pStatsObj = pUserData->QueryInstance()->QueryStatsObj();

    DBG_ASSERT( pStatsObj != NULL );

    if( pUserData->IsLoggedOn()) {

        if( TEST_UF( pUserData, ANONYMOUS ) ) {
            pStatsObj->DecrCurrentAnonymousUsers();
        } else {
            pStatsObj->DecrCurrentNonAnonymousUsers();
        }

        SET_UF( pUserData, LOGGED_ON);
    }

    //
    //  Squirrel away a copy of the domain\user name for later.
    //  If the name is too long, then don't let them logon.
    //

    if ( strlen( pszArg ) >= ( MAX_USERNAME_LENGTH ) ) {

        ReplyToUser(pUserData,
                    REPLY_NOT_LOGGED_IN,
                    PSZ_USER_NOT_LOGGED_IN,
                    pszArg );

    } else {

        BOOL   fNameIsAnonymous;
        LPCSTR pszReply;

        fNameIsAnonymous = ( ( _stricmp( pszArg, PSZ_ANONYMOUS_NAME ) == 0 ) ||
                            ( _stricmp( pszArg, PSZ_FTP_NAME ) == 0 )
                            );

        pUserData->SetUserName( pszArg );

        if( fNameIsAnonymous ) {

            SET_UF( pUserData, ANONYMOUS );
        } else {

            CLEAR_UF( pUserData, ANONYMOUS );
        }

        //
        // remember that we're waiting for PASS command in case we
        // get disconnected.
        //
        SET_UF( pUserData, WAIT_PASS );

        //
        //  If we already have an impersonation token, then remove it.
        //  This will allow us to impersonate the new user.
        //

        pUserData->FreeUserToken();

        //
        //  Tell the client that we need a password.
        //

        pszReply =(((fNameIsAnonymous) && pUserData->QueryInstance()->AllowAnonymous())
                   ? PSZ_REQUEST_ID_FOR_ANONYMOUS
                   : PSZ_REQUEST_PASSWORD_FOR_USER);

        ReplyToUser( pUserData,
                    REPLY_NEED_PASSWORD,
                    pszReply,
                    pszArg);

        pUserData->LockUser();
        if( pUserData->QueryState() != UserStateDisconnected ) {
            pUserData->SetState( UserStateWaitingForPass);
        }
        pUserData->UnlockUser();
    }

    pUserData->WriteLogRecord( PSZ_USER_VERB, pszArg);

    return TRUE;

}   // MainUSER()



BOOL
MainPASS(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  Implements the PASS command.
  Format:  PASS <password>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DWORD dwError = NO_ERROR;

    DBG_ASSERT( pUserData != NULL );

    //
    //  PASS command only valid in WaitingForPass state.
    //

    DBG_ASSERT( pUserData->QueryState() == UserStateWaitingForPass );

    if( ( pszArg != NULL ) && ( strlen( pszArg ) > PWLEN ) ) {

        return FALSE;
    }

    //
    //  Try to logon the user.
    //
    BOOL   fAsGuest;
    BOOL   fHomeDirFailure;
    BOOL   fLicenseExceeded;

    DBG_ASSERT( pUserData->QueryUserToken() == NULL );

    //
    // we got the PASS command we we're waiting for
    //
    CLEAR_UF( pUserData, WAIT_PASS );

    pUserData->QueryInstance()->QueryStatsObj()->IncrLogonAttempts();

    if( MyLogonUser(pUserData,
                    pszArg,
                    &fAsGuest,
                    &fHomeDirFailure,
                    &fLicenseExceeded )
       ) {

        const CHAR * pszGuestAccess =
          ( ( fAsGuest) ? PSZ_GUEST_ACCESS : "");

        //
        //  Successful logon.
        //

        if( *pUserData->QueryUserName() != '-' )  {

            PCSTR pszMsg;

            pUserData->QueryInstance()->LockConfig();

            pszMsg = pUserData->QueryInstance()->QueryGreetingMsg();

            if( pszMsg && *pszMsg ) {

                pUserData->SendMultilineMessage(
                                             REPLY_USER_LOGGED_IN,
                                             pszMsg,
                                             TRUE,                    // first reply line
                                             FALSE);                  // lst reply line
            }

            pUserData->QueryInstance()->UnLockConfig();

            if( TEST_UF( pUserData, ANNOTATE_DIRS )) {

                pUserData->SendDirectoryAnnotation(
                                             REPLY_USER_LOGGED_IN,
                                             FALSE);                  // first reply line
            }
        }

        LPFTP_SERVER_STATISTICS pStats = pUserData->QueryInstance()->QueryStatsObj();
        DBG_ASSERT( pStats != NULL );

        if( TEST_UF( pUserData, ANONYMOUS ) ) {

            pStats->IncrAnonymousUsers();

            ReplyToUser(pUserData,
                        REPLY_USER_LOGGED_IN,
                        PSZ_LOGGED_IN_USER_MESSAGE,
                        pszGuestAccess );

        } else {

            pStats->IncrNonAnonymousUsers();

            ReplyToUser(pUserData,
                        REPLY_USER_LOGGED_IN,
                        PSZ_USER_LOGGED_IN,
                        pUserData->QueryUserName(),
                        pszGuestAccess );
        }

        pUserData->LockUser();
        if( pUserData->QueryState() != UserStateDisconnected ) {
            pUserData->SetState( UserStateLoggedOn);
            SET_UF( pUserData, LOGGED_ON);
        }
        pUserData->UnlockUser();

    } else {

        const CHAR * pszReply = PSZ_USER_CANNOT_LOG_IN;

        //
        //  Logon failure.
        //

        dwError = GetLastError();

        if( fHomeDirFailure ) {

            pszReply = PSZ_INACCESSIBLE_HOME_DIR;

        } else if ( fLicenseExceeded) {

            pszReply = PSZ_LICENSE_QUOTA_EXCEEDED;

        } else if ( fAsGuest && ! pUserData->QueryInstance()->AllowGuestAccess()) {

            pszReply = PSZ_NO_GUEST_ACCESS;
        }

        ReplyToUser(pUserData,
                    REPLY_NOT_LOGGED_IN,
                    pszReply,
                    pUserData->QueryUserName() );

        pUserData->LockUser();
        if( pUserData->QueryState() != UserStateDisconnected ) {
            pUserData->SetState( UserStateWaitingForUser);
            CLEAR_UF( pUserData, LOGGED_ON);
            pUserData->ClearUserName();
        }
        pUserData->UnlockUser();
    }

    pUserData->WriteLogRecord( PSZ_PASSWORD_VERB,
                              (TEST_UF( pUserData, ANONYMOUS)) ? pszArg : NULL,
                              dwError);

    return TRUE;

}   // MainPASS()



BOOL
MainACCT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the ACCT command.
  This is at present not implemented...

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_SUPERFLUOUS,
                PSZ_COMMAND_NOT_IMPLEMENTED,
                "ACCT");

    return TRUE;

}   // MainACCT()




BOOL
MainCWD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the CWD command -- Change Working Directory.
  Format:  CWD <newDirectoryName>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  If argument is NULL or "~", CD to home directory.
    //

    if( ( pszArg == NULL ) || ( strcmp( pszArg, "~" ) == 0 ) ) {

        err = pUserData->CdToUsersHomeDirectory( PSZ_ANONYMOUS_NAME);

    } else {

        err = VirtualChDir( pUserData, pszArg);
    }

    if( err == NO_ERROR ) {

        if( TEST_UF( pUserData, ANNOTATE_DIRS ) &&
           ( *pUserData->QueryUserName() != '-' )
           ) {

            pUserData->SendDirectoryAnnotation(
                                           REPLY_FILE_ACTION_COMPLETED,
                                           TRUE);                        // first reply line
        }

        ReplyToUser(pUserData,
                    REPLY_FILE_ACTION_COMPLETED,
                    PSZ_COMMAND_SUCCESSFUL,
                    "CWD");
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    return TRUE;

}   // MainCWD()



BOOL
MainCDUP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  CDUP -- changes to the parent directory if possible.
--*/
{
    return MainCWD( pUserData, ".." );
}   // MainCDUP


BOOL
MainSIZE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements SIZE command - used for retrieving the size of a file.
  Format:  SIZE pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err = (!NO_ERROR);

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to open the file.
    //

    if (pUserData->ImpersonateUser()){
	    err = pUserData->OpenFileForSend( pszArg );
		pUserData->RevertToSelf();
	}
	else
	{
		err = GetLastError();
    }

    if( err == NO_ERROR ) {

        // just return the file size
        err = pUserData->GetFileSize();
    }

    if( err != NO_ERROR ) {

        pUserData->SendErrorToClient(pszArg, err,
                                     PSZ_NO_FILE_OR_DIRECTORY);

        pUserData->WriteLogRecordForSendError( err );
    }

    pUserData->CloseFileForSend( err);  // close the file, now that we're done.
    return TRUE;

}   // MainSIZE()

BOOL
MainMDTM(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the MDTM command - used for retrieving the last
  modified time for a file. We open the file, get the file mod time, format
  it and send it.

  Format:  SIZE pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR      err = (!NO_ERROR);
    SYSTEMTIME  SystemTime;
    CHAR        rgchBuffer[sizeof("YYYYMMDDHHMMSS")];

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to open the file.
    //

    if (pUserData->ImpersonateUser()){
	    err = pUserData->OpenFileForSend( pszArg );
		pUserData->RevertToSelf();
	}
	else
	{
		err = GetLastError();
    }

    if( err == NO_ERROR ) {

        // Get the last write time.

        err = pUserData->GetFileModTime(&SystemTime);

        if (err == NO_ERROR) {
            // Format the time.
            wsprintfA(rgchBuffer, "%.4hu%.2hu%.2hu%.2hu%.2hu%.2hu",
                        SystemTime.wYear,
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );

            ReplyToUser( pUserData, REPLY_FILE_STATUS, rgchBuffer );
        }
    }

    if( err != NO_ERROR ) {

        pUserData->SendErrorToClient(pszArg, err,
                                     PSZ_NO_FILE_OR_DIRECTORY);

        pUserData->WriteLogRecordForSendError( err );
    }

    pUserData->CloseFileForSend( err);  // close the file, now that we're done.
    return TRUE;

}   // MainMDTM()


BOOL
MainSMNT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the SMNT command.
  This is at present not implemented...

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_SUPERFLUOUS,
                PSZ_COMMAND_NOT_IMPLEMENTED,
                "SMNT");

    return TRUE;

}   // MainSMNT()




BOOL
MainQUIT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the QUIT command.
  Format:  QUIT

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    CHAR    rgchBuffer[MAX_REPLY_LENGTH];
    DWORD   len;
    LPCSTR  pszMsg;
    SOCKERR serr;

    DBG_ASSERT( pUserData != NULL );

    SET_UF( pUserData, CONTROL_QUIT);

    //
    //  Reply to the quit command.
    //

    pUserData->QueryInstance()->LockConfig();

    pszMsg = pUserData->QueryInstance()->QueryExitMsg();
    DBG_ASSERT( pszMsg != NULL);

    len = FtpFormatResponseMessage(REPLY_CLOSING_CONTROL,
                                   pszMsg,
                                   rgchBuffer,
                                   MAX_REPLY_LENGTH);
    pUserData->QueryInstance()->UnLockConfig();

    DBG_ASSERT( len <= MAX_REPLY_LENGTH);

    serr = SockSend( pUserData, pUserData->QueryControlSocket(),
                    rgchBuffer, len);

    //
    //  Cause a disconnection of the user.
    //  This will blow away the sockets first. Blowing off sockets
    //    will cause ATQ to wake up for pending data calls
    //    and send a call back indicating failure.
    //  Since we disconnect now, we will not submit any
    //    Reads to control socket ==> no more control calls come back from ATQ.
    //  At the call back processing we will decrement reference counts
    //    appropriate for cleanup.
    //

    pUserData->DisconnectUserWithError( NO_ERROR, FALSE);

    pUserData->WriteLogRecord( PSZ_QUIT_VERB, "");

    return TRUE;

}   // MainQUIT()



BOOL
MainREIN(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function executes REIN command - ReInitialize
  Format:  REIN

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DBG_ASSERT( pUserData != NULL );

    pUserData->ReInitializeForNewUser();

    ReplyToUser(pUserData,
                REPLY_SERVICE_READY,
                PSZ_SERVICE_READY);

    pUserData->WriteLogRecord( PSZ_REIN_VERB, pszArg);

    return TRUE;

}   // MainREIN()



BOOL
MainPORT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the PORT command.
  Format:  PORT <ipAddress>,<portNumber>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    IN_ADDR DataIpAddress;
    PORT    DataPort;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Parse the string into address/port pair.
    //

    if( !ParseStringIntoAddress( pszArg,
                                 &DataIpAddress,
                                 &DataPort ) )
    {
        return FALSE;
    }

    //
    //  Determine if someone is trying to give us a bogus address/port.
    //  If the port number is less than IPPORT_RESERVED,
    //    then there is a possibility of port attack. Allow this only
    //    if port attack flag is enabled
    //

    if (!pUserData->QueryInstance()->IsEnablePortAttack())
    {
	    if ( ( DataIpAddress.s_addr != pUserData->HostIpAddress.s_addr ) ||
    	     ( DataPort != CONN_PORT_TO_DATA_PORT(pUserData->LocalIpPort) &&
        	   ntohs( DataPort ) < IPPORT_RESERVED) )
        	{

            ReplyToUser(pUserData,
                        REPLY_UNRECOGNIZED_COMMAND,
                        PSZ_INVALID_COMMAND,
                        "PORT");

            return TRUE;
        }
    }


    //
    //  Save the address/port pair into per-user data.
    //

    pUserData->DataIpAddress = DataIpAddress;
    pUserData->DataPort = DataPort;

    //
    //  Disable passive mode for this user.
    //

    CLEAR_UF( pUserData, PASSIVE );

    //
    // Nuke any open data socket.
    //
    pUserData->CleanupPassiveSocket( TRUE );

    //
    //  Let the client know we accepted the port command.
    //

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_COMMAND_SUCCESSFUL,
                "PORT");

    return TRUE;

}   // MainPORT()



BOOL
MainPASV(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the PASV command - used for setting passive mode.
  Format:  PASV

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    SOCKET        DataSocket = INVALID_SOCKET;
    SOCKERR       serr  = 0;
    SOCKADDR_IN   saddrLocal;
    INT           cbLocal;

    DBG_ASSERT( pUserData != NULL );

    //
    // Nuke the old passive socket
    //
    pUserData->CleanupPassiveSocket( TRUE );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Create a new data socket.
    //

    serr = CreateFtpdSocket( &DataSocket,
                             pUserData->LocalIpAddress.s_addr,
                             0,
                             pUserData->QueryInstance() );

    if( serr == 0 )
    {
        //
        //  Determine the port number for the new socket.
        //

        cbLocal = sizeof(saddrLocal);

        if( getsockname( DataSocket, (SOCKADDR *)&saddrLocal, &cbLocal ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Success!
        //

        SET_UF( pUserData, PASSIVE );
        pUserData->SetPassiveSocket( DataSocket);
        pUserData->DataIpAddress = saddrLocal.sin_addr;
        pUserData->DataPort = saddrLocal.sin_port;

        ReplyToUser(pUserData,
                    REPLY_PASSIVE_MODE,
                    PSZ_ENTERING_PASSIVE_MODE,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b1,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b2,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b3,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b4,
                    HIBYTE( ntohs( saddrLocal.sin_port ) ),
                    LOBYTE( ntohs( saddrLocal.sin_port ) ) );

    } else {

        //
        //  Failure during data socket creation/setup.  If
        //  we managed to actually create it, nuke it.
        //

        if( DataSocket != INVALID_SOCKET )
        {
            CloseSocket( DataSocket );
            DataSocket = INVALID_SOCKET;
        }

        //
        //  Tell the user the bad news.
        //

        ReplyToUser(pUserData,
                    REPLY_CANNOT_OPEN_CONNECTION,
                    PSZ_CANNOT_OPEN_DATA_CONNECTION);
    }

    return TRUE;

}   // MainPASV()





BOOL
MainTYPE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the TYPE command - used for setting type.
  Format:  TYPE type form <addl arguments>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    XFER_TYPE   newType;
    CHAR        chType;
    CHAR        chForm;
    LPSTR       pszToken;
    BOOL        fValidForm = FALSE;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    pszToken = strtok( pszArg, PSZ_ARGS_DELIMITER);

    if( pszToken == NULL ) {

        return FALSE;
    }

    //
    //  Ensure we got a valid form type
    //  (only type N supported).
    //

    if( pszToken[1] != '\0' ) {

        return FALSE;
    }

    chType = *pszToken;


    pszToken = strtok( NULL, PSZ_ARGS_DELIMITER );

    if( pszToken == NULL ) {

        chForm     = 'N';       // default
        fValidForm = TRUE;

    } else {

        switch( *pszToken ) {

          case 'n':
          case 'N':
            chForm     = 'N';
            fValidForm = TRUE;
            break;

          case 't':
          case 'T':
            chForm     = 'T';
            fValidForm = TRUE;
            break;

          case 'c':
          case 'C':
            chForm     = 'C';
            fValidForm = TRUE;
            break;

          default:
            fValidForm = FALSE;
            break;
        } // switch

    }

    //
    //  Determine the new transfer type.
    //

    switch( chType ) {

      case 'a':
      case 'A':
        if( !fValidForm ) {

            return FALSE;
        }

        if( ( chForm != 'N' ) && ( chForm != 'T' ) ) {

            ReplyToUser(pUserData,
                        REPLY_PARAMETER_NOT_IMPLEMENTED,
                        PSZ_FORM_MESSAGE);
            return TRUE;
        }

        newType = XferTypeAscii;
        chType  = 'A';
        break;

      case 'e':
      case 'E':
        if( !fValidForm ) {

            return FALSE;
        }

        if( ( chForm != 'N' ) && ( chForm != 'T' ) ) {

            ReplyToUser(pUserData,
                        REPLY_PARAMETER_NOT_IMPLEMENTED,
                        PSZ_FORM_MESSAGE);
            return TRUE;
        }

        ReplyToUser(pUserData,
                    REPLY_PARAMETER_NOT_IMPLEMENTED,
                    PSZ_TYPE_NOT_IMPLEMENTED, 'E');
        return TRUE;

      case 'i':
      case 'I':
        if( pszToken != NULL ) {

            return FALSE;
        }

        newType = XferTypeBinary;
        chType  = 'I';
        break;

    case 'l':
    case 'L':
        if( pszToken == NULL ) {

            return FALSE;
        }

        if( strcmp( pszToken, "8" ) != 0 ) {

            if( IsDecimalNumber( pszToken ) ) {

                ReplyToUser(pUserData,
                            REPLY_PARAMETER_NOT_IMPLEMENTED,
                            PSZ_BYTE_SIZE_SPEC);

                return TRUE;
            } else {

                return FALSE;
            }
        }

        newType = XferTypeBinary;
        chType  = 'L';
        break;

      default:
        return FALSE;
    } // switch (chType)

    IF_DEBUG( COMMANDS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "setting transfer type to %s\n",
                    TransferType( newType ) ));
    }

    pUserData->SetXferType( newType);

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_TYPE_SET_TO,
                chType);

    return TRUE;

}   // MainTYPE()




BOOL
MainSTRU(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the STRU command - structure information
  Format:  STRU fileName

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    CHAR     chStruct;
    CHAR   * pszToken;

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg != NULL );

    pszToken = strtok( pszArg, PSZ_ARGS_DELIMITER );

    if( pszToken == NULL ) {

        return FALSE;
    }

    //
    //  Ensure we got a valid structure type
    //  (only type F supported).
    //

    chStruct = *pszToken;

    if( pszToken[1] != '\0' ) {

        return FALSE;
    }

    switch( chStruct ) {

      case 'f':
      case 'F':
        chStruct = 'F';
        break;

      case 'r':
      case 'R':
      case 'p':
      case 'P':
        ReplyToUser(pUserData,
                    REPLY_PARAMETER_NOT_IMPLEMENTED,
                    PSZ_UNIMPLEMENTED_STRU_TYPE);
        return TRUE;

      default:

        return FALSE;
    }

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_STRU_TYPE_OK,
                chStruct );

    return TRUE;

}   // MainSTRU()



BOOL
MainMODE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the MODE command - to set mode of tfr.
  Format:  MODE newMode

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    XFER_MODE   newMode;
    CHAR        chMode;
    LPSTR       pszToken;

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg != NULL );

    pszToken = strtok( pszArg, PSZ_ARGS_DELIMITER );

    if( pszToken == NULL ) {

        return FALSE;
    }

    //
    //  Ensure we got a valid mode type
    //  (only type S supported).
    //

    if( pszToken[1] != '\0' ) {

        return FALSE;
    }
    chMode = *pszToken;


    switch( chMode )
    {
    case 's' :
    case 'S' :
        newMode = XferModeStream;
        chMode  = 'S';
        break;

    case 'b' :
    case 'B' :
        ReplyToUser(pUserData,
                    REPLY_PARAMETER_NOT_IMPLEMENTED,
                    PSZ_UNIMPLEMENTED_MODE );
        return TRUE;

    default :
        return FALSE;
    }

    IF_DEBUG( COMMANDS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "setting transfer mode to %s\n",
                    TransferMode( newMode ) ));
    }

    pUserData->SetXferMode(newMode);

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_MODE_OK,
                chMode );

    return TRUE;

}   // MainMODE()



BOOL
MainRETR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RETR command - used for retrieving a file.
  Format:  RETR pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
#define MAX_FILE_SIZE_SPEC (32)

    APIERR err = (!NO_ERROR);
    BOOL   fErrorSent = FALSE;
    BOOL   fTriedToOpenFile = FALSE;
    LARGE_INTEGER FileSize;
    DWORD         dwAttribs;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    CHAR rgchSize[MAX_FILE_SIZE_SPEC];
    CHAR rgchBuffer[MAX_FILE_SIZE_SPEC + 10];

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    if (pUserData->ImpersonateUser()){
	    err = pUserData->OpenFileForSend( pszArg );
		pUserData->RevertToSelf();
	}
	else
	{
		err = GetLastError();
    }

    fTriedToOpenFile = TRUE;

    if ( err != NO_ERROR ) {
        goto retr_exit;
    }

    pOpenFileInfo = pUserData->QueryOpenFileInfo();

    if ( pOpenFileInfo == NULL )
    {
        err = ERROR_FILE_NOT_FOUND;
        goto retr_exit;
    }

    //
    // Get the file size
    //

    if ( !pOpenFileInfo->QuerySize(FileSize) )
    {
        err = GetLastError();

        if ( err != NO_ERROR ) {
            goto retr_exit;
        }
    }

    if( FileSize.HighPart != 0 ) {
        //
        // we do not support files >4GB.
        //
        ReplyToUser(pUserData,
                    REPLY_FILE_NOT_ALLOWED,
                    "Cannot send file larger than 4 gigabytes." );

        fErrorSent = TRUE;
        err = ERROR_MESSAGE_EXCEEDS_MAX_SIZE;
        goto retr_exit;
    }

    // removed to fix copatibility problem with cute ftp
    // when FTP service should report always a total size of file to be
    // transfered not a remainder like it was before
    //FileSize.QuadPart -= (LONGLONG)pUserData->QueryCurrentOffset();

    IsLargeIntegerToDecimalChar( &FileSize, rgchSize);
    wsprintfA( rgchBuffer, "(%s bytes)", rgchSize);

    //
    // Establish a data connection
    //
    err = pUserData->EstablishDataConnection( pszArg, rgchBuffer );

    if ( err != NO_ERROR )
    {
        if ( err == ERROR_IO_PENDING )
        {
            //
            // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
            // client to establish a data connection - it takes care of setting up an event that
            // allows us to deal asynchronously with the client connecting [or failing to do so].
            // It indicates this asynchrony by returning ERROR_IO_PENDING
            //

            DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                        !pUserData->QueryHavePASVConn() );

            if ( fTriedToOpenFile )
            {
                pUserData->CloseFileForSend( err);  // close it always on error
            }

            return TRUE;
        }

        fErrorSent = TRUE;

        goto retr_exit;
    }


    err = pUserData->SendFileToUser( pszArg, &fErrorSent);

    if ( err != NO_ERROR)
    {
        //
        // Disconnect connection, since we are in error.
        //
        DBG_REQUIRE( pUserData->DestroyDataConnection( err ));

        // since there was a failure we will close the handle right away.

        IF_DEBUG( ASYNC_IO) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SendFileToUser ( %s) failed"
                        " err = %u\n",
                        pszArg, err));
        }
    }

retr_exit:

    if( err != NO_ERROR )
    {
        //
        // This command failed, so drop out of PASV mode
        //
        CLEAR_UF( pUserData, PASSIVE );

        //
        // Clean up the PASV flags if necessary
        //
        if ( pUserData->QueryInFakeIOCompletion() )
        {
            pUserData->CleanupPASVFlags();
        }

        if ( !fErrorSent)
        {
            pUserData->SendErrorToClient(pszArg, err,
                                         PSZ_NO_FILE_OR_DIRECTORY);
        }

        pUserData->WriteLogRecordForSendError( err );

        if ( fTriedToOpenFile )
        {
            pUserData->CloseFileForSend( err);  // close it always on error
        }
    }

    return TRUE;

}   // MainRETR()




BOOL
MainSTOR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements STOR command - used for storing a file.
  Format:  STOR pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    HANDLE hFile;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to create the file.
    //

    err = VirtualCreateFile( pUserData,
                             &hFile,
                             pszArg,
                             FALSE );

    if( err != NO_ERROR )
    {
        pUserData->SendErrorToClient(pszArg, err, PSZ_CANNOT_CREATE_FILE);
    }
    else
    {

        //
        // Establish a connection to the user
        //
        err = pUserData->EstablishDataConnection( pszArg );

        if ( err != NO_ERROR )
        {
            CloseHandle( hFile );

            if ( err == ERROR_IO_PENDING )
            {
                //
                // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
                // client to establish a data connection - it takes care of setting up an event that
                // allows us to deal asynchronously with the client connecting [or failing to do so].
                // It indicates this asynchrony by returning ERROR_IO_PENDING and we don't do
                // any further processing
                //

                DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                            !pUserData->QueryHavePASVConn() );


                return TRUE;
            }

            goto stor_exit;
        }


        //
        //  Let the worker do the dirty work. ( blocking call)
        //  On return, hFile is closed
        //

        err = ReceiveFileFromUserAndClose( pUserData, pszArg, &hFile );

        if( err != NO_ERROR )
        {
            VirtualDeleteFile( pUserData,
                pszArg );
        }
    }

stor_exit:

    pUserData->WriteLogRecord(PSZ_CREATE_VERB, pszArg, err);

    return TRUE;

}   // MainSTOR()



BOOL
MainSTOU(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements STOU command - used for storing in unique file.
  Format:  STOU <noArgs>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    HANDLE hFile;
    CHAR   szTmpFile[MAX_PATH]; // contains entire path
    CHAR * pszTmpFileName;  // contains only the file name

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg == NULL );

    //
    //  Try to create the file.
    //

    szTmpFile[0] = '\0';
    err = VirtualCreateUniqueFile( pUserData,
                                   &hFile,
                                   szTmpFile );


    //
    // extract the file name alone
    //

    pszTmpFileName = strrchr( szTmpFile, '\\');
    if (NULL == pszTmpFileName)
      {  pszTmpFileName = szTmpFile; }
    else
      { pszTmpFileName++; }

    if( err != NO_ERROR )
    {

        pUserData->SendErrorToClient(pszTmpFileName, err,
                                     PSZ_CANNOT_CREATE_UNIQUE_FILE);
    }
    else
    {

        //
        // Establish a connection to the user
        //
        err = pUserData->EstablishDataConnection( pszTmpFileName );

        if ( err != NO_ERROR )
        {
            CloseHandle( hFile );

            if ( err == ERROR_IO_PENDING )
            {
                //
                // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
                // client to establish a data connection - it takes care of setting up an event that
                // allows us to deal asynchronously with the client connecting [or failing to do so].
                // It indicates this asynchrony by returning ERROR_IO_PENDING and we don't do
                // any further processign

                DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                            !pUserData->QueryHavePASVConn() );

                return TRUE;
            }

            goto stou_exit;
        }

        //
        //  Let the worker do the dirty work.
        //  On return, hFile is closed
        //

        err = ReceiveFileFromUserAndClose( pUserData, pszTmpFileName, &hFile );

        if( err != NO_ERROR ) {
            //
            // Note that VirtualCreateUniqueFile() returns a fully
            // qualified physical path to the temporary file. Because
            // of this, we cannot call VirtualDeleteFile(), as that will
            // attempt to "re-canonicalize" the file, which will fail.
            // So, we'll just call the DeleteFile() Win32 API directly.
            //

            DeleteFile( szTmpFile );
        }
    }



stou_exit:

    pUserData->WriteLogRecord(PSZ_CREATE_VERB, szTmpFile, err);

    return TRUE;

}   // MainSTOU()



BOOL
MainAPPE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements APPE command - used for appending to a file.
  Format:  APPE filename

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to create the file.
    //

    err = VirtualCreateFile( pUserData,
                             &hFile,
                             pszArg,
                             TRUE );



    if( err != NO_ERROR )
    {

        pUserData->SendErrorToClient(pszArg, err, PSZ_CANNOT_CREATE_FILE);
    }
    else
    {

        //
        // Establish a connection to the user
        //
        err = pUserData->EstablishDataConnection( pszArg );

        if ( err != NO_ERROR )
        {

            CloseHandle(hFile);

            if ( err == ERROR_IO_PENDING )
            {
                //
                // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
                // client to establish a data connection - it takes care of setting up an event that
                // allows us to deal asynchronously with the client connecting [or failing to do so].
                // It indicates this asynchrony by returning ERROR_IO_PENDING and we don't do
                // any further processing
                //

                DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                            !pUserData->QueryHavePASVConn() );

                return TRUE;
            }

            goto appe_exit;
        }



        //
        //  Let the worker do the dirty work.
        //  On return, hFile is closed
        //

        err = ReceiveFileFromUserAndClose( pUserData, pszArg, &hFile );
    }

appe_exit:

    pUserData->WriteLogRecord( PSZ_APPEND_VERB, pszArg, err);

    return TRUE;

}   // MainAPPE()




BOOL
MainALLO(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements ALLO command - used for allocating space for file.
  Format:  ALLO filename

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    //
    //  Since we don't need to pre-reserve storage space for
    //  files, we'll treat this command as a noop.
    //

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_COMMAND_SUCCESSFUL,
                "ALLO");

    return TRUE;

}   // MainALLO()



BOOL
MainREST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements REST command - used for restarting file write
  Format:  REST offset

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    LPSTR       pszEndPtr;
    DWORD       dwOffset;

    DBG_ASSERT( pUserData != NULL );

    DBG_ASSERT( pszArg != NULL );

    // Convert the input parameter to a number, and save it for the next command.

    dwOffset = strtoul(pszArg, &pszEndPtr, 10);

    if( (pszEndPtr == pszArg) || (*pszEndPtr != '\0') ||
        (*pszArg == '-') ||
        (dwOffset == ULONG_MAX && strcmp(pszArg, "4294967295")) )
    {
        ReplyToUser(pUserData,
                    REPLY_PARAMETER_SYNTAX_ERROR,
                    PSZ_REPLY_MARKER_SPEC );
    } else {

        pUserData->SetNextOffset( dwOffset );

        ReplyToUser(pUserData,
                    REPLY_NEED_MORE_INFO,
                    PSZ_REPLY_RESTARTING,
                    pszArg);
    }

    return TRUE;

}   // MainREST()



BOOL
MainRNFR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RNFR command - rename from filename
  Format:  RNFR FromFileName

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    CHAR   szCanon[MAX_PATH];
    DWORD  cbSize = MAX_PATH;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Ensure file/directory exists.
    //

    if (pUserData->IsFileNameShort(pszArg))
    {
        err = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        err = pUserData->VirtualCanonicalize(szCanon,
                                             &cbSize,
                                             pszArg,
                                             AccessTypeDelete );
    }

    if( err == NO_ERROR ) {


        if ( pUserData->ImpersonateUser() ) {
            if( GetFileAttributes( szCanon ) == (DWORD)-1L ) {

                err = GetLastError();
            }

            pUserData->RevertToSelf();
        } else {
            err = ERROR_ACCESS_DENIED;
        }

        if(( err == NO_ERROR ) && ( pUserData->RenameSourceBuffer == NULL )){

            pUserData->RenameSourceBuffer = (CHAR *)TCP_ALLOC( MAX_PATH );

            if( pUserData->RenameSourceBuffer == NULL ) {

                err = GetLastError();
            }
        }

        if( err == NO_ERROR ) {

            strcpy( pUserData->RenameSourceBuffer, pszArg );
            SET_UF( pUserData, RENAME );
        }
    }

    if( err == NO_ERROR )
    {
        ReplyToUser(pUserData,
                    REPLY_NEED_MORE_INFO,
                    PSZ_READY_FOR_DEST_FILE);
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }


    pUserData->WriteLogRecord( PSZ_RNFR_VERB, pszArg, err);

    return TRUE;

}   // MainRNFR()



BOOL
MainRNTO(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RNTO command - rename to filename
  Format:  RNTO ToFileName

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Ensure previous command was a RNFR.
    //

    if( !TEST_UF( pUserData, RENAME ) )
    {
        ReplyToUser(pUserData,
                    REPLY_BAD_COMMAND_SEQUENCE,
                    PSZ_BAD_COMMAND_SEQUENCE);
    } else {

        CLEAR_UF( pUserData, RENAME );

        //
        //  Rename the file.
        //

        err = VirtualRenameFile( pUserData,
                                pUserData->RenameSourceBuffer,
                                pszArg );

        if( err == NO_ERROR ) {

            ReplyToUser(pUserData,
                        REPLY_FILE_ACTION_COMPLETED,
                        PSZ_COMMAND_SUCCESSFUL, "RNTO");

        } else if( err == ERROR_FILE_EXISTS ) {

            pUserData->SendErrorToClient(
                pszArg,
                err,
                PSZ_DESTINATION_FILE_EXISTS,
                REPLY_FILE_NOT_ALLOWED
                );

        } else {

            pUserData->SendErrorToClient(
                pszArg,
                err,
                PSZ_NO_FILE_OR_DIRECTORY,
                REPLY_FILE_NOT_FOUND
                );

        }
    }

    pUserData->WriteLogRecord( PSZ_RNTO_VERB, pszArg, err);

    return TRUE;

}   // MainRNTO()



BOOL
MainABOR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements ABOR command - abort any ongoing data transfer
  Format:  ABOR

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                TEST_UF( pUserData, OOB_DATA )
                    ? REPLY_TRANSFER_OK
                    : REPLY_CONNECTION_OPEN,
                PSZ_COMMAND_SUCCESSFUL, "ABOR");

    //
    //  Clear any remaining oob flag.
    //

    CLEAR_UF( pUserData, OOB_DATA );

    pUserData->WriteLogRecord(PSZ_ABORT_VERB, "");

    return TRUE;

}   // MainABOR()



BOOL
MainDELE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements DELE command - used to delete a file
  Format:  DELE filename

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());


    if (pUserData->IsFileNameShort(pszArg))
    {
        err = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        err = VirtualDeleteFile( pUserData, pszArg );
    }

    if( err == NO_ERROR ) {

        ReplyToUser(pUserData,
                    REPLY_FILE_ACTION_COMPLETED,
                    PSZ_COMMAND_SUCCESSFUL, "DELE");

    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->WriteLogRecord( PSZ_DELE_VERB, pszArg, err);

    return TRUE;

}   // MainDELE()



BOOL
MainRMD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RMD command - used to delete a directory
  Format:  RMD directory

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    if (pUserData->IsFileNameShort(pszArg))
    {
        err = ERROR_PATH_NOT_FOUND;
    }
    else
    {
        err = VirtualRmDir( pUserData, pszArg );
    }

    if( err == NO_ERROR ) {

        ReplyToUser(pUserData,
                    REPLY_FILE_ACTION_COMPLETED,
                    PSZ_COMMAND_SUCCESSFUL, "RMD");
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->WriteLogRecord( PSZ_RMD_VERB, pszArg, err);

    return TRUE;

}   // MainRMD()



BOOL
MainMKD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements MKD command - used to create a directory
  Format:  MKD directory

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    err = VirtualMkDir( pUserData, pszArg );

    if( err == NO_ERROR ) {

        ReplyToUser(pUserData,
                    REPLY_FILE_CREATED,
                    PSZ_DIRECTORY_CREATE, pszArg);
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->WriteLogRecord( PSZ_MKD_VERB, pszArg, err);

    return TRUE;

}   // MainMKD()



BOOL
MainPWD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements PWD command - used to query path to working dir.
  Format:  PWD

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    CHAR     szDir[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    // We will be sending back the current directory in virtual form
    // Ofcourse the client should/need not worry about the exact path info.
    //
    strcpy( szDir, pUserData->QueryCurrentDirectory() );

    if( !TEST_UF( pUserData, MSDOS_DIR_OUTPUT ) ) {

        FlipSlashes( szDir );
    }

    ReplyToUser(pUserData,
                REPLY_FILE_CREATED,
                PSZ_CURRENT_DIRECTORY,
                szDir );

    return TRUE;

}   // MainPWD()





/*******************************************************************

    NAME:       MainLIST

    SYNOPSIS:   Implementation for the LIST command.  Similar to NLST,
                except defaults to long format display.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
BOOL
MainLIST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements LIST command - used for getting dir list.
    It is similar to NLST, only that this defaults to long format.
  Format:  LIST [options]* [path]*

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR serr = 0;
    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Let the worker do the dirty work.
    //

    serr = pUserData->EstablishDataConnection("/bin/ls");

    //
    // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
    // client to establish a data connection - it takes care of setting up an event that
    // allows us to deal asynchronously with the client connecting [or failing to do so].
    // It indicates this asynchrony by returning ERROR_IO_PENDING
    //
    if ( serr == ERROR_IO_PENDING )
    {
        DBG_ASSERT( TEST_UF( pUserData, PASSIVE ) );
        DBG_ASSERT( pUserData->QueryWaitingForPASVConn() );
        DBG_ASSERT( !pUserData->QueryHavePASVConn() );

        return TRUE;
    }

    if ( serr == 0) {

        DWORD dwError;

        serr = SimulateLs(pUserData,
                          pszArg,   // switches for path
                          TRUE,     // use data socket
                          TRUE);    // generate default long format

        dwError = ( (!TEST_UF(pUserData, OOB_ABORT) && (serr == 0))
                   ? NO_ERROR : serr);

        if ( dwError != NO_ERROR) {

            //
            // Send a soft error message indicating failure
            //

            pUserData->SendErrorToClient((pszArg != NULL) ? pszArg : ".",
                                         dwError,
                                         PSZ_NO_FILE_OR_DIRECTORY);

            // since we already reported error, now just reset transfer.
            CLEAR_UF( pUserData, TRANSFER);
        }

        DBG_REQUIRE( pUserData->DestroyDataConnection(dwError));

    } else {

        //
        // could not establish a connection send error!
        //  Error is already sent by EstablishDataConnection()
        //

        IF_DEBUG( ERROR) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "EstablishDataConnection( %08x) failed for LIST\n",
                        pUserData));
        }
    }

    return TRUE;

}   // MainLIST()



BOOL
MainNLST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements NLST command - used for getting dir list.
    generates a short form of dir listing.
  Format:  NLST [options]* [path]*

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    BOOL fSpecialLs;
    APIERR serr;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  If any switches are present, use the simulated "ls"
    //  command.  Otherwise (no switches) use the special
    //  file list.
    //

    // Estabalish a data connection for transfer of data and simulate Ls.

    fSpecialLs = ( ( pszArg == NULL) || ( *pszArg != '-')); // no switches

    serr = pUserData->EstablishDataConnection( (fSpecialLs)
                                              ? "file list" : "/bin/ls"
                                              );

    //
    // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
    // client to establish a data connection - it takes care of setting up an event that
    // allows us to deal asynchronously with the client connecting [or failing to do so].
    // It indicates this asynchrony by returning ERROR_IO_PENDING
    //
    if ( serr == ERROR_IO_PENDING )
    {
        DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                    !pUserData->QueryHavePASVConn() );

        return TRUE;
    }

    if ( serr == 0) {

        DWORD  dwError;

        serr = ( ( fSpecialLs) ?
                SpecialLs(pUserData,
                          pszArg,
                          TRUE)
                : SimulateLs(pUserData,
                             pszArg,      // switches & search path
                             TRUE)
                );

        dwError = ((!TEST_UF(pUserData, OOB_DATA) && (serr == 0))
                   ?NO_ERROR: serr);

        if ( dwError != NO_ERROR) {

            //
            // Send a soft error message indicating failure
            //

            pUserData->SendErrorToClient((pszArg != NULL) ? pszArg : ".",
                                         dwError,
                                         PSZ_NO_FILE_OR_DIRECTORY);

            // since we already reported error, now just reset transfer.
            CLEAR_UF( pUserData, TRANSFER);
        }

        DBG_REQUIRE(pUserData->DestroyDataConnection( dwError));

    } else {

        //
        // could not establish a connection send error!
        //  Error is already sent by EstablishDataConnection()
        //

        IF_DEBUG( ERROR) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "EstablishDataConnection( %08x) failed for LIST\n",
                        pUserData));
        }
    }

    return TRUE;

}   // MainNLST()



BOOL
MainSYST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements SYST command - used for getting system info.
  Format:  SYST

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_SYSTEM_TYPE,
                PSZ_VERSION_INFO );

    return TRUE;

}   // MainSYST()




# define MAX_STAT_BUFFER_SIZE        (900)

BOOL
MainSTAT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements STAT command - used for getting system stats.
  Format:  STAT

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    CHAR rgchBuffer[MAX_STAT_BUFFER_SIZE];
    DWORD cchBuf;
    DWORD dwError;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    if( pszArg == NULL )
    {
        HOSTENT * pHost;

        //
        //  Determine the name of the user's host machine.
        //

        pHost = gethostbyaddr((CHAR *)&pUserData->HostIpAddress.s_addr,
                              4,        // size of the s_addr structure
                              PF_INET ) ;

        //
        //  Just dump connection info.
        //

        cchBuf = wsprintfA( rgchBuffer,
                           "%u-%s status:\r\n"
                           "     Connected to %s\r\n"
                           "     Logged in as %s\r\n"
                           "     TYPE: %s, FORM: %s; STRUcture: %s;"
                           " transfer MODE: %s\r\n"
                           "     %s\r\n"
                           ,
                           REPLY_SYSTEM_STATUS,
                           g_FtpServiceNameString,
                           ( ( pHost != NULL )
                            ? pHost->h_name
                            : inet_ntoa( pUserData->HostIpAddress)),
                           pUserData->QueryUserName(),
                           TransferType( pUserData->QueryXferType() ),
                           "Nonprint",
                           "File",
                           TransferMode( pUserData->QueryXferMode()),
                           ( ( pUserData->QueryDataSocket() == INVALID_SOCKET )
                            ? "No data connection"
                            : "Data connection established")
                           );

        if ( cchBuf < MAX_STAT_BUFFER_SIZE &&
             pUserData->QueryControlSocket() != INVALID_SOCKET) {

            dwError = SockSend(pUserData,
                               pUserData->QueryControlSocket(),
                               rgchBuffer,
                               cchBuf);

            IF_DEBUG( SOCKETS) {

                DBGPRINTF((DBG_CONTEXT,
                           " Sending STAT results %d bytes [%s]. Error= %u\n",
                           cchBuf, rgchBuffer, dwError));
            }

        } else {

            dwError = ERROR_INSUFFICIENT_BUFFER;
        }

        ReplyToUser(pUserData,
                    REPLY_SYSTEM_STATUS,
                    PSZ_SERVER_STATUS_END );
    } else {

        //
        //  This should be similar to LIST, except it sends data
        //  over the control socket, not a data socket.
        //

        cchBuf = wsprintfA( rgchBuffer,
                           "%u-status of %s:\r\n",
                           REPLY_FILE_STATUS,
                           pszArg );

        if ( cchBuf < MAX_STAT_BUFFER_SIZE &&
             pUserData->QueryControlSocket() != INVALID_SOCKET) {

            dwError = SockSend(pUserData,
                               pUserData->QueryControlSocket(),
                               rgchBuffer,
                               cchBuf);

            // Error code is ignored after this point!
        }

        SimulateLs(pUserData,
                   pszArg,
                   FALSE,   // use control socket
                   TRUE);   // generate default long format

        ReplyToUser(pUserData,
                    REPLY_FILE_STATUS,
                    PSZ_SERVER_STATUS_END);
    }

    return TRUE;

}   // MainSTAT()



BOOL
MainNOOP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  The DO Nothing  NOOP command.
--*/
{

    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_COMMAND_SUCCESSFUL, "NOOP");

    return TRUE;

}   // MainNOOP()



BOOL
SiteDIRSTYLE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements DIRSTYLE command - used for getting site specific
     directory style. It also toggles the style
  Format:  DIRSTYLE

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    const CHAR *   pszResponse = NULL;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg == NULL );

    //
    //  Toggle the dir output flag.
    //

    if( TEST_UF( pUserData, MSDOS_DIR_OUTPUT ) )
    {
        CLEAR_UF( pUserData, MSDOS_DIR_OUTPUT );
        pszResponse = PSZ_RESPONSE_OFF;
    }
    else
    {
        SET_UF( pUserData, MSDOS_DIR_OUTPUT );
        pszResponse = PSZ_RESPONSE_ON;
    }

    DBG_ASSERT( pszResponse != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_MSDOS_DIRSTYLE,
                pszResponse );

    return TRUE;

}   // SiteDIRSTYLE()




BOOL
SiteCKM(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements CKM command - used for getting site specific
     Annotate Directories flag. It also toggles the flag.
  Format:  CKM

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    const CHAR   * pszResponse = NULL;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg == NULL );

    //
    //  Toggle the directory annotation flag.
    //

    if( TEST_UF( pUserData, ANNOTATE_DIRS ) )
    {
        CLEAR_UF( pUserData, ANNOTATE_DIRS );
        pszResponse = PSZ_RESPONSE_OFF;
    }
    else
    {
        SET_UF( pUserData, ANNOTATE_DIRS );
        pszResponse = PSZ_RESPONSE_ON;
    }

    DBG_ASSERT( pszResponse != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_DIRECTORY_ANNOTATION,
                pszResponse );

    return TRUE;

}   // SiteCKM()




BOOL
ParseStringIntoAddress(
    LPSTR     pszString,
    LPIN_ADDR pinetAddr,
    LPPORT    pport
    )
/*++
  Parse a comma-separated list of six decimal numbers
   into an IP address and a port number. The address and the port are
   in network byte order ( most significant bytes first).

  Arguments:
    pszString - string to be parsed. Should be of the form:
                 dd,dd,dd,dd,dd,dd where 'dd' us the decimal representation
                 of a byte (0-255)
    pinetAddr - will receive the IP Address
    pport     - will receive the port.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    INT     i;
    UCHAR   chBytes[6];
    UCHAR   chSum;

    chSum = 0;
    i     = 0;

    while( *pszString != '\0' )
    {
        UCHAR chCurrent = (UCHAR)*pszString++;

        if( ( chCurrent >= '0' ) && ( chCurrent <= '9' ) )
        {
            chSum = ( chSum * 10 ) + chCurrent - '0';
        }
        else
        if( ( chCurrent == ',' ) && ( i < 5 ) )
        {
            chBytes[i++] = chSum;
            chSum = 0;
        }
        else
        {
            return FALSE;
        }
    }

    chBytes[i] = chSum;

    if( i != 5 )
    {
        return FALSE;
    }

    pinetAddr->S_un.S_un_b.s_b1 = chBytes[0];
    pinetAddr->S_un.S_un_b.s_b2 = chBytes[1];
    pinetAddr->S_un.S_un_b.s_b3 = chBytes[2];
    pinetAddr->S_un.S_un_b.s_b4 = chBytes[3];

    *pport = (PORT)( chBytes[4] + ( chBytes[5] << 8 ) );

    return TRUE;

}   // ParseStringIntoAddress()



/*******************************************************************

    NAME:       ReceiveFileFromUserAndClose

    SYNOPSIS:   Worker function for STOR, STOU, and APPE commands.
                Will establish a connection via the (new) data
                socket, then receive a file over that socket.

    ENTRY:      pUserData - The user initiating the request.

                pszFileName - The name of the file to receive.

                phFile - An handle to the file being received.
                    This handle is closed before this
                    routine returns.

    Returns:
       Win32 Error codes (or socket errors) as DWORD

    HISTORY:
        KeithMo     16-Mar-1993 Created.
        MuraliK     05-April-1995 Dont free hFile here +
                                    Alloc IoTransBuffer locally

********************************************************************/
DWORD
ReceiveFileFromUserAndClose(
    LPUSER_DATA pUserData,
    LPSTR       pszFileName,
    LPHANDLE    phFile
    )
{
    BOOL    fResult;
    DWORD   cbRead = 0;
    DWORD   cbWritten;
    DWORD   dwError;
    SOCKET  DataSocket;
    LPVOID  IoTransferBuffer;
    DWORD dwNumThreads;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszFileName != NULL );
    DBG_ASSERT( *phFile != INVALID_HANDLE_VALUE );

    //
    // We're about to make a blocking call to SockRecv(), so increment the # of threads in the
    // ATQ thread pool.
    // The decision whether to process this request is made based on how many threads are already
    // blocked in a synchronous call.  We do it after accepting/establishing the
    // data connection, so that the clients's connect will succeed in the non-passive case, and
    // then have the request aborted. This prevents clients hangs.
    //

    dwNumThreads = InterlockedIncrement( (long *) &g_ThreadsBlockedInSyncCalls );

    if (dwNumThreads > g_MaxThreadsBlockedInSyncCalls)
    {

        //
        // Blow away the data connection
        //

        InterlockedDecrement( (long *) &g_ThreadsBlockedInSyncCalls );

        dwError = ERROR_NOT_ENOUGH_MEMORY;

        DBG_REQUIRE(pUserData->DestroyDataConnection( dwError));

        goto RecevieFileFromUser_exit;
    }

    AtqSetInfo( AtqIncMaxPoolThreads, 0 );

    //
    //  Allocate an i/o buffer if not already allocated.
    //

    IoTransferBuffer = TCP_ALLOC( g_SocketBufferSize );

    if( IoTransferBuffer == NULL ) {

        ReplyToUser(pUserData,
                    REPLY_LOCAL_ERROR,
                    PSZ_INSUFFICIENT_RESOURCES);

        InterlockedDecrement( (long *) &g_ThreadsBlockedInSyncCalls );
        AtqSetInfo( AtqDecMaxPoolThreads, 0 );

        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto RecevieFileFromUser_exit;
    }

    //
    //  Blast the file from the user to a local file.
    //

    DataSocket = pUserData->QueryDataSocket();

    for( ; ; )
    {
        //
        //  Read a chunk from the socket.
        //

        dwError = SockRecv( pUserData,
                           DataSocket,
                           IoTransferBuffer,
                           g_SocketBufferSize,
                           &cbRead );

        if( TEST_UF( pUserData,  OOB_DATA ) ||
           ( dwError != NO_ERROR ) || ( cbRead == 0 ) )
        {
            //
            //  Socket error during read or end of file or transfer aborted.
            //

            break;
        }

        pUserData->IncrementCbRecvd( cbRead);

        //
        //  Write the current buffer to the local file.
        //

        fResult = WriteFile( *phFile,
                             IoTransferBuffer,
                             cbRead,
                             &cbWritten,
                             NULL );

        if( !fResult )
        {
            dwError = GetLastError();
            break;
        }
    }

    if ( TEST_UF( pUserData, OOB_DATA)) {

        dwError = ERROR_OPERATION_ABORTED;
    }

    IF_DEBUG( COMMANDS )
    {
        if( !fResult )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot write file %s, error %lu\n",
                        pszFileName,
                        dwError ));
        } else if( dwError != NO_ERROR ) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot read data from client, error %d\n",
                       dwError ));
        }

        if( TEST_UF( pUserData,  OOB_DATA ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "transfer aborted by client\n" ));
        }
    }

    //
    // Close file handle before disconnecting from client. This is to serialize
    // requests. If we disconnect first, then an append to this file may follow
    // which may result in a sharing violation of the file (if this write has
    // not been flushed and closed yet).
    //

    DBG_REQUIRE( CloseHandle( *phFile ) );
    *phFile = INVALID_HANDLE_VALUE;

    //
    //  Disconnect from client.
    //

    DBG_REQUIRE(pUserData->DestroyDataConnection( dwError));

    if( IoTransferBuffer != NULL )
    {
        TCP_FREE( IoTransferBuffer );
        IoTransferBuffer = NULL;
    }

    if ( dwError == NO_ERROR) {

        pUserData->QueryInstance()->QueryStatsObj()->IncrTotalFilesReceived();
    }

    InterlockedDecrement( (long *) &g_ThreadsBlockedInSyncCalls );
    AtqSetInfo( AtqDecMaxPoolThreads, 0 );

RecevieFileFromUser_exit:

    if( *phFile != INVALID_HANDLE_VALUE ) {

       CloseHandle( *phFile );
       *phFile = INVALID_HANDLE_VALUE;
    }

    return (dwError);
}   // ReceiveFileFromUserAndClose()




/*******************************************************************

    NAME:       MyLogonUser

    SYNOPSIS:   Validates a user's credentials, then sets the
                impersonation for the current thread.  In effect,
                the current thread "becomes" the user.

    ENTRY:      pUserData - The user initiating the request.

                pszPassword - The user's password.  May be NULL.

                pfAsGuest - Will receive TRUE if the user was validated
                    with guest privileges.

                pfHomeDirFailure - Will receive TRUE if the user failed
                    to logon because the home directory was inaccessible.

                pfLicenseExceeded - Will receive TRUE if the logon
                    was denied due to license restrictions.

    RETURNS:    BOOL - If user validated & impersonation was
                    successful, returns TRUE.  Otherwise returns
                    TRUE.

    HISTORY:
        KeithMo     18-Mar-1993 Created.

********************************************************************/
BOOL
MyLogonUser(
    LPUSER_DATA pUserData,
    LPSTR       pszPassword,
    LPBOOL      pfAsGuest,
    LPBOOL      pfHomeDirFailure,
    LPBOOL      pfLicenseExceeded
    )
{
    BOOL     fReturn = TRUE;
    DWORD    dwUserAccess;
    TS_TOKEN UserToken;
    BOOL     fAsAnonymous;
    BOOL     fAsAnonymous2;
    BOOL     fEmptyPassword;
    const CHAR   * pszUser;

    //
    //  Validate parameters & state.
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pUserData->UserToken == NULL );
    DBG_ASSERT( pfAsGuest != NULL );
    DBG_ASSERT( pfHomeDirFailure != NULL );
    DBG_ASSERT( pfLicenseExceeded != NULL );

    //
    //  Setup.
    //

    *pfAsGuest         = FALSE;
    *pfHomeDirFailure  = FALSE;
    *pfLicenseExceeded = FALSE; // NOT YET SUPPORTED IN GHIA APIS!

    fEmptyPassword = ( pszPassword == NULL ) || ( *pszPassword == '\0' );

    pszUser = pUserData->QueryUserName();
    DBG_ASSERT( pszUser != NULL );
    DBG_ASSERT( *pszUser != '\0' );

    //
    //  Check for invalid logon type.
    //

    fAsAnonymous = TEST_UF( pUserData, ANONYMOUS);

    if( !pUserData->QueryInstance()->IsAllowedUser(fAsAnonymous)) {

        // conflict between what is allowed and type of the client.
        SetLastError( ERROR_LOGON_FAILURE);
        return FALSE;
    }

    //
    //  Check for anonymous logon.
    //

    if( fAsAnonymous )
    {
        //
        //  At this point, we could copy the password specified by the
        //  user into the pUserData->UserName field.  There's a convention
        //  among Internetters that the password specified for anonymous
        //  logon should actually be your login name.  So, if we wanted
        //  honor this convention, we could copy the password into the
        //  pUserData->UserName field so the Administration UI
        // could display it.
        //
        //  If the user didn't enter a password, we'll just copy over
        //  "Anonymous" so we'll have SOMETHING to display...
        //

        pUserData->SetUserName( fEmptyPassword ? PSZ_ANONYMOUS_NAME : pszPassword);

        //
        // TsLogon User will logon as anonymous only when we specify the
        //  UserName == NULL and pszPassword == NULL.
        //
        pszUser = NULL;
        pszPassword = NULL;
    }

    //
    //  Do that logon thang.
    //

    pUserData->QueryInstance()->LockConfig();

    // dumb TsLogonUser() does not take const CHAR * for pszUser :(
    UserToken = TsLogonUser( (CHAR *) pszUser,
                            pszPassword,
                            pfAsGuest,
                            &fAsAnonymous2,
                            pUserData->QueryInstance(),
                            pUserData->QueryInstance()->QueryAuthentInfo() );

    pUserData->QueryInstance()->UnLockConfig();

    //
    // Recheck the logon requirements, just in case the user is trying
    // to do something tricky, like logon with the special IUSR_xxx
    // account name.
    //

    if( UserToken != NULL &&
        !pUserData->QueryInstance()->IsAllowedUser(fAsAnonymous2) ) {

        TsDeleteUserToken( UserToken );
        UserToken = NULL;
        SetLastError( ERROR_LOGON_FAILURE );

    }

    if( UserToken != NULL ) {

        // reset it again even if it was anonymous
        pszUser = pUserData->QueryUserName();

        //
        //  Save away the impersonation token so we can delete
        //  it when the user disconnects or this client thread
        //  otherwise terminates.
        //

        pUserData->UserToken = UserToken;

        //
        //  User validated, now impersonate.
        //

        if( !pUserData->ImpersonateUser()) {

            //
            //  Impersonation failure.
            //

            IF_DEBUG( ERROR) {

                DBGPRINTF(( DBG_CONTEXT,
                           "Impersonate User %08x failed. Error=%lu\n",
                           UserToken, GetLastError()));
            }

            fReturn = FALSE;

        } else {

            //
            //  We're now running in the context of the connected user.
            //  Check the user's access to the FTP Server.
            //

            dwUserAccess = DetermineUserAccess(pUserData->QueryInstance());

            if( dwUserAccess == 0 ) {

                //
                //  User cannot access the FTP Server.
                //

                IF_DEBUG( SECURITY ) {

                    DBGPRINTF(( DBG_CONTEXT,
                               "user %s denied FTP access\n",
                               pszUser ));
                }

                fReturn = FALSE;

            } else {

                const CHAR * apszSubStrings[2];
                DWORD  eventId = 0;

                apszSubStrings[0] = pszUser;

                pUserData->Flags &= ~( UF_READ_ACCESS | UF_WRITE_ACCESS );
                pUserData->Flags |= dwUserAccess;

                IF_DEBUG( SECURITY ) {

                    CHAR * pszTmp = NULL;

                    if( TEST_UF( pUserData, READ_ACCESS ) ) {

                        pszTmp = ( TEST_UF( pUserData, WRITE_ACCESS )
                                  ? "read and write"
                                  : "read"
                                  );
                    } else {

                        DBG_ASSERT( TEST_UF( pUserData, WRITE_ACCESS ) );

                        pszTmp = "write";
                    }

                    DBG_ASSERT( pszTmp != NULL );

                    DBGPRINTF(( DBG_CONTEXT,
                               "user %s granted %s FTP access\n",
                               pszUser,
                               pszTmp ));
                }

                //
                //  initialize the user root directory
                //

                pUserData->SetRootDirectory( PSZ_ANONYMOUS_NAME );

                //
                //  Try to CD to the user's home directory.  Note that
                //  this is VERY important for setting up some of the
                //  "virtual current directory" structures properly.
                //

                if( pUserData->CdToUsersHomeDirectory( PSZ_ANONYMOUS_NAME)
                   != NO_ERROR ) {

                    //
                    //  Home directory inaccessible.
                    //

                    eventId = FTPD_EVENT_BAD_HOME_DIRECTORY;

                } else if (fAsAnonymous &&
                          pUserData->QueryInstance()->QueryLogAnonymous() &&
                          !fEmptyPassword ) {

                    //
                    //  If this is an anonymous user, and we're to log
                    //  anonymous logons, OR if this is not an anonymous
                    //  user, and we're to log nonanonymous logons, then
                    //  do it.
                    //
                    //  Note that we DON'T log the logon if the user is
                    //  anonymous but specified no password.
                    //

                    eventId =  FTPD_EVENT_ANONYMOUS_LOGON;

                } else if (!fAsAnonymous &&
                          pUserData->QueryInstance()->QueryLogNonAnonymous()
                          ) {

                    DBG_ASSERT( *pszUser != '\0');
                    eventId = FTPD_EVENT_NONANONYMOUS_LOGON;
                }

                //
                //  Log an event so the poor admin can figure out
                //  what's going on.
                //

                switch ( eventId) {

                  case FTPD_EVENT_ANONYMOUS_LOGON:
                  case FTPD_EVENT_NONANONYMOUS_LOGON:
                    apszSubStrings[1] = inet_ntoa( pUserData->HostIpAddress);

                    g_pInetSvc->LogEvent( eventId,
                                          2,
                                          apszSubStrings,
                                          0 );
                    break;

                  case FTPD_EVENT_BAD_HOME_DIRECTORY:

                    pUserData->QueryInstance()->LockThisForRead();

                    apszSubStrings[1] = pUserData->QueryInstance()->QueryRoot();

                    *pfHomeDirFailure = TRUE;
                    g_pInetSvc->LogEvent( eventId,
                                          2,
                                          apszSubStrings,
                                          0 );

                    pUserData->QueryInstance()->UnlockThis();

                    fReturn = FALSE;  // bad directory is a failure.
                    break;

                  default:
                    // do nothing
                    break;
                } // switch
            } // user Access Succeeded

            pUserData->RevertToSelf();  // get out the impersonation

        } // Impersonation succeeded.

    } else {

        fReturn = FALSE;
    }

    //
    //  Determine if we logged in with guest access, and
    //  if so, if guest access is allowed in our server.
    //

    if( *pfAsGuest && !pUserData->QueryInstance()->AllowGuestAccess() ) {

        TsDeleteUserToken( pUserData->QueryUserToken() );

        pUserData->UserToken = NULL;

        fReturn = FALSE;
    }

    //
    //  Success!
    //

    return ( fReturn);

}   // MyLogonUser()



DWORD
DetermineUserAccess(FTP_SERVER_INSTANCE *pInstance)
/*++
  This function determines the current user's access to FTP server.
  This is done by testing different RegOpenKey APIs against
  the FTPD_ACCESS_KEY. This key (if it exists) will be "under" the
  FTPD_PARAMETERS_KEY key.

  Arguments:
    None

  Returns:
    DWORD -- will be an OR Combination of UF_READ_ACCESS and UF_WRITE_ACCESS.
    IF this is zero, then the user cannot access FTP server.

  History:
    KeithMo     06-May-1993 Created.
    MuraliK     24-July-1995  Call this function with Impersonation.

  NYI:  Improve performance by avoiding reg opens per connection....
--*/
{
    DWORD  dwAccess = 0;
    HKEY   hkey;
    APIERR err;

    //
    //  Test for read access.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        FTPD_ACCESS_KEY,
                        0,
                        KEY_READ,
                        &hkey );

    if( err == NO_ERROR )
    {
        //
        //  Success.
        //

        dwAccess |= UF_READ_ACCESS;
        RegCloseKey( hkey );
    }
    else
    if( err == ERROR_FILE_NOT_FOUND )
    {
        //
        //  Key doesn't exist.
        //

        dwAccess |= UF_READ_ACCESS;
    }

    //
    //  Test for write access.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        FTPD_ACCESS_KEY,
                        0,
                        KEY_WRITE,
                        &hkey );

    if( err == NO_ERROR )
    {
        //
        //  Success.
        //

        dwAccess |= UF_WRITE_ACCESS;
        RegCloseKey( hkey );
    }
    else
    if( err == ERROR_FILE_NOT_FOUND )
    {
        //
        //  Key doesn't exist.
        //

        dwAccess |= UF_WRITE_ACCESS;
    }

    return dwAccess;
} // DetermineUserAccess()


/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\ftpcmd.cxx ===
/*++


   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      ftpcmd.cxx

   Abstract:

      This module defines the FTP commands supported by this FTP server
        and provides a table of functions to be called for processing
        such command requests.
      ( Some parts of the code are from old engine.cxx ( KeithMo's FTP server))

   Author:

       Murali R. Krishnan    ( MuraliK )     28-Mar-1995

   Environment:

       User Mode -- Win32

   Project:

       FTP Server DLL

   Functions Exported:

       ParseCommand
       ()

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <ftpdp.hxx>
# include "ftpcmd.hxx"
# include "lsaux.hxx"
# include "auxctrs.h"

#define MAX_COMMAND_NAME_LEN    ( 30)
# define MAX_HELP_LINE_SIZE     ( 80)
# define MAX_HELP_AUX_SIZE      (100) // fixed sized aux info with HELP
# define HelpMsgSize( nCommands)   ((1 + nCommands) * MAX_HELP_LINE_SIZE + \
                                    MAX_HELP_AUX_SIZE)

#define IS_7BIT_ASCII(c)   ((UINT)(c) <= 127)


/************************************************************
 *    Static Data containing command lookups
 ************************************************************/



# define UsP           ( UserStateWaitingForPass)
# define UsUP          ( UserStateWaitingForUser | UsP)
# define UsL           ( UserStateLoggedOn)
# define UsUPL         ( UsL | UsUP)

//
// Store the commands in alphabetical order ( manually stored so!)
//   to enable faster search.
//
// Format is:
//  Name   Help Information   FunctionToCall  ArgumentType  ValidStates
//

FTPD_COMMAND MainCommands[] ={

    { "ABOR", "(abort operation)",            MainABOR, ArgTypeNone,    UsL},
    { "ACCT", "(specify account)",            MainACCT, ArgTypeRequired,UsL},
    { "ALLO", "(allocate storage vacuously)", MainALLO, ArgTypeRequired,UsL},
    { "APPE", "<sp> file-name",               MainAPPE, ArgTypeRequired,UsL},
    { "CDUP", "change to parent directory",   MainCDUP, ArgTypeNone,    UsL},
    { "CWD",  "[ <sp> directory-name ]",      MainCWD , ArgTypeOptional,UsL},
    { "DELE", "<sp> file-name",               MainDELE, ArgTypeRequired,UsL},
    { "HELP", "[ <sp> <string>]",             MainHELP, ArgTypeOptional,UsUPL},
    { "LIST", "[ <sp> path-name ]",           MainLIST, ArgTypeOptional,UsL},
    { "MDTM", "(sp) file-name",               MainMDTM, ArgTypeRequired,UsL },
    { "MKD",  "<sp> path-name",               MainMKD , ArgTypeRequired,UsL},
    { "MODE", "(specify transfer mode)",      MainMODE, ArgTypeRequired,UsUPL},
    { "NLST", "[ <sp> path-name ]",           MainNLST, ArgTypeOptional,UsL},
    { "NOOP", "",                             MainNOOP, ArgTypeNone,    UsUPL},
    { "PASS", "<sp> password",                MainPASS, ArgTypeOptional, UsP},
    { "PASV", "(set server in passive mode)", MainPASV, ArgTypeNone,    UsL},
    { "PORT", "<sp> b0,b1,b2,b3,b4,b5",       MainPORT, ArgTypeRequired,UsUPL},
    { "PWD",  "(return current directory)",   MainPWD , ArgTypeNone,    UsL},
    { "QUIT", "(terminate service)",          MainQUIT, ArgTypeNone,    UsUPL},
    { "REIN", "(reinitialize server state)",  MainREIN, ArgTypeNone,    UsL},
    { "REST", "<sp> marker",                  MainREST, ArgTypeRequired,UsL},
    { "RETR", "<sp> file-name",               MainRETR, ArgTypeRequired,UsL},
    { "RMD",  "<sp> path-name",               MainRMD , ArgTypeRequired,UsL },
    { "RNFR", "<sp> file-name",               MainRNFR, ArgTypeRequired,UsL},
    { "RNTO", "<sp> file-name",               MainRNTO, ArgTypeRequired,UsL },
    { "SITE", "(site-specific commands)",     MainSITE, ArgTypeOptional,UsL },
    { "SIZE", "(sp) file-name",               MainSIZE, ArgTypeRequired,UsL },
    { "SMNT", "<sp> pathname",                MainSMNT, ArgTypeRequired,UsL },
    { "STAT", "(get server status)",          MainSTAT, ArgTypeOptional,UsL },
    { "STOR", "<sp> file-name",               MainSTOR, ArgTypeRequired,UsL },
    { "STOU", "(store unique file)",          MainSTOU, ArgTypeNone,    UsL},
    { "STRU", "(specify file structure)",     MainSTRU, ArgTypeRequired,UsUPL},
    { "SYST", "(get operating system type)",  MainSYST, ArgTypeNone,    UsL },
    { "TYPE", "<sp> [ A | E | I | L ]",       MainTYPE, ArgTypeRequired,UsL },
    { "USER", "<sp> username",                MainUSER, ArgTypeRequired,UsUPL},
    { "XCUP", "change to parent directory",   MainCDUP, ArgTypeNone,    UsL},
    { "XCWD", "[ <sp> directory-name ]",      MainCWD , ArgTypeOptional,UsL },
    { "XMKD", "<sp> path-name",               MainMKD , ArgTypeRequired,UsL },
    { "XPWD", "(return current directory)",   MainPWD , ArgTypeNone,    UsL },
    { "XRMD", "<sp> path-name",               MainRMD , ArgTypeRequired,UsL }
};

#define NUM_MAIN_COMMANDS ( sizeof(MainCommands) / sizeof(MainCommands[0]) )




FTPD_COMMAND SiteCommands[] = {

    { "CKM",      "(toggle directory comments)", SiteCKM    , ArgTypeNone,UsL},
    { "DIRSTYLE", "(toggle directory format)",  SiteDIRSTYLE, ArgTypeNone,UsL},
    { "HELP",     "[ <sp> <string>]",           SiteHELP    , ArgTypeOptional,
                                                                     UsL}

#ifdef KEEP_COMMAND_STATS

    ,{ "STATS",    "(display per-command stats)", SiteSTATS , ArgTypeNone, UsL}

#endif  // KEEP_COMMAND_STATS

    };


#define NUM_SITE_COMMANDS ( sizeof(SiteCommands) / sizeof(SiteCommands[0]) )



#ifdef KEEP_COMMAND_STATS
extern CRITICAL_SECTION g_CommandStatisticsLock;
#endif  // KEEP_COMMAND_STATS


#ifdef FTP_AUX_COUNTERS

LONG g_AuxCounters[NUM_AUX_COUNTERS];

#endif // FTP_AUX_COUNTERS




char  PSZ_COMMAND_NOT_UNDERSTOOD[] = "'%s': command not understood";
char  PSZ_INVALID_PARAMS_TO_COMMAND[] = "'%s': Invalid number of parameters";
char  PSZ_ILLEGAL_PARAMS[] = "'%s': illegal parameters";



/************************************************************
 *    Functions
 ************************************************************/



LPFTPD_COMMAND
FindCommandByName(
    LPSTR          pszCommandName,
    LPFTPD_COMMAND pCommandTable,
    INT            cCommands
    );


VOID
HelpWorker(
    LPUSER_DATA    pUserData,
    LPSTR          pszSource,
    LPSTR          pszCommand,
    LPFTPD_COMMAND pCommandTable,
    INT            cCommands,
    INT            cchMaxCmd
    );


/*******************************************************************

    NAME:       ParseCommand

    SYNOPSIS:   Parses a command string, dispatching to the
                appropriate implementation function.

    ENTRY:      pUserData - The user initiating  the request.

                pszCommandText - pointer to command text. This array of
                 characters will be munged while parsing.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     08-18-1995  Eliminated local copy of the command text

********************************************************************/
VOID
ParseCommand(
    LPUSER_DATA pUserData,
    LPSTR       pszCommandText
    )
{
    LPFTPD_COMMAND pcmd;
    LPFN_COMMAND   pfnCmd;
    LPSTR          pszSeparator;
    LPSTR          pszInvalidCommandText = PSZ_INVALID_PARAMS_TO_COMMAND;
    CHAR           chSeparator;
    BOOL           fValidArguments;
    BOOL           fReturn = FALSE;

    DBG_ASSERT( pszCommandText != NULL );
    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );
    DBG_ASSERT( IS_VALID_USER_STATE( pUserData->UserState ) );

    IF_DEBUG( PARSING) {

        DBGPRINTF( ( DBG_CONTEXT, "ParseCommand( %08x, %s)\n",
                    pUserData, pszCommandText));
    }

    //
    //  Ensure we didn't get entered in an invalid state.
    //


//BOGUS:    DBG_ASSERT( ( pUserData->UserState != UserStateEmbryonic ) &&
//BOGUS:                 ( pUserData->UserState != UserStateDisconnected ) );

    pUserData->UpdateOffsets();

    //
    //  The command will be terminated by either a space or a '\0'.
    //

    pszSeparator = strchr( pszCommandText, ' ' );

    if( pszSeparator == NULL )
    {
        pszSeparator = pszCommandText + strlen( pszCommandText );
    }

    //
    //  Try to find the command in the command table.
    //

    chSeparator   = *pszSeparator;
    *pszSeparator = '\0';

    pcmd = FindCommandByName( pszCommandText,
                              MainCommands,
                              NUM_MAIN_COMMANDS );

    if( chSeparator != '\0' )
    {
        *pszSeparator++ = chSeparator;
    }

    //
    //  If this is an unknown command, reply accordingly.
    //

    if( pcmd == NULL )
    {
        FacIncrement( FacUnknownCommands);

        ReplyToUser( pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    PSZ_COMMAND_NOT_UNDERSTOOD,
                    pszCommandText );
        return;
    }

    //
    //  Retrieve the implementation routine.
    //

    pfnCmd = pcmd->Implementation;

    //
    //  If this is an unimplemented command, reply accordingly.
    //

    if( pfnCmd == NULL )
    {
        ReplyToUser( pUserData,
                    REPLY_COMMAND_NOT_IMPLEMENTED,
                    PSZ_COMMAND_NOT_UNDERSTOOD,
                    pcmd->CommandName );

        return;
    }


    //
    //  Ensure we're in a valid state for the specified command.
    //

    if ( ( pcmd->dwUserState & pUserData->UserState) == 0) {

        if( pfnCmd == MainPASS ) {

            ReplyToUser( pUserData,
                        REPLY_BAD_COMMAND_SEQUENCE,
                        "Login with USER first." );
        } else {

            ReplyToUser( pUserData,
                        REPLY_NOT_LOGGED_IN,
                        "Please login with USER and PASS." );
        }

        return;
    }

    //
    //  Do a quick & dirty preliminary check of the argument(s).
    //

    fValidArguments = FALSE;

    while( ( *pszSeparator == ' ' ) && ( *pszSeparator != '\0' ) ) {

        pszSeparator++;
    }

    switch( pcmd->ArgumentType ) {

      case ArgTypeNone :
        fValidArguments = ( *pszSeparator == '\0' );
        break;

      case ArgTypeOptional :
        fValidArguments = TRUE;
        break;

      case ArgTypeRequired :
        fValidArguments = ( *pszSeparator != '\0' );
        break;

      default:
        DBGPRINTF(( DBG_CONTEXT,
                   "ParseCommand - invalid argtype %d\n",
                   pcmd->ArgumentType ));
        DBG_ASSERT( FALSE );
        break;
    }


    //
    // check we did not get extended chars if we are configured not to allow that
    //

    if( g_fNoExtendedChars /* && !pUserDate->QueryUTF8Option() */) {

        LPSTR pszCh = pszSeparator;

        while( *pszCh ) {

            if( !IS_7BIT_ASCII( *pszCh++ ) ) {

               fValidArguments = FALSE;
               pszInvalidCommandText = PSZ_ILLEGAL_PARAMS;
               break;
            }
        }
    }

    if( fValidArguments ) {

        //
        //  Invoke the implementation routine.
        //

        if( *pszSeparator == '\0' )
        {
            pszSeparator = NULL;
        }

        IF_DEBUG( PARSING )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "invoking %s command, args = %s\n",
                        pcmd->CommandName,
                        _strnicmp( pcmd->CommandName, "PASS", 4 )
                            ? pszSeparator
                            : "{secret...}" ));
        }

#ifdef KEEP_COMMAND_STATS
        EnterCriticalSection( &g_CommandStatisticsLock );

        //
        // only increment the count if we're not re-processing a command
        //
        if ( !pUserData->QueryInFakeIOCompletion() )
        {
            pcmd->UsageCount++;
        }
        LeaveCriticalSection( &g_CommandStatisticsLock );
#endif  // KEEP_COMMAND_STATS

        //
        // Keep track of what command is being executed, in case command processing doesn't
        // complete in this thread and another thread has to finish processing it
        // [can happen if we're in PASV mode and doing async accept on the data connection]
        // Only need to do this if this thread isn't handling an IO completion we generated
        // ourselves because a PASV socket became accept()'able - if it is, we've already
        // set the command.
        //
        if ( !pUserData->QueryInFakeIOCompletion() )
        {
            if ( !pUserData->SetCommand( pszCommandText ) )
            {
                ReplyToUser( pUserData,
                             REPLY_LOCAL_ERROR,
                             "Failed to allocate necessary memory.");
            }
        }
        fReturn = (pfnCmd)( pUserData, pszSeparator );

        if ( !fReturn) {

            //
            // Invalid number of arguments. Inform the client.
            //
            ReplyToUser(pUserData,
                        REPLY_UNRECOGNIZED_COMMAND,
                        PSZ_COMMAND_NOT_UNDERSTOOD,
                        pszCommandText);
        }

    } else {

        // Invalid # of arguments

        ReplyToUser(pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    pszInvalidCommandText,
                    pszCommandText);
    }

    return;
}   // ParseCommand()






/*******************************************************************

    NAME:       MainSITE

    SYNOPSIS:   Implementation for the SITE command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
BOOL
MainSITE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    LPFTPD_COMMAND pcmd;
    LPFN_COMMAND   pfnCmd;
    LPSTR          pszSeparator;
    CHAR           chSeparator;
    BOOL           fValidArguments;
    CHAR           szParsedCommand[MAX_COMMAND_LENGTH+1];

    DBG_ASSERT( pUserData != NULL );


    //
    //  If no arguments were given, just return the help text.
    //

    if( pszArg == NULL )
    {
        SiteHELP( pUserData, NULL );
        return TRUE;
    }

    //
    //  Save a copy of the command so we can muck around with it.
    //

    P_strncpy( szParsedCommand, pszArg, MAX_COMMAND_LENGTH );

    //
    //  The command will be terminated by either a space or a '\0'.
    //

    pszSeparator = strchr( szParsedCommand, ' ' );

    if( pszSeparator == NULL )
    {
        pszSeparator = szParsedCommand + strlen( szParsedCommand );
    }

    //
    //  Try to find the command in the command table.
    //

    chSeparator   = *pszSeparator;
    *pszSeparator = '\0';

    pcmd = FindCommandByName( szParsedCommand,
                              SiteCommands,
                              NUM_SITE_COMMANDS );

    if( chSeparator != '\0' )
    {
        *pszSeparator++ = chSeparator;
    }

    //
    //  If this is an unknown command, reply accordingly.
    //

    if( pcmd == NULL ) {

        //
        //  Syntax error in command.
        //

        ReplyToUser( pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    "'SITE %s': command not understood",
                    pszArg );

        return (TRUE);
    }

    //
    //  Retrieve the implementation routine.
    //

    pfnCmd = pcmd->Implementation;

    //
    //  If this is an unimplemented command, reply accordingly.
    //

    if( pfnCmd == NULL )
    {
        ReplyToUser( pUserData,
                    REPLY_COMMAND_NOT_IMPLEMENTED,
                    "SITE %s command not implemented.",
                    pcmd->CommandName );

        return TRUE;
    }


    //
    //  Ensure we're in a valid state for the specified command.
    //

    if ( ( pcmd->dwUserState & pUserData->UserState) == 0) {

        ReplyToUser( pUserData,
                    REPLY_NOT_LOGGED_IN,
                    "Please login with USER and PASS." );
        return (FALSE);
    }

    //
    //  Do a quick & dirty preliminary check of the argument(s).
    //

    fValidArguments = FALSE;

    while( ( *pszSeparator == ' ' ) && ( *pszSeparator != '\0' ) )
    {

        pszSeparator++;
    }

    switch( pcmd->ArgumentType ) {

      case ArgTypeNone:
        fValidArguments = ( *pszSeparator == '\0' );
        break;

      case ArgTypeOptional:
        fValidArguments = TRUE;
        break;

      case ArgTypeRequired:
        fValidArguments = ( *pszSeparator != '\0' );
        break;

      default:
        DBGPRINTF(( DBG_CONTEXT,
                    "MainSite - invalid argtype %d\n",
                   pcmd->ArgumentType ));
        DBG_ASSERT( FALSE );
        break;
    }

    if( fValidArguments ) {

        //
        //  Invoke the implementation routine.
        //

        if( *pszSeparator == '\0' )
        {
            pszSeparator = NULL;
        }

        IF_DEBUG( PARSING )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "invoking SITE %s command, args = %s\n",
                       pcmd->CommandName,
                       pszSeparator ));
        }

        if( (pfnCmd)( pUserData, pszSeparator ) )
        {
            return TRUE;
        }
    } else {

        // Invalid # of arguments

        ReplyToUser(pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    PSZ_INVALID_PARAMS_TO_COMMAND,
                    pszArg);
    }

    return TRUE;

}   // MainSITE()





/*******************************************************************

    NAME:       MainHELP

    SYNOPSIS:   Implementation for the HELP command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
BOOL
MainHELP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    DBG_ASSERT( pUserData != NULL );

    HelpWorker(pUserData,
               "",
               pszArg,
               MainCommands,
               NUM_MAIN_COMMANDS,
               4 );

    return TRUE;

}   // MainHELP







/*******************************************************************

    NAME:       SiteHELP

    SYNOPSIS:   Implementation for the site-specific HELP command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-May-1993 Created.

********************************************************************/
BOOL
SiteHELP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    DBG_ASSERT( pUserData != NULL );

    HelpWorker(pUserData,
               "SITE ",
               pszArg,
               SiteCommands,
               NUM_SITE_COMMANDS,
               8 );

    return TRUE;

}   // SiteHELP






#ifdef KEEP_COMMAND_STATS
/*******************************************************************

    NAME:       SiteSTATS

    SYNOPSIS:   Implementation for the site-specific STATS command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     26-Sep-1994 Created.

********************************************************************/
BOOL
SiteSTATS(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    SOCKET  ControlSocket;
    LPFTPD_COMMAND pCmd;
    INT            i;
    CHAR    rgchUsageStats[NUM_MAIN_COMMANDS * 25]; //  25 chars per command

    pCmd   = MainCommands;

    DBG_ASSERT( NUM_MAIN_COMMANDS > 0); // we know this very well!

    // Print the stats for first command.
    EnterCriticalSection( &g_CommandStatisticsLock );

    // Find first non-zero entry.
    for( i = 0; i < NUM_MAIN_COMMANDS && pCmd->UsageCount <= 0; i++, pCmd++)
      ;

    if ( i < NUM_MAIN_COMMANDS) {

        // There is some non-zero entry.

        CHAR *  pszStats = rgchUsageStats;
        DWORD   cch = 0;

        // print the stats for first command
        cch = wsprintfA( pszStats + cch, "%u-%-4s : %lu\r\n",
                        REPLY_COMMAND_OK,
                        pCmd->CommandName,
                        pCmd->UsageCount);

        for( i++, pCmd++ ; i < NUM_MAIN_COMMANDS ; i++, pCmd++) {

            if( pCmd->UsageCount > 0 ) {

                cch += wsprintfA( pszStats + cch,
                                 "    %-4s : %lu\r\n",
                                 pCmd->CommandName,
                                 pCmd->UsageCount );
                DBG_ASSERT( cch < NUM_MAIN_COMMANDS * 25);
            }

        } // for

        // Ignoring the error code here! probably socket closed
        SockSend( pUserData, pUserData->QueryControlSocket(),
                         rgchUsageStats, cch);
    }

    LeaveCriticalSection( &g_CommandStatisticsLock );

#ifdef  FTP_AUX_COUNTERS

    CHAR *  pszStats = rgchUsageStats;
    DWORD   cch = 0;

    // print the stats for first counter
    cch = wsprintfA( pszStats + cch, "%u-Aux[%d] : %lu\r\n",
                    REPLY_COMMAND_OK,
                    0,
                    FacCounter(0));

    for( i = 1; i < NUM_AUX_COUNTERS; i++) {

        cch += wsprintfA( pszStats + cch,
                         "    Aux[%d] : %lu\r\n",
                         i,
                         FacCounter(i));
        DBG_ASSERT( cch < NUM_MAIN_COMMANDS * 25);
      }

    if ( cch > 0) {

        SockSend( pUserData, pUserData->QueryControlSocket(),
                 rgchUsageStats, cch);
    }

# endif // FTP_AUX_COUNTERS

    ReplyToUser( pUserData,
                REPLY_COMMAND_OK,
                "End of stats." );

    return TRUE;

}   // SiteSTATS
#endif KEEP_COMMAND_STATS





/*******************************************************************

    NAME:       FindCommandByName

    SYNOPSIS:   Searches the command table for a command with this
                specified name.

    ENTRY:      pszCommandName - The name of the command to find.

                pCommandTable - An array of FTPD_COMMANDs detailing
                    the available commands.

                cCommands - The number of commands in pCommandTable.

    RETURNS:    LPFTPD_COMMAND - Points to the command entry for
                    the named command.  Will be NULL if command
                    not found.

    HISTORY:
        KeithMo     10-Mar-1993 Created.
        MuraliK     28-Mar-1995 Completely rewrote to support binary search.

********************************************************************/
LPFTPD_COMMAND
FindCommandByName(
                  LPSTR          pszCommandName,
                  LPFTPD_COMMAND pCommandTable,
                  INT            cCommands
                  )
{
    int  iLower = 0;
    int  iHigher = cCommands  - 1; // store the indexes
    LPFTPD_COMMAND pCommandFound = NULL;

    DBG_ASSERT( pszCommandName != NULL );
    DBG_ASSERT( pCommandTable != NULL );
    DBG_ASSERT( cCommands > 0 );

    //
    //  Search for the command in our table.
    //

    _strupr( pszCommandName );


    while ( iLower <= iHigher) {

        int iMid = ( iHigher + iLower) / 2;

        int comp = strcmp( pszCommandName, pCommandTable[ iMid].CommandName);

        if ( comp == 0) {

            pCommandFound = ( pCommandTable + iMid);
            break;

        } else if ( comp < 0) {

            // reset the higher bound
            iHigher = iMid - 1;
        } else {

            // reset the lower bound
            iLower = iMid + 1;
        }
    }

    return ( pCommandFound);

}   // FindCommandByName()





/*******************************************************************

    NAME:       HelpWorker

    SYNOPSIS:   Worker function for HELP & site-specific HELP commands.

    ENTRY:      pUserData - The user initiating the request.

                pszSource - The source of these commands.

                pszCommand - The command to get help for.  If NULL,
                    then send a list of available commands.

                pCommandTable - An array of FTPD_COMMANDs, one for
                    each available command.

                cCommands - The number of commands in pCommandTable.

                cchMaxCmd - Length of the maximum command.

    HISTORY:
        KeithMo     06-May-1993 Created.
        Muralik     08-May-1995 Added Buffering for performance.

********************************************************************/
VOID
HelpWorker(
           LPUSER_DATA    pUserData,
           LPSTR          pszSource,
           LPSTR          pszCommand,
           LPFTPD_COMMAND pCommandTable,
           INT            cCommands,
           INT            cchMaxCmd
           )
{
    LPFTPD_COMMAND pcmd;
    DWORD  dwError;

    //
    // We should cache the following message and use the cached message for
    //  sending purposes ==> improves performance.
    //  MuraliK   NYI
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pCommandTable != NULL );
    DBG_ASSERT( cCommands > 0 );

    if( pszCommand == NULL ) {

        DWORD          cch;
        LS_BUFFER      lsb;
        CHAR szTmp[MAX_HELP_LINE_SIZE];

        if ((dwError = lsb.AllocateBuffer(HelpMsgSize(cCommands)))!= NO_ERROR){

            IF_DEBUG( ERROR) {

                DBGPRINTF(( DBG_CONTEXT,
                           "Buffer Allocation ( %d bytes) failed.\n",
                           HelpMsgSize(cCommands)));
            }

            ReplyToUser(pUserData,
                        REPLY_HELP_MESSAGE,
                        "HELP command failed." );
            return;
        }

        cch = wsprintfA( lsb.QueryAppendPtr(),
                        "%u-The following %s commands are recognized"
                        "(* ==>'s unimplemented).\r\n",
                        REPLY_HELP_MESSAGE,
                        pszSource);
        lsb.IncrementCB( cch * sizeof( CHAR));

        for( pcmd = pCommandTable; pcmd < pCommandTable + cCommands; pcmd++) {

            cch = sprintf( szTmp,
                          "   %-*s%c\r\n",
                          cchMaxCmd,
                          pcmd->CommandName,
                          pcmd->Implementation == NULL ? '*' : ' ' );

            DBG_ASSERT( cch*sizeof(CHAR) < sizeof(szTmp));

            //
            // since we calculate and preallocate the buffer, we dont
            //  need to worry about the overflow of the buffer.
            //

            DBG_ASSERT( cch*sizeof(CHAR) < lsb.QueryRemainingCB());

            if ( cch * sizeof(CHAR) >= lsb.QueryRemainingCB()) {

                // This is added for retail code where ASSERT may fail.

                dwError = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            strncpy( lsb.QueryAppendPtr(), szTmp, cch);
            lsb.IncrementCB( cch*sizeof(CHAR));

        } // for ( all commands)

        if ( dwError == NO_ERROR) {

            // Append the ending sequence for success in generating HELP.
            cch = sprintf( szTmp,
                          "%u  %s\r\n",
                          REPLY_HELP_MESSAGE,
                          "HELP command successful." );

            if ( cch*sizeof(CHAR) >= lsb.QueryRemainingCB()) {

                dwError = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                // copy the completion message
                strncpy( lsb.QueryAppendPtr(), szTmp, cch);
                lsb.IncrementCB( cch*sizeof(CHAR));
            }
        }

        if ( dwError == NO_ERROR) {

            // Send the chunk of data

            dwError = SockSend( pUserData,
                               pUserData->QueryControlSocket(),
                               lsb.QueryBuffer(),
                               lsb.QueryCB());
        } else {

            IF_DEBUG( ERROR) {

                DBGPRINTF(( DBG_CONTEXT,
                           "Error = %u. Should Not happen though...\n",
                           dwError));
            }

            ReplyToUser( pUserData,
                        REPLY_HELP_MESSAGE,
                        "HELP command failed.");
        }

        lsb.FreeBuffer();

        // Ignore the errors if any from propagating outside

    } else {

        pcmd = FindCommandByName(pszCommand,
                                 pCommandTable,
                                 cCommands );

        if( pcmd == NULL ) {

            ReplyToUser( pUserData,
                        REPLY_PARAMETER_SYNTAX_ERROR,
                        "Unknown command %s.",
                        pszCommand );
        } else {

            ReplyToUser( pUserData,
                        REPLY_HELP_MESSAGE,
                        "Syntax: %s%s %s",
                        pszSource,
                        pcmd->CommandName,
                        pcmd->HelpText );
        }
    }

    return;

}   // HelpWorker()


/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\ftpconf.cxx ===
/*++
   Copyright    (c)    1994        Microsoft Corporation

   Module Name:

        ftpconf.cxx

   Abstract:

        This module contains functions for FTP Server configuration
         class (FTP_SERVER_CONFIG).

   Author:

        Murali R. Krishnan    (MuraliK)    21-March-1995

   Project:
        FTP Server DLL

   Functions Exported:

        FTP_SERVER_CONFIG::FTP_SERVER_CONFIG()
        FTP_SERVER_CONFIG::~FTP_SERVER_CONFIG()
        FTP_SERVER_CONFIG::InitFromRegistry()
        FTP_SERVER_CONFIG::GetConfigInformation()
        FTP_SERVER_CONFIG::SetConfigInformation()
        FTP_SERVER_CONFIG::AllocNewConnection()
        FTP_SERVER_CONFIG::RemoveConnection()
        FTP_SERVER_CONFIG::DisconnectAllConnections()

        FTP_SERVER_CONFIG::Print()

   Revisions:

       MuraliK   26-July-1995    Added Allocation caching of client conns.

--*/

# include "ftpdp.hxx"

#include <ole2.h>
#include <imd.h>
#include <iiscnfgp.h>
#include <mb.hxx>

#include <mbstring.h>
# include <tchar.h>
#include <timer.h>

extern "C"
{
    #include "ntlsa.h"

}   // extern "C"



/************************************************************
 *  Symbolic Constants
 ************************************************************/


#define DEFAULT_ALLOW_ANONYMOUS         TRUE
#define DEFAULT_ALLOW_GUEST_ACCESS      TRUE
#define DEFAULT_ANONYMOUS_ONLY          FALSE

#define DEFAULT_READ_ACCESS_MASK        0
#define DEFAULT_WRITE_ACCESS_MASK       0
#define DEFAULT_MSDOS_DIR_OUTPUT        TRUE

#define DEFAULT_USE_SUBAUTH             TRUE
#define DEFAULT_LOGON_METHOD            LOGON32_LOGON_INTERACTIVE
#define DEFAULT_ANONYMOUS_PWD           ""

const TCHAR DEFAULT_EXIT_MESSAGE[] = TEXT("Goodbye.");
# define CCH_DEFAULT_EXIT_MESSAGE         (lstrlen( DEFAULT_EXIT_MESSAGE) + 1)

const TCHAR DEFAULT_MAX_CLIENTS_MSG[] =
   TEXT("Maximum clients reached, service unavailable.");

# define CCH_DEFAULT_MAX_CLIENTS_MSG  (lstrlen( DEFAULT_MAX_CLIENTS_MSG) + 1)

// this should be a double null terminated null terminated sequence.
const TCHAR DEFAULT_GREETING_MESSAGE[2] = { '\0', '\0' };
# define CCH_DEFAULT_GREETING_MESSAGE  ( 2)

// this should be a double null terminated null terminated sequence.
const TCHAR DEFAULT_BANNER_MESSAGE[2] = { '\0', '\0' };
# define CCH_DEFAULT_BANNER_MESSAGE  ( 2)


#define DEFAULT_ANNOTATE_DIRS           FALSE
#define DEFAULT_LOWERCASE_FILES         FALSE
#define DEFAULT_LISTEN_BACKLOG          1       /* reduce listen backlog */

#define DEFAULT_ENABLE_LICENSING        FALSE
#define DEFAULT_DEFAULT_LOGON_DOMAIN    NULL    // NULL == use primary domain

#define DEFAULT_ENABLE_PORT_ATTACK      FALSE
#define DEFAULT_ENABLE_PASV_THEFT       FALSE
#define DEFAULT_ALLOW_REPLACE_ON_RENAME FALSE
#define DEFAULT_SHOW_4_DIGIT_YEAR       FALSE

#define DEFAULT_USER_ISOLATION          NoIsolation
#define DEFAULT_LOG_IN_UTF_8            FALSE

# define SC_NOTIFY_INTERVAL      3000    // milliseconds
# define CLEANUP_POLL_INTERVAL   2000    // milliseconds
# define CLEANUP_RETRY_COUNT     12      // iterations

//
//  Private Prototypes
//



APIERR
GetDefaultDomainName(
    CHAR  * pszDomainName,
    DWORD   cchDomainName
    );

BOOL
FtpdReadRegString(
    IN HKEY     hkey,
    OUT TCHAR * * ppchstr,
    IN LPCTSTR  pchValue,
    IN LPCTSTR  pchDefault,
    IN DWORD    cchDefault
    );

BOOL
GenMessageWithLineFeed(IN LPSTR pszzMessage,
                       IN LPSTR * ppszMessageWithLineFeed);


#if DBG

static CHAR * p_AccessTypes[] = { "read",
                                  "write",
                                  "create",
                                  "delete" };

#endif  // DBG


/************************************************************
 *    Member Functions of FTP_SERVER_INSTANCE
 ************************************************************/

FTP_SERVER_INSTANCE::FTP_SERVER_INSTANCE(
        IN PFTP_IIS_SERVICE pService,
        IN DWORD  dwInstanceId,
        IN USHORT sPort,
        IN LPCSTR lpszRegParamKey,
        IN LPWSTR lpwszAnonPasswordSecretName,
        IN LPWSTR lpwszRootPasswordSecretName,
        IN BOOL   fMigrateVroots
        )
/*++

  Description:

    Constructor Function for Ftp server Configuration object
     ( Initializes all members to be NULL)

    The valid flag may be initialized to TRUE only after reading values
      from registry.

--*/
        : IIS_SERVER_INSTANCE(
            pService,
            dwInstanceId,
            sPort,
            lpszRegParamKey,
            lpwszAnonPasswordSecretName,
            lpwszRootPasswordSecretName,
            fMigrateVroots
        ),
    m_cCurrentConnections    ( 0),
    m_cMaxCurrentConnections ( 0),
    m_fValid                 ( FALSE),
    m_fAllowAnonymous        ( TRUE),
    m_fAnonymousOnly         ( FALSE),
    m_fAllowGuestAccess      ( TRUE),
    m_fAnnotateDirectories   ( FALSE),
    m_fLowercaseFiles        ( FALSE),
    m_fMsdosDirOutput        ( FALSE),
    m_fFourDigitYear         ( FALSE),
    m_fEnableLicensing       ( FALSE),
    m_fEnablePortAttack      ( FALSE),
    m_fEnablePasvTheft       ( FALSE),
    m_pszGreetingMessageWithLineFeed( NULL),
    m_pszBannerMessageWithLineFeed( NULL),
    m_pszLocalHostName       ( NULL),
    m_dwUserFlags            ( 0),
    m_ListenBacklog          ( DEFAULT_LISTEN_BACKLOG),
    m_pFTPStats              ( NULL),
    m_UserIsolationMode      ( DEFAULT_USER_ISOLATION),
    m_fLogInUtf8             ( DEFAULT_LOG_IN_UTF_8)
{

   InitializeListHead( &m_ActiveConnectionsList);
   INITIALIZE_CRITICAL_SECTION( &m_csLock);
   InitializeListHead( &m_FreeConnectionsList);
   INITIALIZE_CRITICAL_SECTION( &m_csConnectionsList);

   if( QueryServerState() == MD_SERVER_STATE_INVALID ) {
       return;
   }

   m_pFTPStats = new FTP_SERVER_STATISTICS;

   if ( m_pFTPStats == NULL )
   {
       SetServerState( MD_SERVER_STATE_INVALID, ERROR_NOT_ENOUGH_MEMORY );
       SetLastError( ERROR_NOT_ENOUGH_MEMORY );
   }

   return;

} // FTP_SERVER_INSTANCE::FTP_SERVER_INSTANCE()




FTP_SERVER_INSTANCE::~FTP_SERVER_INSTANCE( VOID)
/*++
     Description:

        Destructor function for server config object.
        ( Frees all dynamically allocated storage space)
--*/
{
    HRESULT             hRes;

    //
    // delete statistics object
    //

    if( m_pFTPStats != NULL )
    {
        delete m_pFTPStats;
        m_pFTPStats = NULL;
    }

    //
    //  The strings are automatically freed by a call to destructor
    //

    if ( m_pszLocalHostName != NULL) {

        delete [] ( m_pszLocalHostName);
    }

    if ( m_pszGreetingMessageWithLineFeed != NULL) {

        TCP_FREE( m_pszGreetingMessageWithLineFeed);
         m_pszGreetingMessageWithLineFeed = NULL;
    }

    if ( m_pszBannerMessageWithLineFeed != NULL) {

        TCP_FREE( m_pszBannerMessageWithLineFeed);
         m_pszBannerMessageWithLineFeed = NULL;
    }

    m_rfAccessCheck.Reset( (IMDCOM*)m_Service->QueryMDObject() );

    DBG_ASSERT( m_cCurrentConnections == 0);
    DBG_ASSERT( IsListEmpty( &m_ActiveConnectionsList));

    LockConnectionsList();
    DBG_REQUIRE(FreeAllocCachedClientConn());
    UnlockConnectionsList();

    DBG_ASSERT( IsListEmpty( &m_FreeConnectionsList));

    //
    // Delete the critical section object
    //

    DeleteCriticalSection( &m_csLock);
    DeleteCriticalSection( &m_csConnectionsList);


} /* FTP_SERVER_INSTANCE::~FTP_SERVER_INSTANCE() */




DWORD
FTP_SERVER_INSTANCE::StartInstance()
{
    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "FTP_SERVER_INSTANCE::StartInstance called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT(m_pFTPStats);
    m_pFTPStats->UpdateStopTime();

    DWORD dwError = IIS_SERVER_INSTANCE::StartInstance();

    if ( dwError)
    {
        IF_DEBUG(INSTANCE) {
            DBGPRINTF((
                DBG_CONTEXT,
                "FTO_SERVER_INSTANCE - IIS_SERVER_INSTANCE Failed. StartInstance returned 0x%x",
                dwError
                ));
        }

        return dwError;
    }

    dwError = InitFromRegistry( FC_FTP_ALL );

    if( dwError == NO_ERROR ) {
       dwError = ReadAuthentInfo();
    }

    if (dwError == NO_ERROR)
    {
         m_pFTPStats->UpdateStartTime();
    }

    return dwError;
}



DWORD
FTP_SERVER_INSTANCE::StopInstance()
{
    DBG_ASSERT(m_pFTPStats);

    m_pFTPStats->UpdateStopTime();
    return IIS_SERVER_INSTANCE::StopInstance();
}


DWORD
FTP_SERVER_INSTANCE::SetLocalHostName(IN LPCSTR pszHost)
/*++

  This function copies the host name specified in the given string to
  configuration object.

  Arguments:
     pszHost   pointer to string containing the local host name.

  Returns:
     NO_ERROR on success and ERROR_NOT_ENOUGH_MEMORY when no memory.
     ERROR_ALREADY_ASSIGNED  if value is already present.
--*/
{
    //
    //  if already a host name exists, return error.
    //  otherwise allocate memory and copy the local host name.
    //

    if ( m_pszLocalHostName != NULL) {

        return (ERROR_ALREADY_ASSIGNED);
    } else {
        m_pszLocalHostName = new CHAR[lstrlenA(pszHost) + 1];
        if ( m_pszLocalHostName == NULL) {

            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        lstrcpyA( m_pszLocalHostName, pszHost);
    }

    return (NO_ERROR);

} // FTP_SERVER_INSTANCE::SetLocalHostName()




DWORD
FTP_SERVER_INSTANCE::InitFromRegistry(
    IN FIELD_CONTROL   FieldsToRead)
/*++
    Description:
      Initializes server configuration data from registry.
      Some values are also initialized with constants.
      If invalid registry key or load data from registry fails,
        then use default values.

    Arguments:

      hkeyReg     handle to registry key

      FieldsToRead
        bitmask indicating the fields to read from the registry.
        This is useful when we try to read the new values after
            modifying the registry information as a result of
            SetAdminInfo call from the Admin UI

    Returns:

       NO_ERROR   if there are no errors.
       Win32 error codes otherwise

    Limitations:

        No validity check is performed on the data present in registry.
--*/
{
    BOOL                fSuccess = TRUE;
    DWORD               err = NO_ERROR;
    IMDCOM*             pMBCom;
    METADATA_HANDLE     hMB;
    HRESULT             hRes;
    METADATA_RECORD     mdRecord;
    DWORD               dwRequiredLen;
    BOOL                fMustRel;
    HKEY                hkeyReg = NULL;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );
    DWORD tmp;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        QueryRegParamKey(),
                        0,
                        KEY_ALL_ACCESS,
                        &hkeyReg );


    if ( hkeyReg == INVALID_HANDLE_VALUE ||
         hkeyReg == NULL) {

       //
       // Invalid Registry handle given
       //

       SetLastError( ERROR_INVALID_PARAMETER);
       return ( FALSE);
    }

    LockConfig();

    //
    //  Read metabase data.
    //

    if( !mb.Open( QueryMDPath() ) ) {

        RegCloseKey( hkeyReg );
        UnLockConfig();
        return FALSE;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_EXIT_MESSAGE ) ) {

        if( !mb.GetStr( "",
                        MD_EXIT_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_ExitMessage,
                        METADATA_INHERIT,
                        DEFAULT_EXIT_MESSAGE ) ) {

            fSuccess = FALSE;
            err = GetLastError();

        }

    }

    if( fSuccess && IsFieldSet( FieldsToRead, FC_FTP_GREETING_MESSAGE ) ) {

        if( !mb.GetMultisz( "",
                        MD_GREETING_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_GreetingMessage ) ) {

            if( !m_GreetingMessage.Copy(
                    DEFAULT_GREETING_MESSAGE,
                    CCH_DEFAULT_GREETING_MESSAGE
                    ) )  {

                fSuccess = FALSE;
                err = GetLastError();

            }

        }

        //
        // The m_pszGreetingMessage as read is a double null terminated
        // seq of strings (with one string per line)
        // A local copy of the string in the form suited for RPC Admin
        //   should be generated.
        //

        if( fSuccess ) {

            fSuccess = GenMessageWithLineFeed( m_GreetingMessage.QueryStr(),
                                               &m_pszGreetingMessageWithLineFeed);

            if( !fSuccess ) {
                err = GetLastError();
            }

        }

    }

    if( fSuccess && IsFieldSet( FieldsToRead, FC_FTP_BANNER_MESSAGE ) ) {

        if( !mb.GetMultisz( "",
                        MD_BANNER_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_BannerMessage ) ) {

            if( !m_BannerMessage.Copy(
                    DEFAULT_BANNER_MESSAGE,
                    CCH_DEFAULT_BANNER_MESSAGE
                    ) )  {

                fSuccess = FALSE;
                err = GetLastError();

            }

        }

        //
        // The m_pszBannerMessage as read is a double null terminated
        // seq of strings (with one string per line)
        // A local copy of the string in the form suited for RPC Admin
        //   should be generated.
        //

        if( fSuccess ) {

            fSuccess = GenMessageWithLineFeed( m_BannerMessage.QueryStr(),
                                               &m_pszBannerMessageWithLineFeed);

            if( !fSuccess ) {
                err = GetLastError();
            }

        }

    }

    if( fSuccess && IsFieldSet( FieldsToRead, FC_FTP_MAX_CLIENTS_MESSAGE ) ) {

        if( !mb.GetStr( "",
                        MD_MAX_CLIENTS_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_MaxClientsMessage,
                        METADATA_INHERIT,
                        DEFAULT_MAX_CLIENTS_MSG ) ) {

            fSuccess = FALSE;
            err = GetLastError();

        }

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_MSDOS_DIR_OUTPUT ) ) {

        if( !mb.GetDword( "",
                          MD_MSDOS_DIR_OUTPUT,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_MSDOS_DIR_OUTPUT;

        }

        m_fMsdosDirOutput = !!tmp;
        // clear and then set the MSDOS_DIR_OUTPUT in user flags
        m_dwUserFlags &= ~UF_MSDOS_DIR_OUTPUT;
        m_dwUserFlags |= (m_fMsdosDirOutput) ? UF_MSDOS_DIR_OUTPUT : 0;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_SHOW_4_DIGIT_YEAR) ) {

        if( !mb.GetDword( "",
                          MD_SHOW_4_DIGIT_YEAR,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_SHOW_4_DIGIT_YEAR;

        }

        m_fFourDigitYear = !!tmp;
        // clear and then set the 4_DIGIT_YEAR in user flags
        m_dwUserFlags &= ~UF_4_DIGIT_YEAR;
        m_dwUserFlags |= (m_fFourDigitYear) ? UF_4_DIGIT_YEAR : 0;
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ALLOW_ANONYMOUS ) ) {

        if( !mb.GetDword( "",
                          MD_ALLOW_ANONYMOUS,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_ALLOW_ANONYMOUS;

        }

        m_fAllowAnonymous = !!tmp;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ANONYMOUS_ONLY ) ) {

        if( !mb.GetDword( "",
                          MD_ANONYMOUS_ONLY,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_ANONYMOUS_ONLY;

        }

        m_fAnonymousOnly = !!tmp;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ALLOW_REPLACE_ON_RENAME ) ) {

        if( !mb.GetDword( "",
                          MD_ALLOW_REPLACE_ON_RENAME,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_ALLOW_REPLACE_ON_RENAME;

        }

        m_fAllowReplaceOnRename = !!tmp;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_USER_ISOLATION ) ) {

        if( !mb.GetDword( "",
                          MD_USER_ISOLATION,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_USER_ISOLATION;
        }

        m_UserIsolationMode = (ISOLATION_MODE)tmp;

        if (m_UserIsolationMode >= IsolationModeOverflow) {

           m_UserIsolationMode = DEFAULT_USER_ISOLATION;
        }
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_LOG_IN_UTF_8 ) ) {

        if( !mb.GetDword( "",
                          MD_FTP_LOG_IN_UTF_8,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_LOG_IN_UTF_8;
        }

        m_fLogInUtf8 = !!tmp;

    }

    //
    //  Read registry data.
    //

    if( IsFieldSet( FieldsToRead, FC_FTP_LISTEN_BACKLOG ) )
    {
        m_ListenBacklog = ReadRegistryDword( hkeyReg,
                                            FTPD_LISTEN_BACKLOG,
                                            DEFAULT_LISTEN_BACKLOG );
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ALLOW_GUEST_ACCESS ) ) {

        m_fAllowGuestAccess = !!ReadRegistryDword( hkeyReg,
                                                  FTPD_ALLOW_GUEST_ACCESS,
                                                  DEFAULT_ALLOW_GUEST_ACCESS );
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ANNOTATE_DIRECTORIES ) ) {

        m_fAnnotateDirectories = !!ReadRegistryDword( hkeyReg,
                                                     FTPD_ANNOTATE_DIRS,
                                                     DEFAULT_ANNOTATE_DIRS );

        // clear and then set the ANNOTATE_DIRS in user flags
        m_dwUserFlags &= ~UF_ANNOTATE_DIRS;
        m_dwUserFlags |= (m_fAnnotateDirectories) ? UF_ANNOTATE_DIRS : 0;
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_LOWERCASE_FILES ) ) {

        m_fLowercaseFiles = !!ReadRegistryDword( hkeyReg,
                                                FTPD_LOWERCASE_FILES,
                                                DEFAULT_LOWERCASE_FILES );
    }

    // fEnablePortAttack is not controlled by RPC yet.
    m_fEnablePortAttack = !!ReadRegistryDword(hkeyReg,
                                              FTPD_ENABLE_PORT_ATTACK,
                                              DEFAULT_ENABLE_PORT_ATTACK);

    // fEnablePasvTheft is not controlled by RPC yet.
    m_fEnablePasvTheft = !!ReadRegistryDword(hkeyReg,
                                              FTPD_ENABLE_PASV_THEFT,
                                              DEFAULT_ENABLE_PASV_THEFT);

    if( fSuccess ) {

        //
        //  The following field is not supported in the admin API.
        //

        m_fEnableLicensing = !!ReadRegistryDword( hkeyReg,
                                                 FTPD_ENABLE_LICENSING,
                                                 DEFAULT_ENABLE_LICENSING );

    }

    if ( fSuccess )
    {
        m_rfAccessCheck.Reset( (IMDCOM*)m_Service->QueryMDObject() );

        pMBCom = (IMDCOM*)m_Service->QueryMDObject();
        hRes = pMBCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                            (BYTE *) QueryMDVRPath(),
                                            METADATA_PERMISSION_READ,
                                            5000,
                                            &hMB );
        if ( SUCCEEDED( hRes ) )
        {
            mdRecord.dwMDIdentifier  = MD_IP_SEC;
            mdRecord.dwMDAttributes  = METADATA_INHERIT | METADATA_REFERENCE;
            mdRecord.dwMDUserType    = IIS_MD_UT_FILE;
            mdRecord.dwMDDataType    = BINARY_METADATA;
            mdRecord.dwMDDataLen     = 0;
            mdRecord.pbMDData        = (PBYTE)NULL;

            hRes = pMBCom->ComMDGetMetaData( hMB,
                                             (LPBYTE)"",
                                             &mdRecord,
                                             &dwRequiredLen );
            if ( SUCCEEDED( hRes ) && mdRecord.dwMDDataTag )
            {
                m_rfAccessCheck.Set( mdRecord.pbMDData,
                                     mdRecord.dwMDDataLen,
                                     mdRecord.dwMDDataTag );
            }

            DBG_REQUIRE( SUCCEEDED(pMBCom->ComMDCloseMetaObject( hMB )) );
        }
        else
        if( HRESULTTOWIN32( hRes ) != ERROR_PATH_NOT_FOUND )
        {
            fSuccess = FALSE;
            err = HRESULTTOWIN32( hRes );
        }
    }

    UnLockConfig();

    IF_DEBUG( CONFIG) {
       Print();
    }

    m_fValid = TRUE;

    RegCloseKey( hkeyReg );
    return ( err);

} // FTP_SERVER_INSTANCE::InitFromRegistry()





static BOOL
RemoveInvalidsInPath( IN OUT TCHAR * pszPath)
/*++
  Eliminate path components consisting of '.' and '..'
     to prevent security from being overridden

    Arguments:

        pszPath pointer to string containing path

    Returns:
        TRUE on success and
        FALSE if there is any failure
--*/
{
    int idest;
    TCHAR * pszScan;

    //
    //  Check and eliminate the invalid path components
    //

    for( pszScan = pszPath; *pszScan != TEXT( '\0'); pszScan++) {

       if ( *pszScan == TEXT( '/')) {

          //
          // Check and kill invalid path components before next "\"
          //
          if ( *(pszScan + 1) == TEXT( '.')) {

            if ( *(pszScan +2) == TEXT('/')) {

               pszScan += 2;      // skip the /./ pattern

            } else
            if ( *(pszScan +2) == TEXT('.') &&
                 *(pszScan +3) == TEXT('/')) {

                //
                // We found the pattern  /../, elimiate it
                //
                pszScan += 3;
            }

            *pszPath++ = *pszScan;
            continue;

          } // found a single /.

       }

       *pszPath++ = *pszScan;

    } // for

    *pszPath = TEXT( '\0');

    return ( TRUE);

} // RemoveInvalidsInPath()





VOID
FTP_SERVER_INSTANCE::Print( VOID) const
/*++

    Description:

       Prints the configuration information for this server.
       To be used in debugging mode for verification.


    Returns:

       None.

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
               "FTP Server Configuration ( %08x).\n", this ));
#if 0
    READ_LOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    AnonymousUser = %s\n",
               g_pInetSvc->QueryAnonUserName() ));

    UNLOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n"
               "    %s = %d\n"
               "    %s = %u\n"
               "    %s = %u\n"
               "    %s = %u\n"
               "    %s = %u\n"
               "    %s = %u\n",
               FTPD_ALLOW_ANONYMOUS,
               m_fAllowAnonymous,
               FTPD_ALLOW_GUEST_ACCESS,
               m_fAllowGuestAccess,
               FTPD_ANONYMOUS_ONLY,
               m_fAnonymousOnly,
               FTPD_ENABLE_PORT_ATTACK,
               m_fEnablePortAttack,
               FTPD_ENABLE_PASV_THEFT,
               m_fEnablePasvTheft,
               "LogAnonymous",
               g_pInetSvc->QueryLogAnonymous(),
               "LogNonAnonymous",
               g_pInetSvc->QueryLogNonAnonymous()
               ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_ENABLE_LICENSING,
               m_fEnableLicensing  ));

    DBGPRINTF(( DBG_CONTEXT,
               "    MaxConnections = %lu\n",
               g_pInetSvc->QueryMaxConnections() ));

    DBGPRINTF(( DBG_CONTEXT,
               "    ConnectionTimeout = %lu\n",
               g_pInetSvc->QueryConnectionTimeout() ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_MSDOS_DIR_OUTPUT,
               m_fMsdosDirOutput ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_4_DIGIT_YEAR,
               m_f4DigitYear ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_ANNOTATE_DIRS,
               m_fAnnotateDirectories  ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %08lX\n",
               FTPD_DEBUG_FLAGS,
               GET_DEBUG_FLAGS()));

    READ_LOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    LogFileDirectory = %s\n",
               g_pInetSvc->QueryLogFileDirectory() ));

    UNLOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    LogFileAccess = %lu\n",
               g_pInetSvc->QueryLogFileType() ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %u\n",
               FTPD_LISTEN_BACKLOG,
               m_ListenBacklog ));

    DBGPRINTF(( DBG_CONTEXT,
               "    DefaultLogonDomain = %s\n",
               m_DefaultLogonDomain ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %u\n",
               FTPD_USER_ISOLATION,
               m_UserIsolation ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %u\n",
               FTPD_LOG_IN_UTF_8,
               m_fLogInUtf8 ));
#endif
    return;

} // FTP_SERVER_INSTANCE::Print()




PICLIENT_CONNECTION
FTP_SERVER_INSTANCE::AllocNewConnection()
/*++

  This function first checks that there is room for more connections
  as per the configured max connections.

  If there is no more connections allowed, it returns NULL
    with *pfMaxExceeded = TRUE

  Otherwise:
  This function creates a new CLIENT_CONNECTION (USER_DATA) object.
       The creation maybe fresh from heap or from cached free list.

  It increments the counter of currnet connections and returns
   the allocated object (if non NULL).


  We enter a critical section to avoid race condition
    among different threads. (this can be improved NYI).

  Returns:
      TRUE on success and
      FALSE if there is max Connections exceeded.
--*/
{
    PICLIENT_CONNECTION pConn = NULL;

    LockConnectionsList();

    //
    // We can add this new connection
    //

    pConn = AllocClientConnFromAllocCache();

    if ( pConn != NULL) {

        //
        //  Increment the count of connected users
        //
        m_cCurrentConnections++;

        IF_DEBUG( CLIENT) {
            DBGPRINTF((DBG_CONTEXT, " CurrentConnections = %u\n",
                   m_cCurrentConnections));
        }

        //
        // Update the current maximum connections
        //

        if ( m_cCurrentConnections > m_cMaxCurrentConnections) {

            m_cMaxCurrentConnections = m_cCurrentConnections;
        }

        //
        // Insert into the list of connected users.
        //

        InsertTailList( &m_ActiveConnectionsList, &pConn->QueryListEntry());
    }

   UnlockConnectionsList();

   return ( pConn);

} // FTP_SERVER_INSTANCE::AllocNewConnection()



VOID
FTP_SERVER_INSTANCE::RemoveConnection(
            IN OUT PICLIENT_CONNECTION  pcc
            )
/*++

--*/
{

    LockConnectionsList();

    //
    // Remove from list of connections
    //
    RemoveEntryList( &pcc->QueryListEntry());

    //
    // Decrement count of current users
    //
    m_cCurrentConnections--;

    IF_DEBUG( CLIENT) {
        DBGPRINTF((DBG_CONTEXT, " CurrentConnections = %u\n",
                   m_cCurrentConnections));
    }

    //
    // move the free connection to free list
    //

    FreeClientConnToAllocCache( pcc);

    UnlockConnectionsList();

} // FTP_SERVER_INSTANCE::RemoveConnection()





VOID
FTP_SERVER_INSTANCE::DisconnectAllConnections( VOID)
/*++

   Disconnects all user connections.

   Arguments:

     Instance - If NULL, then all users are disconnected. If !NULL, then
         only those users associated with the specified instance are
         disconnected.

--*/
{
#ifdef CHECK_DBG
    CHAR rgchBuffer[90];
#endif // CHECK_DBG

    DWORD        dwLastTick = GetTickCount();
    DWORD        dwCurrentTick;
    PLIST_ENTRY  pEntry;
    PLIST_ENTRY  pEntryNext;

    DBGPRINTF( ( DBG_CONTEXT,
                "Entering  FTP_SERVER_INSTANCE::DisconnectAllConnections()\n"));


    //
    // Let's empty the connection list immediately while in the lock to avoid a
    // shutdown deadlock
    //

    LockConnectionsList();

    pEntry = m_ActiveConnectionsList.Flink;

    InitializeListHead( &m_ActiveConnectionsList);

    UnlockConnectionsList();

    //
    //  close down all the active sockets.
    //
    for( pEntryNext = pEntry->Flink;
         pEntry != &m_ActiveConnectionsList;
         pEntry = pEntryNext) {

        PICLIENT_CONNECTION  pConn =
          GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        pEntryNext = pEntry->Flink; // cache next entry since pConn may die

        ASSERT( pConn != NULL);

# ifdef CHECK_DBG
        wsprintfA( rgchBuffer, "Kill UID=%u. Ref=%u\n",
                  pConn->QueryId(), pConn->QueryReference());

        OutputDebugString( rgchBuffer);
# endif // CHECK_DBG

        dwCurrentTick = GetTickCount();

        if ( (dwCurrentTick - dwLastTick) >= ( SC_NOTIFY_INTERVAL)) {

            //
            // We seem to take longer time for cleaning up than
            //  expected. Let us ask service controller to wait for us.
            //

            g_pInetSvc->
              DelayCurrentServiceCtrlOperation(SC_NOTIFY_INTERVAL * 2);

            dwLastTick = dwCurrentTick;
        }

        pConn->Reference();
        pConn->DisconnectUserWithError( ERROR_SERVER_DISABLED, TRUE);
        DBG_REQUIRE( pConn->DeReference() > 0 );   // remove ref added above
        if( pConn->RemoveActiveReference() ) {

            //
            // This connection is due for deletion. Kill it.
            //
            // Remove from list of connections
            //

            pConn->Cleanup();
            RemoveEntryList( &pConn->QueryListEntry());

            //
            // Decrement count of current users
            //
            m_cCurrentConnections--;

            // move the connection to free list
            FreeClientConnToAllocCache( pConn);
        }
    } // for

    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    //

    //
    //  Wait for the users to die.
    //

    for( int i = 0 ;
        ( i < CLEANUP_RETRY_COUNT ) && ( m_cCurrentConnections > 0);
        i++ )
    {

        DBGPRINTF(( DBG_CONTEXT, "Sleep Iteration %d; Time=%u millisecs."
                   " CurrentConn=%d.\n",
                   i,  CLEANUP_POLL_INTERVAL, m_cCurrentConnections));

        g_pInetSvc->
          DelayCurrentServiceCtrlOperation( CLEANUP_POLL_INTERVAL * 2);
        Sleep( CLEANUP_POLL_INTERVAL );
    }

    return;

} // FTP_SERVER_INSTANCE::DisconnectAllConnections()



BOOL
FTP_SERVER_INSTANCE::EnumerateConnection(
   IN PFN_CLIENT_CONNECTION_ENUM  pfnConnEnum,
   IN LPVOID  pContext,
   IN DWORD   dwConnectionId)
/*++
  This function iterates through all the connections in the current connected
   users list and enumerates each of them. If the connectionId matches then
   given callback function is called. If the ConnectionId is 0, then the
   callback is called for each and every connection active currently.

  During such a call the reference count of the connection is bumped up.
  Call this function after obtaining the ConnectionsList Lock.

  Arguments:
     pfnConnEnum      pointer to function to be called when a match is found.
     pContext         pointer to context information to be passed in
                       for callback
     dwConnectionId   DWORD containing the Connection Id. IF 0 match all the
                        connections.

  Returns:
    FALSE if no match is found
    TRUE if atleast one match is found.
--*/
{
    BOOL fReturn = FALSE;
    BOOL fFoundOne  = FALSE;
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pEntryNext;

    DBG_ASSERT( pfnConnEnum != NULL);

    //
    //  Loop through the list of connections and call the callback
    //  for each connection  that matches condition
    //

    for ( pEntry  = m_ActiveConnectionsList.Flink,
              pEntryNext = &m_ActiveConnectionsList;
          pEntry != &m_ActiveConnectionsList;
          pEntry  = pEntryNext
         ) {

        PICLIENT_CONNECTION pConn =
          GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        pEntryNext = pEntry->Flink; // cache next entry since pConn may die

        if ( dwConnectionId == 0 || dwConnectionId == pConn->QueryId()) {

            pConn->Reference();

            fReturn = ( pfnConnEnum)( pConn, pContext);

            if ( !pConn->DeReference()) {

                // Blowaway the connection and update the count of entries.
                //
                // Remove from list of connections
                //

                pConn->Cleanup();
                RemoveEntryList( &pConn->QueryListEntry());

                //
                // Decrement count of current users
                //
                m_cCurrentConnections--;

                IF_DEBUG( CLIENT) {
                    DBGPRINTF((DBG_CONTEXT, " CurrentConnections = %u\n",
                               m_cCurrentConnections));
                }
            }

            if (!fReturn) {

                break;
            }

            fFoundOne = TRUE;
        }
    } // for

    //
    //  If we didn't find any, assume that there was no match.
    //

    if ( !fFoundOne ) {

        SetLastError( ERROR_NO_MORE_ITEMS );
        fReturn = FALSE;
    }

    return ( fReturn);
} // FTP_SERVER_INSTANCE::EnumerateConnection()




DWORD
FTP_SERVER_INSTANCE::GetConfigInformation(OUT LPFTP_CONFIG_INFO pConfig)
/*++
  This function copies the ftp server configuration into the given
   structure (pointed to).

  Arguments:
    pConfig -- pointer to FTP_CONFIG_INFO which on success will contain
                 the ftp server configuration

  Returns:
    Win32 error code. NO_ERROR on success.
--*/
{
    DWORD dwError = NO_ERROR;

    memset( pConfig, 0, sizeof(*pConfig) );

    pConfig->FieldControl = FC_FTP_ALL;

    LockConfig();

    pConfig->fAllowAnonymous            = m_fAllowAnonymous;
    pConfig->fAllowGuestAccess          = m_fAllowGuestAccess;
    pConfig->fAnnotateDirectories       = m_fAnnotateDirectories;
    pConfig->fAnonymousOnly             = m_fAnonymousOnly;
    pConfig->dwListenBacklog            = m_ListenBacklog;
    pConfig->fLowercaseFiles            = m_fLowercaseFiles;
    pConfig->fMsdosDirOutput            = m_fMsdosDirOutput;
    pConfig->dwUserIsolationMode        = m_UserIsolationMode;
    pConfig->fLogInUtf8                 = m_fLogInUtf8;

    if( !ConvertStringToRpc( &pConfig->lpszExitMessage,
                             QueryExitMsg() ) ||
        !ConvertStringToRpc( &pConfig->lpszGreetingMessage,
                             m_pszGreetingMessageWithLineFeed ) ||
        !ConvertStringToRpc( &pConfig->lpszBannerMessage,
                             m_pszBannerMessageWithLineFeed ) ||
        !ConvertStringToRpc( &pConfig->lpszMaxClientsMessage,
                             QueryMaxClientsMsg() ) )
    {
        dwError = GetLastError();
    }

    UnLockConfig();

    if ( dwError == NO_ERROR) {

        pConfig->lpszHomeDirectory  = NULL;  // use query virtual roots.
    }

    if ( dwError != NO_ERROR) {

        FreeRpcString( pConfig->lpszExitMessage );
        FreeRpcString( pConfig->lpszGreetingMessage );
        FreeRpcString( pConfig->lpszBannerMessage );
        FreeRpcString( pConfig->lpszHomeDirectory );
        FreeRpcString( pConfig->lpszMaxClientsMessage );
    }

    return (dwError);

} // FTP_SERVER_INSTANCE::GetConfigurationInformation()





// Private Functions ...


BOOL
FTP_SERVER_INSTANCE::FreeAllocCachedClientConn( VOID)
/*++
  This function frees all the alloc cached client connections
  It walks through the list of alloc cached entries and frees them.

  This function should be called when Server module is terminated and when
   no other thread can interfere in processing a shared object.

  Arguments:
    NONE

  Returns:
    TRUE on success and FALSE on failure.

--*/
{
    register PLIST_ENTRY  pEntry;
    register PLIST_ENTRY  pEntryNext;
    register PICLIENT_CONNECTION pConn;

    for( pEntry = m_FreeConnectionsList.Flink;
         pEntry != &m_FreeConnectionsList; ) {


        PICLIENT_CONNECTION  pConn =
          GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        pEntryNext = pEntry->Flink; // cache next entry since pConn may die

        DBG_ASSERT( pConn->QueryReference() == 0);

        RemoveEntryList( pEntry );        // Remove this context from list

        // delete the object itself
        delete pConn;

        pEntry = pEntryNext;

    } // for

    return (TRUE);

} // USER_DATA::FreeAllocCachedClientConn()



PICLIENT_CONNECTION
FTP_SERVER_INSTANCE::AllocClientConnFromAllocCache(
                        VOID
                        )
/*++
  This function attempts to allocate a client connection object from
  the allocation cache, using the free list of connections available.

  If none is available, then a new object is allocated using new ()
   and returned to the caller.
  Eventually the object will enter free list and will be available
   for free use.

  Arguments:
     None

  Returns:
    On success a valid pointer to client connection object.

  Issues:
     This function should be called while holding the ConnectionsLock.
--*/
{
    PLIST_ENTRY pEntry  = m_FreeConnectionsList.Flink;
    PICLIENT_CONNECTION pConn;

    if ( pEntry != &m_FreeConnectionsList) {

        pConn = GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        DBG_ASSERT( pConn != NULL);
        RemoveEntryList( pEntry);  // remove entry from free list

        DBG_ASSERT( pConn->QueryInstance() == NULL );
        pConn->SetInstance( this );

    } else {

        //
        // create a new object, since allocation cache is empty
        //

        pConn = new USER_DATA( this );
    }

    return (pConn);

} // FTP_SERVER_INSTANCE::AllocClientConnFromAllocCache()



VOID
FTP_SERVER_INSTANCE::FreeClientConnToAllocCache(
                        IN PICLIENT_CONNECTION pClient
                        )
/*++
  This function releases the given Client connection to the allocation cache.
  It adds the given object to allocation cache.

  Arguments:
    pClient  pointer to client connection object which needs to be freed.

  Returns:
    None

  Issues:
    This function should be called after holding the ConnectionsList
     critical section.

    Should we limit the number of items that can be on free list and
      to release the remaining to global pool?  NYI (depends on # CPUs)
--*/
{
    PLIST_ENTRY pEntry = &pClient->QueryListEntry();

    //
    // empty out instance pointer
    //

    pClient->QueryInstance()->DecrementCurrentConnections();
    pClient->QueryInstance()->Dereference( );
    pClient->SetInstance( NULL );

    InsertHeadList( &m_FreeConnectionsList, pEntry);
    return;

} // FTP_SERVER_INSTANCE::FreeClientConnToAllocCache()





/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.

********************************************************************/

APIERR
GetDefaultDomainName(
    STR * pstrDomainName
    )
{

    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    APIERR                      err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "cannot open lsa policy, error %08lX\n",
                    NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Query the domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&DomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "cannot query lsa policy info, error %08lX\n",
                    NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Compute the required length of the ANSI name.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // dwFlags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  NULL,                 // lpMultiByteStr
                                  0,                    // cchMultiByte
                                  NULL,                 // lpDefaultChar
                                  NULL                  // lpUsedDefaultChar
                                  );

    if( Result <= 0 )
    {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Resize the output string as appropriate, including room for the
    //  terminating '\0'.
    //

    if( !pstrDomainName->Resize( (UINT)Result + 1 ) )
    {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Convert the name from UNICODE to ANSI.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // flags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  pstrDomainName->QueryStr(),
                                  pstrDomainName->QuerySize() - 1,  // for '\0'
                                  NULL,
                                  NULL
                                  );

    if( Result <= 0 )
    {
        err = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
                    "cannot convert domain name to ANSI, error %d\n",
                    err ));

        goto Cleanup;
    }

    //
    //  Ensure the ANSI string is zero terminated.
    //

    DBG_ASSERT( (DWORD)Result < pstrDomainName->QuerySize() );

    pstrDomainName->QueryStr()[Result] = '\0';

    //
    //  Success!
    //

    DBG_ASSERT( err == 0 );

    IF_DEBUG( CONFIG )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetDefaultDomainName: default domain = %s\n",
                    pstrDomainName->QueryStr() ));
    }

Cleanup:

    if( DomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)DomainInfo );
    }

    if( LsaPolicyHandle != NULL )
    {
        LsaClose( LsaPolicyHandle );
    }

    return err;

}   // GetDefaultDomainName()



BOOL
GenMessageWithLineFeed(IN LPTSTR pszzMessage,
                       IN LPTSTR * ppszMessageWithLineFeed)
{
    DWORD   cchLen = 0;
    DWORD   cchLen2;
    DWORD   nLines = 0;
    LPCTSTR  pszNext = pszzMessage;
    LPTSTR   pszDst = NULL;

    DBG_ASSERT( ppszMessageWithLineFeed != NULL);

    //
    // 1. Find the length of the the complete message
    //

    for ( cchLen = _tcslen( pszzMessage), nLines = 0;
          *(pszzMessage + cchLen + 1) != TEXT('\0');
          cchLen +=  1+_tcslen( pszzMessage + cchLen + 1), nLines++
         )
      ;

    //
    // 2. Allocate sufficient space to hold the data
    //

    if ( *ppszMessageWithLineFeed != NULL) {

        TCP_FREE( *ppszMessageWithLineFeed);
    }


    *ppszMessageWithLineFeed = (TCHAR *) TCP_ALLOC((cchLen + nLines + 3)
                                         * sizeof(TCHAR));


    if ( *ppszMessageWithLineFeed == NULL) {


        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (FALSE);
    }

    //
    // 3.
    // Copy the message from double null terminated string to the
    //  new string, taking care to replace the nulls with \n for linefeed
    //

    pszDst = * ppszMessageWithLineFeed;
    _tcscpy( pszDst, pszzMessage);
    cchLen2 = _tcslen( pszzMessage) + 1;
    *(pszDst+cchLen2 - 1) = TEXT('\n');  // replacing the '\0' with '\n'

    for( pszNext = pszzMessage + cchLen2;
         *pszNext != '\0';
        pszNext = pszzMessage + cchLen2
        ) {

        _tcscpy( pszDst + cchLen2, pszNext);
        cchLen2 += _tcslen(pszNext) + 1;
        *(pszDst + cchLen2 - 1) = TCHAR('\n'); // replacing the '\0' with '\n'

    } // for

    //
    // Reset the last line feed.
    //
    *(pszDst + cchLen2 - 1) = TCHAR('\0');

    // if following assertion is not true, we are writing into heap!!!
    if ( cchLen + nLines + 3 <= cchLen2) {

        return ( FALSE);
    }

    DBG_ASSERT( cchLen + nLines + 3 >= cchLen2);

    return ( TRUE);
} // GenMessageWithLineFeed()




TCHAR *
FtpdReadRegistryString(IN HKEY     hkey,
                       IN LPCTSTR  pszValueName,
                       IN LPCTSTR  pchDefaultValue,
                       IN DWORD    cbDefaultValue)
/*++
  This function reads a string (REG_SZ/REG_MULTI_SZ/REG_EXPAND_SZ) without
   expanding the same. It allocates memory for reading the data from registry.

  Arguments:
    hkey    handle for the registry key.
    pszValueName   pointer to string containing the name of value to be read.
    pchDefaultValue pointer to default value to be used for reading the string
                   this may be double null terminated sequence of string for
                    REG_MULTI_SZ strings
    cchDefaultValue  count of characters in default value string,
                     including double null characters.

  Return:
    pointer to newly allocated string containing the data read from registry
      or the default string.

--*/
{
    TCHAR   * pszBuffer1 = NULL;
    DWORD     err;


    if( hkey == NULL ) {

        //
        //  Pretend the key wasn't found.
        //

        err = ERROR_FILE_NOT_FOUND;

    } else {

        DWORD     cbBuffer = 0;
        DWORD     dwType;

        //
        //  Determine the buffer size.
        //

        err = RegQueryValueEx( hkey,
                              pszValueName,
                              NULL,
                              &dwType,
                              NULL,
                              &cbBuffer );

        if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) ) {

            if(( dwType != REG_SZ ) &&
               ( dwType != REG_MULTI_SZ ) &&
               ( dwType != REG_EXPAND_SZ )
               ) {

                //
                //  Type mismatch, registry data NOT a string.
                //  Use default.
                //

                err = ERROR_FILE_NOT_FOUND;

            } else {

                //
                //  Item found, allocate a buffer.
                //

                pszBuffer1 = (TCHAR *) TCP_ALLOC( cbBuffer+sizeof(TCHAR) );

                if( pszBuffer1 == NULL ) {

                    err = GetLastError();
                } else {

                    //
                    //  Now read the value into the buffer.
                    //

                    err = RegQueryValueEx( hkey,
                                           pszValueName,
                                           NULL,
                                           NULL,
                                           (LPBYTE)pszBuffer1,
                                           &cbBuffer );
                }
            }
        }
    }

    if( err == ERROR_FILE_NOT_FOUND ) {

        //
        //  Item not found, use default value.
        //

        err = NO_ERROR;

        if( pchDefaultValue != NULL ) {

            if ( pszBuffer1 != NULL) {

                TCP_FREE( pszBuffer1);
            }

            pszBuffer1 = (TCHAR *)TCP_ALLOC((cbDefaultValue) *
                                            sizeof(TCHAR));

            if( pszBuffer1 == NULL ) {

                err = GetLastError();
            } else {

                memcpy(pszBuffer1, pchDefaultValue,
                       cbDefaultValue*sizeof(TCHAR) );
            }
        }
    }

    if( err != NO_ERROR ) {

        //
        //  Something tragic happend; free any allocated buffers
        //  and return NULL to the caller, indicating failure.
        //

        if( pszBuffer1 != NULL ) {

            TCP_FREE( pszBuffer1 );
            pszBuffer1 = NULL;
          }

        SetLastError( err);
    }


    return pszBuffer1;

} // FtpdReadRegistryString()




BOOL
FtpdReadRegString(
    IN HKEY     hkey,
    OUT TCHAR * * ppchstr,
    IN LPCTSTR  pchValue,
    IN LPCTSTR  pchDefault,
    IN DWORD    cchDefault
    )
/*++

   Description

     Gets the specified string from the registry.  If *ppchstr is not NULL,
     then the value is freed.  If the registry call fails, *ppchstr is
     restored to its previous value.

   Arguments:

      hkey - Handle to open key
      ppchstr - Receives pointer of allocated memory of the new value of the
        string
      pchValue - Which registry value to retrieve
      pchDefault - Default string if value isn't found
      cchDefault - count of characters in default value

   Note:

--*/
{
    CHAR * pch = *ppchstr;

    *ppchstr = FtpdReadRegistryString(hkey,
                                      pchValue,
                                      pchDefault,
                                      cchDefault);

    if ( !*ppchstr )
    {
        *ppchstr = pch;
        return FALSE;
    }

    if ( pch ) {

        //
        // use TCP_FREE since FtpdReadRegistryString() uses TCP_ALLOC
        //  to allocate the chunk of memory
        //

        TCP_FREE( pch );
    }

    return TRUE;

} // FtpdReadRegString()


BOOL
FTP_IIS_SERVICE::AddInstanceInfo(
    IN DWORD dwInstance,
    IN BOOL fMigrateRoots
    )
{
    PFTP_SERVER_INSTANCE pInstance;
    CHAR                 szHost[MAXGETHOSTSTRUCT];

    IF_DEBUG(SERVICE_CTRL) {
        DBGPRINTF(( DBG_CONTEXT,
            "AddInstanceInfo: instance %d reg %s\n", dwInstance, QueryRegParamKey() ));
    }

    // Guard against startup race where another thread might be adding
    // instances before the MSFTPSVC thread is finished with initializing
    // the g_pInetSvc pointer.

    if ( g_pInetSvc == NULL )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    //
    // Get the current host name.
    //

    if( gethostname( szHost, sizeof(szHost) ) < 0 ) {

        return FALSE;

    }

    //
    // Create the new instance
    //

    pInstance = new FTP_SERVER_INSTANCE(
                                this,
                                dwInstance,
                                IPPORT_FTP,
                                QueryRegParamKey(),
                                FTPD_ANONYMOUS_SECRET_W,
                                FTPD_ROOT_SECRET_W,
                                fMigrateRoots
                                );

    if (pInstance == NULL) {
        SetLastError( E_OUTOFMEMORY );
        return FALSE;
    }

    if( !AddInstanceInfoHelper( pInstance ) ) {
        return FALSE;
    }

    if( pInstance->SetLocalHostName( szHost ) != NO_ERROR ) {
        RemoveServerInstance( pInstance );
        return FALSE;
    }

    return TRUE;

}   // FTP_IIS_SERVICE::AddInstanceInfo

DWORD
FTP_IIS_SERVICE::DisconnectUsersByInstance(
    IN IIS_SERVER_INSTANCE * pInstance
    )
/*++

    Virtual callback invoked by IIS_SERVER_INSTANCE::StopInstance() to
    disconnect all users associated with the given instance.

    Arguments:

        pInstance - All users associated with this instance will be
            forcibly disconnected.

--*/
{

    ((FTP_SERVER_INSTANCE *)pInstance)->DisconnectAllConnections();
    return NO_ERROR;

}   // FTP_IIS_SERVICE::DisconnectUsersByInstance

VOID
FTP_SERVER_INSTANCE::MDChangeNotify(
    MD_CHANGE_OBJECT * pco
    )
/*++

    Handles metabase change notifications.

    Arguments:

        pco - Path and ID that changed.

--*/
{

    FIELD_CONTROL control = 0;
    DWORD i;
    DWORD err;
    DWORD id;
    PCSTR pszURL;
    DWORD dwURLLength;

    //
    // Let the parent deal with it.
    //

    IIS_SERVER_INSTANCE::MDChangeNotify( pco );

    //
    // Now flush the metacache and relevant file handle cache entries.
    //

    TsFlushMetaCache(METACACHE_FTP_SERVER_ID, FALSE);

    if ( !_mbsnbicmp((PUCHAR)pco->pszMDPath, (PUCHAR)QueryMDVRPath(),
                     _mbslen( (PUCHAR)QueryMDVRPath() )) )
    {
        pszURL = (CHAR *)pco->pszMDPath + QueryMDVRPathLen() - 1;

        //
        // Figure out the length of the URL. Unless this is the root,
        // we want to strip the trailing slash.

        if (memcmp(pszURL, "/", sizeof("/")) != 0)
        {
            dwURLLength = strlen(pszURL) - 1;
        }
        else
        {
            dwURLLength = sizeof("/") - 1;
        }

    }
    else
    {
        //
        // Presumably this is for a change above the root URL level, i.e. a
        // change of a property at the service level. Since this affects
        // everything, flush starting at the root.
        //

        pszURL = "/";
        dwURLLength = sizeof("/") - 1;
    }

    DBG_ASSERT(pszURL != NULL);
    DBG_ASSERT(*pszURL != '\0');

    TsFlushURL(GetTsvcCache(), pszURL, dwURLLength, RESERVED_DEMUX_URI_INFO);

    //
    // Interpret the changes.
    //

    for( i = 0 ; i < pco->dwMDNumDataIDs ; i++ ) {

        id = pco->pdwMDDataIDs[i];

        switch( id ) {

        case MD_EXIT_MESSAGE :
            control |= FC_FTP_EXIT_MESSAGE;
            break;

        case MD_GREETING_MESSAGE :
            control |= FC_FTP_GREETING_MESSAGE;
            break;

        case MD_BANNER_MESSAGE :
            control |= FC_FTP_BANNER_MESSAGE;
            break;

        case MD_MAX_CLIENTS_MESSAGE :
            control |= FC_FTP_MAX_CLIENTS_MESSAGE;
            break;

        case MD_MSDOS_DIR_OUTPUT :
            control |= FC_FTP_MSDOS_DIR_OUTPUT;
            break;

        case MD_ALLOW_ANONYMOUS :
            control |= FC_FTP_ALLOW_ANONYMOUS;
            break;

        case MD_ANONYMOUS_ONLY :
            control |= FC_FTP_ANONYMOUS_ONLY;
            break;

        case MD_ALLOW_REPLACE_ON_RENAME :
            control |= FC_FTP_ALLOW_REPLACE_ON_RENAME;
            break;

        case MD_SHOW_4_DIGIT_YEAR :
            control |= FC_FTP_SHOW_4_DIGIT_YEAR;
            break;

        case MD_USER_ISOLATION :
            control |= FC_FTP_USER_ISOLATION;
            break;

        case MD_FTP_LOG_IN_UTF_8 :
            control |= FC_FTP_LOG_IN_UTF_8;
            break;

        case MD_ANONYMOUS_USER_NAME :
        case MD_ANONYMOUS_PWD :
        case MD_ANONYMOUS_USE_SUBAUTH :
        case MD_DEFAULT_LOGON_DOMAIN :
        case MD_LOGON_METHOD :
            err = ReadAuthentInfo( FALSE, id );

            if( err != NO_ERROR ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "FTP_SERVER_INSTANCE::MDChangeNotify() cannot read authentication info, error %d\n",
                    err
                    ));

            }
            break;

        }

    }

    if( control != 0 ) {

        err = InitFromRegistry( control );

        if( err != NO_ERROR ) {

            DBGPRINTF((
                DBG_CONTEXT,
                "FTP_SERVER_INSTANCE::MDChangeNotify() cannot read config, error %lx\n",
                err
                ));

        }

    }

}   // FTP_SERVER_INSTANCE::MDChangeNotify


DWORD
FTP_SERVER_INSTANCE::ReadAuthentInfo(
    IN BOOL ReadAll,
    IN DWORD SingleItemToRead
    )
/*++

    Reads per-instance authentication info from the metabase.

    Arguments:

        ReadAll - If TRUE, then all authentication related items are
            read from the metabase. If FALSE, then only a single item
            is read.

        SingleItemToRead - The single authentication item to read if
            ReadAll is FALSE. Ignored if ReadAll is TRUE.

    Returns:

        DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD tmp;
    DWORD err = NO_ERROR;
    BOOL rebuildAcctDesc = FALSE;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    //
    // Lock our configuration (since we'll presumably be making changes)
    // and open the metabase.
    //

    LockConfig();

    if( !mb.Open( QueryMDPath() ) ) {

        err = GetLastError();

        DBGPRINTF((
            DBG_CONTEXT,
            "ReadAuthentInfo: cannot open metabase, error %lx\n",
            err
            ));

    }

    //
    // Read the anonymous username if necessary. Note this is a REQUIRED
    // property. If it is missing from the metabase, bail.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_USER_NAME ) ) {

        if( mb.GetStr(
                "",
                MD_ANONYMOUS_USER_NAME,
                IIS_MD_UT_SERVER,
                &m_TcpAuthentInfo.strAnonUserName
                ) ) {

            rebuildAcctDesc = TRUE;

        } else {

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: cannot read MD_ANONYMOUS_USER_NAME, error %lx\n",
                err
                ));

        }

    }

    //
    // Read the "use subauthenticator" flag if necessary. This is an
    // optional property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_USE_SUBAUTH ) ) {

        if( !mb.GetDword(
                "",
                MD_ANONYMOUS_USE_SUBAUTH,
                IIS_MD_UT_SERVER,
                &tmp
                ) ) {

            tmp = DEFAULT_USE_SUBAUTH;

        }

        m_TcpAuthentInfo.fDontUseAnonSubAuth = !tmp;

    }

    //
    // Read the anonymous password if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_PWD ) ) {

        if( mb.GetStr(
                "",
                MD_ANONYMOUS_PWD,
                IIS_MD_UT_SERVER,
                &m_TcpAuthentInfo.strAnonUserPassword,
                METADATA_INHERIT,
                DEFAULT_ANONYMOUS_PWD
                ) ) {

            rebuildAcctDesc = TRUE;

        } else {

            //
            // Since we provided a default value to mb.GetStr(), it should
            // only fail if something catastrophic occurred, such as an
            // out of memory condition.
            //

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: cannot read MD_ANONYMOUS_PWD, error %lx\n",
                err
                ));

        }

    }

    //
    // Read the default logon domain if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_DEFAULT_LOGON_DOMAIN ) ) {

        if( !mb.GetStr(
                "",
                MD_DEFAULT_LOGON_DOMAIN,
                IIS_MD_UT_SERVER,
                &m_TcpAuthentInfo.strDefaultLogonDomain
                ) ) {

            //
            // Generate a default domain name.
            //

            err = GetDefaultDomainName( &m_TcpAuthentInfo.strDefaultLogonDomain );

            if( err != NO_ERROR ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "ReadAuthentInfo: cannot get default domain name, error %d\n",
                    err
                    ));

            }

        }

    }

    //
    // Read the logon method if necessary. This is an optional property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_LOGON_METHOD ) ) {

        if( !mb.GetDword(
                "",
                MD_LOGON_METHOD,
                IIS_MD_UT_SERVER,
                &tmp
                ) ) {

            tmp = DEFAULT_LOGON_METHOD;

        }

        m_TcpAuthentInfo.dwLogonMethod = tmp;

    }

    //
    // If anything changed that could affect the anonymous account
    // descriptor, then rebuild the descriptor.
    //

    if( err == NO_ERROR && rebuildAcctDesc ) {

        if( !BuildAnonymousAcctDesc( &m_TcpAuthentInfo ) ) {

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: BuildAnonymousAcctDesc() failed\n"
                ));

            err = ERROR_NOT_ENOUGH_MEMORY;  // SWAG

        }

    }

    UnLockConfig();
    return err;

}   // FTP_SERVER_INSTANCE::ReadAuthentInfo


BOOL
FTP_IIS_SERVICE::GetGlobalStatistics(
    IN DWORD dwLevel,
    OUT PCHAR *pBuffer
    )
{
    APIERR err = NO_ERROR;


    switch( dwLevel ) {
        case 0 : {

            LPFTP_STATISTICS_0 pstats0;

            pstats0 = (LPFTP_STATISTICS_0)
                       MIDL_user_allocate(sizeof(FTP_STATISTICS_0));

            if( pstats0 == NULL ) {

                err = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                ATQ_STATISTICS      atqStat;

                ZeroMemory( pstats0, sizeof( FTP_STATISTICS_0 ) );

                g_pFTPStats->CopyToStatsBuffer( pstats0 );

                *pBuffer = (PCHAR)pstats0;
            }

        }

        break;

     default :
        err = ERROR_INVALID_LEVEL;
        break;
    }



    SetLastError(err);
    return(err == NO_ERROR);
}   // FTP_IIS_SERVICE::GetGlobalStatistics



BOOL
FTP_IIS_SERVICE::AggregateStatistics(
        IN PCHAR    pDestination,
        IN PCHAR    pSource
        )
{
    LPFTP_STATISTICS_0   pStatDest = (LPFTP_STATISTICS_0) pDestination;
    LPFTP_STATISTICS_0   pStatSrc  = (LPFTP_STATISTICS_0) pSource;

    if ((NULL == pDestination) || (NULL == pSource))
    {
        return FALSE;
    }

    pStatDest->TotalBytesSent.QuadPart      += pStatSrc->TotalBytesSent.QuadPart;
    pStatDest->TotalBytesReceived.QuadPart  += pStatSrc->TotalBytesReceived.QuadPart;

    pStatDest->TotalFilesSent               += pStatSrc->TotalFilesSent;
    pStatDest->TotalFilesReceived           += pStatSrc->TotalFilesReceived;
    pStatDest->CurrentAnonymousUsers        += pStatSrc->CurrentAnonymousUsers;
    pStatDest->CurrentNonAnonymousUsers     += pStatSrc->CurrentNonAnonymousUsers;
    pStatDest->TotalAnonymousUsers          += pStatSrc->TotalAnonymousUsers;
    pStatDest->MaxAnonymousUsers            += pStatSrc->MaxAnonymousUsers;
    pStatDest->MaxNonAnonymousUsers         += pStatSrc->MaxNonAnonymousUsers;

    pStatDest->CurrentConnections           += pStatSrc->CurrentConnections;
    pStatDest->MaxConnections               += pStatSrc->MaxConnections;
    pStatDest->ConnectionAttempts           += pStatSrc->ConnectionAttempts;
    pStatDest->LogonAttempts                += pStatSrc->LogonAttempts;
    pStatDest->ServiceUptime                = pStatSrc->ServiceUptime;


    // bandwidth throttling info. Not relevant for FTP

    /*
    pStatDest->CurrentBlockedRequests       += pStatSrc->CurrentBlockedRequests;
    pStatDest->TotalBlockedRequests         += pStatSrc->TotalBlockedRequests;
    pStatDest->TotalAllowedRequests         += pStatSrc->TotalAllowedRequests;
    pStatDest->TotalRejectedRequests        += pStatSrc->TotalRejectedRequests;
    pStatDest->MeasuredBandwidth            += pStatSrc->MeasuredBandwidth;
    */

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\globals.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    globals.cxx

    This module contains global variable definitions shared by the
    various FTPD Service components.

    Functions exported by this module:

        InitializeGlobals
        TerminateGlobals
        ReadParamsFromRegistry
        WriteParamsToRegistry


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     11-April-1995 Created new global ftp server config object

*/


#include "ftpdp.hxx"
#include "acptctxt.hxx"

#include <timer.h>


//
//  Private constants.
//

#ifdef _NO_TRACING_
#define DEFAULT_DEBUG_FLAGS             0
#else
#define DEFAULT_TRACE_FLAGS             0
#endif

#define DEFAULT_NO_EXTENDED_FILENAME    0



//
//  Socket transfer buffer size.
//

DWORD                   g_SocketBufferSize;

//
//  Statistics.
//

//
//  FTP Statistics structure.
//

LPFTP_SERVER_STATISTICS g_pFTPStats;

//
//  Miscellaneous data.
//

//
//  The FTP Server sign-on string.
//

LPSTR                   g_FtpServiceNameString;

//
//  key for the registry to read parameters
//
HKEY        g_hkeyParams = NULL;


//
// List holding all the PASV accept context entries
//
LIST_ENTRY g_AcceptContextList;

//
//  The number of threads currently blocked in Synchronous sockets
//  calls, like recv()
//

DWORD       g_ThreadsBlockedInSyncCalls = 0;

//
//  The maximum number of threads that will be allowed to block in
//  Synchronous sockets calls. Magic # that will be changed if the max # of
//  pool threads is less than 100.
//

DWORD       g_MaxThreadsBlockedInSyncCalls = 100;

//
//  The global variable lock.
//

CRITICAL_SECTION        g_GlobalLock;

#ifdef KEEP_COMMAND_STATS

//
//  Lock protecting per-command statistics.
//

CRITICAL_SECTION        g_CommandStatisticsLock;

#endif  // KEEP_COMMAND_STATS


//
//  By default, extended characters are allowed for file/directory names
//  in the data transfer commands. Reg key can disable this.
//

DWORD       g_fNoExtendedChars = FALSE;

#if DBG

//
//  Debug-specific data.
//

//
//  Debug output control flags.
//

#endif  // DBG


//
//  Public functions.
//

/*******************************************************************

    NAME:       InitializeGlobals

    SYNOPSIS:   Initializes global shared variables.  Some values are
                initialized with constants, others are read from the
                configuration registry.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

                Also, this routine is called before the event logging
                routines have been initialized.  Therefore, event
                logging is not available.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     05-April-1995 Added FTP server config object

********************************************************************/
APIERR
InitializeGlobals(
    VOID
    )
{
    APIERR      err = NO_ERROR;
    DWORD       dwDebugFlags;
    ACCEPT_CONTEXT_ENTRY *pAcceptEntry = NULL;
    UINT_PTR dwMaxThreads = 0;

    //
    //  Setup the service sign-on string.
    //

    g_FtpServiceNameString = "Microsoft FTP Service\0";  // must be double \0 terminated


    //
    // Set up PASV accept event variables
    //
    InitializeListHead( &g_AcceptContextList );

    if ( err = CreateInitialAcceptContext() )
    {
        return err;
    }

    //
    //  Create global locks.
    //

    INITIALIZE_CRITICAL_SECTION( &g_GlobalLock );

#ifdef KEEP_COMMAND_STATS

    INITIALIZE_CRITICAL_SECTION( &g_CommandStatisticsLock );

#endif  // KEEP_COMMAND_STATS


    //
    // Create an FTP server object and load values from registry.
    //

    //
    //  Connect to the registry.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        FTPD_PARAMETERS_KEY,
                        0,
                        KEY_ALL_ACCESS,
                        &g_hkeyParams );

    if( err != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "cannot open registry key %s, error %lu\n",
                   FTPD_PARAMETERS_KEY,
                    err ));

        //
        // Load Default values
        //
        err = NO_ERROR;
    }

    //
    // Figure out how many pool threads we can create maximally - if less than built-in
    // number, adjust accordingly
    //

    dwMaxThreads = AtqGetInfo( AtqMaxThreadLimit );

    if ( dwMaxThreads/2 < (UINT_PTR)g_MaxThreadsBlockedInSyncCalls )
    {
        g_MaxThreadsBlockedInSyncCalls = (DWORD)(dwMaxThreads/2);
    }

    DBGPRINTF((DBG_CONTEXT,
               "Max # of threads allowed to be blocked in sync calls : %d\n",
               g_MaxThreadsBlockedInSyncCalls));

# ifdef _NO_TRACING_
# if DBG

    dwDebugFlags  = ReadRegistryDword( g_hkeyParams,
                                      FTPD_DEBUG_FLAGS,
                                      DEFAULT_DEBUG_FLAGS );
    SET_DEBUG_FLAGS( dwDebugFlags);

# endif // DBG
# endif

    g_fNoExtendedChars = ReadRegistryDword( g_hkeyParams,
                                      FTPD_NO_EXTENDED_FILENAME,
                                      DEFAULT_NO_EXTENDED_FILENAME );

    g_pFTPStats = new FTP_SERVER_STATISTICS;
    if ( g_pFTPStats == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return ( err);

}   // InitializeGlobals()







/*******************************************************************

    NAME:       TerminateGlobals

    SYNOPSIS:   Terminate global shared variables.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

                Also, this routine is called after the event logging
                routines have been terminated.  Therefore, event
                logging is not available.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID
TerminateGlobals(
    VOID
    )
{

    if ( g_hkeyParams != NULL) {

        RegCloseKey( g_hkeyParams);
        g_hkeyParams = NULL;
    }


    DeleteAcceptContexts();

    DeleteCriticalSection( &g_GlobalLock );

#ifdef KEEP_COMMAND_STATS

    DeleteCriticalSection( &g_CommandStatisticsLock );

#endif  // KEEP_COMMAND_STATS

}   // TerminateGlobals


/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for the FTPD Service.

    Functions exported by this module:

        ServiceEntry


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        KeithMo     07-Jan-1994 Made it a DLL (part of TCPSVCS.EXE).
        MuraliK     21-March-1995 Modified it to use InternetServices
                                        common dll ( tcpsvcs.dll)
        MuraliK     11-April-1995 Added global ftp server config objects etc.
                       ( removed usage of Init and Terminate UserDatabase)

*/


#include <ftpdp.hxx>
#include <apiutil.h>
#include <inetsvcs.h>

//
//  Private constants.
//

#define FTPD_MODULE_NAME_A          "ftpsvc2.dll"
#define DEFAULT_RECV_BUFFER_SIZE    (8192)

//
// Global variables for service info and debug variables.
//

DEFINE_TSVC_INFO_INTERFACE( );
DECLARE_DEBUG_PRINTS_OBJECT();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisFtpGuid, 
0x784d891F, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif

//
// The following critical section synchronizes execution in ServiceEntry().
// This is necessary because the NT Service Controller may reissue a service
// start notification immediately after we have set our status to stopped.
// This can lead to an unpleasant race condition in ServiceEntry() as one
// thread cleans up global state as another thread is initializing it.
//

CRITICAL_SECTION g_csServiceEntryLock;

//
//  Private prototypes.
//

APIERR
InitializeService(
    LPVOID lpContext
    );

APIERR
TerminateService(
    LPVOID lpContext
    );

extern
VOID
FtpdNewConnection(
    IN SOCKET sNew,
    IN SOCKADDR_IN * psockaddr,
    IN PVOID EndpointContext,
    IN PVOID EndpointObject
    );


extern
VOID
FtpdNewConnectionEx(
    IN PVOID        patqContext,
    IN DWORD        cbWritten,
    IN DWORD        dwError,
    IN OVERLAPPED * lpo
    );


DWORD
PrintOutCurrentTime(
            IN CHAR * pszFile,
            IN int lineNum
            );

# ifdef CHECK_DBG
# define PRINT_CURRENT_TIME_TO_DBG()  PrintOutCurrentTime( __FILE__, __LINE__)
# else
# define PRINT_CURRENT_TIME_TO_DBG()  ( NO_ERROR)
# endif // CHECK_DBG



VOID
ServiceEntry(
    DWORD                   cArgs,
    LPSTR                   pArgs[],
    PTCPSVCS_GLOBAL_DATA    pGlobalData     // unused
    )
/*++

    Routine:
        This is the "real" entrypoint for the service.  When
                the Service Controller dispatcher is requested to
                start a service, it creates a thread that will begin
                executing this routine.

    Arguments:
        cArgs - Number of command line arguments to this service.

        pArgs - Pointers to the command line arguments.

    Returns:
        None.  Does not return until service is stopped.

--*/
{
    APIERR err = NO_ERROR;
    BOOL fInitSvcObject = FALSE;

    EnterCriticalSection( &g_csServiceEntryLock );

    if ( !InitCommonDlls() )
    {
        err = GetLastError();
        LeaveCriticalSection( &g_csServiceEntryLock );
        goto notify_scm;
    }

    //
    //  Initialize the service status structure.
    //

    g_pInetSvc = new FTP_IIS_SERVICE(
                            FTPD_SERVICE_NAME,
                            FTPD_MODULE_NAME_A,
                            FTPD_PARAMETERS_KEY_A,
                            INET_FTP_SVC_ID,
                            INET_FTP_SVCLOC_ID,
                            FALSE,
                            0,
                            FtpdNewConnection,
                            FtpdNewConnectionEx,
                            ProcessAtqCompletion
                            );

    //
    //  If we couldn't allocate memory for the service info structure,
    //  then we're totally hozed.
    //

    if( (g_pInetSvc != NULL) && g_pInetSvc->IsActive() ) {
        fInitSvcObject = TRUE;

        //
        //  Start the service. This blocks until the service is shutdown.
        //

        err = g_pInetSvc->StartServiceOperation(
                                    SERVICE_CTRL_HANDLER(),
                                    InitializeService,
                                    TerminateService
                                    );

        if( err != NO_ERROR) {

            //
            //  The event has already been logged.
            //

            DBGPRINTF(( DBG_CONTEXT,
                       "FTP ServiceEntry: StartServiceOperation returned %d\n",
                       err ));
        }

    } else {

        if ( g_pInetSvc ) {
            err = g_pInetSvc->QueryCurrentServiceError();
        } else {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
        

    if( g_pInetSvc != NULL ) {

        //
        // delete the service object
        //

        g_pInetSvc->CloseService( );
        g_pInetSvc = NULL;
    }

    TerminateCommonDlls();
    LeaveCriticalSection( &g_csServiceEntryLock );    

notify_scm:
    //
    // We need to tell the Service Control Manager that the service
    // is stopped if we haven't called g_pInetSvc->StartServiceOperation.
    //  1) InitCommonDlls fails, or
    //  2) new operator failed, or
    //  3) FTP_IIS_SERVICE constructor couldn't initialize properly
    //

    if ( !fInitSvcObject ) {
        SERVICE_STATUS_HANDLE hsvcStatus;
        SERVICE_STATUS svcStatus;

        hsvcStatus = RegisterServiceCtrlHandler( FTPD_SERVICE_NAME,
                                                 SERVICE_CTRL_HANDLER() );


        if ( hsvcStatus != NULL_SERVICE_STATUS_HANDLE ) {
            svcStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
            svcStatus.dwCurrentState = SERVICE_STOPPED;
            svcStatus.dwWin32ExitCode = err;
            svcStatus.dwServiceSpecificExitCode = err;
            svcStatus.dwControlsAccepted = 0;
            svcStatus.dwCheckPoint = 0;
            svcStatus.dwWaitHint = 0;

            SetServiceStatus( hsvcStatus, (LPSERVICE_STATUS) &svcStatus );
        }
    }
    
} // ServiceEntry()




//
//  Private functions.
//

DWORD
InitializeInstances(
    PFTP_IIS_SERVICE pService
    )
/*++

Routine Description:

    Read the instances from the registry

Arguments:

    pService - Server instance added to.

Return Value:

    Win32

--*/
{
    DWORD                err = NO_ERROR;
    DWORD                i;
    DWORD                cInstances = 0;
    MB                   mb( (IMDCOM*) pService->QueryMDObject() );
    BUFFER               buff;
    CHAR                 szKeyName[MAX_PATH+1];
    BOOL                 fMigrateRoots = FALSE;

    //
    //  Open the metabase for write to get an atomic snapshot
    //

    if ( !mb.Open( "/LM/MSFTPSVC/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "InitializeInstances: Cannot open path %s, error %lu\n",
                    "/LM/MSFTPSVC/", GetLastError() ));

#if 1 // Temporary until setup is modified to create the instances in the metabase
        if ( !mb.Open( METADATA_MASTER_ROOT_HANDLE,
               METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ||
             !mb.AddObject( "/LM/MSFTPSVC/" ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create service, error %d\n",
                        GetLastError() ));

            return GetLastError();
        }
#else
        return GetLastError();
#endif
    }

TryAgain:
    i = 0;
    while ( mb.EnumObjects( "",
                            szKeyName,
                            i++ ))
    {
        BOOL fRet;
        DWORD dwInstance;
        CHAR szRegKey[MAX_PATH+1];

        //
        // Get the instance id
        //

        dwInstance = atoi( szKeyName );
        if ( dwInstance == 0 ) {
            continue;
        }

        if ( buff.QuerySize() < (cInstances + 1) * sizeof(DWORD) )
        {
            if ( !buff.Resize( (cInstances + 10) * sizeof(DWORD)) )
            {
                return GetLastError();
            }
        }

        ((DWORD *) buff.QueryPtr())[cInstances++] = dwInstance;
    }

    if ( cInstances == 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "No defined instances\n" ));

        if ( !mb.AddObject( "1" ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create first instance, error %d\n",
                        GetLastError() ));

            return GetLastError();
        }

        fMigrateRoots = TRUE; // Force reg->metabase migration of virtual directories
        goto TryAgain;
    }

    DBG_REQUIRE( mb.Close() );

    for ( i = 0; i < cInstances; i++ )
    {
        DWORD dwInstance = ((DWORD *)buff.QueryPtr())[i];

        if( !g_pInetSvc->AddInstanceInfo( dwInstance, fMigrateRoots ) ) {

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "InitializeInstances: cannot create instance %lu, error %lu\n",
                dwInstance,
                err
                ));

            break;

        }

    }

    return err;

}   // InitializeInstances


APIERR
InitializeService(
    LPVOID lpContext
    )
/*++

    Routine:
        This function initializes the various FTPD Service components.

    Arguments:
        lpContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    APIERR err = NO_ERROR;
    PFTP_IIS_SERVICE  pInetSvc = (PFTP_IIS_SERVICE)lpContext;
    PFTP_SERVER_INSTANCE pServer;

    DBG_ASSERT( lpContext == g_pInetSvc);

    IF_DEBUG( SERVICE_CTRL ) {
        DBGPRINTF(( DBG_CONTEXT,"Initializing ftp service\n" ));
    }

    //
    //  Initialize various components.  The ordering of the
    //  components is somewhat limited.
    //  We should initialize connections as the last item,
    //   since it kicks off the connection thread.
    //

    err = PRINT_CURRENT_TIME_TO_DBG();

    if(( err = InitializeGlobals() )          != NO_ERROR ||
       ( err = PRINT_CURRENT_TIME_TO_DBG())   != NO_ERROR ||
       ( err = pInetSvc->InitializeSockets()) != NO_ERROR ||
       ( err = PRINT_CURRENT_TIME_TO_DBG())   != NO_ERROR ||
       ( err = pInetSvc->InitializeDiscovery( )) != NO_ERROR ||
       ( err = PRINT_CURRENT_TIME_TO_DBG())   != NO_ERROR ) {

       DBGPRINTF(( DBG_CONTEXT,
                     "cannot initialize ftp service, error %lu\n",err ));

        goto exit;

    } else {

          //
          //  Success!
          //

          DBG_ASSERT( err == NO_ERROR);

          //
          // From discusssions with KeithMo, we decided to punt on the
          //   default buffer size for now. Later on if performance is
          //   critical, we will try to improve on this by proper values
          //   for listen socket.
          //

          g_SocketBufferSize = DEFAULT_RECV_BUFFER_SIZE;

          IF_DEBUG( SERVICE_CTRL )  {

              DBGPRINTF(( DBG_CONTEXT, " %s service initialized\n",
                         pInetSvc->QueryServiceName())
                        );
          }
    }

    //
    // Initialize all instances
    //
    InitializeInstances(pInetSvc);


    g_pFTPStats->UpdateStartTime();

exit:

    PRINT_CURRENT_TIME_TO_DBG();

    return ( err);

} // InitializeService()





APIERR
TerminateService(
    LPVOID lpContext
    )
/*++

    Routine:
        This function cleans up the various FTPD Service components.

    Arguments:
        lpContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    APIERR err = NO_ERROR;
    PFTP_IIS_SERVICE pInetSvc = (PFTP_IIS_SERVICE)lpContext;

    DBG_ASSERT( lpContext == g_pInetSvc);


    IF_DEBUG( SERVICE_CTRL ) {
        DBGPRINTF(( DBG_CONTEXT, "terminating service\n" ));
    }

    PRINT_CURRENT_TIME_TO_DBG();

    g_pFTPStats->UpdateStopTime();

    //
    //  Components should be terminated in reverse
    //  initialization order.
    //

    g_pInetSvc->ShutdownService( );

    PRINT_CURRENT_TIME_TO_DBG();
    IF_DEBUG( SERVICE_CTRL ) {
        DBGPRINTF(( DBG_CONTEXT, "Ftp service terminated\n" ));
    }

    PRINT_CURRENT_TIME_TO_DBG();
    err = pInetSvc->TerminateDiscovery();

    if ( err != NO_ERROR) {
        DBGPRINTF( ( DBG_CONTEXT,
                    "CleanupService( %s):"
                    " TerminateDiscovery failed, err=%lu\n",
                    pInetSvc->QueryServiceName(),
                    err));
    }

    PRINT_CURRENT_TIME_TO_DBG();
    pInetSvc->CleanupSockets();

    PRINT_CURRENT_TIME_TO_DBG();

    TsCacheFlush( INET_FTP_SVC_ID );
    TsFlushMetaCache(METACACHE_FTP_SERVER_ID, TRUE);
    TerminateGlobals();

    return ( err);

} // TerminateService()



# ifdef CHECK_DBG
DWORD PrintOutCurrentTime(IN CHAR * pszFile, IN int lineNum)
/*++
  This function generates the current time and prints it out to debugger
   for tracing out the path traversed, if need be.

  Arguments:
      pszFile    pointer to string containing the name of the file
      lineNum    line number within the file where this function is called.

  Returns:
      NO_ERROR always.
--*/
{
    CHAR    szBuffer[1000];

    sprintf( szBuffer, "[%u]( %40s, %10d) TickCount = %u\n",
            GetCurrentThreadId(),
            pszFile,
            lineNum,
            GetTickCount()
            );

    OutputDebugString( szBuffer);

    return ( NO_ERROR);

} // PrintOutCurrentTime()

# endif // CHECK_DBG

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpvReserved
    )
{


    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( FTPD_SERVICE_NAME);
#else
        CREATE_DEBUG_PRINT_OBJECT( FTPD_SERVICE_NAME, IisFtpGuid);
#endif
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            return FALSE;  // Nothing can be done. Debug Print object failed!
        }

        DBG_REQUIRE( DisableThreadLibraryCalls( hDll ) );
        INITIALIZE_CRITICAL_SECTION( &g_csServiceEntryLock );
        break;

    case DLL_PROCESS_DETACH:
        DELETE_DEBUG_PRINT_OBJECT();
        DeleteCriticalSection( &g_csServiceEntryLock );
        break;

    }

    return TRUE;

}   // DLLEntry

}   // extern "C"

/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\lsaux.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :
      lsaux.cxx

   Abstract:
      This modules defines the functions supporting list processing.

   Author:

       Murali R. Krishnan    ( MuraliK )     2-May-1995

   Environment:
       User Mode -- Win32

   Project:

       FTP Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include "ftpdp.hxx"
# include "lsaux.hxx"

/************************************************************
 *    Functions
 ************************************************************/


const FILETIME *
PickFileTime(IN const WIN32_FIND_DATA * pfdInfo,
             IN const LS_OPTIONS  * pOptions)
/*++

  This function selects and returns proper FILETIME structure
   to display based on the current sort method and filesystem
   capabilities.

  Arguments:
    pfdInfo   pointer to file information for a directory entry.
    pOptions  the current ls options

  Returns:
    FILETIME   -- pointer to proper time required

  History:
    MuraliK      25-Apr-1995

   This is a costly operation too. Given that this one is called once every
     directory entry is getting formatted. Can we avoid the cost ?
    YES, if we can use the offsets in the pfdInfo to chose the time object.
    NYI
--*/
{
    const FILETIME *  pliTime;

    switch ( pOptions->SortMethod) {

      case LsSortByName:
      case LsSortByWriteTime:
        pliTime = &pfdInfo->ftLastWriteTime;
        break;

      case LsSortByCreationTime:
        pliTime = &pfdInfo->ftCreationTime;
        break;

      case LsSortByAccessTime:
        pliTime = &pfdInfo->ftLastAccessTime;
        break;

      default:
        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                       "Invalid Sort %d!\n", pOptions->SortMethod ));
        }
        DBG_ASSERT( FALSE );
        pliTime = &pfdInfo->ftLastWriteTime;
        break;

    } // switch()

    //
    //  If the selected time field is not supported on
    //  the current filesystem, default to ftLastWriteTime
    //  (all filesystems support this field).
    //

    if( NULL_FILE_TIME( *pliTime ) ) {

        pliTime = &pfdInfo->ftLastWriteTime;
    }

    return ( pliTime);
} // PickFileTime()




BOOL __cdecl
FtpFilterFileInfo(
    IN const WIN32_FIND_DATA * pfdInfo,
    IN LPVOID  pContext
    )
/*++
  This function tries to filter out the file information using
   Ftp service "ls" specific filter.

  Arguments:
    pfdInfo   pointer to file information that contains the current
               file information object for filtering.
    pContext  pointer to FTP_LS_FILTER_INFO  used for filtering.

  Returns:
    TRUE if there is a match and that this file info should not be
      eliminated.
    FALSE if this file info object can be dropped out of generated list.
--*/
{
    register FTP_LS_FILTER_INFO * pfls = (FTP_LS_FILTER_INFO *) pContext;
    DWORD dwAttribs;
    BOOL  fReturn;

    if ( pfdInfo == NULL ||
        pfdInfo->dwFileAttributes == INVALID_FILE_ATTRIBUTES) {

        return ( FALSE);
    }

    //
    // We dont need to expose hidden/system files unless necessary.
    //

    dwAttribs = pfdInfo->dwFileAttributes;

    if (pfls->fFilterHidden && IS_HIDDEN( dwAttribs) ||
        pfls->fFilterSystem && IS_SYSTEM( dwAttribs)) {

        return ( FALSE);       // unwanted files.
    }

    // Always filter away "." and ".."
    const CHAR * pszFileName = ( pfdInfo->cFileName);

    if (pfls->fFilterDotDot && pszFileName[0] == '.' ||
        strcmp( pszFileName, ".") == 0 ||
        strcmp( pszFileName, "..") == 0) {

        return ( FALSE);
    }

    DBG_ASSERT( pfls->pszExpression == NULL || *pfls->pszExpression != '\0');

    //
    // Check about the file name.
    //  If the expression is not a regular expression, use simple StringCompare
    //  else  use a regular expression comparison.
    //  Return TRUE if there is a match else return FALSE.
    //

    return ( pfls->pszExpression == NULL ||  // null-expr ==> all match.
            (( pfls->fRegExpression)
             ? IsNameInRegExpressionA(pfls->pszExpression, pszFileName,
                                      pfls->fIgnoreCase)
             : !strcmp(pszFileName, pfls->pszExpression)
             ));

} // FtpFilterFileInfo()



APIERR
GetDirectoryInfo(
    IN LPUSER_DATA pUserData,
    OUT TS_DIRECTORY_INFO   * pTsDirInfo,
    IN CHAR     *  pszSearchPath,
    IN const FTP_LS_FILTER_INFO * pfls,
    IN PFN_CMP_WIN32_FIND_DATA pfnCompare
    )
/*++
  This function creates a directory listing for given directory,
    filters out unmatched files and sorts the resulting elements
    using the sort function.

  Arguments:
    pUserData    pointer to UserData structure.
    pTsDirInfo   pointer to Directory Information object that will be
                   filled in with the directory information.

    pszSearchPath  pointer to null-terminated string containing
                     the absolute path for directory along with
                     the possible filter specification.
                     eg: d:\foo\bar

    pfls         pointer to filter information used for filtering.

    pfnCompare   pointer to function used for sorting.

  Returns:
    NO_ERROR on success and Win32 error code if there are any failure.

  History:
      MuraliK      25-Apr-1995
--*/
{
    DWORD dwError = NO_ERROR;

    DBG_ASSERT( pTsDirInfo != NULL && pszSearchPath != NULL);
    DBG_ASSERT( !pTsDirInfo->IsValid());  // no dir list yet.

    IF_DEBUG(DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "GetDirListing( dir=%s, Filter=%08x (Sz=%s), "
                   "user=%08x, cmp=%08x)\n",
                   pszSearchPath, pfls, pfls->pszExpression,
                   pUserData->QueryUserToken(), pfnCompare));
    }

    CHAR  rgDirPath[MAX_PATH+10];
    CHAR * pszDirPath;
    DWORD len = strlen( pszSearchPath);

    // check to see if the last character is a "\" in the dir path
    // if not append one to make sure GetDirectoryListing works fine.
    if ( *CharPrev( pszSearchPath, pszSearchPath + len ) != '\\') {
        DBG_ASSERT( len < sizeof(rgDirPath) - 2);
        wsprintf( rgDirPath, "%s\\", pszSearchPath);
        pszDirPath = rgDirPath;
    } else {

        pszDirPath = pszSearchPath;
    }

    if ( !pTsDirInfo->GetDirectoryListingA(pszDirPath,
                                           pUserData->QueryUserToken())
        ) {

        dwError = GetLastError();
    }


    if ( dwError == NO_ERROR) {

        //
        //  we got the directory listing.
        //  We need to apply filters to restrict the directory listing.
        //  Next we need to sort the resulting mix based on the
        //    sorting options requested by the list command.
        //

        //
        // We need to identify the appropriate filter
        //   file spec to be applied. For present use *.*
        // Filtering should not fail unless tsDirInfo is invalid.
        //

        if ( pfls != NULL) {

            DBG_REQUIRE(pTsDirInfo->FilterFiles(FtpFilterFileInfo,
                                                (LPVOID )pfls)
                        );
        }

        //
        // Sort only if sort function specified
        //

        if ( pfnCompare != NULL) {

            DBG_REQUIRE( pTsDirInfo->SortFileInfoPointers( pfnCompare));
        }
    }

    return ( dwError);
} // GetDirectoryInfo()




/**************************************************
 *   Comparison Functions
 **************************************************/


int __cdecl
CompareNamesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the two directory entries by name of the files.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);

    return ( lstrcmpi((LPCSTR )pFileInfo1->cFileName,
                      (LPCSTR )pFileInfo2->cFileName));

} // CompareNamesInFileInfo()



int __cdecl
CompareNamesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the two directory entries by name of the files.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     -1 if pvFileInfo1 > pvFileInfo2
     +1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
}   // CompareNamesRevInFileInfo()





int __cdecl
CompareWriteTimesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the write times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);


    INT nResult;

    nResult = CompareFileTime(&pFileInfo1->ftLastWriteTime,
                              &pFileInfo2->ftLastWriteTime );

    if( nResult == 0 ) {

        nResult = CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
    }

    return nResult;

}   // CompareWriteTimesInFileInfo()





int __cdecl
CompareWriteTimesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the write times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     -1 if pvFileInfo1 > pvFileInfo2
     +1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareWriteTimesInFileInfo( pvFileInfo1, pvFileInfo2);

}   // CompareWriteTimesRevInFileInfo()



int __cdecl
CompareCreationTimesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the creation times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);


    INT nResult;

    if ( NULL_FILE_TIME( pFileInfo1->ftCreationTime)) {

        nResult = CompareFileTime(&pFileInfo1->ftLastWriteTime,
                                  &pFileInfo2->ftLastWriteTime );
    } else {

        nResult = CompareFileTime(&pFileInfo1->ftCreationTime,
                                  &pFileInfo2->ftCreationTime );
    }

    if( nResult == 0 ) {

        nResult = CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
    }

    return nResult;

}   // CompareCreationTimesInFileInfo()



int __cdecl
CompareCreationTimesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the creation times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareCreationTimesInFileInfo( pvFileInfo1, pvFileInfo2 );

}   // CompareCreationTimesRevInFileInfo()



int __cdecl
CompareAccessTimesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the last access times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);


    INT nResult;

    if ( NULL_FILE_TIME( pFileInfo1->ftLastAccessTime)) {

        nResult = CompareFileTime(&pFileInfo1->ftLastWriteTime,
                                  &pFileInfo2->ftLastWriteTime );
    } else {

        nResult = CompareFileTime(&pFileInfo1->ftLastAccessTime,
                                  &pFileInfo2->ftLastAccessTime );
    }

    if( nResult == 0 ) {

        nResult = CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
    }

    return nResult;

}   // CompareAccessTimesInFileInfo()



int __cdecl
CompareAccessTimesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++

  Compares the last access times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareAccessTimesInFileInfo( pvFileInfo1, pvFileInfo2 );

}   // CompareAccessTimesRevInFileInfo()






DWORD
ComputeModeBits(
    IN HANDLE            hUserToken,
    IN const CHAR *      pszPathPart,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN DWORD           * pcLinks,
    IN BOOL              fVolumeReadable,
    IN BOOL              fVolumeWritable
    )
/*++
  This function computes the mode buts r-w-x for a specific file.

  Arguments:
    hUserToken   - The security token of the user that initiated the request.
    pszPathPart  - contains the search path for this directory.
    pfdInfo      - pointer to File information
    pcLinks      - will receive the count of symbolic links to this file.
    fVolumeReadable - TRUE if volume is readable
    fVolumeWritable - TRUE if volume is writable

  Returns:
    DWORD - A combination of FILE_MODE_R, FILE_MODE_W, and FILE_MODE_X bits.

  HISTORY:
    KeithMo     01-Jun-1993 Created.
    MuraliK     26-Apr-1995 Modified to support new pfdInfo
--*/
{
    APIERR err;
    DWORD  dwAccess;
    DWORD  dwMode = 0;

    DBG_ASSERT( hUserToken != NULL );
    DBG_ASSERT( pszPathPart != NULL );
    DBG_ASSERT( pfdInfo != NULL );
    DBG_ASSERT( pcLinks != NULL );
    DBG_ASSERT( pszPathPart[1] == ':' );
    DBG_ASSERT( pszPathPart[2] == '\\' );

    if( !( GetFsFlags( *pszPathPart ) & FS_PERSISTENT_ACLS ) )
    {
        //
        //  Short-circuit if on a non-NTFS partition.
        //

        *pcLinks = 1;
        dwAccess = FILE_ALL_ACCESS;

        err = NO_ERROR;
    }
    else
    {
        CHAR   szPath[MAX_PATH*2];
        CHAR * pszEnd;
        INT    len;

        //
        //  Determine the maximum file access allowed.
        //

        DBG_ASSERT( strlen( pszPathPart) +
                   strlen( pfdInfo->cFileName) < MAX_PATH * 2);

        len = strlen( pszPathPart );
        memcpy( szPath, pszPathPart, len );
        szPath[len] = '\0';
        pszEnd = CharPrev( szPath, szPath + len );
        if( *pszEnd != '\\' && *pszEnd != '/' ) {
            pszEnd = szPath + len;
            *pszEnd = '\\';
        }
        strcpy( pszEnd + 1, pfdInfo->cFileName );

        err = ComputeFileInfo( hUserToken,
                               szPath,
                               &dwAccess,
                               pcLinks );
    }

    if( err == NO_ERROR )
    {


        //
        //  Map various NT access to unix-like mode bits.
        //

        if( fVolumeReadable && ( dwAccess & FILE_READ_DATA ) )
        {
            dwMode |= FILE_MODE_R;
        }

        if( fVolumeReadable && ( dwAccess & FILE_EXECUTE ) )
        {
            dwMode |= FILE_MODE_X;
        }

        if( fVolumeWritable &&
            !( pfdInfo->dwFileAttributes & FILE_ATTRIBUTE_READONLY ) &&
            ( dwAccess & FILE_WRITE_DATA  ) &&
            ( dwAccess & FILE_APPEND_DATA ) )
        {
            dwMode |= FILE_MODE_W;
        }
    }

    return dwMode;

}   // ComputeModeBits()




#define DEFAULT_SECURITY_DESC_SIZE ( 2048)
#define DEFAULT_PRIV_SET_SIZE      ( 1024)


APIERR
ComputeFileInfo(
    HANDLE   hUserToken,
    CHAR   * pszFile,
    DWORD  * pdwAccessGranted,
    DWORD  * pcLinks
    )
/*++
  This function uses internal Nt security api's to determine if the
   valid access is granted.

  BEWARE: this function is extremely costly! We need to simplify the cost.
  ==>> NYI

  Arguments:
    hUserToken - handle for the user, for whom we are determining the
                    access and links
    pszFile  - full path for the file.
    pdwAccessGranted - pointer to DWORD which will receive the granted access.
    pcLinks - pointer to count of links for the file.

  Returns:
    Win32 Error code if there is any failure.
    NO_ERROR on success.
--*/
{
    NTSTATUS                    NtStatus;
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    APIERR                      err;
    SECURITY_DESCRIPTOR       * psd      = NULL;
    PRIVILEGE_SET             * pps      = NULL;
    DWORD                       cbsd;
    DWORD                       cbps;
    GENERIC_MAPPING             mapping  = { 0, 0, 0, FILE_ALL_ACCESS };
    HANDLE                      hFile    = INVALID_HANDLE_VALUE;
    BOOL                        fStatus;

    DBG_ASSERT( hUserToken != NULL );
    DBG_ASSERT( pszFile != NULL );
    DBG_ASSERT( pdwAccessGranted != NULL );
    DBG_ASSERT( pcLinks != NULL );

    //
    //  Setup.
    //

    *pdwAccessGranted = 0;
    *pcLinks          = 1;

    //
    //  Open the target file/directory.
    //

    err = OpenPathForAccess( &hFile,
                            pszFile,
                            GENERIC_READ,
                            ( FILE_SHARE_READ | FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE),
                            hUserToken
                            );

    if( err != NO_ERROR )
    {
        return err;
    }

    //
    //  Determine the number of symbolic links.
    //

    if ( GetFileInformationByHandle( hFile,
                                     &FileInfo)
        ) {

        *pcLinks = FileInfo.nNumberOfLinks;
    } else {

        //
        //  We won't let this be serious enough to abort
        //  the entire operation.
        //

        *pcLinks = 1;
    }

    //
    //  Get the file's security descriptor.
    //

    cbsd = DEFAULT_SECURITY_DESC_SIZE;
    psd  = (SECURITY_DESCRIPTOR *)TCP_ALLOC( cbsd );

    if( psd == NULL )
    {
        err = GetLastError();
        goto Cleanup;
    }

    do
    {
        err = NO_ERROR;

        //
        // Replace NtQuerySecurityObject() by GetFileSecurity()
        //

        if (!GetFileSecurity( pszFile,
                             OWNER_SECURITY_INFORMATION
                             | GROUP_SECURITY_INFORMATION
                             | DACL_SECURITY_INFORMATION,
                             psd,
                             cbsd,
                             &cbsd )
            ) {

            err = GetLastError();
        }

        if( err == ERROR_INSUFFICIENT_BUFFER )
        {
            TCP_FREE( psd );
            psd = (SECURITY_DESCRIPTOR *)TCP_ALLOC( cbsd );

            if( psd == NULL )
            {
                err = GetLastError();
                break;
            }
        }

    } while( err == ERROR_INSUFFICIENT_BUFFER );

    if( err != NO_ERROR ) {

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot get security for %s, error %lu\n",
                       pszFile,
                       err ));
        }

        goto Cleanup;
    }

    //
    //  Check access.
    //

    cbps = DEFAULT_PRIV_SET_SIZE;
    pps  = (PRIVILEGE_SET *)TCP_ALLOC( cbps );

    if( pps == NULL )
    {
        err = GetLastError();
        goto Cleanup;
    }

    do
    {
        if( AccessCheck( psd,
                         hUserToken,
                         MAXIMUM_ALLOWED,
                         &mapping,
                         pps,
                         &cbps,
                         pdwAccessGranted,
                         &fStatus ) )
        {
            err = fStatus ? NO_ERROR : GetLastError();

            if( err != NO_ERROR )
            {
                IF_DEBUG( DIR_LIST) {
                    DBGPRINTF(( DBG_CONTEXT,
                               "AccessCheck() failure. Error=%d\n", err ));
                }
                break;
            }
        }
        else
        {
            err = GetLastError();

            if( err == ERROR_INSUFFICIENT_BUFFER )
            {
                TCP_FREE( pps );
                pps = (PRIVILEGE_SET *)TCP_ALLOC( cbps );

                if( pps == NULL )
                {
                    err = GetLastError();
                    break;
                }
            }
        }

    } while( err == ERROR_INSUFFICIENT_BUFFER );

    if( err != NO_ERROR )
    {
        IF_DEBUG(DIR_LIST) {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot get check access for %s, error %lu\n",
                       pszFile,
                       err ));
        }

        goto Cleanup;
    }

Cleanup:

    if( psd != NULL )
    {
        TCP_FREE( psd );
    }

    if( pps != NULL )
    {
        TCP_FREE( pps );
    }

    if( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    }

    return err;

}   // ComputeFileInfo()





# define INVALID_FS_FLAGS        ((DWORD ) -1L)


DWORD
GetFsFlags( IN CHAR chDrive)
/*++

  This function uses GetVolumeInformation to retrieve the file system
    flags for the given drive.

  Arguments:
    chDrive   the drive letter to check for. Must be A-Z.

  Returns:
    DWORD containing the FS flags. 0 if unknown.

  History:
    MuraliK   25-Apr-1995
--*/
{
    INT      iDrive;
    DWORD    Flags = INVALID_FS_FLAGS;

    static DWORD  p_FsFlags[26] = {
        // One per DOS drive (A - Z).
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS
      };

    //
    //  Validate the parameter & map to uppercase.
    //

    chDrive = (INT)toupper( chDrive );
    DBG_ASSERT( ( chDrive >= 'A' ) && ( chDrive <= 'Z' ) );

    iDrive = (INT)( chDrive - 'A' );

    //
    //  If we've already touched this drive, use the
    //  cached value.
    //

    Flags = p_FsFlags[iDrive];

    if( Flags == INVALID_FS_FLAGS )
    {
        CHAR  szRoot[] = "d:\\";

        //
        //  Retrieve the flags.
        //

        szRoot[0] = chDrive;

        GetVolumeInformation( szRoot,       // lpRootPathName
                              NULL,         // lpVolumeNameBuffer
                              0,            // nVolumeNameSize
                              NULL,         // lpVolumeSerialNumber
                              NULL,         // lpMaximumComponentLength
                              &Flags,       // lpFileSystemFlags
                              NULL,         // lpFileSYstemNameBuffer,
                              0 );          // nFileSystemNameSize

        p_FsFlags[iDrive] = Flags;
    }

    return ( Flags == INVALID_FS_FLAGS ) ? 0 : Flags;

}   // GetFsFlags()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\makefile.inc ===
#
# Supplemental rules for generating message file.
#

$(O)\msg.h $(O)\msg.rc $(O)\msg00001.bin: msg.mc ..\..\..\inc\inetamsg.mc
    copy /a ..\..\..\inc\inetamsg.mc + /a msg.mc $(O)\tmp.mc
    mc -h .\$(O) -r .\$(O) -v $(O)\tmp.mc
    move $(O)\tmp.h $(O)\msg.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\rpcex.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        rpcex.cxx

   Abstract:

        This module defines K2 rpc support.

   Author:

        Johnson Apacible    (JohnsonA)      June-19-1996

--*/

#include "ftpdp.hxx"
#include "time.h"
#include "timer.h"

# define ASSUMED_AVERAGE_USER_NAME_LEN         ( 40)
# define CONN_LEEWAY                           ( 3)

//
//  Private functions.
//

BOOL
GenDoubleNullStringFromMultiLine( IN LPCWSTR lpsz,
                                  IN OUT LPWSTR * ppszz,
                                  IN OUT LPDWORD  pcchLen)
{
    DWORD cchLen;
    DWORD nLines;
    LPWSTR pszNext;
    LPCWSTR pszSrc;

    DBG_ASSERT( lpsz != NULL && ppszz != NULL && pcchLen != NULL);

    // Initialize
    *ppszz = NULL;
    *pcchLen = 0;

    //
    // 1. Find the length of the the complete message including new lines
    //  For each new line we may potentially need an extra blank char
    //  So allocate space = nLines + length + 2 terminating null chars.
    //

    cchLen = lstrlenW( lpsz);

    for ( pszSrc = lpsz, nLines = 0;  *pszSrc != L'\0'; pszSrc++) {

        if ( *pszSrc == L'\n')   { nLines++; }
    } // for


    // Allocate sufficient space for the string.
    *ppszz = (LPWSTR ) TCP_ALLOC( (cchLen + nLines + 3) * sizeof(WCHAR));
    if ( *ppszz == NULL) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (FALSE);
    }


    //
    // walk down the local copy and convert all the line feed characters to
    //   be null char
    //

    //
    // Since the MULTI_SZ string cannot contain empty strings
    //  we convert empty lines (ones with just \n into " \0"
    //  i.e.  with a blank character.
    //

    pszSrc = lpsz;
    LPWSTR pszDst = *ppszz;

    if ( *pszSrc == L'\n') {

        // first line is a linefeed. insert a blank and proceed to next line.
        *pszDst = L' ';
        *(pszDst + 1) = L'\0';

        // move forward
        pszDst += 2;
        pszSrc++;
    }

    for( ; *pszSrc != L'\0';  pszSrc++, pszDst++) {

        if ( *pszSrc == L'\n') {

            // we are at boundary of new line.

            if ( pszSrc > lpsz && *(pszSrc - 1) == L'\n') {

                // we detected an empty line. Store an additional blank.

                *pszDst++ = L' ';
            }

            *pszDst = L'\0';  // put null char in place of line feed.

        } else {

            *pszDst = *pszSrc;
        }
    } // for

    *pszDst++   = L'\0';  // terminate with 1st null chars.
    *pszDst++ = L'\0';  // terminate with 2nd null chars.

    *pcchLen = DIFF(pszDst - *ppszz);

    DBG_ASSERT( *pcchLen <= cchLen + nLines + 3);

    return ( TRUE);
} // GenDoubleNullStringFromMultiline()


BOOL
FTP_SERVER_INSTANCE::WriteParamsToRegistry(
    LPFTP_CONFIG_INFO pConfig
    )
/*++
  This function writes parameters to the registry

  Arguments:
    hkey         HKEY for registry entry of parameters of FTP server.
    pConfig      pointer to configuration information.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    DWORD   err = NO_ERROR;
    BOOL    fRet = TRUE;

    HKEY    hkey = NULL;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        QueryRegParamKey(),
                        0,
                        KEY_ALL_ACCESS,
                        &hkey );

    if( hkey == NULL )
    {
        err = ERROR_INVALID_HANDLE;
        SetLastError( err);
        DBGPRINTF(( DBG_CONTEXT,
                    "Invalid Registry key given. error %lu\n",
                    err ));

        return FALSE;
    }

    //
    //  Write the registry data.
    //

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ALLOW_ANONYMOUS ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ALLOW_ANONYMOUS,
                                  pConfig->fAllowAnonymous );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ALLOW_GUEST_ACCESS ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ALLOW_GUEST_ACCESS,
                                  pConfig->fAllowGuestAccess );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ANNOTATE_DIRECTORIES ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ANNOTATE_DIRS,
                                  pConfig->fAnnotateDirectories );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ANONYMOUS_ONLY ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ANONYMOUS_ONLY,
                                  pConfig->fAnonymousOnly );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_LISTEN_BACKLOG ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_LISTEN_BACKLOG,
                                  pConfig->dwListenBacklog );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_LOWERCASE_FILES ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_LOWERCASE_FILES,
                                  pConfig->fLowercaseFiles );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_MSDOS_DIR_OUTPUT ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_MSDOS_DIR_OUTPUT,
                                  pConfig->fMsdosDirOutput );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_SHOW_4_DIGIT_YEAR ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_SHOW_4_DIGIT_YEAR,
                                  pConfig->fFourDigitYear );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_EXIT_MESSAGE ) )
    {
        err = RegSetValueExW( hkey,
                              FTPD_EXIT_MESSAGE_W,
                              0,
                              REG_SZ,
                              (BYTE *)pConfig->lpszExitMessage,
                              ( wcslen( pConfig->lpszExitMessage ) + 1 ) *
                                  sizeof(WCHAR) );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_GREETING_MESSAGE ) )
    {

        LPWSTR pszzGreetingMessage = NULL;
        DWORD   cchLen = 0;

        if (GenDoubleNullStringFromMultiLine( pConfig->lpszGreetingMessage,
                                             &pszzGreetingMessage,
                                             &cchLen)
            ) {

            DBG_ASSERT( pszzGreetingMessage != NULL);

            err = RegSetValueExW( hkey,
                                 FTPD_GREETING_MESSAGE_W,
                                 0,
                                 REG_MULTI_SZ,
                                 (BYTE *) pszzGreetingMessage,
                                 cchLen * sizeof(WCHAR));

            TCP_FREE( pszzGreetingMessage);
        } else {

            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_BANNER_MESSAGE ) )
    {

        LPWSTR pszzBannerMessage = NULL;
        DWORD   cchLen = 0;

        if (GenDoubleNullStringFromMultiLine( pConfig->lpszBannerMessage,
                                             &pszzBannerMessage,
                                             &cchLen)
            ) {

            DBG_ASSERT( pszzBannerMessage != NULL);

            err = RegSetValueExW( hkey,
                                 FTPD_BANNER_MESSAGE_W,
                                 0,
                                 REG_MULTI_SZ,
                                 (BYTE *) pszzBannerMessage,
                                 cchLen * sizeof(WCHAR));

            TCP_FREE( pszzBannerMessage);
        } else {

            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }


    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_MAX_CLIENTS_MESSAGE ) )
    {
        err = RegSetValueExW( hkey,
                              FTPD_MAX_CLIENTS_MSG_W,
                              0,
                              REG_SZ,
                              (BYTE *)pConfig->lpszMaxClientsMessage,
                              ( wcslen( pConfig->lpszMaxClientsMessage ) + 1 ) *
                                  sizeof(WCHAR) );
    }

    if( err )
    {
        SetLastError( err );
        return FALSE;
    }

    return TRUE;

}   // WriteParamsToRegistry



DWORD
FTP_IIS_SERVICE::GetServiceConfigInfoSize(
                    IN DWORD dwLevel
                    )
{
    switch (dwLevel) {
    case 1:
        return sizeof(FTP_CONFIG_INFO);
    }

    return 0;

} // FTP_IIS_SERVICE::GetServerConfigInfoSize


BOOL
FTP_SERVER_INSTANCE::SetServiceConfig(
    IN PCHAR pBuffer
    )
/*++

   Description

       Sets the common service admin information for the servers specified
       in dwServerMask.

   Arguments:

       pConfig - Admin information to set

   Note:

--*/
{
    LPFTP_CONFIG_INFO pConfig = (LPFTP_CONFIG_INFO)pBuffer;
    DWORD err = NO_ERROR;

    HKEY hKey;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        QueryRegParamKey(),
                        0,
                        KEY_ALL_ACCESS,
                        &hKey );

    if ( err != NO_ERROR )
    {
        return(TRUE);
    }

    //
    //  If success, then Write the new info to the registry, then read it back.
    //

    if( WriteParamsToRegistry( pConfig )) {

        err = InitFromRegistry( pConfig->FieldControl);
    } else {

        err = GetLastError();
    }

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "FtpSetServiceConfig returns with %d %lu\n",
                   err ));
    }

    return(err == NO_ERROR);

} // FTP_SERVER_INSTANCE::SetServiceConfig




BOOL
FTP_SERVER_INSTANCE::GetServiceConfig(
    IN  PCHAR   pBuffer,
    IN  DWORD   dwLevel
    )
/*++

   Description

       Retrieves the admin information

   Arguments:

       pBuffer - Buffer to fill up.
       dwLevel - info level of information to return.

   Note:

--*/
{

    LPFTP_CONFIG_INFO pConfig = (LPFTP_CONFIG_INFO)pBuffer;
    DWORD err = NO_ERROR;

    ZeroMemory( pConfig, sizeof(FTP_CONFIG_INFO) );

    //
    //  Obtain and Return the admin information.
    //

    err = GetConfigInformation( pConfig);

    IF_DEBUG( RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "FtprGetAdminInformation() returns Error=%u\n",
                   err));
    }

    return (err == NO_ERROR);

} // FTP_SERVER_INSTANCE::GetServiceConfig


BOOL
FTP_SERVER_INSTANCE::EnumerateUsers(
    OUT PCHAR * pBuffer,
    OUT PDWORD  nRead
    )
/*++

   Description

       Enumerates the connected users.

   Arguments:

       pBuffer - Buffer to fill up.
       nRead - number of entries filled

--*/
{
    DWORD err;
    DWORD cbBuffer;
    LPIIS_USER_INFO_1 pInfo;

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,"Entering FtpEnumerateUsers\n"));
    }

    //
    //  Determine the necessary buffer size.
    //

    cbBuffer = (GetCurrentConnectionsCount() + CONN_LEEWAY)
                * sizeof( IIS_USER_INFO_1 );

    *nRead = 0;

    pInfo = (LPIIS_USER_INFO_1)MIDL_user_allocate( cbBuffer);

    if (pInfo == NULL) {

        err = ERROR_NOT_ENOUGH_MEMORY;
    } else {

        //
        // Make a first attempt at enumerating the user info
        //

        err = NO_ERROR;
        if ( !::EnumerateUsers( (PCHAR)pInfo, &cbBuffer, nRead, this )) {

            //
            // Free up old buffer and allocate big one now.
            // We will try once more to get the data again
            //   with a larger buffer.
            //

            if ( cbBuffer > 0) {

                MIDL_user_free( pInfo );
                pInfo = (LPIIS_USER_INFO_1)MIDL_user_allocate(cbBuffer);

                if( pInfo == NULL ) {

                    err = ERROR_NOT_ENOUGH_MEMORY;
                } else {

                    //
                    // Since we do not lock the active connections list
                    // it is possible some one came in now and hence the
                    //  buffer is insufficient to hold all people.
                    // Ignore this case, as we are never
                    //  going to be accurate
                    //

                    ::EnumerateUsers( (PCHAR)pInfo, &cbBuffer, nRead, this );
                    if ( *nRead == 0 ) {
                        MIDL_user_free(pInfo);
                        pInfo = NULL;
                    }
                }

            } // cbBuffer > 0

        } // if unsuccessful at first attempt
    }

    if( err != NO_ERROR ) {

        IF_DEBUG( RPC ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "I_FtprEnumerateUsers failed. Error = %lu\n",
                       err ));
        }
        SetLastError(err);
        return(FALSE);
    }

    *pBuffer = (PCHAR)pInfo;

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "FtpEnumerateUsers returns %d entries, buffer [%x]\n",
                   *nRead, *pBuffer ));
    }
    return TRUE;

} // EnumerateUsers


BOOL
FTP_SERVER_INSTANCE::DisconnectUser(
                        IN DWORD dwIdUser
                        )
/*++

   Description

       Disconnect the user

   Arguments:

       dwIdUser - Identifies the user to disconnect.  If 0,
           then disconnect ALL users.

--*/
{
    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
            "Entering FtpDisconnectUsers with id[%d]\n", dwIdUser));
    }

    if ( !::DisconnectUser( dwIdUser, this ) ) {

        IF_DEBUG( RPC ) {
            DBGPRINTF(( DBG_CONTEXT,
                "DisconnectUser failed with %d\n", GetLastError()));
        }
        SetLastError(NERR_UserNotFound);
        return(FALSE);
    }

    return(TRUE);
} // DisconnectUser


BOOL
FTP_SERVER_INSTANCE::GetStatistics(
                        IN DWORD dwLevel,
                        OUT PCHAR* pBuffer
                        )
/*++

   Description

       Disconnect Queries the server statistics

   Arguments:

       dwLevel - Info level.  Currently only level 0 is
           supported.

       pBuffer - Will receive a pointer to the statistics
           structure.

--*/
{
    APIERR err = NO_ERROR;

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "FtpQueryStatistics2, level %lu\n", dwLevel ));
    }

    //
    //  Return the proper statistics based on the infolevel.
    //

    switch( dwLevel ) {
        case 0 : {

            LPFTP_STATISTICS_0 pstats0;

            pstats0 = (LPFTP_STATISTICS_0)
                       MIDL_user_allocate(sizeof(FTP_STATISTICS_0));

            if( pstats0 == NULL ) {

                err = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                ATQ_STATISTICS      atqStat;

                ZeroMemory( pstats0, sizeof( FTP_STATISTICS_0 ) );

                QueryStatsObj()->CopyToStatsBuffer( pstats0 );

                //
                //  Get instance's bandwidth throttling statistics
                //

                if ( QueryBandwidthInfo() )
                {
                    if ( AtqBandwidthGetInfo( QueryBandwidthInfo(),
                                              ATQ_BW_STATISTICS,
                                              (ULONG_PTR *) &atqStat ) )
                    {
                        pstats0->TotalBlockedRequests = atqStat.cBlockedRequests;
                        pstats0->TotalRejectedRequests = atqStat.cRejectedRequests;
                        pstats0->TotalAllowedRequests = atqStat.cAllowedRequests;
                        pstats0->CurrentBlockedRequests = atqStat.cCurrentBlockedRequests;
                        pstats0->MeasuredBandwidth = atqStat.MeasuredBandwidth;
                    }
                }

                pstats0->TimeOfLastClear = GetCurrentTimeInSeconds() -
                                           pstats0->TimeOfLastClear;

                //
                //  Copy Global statistics counter values
                //

                pstats0->ConnectionAttempts =
                    g_pFTPStats->QueryStatsObj()->ConnectionAttempts;

                *pBuffer = (PCHAR)pstats0;
            }

        }

        break;

     default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "FtpQueryStatistics2 returns Error = %lu\n",
                   err ));
    }

    SetLastError(err);
    return(err == NO_ERROR);

} // QueryStatistics



BOOL
FTP_SERVER_INSTANCE::ClearStatistics(
                        VOID
                        )
/*++

   Description

       Clears the server statistics

   Arguments:

        None.

--*/
{

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT, "Entering FtpClearStatistics2\n"));
    }

    QueryStatsObj()->ClearStatistics();
    return TRUE;

} // ClearStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\newls.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/
/*
   newls.cxx

    Implements a simulated "ls" command for the FTP Server service,
     with buffering and possibly caching of the results generated.

    Functions exported by this module:

        SimulateLs()
        SpecialLs()

    FILE HISTORY:
        MuraliK     19-April-1995  Created.
*/

# include "ftpdp.hxx"
# include "tsunami.hxx"
# include "lsaux.hxx"
# include <mbstring.h>


/**********************************************************************
 *  Private Globals
 **********************************************************************/

// Following message is required to send error msg when the file
//  or directory is absent.
extern CHAR * p_NoFileOrDirectory;              // This lives in engine.c.

static const char * PSZ_DEFAULT_SEARCH_PATH = "";

static const char * PSZ_WILD_CHARACTERS = "*?<>";  // include DOS wilds!


/**********************************************************************
 *  Prototypes of Functions
 **********************************************************************/

DWORD
FormatFileInfoLikeMsdos(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO  * pFormatInfo
    );

DWORD
FormatFileInfoLikeUnix(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO *  pFormatInfo
    );


APIERR
SimulateLsWorker(
    IN USER_DATA * pUserData,
    IN BOOL       fUseDataSocket,
    IN CHAR *     pszSearchPath,
    IN const LS_OPTIONS * pOptions,
    IN BOOL       fSendHeader = FALSE,
    IN BOOL       fSendBlank  = FALSE
    );


APIERR
SpecialLsWorker(
    IN USER_DATA *pUserData,
    IN BOOL       fUseDataSocket,
    CHAR *        pszSearchPath,
    BOOL          fShowDirectories,
    IN OUT LS_BUFFER * plsb
    );


//
//  The following is a table consisting of the sort methods used
//   for generating various dir listing. The table is indexed by LS_SORT.
//  This is used for finding the appropriate compare function for
//   any given sort method.
//  THE ORDER OF FUNCTIONS IN THIS ARRAY MUST MATCH THE ORDER IN LS_SORT!
//

static PFN_CMP_WIN32_FIND_DATA CompareRoutines[] = {

    CompareNamesInFileInfo,              // Normal sort order.
    CompareWriteTimesInFileInfo,
    CompareCreationTimesInFileInfo,
    CompareAccessTimesInFileInfo,

    CompareNamesRevInFileInfo,           // Reversed sort order.
    CompareWriteTimesRevInFileInfo,
    CompareCreationTimesRevInFileInfo,
    CompareAccessTimesRevInFileInfo
  };

// method,direction are used for indexing.
#define SORT_INDEX(method, dirn)   ((INT)(method) + \
                                    ((dirn) ? (INT)MaxLsSort : 0))





/**********************************************************************
 *  Functions
 **********************************************************************/

static
BOOL
SeparateOutFilterSpec( IN OUT CHAR * szPath, IN BOOL fHasWildCards,
                       OUT LPCSTR * ppszFilterSpec)
/*++
  The path has the form  c:\ftppath\foo\bar\*.*
  Check to see if the path is already a directory.
  If so set filter as nothing.
  This function identifies the last "\" and terminates the
   path at that point. The remaining forms a filter (here: *.*)
--*/
{
    char * pszFilter;
    BOOL fDir = FALSE;

    IF_DEBUG( DIR_LIST) {
        DBGPRINTF((DBG_CONTEXT, "SeparateOutFilter( %s, %d)\n",
                   szPath, fHasWildCards));
    }

    DBG_ASSERT( ppszFilterSpec != NULL);
    *ppszFilterSpec = NULL;  // initialize.

    if ( !fHasWildCards) {

        // Identify if the path is a directory

        DWORD dwAttribs = GetFileAttributes( szPath);

        if ( dwAttribs == INVALID_FILE_ATTRIBUTES) {

            return ( FALSE);
        } else {

            fDir = ( IS_DIR(dwAttribs));
        }
    }

    if ( !fDir ) {
        pszFilter = (PCHAR)_mbsrchr( (PUCHAR)szPath, '\\');

        //This has to exist, since valid path was supplied.
        DBG_ASSERT( pszFilter != NULL);
        *pszFilter = '\0';  // terminate the old path.
        pszFilter++;        // skip past the terminating null character.

        *ppszFilterSpec = (*pszFilter == '\0') ? NULL : pszFilter;

        IF_DEBUG(DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, "Path = %s; Filter = %s\n",
                       szPath, *ppszFilterSpec));
        }
    }

    return (TRUE);

} // SeparateOutFilterSpec()




APIERR
SimulateLs(
    IN USER_DATA * pUserData,
    IN OUT CHAR *  pszArg,
    IN BOOL        fUseDataSocket,
    IN BOOL        fDefaultLong
    )
/*++
  This function simulates an LS command. This simulated ls command supports
    the following switches:

                    -C  = Multi column, sorted down.
                    -l  = Long format output.
                    -1  = One entry per line (default).
                    -F  = Directories have '/' appended.
                    -t  = Sort by time of last write.
                    -c  = Sort by time of creation.
                    -u  = Sort by time of last access.
                    -r  = Reverse sort direction.
                    -a  = Show all files (including .*).
                    -A  = Show all files (except . and ..).
                    -R  = Recursive listing.

  Arguments:
    pUserData  --  the user initiating the request.
    pszArg     --  contains the search path, preceded by switches.
      Note: The argument is destroyed during processing!!!!
    fUseDataSocket -- if TRUE use Data socket, else use control socket.
    fDefaultLong  -- should the default be long ? ( if TRUE)

  Returns:
    APIERR,   0 on success.
--*/
{
    APIERR      serr = 0;
    LS_OPTIONS   options;
    CHAR       * pszToken = pszArg;
    CHAR       * pszDelimiters = " \t";

    DBG_ASSERT( pUserData != NULL );

    //
    //  Setup default ls options.
    //

    options.OutputFormat  = (( fDefaultLong) ?
                             LsOutputLongFormat : LsOutputSingleColumn);
    options.SortMethod    = LsSortByName;
    options.fReverseSort  = FALSE;
    options.fDecorate     = FALSE;
    options.fShowAll      = FALSE;
    options.fShowDotDot   = FALSE;
    options.fRecursive    = FALSE;
    options.lsStyle       = ( TEST_UF( pUserData, MSDOS_DIR_OUTPUT)
                             ? LsStyleMsDos
                             : LsStyleUnix
                             );
    options.fFourDigitYear= TEST_UF( pUserData, 4_DIGIT_YEAR);

    //
    //  Process switches in the input, if any
    //

    // simplify things by skipping whitespace...

    if (pszArg && isspace(*pszArg)) {
        while (isspace(*pszArg))
            pszArg++;
    }

    // now we should be pointing to the options, or the filename

    if (pszArg && (*pszArg == '-')) {

        for( pszToken = strtok( pszArg, pszDelimiters ); // getfirst Tok.
            ( ( pszToken != NULL ) && ( *pszToken == '-' ) );
            pszToken  = strtok( NULL, pszDelimiters)     // get next token
            ) {

            DBG_ASSERT( *pszToken == '-' );

            // process all the switches in single token

            //  for( pszToken++; *pszToken;  pszToken++)  is written as follows
            while ( *++pszToken) {

                switch( *pszToken ) {

                  case 'C' :
                  case '1' :
                    options.OutputFormat = LsOutputSingleColumn;
                    break;

                  case 'l' :
                    options.OutputFormat = LsOutputLongFormat;
                    break;

                  case 'F' :
                    options.fDecorate = TRUE;
                    break;

                  case 'r' :
                    options.fReverseSort = TRUE;
                    break;

                  case 't' :
                    options.SortMethod = LsSortByWriteTime;
                    break;

                  case 'c' :
                    options.SortMethod = LsSortByCreationTime;
                    break;

                  case 'u' :
                    options.SortMethod = LsSortByAccessTime;
                    break;

                  case 'a' :
                    options.fShowAll    = TRUE;
                    options.fShowDotDot = TRUE;
                    break;

                  case 'A' :
                    options.fShowAll    = TRUE;
                    options.fShowDotDot = FALSE;
                    break;

                  case 'R' :
                    options.fRecursive = TRUE;
                    break;

                  default:
                    IF_DEBUG( COMMANDS ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                   "ls: skipping unsupported option '%c'\n",
                                   *pszToken ));
                    }
                    break;
                } // switch()
            } // process all switches in a token

        } // for
    }

    //
    //  If the user is requesting an MSDOS-style long-format listing,
    //  then enable display of "." and "..".  This will make the MSDOS-style
    //  long-format output look a little more like MSDOS.
    //

    options.fShowDotDot = ( options.fShowDotDot ||
                           ( options.lsStyle == LsStyleMsDos &&
                            ( options.OutputFormat == LsOutputLongFormat ))
                           );


    //
    // since LIST is sent out synchronously, bump up thread count
    //  before beginning to send out the response for LIST
    //
    // A better method:
    //   Make LIST generate response in a buffer and use async IO
    //   operations for sending response.
    //   TBD (To Be Done)
    //
    AtqSetInfo( AtqIncMaxPoolThreads, 0);


    //
    //  At this point, pszToken is either NULL or points
    //  to the first (of potentially many) LS search paths.
    //

        serr = SimulateLsWorker(pUserData, fUseDataSocket, pszToken, &options);
#if 0
    // the following code supported handling a list of files to send info
    // back for - delimited by spaces.  However, the spec doesn't support
    // multiple arguments on an LS call.

    if( pszToken == NULL ) {

        //
        // Get the directory listing for current directory.
        //  Send in NULL for the path to be listed.
        //

        serr = SimulateLsWorker(pUserData, fUseDataSocket, NULL, &options);

    } else {

        //
        // There is a sequence of tokens on the command line.
        //  Process them all.
        //
        BOOL  fSendHeader = FALSE;

        while( pszToken != NULL ) {

            CHAR * pszNextToken = strtok( NULL, pszDelimiters );

            //
            //  Send the directory.
            //
            serr = SimulateLsWorker(pUserData,
                                    fUseDataSocket,
                                    pszToken,
                                    &options,
                                    fSendHeader || (pszNextToken != NULL),
                                    fSendHeader);

            //
            //  If there are more directories to send,
            //  send a blank line as a separator.
            //

            pszToken    = pszNextToken;
            fSendHeader = TRUE; // turn on for subsequent sends

            if( TEST_UF( pUserData, OOB_DATA ) || ( serr != 0 ) )
            {
                break;
            }
        } // while
    } // multiple arguments
#endif

    //
    // bring down the thread count when response is completed
    // TBD: Use Async send reponse()
    //

    AtqSetInfo( AtqDecMaxPoolThreads, 0);


    return ( serr);
}   // SimulateLs()




APIERR
SpecialLs(
    USER_DATA * pUserData,
    CHAR      * pszArg,
    IN BOOL     fUseDataSocket
    )
/*++
  This produces a special form of the directory listing that is required
    when an NLST command is received with no switches. Most of the FTP clients
    require this special form in order to get the MGET and MDEL commands
    to work. This produces atmost one level of directory information.

  Arguments:
    pUserData  - the user initiating the request.
    pszArg     - pointer to null-terminated string containing the argument.
                  NULL=current directory for UserData.
    fUseDataSocket - if TRUE use Data Socket, else use the ContorlSocket.

  Returns:
    APIERR   - 0 if successful, !0 if not.
--*/
{
    APIERR     dwError = 0;
    LS_BUFFER   lsb;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( ( pszArg == NULL ) || ( *pszArg != '-' ) ); // No options



    if ((dwError = lsb.AllocateBuffer( DEFAULT_LS_BUFFER_ALLOC_SIZE))
        != NO_ERROR) {

        IF_DEBUG(ERROR) {

            DBGPRINTF((DBG_CONTEXT, "Buffer allocation(%d bytes) failed.\n",
                       DEFAULT_LS_BUFFER_ALLOC_SIZE));
        }

        return (dwError);
    }



    //
    // since LIST is sent out synchronously, bump up thread count
    //  before beginning to send out the response for LIST
    //
    // A better method:
    //   Make LIST generate response in a buffer and use async IO
    //   operations for sending response.
    //   TBD (To Be Done)
    //
    AtqSetInfo( AtqIncMaxPoolThreads, 0);


    //
    //  Let the worker do the dirty work.
    //
    dwError = SpecialLsWorker(pUserData,
                              fUseDataSocket,
                              pszArg,         // search path (no switches)
                              TRUE,           // show directories
                              &lsb);

#if 0
    // the following code supported handling a list of files to send info
    // back for - delimited by spaces.  However, the spec doesn't support
    // multiple arguments on an LS call.

    if( pszArg == NULL )
    {
        dwError = SpecialLsWorker(pUserData,
                                  fUseDataSocket,
                                  pszArg,         // search path (no switches)
                                  TRUE,           // show directories
                                  &lsb);
    }
    else
    {
        CHAR  * pszToken;
        CHAR  * pszDelimiters = " \t";

        dwError = NO_ERROR;
        for( pszToken = strtok( pszArg, pszDelimiters ); // get first token
             pszToken != NULL && dwError == NO_ERROR;
             pszToken = strtok( NULL, pszDelimiters)     // get next token
            ) {

            dwError = SpecialLsWorker(pUserData,
                                      fUseDataSocket,
                                      pszToken,   // search path (no switches)
                                      TRUE,       // show directories
                                      &lsb);

            if( TEST_UF( pUserData, OOB_DATA )) {

                break;
            }
        } // for
    }
#endif
    if ( dwError == NO_ERROR) {

        // send all the remaining bytes in the buffer and then free memory.

        if ( lsb.QueryCB() != 0) {

            SOCKET sock = ((fUseDataSocket) ? pUserData->QueryDataSocket() :
                           pUserData->QueryControlSocket());

            dwError = SockSend(pUserData, sock,
                               lsb.QueryBuffer(),
                               lsb.QueryCB()/sizeof(CHAR));
        }

        lsb.FreeBuffer();
    }


    //
    // bring down the thread count when response is completed
    // TBD: Use Async send reponse()
    //

    AtqSetInfo( AtqDecMaxPoolThreads, 0);

    return ( dwError);

}   // SpecialLs()





//
//  Private functions.
//
APIERR
SimulateLsWorker(
    USER_DATA  * pUserData,
    IN BOOL      fUseDataSocket,
    IN CHAR    * pszSearchPath,
    IN const LS_OPTIONS * pOptions,
    IN BOOL      fSendHeader,
    IN BOOL      fSendBlank
    )
/*++
   Worker function for SimulateLs function, forms directory listing
    for requested directory, formats the directory listing and
    sends it to the client.

   Arguments:
      pUserData - The user initiating the request.

      pszSearchPath - Search directory, NULL = current dir.

      pOptions - LS options set by command line switches.

      fSendHeader - if TRUE send header with directory name in it.
      fSendBlank  - also add a blank if there is one that has to be sent.

  Returns:
     APIERR - 0 if successful, !0 if not.

  HISTORY:
     MuraliK     24-Apr-1995 ReCreated.
--*/
{
    SOCKET        sock;
    BOOL          fLikeMsdos;
    CHAR          szSearch[MAX_PATH];
    CHAR        * pszFilePart;
    CHAR          rgchLowFileName[MAX_PATH];  // used for lower casing filename
    BOOL          fMapToLowerCase = FALSE;
    DWORD         dwAccessMask = 0;
    BOOL          fImpersonated = FALSE;

    LS_BUFFER     lsb;
    LS_FORMAT_INFO lsfi;        // required only for long formatting.

    BOOL          fHasWildCards   = FALSE;
    BOOL          fHasTrailingDot = FALSE;
    DWORD         dwError         = NO_ERROR;
    APIERR        serr            = 0;
    TS_DIRECTORY_INFO   tsDirInfo( pUserData->QueryInstance()->GetTsvcCache());


    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT, " SimulateLsWorker( %08x, %d, %s)\n",
                   pUserData, fUseDataSocket, pszSearchPath));
    }

    DBG_ASSERT( pUserData != NULL && pOptions != NULL);

    //
    // Check for emptiness of path or wildcards in search path.
    // We are only concerned about wild cards in user input. The reason
    //   is all trailing '.' will be removed when we canonicalize
    //   the path ( which user may not appreciate).
    //

    if ( IS_EMPTY_PATH(pszSearchPath)) {

        // we know pszSearchPath will not change the buffer!
        pszSearchPath = (char *) PSZ_DEFAULT_SEARCH_PATH;

    } else if (( pszSearchPath != NULL) &&
               ( strpbrk( pszSearchPath, PSZ_WILD_CHARACTERS ) != NULL)
               ){

        //
        //  Search path contains wildcards.
        //

        fHasWildCards = TRUE;
    }

    //
    //  Canonicalize the search path.
    //

    DWORD cbSize = MAX_PATH;
    dwError = pUserData->VirtualCanonicalize(szSearch, &cbSize,
                                             pszSearchPath,
                                             AccessTypeRead,
                                             &dwAccessMask);

    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);

    if( dwError == NO_ERROR ) {

        FTP_LS_FILTER_INFO  fls;  // required for generating directory listing
        PFN_CMP_WIN32_FIND_DATA  pfnCompare;

        //
        //  VirtualCanonicalize() when sanitizing the path removes
        //     trailing dots from the path. Replace them here
        //
        DBG_ASSERT( !fHasWildCards || strlen(pszSearchPath) >= 1);

        if( fHasWildCards && (pszSearchPath[strlen(pszSearchPath)-1] == '.')) {

            DBG_ASSERT( strlen(szSearch) < MAX_PATH - 1);
            strcat( szSearch, "." );
        }

        //
        //  Build the directory list.
        //

        pfnCompare = CompareRoutines[SORT_INDEX(pOptions->SortMethod,
                                                pOptions->fReverseSort)
                                     ];

        // Separate the filter out ( that is the last component)

        if (pUserData->ImpersonateUser() &&
            SeparateOutFilterSpec( szSearch, fHasWildCards, &fls.pszExpression)
            ) {

            fls.fFilterHidden = !pOptions->fShowAll;
            fls.fFilterSystem = !pOptions->fShowAll;
            fls.fFilterDotDot = !pOptions->fShowDotDot;

            fls.fRegExpression = ( fls.pszExpression != NULL && fHasWildCards);
            fls.fIgnoreCase    = pUserData->QueryInstance()->QueryLowercaseFiles();

            dwError = GetDirectoryInfo(pUserData,
                                       &tsDirInfo,
                                       szSearch,
                                       &fls,
                                       pfnCompare);

            pUserData->RevertToSelf();
        } else {

            dwError = GetLastError();
        }
    }

    //
    //  If there were any errors, tell them the bad news now.
    //

    if( dwError != NO_ERROR ) {

        return  (dwError);
    }

    sock  = ((fUseDataSocket) ? pUserData->QueryDataSocket() :
             pUserData->QueryControlSocket());

    DBG_ASSERT( tsDirInfo.IsValid());

    int cDirEntries = tsDirInfo.QueryFilesCount();

    if ( cDirEntries > 0) {

        //
        // put out the header block before starting dir listing
        //

        if( fSendHeader ) {

            serr = SockPrintf2( pUserData, sock,
                               "%s%s:",
                               (fSendBlank)? "\r\n" : "",  // send \r\n
                               pszSearchPath);

            if ( serr != 0) {

                return (serr);
            }
        }
    }

    fLikeMsdos  = (pOptions->lsStyle == LsStyleMsDos);

    lsfi.fFourDigitYear = pOptions->fFourDigitYear;

    if( !fLikeMsdos ) {

        //
        //  Initialize the information in lsfi if we are doing
        //   long format output.
        //

        if ( pOptions->OutputFormat == LsOutputLongFormat) {

            SYSTEMTIME    timeNow;
            BOOL fUserRead, fUserWrite;

            //
            //  Obtain the current time.
            //  The Unix-like output requires current year
            //

            GetLocalTime( &timeNow );

            lsfi.wCurrentYear = timeNow.wYear;
            lsfi.hUserToken   = TsTokenToImpHandle(pUserData->QueryUserToken());

            //
            // Since szSearch contains the complete path, we call
            //  PathAccessCheck directly without resolving
            //    from absolute to virtual
            //

            fUserRead  = TEST_UF( pUserData, READ_ACCESS);
            fUserWrite = TEST_UF( pUserData, WRITE_ACCESS);

            lsfi.fVolumeReadable =
              PathAccessCheck(AccessTypeRead,
                              dwAccessMask,
                              fUserRead,
                              fUserWrite);

            lsfi.fVolumeWritable =
              PathAccessCheck(AccessTypeWrite,
                              dwAccessMask,
                              fUserRead,
                              fUserWrite);


            lsfi.pszPathPart = szSearch;
            lsfi.pszFileName = NULL;
            lsfi.pszDecorate = NULL;
        } // if ( long format output)

        //
        // We need to be impersonated only for UNIX-style listing.
        //  For UNIX style listing, we make some NTsecurity queries
        //   and they work only under the context of an impersonation.
        //

        if ( !(fImpersonated = pUserData->ImpersonateUser())) {

            dwError = GetLastError();
        }
    }

    //
    //  Loop for each directory entry
    //

    if (dwError != NO_ERROR ||
        (dwError = lsb.AllocateBuffer( DEFAULT_LS_BUFFER_ALLOC_SIZE))
        != NO_ERROR) {

        IF_DEBUG(ERROR) {

            DBGPRINTF((DBG_CONTEXT,
                       "Impersonation or Buffer allocation(%d bytes)",
                       " failed.\n",
                       DEFAULT_LS_BUFFER_ALLOC_SIZE));
        }

        if ( fImpersonated) {

            pUserData->RevertToSelf();
        }

        return (dwError);
    }

    //
    //  Only map to lower case if not a remote drive AND the lower-case file
    //  names flag is set AND this is not a case perserving file system.
    //

    if (*szSearch != '\\') {
        fMapToLowerCase = pUserData->QueryInstance()->QueryLowercaseFiles();
    }

    for( int idx = 0; serr == 0 && idx < cDirEntries; idx++) {

        const WIN32_FIND_DATA * pfdInfo = tsDirInfo[idx];
        DBG_ASSERT( pfdInfo != NULL);
        const CHAR * pszFileName = pfdInfo->cFileName;
        DWORD dwAttribs = pfdInfo->dwFileAttributes;

        //
        //  Dump it.
        //

        // We may need to convert all filenames to lower case if so desired!!
        if( fMapToLowerCase ) {

            //
            // copy file name to local scratch and change the ptr pszFileName
            // because we cannot destroy pfdInfo->cFileName
            //
            strcpy( rgchLowFileName, pszFileName);
            CharLower( rgchLowFileName);
            pszFileName = rgchLowFileName;
        }

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF((DBG_CONTEXT, "Dir list for %s\n",
                       pszFileName));
        }

        //
        // Send the partial data obtained so far.
        //  Use buffering to minimize number of sends occuring
        //

        if ( dwError == NO_ERROR) {

            if ( lsb.QueryRemainingCB() < MIN_LS_BUFFER_SIZE) {

                // send the bytes available in buffer and reset the buffer
                serr = SockSend(pUserData, sock,
                                lsb.QueryBuffer(), lsb.QueryCB()/sizeof(CHAR));
                lsb.ResetAppendPtr();
            }

        } else {

            serr = dwError;
        }

        //
        //  Check for socket errors on send or pending OOB data.
        //

        if( TEST_UF( pUserData, OOB_DATA ) || ( serr != 0 ) )
        {
            break;
        }


        CHAR * pszDecorate = ( (pOptions->fDecorate && IS_DIR(dwAttribs) )
                            ? "/" : "");

        if( pOptions->OutputFormat == LsOutputLongFormat )
        {
            FILETIME ftLocal;

            //
            //  Long format output.  Just send the file/dir info.
            //

            //
            //  Map the file's last write time to (local) system time.
            //
            if ( !FileTimeToLocalFileTime(
                     PickFileTime( pfdInfo, pOptions),
                     &ftLocal) ||
                 ! FileTimeToSystemTime(
                                       &ftLocal,
                                       &lsfi.stFile)
                ) {

                dwError = GetLastError();

                IF_DEBUG( ERROR) {
                    DBGPRINTF(( DBG_CONTEXT,
                               "Error in converting largeintger time %lu\n",
                               dwError));
                }
            } else {

                lsfi.pszDecorate = pszDecorate;
                lsfi.pszFileName = pszFileName;

                if( fLikeMsdos ) {

                    dwError = FormatFileInfoLikeMsdos(&lsb,
                                                      pfdInfo,
                                                      &lsfi);

                    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);
                } else {

                    dwError = FormatFileInfoLikeUnix(&lsb,
                                                     pfdInfo,
                                                     &lsfi);

                    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);
                }
            }

        } else {

            //
            //  Short format output.
            //

            DWORD cchSize = wsprintfA(lsb.QueryAppendPtr(), "%s%s\r\n",
                                      pszFileName, pszDecorate);
            lsb.IncrementCB( cchSize * sizeof(CHAR));
        }

    } // for()

    //
    // Get out of being impersonated.
    //
    if ( fImpersonated) {

        pUserData->RevertToSelf();
    }

    if ( dwError == NO_ERROR) {

        // send all the remaining bytes in the buffer and then free memory.

        if ( lsb.QueryCB() != 0) {

            serr = SockSend(pUserData, sock,
                            lsb.QueryBuffer(), lsb.QueryCB()/sizeof(CHAR));
        }

        lsb.FreeBuffer();
    } else {

        return ( dwError);  // an error has occured. stop processing
    }


    if( serr == 0 && !TEST_UF( pUserData, OOB_DATA) && pOptions->fRecursive )
    {
        //
        //  The user want's a recursive directory search...
        //

        CHAR   szOriginal[ MAX_PATH*2];
        CHAR * pszOriginalFilePart;


        // Obtain a copy of the path in the szOriginal so that we
        //  can change it while recursively calling ourselves.

        if ( pszSearchPath == PSZ_DEFAULT_SEARCH_PATH) {

            // means that we had all files/dir of current directory.

            strcpy( szOriginal, fLikeMsdos ? ".\\" : "./" );

        } else {

            DBG_ASSERT( strlen(pszSearchPath) < MAX_PATH);
            strcpy( szOriginal, pszSearchPath );

            // strip off the wild cards if any present
            if( fHasWildCards )
              {
                  CHAR * pszTmp;

                  pszTmp = (PCHAR)_mbsrchr( (PUCHAR)szOriginal, '\\');

                  pszTmp = pszTmp ? pszTmp : strrchr( szOriginal, '/' );
                  pszTmp = pszTmp ? pszTmp : strrchr( szOriginal, ':' );

                  pszTmp = ( pszTmp) ? pszTmp+1 : szOriginal;

                  *pszTmp = '\0';
              } else {
                  CHAR ch;
                  int cb = strlen( szOriginal);

                  DBG_ASSERT( cb > 0);
                  ch = *CharPrev( szOriginal, szOriginal + cb );
                  if( !IS_PATH_SEP( ch ) ) {

                      // to add "/"
                      DBG_ASSERT( strlen( szOriginal) + 2 < MAX_PATH);
                      strcat( szOriginal, fLikeMsdos ? "\\" : "/" );
                  }
              }
        }

        pszOriginalFilePart = szOriginal + strlen(szOriginal);

        DBG_ASSERT( tsDirInfo.IsValid());
        DBG_ASSERT( cDirEntries == tsDirInfo.QueryFilesCount());

        for( int idx = 0; serr == 0 && idx < cDirEntries; idx++) {

            const WIN32_FIND_DATA * pfdInfo = tsDirInfo[idx];
            DBG_ASSERT( pfdInfo != NULL);
            const char * pszFileName = pfdInfo->cFileName;
            DWORD dwAttribs = pfdInfo->dwFileAttributes;

            //
            //  Filter out non-directories.
            //

            if( !IS_DIR( dwAttribs) ) {

                continue;
            }

            //
            //  Dump it.
            //

            DBG_ASSERT( strlen( pszOriginalFilePart) + strlen(pszFileName)
                       < MAX_PATH * 2);
            strcpy( pszOriginalFilePart, pszFileName );

            serr = SimulateLsWorker(pUserData,
                                    fUseDataSocket,
                                    szOriginal,
                                    pOptions,
                                    TRUE, TRUE);

            //
            //  Check for socket errors on send or pending OOB data.
            //

            if( TEST_UF( pUserData, OOB_DATA ) || ( serr != 0 ) )
              {
                  break;
              }

        } // for( directory looping)

    } // if ( fRecursive)


    // At the end of directory listing. Return back.

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "SimulateLsWorker() for User %08x, Dir %s returns %d\n",
                   pUserData, pszSearchPath, serr));
    }


    return serr;
}   // SimulateLsWorker()




APIERR
SpecialLsWorker(
    USER_DATA * pUserData,
    IN BOOL     fUseDataSocket,
    CHAR      * pszSearchPath,
    BOOL        fShowDirectories,
    IN OUT LS_BUFFER * plsb
    )
/*++
  This is the worker function for Special Ls function. It is similar to
   the the SimulateLsWorker, only in that it shows directory if the
   fShowDirectories flag is set.

  The reason for this comes from a special FTP command which inquires about
    all the files in the first level and second level of current directory,
    which is not a recursive listing at all. This function when it recursively
    calls itself, always sets the fShowDirectories as FALSE.

  Arguments:
    pUserData     pointer to user data object that initiated the request.
    fUseDataSocket  if TRUE use DataSocket of UserData else
                       use the control socket of UserData.
    pszSearchPath  pointer to null-terminated string for requested directory.
                       NULL means use current directory.
    fShowDirectories  only show directories if TRUE.
    plsb          pointer to buffer to accumulate the data generated and send
                     it out in a single bulk.

  Returns:
    APIERR   0  if successful.

  History:
     KeithMo     17-Mar-1993 Created.
     MuraliK     26-Apr-1995 ReCreated to use new way of generation.
--*/
{
    CHAR        chSeparator;
    CHAR  *     pszRecurse;
    SOCKET      sock;
    BOOL        fHasWildCards = FALSE;
    DWORD       dwError       = NO_ERROR;
    TS_DIRECTORY_INFO  tsDirInfo( pUserData->QueryInstance()->GetTsvcCache());
    CHAR        szSearch[MAX_PATH];
    CHAR        szRecurse[MAX_PATH];
    BOOL        fMapToLowerCase = FALSE;
    CHAR        rgchLowFileName[MAX_PATH];  // used for lower casing filename
    BOOL        fHadOneComponent = FALSE;

    DBG_ASSERT( pUserData != NULL);

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "Entering SpecialLsWorker( %08x, %s)\n",
                   pUserData, pszSearchPath));
    }


    chSeparator = TEST_UF( pUserData, MSDOS_DIR_OUTPUT ) ? '\\' : '/';

    //
    //  Check for wildcards in search path.
    //

    if( ( pszSearchPath != NULL ) && ( *pszSearchPath != '\0' ) )
    {
        //
        //  Setup for recursive directory search.  We'll set things up
        //  so we can strcpy a new directory to pszRecurse, then
        //  recursively call ourselves with szRecurse as the search
        //  path.
        //
        //  We also use szRecurse as a "prefix" to display before each
        //  file/directory.  The FTP Client software needs this for the
        //  MDEL & MGET commands.
        //
        if ( strlen(pszSearchPath) >= MAX_PATH -1 )
        {
            return ERROR_BUFFER_OVERFLOW;
        }

        strcpy( szRecurse, pszSearchPath );

        // get slash.
        pszRecurse = (PCHAR)_mbsrchr( (PUCHAR)szRecurse, '\\');
        pszRecurse = ((pszRecurse == NULL) ?
                      strrchr( szRecurse, '/') : pszRecurse);
        fHadOneComponent = (pszRecurse == NULL);

        if( strpbrk( szRecurse, PSZ_WILD_CHARACTERS) != NULL )
        {
            //
            //  Search path contains wildcards.
            //

            fHasWildCards = TRUE;

            // we do not care about components when wild card is present
            fHadOneComponent = FALSE;

            //
            //  Strip the wildcard pattern from the search path.
            // look for both kind of slashes ( since precanonicalized)
            //

            //
            // If we found right-most dir component, skip path separator
            //  else set it to start of search path.
            //
            pszRecurse = ( ( pszRecurse != NULL)
                          ? pszRecurse + 1
                          : szRecurse
                          );
        } else {

            //
            //  No wildcards, so the argument must be a path.
            //  Ensure it is terminated with a path separator.
            //

            pszRecurse = CharPrev( szRecurse, szRecurse + strlen(szRecurse) );

            if( !IS_PATH_SEP( *pszRecurse ) )
            {
                *++pszRecurse = chSeparator;
            }

            pszRecurse++;  // skip the path separator
        }
    } else {

        //
        //  No arguments.
        //

        pszRecurse = szRecurse;


        //
        //  Munge the arguments around a bit.  NULL = *.* in current
        //  directory.  If the user specified a directory (like d:\foo)
        //  then append *.*.
        //

        pszSearchPath = (char *) PSZ_DEFAULT_SEARCH_PATH;
    }

    *pszRecurse = '\0';

    //
    //  Canonicalize the search path.
    //
    DWORD cbSize = MAX_PATH;
    dwError = pUserData->VirtualCanonicalize(szSearch, &cbSize,
                                             pszSearchPath,
                                             AccessTypeRead);

    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);

    if( dwError == NO_ERROR ) {

        FTP_LS_FILTER_INFO  fls;  // required for generating directory listing
        LPCSTR  pszFilter = NULL;

        //
        //  VirtualCanonicalize() when sanitizing the path removes
        //     trailing dots from the path. Replace them here
        //

        if( fHasWildCards && (pszSearchPath[strlen(pszSearchPath)-1] == '.')) {

            strcat( szSearch, "." );
        }

        //
        //  Build the directory list.
        //

        if (pUserData->ImpersonateUser() &&
            SeparateOutFilterSpec( szSearch, fHasWildCards, &fls.pszExpression)
            ) {

            fls.fFilterHidden = TRUE;
            fls.fFilterSystem = TRUE;
            fls.fFilterDotDot = TRUE;

            fls.fRegExpression = ( fls.pszExpression != NULL && fHasWildCards);
            fls.fIgnoreCase    = pUserData->QueryInstance()->QueryLowercaseFiles();


            dwError = GetDirectoryInfo(pUserData,
                                       &tsDirInfo,
                                       szSearch,
                                       &fls,
                                       NULL);  // unsorted list

            pUserData->RevertToSelf();

        } else {

            dwError = GetLastError();
        }
    }

    //
    //  If there were any errors, tell them the bad news now.
    //

    if( dwError != NO_ERROR ) {

        return  ( dwError);
    }

    if ( fHadOneComponent) {

        // HARD CODE! Spend some time and understand this....

        //
        // Adjust the szRecurse buffer to contain appropriate path
        //  such that in presence of one component we generate proper
        //  result.
        //

        // the given path is either invalid or non-directory
        //  so reset the string stored in szRecurse.
        szRecurse[0] = '\0';
        pszRecurse = szRecurse;
    }


    //
    //  Only map to lower case if not a remote drive AND the lower-case file
    //  names flag is set AND this is not a case perserving file system.
    //

    if (*szSearch != '\\') {
        fMapToLowerCase = pUserData->QueryInstance()->QueryLowercaseFiles();
    }

    //
    //  Loop until we're out of files to find.
    //

    sock = ((fUseDataSocket) ? pUserData->QueryDataSocket() :
            pUserData->QueryControlSocket());

    int cDirEntries = tsDirInfo.QueryFilesCount();

    for( int idx = 0; dwError == NO_ERROR && idx < cDirEntries; idx++) {

        const WIN32_FIND_DATA * pfdInfo = tsDirInfo[idx];
        DBG_ASSERT( pfdInfo != NULL);
        const CHAR * pszFileName = pfdInfo->cFileName;
        DWORD dwAttribs = pfdInfo->dwFileAttributes;

        if ( !fShowDirectories && IS_DIR( dwAttribs)) {

            continue;
        }

        //
        //  Dump it.
        //

        // We may need to convert all filenames to lower case if so desired!!
        if( fMapToLowerCase ) {

            //
            // copy file name to local scratch and change the ptr pszFileName
            // because we cannot destroy pfdInfo->cFileName
            //
            strcpy( rgchLowFileName, pszFileName);
            CharLower( rgchLowFileName );
            pszFileName = rgchLowFileName;
        }

        //
        // Send the partial data obtained so far.
        //  Use buffering to minimize number of sends occuring
        //

        if ( dwError == NO_ERROR) {

            if ( plsb->QueryRemainingCB() < MIN_LS_BUFFER_SIZE) {

                // send the bytes available in buffer and reset the buffer
                dwError = SockSend(pUserData, sock,
                                   plsb->QueryBuffer(),
                                   plsb->QueryCB()/sizeof(CHAR));
                plsb->ResetAppendPtr();
            }

        }

        //
        //  Test for aborted directory listing or socket error.
        //

        if( TEST_UF( pUserData, OOB_DATA ) || ( dwError != NO_ERROR ) )
        {
            break;
        }

        //
        //  If no wildcards were given, then just dump out the
        //  file/directory.  If wildcards were given, AND this
        //  is a directory, then recurse (one level only) into
        //  the directory.  The mere fact that we don't append
        //  any wildcards to the recursed search path will
        //  prevent a full depth-first recursion of the file system.
        //

        if( fHasWildCards && IS_DIR(dwAttribs) ) {

            DBG_ASSERT(strcmp( pszFileName, "." ) != 0);
            DBG_ASSERT(strcmp( pszFileName, "..") != 0);

            DBG_ASSERT(strlen(szRecurse)+strlen( pszFileName) < MAX_PATH);
            strcpy( pszRecurse, pszFileName );
            strcat( pszRecurse, "/"); // indicating this is a directory

            dwError = SpecialLsWorker(pUserData,
                                      fUseDataSocket,
                                      szRecurse,
                                      FALSE,
                                      plsb);
        } else {

            DWORD cchSize;

            *pszRecurse = '\0';  // as a side effect this terminates szRecurse.

            //
            //  Short format output.
            //

            cchSize = wsprintfA(plsb->QueryAppendPtr(),
                                "%s%s\r\n",
                                szRecurse,
                                pszFileName);
            plsb->IncrementCB( cchSize*sizeof(CHAR));

        }

    } // for


    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "Leaving SpecialLsWorker() with Error = %d\n",
                   dwError));
    }

    return (dwError);

}   // SpecialLsWorker()




/**************************************************
 *   Formatting functions.
 **************************************************/



DWORD
FormatFileInfoLikeMsdos(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO  * pFormatInfo
    )
/*++

  Forms an MSDOS like directory entry for the given dir info object.

  Arguments:

    plsb    pointer to buffer into which the dir line is generated.

    pfdInfo    pointer to dir information element.
    pFormatInfo pointer to information required for formatting.
     ( use the file name in pFormatInfo, becauze it may have been
       made into lower case if necessary)

  Returns:
    Win32 error code and NO_ERROR on success.

  History:
    MuraliK      25-Apr-1995
--*/
{
    DWORD        dwError = NO_ERROR;
    CHAR         szSizeOrDir[32];
    BOOL         fDir;
    DWORD        cbReqd;

    DBG_ASSERT(plsb != NULL && pfdInfo != NULL   && pFormatInfo != NULL);

    if ( IS_DIR( pfdInfo->dwFileAttributes)) {

        strcpy( szSizeOrDir, "<DIR>         " );
    } else {

        LARGE_INTEGER li;
        li.HighPart = pfdInfo->nFileSizeHigh;
        li.LowPart  = pfdInfo->nFileSizeLow;

        IsLargeIntegerToDecimalChar( &li, szSizeOrDir);
    }

    DBG_ASSERT( strlen(szSizeOrDir) <= 20);

    cbReqd = ( 10       // size for the date field
              + 10      // size for time field
              + 20      // space for size/dir
              + strlen( pFormatInfo->pszFileName)
              + 8       // addl space + decoration ...
              ) * sizeof(CHAR);

    DBG_ASSERT( cbReqd <= MIN_LS_BUFFER_SIZE);

    if ( cbReqd < plsb->QueryRemainingCB()) {

        register const SYSTEMTIME * pst = &pFormatInfo->stFile;
        WORD   wHour;
        char * pszAmPm;
        DWORD  cchUsed;

        wHour   = pst->wHour;
        pszAmPm = ( wHour < 12 ) ? "AM" : "PM";

        if ( wHour == 0 ) {            wHour = 12;  }
        else if ( wHour > 12) {        wHour -= 12; }

        if (pFormatInfo->fFourDigitYear) {
            cchUsed = wsprintfA(plsb->QueryAppendPtr(),
                           "%02u-%02u-%04u  %02u:%02u%s %20s %s%s\r\n",
                           pst->wMonth,
                           pst->wDay,
                           pst->wYear,
                           wHour,
                           pst->wMinute,
                           pszAmPm,
                           szSizeOrDir,
                           pFormatInfo->pszFileName,
                           pFormatInfo->pszDecorate);
        }
        else {
            cchUsed = wsprintfA(plsb->QueryAppendPtr(),
                           "%02u-%02u-%02u  %02u:%02u%s %20s %s%s\r\n",
                           pst->wMonth,
                           pst->wDay,
                           pst->wYear%100,  //instead of wYear - 1900
                           wHour,
                           pst->wMinute,
                           pszAmPm,
                           szSizeOrDir,
                           pFormatInfo->pszFileName,
                           pFormatInfo->pszDecorate);
        }

        DBG_ASSERT( cchUsed * sizeof(CHAR) <= cbReqd);
        plsb->IncrementCB(cchUsed * sizeof(CHAR));

    } else {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    }


    return ( dwError);

}   // FormatFileInfoLikeMsdos()




DWORD
FormatFileInfoLikeUnix(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO * pFormatInfo
    )
/*++
  This function formats file information for a UNIX stle client.

  Arguments:

    plsb        pointer to buffer into which the dir line is generated.
    pfdInfo     pointer to dir information element.
    pFormatInfo pointer to information required for long formatting.

  Returns:
    Win32 error code and NO_ERROR on success.

  History:
    MuraliK      25-Apr-1995
--*/
{
    DWORD         dwError = NO_ERROR;
    CHAR        * pszFileOwner;
    CHAR        * pszFileGroup;
    const SYSTEMTIME * pst;
    DWORD         dwMode;
    DWORD         cLinks;
    NTSTATUS      status;
    LARGE_INTEGER li;
    CHAR          attrib[4];
    CHAR          szTimeOrYear[12];
    CHAR          szSize[32];

    DWORD         cbReqd;

    static CHAR * apszMonths[] = { "   ", "Jan", "Feb", "Mar", "Apr",
                                   "May", "Jun", "Jul", "Aug", "Sep",
                                   "Oct", "Nov", "Dec" };

    DBG_ASSERT( plsb != NULL);
    DBG_ASSERT( pFormatInfo != NULL );
    DBG_ASSERT( pFormatInfo->hUserToken != NULL );
    DBG_ASSERT( pFormatInfo->pszPathPart != NULL );
    DBG_ASSERT( pfdInfo != NULL );


    //
    //  Build the attribute triple.  Note that we only build one,
    //  and replicate it three times for the owner/group/other fields.
    //

    dwMode = ComputeModeBits( pFormatInfo->hUserToken,
                              pFormatInfo->pszPathPart,
                              pfdInfo,
                              &cLinks,
                              pFormatInfo->fVolumeReadable,
                              pFormatInfo->fVolumeWritable );

    attrib[0] = ( dwMode & FILE_MODE_R ) ? 'r' : '-';
    attrib[1] = ( dwMode & FILE_MODE_W ) ? 'w' : '-';
    attrib[2] = ( dwMode & FILE_MODE_X ) ? 'x' : '-';
    attrib[3] = '\0';

    pst = &pFormatInfo->stFile;

    // NYI: can we make the following a single wsprintf call ??
    if( pst->wYear == pFormatInfo->wCurrentYear ) {

        //
        //  The file's year matches the current year, so
        //  display the hour & minute of the last write.
        //

        wsprintfA( szTimeOrYear, "%2u:%02u", pst->wHour, pst->wMinute );
    } else {

        //
        //  The file's year does not match the current
        //  year, so display the year of the last write.
        //

        wsprintfA( szTimeOrYear, "%4u", pst->wYear );
    }

    //
    //  CODEWORK:  How expensive would it be do
    //  get the proper owner & group names?
    //

    pszFileOwner = "owner";
    pszFileGroup = "group";

    //
    //  Get the size in a displayable form.
    //

    li.HighPart = pfdInfo->nFileSizeHigh;
    li.LowPart  = pfdInfo->nFileSizeLow;

    IsLargeIntegerToDecimalChar( &li, szSize);

    //
    //  Dump it.
    //
    DBG_ASSERT( strlen(szSize) <= 12);
    cbReqd = ( 3*strlen(attrib) + strlen( pszFileOwner)
              + strlen( pszFileGroup) + 12 + 20 // date
              + strlen( pFormatInfo->pszFileName)
              + strlen( pFormatInfo->pszDecorate) + 20 // 20 for spaces etc.
              ) * sizeof(CHAR);
    DBG_ASSERT( cbReqd < MIN_LS_BUFFER_SIZE);

    if ( cbReqd < plsb->QueryRemainingCB()) {

        DWORD cchUsed = wsprintfA( plsb->QueryAppendPtr(),
                          "%c%s%s%s %3lu %-8s %-8s %12s %s %2u %5s %s%s\r\n",
                          (IS_DIR(pfdInfo->dwFileAttributes) ? 'd' : '-'),
                          attrib,
                          attrib,
                          attrib,
                          cLinks,
                          pszFileOwner,
                          pszFileGroup,
                          szSize,
                          apszMonths[pst->wMonth],
                          pst->wDay,
                          szTimeOrYear,
                          pFormatInfo->pszFileName,
                          pFormatInfo->pszDecorate);

        DBG_ASSERT( cchUsed * sizeof(CHAR) <= cbReqd);
        plsb->IncrementCB( cchUsed*sizeof(CHAR));

    } else {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    }

    return ( dwError);

}   // FormatFileInfoLikeUnix()

/************************ End of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\stats.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module Name :
    
       stats.cxx

   Abstract:
    
       Defines functions required for FTP server statistics

   Author:

       Murali R. Krishnan    ( MuraliK )     04-Nov-1994
   
   Project:

       Web Server DLL

   Functions Exported:

               FTP_SERVER_STATISTICS::FTP_SERVER_STATISTICS( VOID) 
       VOID    FTP_SERVER_STATISTICS::ClearStatistics( VOID)
       DWORD   CopyToStatsBuffer( LPFTP_STATISTICS_0 lpStat)

   Revision History:

       Sophia Chung ( SophiaC )     20-Nov-1996

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "ftpdp.hxx"
#include <timer.h>
#include <time.h>


/************************************************************
 *    Functions 
 ************************************************************/


FTP_SERVER_STATISTICS::FTP_SERVER_STATISTICS( VOID) 
/*++
     Initializes statistics information for server.
--*/
{
    INITIALIZE_CRITICAL_SECTION( & m_csStatsLock);

    ClearStatistics();

} // FTP_SERVER_STATISTICS::FTP_SERVER_STATISTICS();


VOID
FTP_SERVER_STATISTICS::ClearStatistics( VOID)
/*++

    Clears the counters used for statistics information

--*/ 
{
    LockStatistics();

    memset( &m_FTPStats, 0, sizeof(FTP_STATISTICS_0) );
    m_FTPStats.TimeOfLastClear       = GetCurrentTimeInSeconds();

    UnlockStatistics();

} // FTP_SERVER_STATISTICS::ClearStatistics()



DWORD
FTP_SERVER_STATISTICS::CopyToStatsBuffer( LPFTP_STATISTICS_0 lpStat)
/*++
    Description:
        copies the statistics data from the server statistcs structure
        to the FTP_STATISTICS_0 structure for RPC access.

    Arugments:
        lpStat  pointer to FTP_STATISTICS_0 object which contains the 
                data on successful return

    Returns:
        Win32 error codes. NO_ERROR on success. 

--*/
{

    DBG_ASSERT( lpStat != NULL);

    LockStatistics();

    CopyMemory( lpStat, &m_FTPStats, sizeof(FTP_STATISTICS_0) );

    if (lpStat->ServiceUptime)
    {
        lpStat->ServiceUptime = GetCurrentTimeInSeconds() - lpStat->ServiceUptime;
    }

    UnlockStatistics();

    return ( NO_ERROR);

} // CopyToStatsBuffer()


// gets currenttime and stores it inside stats structure
void 
FTP_SERVER_STATISTICS::UpdateStartTime()
{
    m_FTPStats.ServiceUptime = GetCurrentTimeInSeconds();
}



void 
FTP_SERVER_STATISTICS::UpdateStopTime()
{
    m_FTPStats.ServiceUptime = 0;
}


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\sockutil.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    sockutil.cxx

    This module contains utility routines for managing & manipulating
    sockets.

    Functions exported by this module:

        InitializeSockets
        TerminateSockets
        CreateDataSocket
        CreateFtpdSocket
        CloseSocket
        ResetSocket
        AcceptSocket
        SockSend
        SockRecv
        SockPrintf2
        ReplyToUser()
        SockReadLine
        SockMultilineMessage2



    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     April-1995 Misc modifications (removed usage of various
                                  socket functions/modified them)

*/


#include "ftpdp.hxx"


//
//  Private constants.
//

#define DEFAULT_BUFFER_SIZE     4096    // bytes

//
//  Private globals.
//


//
//  Private prototypes.
//

SOCKERR
vSockPrintf(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPCSTR      pszFormat,
    va_list     args
    );

SOCKERR
vSockReply(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    UINT        ReplyCode,
    CHAR        chSeparator,
    LPCSTR      pszFormat,
    va_list     args
    );

BOOL
vTelnetEscapeIAC(
    PCHAR       pszBuffer,
    PINT        pcchBufChars,
    INT         ccbMaxLen
    );

//
//  Public functions.
//


/*******************************************************************

    NAME:       CreateDataSocket

    SYNOPSIS:   Creates a data socket for the specified address & port.

    ENTRY:      psock - Will receive the new socket ID if successful.

                addrLocal - The local Internet address for the socket
                    in network byte order.

                portLocal - The local port for the socket in network
                    byte order.

                addrRemote - The remote Internet address for the socket
                    in network byte order.

                portRemote - The remote port for the socket in network
                    byte order.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     10-Mar-1993 Created.
        KeithMo     07-Sep-1993 Enable SO_REUSEADDR.

********************************************************************/
SOCKERR
CreateDataSocket(
    SOCKET * psock,
    ULONG    addrLocal,
    PORT     portLocal,
    ULONG    addrRemote,
    PORT     portRemote
    )
{
    SOCKET      sNew = INVALID_SOCKET;
    SOCKERR     serr = 0;
    SOCKADDR_IN sockAddr;

    //
    //  Just to be paranoid...
    //

    DBG_ASSERT( psock != NULL );
    *psock = INVALID_SOCKET;

    //
    //  Create the socket.
    //

    sNew = WSASocketW(AF_INET,
                      SOCK_STREAM,
                      IPPROTO_TCP,
                      NULL,
                      0,
                      WSA_FLAG_OVERLAPPED);

    serr = ( sNew == INVALID_SOCKET ) ? WSAGetLastError() : 0;

    if( serr == 0 )
    {
        BOOL fReuseAddr = TRUE;

        //
        //  Since we always bind to the same local port,
        //  allow the reuse of address/port pairs.
        //

        if( setsockopt( sNew,
                        SOL_SOCKET,
                        SO_REUSEADDR,
                        (CHAR *)&fReuseAddr,
                        sizeof(fReuseAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Bind the local internet address & port to the socket.
        //

        sockAddr.sin_family      = AF_INET;
        sockAddr.sin_addr.s_addr = addrLocal;
        sockAddr.sin_port        = portLocal;

        if( bind( sNew, (SOCKADDR *)&sockAddr, sizeof(sockAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Connect to the remote internet address & port.
        //

        sockAddr.sin_family      = AF_INET;
        sockAddr.sin_addr.s_addr = addrRemote;
        sockAddr.sin_port        = portRemote;

        if( connect( sNew, (SOCKADDR *)&sockAddr, sizeof(sockAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Success!  Return the socket to the caller.
        //

        DBG_ASSERT( sNew != INVALID_SOCKET );
        *psock = sNew;

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "data socket %d connected from (%08lX,%04X) to (%08lX,%04X)\n",
                        sNew,
                        ntohl( addrLocal ),
                        ntohs( portLocal ),
                        ntohl( addrRemote ),
                        ntohs( portRemote ) ));
        }
    }
    else
    {
        //
        //  Something fatal happened.  Close the socket if
        //  managed to actually open it.
        //

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "no data socket from (%08lX,%04X) to (%08lX, %04X), error %d\n",
                        ntohl( addrLocal ),
                        ntohs( portLocal ),
                        ntohl( addrRemote ),
                        ntohs( portRemote ),
                        serr ));

        }

        if( sNew != INVALID_SOCKET )
        {
            ResetSocket( sNew );
        }
    }

    return serr;

}   // CreateDataSocket




/*******************************************************************

    NAME:       CreateFtpdSocket

    SYNOPSIS:   Creates a new socket at the FTPD port.
                  This will be used by the passive data transfer.

    ENTRY:      psock - Will receive the new socket ID if successful.

                addrLocal - The lcoal Internet address for the socket
                    in network byte order.

                portLocal - The local port for the socket in network
                    byte order.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     08-Mar-1993 Created.

********************************************************************/
SOCKERR
CreateFtpdSocket(
    SOCKET * psock,
    ULONG    addrLocal,
    PORT     portLocal,
    FTP_SERVER_INSTANCE *pInstance
    )
{
    SOCKET  sNew = INVALID_SOCKET;
    SOCKERR serr = 0;

    //
    //  Just to be paranoid...
    //

    DBG_ASSERT( psock != NULL );
    *psock = INVALID_SOCKET;

    //
    //  Create the connection socket.
    //

    sNew = WSASocketW(AF_INET,
                      SOCK_STREAM,
                      IPPROTO_TCP,
                      NULL,
                      0,
                      WSA_FLAG_OVERLAPPED);


    serr = ( sNew == INVALID_SOCKET ) ? WSAGetLastError() : 0;

    if( serr == 0 )
    {
        BOOL fReuseAddr = FALSE;

        //
        //  Muck around with the socket options a bit.
        //  Berkeley FTPD does this.
        //

        if( setsockopt( sNew,
                        SOL_SOCKET,
                        SO_REUSEADDR,
                        (CHAR *)&fReuseAddr,
                        sizeof(fReuseAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        SOCKADDR_IN sockAddr;

        //
        //  Bind an address to the socket.
        //

        sockAddr.sin_family      = AF_INET;
        sockAddr.sin_addr.s_addr = addrLocal;
        sockAddr.sin_port        = portLocal;

        if( bind( sNew, (SOCKADDR *)&sockAddr, sizeof(sockAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Put the socket into listen mode.
        //

        if( listen( sNew, (INT)pInstance->NumListenBacklog()) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Success!  Return the socket to the caller.
        //

        DBG_ASSERT( sNew != INVALID_SOCKET );
        *psock = sNew;

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "connection socket %d created at (%08lX,%04X)\n",
                        sNew,
                        ntohl( addrLocal ),
                        ntohs( portLocal ) ));
        }
    }
    else
    {
        //
        //  Something fatal happened.  Close the socket if
        //  managed to actually open it.
        //

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "no connection socket at (%08lX, %04X), error %d\n",
                        ntohl( addrLocal ),
                        ntohs( portLocal ),
                        serr ));

        }

        if( sNew != INVALID_SOCKET )
        {
            ResetSocket( sNew );
        }
    }

    return serr;

}   // CreateFtpdSocket



/*******************************************************************

    NAME:       CloseSocket

    SYNOPSIS:   Closes the specified socket.  This is just a thin
                wrapper around the "real" closesocket() API.

    ENTRY:      sock - The socket to close.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     26-Apr-1993 Created.

********************************************************************/
SOCKERR
CloseSocket(
    SOCKET sock
    )
{
    SOCKERR serr = 0;

    //
    //  Close the socket.
    //

    if( closesocket( sock ) != 0 )
    {
        serr = WSAGetLastError();
    }

    IF_DEBUG( SOCKETS )
    {
        if( serr == 0 )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "closed socket %d\n",
                        sock ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot close socket %d, error %d\n",
                        sock,
                        serr ));
        }
    }

    return serr;

}   // CloseSocket


/*******************************************************************

    NAME:       ResetSocket

    SYNOPSIS:   Performs a "hard" close on the given socket.

    ENTRY:      sock - The socket to close.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     08-Mar-1993 Created.

********************************************************************/
SOCKERR
ResetSocket(
    SOCKET sock
    )
{
    SOCKERR serr = 0;
    LINGER  linger;

    //
    //  Enable linger with a timeout of zero.  This will
    //  force the hard close when we call closesocket().
    //
    //  We ignore the error return from setsockopt.  If it
    //  fails, we'll just try to close the socket anyway.
    //

    linger.l_onoff  = TRUE;
    linger.l_linger = 0;

    setsockopt( sock,
                SOL_SOCKET,
                SO_LINGER,
                (CHAR *)&linger,
                sizeof(linger) );

    //
    //  Close the socket.
    //

    if( closesocket( sock ) != 0 )
    {
        serr = WSAGetLastError();
    }

    IF_DEBUG( SOCKETS )
    {
        if( serr == 0 )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "reset socket %d\n",
                        sock ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot reset socket %d, error %d\n",
                        sock,
                        serr ));
        }
    }

    return serr;

}   // ResetSocket



/*******************************************************************

    NAME:       AcceptSocket

    SYNOPSIS:   Waits for a connection to the specified socket.
                The socket is assumed to be "listening".

    ENTRY:      sockListen - The socket to accept on.

                psockNew - Will receive the newly "accepted" socket
                    if successful.

                paddr - Will receive the client's network address.

                fEnforceTimeout - If TRUE, this routine will enforce
                    the idle-client timeout.  If FALSE, no timeouts
                    are enforced (and this routine may block
                    indefinitely).

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     27-Apr-1993 Created.

********************************************************************/
SOCKERR
AcceptSocket(
    SOCKET          sockListen,
    SOCKET *        psockNew,
    LPSOCKADDR_IN   paddr,
    BOOL            fEnforceTimeout,
    FTP_SERVER_INSTANCE *pInstance
    )
{
    SOCKERR serr    = 0;
    SOCKET  sockNew = INVALID_SOCKET;
    BOOL    fRead = FALSE;

    DBG_ASSERT( psockNew != NULL );
    DBG_ASSERT( paddr != NULL );

    if( fEnforceTimeout ) {

        //
        //  Timeouts are to be enforced, so wait for a connection
        //  to the socket.
        //

        serr = WaitForSocketWorker(
                            sockListen,
                            INVALID_SOCKET,
                            &fRead,
                            NULL,
                            pInstance->QueryConnectionTimeout()
                            );
    }

    if( serr == 0 )
    {
        INT cbAddr = sizeof(SOCKADDR_IN);

        //
        //  Wait for the actual connection.
        //

        sockNew = accept( sockListen, (SOCKADDR *)paddr, &cbAddr );

        if( sockNew == INVALID_SOCKET )
        {
            serr = WSAGetLastError();
        }
    }

    //
    //  Return the (potentially invalid) socket to the caller.
    //

    *psockNew = sockNew;

    return serr;

}   // AcceptSocket



/*******************************************************************

    NAME:       SockSend

    SYNOPSIS:   Sends a block of bytes to a specified socket.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pBuffer - Contains the data to send.

                cbBuffer - The size (in bytes) of the buffer.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     13-Mar-1993 Created.

********************************************************************/
SOCKERR
SockSend(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPVOID      pBuffer,
    DWORD       cbBuffer
    )
{
    SOCKERR     serr = 0;
    INT         cbSent;
    DWORD       dwBytesSent = 0;

    DBG_ASSERT( pBuffer != NULL );

    //
    //  Loop until there's no more data to send.
    //

    while( cbBuffer > 0 ) {

        //
        //  Wait for the socket to become writeable.
        //
        BOOL  fWrite = FALSE;

        serr = WaitForSocketWorker(
                        INVALID_SOCKET,
                        sock,
                        NULL,
                        &fWrite,
                        (pUserData != NULL) ?
                            pUserData->QueryInstance()->QueryConnectionTimeout():
                            FTP_DEF_SEND_TIMEOUT
                        );

        if( serr == 0 )
        {
            //
            //  Write a block to the socket.
            //

            cbSent = send( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

            if( cbSent < 0 )
            {
                //
                //  Socket error.
                //

                serr = WSAGetLastError();
            }
            else
            {
                dwBytesSent += (DWORD)cbSent;

                IF_DEBUG( SEND )
                {
                    if( pUserData && TEST_UF( pUserData, TRANSFER ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "send %d bytes @%p to socket %d\n",
                                    cbSent,
                                    pBuffer,
                                    sock ));
                    }
                }
            }
        }


        // added a check for special case when we are sending and thinking that we are sending
        // synchronoulsy on socket which was set to non blocking mode. In that case when buffer space
        // in winsock becomes exhausted send return WSAEWOULDBLOCK. So then we just retry.

        if ( serr != WSAEWOULDBLOCK )
        {
            if( serr != 0 )
            {
                break;
            }

            pBuffer   = (LPVOID)( (LPBYTE)pBuffer + cbSent );
            cbBuffer -= (DWORD)cbSent;
        }
    }

    if( serr != 0 )
    {
        IF_DEBUG( SEND )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "socket error %d during send on socket %d.\n",
                        serr,
                        sock));
        }
    }

    if( pUserData != NULL ) {
        pUserData->QueryInstance()->QueryStatsObj()->UpdateTotalBytesSent(
                                                                dwBytesSent );
    }

    return serr;

}   // SockSend



/*******************************************************************

    NAME:       SockRecv

    SYNOPSIS:   Receives a block of bytes from a specified socket.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pBuffer - Will receive the data.

                cbBuffer - The size (in bytes) of the buffer.

                pbReceived - Will receive the actual number of bytes
                    received.  This value is undefined if this function
                    fails.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     13-Mar-1993 Created.

********************************************************************/
SOCKERR
SockRecv(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPVOID      pBuffer,
    DWORD       cbBuffer,
    LPDWORD     pbReceived
    )
{
    SOCKERR     serr = 0;
    DWORD       cbTotal = 0;
    INT         cbReceived;
    DWORD       dwBytesRecv = 0;

    DBG_ASSERT( pBuffer != NULL );
    DBG_ASSERT( pbReceived != NULL );

    //
    //  Loop until the buffer's full.
    //

    while (cbBuffer > 0) {

        BOOL fRead = FALSE;

        //
        //  Wait for the socket to become readable.
        //

        serr = WaitForSocketWorker(
                            sock,
                            INVALID_SOCKET,
                            &fRead,
                            NULL,
                            (pUserData != NULL) ?
                                pUserData->QueryInstance()->QueryConnectionTimeout():
                                FTP_DEF_RECV_TIMEOUT
                            );

        if( serr == 0 )
        {
            //
            //  Read a block from the socket.
            //
            DBG_ASSERT( fRead);

            cbReceived = recv( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

            if( cbReceived < 0 )
            {
                //
                //  Socket error.
                //

                serr = WSAGetLastError();
            }
            else
            {
                dwBytesRecv += (DWORD)cbReceived;

                IF_DEBUG( RECV )
                {
                    if( pUserData && TEST_UF( pUserData, TRANSFER ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "received %d bytes @%p from socket %d\n",
                                    cbReceived,
                                    pBuffer,
                                    sock ));
                    }
                }
            }
        }

        if( ( serr != 0 ) || ( cbReceived == 0 ) )
        {
            //
            //  End of file, socket closed, timeout, or socket error.
            //

            break;
        }

        pBuffer   = (LPVOID)( (LPBYTE)pBuffer + cbReceived );
        cbBuffer -= (DWORD)cbReceived;
        cbTotal  += (DWORD)cbReceived;
    }

    if( serr == 0 )
    {
        //
        //  Return total byte count to caller.
        //

        *pbReceived = cbTotal;
    }
    else
    {
        IF_DEBUG( RECV )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "socket error %d during recv on socket %d\n",
                        serr,
                        sock ));
        }
    }

    if( pUserData != NULL ) {
        pUserData->QueryInstance()->QueryStatsObj()->UpdateTotalBytesReceived(
                                                                dwBytesRecv );
    }

    return serr;

}   // SockRecv



/*******************************************************************

    NAME:       SockPrintf2

    SYNOPSIS:   Send a formatted string to a specific socket.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pszFormat - A printf-style format string.

                ... - Any other parameters needed by the format string.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     10-Mar-1993 Created.

********************************************************************/
SOCKERR
__cdecl
SockPrintf2(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPCSTR      pszFormat,
    ...
    )
{
    va_list ArgPtr;
    SOCKERR serr;

    //
    //  Let the worker do the dirty work.
    //

    va_start( ArgPtr, pszFormat );

    serr = vSockPrintf( pUserData,
                        sock,
                        pszFormat,
                        ArgPtr );

    va_end( ArgPtr );

    return serr;

}   // SockPrintf2



SOCKERR
__cdecl
ReplyToUser(
    IN LPUSER_DATA pUserData,
    IN UINT        ReplyCode,
    IN LPCSTR      pszFormat,
    ...
    )
/*++

  This function sends an FTP reply to the user data object. The reply
   is usually sent over the control socket.

  Arguments:
     pUserData    pointer to UserData object initiating the reply
     ReplyCode    One of the REPLY_* manifests.
     pszFormat    pointer to null-terminated string containing the format
     ...          additional paramters if any required.

  Returns:
     SOCKET error code. 0 on success and !0 on failure.

  History:
     MuraliK
--*/
{
    va_list ArgPtr;
    SOCKERR serr;

    DBG_ASSERT( pUserData != NULL);

    pUserData->SetLastReplyCode( ReplyCode );

    if ( pUserData->QueryControlSocket() != INVALID_SOCKET) {

        //
        //  Let the worker do the dirty work.
        //

        va_start( ArgPtr, pszFormat );

        serr = vSockReply( pUserData,
                          pUserData->QueryControlSocket(),
                          ReplyCode,
                          ' ',
                          pszFormat,
                          ArgPtr );

        va_end( ArgPtr );
    } else {

        serr = WSAECONNABORTED;
    }


    return serr;

}   // ReplyToUser()


// Private functions

/*******************************************************************

    NAME:       vSockPrintf

    SYNOPSIS:   Worker function for printf-to-socket functions.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pszFormat - The format string.

                args - Variable number of arguments.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     17-Mar-1993 Created.

********************************************************************/
SOCKERR
vSockPrintf(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPCSTR      pszFormat,
    va_list     args
    )
{
    INT     cchBuffer = 0;
    INT     buffMaxLen;
    SOCKERR serr = 0;
    CHAR    szBuffer[MAX_REPLY_LENGTH];

    DBG_ASSERT( pszFormat != NULL );

    //
    //  Render the format into our local buffer.
    //


    DBG_ASSERT( MAX_REPLY_LENGTH > 3);
    buffMaxLen = MAX_REPLY_LENGTH - 3;
    cchBuffer = _vsnprintf( szBuffer,
                           buffMaxLen,
                           pszFormat, args );
    //
    // The string length is long, we get back -1.
    //   so we get the string length for partial data.
    //

    if ( cchBuffer == -1 ) {

        //
        // terminate the string properly,
        //   since _vsnprintf() does not terminate properly on failure.
        //
        cchBuffer = buffMaxLen;
        szBuffer[ buffMaxLen] = '\0';
    }

    IF_DEBUG( SOCKETS ) {
        DBGPRINTF(( DBG_CONTEXT, "sending '%s'\n", szBuffer ));
    }

    //
    // Escape all telnet IAC bytes with a second IAC
    //
    vTelnetEscapeIAC( szBuffer, &cchBuffer, MAX_REPLY_LENGTH - 3 );

    strcpy( szBuffer + cchBuffer, "\r\n" );
    cchBuffer += 2;

    //
    //  Blast it out to the client.
    //

    serr = SockSend( pUserData, sock, szBuffer, cchBuffer );
    return serr;

} // vSockPrintf



/*******************************************************************

    NAME:       vSockReply

    SYNOPSIS:   Worker function for reply functions.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                ReplyCode - A three digit reply code from RFC 959.

                chSeparator - Should be either ' ' (normal reply) or
                    '-' (first line of multi-line reply).

                pszFormat - The format string.

                args - Variable number of arguments.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     17-Mar-1993 Created.

********************************************************************/
SOCKERR
vSockReply(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    UINT        ReplyCode,
    CHAR        chSeparator,
    LPCSTR      pszFormat,
    va_list     args
    )
{
    INT     cchBuffer;
    INT     cchBuffer1;
    INT     buffMaxLen;
    SOCKERR serr = 0;
    CHAR    szBuffer[MAX_REPLY_LENGTH];

    DBG_ASSERT( ( ReplyCode >= 100 ) && ( ReplyCode < 600 ) );

    //
    //  Render the format into our local buffer.
    //

    cchBuffer = wsprintfA( szBuffer,
                          "%u%c",
                          ReplyCode,
                          chSeparator );

    DBG_ASSERT( MAX_REPLY_LENGTH > cchBuffer + 3);
    buffMaxLen = MAX_REPLY_LENGTH - cchBuffer - 3;
    cchBuffer1 = _vsnprintf( szBuffer + cchBuffer,
                            buffMaxLen,
                            pszFormat, args );
    //
    // The string length is long, we get back -1.
    //   so we get the string length for partial data.
    //

    if ( cchBuffer1 == -1 ) {

        //
        // terminate the string properly,
        //   since _vsnprintf() does not terminate properly on failure.
        //
        cchBuffer = buffMaxLen;
        szBuffer[ buffMaxLen] = '\0';
    } else {

        cchBuffer += cchBuffer1;
    }

    IF_DEBUG( SOCKETS ) {
        DBGPRINTF(( DBG_CONTEXT, "sending '%s'\n",szBuffer ));
    }

    //
    // Escape all telnet IAC bytes with a second IAC
    //
    vTelnetEscapeIAC( szBuffer, &cchBuffer, MAX_REPLY_LENGTH - 3 );

    strcpy( szBuffer + cchBuffer, "\r\n" );
    cchBuffer += 2;

    //
    //  Blast it out to the client.
    //

    serr = SockSend( pUserData, sock, szBuffer, cchBuffer );

    return serr;

}   // vSockReply


DWORD
FtpFormatResponseMessage( IN UINT     uiReplyCode,
                          IN LPCTSTR  pszReplyMsg,
                          OUT LPTSTR  pszReplyBuffer,
                          IN DWORD    cchReplyBuffer)
/*++
  This function formats the message to be sent to the client,
    given the reply code and the message to be sent.

  The formatting function takes care of the reply buffer length
    and ensures the safe write of data. If the reply buffer is
    not sufficient to hold the entire message, the reply msg is trunctaed.

  Arguments:
    uiReplyCode   reply code to be used.
    pszReplyMsg   pointer to string containing the reply message
    pszReplyBuffer pointer to character buffer where the reply message
                   can be sent.
    cchReplyBuffer character count for the length of reply buffer.

  Returns:
    length of the data written to the reply buffer.

--*/
{
    DWORD len;

    DBG_ASSERT( pszReplyMsg != NULL && pszReplyBuffer != NULL);

    len = lstrlen( pszReplyMsg) + 10;   // 10 chars are required for aux info.

    if ( len >= cchReplyBuffer) {

        // truncate the message since length is too high.

        len = wsprintf( pszReplyBuffer, TEXT("%u \r\n"),
                        uiReplyCode);

        DBG_ASSERT( len >= 3);  // length greater than formatting string
        DBG_ASSERT( len < cchReplyBuffer);

        lstrcpyn( pszReplyBuffer + len, pszReplyMsg, cchReplyBuffer - len);

        len = lstrlen( pszReplyBuffer);
        DBG_ASSERT( len < cchReplyBuffer);

    } else {

        len = wsprintf( pszReplyBuffer, TEXT("%u %s\r\n"),
                        uiReplyCode,
                        pszReplyMsg);
        DBG_ASSERT( len >= 4);
        DBG_ASSERT( len <= cchReplyBuffer);
    }

    return (len);
} // FtpFormatResponseMessage()


/*******************************************************************

    NAME:       vTelnetEscapeIAC

    SYNOPSIS:   replace (in place) all 0xFF bytes in a buffer with 0xFF 0xFF.
                This is the TELNET escape sequence for an IAC value data byte.

    ENTRY:      pszBuffer - data buffer.

                pcchBufChars - on entry, current number of chars in buffer.
                               on return, number of chars in buffer.

                cchMaxLen - maximum characters in the output buffer

    RETURNS:    TRUE - success, FALSE - overflow.

    HISTORY:
        RobSol     25-April-2001 Created.

********************************************************************/
BOOL
vTelnetEscapeIAC( IN OUT PCHAR pszBuffer,
                  IN OUT PINT  pcchBufChars,
                  IN     INT   cchMaxLen)
{

#   define CHAR_IAC ((CHAR)(-1))

    PCHAR  pszFirstIAC;
    PCHAR  pSrc, pDst;
    BOOL   fReturn = TRUE;
    CHAR   szBuf[MAX_REPLY_LENGTH];
    INT    cCharsInDst;

    DBG_ASSERT( pszBuffer );
    DBG_ASSERT( pcchBufChars );
    DBG_ASSERT( cchMaxLen <= MAX_REPLY_LENGTH );

    if ((pszFirstIAC = strchr( pszBuffer, CHAR_IAC)) == NULL) {

        //
        // no IAC - return.
        //

        return TRUE;
    }

    //
    // we'll expand the string into a temp buffer, then copy back.
    //

    pSrc = pszFirstIAC;
    pDst = szBuf;
    cCharsInDst = DIFF(pszFirstIAC - pszBuffer);

    do {
       if (*pSrc == CHAR_IAC) {

          //
          // this is a char to escape
          //

          if ((cCharsInDst + 1) < cchMaxLen) {

              //
              // we have space to escape the char, so do it.
              //

              cCharsInDst++;
              *pDst++ = CHAR_IAC;
          } else {

              //
              // overflow.
              //

              fReturn = FALSE;
              break;
          }
       }

       *pDst++ = *pSrc++;

    } while ((++cCharsInDst < cchMaxLen) && (*pSrc != '\0'));

    //
    // copy the expanded data back into the input buffer and terminate the string
    //

    memcpy( pszFirstIAC, szBuf, pDst - szBuf);
    pszBuffer[ cCharsInDst ] = '\0';

    *pcchBufChars = cCharsInDst;

    return fReturn;
}

/************************ End of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\utility.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    utility.cxx

    This module contains routines of general utility.

    Functions exported by this module:

        TransferType
        TransferMode
        DisplayBool
        IsDecimalNumber
        AllocErrorText
        FreeErrorText
        OpenDosPath
        FlipSlashes
        OpenLogFile
        P_strncpy


    FILE HISTORY:
        KeithMo     17-Mar-1993 Created.

*/


#include "ftpdp.hxx"

extern "C" {

    # include <ntlsa.h>
};

//
//  Public functions.
//

/*******************************************************************

    NAME:       TransferType

    SYNOPSIS:   Generates printable form of a transfer type.

    ENTRY:      type - From the XFER_TYPE enumerator.

    RETURNS:    CHAR * - "ASCII", "BINARY", etc.

    HISTORY:
        KeithMo     12-Mar-1993 Created.

********************************************************************/
CHAR *
TransferType(
    XFER_TYPE type
    )
{
    CHAR * pszResult = NULL;

    switch( type )
    {
    case XferTypeAscii :
        pszResult = "ASCII";
        break;

    case XferTypeBinary :
        pszResult = "BINARY";
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT,
                    "invalid transfer type %d\n",
                    type ));
        DBG_ASSERT( FALSE );
        pszResult = "ASCII";
        break;
    }

    DBG_ASSERT( pszResult != NULL );

    return pszResult;

}   // TransferType

/*******************************************************************

    NAME:       TransferMode

    SYNOPSIS:   Generates printable form of a transfer mode.

    ENTRY:      mode - From the XFER_MODE enumerator.

    RETURNS:    CHAR * - "STREAM", "BLOCK", etc.

    NOTES:      Currently, only the STREAM mode is suppored.

    HISTORY:
        KeithMo     12-Mar-1993 Created.

********************************************************************/
CHAR *
TransferMode(
    XFER_MODE mode
    )
{
    CHAR * pszResult = NULL;

    switch( mode )
    {
    case XferModeStream :
        pszResult = "STREAM";
        break;

    case XferModeBlock :
        pszResult = "BLOCK";
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT,
                    "invalid transfer mode %d\n",
                    mode ));
        DBG_ASSERT( FALSE );
        pszResult = "STREAM";
        break;
    }

    DBG_ASSERT( pszResult != NULL );

    return pszResult;

}   // TransferMode

/*******************************************************************

    NAME:       DisplayBool

    SYNOPSIS:   Generates printable form of a boolean.

    ENTRY:      fFlag - The BOOL to display.

    RETURNS:    CHAR * - "TRUE" or "FALSE".

    HISTORY:
        KeithMo     17-Mar-1993 Created.

********************************************************************/
CHAR *
DisplayBool(
    BOOL fFlag
    )
{
    return fFlag ? "TRUE" : "FALSE";

}   // DisplayBool

/*******************************************************************

    NAME:       IsDecimalNumber

    SYNOPSIS:   Determines if a given string represents a decimal
                number.

    ENTRY:      psz - The string to scan.

    RETURNS:    BOOL - TRUE if this is a decimal number, FALSE
                    otherwise.

    HISTORY:
        KeithMo     12-Mar-1993 Created.

********************************************************************/
BOOL
IsDecimalNumber(
    CHAR * psz
    )
{
    BOOL fResult = ( *psz != '\0' );
    CHAR ch;

    while( ch = *psz++ )
    {
        if( ( ch < '0' ) || ( ch > '9' ) )
        {
            fResult = FALSE;
            break;
        }
    }

    return fResult;

}   // IsDecimalNumber

/*******************************************************************

    NAME:       AllocErrorText

    SYNOPSIS:   Maps a specified Win32 error code to a textual
                description.  In the interest of multithreaded
                safety, this routine will allocate a block of memory
                to contain the text and return a pointer to that
                block.  It is up to the caller to free the block
                with FreeErrorText.

    ENTRY:      err - The error to map.

    RETURNS:    CHAR * - A textual description of err.  Will be NULL
                    if an error occurred while mapping err to text.

    HISTORY:
        KeithMo     27-Apr-1993 Created.

********************************************************************/
CHAR *
AllocErrorText(
    APIERR err
    )
{
    APIERR   fmerr   = NO_ERROR;
    CHAR   * pszText = NULL;

    if( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER
                           | FORMAT_MESSAGE_IGNORE_INSERTS
                           | FORMAT_MESSAGE_FROM_SYSTEM
                           | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                       NULL,
                       (DWORD)err,
                       g_pInetSvc->IsSystemDBCS()   // always use english for
                           ? 0x409                  // FarEast NT system
                           : 0,
                       (LPTSTR)&pszText,
                       0,
                       NULL ) == 0 )
    {
        fmerr = GetLastError();
    }
    else
    {

    }

    IF_DEBUG( COMMANDS )
    {
        if( fmerr == NO_ERROR )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "mapped error %lu to %s\n",
                        err,
                        pszText ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot map error %lu to text, error %lu\n",
                        err,
                        fmerr ));
        }
    }

    return pszText;

}   // AllocErrorText

/*******************************************************************

    NAME:       FreeErrorText

    SYNOPSIS:   Frees the pointer returned by AllocErrorText.

    ENTRY:      pszText - The text to free.  Must be a pointer
                    returned by AllocErrorText.

    HISTORY:
        KeithMo     27-Apr-1993 Created.

********************************************************************/
VOID
FreeErrorText(
    CHAR * pszText
    )
{
    LocalFree( (HLOCAL)pszText );

}   // FreeErrorText




DWORD
OpenPathForAccess(
    LPHANDLE    phFile,
    LPSTR       pszPath,
    ULONG       DesiredAccess,
    ULONG       ShareAccess,
    HANDLE      hImpersonation
    )
/*++
  This function opens a path for access to do some verification
    or holding on to the file/directory when a user is logged on.

  Arguments:
    phFile   - pointer to handle, where a handle is stored on
                successful return.

    pszPath  - pointer to null terminated string containing the path
                for path to be opened.

    DesiredAccess - Access type to the file.

    ShareAccess - access flags for shared opens.

    hImpersonation - Impersonation token for this user - used for
                      long filename check

  Returns:
     Win32 error code - NO_ERROR on success

  Author:
     MuraliK  14-Nov-1995
--*/
{
    DWORD  dwError = NO_ERROR;

    if ( phFile == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }

    *phFile = CreateFile( pszPath,        // path for the file
                         DesiredAccess,   // fdwAccess
                         ShareAccess,     // fdwShareMode
                         NULL,            // Security attributes
                         OPEN_EXISTING,   // fdwCreate
                         FILE_FLAG_BACKUP_SEMANTICS,  // fdwAttrsAndFlags
                         NULL );          // hTemplateFile

    if ( *phFile == INVALID_HANDLE_VALUE) {

        dwError = GetLastError();
    }
    else {

        if ( strchr( pszPath, '~' )) {

            BOOL  fShort;

            RevertToSelf();

            dwError = CheckIfShortFileName( (UCHAR *) pszPath,
                                            hImpersonation,
                                            &fShort );

            if ( !dwError && fShort )
            {
                dwError = ERROR_FILE_NOT_FOUND;
                DBG_REQUIRE( CloseHandle( *phFile ));
                *phFile = INVALID_HANDLE_VALUE;
            }
        }
    }

    return ( dwError);

} // OpenPathForAccess()



/*******************************************************************

    NAME:       FlipSlashes

    SYNOPSIS:   Flips the DOS-ish backslashes ('\') into Unix-ish
                forward slashes ('/').

    ENTRY:      pszPath - The path to munge.

    RETURNS:    CHAR * - pszPath.

    HISTORY:
        KeithMo     04-Jun-1993 Created.

********************************************************************/
CHAR *
FlipSlashes(
    CHAR * pszPath
    )
{
    CHAR   ch;
    CHAR * pszScan = pszPath;

    while( ( ch = *pszScan ) != '\0' )
    {
        //
        //  skip DBCS character
        //
        if ( IsDBCSLeadByte( ch ) && *(pszScan+1) )
        {
            pszScan++;
        }
        else
        if( ch == '\\' )
        {
            *pszScan = '/';
        }

        pszScan++;
    }

    return pszPath;

}   // FlipSlashes

//
//  Private functions.
//


/*******************************************************************

    NAME:

    SYNOPSIS:   strncpy, that always terminates with a '\0'

    ENTRY:      same as strncpy.

    RETURNS:    same as strncpy.

    HISTORY:
        RobSol     02-Apr-2001 Created.

********************************************************************/
PSTR
P_strncpy(
    PSTR dst,
    PCSTR src,
    DWORD cnt)
{
    strncpy( dst, src, cnt);

    dst[ cnt - 1] = '\0';

    return dst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\virtual.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    virtual.cxx

    This module contains the virtual I/O package.

    Under Win32, the "current directory" is an attribute of a process,
    not a thread.  This causes some grief for the FTPD service, since
    it is impersonating users on the server side.  The users must
    "think" they can change current directory at will.  We'll provide
    this behaviour in this package.

    Functions exported by this module:

        VirtualCreateFile
        VirtualCreateUniqueFile
        Virtual_fopen

        VirtualDeleteFile
        VirtualRenameFile
        VirtualChDir
        VirtualRmDir
        VirtualMkDir


    FILE HISTORY:
        KeithMo     09-Mar-1993 Created.

        MuraliK     28-Mar-1995 Enabled FILE_FLAG_OVERLAPPED in OpenFile()
        MuraliK     28-Apr-1995 modified to use new canonicalization
                    11-May-1995 made parameters to be const unless otherwise
                                required.
                    12-May-1995 eliminated the old log file access

*/


#include "ftpdp.hxx"


//
//  Private prototypes.
//

VOID
VirtualpSanitizePath(
    CHAR * pszPath
    );



//
//  Public functions.
//



/*******************************************************************

    NAME:       VirtualCreateFile

    SYNOPSIS:   Creates a new (or overwrites an existing) file.
                Also handles moving the file pointer and truncating the
                file in the case of a REST command sequence.

    ENTRY:      pUserData - The user initiating the request.

                phFile - Will receive the file handle.  Will be
                    INVALID_HANDLE_VALUE if an error occurs.

                pszFile - The name of the new file.

                fAppend - If TRUE, and pszFile already exists, then
                    append to the existing file.  Otherwise, create
                    a new file.  Note that FALSE will ALWAYS create
                    a new file, potentially overwriting an existing
                    file.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.
        MuraliK     28-Apr-1995 modified to use new canonicalization

********************************************************************/
APIERR
VirtualCreateFile(
    USER_DATA * pUserData,
    HANDLE    * phFile,
    LPSTR       pszFile,
    BOOL        fAppend
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    APIERR err;
    CHAR   szCanonPath[MAX_PATH];
    DWORD  cbSize = MAX_PATH;
    DWORD  dwOffset;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( phFile != NULL );
    DBG_ASSERT( pszFile != NULL );

    dwOffset = pUserData->QueryCurrentOffset();

    // We'll want to do pretty much the same thing whether we're
    // actually appending or just starting at an offset due to a REST
    // command, so combine them here.

    fAppend = fAppend || (dwOffset != 0);

    err = pUserData->VirtualCanonicalize(szCanonPath,
                                         &cbSize,
                                         pszFile,
                                         AccessTypeCreate );

    if( err == NO_ERROR ) {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "creating %s\n", szCanonPath ));
        }

        if ( pUserData->ImpersonateUser()) {

            hFile = CreateFile( szCanonPath,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );
            //
            //  Disallow usage of short names
            //

            pUserData->RevertToSelf();

            if ( hFile != INVALID_HANDLE_VALUE )
            {
                if ( GetFileType( hFile ) != FILE_TYPE_DISK )
                {
                    DBG_REQUIRE( CloseHandle( hFile ) );
                    SetLastError( ERROR_ACCESS_DENIED );
                    hFile = INVALID_HANDLE_VALUE;
                }
                else if ( strchr( szCanonPath, '~' )) {

                    BOOL  fShort;
                    DWORD err;

                    err = CheckIfShortFileName( (UCHAR *) szCanonPath,
                                                pUserData->QueryImpersonationToken(),
                                                &fShort );

                    if ( !err && fShort ) {

                        err = ERROR_FILE_NOT_FOUND;
                    }

                    if ( err ) {

                        DBG_REQUIRE( CloseHandle( hFile ));
                        hFile = INVALID_HANDLE_VALUE;
                        SetLastError( err );
                    }
                }
            }
        }

        if( hFile == INVALID_HANDLE_VALUE ) {

            err = GetLastError();
        }

        if( fAppend && ( err == NO_ERROR ) ) {

            if (dwOffset == 0) {
                // This is a real append, not a restart sequence.
                if( SetFilePointer( hFile,
                                    0,
                                    NULL,
                                    FILE_END )
                   == (DWORD)-1L ) {

                    err = GetLastError();
                }
            } else {

                // We're in part of a restart sequence. Set the file pointer
                // to the offset, and truncate the file there.

                if (SetFilePointer( hFile,
                                    dwOffset,
                                    NULL,
                                    FILE_BEGIN)
                    == (DWORD)-1L &&
                    (dwOffset != (DWORD)-1L) ) {

                    err = GetLastError();
                }
                else {

                    if (SetEndOfFile( hFile ) == 0) {

                        err = GetLastError();

                    }
                }

            }

            if (err != NO_ERROR ) {

                CloseHandle( hFile );
                hFile = INVALID_HANDLE_VALUE;

            }

        }
    }

    if ( err != NO_ERROR) {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot create %s, error %lu\n",
                        szCanonPath,
                        err ));
        }
    }

    *phFile = hFile;

    return err;

}   // VirtualCreateFile


/*******************************************************************

    NAME:       VirtualCreateUniqueFile

    SYNOPSIS:   Creates a new unique (temporary) file in the current
                    virtual directory.

    ENTRY:      pUserData - The user initiating the request.

                phFile - Will receive the file handle.  Will be
                    INVALID_HANDLE_VALUE if an error occurs.

                pszTmpFile - Will receive the name of the temporary
                    file.  This buffer MUST be at least MAX_PATH
                    characters long.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     16-Mar-1993 Created.
        MuraliK     28-Apr-1995 modified to use new canonicalization

********************************************************************/
APIERR
VirtualCreateUniqueFile(
    USER_DATA * pUserData,
    HANDLE    * phFile,
    LPSTR       pszTmpFile
    )
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    APIERR      err   = NO_ERROR;
    DWORD       cbSize = MAX_PATH;
    CHAR        szCanon[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( phFile != NULL );
    DBG_ASSERT( pszTmpFile != NULL );

    //
    // Obtain the virtual to real path conversion.
    //

    err = pUserData->VirtualCanonicalize(szCanon,
                                         &cbSize,
                                         "", // current directory
                                         AccessTypeCreate);

    if( err == NO_ERROR )
      {
          IF_DEBUG( VIRTUAL_IO ) {

              DBGPRINTF(( DBG_CONTEXT,
                        "creating unique file %s\n", pszTmpFile ));
          }

          if ( pUserData->ImpersonateUser()) {

              if ( GetTempFileName(szCanon,
                                   "FTPD",
                                   0, pszTmpFile ) != 0
                  ) {

                  hFile = CreateFile( pszTmpFile,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL );
              }

              pUserData->RevertToSelf();
          }

          if( hFile == INVALID_HANDLE_VALUE ) {

              err = GetLastError();
          }
      }

    if( err != 0 )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot create unique file, error %lu\n",
                        err ));
        }
    }

    *phFile = hFile;

    return err;

}   // VirtualCreateUniqueFile()



/*******************************************************************

    NAME:       Virtual_fopen

    SYNOPSIS:   Opens an file stream.

    ENTRY:      pUserData - The user initiating the request.

                pszFile - The name of the file to open.

                pszMode - The type of access required.

    RETURNS:    FILE * - The open file stream, NULL if file cannot
                    be opened.

    NOTES:      Since this is only used for accessing the ~FTPSVC~.CKM
                    annotation files, we don't log file accesses here.

    HISTORY:
        KeithMo     07-May-1993 Created.
        MuraliK     28-Apr-1995 modified to use new canonicalization

********************************************************************/
FILE *
Virtual_fopen(
    USER_DATA * pUserData,
    LPSTR       pszFile,
    LPSTR       pszMode
    )
{
    FILE   * pfile = NULL;
    APIERR   err;
    CHAR     szCanonPath[MAX_PATH];
    DWORD    cbSize = MAX_PATH;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszFile != NULL );
    DBG_ASSERT( pszMode != NULL );

    err = pUserData->VirtualCanonicalize(szCanonPath,
                                         &cbSize,
                                         pszFile,
                                         *pszMode == 'r'
                                         ? AccessTypeRead
                                         : AccessTypeWrite );

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "opening %s\n", szCanonPath ));
        }

        if ( pUserData->ImpersonateUser()) {

            pfile = fopen( szCanonPath, pszMode );

            pUserData->RevertToSelf();
        }

        if( pfile == NULL )
        {
            err = ERROR_FILE_NOT_FOUND; // best guess
        }
    }

    IF_DEBUG( VIRTUAL_IO )
    {
        if( err != NO_ERROR )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot open %s, error %lu\n",
                        pszFile,
                        err ));
        }
    }

    return pfile;

}   // Virtual_fopen




/*******************************************************************

    NAME:       VirtualDeleteFile

    SYNOPSIS:   Deletes an existing file.

    ENTRY:      pUserData - The user initiating the request.

                pszFile - The name of the file.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
APIERR
VirtualDeleteFile(
    USER_DATA * pUserData,
    LPSTR       pszFile
    )
{
    APIERR err;
    DWORD  cbSize = MAX_PATH;
    CHAR   szCanonPath[MAX_PATH];
    DWORD  dwAccessMask = 0;

    DBG_ASSERT( pUserData != NULL );

    //
    //  We'll canonicalize the path, asking for *read* access.  If
    //  the path canonicalizes correctly, we'll then try to open the
    //  file to ensure it exists.  Only then will we check for delete
    //  access to the path.  This mumbo-jumbo is necessary to get the
    //  proper error codes if someone trys to delete a nonexistent
    //  file on a read-only volume.
    //

    err = pUserData->VirtualCanonicalize(szCanonPath,
                                         &cbSize,
                                         pszFile,
                                         AccessTypeRead,
                                         &dwAccessMask);

    if( err == NO_ERROR )
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;

        if ( pUserData->ImpersonateUser()) {

            hFile = CreateFile( szCanonPath,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

            pUserData->RevertToSelf();
        }

        if( hFile == INVALID_HANDLE_VALUE )
        {
            err = GetLastError();
        }
        else
        {
            //
            //  The file DOES exist.  Close the handle, then check
            //  to ensure we really have delete access.
            //

            CloseHandle( hFile );

            if( !PathAccessCheck( AccessTypeDelete,
                                 dwAccessMask,
                                 TEST_UF(pUserData, READ_ACCESS),
                                 TEST_UF(pUserData, WRITE_ACCESS)
                                 )
               ) {

                err = ERROR_ACCESS_DENIED;
            }
        }
    }

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "deleting %s\n", szCanonPath ));
        }

        if ( pUserData->ImpersonateUser()) {

            if( !DeleteFile( szCanonPath ) ) {

                err = GetLastError();

                IF_DEBUG( VIRTUAL_IO ) {

                    DBGPRINTF(( DBG_CONTEXT,
                               "cannot delete %s, error %lu\n",
                               szCanonPath,
                               err ));
                }
            }

            pUserData->RevertToSelf();
        } else {

            err = GetLastError();
        }
    }
    else
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot canonicalize %s - %s, error %lu\n",
                        pUserData->QueryCurrentDirectory(),
                        pszFile,
                        err ));
        }
    }

    return err;

}   // VirtualDeleteFile()



/*******************************************************************

    NAME:       VirtualRenameFile

    SYNOPSIS:   Renames an existing file or directory.

    ENTRY:      pUserData - The user initiating the request.

                pszExisting - The name of an existing file or directory.

                pszNew - The new name for the file or directory.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     10-Mar-1993 Created.

********************************************************************/
APIERR
VirtualRenameFile(
    USER_DATA * pUserData,
    LPSTR       pszExisting,
    LPSTR       pszNew
    )
{
    APIERR err;
    DWORD  cbSize = MAX_PATH;
    CHAR   szCanonExisting[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );

    err = pUserData->VirtualCanonicalize(szCanonExisting,
                                         &cbSize,
                                         pszExisting,
                                         AccessTypeDelete );

    if( err == NO_ERROR ) {

        CHAR   szCanonNew[MAX_PATH];
        cbSize = MAX_PATH;

        err = pUserData->VirtualCanonicalize(szCanonNew,
                                             &cbSize,
                                             pszNew,
                                             AccessTypeCreate );

        if( err == NO_ERROR ) {

            IF_DEBUG( VIRTUAL_IO ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "renaming %s to %s\n",
                           szCanonExisting,
                           szCanonNew ));
            }

            if ( pUserData->ImpersonateUser()) {

                if( !MoveFileEx( szCanonExisting,
                                 szCanonNew,
                                 pUserData->QueryInstance()->AllowReplaceOnRename()
                                     ? MOVEFILE_REPLACE_EXISTING
                                     : 0 )
                   ){

                    err = GetLastError();

                    IF_DEBUG( VIRTUAL_IO ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                   "cannot rename %s to %s, error %lu\n",
                                   szCanonExisting,
                                   szCanonNew,
                                   err ));
                    }
                }

                pUserData->RevertToSelf();

            } else {
                err = GetLastError();
            }

        } else  {

            IF_DEBUG( VIRTUAL_IO ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "cannot canonicalize %s - %s, error %lu\n",
                           pUserData->QueryCurrentDirectory(),
                           pszExisting,
                           err ));
            }
        }
    } else {

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                        "cannot canonicalize %s - %s, error %lu\n",
                       pUserData->QueryCurrentDirectory(),
                       pszExisting,
                       err ));
        }
    }

    return err;

}   // VirtualRenameFile()




APIERR
VirtualChDir(
    USER_DATA * pUserData,
    LPSTR       pszDir
    )
/*++
  This function sets the current directory to newly specified directory.

  Arguments:
     pUserData -- the user initiating the request
     pszDir  -- pointer to null-terminated buffer containing the
                   new directory name.

  Returns:
     APIERR  -- NO_ERROR if successful, otherwise a Win32 error code.

  History:
     MuraliK   28-Apr-1995  Modified to use symbolic roots.
--*/
{
    CHAR     rgchVirtual[MAX_PATH];
    DWORD    cbVirtSize;
    APIERR   err = NO_ERROR;
    DWORD    cbSize;
    CHAR     szCanonDir[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );

    if (pszDir == NULL || *pszDir == '\0') {

        //
        // Nothing new specified.
        //

        return ( NO_ERROR);
    }

    //
    //  Canonicalize the new path.
    //

    cbSize = sizeof(szCanonDir);
    cbVirtSize = sizeof(rgchVirtual);
    err = pUserData->VirtualCanonicalize(szCanonDir,
                                         &cbSize,
                                         pszDir,
                                         AccessTypeRead,
                                         NULL,
                                         rgchVirtual,
                                         &cbVirtSize);

    if ( err == ERROR_ACCESS_DENIED) {

        //
        // this maybe a write only virtual root directory.
        // Let us try again to find we have Write access atleast
        //

        cbSize = sizeof(szCanonDir);
        cbVirtSize = sizeof(rgchVirtual);
        err = pUserData->VirtualCanonicalize(szCanonDir,
                                             &cbSize,
                                             pszDir,
                                             AccessTypeWrite,
                                             NULL,
                                             rgchVirtual,
                                             &cbVirtSize);
    }

    if( err != NO_ERROR )
    {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot canonicalize %s - %s, error %lu\n",
                       pUserData->QueryCurrentDirectory(),
                       pszDir,
                       err ));
        }

        return err;
    }

    //
    //  Try to open the directory and get a handle for the same.
    //

    // This is possibly a new place to change directory to.

    if ( pUserData->ImpersonateUser()) {

        HANDLE CurrentDirHandle = INVALID_HANDLE_VALUE;

        err = OpenPathForAccess( &CurrentDirHandle,
                                szCanonDir,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                pUserData->QueryImpersonationToken()
                                );

        if( err == ERROR_ACCESS_DENIED ) {
            err = OpenPathForAccess( &CurrentDirHandle,
                                    szCanonDir,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    pUserData->QueryImpersonationToken()
                                    );
        }

        if( err == NO_ERROR ) {

            BY_HANDLE_FILE_INFORMATION fileInfo;
            BOOL fRet;

            fRet = GetFileInformationByHandle( CurrentDirHandle,
                                              &fileInfo);

            if ( !fRet) {

                err = GetLastError();

                // Error in getting the file information.
                // close handle and return.

                CloseHandle( CurrentDirHandle);

            } else {

                if ( (fileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    != FILE_ATTRIBUTE_DIRECTORY) {

                    //
                    // this file is not a directory.
                    // Do not change directory. But return error.
                    //

                    err = ERROR_DIRECTORY;
                    CloseHandle( CurrentDirHandle);
                } else {

                    //
                    //  Directory successfully opened.  Save the handle
                    //  in the per-user data. This handle is maintained to
                    //  prevent accidental deletion of the directory.
                    //

                    if( pUserData->CurrentDirHandle != INVALID_HANDLE_VALUE ) {

                        IF_DEBUG( VIRTUAL_IO ) {

                            DBGPRINTF(( DBG_CONTEXT,
                                       "closing dir handle %08lX for %s\n",
                                       pUserData->CurrentDirHandle,
                                       pUserData->QueryCurrentDirectory()));
                        }

                        CloseHandle( pUserData->CurrentDirHandle );
                    }

                    pUserData->CurrentDirHandle = CurrentDirHandle;

                    IF_DEBUG( VIRTUAL_IO ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                   "opened directory %s, handle = %08lX\n",
                                   szCanonDir,
                                   CurrentDirHandle ));
                    }

                    // update the current directory
                    pUserData->SetCurrentDirectory( rgchVirtual );

                }
            }
        }

        pUserData->RevertToSelf();

    } else {

        // Impersonation failed
        err = GetLastError();
    }

    IF_DEBUG( VIRTUAL_IO ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "chdir to %s  returns error = %d\n", szCanonDir, err ));
    }

    return ( err);

}   // VirtualChDir()



/*******************************************************************

    NAME:       VirtualRmDir

    SYNOPSIS:   Removes an existing directory.

    ENTRY:      pUserData - The user initiating the request.

                pszDir - The name of the directory to remove.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
APIERR
VirtualRmDir(
    USER_DATA * pUserData,
    LPSTR      pszDir
    )
{
    APIERR err;
    DWORD  cbSize = MAX_PATH;
    CHAR   szCanonDir[MAX_PATH];

    err = pUserData->VirtualCanonicalize(szCanonDir,
                                         &cbSize,
                                         pszDir,
                                         AccessTypeDelete );

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "rmdir %s\n", szCanonDir ));
        }

        if ( pUserData->ImpersonateUser()) {

            if( !RemoveDirectory( szCanonDir ) ) {

                err = GetLastError();

                IF_DEBUG( VIRTUAL_IO ) {

                    DBGPRINTF(( DBG_CONTEXT,
                               "cannot rmdir %s, error %lu\n",
                               szCanonDir,
                               err ));
                }
            }
            pUserData->RevertToSelf();
        } else {
            err = GetLastError();
        }
    } else {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot canonicalize %s - %s, error %lu\n",
                        pUserData->QueryCurrentDirectory(),
                        pszDir,
                        err ));
        }
    }

    return err;

}   // VirtualRmDir



/*******************************************************************

    NAME:       VirtualMkDir

    SYNOPSIS:   Creates a new directory.

    ENTRY:      pUserData - The user initiating the request.

                pszDir - The name of the directory to create.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
APIERR
VirtualMkDir(
    USER_DATA * pUserData,
    LPSTR      pszDir
    )
{
    APIERR err;
    DWORD  cbSize = MAX_PATH;
    CHAR   szCanonDir[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );

    err = pUserData->VirtualCanonicalize(szCanonDir,
                                         &cbSize,
                                         pszDir,
                                         AccessTypeCreate );

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "mkdir %s\n", szCanonDir ));
        }

        if ( pUserData->ImpersonateUser()) {

            if( !CreateDirectory( szCanonDir, NULL ) ) {

                err = GetLastError();

                IF_DEBUG( VIRTUAL_IO )
                  {
                      DBGPRINTF(( DBG_CONTEXT,
                                 "cannot mkdir %s, error %lu\n",
                                 szCanonDir,
                                 err ));
                  }
            }
            pUserData->RevertToSelf();
        } else {
            err = GetLastError();
        }
    } else {

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot canonicalize %s - %s, error %lu\n",
                       pUserData->QueryCurrentDirectory(),
                       pszDir,
                       err ));
        }
    }

    return err;

}   // VirtualMkDir




//
//  Private constants.
//

#define ACTION_NOTHING              0x00000000
#define ACTION_EMIT_CH              0x00010000
#define ACTION_EMIT_DOT_CH          0x00020000
#define ACTION_EMIT_DOT_DOT_CH      0x00030000
#define ACTION_BACKUP               0x00040000
#define ACTION_MASK                 0xFFFF0000


//
//  Private globals.
//

INT p_StateTable[4][4] =
    {
        {   // state 0
            1 | ACTION_EMIT_CH,             // "\"
            0 | ACTION_EMIT_CH,             // "."
            4 | ACTION_EMIT_CH,             // EOS
            0 | ACTION_EMIT_CH              // other
        },

        {   // state 1
            1 | ACTION_NOTHING,             // "\"
            2 | ACTION_NOTHING,             // "."
            4 | ACTION_EMIT_CH,             // EOS
            0 | ACTION_EMIT_CH              // other
        },

        {   // state 2
            1 | ACTION_NOTHING,             // "\"
            3 | ACTION_NOTHING,             // "."
            4 | ACTION_EMIT_CH,             // EOS
            0 | ACTION_EMIT_DOT_CH          // other
        },

        {   // state 3
            1 | ACTION_BACKUP,              // "\"
            0 | ACTION_EMIT_DOT_DOT_CH,     // "."
            4 | ACTION_BACKUP,              // EOS
            0 | ACTION_EMIT_DOT_DOT_CH      // other
        }
    };



/*******************************************************************

    NAME:       VirtualpSanitizePath

    SYNOPSIS:   Sanitizes a path by removing bogus path elements.

                As expected, "/./" entries are simply removed, and
                "/../" entries are removed along with the previous
                path element.

                To maintain compatibility with URL path semantics
                 additional transformations are required. All backward
                 slashes "\\" are converted to forward slashes. Any
                 repeated forward slashes (such as "///") are mapped to
                 single backslashes.  Also, any trailing path elements
                 consisting solely of dots "/....." are removed.

                Thus, the path "/foo\./bar/../tar\....\......" is
                mapped to "/foo/tar".

                A state table (see the p_StateTable global at the
                beginning of this file) is used to perform most of
                the transformations.  The table's rows are indexed
                by current state, and the columns are indexed by
                the current character's "class" (either slash, dot,
                NULL, or other).  Each entry in the table consists
                of the new state tagged with an action to perform.
                See the ACTION_* constants for the valid action
                codes.

                After the FSA is finished with the path, we make one
                additional pass through it to remove any trailing
                backslash, and to remove any trailing path elements
                consisting solely of dots.

    ENTRY:      pszPath - The path to sanitize.

    HISTORY:
        KeithMo     07-Sep-1994 Created.
        MuraliK     28-Apr-1995 Adopted this for symbolic paths

********************************************************************/
VOID
VirtualpSanitizePath(
    CHAR * pszPath
    )
{
    CHAR * pszSrc;
    CHAR * pszDest;
    CHAR * pszHead;
    CHAR   ch;
    INT    State;
    INT    Class;
    BOOL   fDBCS = FALSE;

    //
    //  Ensure we got a valid symbolic path (something starting "/"
    //

    DBG_ASSERT( pszPath != NULL );
//     DBG_ASSERT( pszPath[0] == '/');

    //
    //  Start our scan at the first "/.
    //

    pszHead = pszSrc = pszDest = pszPath;

    //
    //  State 0 is the initial state.
    //

    State = 0;

    //
    //  Loop until we enter state 4 (the final, accepting state).
    //

    while( State != 4 )
    {
        //
        //  Grab the next character from the path and compute its
        //  character class.  While we're at it, map any forward
        //  slashes to backward slashes.
        //

        ch = *pszSrc++;

        switch( ch )
        {
        case '\\' :
            //
            //  fDBCS is always false for non-DBCS system
            //

            if ( fDBCS )
            {
                Class = 3;
                break;
            }
            ch = '/';  // convert it to symbolic URL path separator char.
            /* fall through */

        case '/' :
            Class = 0;
            break;

        case '.' :
            Class = 1;
            break;

        case '\0' :
            Class = 2;
            break;

        default :
            Class = 3;
            break;
        }

        //
        //  Advance to the next state.
        //

        State = p_StateTable[State][Class];

        //
        //  Perform the action associated with the state.
        //

        switch( State & ACTION_MASK )
        {
        case ACTION_EMIT_DOT_DOT_CH :
            *pszDest++ = '.';
            /* fall through */

        case ACTION_EMIT_DOT_CH :
            *pszDest++ = '.';
            /* fall through */

        case ACTION_EMIT_CH :
            *pszDest++ = ch;
            /* fall through */

        case ACTION_NOTHING :
            break;

        case ACTION_BACKUP :
            if( pszDest > ( pszHead + 1 ) )
            {
                pszDest--;
                DBG_ASSERT( *pszDest == '/' );

                *pszDest = '\0';
                pszDest = strrchr( pszPath, '/') + 1;
            }

            *pszDest = '\0';
            break;

        default :
            DBG_ASSERT( !"Invalid action code in state table!" );
            State = 4;
            *pszDest++ = '\0';
            break;
        }

        State &= ~ACTION_MASK;
        if ( !fDBCS )
        {
            if ( IsDBCSLeadByte( ch ) )
            {
                fDBCS = TRUE;
            }
        }
        else
        {
            fDBCS = FALSE;
        }
    }

    //
    //  Remove any trailing slash.
    //

    pszDest -= 2;

    if( ( strlen( pszPath ) > 3 ) && ( *pszDest == '/' ) )
    {
        *pszDest = '\0';
    }

    //
    //  If the final path elements consists solely of dots, remove them.
    //

    while( strlen( pszPath ) > 3 )
    {
        pszDest = strrchr( pszPath, '/');
        DBG_ASSERT( pszDest != NULL );

        pszHead = pszDest;
        pszDest++;

        while( ch = *pszDest++ )
        {
            if( ch != '.' )
            {
                break;
            }
        }

        if( ch == '\0' )
        {
            //
            // this is probably dead code left over from
            // when we used physical paths.
            //
            if( pszHead == ( pszPath + 2 ) )
            {
                pszHead++;
            }
            // end of dead code

            //
            // Don't remove the first '/'
            //
            if ( pszHead == pszPath )
            {
                pszHead++;
            }

            *pszHead = '\0';
        }
        else
        {
            break;
        }
    }

}   // VirtualpSanitizePath


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for FTP server

   Author:

       Murali R. Krishnan    ( MuraliK )    06-Feb-1996

   Environment:

       Windows NT - User Mode

   Project:

       FTP Server DLL

   Revision History:

--*/

# ifndef _FTP_AUX_COUNTERS_HXX_
# define _FTP_AUX_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

typedef enum  {   // Fac - stands for Ftp Aux Counters

    FacUnknownCommands = 0,           // cumulative counter
    CacTimeoutWhenProcessing,         // cumulative
    CacTimeoutInDisconnect,           // cumulative
    FacPassiveDataListens,            // active counter
    FacSimulatedAborts,               // cumulative counter
    FacPassiveDataConnections,        // cumulative counter
    FacActiveDataConnections,         // cumulative counter
    FacFilesOpened,                   // cumulative counter
    FacFilesClosed,                   // cumulative counter
    FacFilesInvalid,                  // cumulative counter

    FacMaxCounters
} ENUM_FTP_AUX_COUNTER;



#ifdef FTP_AUX_COUNTERS

# define NUM_AUX_COUNTERS    (FacMaxCounters)

//
// Macros for operating on these counters
//

# define FacIncrement( facCounter)   \
 (((facCounter) < FacMaxCounters) ?  \
  InterlockedIncrement( g_AuxCounters+(facCounter)) : \
  0)

# define FacDecrement( facCounter)   \
 (((facCounter) < FacMaxCounters) ?  \
  InterlockedDecrement( g_AuxCounters+(facCounter)) : \
  0)

# define FacCounter( facCounter)   \
 (((facCounter) < FacMaxCounters) ? g_AuxCounters[facCounter] : 0)


extern LONG g_AuxCounters[];


# else // FTP_AUX_COUNTERS

# define NUM_AUX_COUNTERS          (0)

# define FacIncrement( facCounter)       (0)    /* do nothing */
# define FacDecrement( facCounter)       (0)    /* do nothing */
# define FacCounter(facCounter)          (0)    /* do nothing */

#endif // FTP_AUX_COUNTERS


# endif // _FTP_AUX_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server\userdb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    userdb.cxx

    This module manages the user database for the FTPD Service.

    Functions exported by this module:


        DisconnectUser()
        DisconnectUsersWithNoAccess()
        EnumerateUsers()

        USER_DATA::USER_DATA()
        USER_DATA::Reset()
        USER_DATA::~USER_DATA()
        USER_DATA::Cleanup()
        USER_DATA::ProcessAsyncIoCompletion()
        USER_DATA::ReInitializeForNewUser()
        USER_DATA::ReadCommand()
        USER_DATA::DisconnectUserWithError()
        USER_DATA::SendMultilineMessage()
        USER_DATA::SendDirectoryAnnotation()
        USER_DATA::GetFileSize();

        ProcessUserAsyncIoCompletion()

    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     March-May, 1995
                      Adding support for Async Io/Transfers
                      + new USER_DATA class functions defined.
                      + oob_inline enabled; ReadCommand() issued after
                          data socket is established.
                      + added member functions for common operations
                      + added ProcessAsyncIoCompletion()
                      + added Establish & Destroy of Data connection

       MuraliK   26-July-1995    Added Allocation caching of client conns.
       Terryk    18-Sep-1996     Added GetFileSize
       AMallet   Sep 1998        Added support for AcceptEx() of PASV data connections
*/


#include "ftpdp.hxx"
# include "tsunami.hxx"
#include <timer.h>
# include "auxctrs.h"
# include <mbstring.h>
#include "acptctxt.hxx"

#define FIRST_TELNET_COMMAND    240
#define TELNET_DM_COMMAND       242
#define TELNET_IP_COMMAND       244
#define TELNET_SB_CODE          250
#define TELNET_SB_CODE_MIN      251
#define TELNET_SB_CODE_MAX      254
#define TELNET_IAC_CODE         255

# define  MAX_FILE_SIZE_SPEC           ( 32)


//
//  Private globals.
//

#define PSZ_DEFAULT_SUB_DIRECTORY   "Default"

static const char PSZ_SENT_VERB[]  = "sent";
static const char PSZ_CONNECTION_CLOSED_VERB[]  = "closed";
static const char PSZ_FILE_ERROR[] = "%s: %s";
static const char PSZ_TRANSFER_COMPLETE[]  = "Transfer complete.";
static const char PSZ_TRANSFER_ABORTED[] =
    "Connection closed; transfer aborted.";
static const char PSZ_TRANSFER_STARTING[] =
    "Data connection already open; Transfer starting.";
static const char PSZ_INSUFFICIENT_RESOURCES[] =
    "Insufficient system resources.";
static const char PSZ_TOO_MANY_PASV_USERS[] =
    "Too many passive-mode users.";
static const char PSZ_OPENING_DATA_CONNECTION[] =
    "Opening %s mode data connection for %s%s.";
static const char PSZ_CANNOT_OPEN_DATA_CONNECTION[] =
    "Can't open data connection.";
static const char PSZ_COMMAND_TOO_LONG[] =
    "Command was too long";

static DWORD  p_NextUserId = 0;        // Next available user id.

static const char SZ_LOCALUSER_DIR[] = "LocalUser\\";
static const char SZ_ANONYMOUS_DIR[] = "Public";

//
//  Private prototypes.
//

DWORD
UserpGetNextId(
    VOID
    );



inline VOID
StopControlRead( IN LPUSER_DATA pUserData)
/*++
  Stops control read operation, if one is proceeding.
  Resets the CONTROL_READ flag as well as decrements ref count in user data.

--*/
{
    if ( TEST_UF( pUserData, CONTROL_READ)) {

        if ( InterlockedDecrement( &pUserData->m_nControlRead) < 0 ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "StopControLRead: no read active!!!\n"));
            DBG_ASSERT( FALSE);
        }

        DBG_REQUIRE( pUserData->DeReference() > 0);
        CLEAR_UF( pUserData, CONTROL_READ);
    }

} // StopControlRead()


BOOL
FilterTelnetCommands(IN CHAR * pszLine, IN DWORD cchLine,
                     IN LPBOOL pfLineEnded,
                     IN LPDWORD  pcchRequestRecvd)
/*++
  Filters out the Telnet commands and
  terminates the command line with  linefeed.

  Also this function filters out the out of band data.
  This works similar to the Sockutil.cxx::DiscardOutOfBandData().
  We scan for the pattern "ABOR\r\n" and
   set the OOB_DATA flag if it is present.

  Arguments:
   pszLine   pointer to null terminated string containing the input data.
   cchLine   count  of characters of data received
   pfLineEnded  pointer to Boolean flag which is set to true if complete
             line has been received.
   pcchRequestRecvd  pointer to DWORD which on return contains the number
                      of bytes received.

  Returns:
    TRUE if the filtering is successful without any out of band abort request.
    FALSE if there was any abort request in the input.

--*/
{
    BOOL    fDontAbort = TRUE;
    BOOL    fStateTelnetCmd = FALSE;
    BOOL    fStateTelnetSB = FALSE;
    BOOL    fFoundTelnetIP = FALSE;
    CHAR *  pszSrc;
    CHAR *  pszDst;

    LPCSTR  pszAbort = "ABOR\r\n";
    LPCSTR  pszNext  = pszAbort;

    DBG_ASSERT( pszLine != NULL && cchLine > 0 &&
               pfLineEnded != NULL && pcchRequestRecvd != NULL);

    *pfLineEnded = FALSE;

    for( pszSrc = pszDst = pszLine; pszSrc < pszLine + cchLine &&  *pszSrc;
        pszSrc++) {

        CHAR ch = *pszSrc;
        BYTE uch = (BYTE)ch;

        //
        // Filter out TELNET commands. these are of the form: IAC <cmd> or
        // IAC SB <op> (IAC = 255, SB = 250, op 251..254, cmd > 240)
        //

        if( fStateTelnetCmd ) {
            //
            // we are in a Telbent command sequence
            //

            fStateTelnetCmd = FALSE;

            DBG_ASSERT( uch >= FIRST_TELNET_COMMAND );

            if( fStateTelnetSB ) {
                //
                // we are in a Telnet subsequence command
                //

                fStateTelnetSB = FALSE;

                DBG_ASSERT( (uch >= TELNET_SB_CODE_MIN) &&
                            (uch <= TELNET_SB_CODE_MAX) );

                if( uch >= FIRST_TELNET_COMMAND ) {
                    //
                    // consider it a valid Telnet command, as long as it's in
                    // the Telnet range. Filter this char out.
                    //

                    continue;
                }

                //
                // this is a TELNET protocol error, we'll ignore it.
                //
                // fall through with this char
                //

            } else if( uch == TELNET_SB_CODE ) {
                //
                // enter Telnet subsequense command state
                //

                fStateTelnetCmd = fStateTelnetSB = TRUE;
                continue;

            } else if( uch == TELNET_IAC_CODE ) {
                //
                // this is an escape sequence for a 255 data byte
                //
                // let it fall through
                //

            } else if ( uch == TELNET_IP_COMMAND ) {
                //
                // remember this, it is the first in a SYNCH sequence
                //

                fFoundTelnetIP = TRUE;
                continue;

            } else if ( uch == TELNET_DM_COMMAND ) {
                //
                // if in a SYNCH sequence, this resets the input stream
                //

                if( fFoundTelnetIP ) {
                    pszDst = pszLine;
                    fFoundTelnetIP = FALSE; // completed the SYNCH sequence
                }
                continue;

            } else {
                //
                // we expect a Telnet command code here. filter it out
                //

                DBG_ASSERT( uch >= FIRST_TELNET_COMMAND );

                if ( uch >= FIRST_TELNET_COMMAND ) {
                    continue;
                }

                //
                // this is a TELNET protocol error, we'll ignore it.
                //
                // fall through with this char
                //
            }
        } else if( uch == TELNET_IAC_CODE ) {
            //
            // entering Telnet command parsing state
            //

            fStateTelnetCmd = TRUE;
            continue;
        } else if( uch == TELNET_DM_COMMAND ) {
            //
            // FTP.EXE on Win2k is sending an unexpected SYNCH sequence: DM, IAC, IP. See if this is it.
            //

            if( ( pszSrc == pszLine ) &&
                ( cchLine >= 3 ) &&
                ( (UINT)*(pszSrc+1) == TELNET_IAC_CODE ) &&
                ( (UINT)*(pszSrc+2) == TELNET_DM_COMMAND ) ) {
                //
                // just filter the sequence out
                //

                pszSrc += 2;

                continue;

            } else if( fFoundTelnetIP ) {
                //
                // or, it could be a single byte URGENT notification in the telnet Sync
                //

                pszDst = pszLine;

                fFoundTelnetIP = FALSE; // completed the SYNCH sequence

                continue;
            }
        }

        //
        // if we have seen a Telnet IP, then skip everything up to a DM
        //

        if (fFoundTelnetIP) {
            continue;
        }

        //
        // try matching ABOR\r\n
        //

        if ( *pszNext != ch) {

            // the pattern match failed. reset to start at the beginning.

            pszNext = pszAbort;
        }

        if ( *pszNext == ch) {

            // pattern match at this character. move forward
            pszNext++;

            if ( *pszNext == '\0') {   // end of string==> all matched.

                // only consider this an OOB Abort if at the beginning of
                // a (reset) line

                if( (pszDst - pszLine + 2) == (pszNext - pszAbort) ) {
                    fDontAbort = FALSE;
                }

                pszNext = pszAbort;
            }
        }

        //
        //  don't copy <CR> and <LF> to the output
        //

        if ( (ch != '\r') && ( ch != '\n')) {

            *pszDst++ = ch;

        } else if ( ch == '\n') {

            // terminate at the linefeed
            *pfLineEnded = TRUE;
            break;
        }

    } // for

    //
    // remember Telnet IP if we have seen it
    //

    if (fFoundTelnetIP) {

       //
       // we can safely do this, as we have filtered the 2 byte sequence out earlier
       //

       *(UCHAR*)pszDst++ = TELNET_IAC_CODE;
       *(UCHAR*)pszDst++ = TELNET_IP_COMMAND;
    }

    //
    // remember Telnet command states
    //
    if( fStateTelnetCmd ) {

       *(UCHAR*)pszDst++ = TELNET_IAC_CODE;

       if( fStateTelnetSB ) {
          *(UCHAR*)pszDst++ = TELNET_SB_CODE;
       }
    }

    *pszDst = '\0';

    *pcchRequestRecvd = DIFF(pszDst - pszLine);
    DBG_ASSERT( *pcchRequestRecvd <= cchLine);

    return (fDontAbort);

} // FilterTelnetCommands()



//
//  Public functions.
//





USER_DATA::USER_DATA(
    IN FTP_SERVER_INSTANCE *pInstance
    )
/*++
  This function creates a new UserData object for the information
    required to process requests from a new User connection ( FTP).

  Arguments:
     sControl   Socket used for control channel in FTP connection
     clientIpAddress  strcuture containing the client Ip address

  Returns:
     a newly constructed USER_DATA object.
     Check IsValid() to ensure the object was properly created.

  NOTE:
    This function is to be used for dummy creation of the object so
      allocation cacher can use this object.
    Fields are randomly initialized. Reset() will initialize them properly.

    However when a new effective USER_DATA object is needed, after allocation
     one can call USER_DATA::Reset() to initialize all vars.
--*/
:
  m_References              ( 0),
  m_ActiveRefAdded          ( 0),
  m_cchRecvBuffer           ( 0),
  m_cbRecvd                 ( 0),
  m_cchPartialReqRecvd      ( 0),
  m_pOpenFileInfo           ( NULL),
  Flags                     ( 0),
  UserToken                 ( NULL),
  m_UserId                  ( 0),
  DataPort                  ( 0),
  UserState                 ( UserStateEmbryonic),
  m_AioControlConnection    ( ProcessUserAsyncIoCompletion),
  m_AioDataConnection       ( ProcessUserAsyncIoCompletion),
  m_sPassiveDataListen      ( INVALID_SOCKET),
  CurrentDirHandle          ( INVALID_HANDLE_VALUE),
  RenameSourceBuffer        ( NULL),
  m_fCleanedup              ( FALSE),
  m_pMetaData               ( NULL),
  m_pInstance               ( pInstance ),
  m_acCheck                 ( AC_NOT_CHECKED ),
  m_fNeedDnsCheck           ( FALSE ),
  m_dwLastReplyCode         ( 0 ),
  m_fHavePASVConn           ( FALSE ),
  m_fWaitingForPASVConn     ( FALSE ),
  m_fFakeIOCompletion       ( FALSE ),
  m_pszCmd                  ( NULL ),
  m_hPASVAcceptEvent        ( NULL )
#if DBG
  ,m_RefTraceLog( NULL )
#endif
{
    DWORD dwTimeout = m_pInstance->QueryConnectionTimeout();

    INITIALIZE_CRITICAL_SECTION( &m_UserLock );

    //
    //  Setup the structure signature.
    //

    INIT_USER_SIG( this );

    m_AioControlConnection.SetAioInformation( this, dwTimeout);
    m_AioDataConnection.SetAioInformation( this, dwTimeout);

    InitializeListHead( &ListEntry);

    ZeroMemory( m_recvBuffer, DEFAULT_REQUEST_BUFFER_SIZE);

    IF_DEBUG( USER_DATABASE ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "user_data object created  @ %08lX.\n",
                   this));
    }

    m_licbSent.QuadPart = 0;

#if DBG
    m_RefTraceLog = CreateRefTraceLog( TRACE_LOG_SIZE, 0 );
#endif

        FakeIOTimes = 0;

} // USER_DATA::USER_DATA()



USER_DATA::~USER_DATA(VOID)
{

    if ( !m_fCleanedup) {
        Cleanup();
    }

    if( RenameSourceBuffer != NULL ) {
        TCP_FREE( RenameSourceBuffer);
        RenameSourceBuffer = NULL;
    }

    if ( m_pszCmd != NULL )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    if ( m_hPASVAcceptEvent != NULL )
    {
        RemovePASVAcceptEvent( TRUE );
    }

    if ( m_pInstance != NULL ) {
        m_pInstance->DecrementCurrentConnections();
        m_pInstance->Dereference();
        m_pInstance = NULL;
    }

#if DBG
    if( m_RefTraceLog != NULL ) {
        DestroyRefTraceLog( m_RefTraceLog );
    }
#endif

    DeleteCriticalSection( &m_UserLock );

} // USER_DATA::~USER_DATA()



BOOL
USER_DATA::Reset(IN SOCKET          sControl,
                 IN PVOID           EndpointObject,
                 IN IN_ADDR         clientIpAddress,
                 IN const SOCKADDR_IN * psockAddrLocal /* = NULL */ ,
                 IN PATQ_CONTEXT    pAtqContext         /* = NULL */ ,
                 IN PVOID           pvInitialRequest    /* = NULL */ ,
                 IN DWORD           cbWritten           /* = 0    */ ,
                 IN AC_RESULT       acCheck
                 )
{
    BOOL  fReturn = TRUE;

    //
    //  Setup the structure signature.
    //

    INIT_USER_SIG( this );

    m_References    = 1;  // set to 1 to prevent immediate deletion.
    m_ActiveRefAdded=  1;
    m_fCleanedup    = FALSE;
    Flags           = m_pInstance->QueryUserFlags();
    UserState       = UserStateEmbryonic;

#if DBG
    if( m_RefTraceLog != NULL ) {
        ResetTraceLog( m_RefTraceLog );
    }
#endif

    m_pOpenFileInfo = NULL;
    UserToken       = NULL;
    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }
    m_UserId        = UserpGetNextId();
    m_xferType      = XferTypeAscii;
    m_xferMode      = XferModeStream;
    m_msStartingTime= 0;
    m_acCheck       = acCheck;
    m_fNeedDnsCheck = FALSE;
    m_dwLastReplyCode = 0;

    HostIpAddress   = clientIpAddress;
    DataIpAddress   = clientIpAddress;

    m_cbRecvd       = 0;
    m_cchRecvBuffer = sizeof( m_recvBuffer) - sizeof(m_recvBuffer[0]);
    m_cchPartialReqRecvd = 0;

    CurrentDirHandle   = INVALID_HANDLE_VALUE;
    RenameSourceBuffer = NULL;
    m_TimeAtConnection = GetCurrentTimeInSeconds();
    m_TimeAtLastAccess = m_TimeAtConnection;


    m_pvInitialRequest  = pvInitialRequest;
    m_cbInitialRequest  = cbWritten;

    //
    // clean up the stuff needed to deal async with PASV command
    //
    if ( m_pszCmd )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    if ( m_hPASVAcceptEvent )
    {
        RemovePASVAcceptEvent( TRUE );
    }

    CleanupPASVFlags();

    // set up the async io contexts
    m_AioControlConnection.SetNewSocket( sControl, pAtqContext, EndpointObject );
    m_AioDataConnection.SetNewSocket(INVALID_SOCKET);
    m_sPassiveDataListen = ( INVALID_SOCKET);

    m_rgchFile[0] = '\0';
    m_szUserName[0]  = '\0';             // no user name available yet.
    m_szCurrentDirectory[0] = '\0';      // initialize to no virtual dir.
    m_szRootDir[0] = '\0';               // no root directory known yet

    m_licbSent.QuadPart = 0;

    m_pInstance->QueryStatsObj()->IncrCurrentConnections();

    m_dwCurrentOffset = 0;
    m_dwNextOffset = 0;

    //
    //  get the local Ip address
    //

    if ( psockAddrLocal != NULL) {

        LocalIpAddress = psockAddrLocal->sin_addr;
        LocalIpPort = psockAddrLocal->sin_port;
    } else {

        SOCKADDR_IN  saddrLocal;
        INT   cbLocal;

        cbLocal = sizeof( saddrLocal);
        if ( getsockname( sControl, (SOCKADDR *) &saddrLocal, &cbLocal) != 0) {

            DWORD err = WSAGetLastError();

            fReturn = FALSE;

            IF_DEBUG( ERROR) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Failure in getsockname( sock=%d). Error = %u\n",
                            sControl, err));
            }

            SetLastError( err);

        } else  {

            LocalIpAddress = saddrLocal.sin_addr;
            LocalIpPort = saddrLocal.sin_port;
        }
    }

    DataPort = CONN_PORT_TO_DATA_PORT(LocalIpPort);

    //
    //  Success!
    //

    IF_DEBUG( CLIENT) {

        time_t now;
        time( & now);
        CHAR pchAddr[32];

        InetNtoa( clientIpAddress, pchAddr);

        DBGPRINTF( ( DBG_CONTEXT,
                    " Client Connection for %s:%d starting @ %s",
                    pchAddr, sControl,
                    asctime( localtime( &now))));
    }

    IF_DEBUG( USER_DATABASE ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "user %lu reset @ %08lX.\n",
                   QueryId(), this));
    }

    m_nControlRead = 0;

    FakeIOTimes = 0;

    return (fReturn);

} // USER_DATA::Reset()




VOID
USER_DATA::Cleanup( VOID)
/*++
  This cleans up data stored in the user data object.

 Returns:
    None

--*/
{
    DBG_ASSERT( QueryReference() == 0);

    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG( USER_DATABASE ) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Cleaning up user %lu  @ %08lX.\n",
                   QueryId(), this));
    }

    DBG_ASSERT( m_nControlRead == 0);

    //
    // Clean up stuff needed to deal with PASV connections
    //
    if ( m_hPASVAcceptEvent )
    {
        RemovePASVAcceptEvent( TRUE );
    }


    if ( m_pszCmd )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    //
    //  Close any open sockets & handles.
    //

    CloseSockets( FALSE );

    // invalidate the connections
    m_AioControlConnection.SetNewSocket(INVALID_SOCKET);
    m_AioDataConnection.SetNewSocket(INVALID_SOCKET);


    //
    //  Update the statistics.
    //

    if( IsLoggedOn()
        && !TEST_UF( this, WAIT_PASS ) )
    {
        if( TEST_UF( this, ANONYMOUS))
        {
            m_pInstance->QueryStatsObj()->DecrCurrentAnonymousUsers();
        }
        else
        {
            m_pInstance->QueryStatsObj()->DecrCurrentNonAnonymousUsers();
        }
    }

    m_pInstance->QueryStatsObj()->DecrCurrentConnections();

    if( UserToken != NULL )
    {
        TsDeleteUserToken( UserToken );
        UserToken = NULL;
    }

    if( CurrentDirHandle != INVALID_HANDLE_VALUE )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "closing directory handle %08lX\n",
                        CurrentDirHandle ));
        }

        CloseHandle( CurrentDirHandle );
        CurrentDirHandle = INVALID_HANDLE_VALUE;
    }

    if ( m_pOpenFileInfo != NULL) {

        DBG_REQUIRE( CloseFileForSend());
    }

    //
    //  Release the memory attached to this structure.
    //


    if( RenameSourceBuffer != NULL ) {

        // do not free this location until end of usage.
        RenameSourceBuffer[0] = '\0';
    }

    m_UserId        = 0;  // invalid User Id

    //
    //  Kill the structure signature.
    //

    KILL_USER_SIG( this );

    IF_DEBUG( CLIENT) {

        time_t now;
        time( & now);

        DBGPRINTF( ( DBG_CONTEXT,
                    " Client Connection for %s:%d ending @ %s",
                    inet_ntoa( HostIpAddress), QueryControlSocket(),
                    asctime( localtime( &now))));
    }


    //
    // There is a possible race condition. If the socket was abruptly closed
    //   and there was any pending Io, they will get blown away. This will
    //   cause a call-back from the ATQ layer. That is unavoidable.
    //  In such cases it is possible that the object was deleted.
    //   This can lead to problems. We need to be careful.
    //  But Reference Count protects against such disasters. So tread
    //   carefully and use Reference count.
    //

    DBG_ASSERT( m_sPassiveDataListen == INVALID_SOCKET);

    m_fCleanedup = TRUE; // since we  just cleaned up this object

    return;

} // USER_DATA::Cleanup()






VOID
USER_DATA::ReInitializeForNewUser( VOID)
/*++

  This function reinitializes the user data information for a new user to
  communicate with the server using existing control socket connection.

--*/
{

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    //
    //  Update the statistics.
    //

    if( IsLoggedOn())
    {
        if( TEST_UF( this, ANONYMOUS))
        {
            m_pInstance->QueryStatsObj()->DecrCurrentAnonymousUsers();
        }
        else
        {
            m_pInstance->QueryStatsObj()->DecrCurrentNonAnonymousUsers();
        }
    }

    CLEAR_UF_BITS( this, (UF_LOGGED_ON | UF_ANONYMOUS | UF_PASSIVE));

    LockUser();
    if( QueryState() != UserStateDisconnected ) {
        SetState( UserStateWaitingForUser );
    }
    UnlockUser();

    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }
    m_TimeAtConnection= GetCurrentTimeInSeconds();
    m_TimeAtLastAccess= m_TimeAtConnection;
    m_xferType        = XferTypeAscii;
    m_xferMode        = XferModeStream;
    DataIpAddress     = HostIpAddress;
    DataPort          = CONN_PORT_TO_DATA_PORT(LocalIpPort);

    m_szUserName[0] = '\0';
    m_szCurrentDirectory[0] = '\0';
    m_szRootDir[0] = '\0';

    if( UserToken != NULL )
    {
        TsDeleteUserToken( UserToken );
        UserToken = NULL;
    }

    if( CurrentDirHandle != INVALID_HANDLE_VALUE )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "closing directory handle %08lX\n",
                        CurrentDirHandle ));
        }

        CloseHandle( CurrentDirHandle );
        CurrentDirHandle = INVALID_HANDLE_VALUE;
    }

    if ( m_pOpenFileInfo != NULL) {

        DBG_REQUIRE( CloseFileForSend());
    }

    m_licbSent.QuadPart = 0;

    m_pvInitialRequest  = NULL;
    m_cbInitialRequest  = 0;

    CleanupPassiveSocket( TRUE );

    return;

} // USER_DATA::ReInitializeForNewUser()






BOOL
USER_DATA::ProcessAsyncIoCompletion(
    IN DWORD cbIo,
    IN DWORD dwError,
    IN LPASYNC_IO_CONNECTION  pAioConn,
    IN BOOL  fTimedOut)
/*++
  This function processes the Async Io completion.
  ( invoked due to a callback from the ASYNC_IO_CONNECTION object)

  Arguments:
     pContext      pointer to the context information ( UserData object).
     cbIo          count of bytes transferred in Io
     dwError       DWORD containing the error code resulting from last tfr.
     pAioConn      pointer to AsyncIo connection object.
     fTimedOut     flag indicating if the current call was made
                     because of timeout.

  Returns:
     None
--*/
{
    BOOL        fReturn = FALSE;
    AC_RESULT   acDnsAccess;
    DWORD       dwOriginalError;

    dwOriginalError = dwError;

    //
    // Special processing if it's an IO completion on the control connection - we might
    // be processing a completion we posted ourselves to signal that the data socket for the PASV
    // data connection is now accept()'able.
    //

    if ( pAioConn == &m_AioControlConnection && QueryInFakeIOCompletion() )
    {
        // Here is a horrible race condition:
        // If the FTP client closes the control socket
        // right after having finished receiving the transmitted file
        // than there may be a thread that enters this
        // code path (because the FakeIO flag is set, and the
        // Control Socket is involved) before the IO completion
        // for the data sonnection has traveled this same function,
        // cleaning the FakeIO flag
        // Here is the race condition:
        // A thread enter here, and see that the FakeIO is set
        // the normal behavior is reprocessing a command like
        // "RETR foo.txt", while now the command if a zero length string.
        // the Second thread enter this function with the DataConnection
        // it clears the flag (at a non specified point of the
        // processing of the other thread) and it exit.
        // the original thread is now processing a saved string
        // (because of the FakeIO flag) while it is not supposed to.
        // this causes problems to the time-out algorithm, because
        // of a ref-count problem in the USER_DATA

        LONG CurVal = InterlockedIncrement(&(this->FakeIOTimes));
        if (CurVal>1){
            goto NormalProcessing;
        }

        //
        // Remove the reference used to deal with the race condition between an IO
        // thread doing clean-up and the thread watching for the data socket to become
        // accept()'able and holding on to this USER_DATA object
        //
        DeReference();

        //
        // There is a race condition between the thread watching for a socket to become
        // accept()'able and an IO thread being woken up because the client has (unexpectedly)
        // disconnected. The thread watching the socket will post a fake IO completion to
        // indicate that an accept() on the socket will succeed; however, if the client
        // disconnects (the control connection) before the fake completion is processed,
        // we don't want to do any more processing.
        //
        if ( UserState == UserStateDisconnected )
        {
            return TRUE;
        }
        else
        {
            //
            // Fast-path if we know this is the second time around we're trying to process the
            // command, which happens when we're in PASV mode
            //
            DBG_ASSERT( UserState == UserStateLoggedOn );
            goto ProcessCommand;
        }
    }

NormalProcessing:

    if( dwError != NO_ERROR &&
        dwError != ERROR_SEM_TIMEOUT )
    {

        //
        // Geezsh, I hate my life.
        //
        // Once upon a time, there was a bug in ATQ that cause it to
        // always pass NO_ERROR as the status to the async completion
        // routine. This bug caused, among other things, FTP to never
        // time out idle connections, because it never saw the
        // ERROR_SEM_TIMEOUT status. So, I fixed the bug in ATQ.
        //
        // Now, this completion routine gets the actual status. Well,
        // that breaks service shutdown when there are connected users.
        // Basically, when a shutdown occurs, the connected sockets are
        // closed, causing the IO to complete with ERROR_NETNAME_DELETED.
        // USER_DATA::ProcessAsyncIoCompletion() is not handling this
        // error properly, which causes 1) an assertion failure because
        // USER_DATA::DisconnectUserWithError() is getting called *twice*
        // and 2) the service never stops because of a dangling reference
        // on the USER_DATA structure.
        //
        // Of course, the proper thing to do would be to fix the offending
        // code in USER_DATA::ProcessAsyncIoCompletion() so that it DID
        // handle the error properly. Unfortunately, that fix requires a
        // nontrivial amount of surgery, and we're a scant three days
        // from releasing K2 Beta 1. So...
        //
        // As a quick & dirty work around for K2 Beta 1, we'll map all
        // errors other than ERROR_SEM_TIMEOUT to NO_ERROR. This should
        // provide the lower software layers with the old ATQ behavior
        // they're expecting.
        //
        // REMOVE THIS POST BETA 1 AND FIX USER_DATA PROPERLY!!!!
        //
        // 3/12/98
        //
        // N.B. The debug output below has been changed to be a little
        // more customer friendly but I hate to prevent future developers
        // for enjoying the original message which read:
        // "Mapping error %d to NO_ERROR to mask FTP bug (FIX!)\n"
        //
        // I'm removing this message because it was the source of some
        // embarrasment, when a checked version of this DLL was sent to
        // Ernst & Young to track the now famous bug #138566.
        //

        DBGPRINTF((
            DBG_CONTEXT,
            "Mapping error %d to NO_ERROR\n",
            dwError
            ));

        dwError = NO_ERROR;

    }

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG


    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[%lu] Entering USER_DATA( %08x)::Process( %u, %u, %08x)."
                    " RefCount = %d. State = %d\n",
                    GetTickCount(),
                    this, cbIo, dwError, pAioConn, QueryReference(),
                    QueryState()));
    }

    if ( m_fNeedDnsCheck )
    {
        acDnsAccess = QueryAccessCheck()->CheckDnsAccess();

        UnbindInstanceAccessCheck();

        m_fNeedDnsCheck = FALSE;

        if ( (acDnsAccess == AC_IN_DENY_LIST) ||
             (acDnsAccess == AC_NOT_IN_GRANT_LIST) ||
             ((m_acCheck == AC_NOT_IN_GRANT_LIST) &&
              (acDnsAccess != AC_IN_GRANT_LIST) ) ) {

            ReplyToUser(this,
                        REPLY_NOT_LOGGED_IN,
                        "Connection refused, unknown IP address." );

            DisconnectUserWithError( NO_ERROR );

            return TRUE;
        }
    }

    if ( pAioConn == &m_AioDataConnection)
    {

        //
        // a Data transfer operation has completed.
        //

        DBG_REQUIRE( IsLoggedOn());

        // Update last access time
        m_TimeAtLastAccess = GetCurrentTimeInSeconds();

        if ( dwError == NO_ERROR || !fTimedOut)
        {

            // dwError == NO_ERROR  ==> No error in transmitting data
            //   so decrease ref count and blow away the sockets.

            // if dwError != NO_ERROR then
            //    if timeout occured ==> ATQ will send another callback
            //                      so do not decrease ref count now.
            //    if no timeout ==> then decrement ref count now.

            DBG_REQUIRE( DeReference() > 0);
        }
        else
        {

            if ( fTimedOut)
            {
                SET_UF( this, DATA_TIMEDOUT);
            }
            else
            {
                SET_UF( this, DATA_ERROR);
            }

        }

# ifdef CHECK_DBG
        if ( dwError != NO_ERROR)
        {

            CHAR szBuffer[100];
            sprintf( szBuffer, " Data Socket Error = %u ", dwError);
            Print( szBuffer);
        }
# endif // CHECK_DBG

        CLEAR_UF( this, ASYNC_TRANSFER);

        //
        // Destroy the data connection.
        //  Send message accordingly to indicate if this was a failure/success
        //  That is done by DestroyDataConnection.
        //
        DBG_REQUIRE( DestroyDataConnection( dwOriginalError));


        if ( m_pOpenFileInfo != NULL)
        {
            //
            // set number of bytes actually sent
            //
            m_licbSent.QuadPart += cbIo;

            DBG_REQUIRE( CloseFileForSend( dwOriginalError));
        }

        if ( dwError == NO_ERROR)
        {

            //
            // Process any Pending commands, due to the parallel
            //    control channel operation for this user Connection.
            // For the present, we dont buffer commands ==> No processing
            //   to be done effectively.   NYI
            // Just ensure that there is a read-operation pending on
            //  control channel.
            //

            // BOGUS: DBG_ASSERT( TEST_UF( this, CONTROL_READ));
        }

        fReturn = TRUE;   // since this function went on well.
    }
    else if ( pAioConn == &m_AioControlConnection)
    {

        //
        // a control socket operation has completed.
        //

        if ( dwError != NO_ERROR)
        {

            //
            // There is an error in processing the control connection request.
            // the only ASYNC_IO request we submit on control is:
            //         Read request on control socket
            //

            if ( fTimedOut)
            {

                if ( TEST_UF( this, TRANSFER))
                {

                    // A data transfer is going on.
                    // allow client to send commands later
                    // (client may not be async in control/data io,so allow it)

                    // resubmit the control read operation
                    //  after clearing old one

                    //
                    // Since there is a pending IO in atq.
                    //  Just resume the timeout processing in ATQ for
                    //  this context.
                    //

                    pAioConn->ResumeIoOperation();
                    fReturn = TRUE;
                }
                else
                {

                    // For timeouts, ATQ sends two call backs.
                    //  So be careful to decrement reference count only once.

                    DBG_ASSERT( fReturn == FALSE);

                    DBG_ASSERT( TEST_UF( this, CONTROL_READ));
                    SET_UF( this, CONTROL_TIMEDOUT);
                }

            }
            else
            {

                // Either there should be a control read pending or
                // control socket should have received a timeout.
                DBG_ASSERT( TEST_UF( this, CONTROL_READ) ||
                            TEST_UF( this, CONTROL_TIMEDOUT)
                           );

                // a non-timeout error has occured. ==> stop read operation.
                StopControlRead(this);
                DBG_ASSERT( fReturn == FALSE);
                SET_UF( this, CONTROL_ERROR);
            }

        }
        else
        {

            // If this connection had an outstanding IO on wait queue, it
            //   got completed. Hence get rid of the reference count.
            StopControlRead( this);

            switch ( UserState)
            {

              case UserStateEmbryonic:

                fReturn = StartupSession( m_pvInitialRequest,
                                          m_cbInitialRequest);

                if ( m_pvInitialRequest == NULL)
                {
                    // No initial buffer. Wait for read to complete
                    break;
                }

                cbIo = m_cbInitialRequest;  // fake the bytes read.

                // Fall Through for processing request

              case UserStateWaitingForUser:
              case UserStateWaitingForPass:
              case UserStateLoggedOn:

            ProcessCommand:
                //
                // Input already read. Process request and submit another read.
                //

                fReturn = ParseAndProcessRequest(cbIo/sizeof(CHAR));

                if ( fReturn && IsDisconnected() &&
                     TEST_UF( this, CONTROL_TIMEDOUT))
                {

                    // disconnect only if no pending control read
                    // if there is a pending control read,
                    //  atq will pop this up for cleanup.
                    fReturn = !(TEST_UF( this, CONTROL_READ));

                    IF_DEBUG( ERROR) {
                        DBGPRINTF(( DBG_CONTEXT,
                                   "%08x ::Timeout killed conn while "
                                   " processing!\n State = %d(%x),"
                                   " Ref = %d, Id = %d, fRet=%d\n",
                                   this, QueryState(), Flags,
                                   QueryReference(), QueryId(), fReturn
                               ));
                    }
                    FacIncrement( CacTimeoutWhenProcessing);
                }
                break;

              case UserStateDisconnected:

                fReturn = TRUE;
                if ( TEST_UF( this, CONTROL_TIMEDOUT))
                {

                    // Timeout thread raced against me :(

                    IF_DEBUG( ERROR) {
                        DBGPRINTF(( DBG_CONTEXT,
                                   "%08x :: Conn already Disconnected !!!\n"
                                   " State = %d(%x), Ref = %d, Id = %d\n",
                                   this, QueryState(), Flags,
                                   QueryReference(), QueryId()
                                   ));
                    }
                    FacIncrement( CacTimeoutInDisconnect);
                    fReturn = FALSE;
                }
                break;

              default:

                DBG_ASSERT( !"Invalid UserState for processing\n");
                SetLastError( ERROR_INVALID_PARAMETER);
                break;
            } // switch

            dwError = ( fReturn) ? NO_ERROR : GetLastError();
        }

        if ( !fReturn)
        {
            DisconnectUserWithError( dwError, fTimedOut);
        }
    }
    else
    {

        DBG_ASSERT( !"call to Process() with wrong parameters");
    }

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[%lu] Leaving USER_DATA( %08x)::Process()."
                    " RefCount = %d. State = %d\n",
                    GetTickCount(),
                    this, QueryReference(), QueryState())
                  );
    }

    return ( fReturn);
} // USER_DATA::ProcessAsyncIoCompletion()






# define  min(a, b)    (((a) < (b)) ? (a) : (b))

BOOL
USER_DATA::StartupSession(IN PVOID  pvInitialRequest,
                          IN DWORD  cbInitialRequest
                          )
/*++
  This function allocates a buffer for receiving request from the client
   and also sets up initial read from the control socket to
   get client requests.

  Arguments:
    pvInitialRequest   pointer to initial request buffer
    cbInitialRequest   count of bytes of data in the initial request

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    SOCKERR serr;
    BOOL fReturn = FALSE;
    PCSTR pszBanner;

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG


    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    DBG_ASSERT( QueryState() == UserStateEmbryonic);

    //
    //  Reply to the initial connection message. ( Greet the new user).
    //

    pszBanner = QueryInstance()->QueryBannerMsg();

    if( pszBanner && *pszBanner ) {
        serr = SendMultilineMessage(
                                   REPLY_SERVICE_READY,
                                   g_FtpServiceNameString,
                                   TRUE,
                                   FALSE);

        serr = serr || SendMultilineMessage(
                                   REPLY_SERVICE_READY,
                                   pszBanner,
                                   FALSE,
                                   TRUE);
    } else {
        serr = ReplyToUser( this,
                           REPLY_SERVICE_READY,
                           "%s",
                           g_FtpServiceNameString );
    }

    if ( serr != 0) {

        IF_DEBUG( ERROR) {
            DBGPRINTF( ( DBG_CONTEXT,
                        " Cannot reply with initial connection message."
                        " Error = %lu\n",
                        serr));
        }

    } else {

        //
        //  enable OOB_INLINE since we are using that for our control socket
        //
        BOOL  fOobInline = TRUE;

        serr = setsockopt( QueryControlSocket(), SOL_SOCKET,
                           SO_OOBINLINE, (const char *) &fOobInline,
                          sizeof( fOobInline));

        m_cchPartialReqRecvd = 0;

        if ( serr == 0) {

            //
            // Try to set up the buffer and enter the mode for reading
            //  requests from the client
            //

            LockUser();
            if( QueryState() != UserStateDisconnected ) {
                SetState( UserStateWaitingForUser);
            }
            UnlockUser();

            if ( pvInitialRequest != NULL && cbInitialRequest > 0) {

                //
                // No need to issue a read, since we have the data required.
                // Do a safe copy to the buffer.
                //

                CopyMemory( QueryReceiveBuffer(), pvInitialRequest,
                       min( cbInitialRequest, QueryReceiveBufferSize())
                       );

                fReturn = TRUE;

            } else {

                fReturn = ReadCommand();
            }

        } else {

            IF_DEBUG( ERROR) {
                DBGPRINTF((DBG_CONTEXT,
                           " SetsockOpt( OOB_INLINE) failed. Error = %lu\n",
                           WSAGetLastError()));
            }

        }
    }

    IF_DEBUG( CLIENT) {

        DWORD  dwError = (fReturn) ? NO_ERROR : GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                    " connection ( %08x)::StartupSession() returns %d."
                    " Error = %lu\n",
                    this, fReturn,
                    dwError));

        if (fReturn)    {   SetLastError( dwError); }
    }

    return ( fReturn);

} // USER_DATA::StartupSession()



VOID
CheckAndProcessAbortOperation( IN LPUSER_DATA pUserData)
{
    if ( TEST_UF( pUserData, OOB_ABORT)) {

        //
        // An abort was requested by client. So our processing
        // has unwound and we are supposed to send some message
        //  to the client. ==> simulate processing ABOR command
        // ABORT was not processed yet; so process now.
        //

        DBGPRINTF((DBG_CONTEXT,
                   "Executing simulated Abort for %08x\n",
                   pUserData));

        FacIncrement( FacSimulatedAborts);

        // To avoid thread races, check twice.

        if ( TEST_UF( pUserData, OOB_ABORT)) {

          //
          // we need this stack variable (szAbort), so that
          //  ParseCommand() can freely modify the string!
          CHAR szAbort[10];

          CLEAR_UF( pUserData, OOB_ABORT);

          CopyMemory( szAbort, "ABOR", sizeof("ABOR"));
          ParseCommand( pUserData, szAbort);
        }
    }

    return;

} // CheckAndProcessAbortOperation()



BOOL
USER_DATA::ParseAndProcessRequest(IN DWORD cchRequest)
/*++
  This function parses the incoming request from client, identifies the
   command to execute and executes the same.
  Before parsing, the input is pre-processed to remove any of telnet commands
   or OOB_inlined data.

  Arguments:
    cchRequest         count of characters of request received.

--*/
{
    BOOL fLineEnded = FALSE;
    DWORD cchRequestRecvd = 0;
    CHAR szCommandLine[ MAX_COMMAND_LENGTH + 1];

# if DBG

    if ( !IS_VALID_USER_DATA( this))
    {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG


    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG( CLIENT)
    {

        DBGPRINTF( ( DBG_CONTEXT,
                    "UserData(%08x)::ParseAndProcessRequest( %d chars)\n",
                    this, cchRequest));
    }


    //
    // Fast-path if we're re-processing this command, which happens in PASV mode
    //
    if ( QueryInFakeIOCompletion() )
    {
        goto FastPathLabel;
    }


    if ( cchRequest > 0)
    {
        // We have a valid request. Process it

        // Update last access time
        m_TimeAtLastAccess = GetCurrentTimeInSeconds();

        m_pInstance->QueryStatsObj()->UpdateTotalBytesReceived(
                                                cchRequest*sizeof(CHAR));

        if ( m_cchPartialReqRecvd + cchRequest >=  MAX_COMMAND_LENGTH)
        {

            CHAR  szCmdFailed[600];
            wsprintfA( szCmdFailed,
                      " Command is too long:  Partial=%d bytes. Now=%d \n"
                      "  UserDb(%08x) = %s from Host: %s\n",
                      m_cchPartialReqRecvd, cchRequest,
                      this, QueryUserName(), QueryClientHostName());

            DBGPRINTF((DBG_CONTEXT, szCmdFailed));

            DisconnectUserWithError( ERROR_BUSY);

            return ( TRUE);  // we are done with this connection.
        }

        CopyMemory(szCommandLine, m_recvBuffer,
               m_cchPartialReqRecvd + cchRequest);
        szCommandLine[m_cchPartialReqRecvd + cchRequest] = '\0';

        if ( !::FilterTelnetCommands(szCommandLine,
                                     m_cchPartialReqRecvd + cchRequest,
                                     &fLineEnded,    &cchRequestRecvd))
        {

            if ( TEST_UF( this, TRANSFER))
            {

                //
                // I am in data transfer mode. Some other thread is sending
                //  data for this client. Just post a OOB_DATA and OOB_ABORT
                // OOB_DATA will cause the call-stack of other thread to unwind
                //   and get out of the command.
                // Then check if any async transfer was occuring. If so
                //  process abort with disconnect now.
                //

                SET_UF_BITS( this, (UF_OOB_DATA | UF_OOB_ABORT));

                if ( TEST_UF( this, ASYNC_TRANSFER))
                {

                    //
                    // An async transfer is occuring. Stop it
                    //
                    DestroyDataConnection( ERROR_OPERATION_ABORTED);

                    CheckAndProcessAbortOperation( this);
                }

# ifdef CHECK_DBG

                Print( " OOB_ABORT ");

# endif // CHECK_DBG

                IF_DEBUG( CLIENT) {

                    DBGPRINTF((DBG_CONTEXT,
                               "[%08x]Set up the implied ABORT command\n",
                               this));
                }

                IF_DEBUG( COMMANDS) {

                    DBGPRINTF((DBG_CONTEXT, " ***** [%08x] OOB_ABORT Set \n",
                               this));
                }

                // Ignore the rest of the commands that may have come in.
            }
            else
            {

                //
                // Since no command is getting processed.
                //   atleast process the abort command, otherwise clients hang.
                //

                //
                // we need this stack variable (szAbort), so that
                //  ParseCommand() can freely modify the string!
                CHAR szAbort[10];

                CopyMemory( szAbort, "ABOR", sizeof("ABOR"));
                ParseCommand( this, szAbort);
                CLEAR_UF( this, OOB_ABORT);  // clear the abort flag!
            }

        }
        else
        {

            if ( TEST_UF( this, TRANSFER))
            {

                //
                // we are transferring data, sorry no more commands accepted.
                // This could hang clients. Hey! they asked for it :( NYI
                //

                // Do nothing
                IF_DEBUG( COMMANDS) {

                    DBGPRINTF((DBG_CONTEXT,
                               "***** [%08x] Received Request %s during"
                               " transfer in progress\n",
                               this, szCommandLine));
                }

            }
            else
            {
                //
                //  Let ParseCommand do the dirty work.
                //


                // Remember the count of partial bytes received.
                m_cchPartialReqRecvd = cchRequestRecvd;

                if ( !fLineEnded)
                {

                    // In case if command was long enough to fill all buffer but
                    // we haven't found new line  simply tell to user about the error
                    // and disconnect. Some ftp clients will not see that msg, becuase
                    // connection was disconnected, but thats a bug in client code

                    if ( m_cchPartialReqRecvd >=  MAX_COMMAND_LENGTH - 1)
                    {
                        ReplyToUser( this,
                                     REPLY_UNRECOGNIZED_COMMAND,
                                     PSZ_COMMAND_TOO_LONG);
                        DisconnectUserWithError( ERROR_BUSY );

                        return ( TRUE);  // we are done with this connection.
                    }


                    //
                    // Complete line is not received. Continue reading
                    //   the requests, till we receive the complete request
                    //

                }
                else
                {

                    StartProcessingTimer();

                    //
                    // set the partial received byte count to zero.
                    //  we will not use this value till next incomplete request
                    //

                    m_cchPartialReqRecvd = 0;

FastPathLabel:
                    ParseCommand( this, ( QueryInFakeIOCompletion() ? QueryCmdString() :
                                                                      szCommandLine ) );

                    CheckAndProcessAbortOperation( this);

                } // if TRANSFER is not there...

            } //Parse if complete

        } // if FilterTelnetCommands()
    }
    else
    {
        // if (cchRequest <= 0)

        SET_UF( this, CONTROL_ZERO);

        //
        // after a quit a client is expected to wait for quit message from
        //  the server. if the client prematurely closes connection, then
        //  the server receives it as a receive with zero byte read.
        //  since, we should not be having outstanding read at this time,
        //   atq should not be calling us. On the contrary we are getting
        //  called by ATQ. Let us track this down.
        //

        if ( !TEST_UF( this, CONTROL_QUIT))
        {
            DisconnectUserWithError( NO_ERROR);
        }
        else
        {

            // Quit message is received and then ZeroBytes Received!!
            DBGPRINTF((DBG_CONTEXT,
                       " (%08x)::ZeroBytes recvd after QUIT message!!."
                       " State = %d(%x), Ref = %d\n",
                       this,
                       QueryState(), Flags,
                       QueryReference()
                       ));
            // Do nothing. Since Quit will take care of cleanup
            return (TRUE);
        }
    }

    //
    // If the connection is not yet disconnected, submit a read command.
    //  else return that everything is fine (someone had disconnected it).
    //

    return ( IsDisconnected() ? TRUE : ReadCommand());
} // USER_DATA::ParseAndProcessRequest()





BOOL
USER_DATA::ReadCommand( VOID)
{
    BOOL fReturn = TRUE;

    DBG_CODE(
             if ( !IS_VALID_USER_DATA( this)) {

                 DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                             this));
                 Print();
             }
             );

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );
    if ( TEST_UF( this, CONTROL_TIMEDOUT) || IsDisconnected()) {

        SetLastError( ERROR_SEM_TIMEOUT);
        return (FALSE);
    }

    //
    // Submit a read on control socket only if there is none pending!
    // Otherwise, behave in idempotent manner.
    //

    if ( !TEST_UF( this, CONTROL_READ)) {

        Reference();         // since we are going to set up async read.

        InterlockedIncrement( &m_nControlRead);

        DBG_ASSERT( m_nControlRead <= 1);

        SET_UF( this, CONTROL_READ);  // a read will be pending

        if ( !m_AioControlConnection.ReadFile(QueryReceiveBuffer(),
                                              QueryReceiveBufferSize())
            ) {

            CLEAR_UF( this, CONTROL_READ);  // since read failed.

            DBG_REQUIRE( DeReference() > 0);
            InterlockedDecrement( &m_nControlRead);

            DWORD dwError = GetLastError();

            IF_DEBUG( ERROR) {
                DBGPRINTF( ( DBG_CONTEXT,
                            " User( %08x)::ReadCommand() failed. Ref = %d."
                            " Error = %d\n",
                            this, QueryReference(), dwError));
            }

            SetLastError( dwError);
            fReturn = FALSE;
        }

    }

    return ( fReturn);
} // USER_DATA::ReadCommand()




BOOL
USER_DATA::DisconnectUserWithError(IN DWORD dwError,
                                   IN BOOL fNextMsg OPTIONAL)
/*++
  This function disconnects a user with the error code provided.
  It closes down the control connection by stopping ASYNC_IO.
  If the fNextMsg is not set, then it also decrements the reference count
    for the user data object, to be freed soon.

--*/
{
    CHAR   szBuffer[120];

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG ( CLIENT) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " USER_DATA( %08x)::DisconnectUserWithError( %lu, %d)."
                    " RefCount = %d\n",
                    this, dwError, fNextMsg, QueryReference()));
    }


    if (!fNextMsg) {
        RemoveActiveReference();
    }

    LockUser();

    if ( QueryState() == UserStateDisconnected) {

        //
        // It is already in disconnected state. Do nothing for disconnect.
        //

        UnlockUser();

    } else {

        SetState( UserStateDisconnected );
        UnlockUser();

        if( dwError == ERROR_SEM_TIMEOUT) {

            const CHAR * apszSubStrings[3];

            IF_DEBUG( CLIENT )
              {
                  DBGPRINTF(( DBG_CONTEXT,
                             "client (%08x) timed-out\n", this ));
              }

            sprintf( szBuffer, "%lu", m_pInstance->QueryConnectionTimeout() );

            apszSubStrings[0] = QueryUserName();
            apszSubStrings[1] = inet_ntoa( HostIpAddress );
            apszSubStrings[2] = szBuffer;

            g_pInetSvc->LogEvent( FTPD_EVENT_CLIENT_TIMEOUT,
                                  3,
                                  apszSubStrings,
                                  0 );

            ReplyToUser(this,
                        REPLY_SERVICE_NOT_AVAILABLE,
                        "Timeout (%lu seconds): closing control connection.",
                        m_pInstance->QueryConnectionTimeout() );
        }

        if ( dwError != NO_ERROR) {

# ifdef CHECK_DBG
            sprintf( szBuffer, " Control Socket Error=%u ", dwError);
            Print( szBuffer);
# endif // CHECK_DBG

            if( dwError != ERROR_SEM_TIMEOUT ) {
                SetLastReplyCode( REPLY_TRANSFER_ABORTED );
            }

            // Produce a log record indicating the cause for failure.
            WriteLogRecord( PSZ_CONNECTION_CLOSED_VERB, "", dwError);
        }

        //
        //  Force close the connection's sockets.  This will cause the
        //  thread to awaken from any blocked socket operation.  It
        //  is the destructor's responsibility to do any further cleanup.
        //  (such as calling UserDereference()).
        //

        CloseSockets(dwError != NO_ERROR);
    }

    return ( TRUE);

} // USER_DATA::DisconnectUserWithError()






static BOOL
DisconnectUserWorker( IN LPUSER_DATA  pUserData, IN LPVOID pContext)
/*++
  This disconnects (logically) a user connection, by resetting the
   control connection and stopping IO. Later on the blown away socket
   will cause an ATQ relinquish to occur to blow away of this connection.

  Arguments:
    pUserData   pointer to User data object for connection to be disconnected.
    pContext    pointer to context information
    ( in this case to DWORD containing error code indicating reasong for
         disconnect).

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DWORD  dwError;
    BOOL   retVal;
    DBG_ASSERT( pContext != NULL && pUserData != NULL);
    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );


    dwError = *(LPDWORD ) pContext;


    retVal = pUserData->DisconnectUserWithError( dwError, TRUE);

    // fix for bug 268175 : if we disconnected user we need to do normal cleanup
    // for that connection

    // this check is not very necessary but I leave it for future
    // DisconnectUserWithError always returns TRUE

    if (retVal)
    {
        DereferenceUserDataAndKill(pUserData);
    }


    return retVal;
} // DisconnectUserWorker()




BOOL
DisconnectUser( IN DWORD UserId, FTP_SERVER_INSTANCE *pInstance )
/*++
  This function disconnects a specified user identified using the UserId.
  If UserId specified == 0, then all the users will be disconnected.

  Arguments:
     UserId   user id for the connection to be disconnected.

  Returns:
     TRUE if atleast one of the connections is disconnected.
     FALSE if no user connetion found.

  History:
     06-April-1995 Created.
--*/
{
    BOOL   fFound;
    DWORD  dwError = ERROR_SERVER_DISABLED;

    pInstance->Reference();
    pInstance->LockConnectionsList();

    fFound = ( pInstance->
               EnumerateConnection( DisconnectUserWorker,
                                   (LPVOID ) &dwError,
                                   UserId));

    pInstance->UnlockConnectionsList();
    pInstance->Dereference();

    IF_DEBUG( CLIENT) {

        DWORD dwError = (fFound) ? NO_ERROR: GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                     " DisconnectUser( %d) returns %d. Error = %lu\n",
                    UserId, fFound, dwError));

        if (fFound)   { SetLastError( dwError); }
    }

    return ( fFound);
}   // DisconnectUser()





static BOOL
DisconnectUserWithNoAccessWorker( IN LPUSER_DATA  pUserData,
                                  IN LPVOID pContext)
/*++
  This disconnects (logically) a user connection with no access.
  This occurs by resetting the control connection and stopping IO.
  Later on the blown away thread
   will cause an ATQ relinquish to occur to blow away of this connection.

  Arguments:
    pUserData   pointer to User data object for connection to be disconnected.
    pContext    pointer to context information
    ( in this case to DWORD containing error code indicating reasong for
         disconnect).

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL fSuccess = TRUE;
    DBG_ASSERT( pUserData != NULL);

    // Ignode the pContext information.

    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );

    //
    //  We're only interested in connected users.
    //

    if( pUserData->IsLoggedOn()) {

        //
        //  If this user no longer has access to their
        //  current directory, blow them away.
        //

        if( !pUserData->VirtualPathAccessCheck(AccessTypeRead )) {

            const CHAR * apszSubStrings[2];

            IF_DEBUG( SECURITY ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "User %s (%lu) @ %08lX retroactively"
                           " denied access to %s\n",
                           pUserData->QueryUserName(),
                           pUserData->QueryId(),
                           pUserData,
                           pUserData->QueryCurrentDirectory() ));
            }


            fSuccess = ( pUserData->
                           DisconnectUserWithError(ERROR_ACCESS_DENIED,
                                                   TRUE)
                        );

            //
            //  Log an event to tell the admin what happened.
            //

            apszSubStrings[0] = pUserData->QueryUserName();
            apszSubStrings[1] = pUserData->QueryCurrentDirectory();

            g_pInetSvc->LogEvent( FTPD_EVENT_RETRO_ACCESS_DENIED,
                                  2,
                                  apszSubStrings,
                                  0 );
        } // no access

    } // logged on user

    IF_DEBUG( CLIENT) {

        DWORD dwError = (fSuccess) ? NO_ERROR: GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                    " DisconnectUsersWithNoAccessWorker( %d) returns %d."
                    " Error = %lu\n",
                    pUserData->QueryId(), fSuccess,
                    dwError)
                  );

        if (fSuccess)   { SetLastError( dwError); }
    }

    return ( fSuccess);
} // DisconnectUserWithNoAccessWorker()



VOID
DisconnectUsersWithNoAccess(FTP_SERVER_INSTANCE *pInstance )
/*++
  This function disconnects all users who do not have read access to
  their current directory. This is typically called when the access masks
  have been changed.

  Arguments:
    None

  Returns:
    None.
--*/
{
    BOOL   fFound;
    DWORD  dwError = ERROR_ACCESS_DENIED;

    pInstance->Reference();
    pInstance->LockConnectionsList();

    fFound = ( pInstance->
               EnumerateConnection( DisconnectUserWithNoAccessWorker,
                                   (LPVOID ) &dwError,
                                   0));

    pInstance->UnlockConnectionsList();
    pInstance->Dereference();

    IF_DEBUG( CLIENT) {

        DWORD dwError = (fFound) ? NO_ERROR: GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                    " DisconnectUsersWithNoAccess() returns %d."
                    " Error = %lu\n",
                    fFound, dwError)
                  );

        if (fFound)   { SetLastError( dwError); }
    }


}   // DisconnectUsersWithNoAccess




/*++
  The following structure UserEnumBuffer is required to carry the context
  information for enumerating the users currently connected.
  It contains a pointer to array of USER_INFO structures which contain the
   specific information for the user. The user name is stored in the buffer
   from the end ( so that null terminated strings are formed back to back.
   This permits efficient storage of variable length strings.

   The member fResult is used to carry forward the partial result of
    success/failure from one user to another ( since the enumeration has
    to walk through all the elements to find out all user information).


  History: MuraliK ( 12-April-1995)

--*/
struct  USER_ENUM_BUFFER {

    DWORD   cbSize;                   // pointer to dword containing size of
    IIS_USER_INFO_1 * pUserInfo;      // pointer to start of array of USER_INFO
    DWORD   cbRequired;               // incremental count of bytes required.
    DWORD   nEntry;      // number of current entry ( index into  pUserInfo)
    DWORD   dwCurrentTime;            // current time
    WCHAR * pszNext;                  // pointer to next string location.
    BOOL    fResult;             // boolean flag accumulating partial results
};

typedef USER_ENUM_BUFFER  * PUSER_ENUM_BUFFER;


BOOL
EnumerateUserInBufferWorker( IN LPUSER_DATA pUserData,
                             IN LPVOID pContext)
{
# ifdef CHECK_DBG
    CHAR   szBuffer[400];
# endif // CHECK_DBG

    PUSER_ENUM_BUFFER  pUserEnumBuffer = (PUSER_ENUM_BUFFER ) pContext;
    DWORD     tConnect;
    DWORD     cbUserName;
    LPDWORD   pcbBuffer;

    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );

    //
    //  We're only interested in connected users.
    //

    if( pUserData->IsDisconnected()) {

        return ( TRUE);
    }

    //
    //  Determine required buffer size for current user.
    //

    cbUserName  = ( strlen( pUserData->QueryUserName() ) + 1 ) * sizeof(WCHAR);
    pUserEnumBuffer->cbRequired += sizeof(IIS_USER_INFO_1);

    //
    //  If there's room for the user data, store it.
    //

    tConnect = ( pUserEnumBuffer->dwCurrentTime -
                pUserData->QueryTimeAtConnection());

    if( pUserEnumBuffer->fResult &&
       ( pUserEnumBuffer->cbRequired <= pUserEnumBuffer->cbSize)
       ) {

        LPIIS_USER_INFO_1 pUserInfo =
          &pUserEnumBuffer->pUserInfo[ pUserEnumBuffer->nEntry];

        pUserInfo->idUser     = pUserData->QueryId();
        pUserInfo->pszUser    = (WCHAR *)MIDL_user_allocate( cbUserName );

        if( pUserInfo->pszUser ) {

            pUserInfo->fAnonymous = ( pUserData->Flags & UF_ANONYMOUS ) != 0;
            pUserInfo->inetHost   = (DWORD)pUserData->HostIpAddress.s_addr;
            pUserInfo->tConnect   = tConnect;

            if( !MultiByteToWideChar( CP_OEMCP,
                                     0,
                                     pUserData->QueryUserName(),
                                     -1,
                                     pUserInfo->pszUser,
                                     (int)cbUserName )
               ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "MultiByteToWideChar failed???\n" ));

                pUserEnumBuffer->fResult = ( pUserEnumBuffer->fResult && FALSE);
            } else {
                pUserEnumBuffer->nEntry++;
            }
        }
        else {

            //
            // Unable to allocate memory
            //
            pUserEnumBuffer->fResult = ( pUserEnumBuffer->fResult && FALSE);
        }

    } else {

        pUserEnumBuffer->fResult = ( pUserEnumBuffer->fResult && FALSE);
    }

# ifdef CHECK_DBG

    sprintf( szBuffer, " Enum  tLastAction=%u;  tConnect=%u. " ,
            ( pUserEnumBuffer->dwCurrentTime -
             pUserData->QueryTimeAtLastAccess()),
            tConnect
            );

    pUserData->Print( szBuffer);

# endif // CHECK_DBG

    return ( TRUE);
} // EnumerateUserInBufferWorker()



BOOL
EnumerateUsers(
    PCHAR   pBuffer,
    PDWORD  pcbBuffer,
    PDWORD  nRead,
    FTP_SERVER_INSTANCE *pInstance
    )
/*++
  Enumerates the current active users into the specified buffer.

  Arguments:
    pvEnum   pointer to enumeration buffer which will receive the number of
                   entries and the user information.
    pcbBuffer  pointer to count of bytes. On entry this contains the size in
                   bytes of the enumeration buffer. It receives the count
                   of bytes for enumerating all the users.
    nRead - pointer to a DWORD to return the number of user entries filled.

  Returns:
    TRUE  if enumeration is successful ( all connected users accounted for)
    FALSE  otherwise

--*/
{
    USER_ENUM_BUFFER       userEnumBuffer;
    BOOL   fSuccess;

    DBG_ASSERT( pcbBuffer != NULL );

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering EnumerateUsers( %08x, %08x[%d]).\n",
                    pBuffer, pcbBuffer, *pcbBuffer));
    }

    //
    //  Setup the data in user enumeration buffer.
    //

    userEnumBuffer.cbSize     = *pcbBuffer;
    userEnumBuffer.cbRequired = 0;
    userEnumBuffer.pUserInfo  = (LPIIS_USER_INFO_1)pBuffer;
    userEnumBuffer.nEntry     = 0;
    userEnumBuffer.dwCurrentTime = GetCurrentTimeInSeconds();
    userEnumBuffer.fResult    = TRUE;

    //
    // CODEWORK
    // This field is obsolete it now points to the extra CONN_LEEWAY
    // buffer.
    //
    userEnumBuffer.pszNext    = ((WCHAR *)( pBuffer + *pcbBuffer));


    //
    //  Scan the users and get the information required.
    //

    pInstance->Reference();
    pInstance->LockConnectionsList();

    fSuccess = (pInstance->
                EnumerateConnection( EnumerateUserInBufferWorker,
                                    (LPVOID ) &userEnumBuffer,
                                    0));

    pInstance->UnlockConnectionsList();
    pInstance->Dereference();

    //
    //  Update enum buffer header.
    //

    *nRead             = userEnumBuffer.nEntry;
    *pcbBuffer         = userEnumBuffer.cbRequired;

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF((DBG_CONTEXT,
                   " Leaving EnumerateUsers() with %d."
                   " Entries read =%d. BufferSize required = %d\n",
                   userEnumBuffer.fResult,
                   userEnumBuffer.nEntry, userEnumBuffer.cbRequired));
    }

    return ( userEnumBuffer.fResult);

}   // EnumerateUsers




SOCKERR
USER_DATA::SendMultilineMessage(
    IN UINT  nReplyCode,
    IN LPCSTR pszzMessage,
    IN BOOL fIsFirst,
    IN BOOL fIsLast)
/*++
  Sends a multiline message to the control socket of the client.

  Arguments:
    nReplyCode   the reply code to use for the first line of the multi-line
                  message.
    pszzMessage  pointer to double null terminated sequence of strings
                  containing the message to be sent.
    fIsFirst     flag to indicate we are starting the multiline reply. if FALSE,
                  don't print the code for the first line, as it was already emmited elsewhere
    fIsLast      flag to indicate we are finishing the multiline reply. if FALSE,
                  don't print the code for the first line, as it was already emmited elsewhere

    If the message is empty, we do not print anything. If there is only one line, then if
    fIsLast is TRUE, we only print the terminating line, otherwise we do print the openning
    line if fIsFirst is TRUE.

  Returns:
    SOCKERR  - 0 if successful, !0 if not.

  History:
    MuraliK    12-April-1995
--*/
{
    SOCKERR   serr = 0;
    LPCSTR    pszMsg, pszNext;

    //
    // return if there is nothing to send
    //

    if ( pszzMessage == NULL || *pszzMessage == '\0') {
        return serr;
    }


    for ( pszMsg = pszzMessage;  serr == 0 && *pszMsg != '\0';  pszMsg = pszNext) {

        //
        // find next message so that we can check of pszMsg is the last line
        //

        pszNext = pszMsg + strlen( pszMsg) + 1;

        if( fIsLast && *pszNext == '\0' ) {
            //
            // This is globally the last line. Print it pefixed with the reply code.
            //
            serr = SockPrintf2(this, QueryControlSocket(),
                               "%u %s",
                               nReplyCode,
                               pszMsg);

        } else if( fIsFirst ) {
            //
            // this is globally the first line of reply, and it is not globally the last one.
            // print it with '-'.
            //
            serr = SockPrintf2(this, QueryControlSocket(),
                               "%u-%s",
                               nReplyCode,
                               pszMsg);

            fIsFirst = FALSE;
        } else {
            //
            // this is either an intermediate line, or the last line in this batch (but
            // not globally), so print it idented without the reply code.
            //
            serr = SockPrintf2(this, QueryControlSocket(),
                               "    %s",
                               pszMsg);
        }
    } // for

    return ( serr);

} // USER_DATA::SendMultilineMessge()






SOCKERR
USER_DATA::SendDirectoryAnnotation( IN UINT ReplyCode, IN BOOL fIsFirst)
/*++
    SYNOPSIS:   Tries to open the FTPD_ANNOTATION_FILE (~~ftpsvc~~.ckm)
                file in the user's current directory.  If it can be
                opened, it is sent to the user over the command socket
                as a multi-line reply.

    ENTRY:
                ReplyCode - The reply code to send as the first line
                    of this multi-line reply.

                fIsFirst - flag to indicate if this is the first line in the multi-line
                    reply. If not, the ReplyCode is not shown

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     06-May-1993 Created.
        MuraliK     12-Apr-1995 Made it to be part of USER_DATA
--*/
{
    FILE    * pfile;
    SOCKERR   serr = 0;
    CHAR      szLine[MAX_REPLY_LENGTH+1];


    //
    //  Try to open the annotation file.
    //

    pfile = Virtual_fopen( this,
                           FTPD_ANNOTATION_FILE,
                           "r" );

    if( pfile == NULL )
    {
        //
        //  File not found.  Blow it off.
        //

        return 0;
    }


    // protection agians attack when CKM file islarge, somebody is downloading it
    // slowly on many connections and uses all ATQ threads. Note that attack is still possible
    // but much more difficult to achieve

    AtqSetInfo( AtqIncMaxPoolThreads, 0);

    //
    //  While there's more text in the file, blast
    //  it to the user.
    //

    while( fgets( szLine, MAX_REPLY_LENGTH, pfile ) != NULL )
    {
        CHAR * pszTmp = szLine + strlen(szLine) - 1;

        //
        //  Remove any trailing CR/LFs in the string.
        //

        while( ( pszTmp >= szLine ) &&
               ( ( *pszTmp == '\n' ) || ( *pszTmp == '\r' ) ) )
        {
            *pszTmp-- = '\0';
        }

        //
        //  Ensure we send the proper prefix for the
        //  very *first* line of the file.
        //

        if( fIsFirst )
        {
            serr = SockPrintf2(this,
                               QueryControlSocket(),
                               "%u-%s",
                               ReplyCode,
                               szLine );

            fIsFirst = FALSE;
        }
        else
        {
            serr = SockPrintf2(this,
                               QueryControlSocket(),
                               "   %s",
                               szLine );
        }

        if( serr != 0 )
        {
            //
            //  Socket error sending file.
            //

            break;
        }
    }

    AtqSetInfo( AtqDecMaxPoolThreads, 0);

    //
    //  Cleanup.
    //

    if ( 0 != fclose( pfile )) {

        IF_DEBUG( ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "[%08x]::SendAnnotationFile() file close failed. "
                       " Error = %d\n",
                       this,
                       GetLastError()
                       ));
        }
    }

    return serr;

}   // USER_DATA::SendDirectoryAnnotation()




SOCKERR
USER_DATA::SendErrorToClient(
   IN LPCSTR pszPath,
   IN DWORD  dwError,
   IN LPCSTR pszDefaultErrorMsg,
   IN UINT nReplyCode
   )
/*++
  Send an error message indicating that the path is not found or
   a particular error occured in a path.

  Arguments:
    sock       socket to be used for synchronously sending message
    pszPath    pointer to path to be used.
    dwError    DWORD containing the error code, used for getting error text.
    pszDefaultErrorMsg  pointer to null-terminated string containing the
                     error message to be used if we can't alloc error text.
    nReplyCode UINT containing the FTP reply code.

  Returns:
    SOCKERR.  0 if successful and !0 if failure.
--*/
{
    BOOL    fDelete = TRUE;
    LPCSTR  pszText;
    APIERR serr;

    DBG_ASSERT( pszPath != NULL);
    pszText = AllocErrorText( dwError );

    if( pszText == NULL ) {

        pszText = pszDefaultErrorMsg;
        fDelete = FALSE;
    }

    serr = ReplyToUser( this,
                        nReplyCode,
                        PSZ_FILE_ERROR,
                        pszPath,
                        pszText );

    if( fDelete ) {

        FreeErrorText( (char *) pszText );
    }

    return ( serr);
} // USER_DATA::SendErrorToClient()





BOOL
USER_DATA::FreeUserToken( VOID)
/*++

   This function frees the user token if present already.
   Otherwise does nothing.
--*/
{
    BOOL fReturn = TRUE;

    if( UserToken != NULL ) {

        fReturn = TsDeleteUserToken( UserToken );

        UserToken = NULL;
        ::RevertToSelf();
    }

    return ( fReturn);
} // USER_DATA::FreeUserToken()


APIERR
USER_DATA::CdToUsersHomeDirectory(IN const CHAR * pszAnonymousName)
/*++
  This function changes user's home directory.
  First, a CD to the virtual root is attempted.
  If this succeeds, a CD to pszUser is attempted.
  If this fails, a CD to DEFAULT_SUB_DIRECTORY is attempted.

  Returns:
    APIERR.  NO_ERROR on success.
--*/
{
    APIERR   err;
    PCSTR    pszUser;
    CHAR     rgchRoot[MAX_PATH];

    //
    //  Try the top-level home directory.  If this fails, bag out.
    //   Set and try to change directory to symbolic root.
    //

    m_szCurrentDirectory[0] = '\0'; // initially nothing.

    m_pInstance->LockThisForRead();
    DBG_ASSERT( strlen( m_pInstance->QueryRoot()) < MAX_PATH);
    P_strncpy( rgchRoot, m_pInstance->QueryRoot(), MAX_PATH);
    m_pInstance->UnlockThis();

    err = VirtualChDir( this, rgchRoot); // change to default dir.

    if ( (err == NO_ERROR) &&
         (m_pInstance->QueryIsolationMode() == NoIsolation) ) {

        //
        //  We successfully CD'd into the top-level home
        //  directory.  Now see if we can CD into pszUser.
        //

        P_strncpy( rgchRoot, QueryRootDirectory(), MAX_PATH);
        if ( !VirtualChDir( this, rgchRoot ) ) {

            //
            //  Nope, try DEFAULT_SUB_DIRECTORY. If this fails, just
            //  hang-out at the top-level home directory.
            //

            P_strncpy( rgchRoot, PSZ_DEFAULT_SUB_DIRECTORY, MAX_PATH);
            VirtualChDir( this, rgchRoot );
        }
    }

    return ( err);

}   // USER_DATA::CdToUsersHomeDirectory()


VOID
USER_DATA::SetRootDirectory(
   IN PCSTR pszAnonymousName)
/*++
  this function sets the home directory for the logging in user,
  based on the current isolation mode. If we are in no-isolation mode,
  the user name excluding domain name is used. In isolation mode <domain>\<user>
  is used for domain users, and local\<user> for local domain users. The
  anonymous user gets 'LocalUser\public' in the isolation mode, and pszAnonymousName in
  the no-isolation mode. For full hosting isolatin mode, the home directory is
  retrieved from the AD

  Arguments:
  pszUser            the user name logging in
  pszAnonymousName   the name of the anonymous directory

  Returns:
  NO_ERROR on success, WinError otherwise.
--*/
{
    PUCHAR puch;
    PCSTR  pszUserName;


    // BUGBUG: handle UPN names

    switch (m_pInstance->QueryIsolationMode()) {

    case NoIsolation:

        m_szRootDir[ 0 ] = '\\';

        if( TEST_UF( this, ANONYMOUS ) ) {

            strcpy( m_szRootDir + 1, pszAnonymousName);

        } else {
            pszUserName = (PCHAR)_mbspbrk( (PUCHAR)QueryUserName(), (PUCHAR)"/\\" );

            pszUserName = (pszUserName == NULL) ? QueryUserName() : pszUserName + 1;

            P_strncpy( m_szRootDir + 1, pszUserName, sizeof( m_szRootDir ) - 1);
        }

        break;

    case StandAloneIsolation:

        m_szRootDir[ 0 ] = '\\';

        if( TEST_UF( this, ANONYMOUS ) ) {

            memcpy( m_szRootDir + 1,
                    SZ_LOCALUSER_DIR,
                    sizeof( SZ_LOCALUSER_DIR ) - 1 );

            memcpy( m_szRootDir + sizeof( SZ_LOCALUSER_DIR ),
                    SZ_ANONYMOUS_DIR,
                    sizeof( SZ_ANONYMOUS_DIR ));

        } else {

            if (_mbspbrk( (PUCHAR)QueryUserName(), (PUCHAR)"/\\" )) {

                P_strncpy( m_szRootDir + 1, QueryUserName(), MAX_PATH - 1);

                FlipSlashes( m_szRootDir );

            } else {

                memcpy( m_szRootDir + 1,
                        SZ_LOCALUSER_DIR,
                        sizeof( SZ_LOCALUSER_DIR ) - 1 );

                P_strncpy( m_szRootDir + sizeof( SZ_LOCALUSER_DIR ),
                        QueryUserName(),
                        sizeof( m_szRootDir ) - sizeof( SZ_LOCALUSER_DIR ));
            }
        }

        break;

    case EnterpriseIsolation:

       DBG_ASSERT( FALSE ); // BUGBUG: not implemented

       break;

    default:

       DBG_ASSERT( FALSE );
    }
}


APIERR
USER_DATA::OpenFileForSend( IN LPSTR pszFile)
/*++
  Open an existing file for transmission using TransmitFile.
  This function converts the given relative path into canonicalized full
    path and opens the file through the cached file handles manager.

  Arguments:
    pszFile   pointer to null-terminated string containing the file name

  Returns:
    TRUE on success and FALSE if any failure.
--*/
{
    APIERR  err;
    CHAR   szCanonPath[MAX_PATH];
    DWORD  cbSize = MAX_PATH*sizeof(CHAR);
    CHAR   szVirtualPath[MAX_PATH+1];
    DWORD  cchVirtualPath = MAX_PATH;

    DBG_ASSERT( pszFile != NULL );

    //
    // Close any file we might have open now
    // N.B. There shouldn't be an open file; we're just
    // being careful here.
    //

    if (m_pOpenFileInfo) {
        DBGPRINTF(( DBG_CONTEXT,
                   "WARNING!! Closing [%08x], before opening %s\n",
                   pszFile
                   ));
        DBG_REQUIRE( CloseFileForSend() );
    }

    //
    // Open the requested file
    //
    err = VirtualCanonicalize(szCanonPath,
                              &cbSize,
                              pszFile,
                              AccessTypeRead,
                              NULL,
                              szVirtualPath,
                              &cchVirtualPath);

    if( err == NO_ERROR ) {

        DWORD                   dwCreateFlags = 0;

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                        "Opening File: %s\n", szCanonPath ));
        }

        // store the virtual path name of file.
        P_strncpy( m_rgchFile, szVirtualPath, sizeof(m_rgchFile));

        dwCreateFlags = TS_FORBID_SHORT_NAMES | TS_NOT_IMPERSONATED ;


        if ( m_pMetaData )
        {
            if ( m_pMetaData->QueryDoCache() )
            {
                dwCreateFlags |= TS_CACHING_DESIRED;
            }
        }
        else
        {
            dwCreateFlags |= TS_CACHING_DESIRED;
        }

        m_pOpenFileInfo = TsCreateFile( m_pInstance->GetTsvcCache(),
                                szCanonPath,
                                QueryImpersonationToken(),
                                dwCreateFlags
                                );
                                // caching desired.

        if( m_pOpenFileInfo == NULL ) {

            err = GetLastError();

        } else {

            DWORD dwAttrib = m_pOpenFileInfo->QueryAttributes();

            FacIncrement( FacFilesOpened);

            DBG_ASSERT( dwAttrib != 0xffffffff);

            if (dwAttrib == 0xFFFFFFFF ||   // invalid attributes
                dwAttrib & (FILE_ATTRIBUTE_DIRECTORY |
                            FILE_ATTRIBUTE_HIDDEN |
                            FILE_ATTRIBUTE_SYSTEM)
                ) {

                FacIncrement( FacFilesInvalid);

                err =  ERROR_FILE_NOT_FOUND;
            }

        }
    }

    if( err != NO_ERROR ) {

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot open %s, error %lu\n",
                       pszFile,
                       err ));
        }
    }

    return ( err);
} // USER_DATA::OpenFileForSend()





BOOL
USER_DATA::CloseFileForSend( IN DWORD dwError)
{
    BOOL fReturn = TRUE;
    TS_OPEN_FILE_INFO * pOpenFileInfo;

    // make sure it includes the full path
    DBG_ASSERT( m_rgchFile[0] == '/');

    pOpenFileInfo = (TS_OPEN_FILE_INFO *) InterlockedExchangePointer(
                                              (PVOID *) &m_pOpenFileInfo,
                                              NULL
                                              );

    if ( pOpenFileInfo != NULL) {

        //
        // Fabricate an appropriate reply code based on the incoming
        // error code. WriteLogRecord() will pick up this reply code
        // and use it in the activity log.
        //

        SetLastReplyCode(
            ( dwError == NO_ERROR )
                ? REPLY_TRANSFER_OK
                : REPLY_TRANSFER_ABORTED
                );

        FacIncrement( FacFilesClosed);
        TsCloseHandle( m_pInstance->GetTsvcCache(), pOpenFileInfo);
        WriteLogRecord( PSZ_SENT_VERB, m_rgchFile, dwError);
    }

    return ( fReturn);
} // USER_DATA::CloseFileForSend()






# define MAX_ERROR_MESSAGE_LEN   ( 500)
VOID
USER_DATA::WriteLogRecord( IN LPCSTR  pszVerb,
                           IN LPCSTR  pszPath,
                           IN DWORD   dwError)
/*++
  This function writes the log record for current request made to the
   Ftp server by the client.

  Arguments:
    pszVerb    - pointer to null-terminated string containing the verb
                 of operation done
    pszPath    - pointer to string containing the path for the verb
    dwError    - DWORD containing the error code for operation

  Returns:
    None.
--*/
{
    INETLOG_INFORMATION   ilRequest;
    DWORD dwLog;
    CHAR  pszClientHostName[50];
    CHAR  pszServerIpAddress[50];
    CHAR  rgchRequest[MAX_PATH + 20];
    DWORD cch;
    static CHAR szFTPVersion[]="FTP";

    BOOL  fDontLog = m_pMetaData && m_pMetaData->DontLog();

    if (!fDontLog)
    {

                //
                // Fill in the information that needs to be logged.
                //

                ZeroMemory(&ilRequest, sizeof(ilRequest));

                strcpy( pszClientHostName, (char *)QueryClientHostName());
                ilRequest.pszClientHostName       = pszClientHostName;
                ilRequest.cbClientHostName       = strlen(pszClientHostName);

                ilRequest.pszClientUserName       = (char *)QueryUserName();
                strcpy( pszServerIpAddress, inet_ntoa( LocalIpAddress ));
                ilRequest.pszServerAddress        = pszServerIpAddress;

                ilRequest.msTimeForProcessing     = QueryProcessingTime();
                ilRequest.dwBytesSent             = m_licbSent.LowPart;
                ilRequest.dwBytesRecvd            = m_cbRecvd;
                ilRequest.dwProtocolStatus        = GetLastReplyCode();
                ilRequest.dwWin32Status           = dwError;
                ilRequest.dwPort                  = ntohs ((WORD)LocalIpPort);

                cch = wsprintfA( rgchRequest, "[%d]%s", QueryId(), pszVerb);
                DBG_ASSERT( cch < MAX_PATH + 20);

                ilRequest.pszOperation            = rgchRequest;
                if ( rgchRequest != NULL ) {
                        ilRequest.cbOperation            = strlen(rgchRequest);
                } else {
                        ilRequest.cbOperation            = 0;
                }

                ilRequest.pszTarget               = (char *)pszPath;
                if ( pszPath != NULL ) {
                        ilRequest.cbTarget               = strlen((char *)pszPath);
                } else {
                        ilRequest.cbTarget               = 0;
                }

                ilRequest.pszParameters             = "";
                ilRequest.pszVersion                = szFTPVersion;

                dwLog = m_pInstance->m_Logging.LogInformation( &ilRequest);

                if ( dwLog != NO_ERROR) {
                        IF_DEBUG( ERROR) {

                                DBGPRINTF((DBG_CONTEXT,
                                                   " Unable to log information to logger. Error = %u\n",
                                                   dwLog));

                                DBGPRINTF((DBG_CONTEXT,
                                                   " Request From %s, User %s. Request = %s %s\n",
                                                   ilRequest.pszClientHostName,
                                                   ilRequest.pszClientUserName,
                                                   ilRequest.pszOperation,
                                                   ilRequest.pszTarget));
                        }
                }

                //
                // LogInformation() should not fail.
                //  If it does fail, the TsvcInfo will gracefully suspend logging
                //    for now.
                //  We may want to gracefully handle the same.
        //
    }

    m_cbRecvd = 0;        // reset since we wrote the record

    m_pInstance->QueryStatsObj()->UpdateTotalBytesSent( m_licbSent.QuadPart );
    m_licbSent.QuadPart = 0;

    return;
} // USER_DATA::WriteLogRecord()

VOID
USER_DATA::WriteLogRecordForSendError( DWORD dwError )
{
    //
    // We put this into its own method in this file so it can access
    // the common PSZ_SENT_VERB global.
    //

    WriteLogRecord(
        PSZ_SENT_VERB,
        m_rgchFile,
        dwError
        );

}   // USER_DATA::WriteLogRecordForSendError



//
//  Private functions.
//

VOID
USER_DATA::CloseSockets(IN BOOL fWarnUser)
/*++
  Closes sockets (data and control) opened by the user for this session.

  Arguments:
    fWarnUser  - If TRUE, send the user a warning shot before closing
                   the sockets.
--*/
{
    SOCKET PassiveSocket;
    SOCKET ControlSocket;

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    //
    //  Close any open sockets.  It is very important to set
    //  PassiveDataListen socket & ControlSocket to INVALID_SOCKET
    //   *before* we actually close the sockets.
    //  Since this routine is called to
    //  disconnect a user, and may be called from the RPC thread,
    //  closing one of the sockets may cause the client thread
    //  to unblock and try to access the socket.  Setting the
    //  values in the per-user area to INVALID_SOCKET before
    //  closing the sockets keeps this from being a problem.
    //
    //  This was a problem created by the Select or WaitForMultipleObjects()
    //   Investigate if such race conditions occur with   Asynchronous IO?
    //      NYI
    //

    CleanupPassiveSocket( TRUE );

    //
    // Get rid of the async io connection used for data transfer.
    //

    m_AioDataConnection.StopIo( NO_ERROR);

    ControlSocket = QueryControlSocket();

    if( ControlSocket != INVALID_SOCKET )
    {
        if( fWarnUser )
        {
            //
            //  Since this may be called in a context other than
            //  the user we're disconnecting, we cannot rely
            //  on the USER_DATA fields.  So, we cannot call
            //  SockReply, so we'll kludge one together with
            //  SockPrintf2.
            //

            SockPrintf2( this,
                         ControlSocket,
                         "%d Terminating connection.",
                         REPLY_SERVICE_NOT_AVAILABLE );
        }

        StopControlIo(); // to stop the io on control socket.
    }

    return;

}   // USER_DATA::CloseSockets()


/*******************************************************************

    NAME:       UserpGetNextId

    SYNOPSIS:   Returns the next available user id.

    RETURNS:    DWORD - The user id.

    HISTORY:
        KeithMo     23-Mar-1993 Created.

********************************************************************/
DWORD
UserpGetNextId(
    VOID
    )
{
    DWORD userId;

    // Increment the global counter, avoiding it from becoming 0.
    InterlockedIncrement( (LPLONG ) &p_NextUserId);

    if ((userId = p_NextUserId) == 0) {

        InterlockedIncrement( (LPLONG ) &p_NextUserId);
        userId = p_NextUserId;
    }

    DBG_ASSERT( userId != 0);

    return userId;

}   // UserpGetNextId





VOID
USER_DATA::Print( IN LPCSTR pszMsg) const
/*++

  Prints the UserData object in debug mode.

  History:
     MuraliK  28-March-1995  Created.
--*/
{

# ifdef CHECK_DBG
    CHAR   szBuffer[1000];

    sprintf( szBuffer,
            "[%d] %s: {%u} \"%s\" State=%u. Ref=%u.\n"
            "    Ctrl sock=%u; Atq=%x. Data sock=%u; Atq=%x. CtrlRead=%u\n"
            "    LastCmd= \"%s\"\n",
            GetCurrentThreadId(), pszMsg,
            QueryId(), QueryUserName(),
            QueryState(), QueryReference(),
            QueryControlSocket(), m_AioControlConnection.QueryAtqContext(),
            QueryDataSocket(), m_AioDataConnection.QueryAtqContext(),
            TEST_UF( this, CONTROL_READ), m_recvBuffer
            );

    OutputDebugString( szBuffer);

# endif // CHECK_DBG

#ifndef _NO_TRACING_
    CHKINFO( ( DBG_CONTEXT,
                " Printing USER_DATA( %08x)   Signature: %08x\n"
                " RefCount  = %08x;  UserState = %08x;\n"
                " ControlSocket = %08x; PassiveL = %08x\n"
                " FileInfo@ = %08x; CurDir( %s) Handle = %08x\n"
                " UserName = %s; UserToken = %08x; UserId = %u\n"
                " Behaviour Flags = %08x; XferType = %d; XferMode = %d\n",
                this, Signature, m_References, UserState,
                QueryControlSocket(), m_sPassiveDataListen,
                m_pOpenFileInfo, QueryCurrentDirectory(), CurrentDirHandle,
                QueryUserName(), UserToken, QueryId(),
                Flags, m_xferType, m_xferMode));
#else
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing USER_DATA( %08x)   Signature: %08x\n"
                " RefCount  = %08x;  UserState = %08x;\n"
                " ControlSocket = %08x; PassiveL = %08x\n"
                " FileInfo@ = %08x; CurDir( %s) Handle = %08x\n"
                " UserName = %s; UserToken = %08x; UserId = %u\n"
                " Behaviour Flags = %08x; XferType = %d; XferMode = %d\n",
                this, Signature, m_References, UserState,
                QueryControlSocket(), m_sPassiveDataListen,
                m_pOpenFileInfo, QueryCurrentDirectory(), CurrentDirHandle,
                QueryUserName(), UserToken, QueryId(),
                Flags, m_xferType, m_xferMode));
#endif

    DBGPRINTF( ( DBG_CONTEXT,
                " Local IpAddr = %s; HostIpAddr = %s; DataIpAddr = %s;\n"
                " Port = %d; TimeAtConnection = %08x;\n",
                inet_ntoa( LocalIpAddress), inet_ntoa( HostIpAddress),
                inet_ntoa( DataIpAddress),
                DataPort,
                m_TimeAtConnection));

    DBGPRINTF(( DBG_CONTEXT, " ASYNC_IO_CONN Control=%08x; Data=%08x\n",
               &m_AioControlConnection, m_AioDataConnection));

    IF_DEBUG( ASYNC_IO) {

# if DBG
        m_AioControlConnection.Print();
        m_AioDataConnection.Print();
# endif // DBG
    }

    return;
} // USER_DATA::Print()




BOOL
USER_DATA::VirtualPathAccessCheck(IN ACCESS_TYPE  _access, IN  char * pszPath)
/*++
  checks to see if the access is allowed for accessing the path
    using pszPath after canonicalizing it.

 Arguments:
    access     the access desired
    pszPath    pointer to string containing the path

 Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DWORD  dwError;
    DWORD  dwSize = MAX_PATH;
    CHAR   rgchPath[MAX_PATH];


    // this following call converts the symbolic path into absolute
    //  and also does path access check.
    dwError = VirtualCanonicalize(rgchPath, &dwSize,
                                  pszPath, _access);

    return ( dwError);

} // USER_DATA::VirtualPathAccessCheck()





APIERR
USER_DATA::VirtualCanonicalize(
    OUT CHAR *   pszDest,
    IN OUT LPDWORD  lpdwSize,
    IN OUT CHAR *   pszSearchPath,
    IN ACCESS_TYPE  _access,
    OUT LPDWORD     pdwAccessMask,
    OUT CHAR *      pchVirtualPath,             /* OPTIONAL */
    IN OUT LPDWORD  lpcchVirtualPath            /* OPTIONAL */
    )
/*++
  This function canonicalizes the path, taking into account the current
    user's current directory value.

  Arguments:
     pszDest   string that will on return contain the complete
                      canonicalized path. This buffer will be of size
                      specified in *lpdwSize.

     lpdwSize  Contains the size of the buffer pszDest on entry.
                  On return contains the number of bytes written
                   into the buffer or number of bytes required.

     pszSearchPath  pointer to string containing the path to be converted.
       IF NULL, use the current directory only

     accesss   Access type for this path ( read, write, etc.)

     pdwAccessMask  pointer to DWORD which on succesful deciphering
                     will contain the  access mask.

     pchVirtualPath  pointer to string which will contain the sanitized
                     virtual path on return (on success)
     lpcchVirtualPath  pointer to DWORD containing the length of buffer
                     (contains the length on return).

  Returns:

     Win32 Error Code - NO_ERROR on success

     MuraliK   24-Apr-1995   Created.

--*/
{
    DWORD dwError = NO_ERROR;
    CHAR  rgchVirtual[MAX_PATH];

    DBG_ASSERT( pszDest != NULL);
    DBG_ASSERT( lpdwSize != NULL);
    DBG_ASSERT( pszSearchPath != NULL);

    IF_DEBUG( VIRTUAL_IO) {

        DBGPRINTF(( DBG_CONTEXT,
                   "UserData(%08x)::VirtualCanonicalize(%08x, %08x[%u],"
                   " %s, %d)\n",
                   this, pszDest, lpdwSize, *lpdwSize, pszSearchPath, _access));
    }

    if ( pdwAccessMask != NULL) {

        *pdwAccessMask = 0;
    }

    //
    // Form the virtual path for the given path.
    //

    if ( !IS_PATH_SEP( *pszSearchPath)) {

        const CHAR * pszNewDir = QueryCurrentDirectory(); // get virtual dir.

        //
        // This is a relative path. append it to currrent directory
        //

        if ( strlen(pszNewDir) + strlen(pszSearchPath) + 2 <= MAX_PATH) {

            // copy the current directory
            wsprintfA( rgchVirtual, "%s/%s",
                      pszNewDir, pszSearchPath);
            pszSearchPath = rgchVirtual;

        } else {

            // long path --> is not supported.
            DBGPRINTF((DBG_CONTEXT, "Long Virtual Path %s---%s\n",
                       pszNewDir, pszSearchPath));

            dwError = ERROR_PATH_NOT_FOUND;
        }

    } else {

        // This is an absolute virtual path.
        // need to overwrite this virtual path with absolute
        // path of the root.  Do nothing.
    }

    if ( dwError == NO_ERROR) {

        DWORD dwAccessMask = 0;
        DBG_ASSERT( IS_PATH_SEP(*pszSearchPath));

        //
        // Now we have the complete symbolic path to the target file.
        //  Translate it into the absolute path
        //

        VirtualpSanitizePath( pszSearchPath);

        if ( !LookupVirtualRoot( pszSearchPath,
                                 pszDest,
                                 lpdwSize,
                                 &dwAccessMask ) ) {

            dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "LookupVirtualRoot Failed. Error = %d. pszDest = %s. BReq=%d\n",
                       dwError, pszDest, *lpdwSize));

        } else if ( !PathAccessCheck( _access, dwAccessMask,
                                     TEST_UF( this, READ_ACCESS),
                                     TEST_UF( this, WRITE_ACCESS))
                   ) {

            dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "PathAccessCheck Failed. Error = %d. pszDest = %s\n",
                       dwError, pszDest));
        } else if ( lpcchVirtualPath != NULL) {

            // successful in getting the path.

            DWORD cchVPath = strlen( pszSearchPath);

            if ( *lpcchVirtualPath > cchVPath && pchVirtualPath != NULL) {

                // copy the virtual path, since we have space.
                strcpy( pchVirtualPath, pszSearchPath);
            }

            *lpcchVirtualPath = cchVPath;   // set the length to required size.
        }

        if ( dwError == NO_ERROR ) {
            // IP check

            AC_RESULT       acIpAccess;
            AC_RESULT       acDnsAccess;
            BOOL            fNeedDnsCheck;

            BindPathAccessCheck();
            acIpAccess = QueryAccessCheck()->CheckIpAccess( &fNeedDnsCheck );

            if ( (acIpAccess == AC_IN_DENY_LIST) ||
                 ((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) ) {
                dwError = ERROR_INCORRECT_ADDRESS;
            }
            else if ( fNeedDnsCheck ) {
                if ( !QueryAccessCheck()->IsDnsResolved() ) {
                    BOOL fSync;
                    LPSTR pDns;

                    if ( !QueryAccessCheck()->QueryDnsName( &fSync,
                            (ADDRCHECKFUNCEX)NULL,
                            (ADDRCHECKARG)NULL,
                            &pDns ) ) {
                        dwError = ERROR_INCORRECT_ADDRESS;
                    }
                }
                if ( dwError == NO_ERROR ) {
                    acDnsAccess = QueryAccessCheck()->CheckDnsAccess();

                    if ( (acDnsAccess == AC_IN_DENY_LIST) ||
                         (acDnsAccess == AC_NOT_IN_GRANT_LIST) ||
                         ((m_acCheck == AC_NOT_IN_GRANT_LIST) &&
                          (acDnsAccess != AC_IN_GRANT_LIST) ) ) {
                        dwError = ERROR_INCORRECT_ADDRESS;
                    }
                }
            }
            UnbindPathAccessCheck();
        }

        if ( pdwAccessMask != NULL) {

            *pdwAccessMask = dwAccessMask;
        }
    }


    IF_DEBUG( VIRTUAL_IO) {

        if ( dwError != NO_ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       " Cannot Canonicalize %s -- %s, Error = %lu\n",
                       QueryCurrentDirectory(),
                       pszSearchPath,
                       dwError));
        } else {

            DBGPRINTF(( DBG_CONTEXT,
                       "Canonicalized path is: %s\n",
                       pszDest));
        }
    }

    return ( dwError);
} // USER_DATA::VirtualCanonicalize()





/*******************************************************************

********************************************************************/
SOCKERR
USER_DATA::EstablishDataConnection(
    IN LPCSTR   pszReason,
    IN LPCSTR   pszSize
    )
/*++

  Connects to the client's data socket.

  Arguments:
     pszReason - The reason for the transfer (file list, get, put, etc).
     pszSize   - size of data being transferred.

  Returns:
    socket error code on any error.
--*/
{
    SOCKERR     serr  = 0;
    SOCKET      DataSocket = INVALID_SOCKET;
    BOOL        fPassive;
    BOOL        fAcceptableSocket = FALSE;

    //
    // if we're in passive mode and aren't dealing with a fake IO completion [ie reprocessing
    // the command], we just set up the event that will get signalled when the client
    // actually connects.
    //

    if ( TEST_UF( this, PASSIVE ) &&
         !QueryInFakeIOCompletion() )
    {
        //
        //  Ensure we actually created a passive listen data socket.
        //    no data transfer socket is in AsyncIo object.
        //

        DBG_ASSERT( m_sPassiveDataListen != INVALID_SOCKET );

        //
        // To avoid blocking while waiting for the client to connect, we're going to use
        // WSAEventSelect() to wait for the socket to be accept()'able.
        //
        //

        if ( ( serr = AddPASVAcceptEvent( &fAcceptableSocket ) ) != 0 )
        {
            ReplyToUser( this,
                         REPLY_LOCAL_ERROR,
                         PSZ_TOO_MANY_PASV_USERS );

            return ( serr );
        }

        //
        // No need to wait around, we can call accept() on the socket right now
        //
        if ( fAcceptableSocket )
        {
            goto continue_label;
        }

        m_fWaitingForPASVConn = TRUE;
        m_fHavePASVConn = FALSE;

        return ERROR_IO_PENDING;
    }

    DBG_ASSERT( !TEST_UF(this, PASSIVE) || QueryInFakeIOCompletion() );


continue_label:
    //
    //  Reset any oob flag.
    //

    CLEAR_UF( this, OOB_DATA );

    //
    //  Capture the user's passive flag, then reset to FALSE.
    //

    fPassive = TEST_UF( this, PASSIVE );
    CLEAR_UF( this, PASSIVE );

    //
    //  If we're in passive mode, then accept a connection to
    //  the data socket.
    //
    //  Calling accept() on this socket should -not- block because shouldn't get this
    //  far without being sure that calling accept() won't block - that's the point of
    //  jumping through the WSAEventSelect() hoops mentioned above
    //

    if( fPassive )
    {

        SOCKADDR_IN saddrClient;

        //
        //  Ensure we actually created a passive listen data socket.
        //    no data transfer socket is in AsyncIo object.
        //

        DBG_ASSERT( m_sPassiveDataListen != INVALID_SOCKET );

        //
        //  Wait for a connection.
        //

        IF_DEBUG( CLIENT )
        {

            DBGPRINTF(( DBG_CONTEXT,
                        "waiting for passive connection on socket %d\n",
                       m_sPassiveDataListen ));
        }

        serr = AcceptSocket( m_sPassiveDataListen,
                             &DataSocket,
                             &saddrClient,
                             TRUE,
                             m_pInstance );            // enforce timeouts


        //
        //  We can kill m_sPassiveDataListen now.
        //  We only allow one connection in passive mode.
        //

        CleanupPassiveSocket( TRUE );

        // PASV Theft is disabled, so you MUST have the same IP
        // address ad the Control Connection
        if (!(QueryInstance()->IsEnablePasvTheft()))
        {
            if (!(HostIpAddress.S_un.S_addr == saddrClient.sin_addr.S_un.S_addr))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Unmatching IP - Control: %d.%d.%d.%d Data: %d.%d.%d.%d \n",
                           HostIpAddress.S_un.S_un_b.s_b1,
                           HostIpAddress.S_un.S_un_b.s_b2,
                           HostIpAddress.S_un.S_un_b.s_b3,
                           HostIpAddress.S_un.S_un_b.s_b4,
                           saddrClient.sin_addr.S_un.S_un_b.s_b1,
                           saddrClient.sin_addr.S_un.S_un_b.s_b2,
                           saddrClient.sin_addr.S_un.S_un_b.s_b3,
                           saddrClient.sin_addr.S_un.S_un_b.s_b4));

                CloseSocket( DataSocket);
                DataSocket = INVALID_SOCKET;
                serr = WSA_OPERATION_ABORTED;
            };
        };

        if( serr == 0 )
        {

            //
            //  Got one.
            //

            DBG_ASSERT( DataSocket != INVALID_SOCKET );

            m_fHavePASVConn = TRUE;
            m_fWaitingForPASVConn = FALSE;

            FacIncrement( FacPassiveDataConnections);

            if ( m_AioDataConnection.SetNewSocket( DataSocket))
            {

                ReplyToUser(this,
                            REPLY_TRANSFER_STARTING,
                            PSZ_TRANSFER_STARTING);
            }
            else
            {

                //
                // We are possibly running low on resources. Send error.
                //

                ReplyToUser( this,
                            REPLY_LOCAL_ERROR,
                            PSZ_INSUFFICIENT_RESOURCES);

                CloseSocket( DataSocket);
                DataSocket = INVALID_SOCKET;
                serr = WSAENOBUFS;
            }
        }
        else
        {

            IF_DEBUG( CLIENT )
            {

                DBGPRINTF(( DBG_CONTEXT,
                            "cannot wait for connection, error %d\n",
                            serr ));
            }

            ReplyToUser(this,
                        REPLY_TRANSFER_ABORTED,
                        PSZ_TRANSFER_ABORTED);
        }

    }
    else
    {

        //
        //  Announce our intentions of establishing a connection.
        //

        ReplyToUser(this,
                    REPLY_OPENING_CONNECTION,
                    PSZ_OPENING_DATA_CONNECTION,
                    TransferType(m_xferType ),
                    pszReason,
                    pszSize);

        //
        //  Open data socket.
        //

        serr = CreateDataSocket(&DataSocket,           // Will receive socket
                                0,                   // Local address
                                CONN_PORT_TO_DATA_PORT(LocalIpPort),
                                DataIpAddress.s_addr,// RemoteAddr
                                DataPort ); // Remote port

        if ( serr == 0 )
        {

            DBG_ASSERT( DataSocket != INVALID_SOCKET );

            FacIncrement( FacActiveDataConnections);

            if ( !m_AioDataConnection.SetNewSocket( DataSocket))
            {

                CloseSocket( DataSocket);
                DataSocket = INVALID_SOCKET;

                serr = WSAENOBUFS;
            }
        }

        if ( serr != 0)
        {

            ReplyToUser(this,
                        REPLY_CANNOT_OPEN_CONNECTION,
                        PSZ_CANNOT_OPEN_DATA_CONNECTION);

            IF_DEBUG( COMMANDS )
            {

                DBGPRINTF(( DBG_CONTEXT,
                           "could not create data socket, error %d\n",
                           serr ));
            }
        }
    }


    if( serr == 0 )
    {

        // set this to indicate a transfer might start
        SET_UF( this, TRANSFER );

        //
        // Submit a read command on control socket, since we
        //  have to await possibility of an abort on OOB_INLINE.
        // Can we ignore possibility of an error on read request?
        //

        if ( !ReadCommand())
        {

            DWORD  dwError = GetLastError();

# ifdef CHECK_DBG
            CHAR   szBuffer[100];
            sprintf( szBuffer, " Read while DataTfr failed Error = %u. ",
                    dwError);
            Print( szBuffer);
# endif // CHECK_DBG

            IF_DEBUG(CLIENT) {

                DBGPRINTF((DBG_CONTEXT,
                           " %08x::ReadCommand() failed. Error = %u\n",
                           this, dwError));
                SetLastError( dwError);
            }
        }

    }

    return ( serr);

}   // USER_DATA::EstablishDataConnection()






BOOL
USER_DATA::DestroyDataConnection( IN DWORD dwError)
/*++
  Tears down the connection to the client's data socket that was created
    using EstablishDataConnection()

  Arguments:
    dwError      = NO_ERROR if data is transferred successfully.
                 Win32 error code otherwise

--*/
{
    UINT   replyCode;
    LPCSTR pszReply;
    BOOL   fTransfer;

    fTransfer = TEST_UF( this, TRANSFER);
    CLEAR_UF( this, TRANSFER );

    CleanupPASVFlags();

    //
    //  Close the data socket.
    //

    DBG_ASSERT( m_sPassiveDataListen == INVALID_SOCKET);


    // Stop Io occuring on data connection
    m_AioDataConnection.StopIo(dwError);

    if ( fTransfer) {

        //
        //  Tell the client we're done with the transfer.
        //

        if ( dwError == NO_ERROR) {

            replyCode = REPLY_TRANSFER_OK;
            pszReply  = PSZ_TRANSFER_COMPLETE;
        } else {

            replyCode = REPLY_TRANSFER_ABORTED;
            pszReply  = PSZ_TRANSFER_ABORTED;
        }

        ReplyToUser(this, replyCode, pszReply);
    }

    return (TRUE);
} // USER_DATA::DestroyDataConnection()


APIERR
USER_DATA::GetFileSize()
{
    LARGE_INTEGER FileSize;
    DWORD         dwError = NO_ERROR;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    CHAR rgchSize[MAX_FILE_SIZE_SPEC];

    pOpenFileInfo = m_pOpenFileInfo;

    if ( pOpenFileInfo == NULL) {

        return ( ERROR_FILE_NOT_FOUND);
    }

    if ( !pOpenFileInfo->QuerySize(FileSize)) {

        dwError = GetLastError();

        if( dwError != NO_ERROR ) {

            return ( dwError);
        }
    }

    IsLargeIntegerToDecimalChar( &FileSize, rgchSize);

    ReplyToUser( this, REPLY_FILE_STATUS, rgchSize );
    return(dwError);
}

APIERR
USER_DATA::GetFileModTime(LPSYSTEMTIME lpSystemTime)
{
    DWORD         dwError = NO_ERROR;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    FILETIME      FileTime;

    pOpenFileInfo = m_pOpenFileInfo;

    DBG_ASSERT( pOpenFileInfo != NULL );

    if ( !pOpenFileInfo->QueryLastWriteTime(&FileTime)) {

        dwError = GetLastError();
        return ( dwError);
    }

    if (!FileTimeToSystemTime(&FileTime, lpSystemTime)) {

        return GetLastError();
    }

    return NO_ERROR;
}


APIERR
USER_DATA::SendFileToUser( IN LPSTR  pszFileName,
                          IN OUT LPBOOL pfErrorSent)
/*++
  This is a worker function for RETR command of FTP. It will establish
  connection via the ( new ) data socket, then send a file over that
   socket. This uses Async io for transmitting the file.

  Arguments:
     pszFileName    pointer to null-terminated string containing the filename
     pfErrorSent    pointer to boolean flag indicating if an error has
                       been already sent to client.
                    The flag should be used only when return value is error.

  Returns:
     NO_ERROR on success and Win32 error code if error.

  History:
     30-April-1995   MuraliK
--*/
{
    LARGE_INTEGER FileSize;
    DWORD         dwError = NO_ERROR;
    BOOL          fTransmit;
    DWORD         dwAttribs;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    CHAR rgchSize[MAX_FILE_SIZE_SPEC];
    CHAR rgchBuffer[MAX_FILE_SIZE_SPEC + 10];


    DBG_ASSERT( pszFileName != NULL && pfErrorSent != NULL);

    *pfErrorSent = FALSE;

    IF_DEBUG( SEND) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " USER_DATA ( %08x)::SendFileToUser( %s,"
                    " pfErrorSent = %08x).\n",
                    this, pszFileName, pfErrorSent));
    }

    //
    //  Get file size.
    //
    pOpenFileInfo = m_pOpenFileInfo;

    if ( pOpenFileInfo == NULL) {

        return ( ERROR_FILE_NOT_FOUND);
    }

    // Get the file size

    if ( !pOpenFileInfo->QuerySize(FileSize)) {

        dwError = GetLastError();

        if( dwError != NO_ERROR ) {

            return ( dwError);
        }
    }

    FileSize.QuadPart -= (LONGLONG)QueryCurrentOffset();

    IsLargeIntegerToDecimalChar( &FileSize, rgchSize);
    wsprintfA( rgchBuffer, "(%s bytes)", rgchSize);

    m_pInstance->QueryStatsObj()->IncrTotalFilesSent();

    //
    //  Blast the file from a local file to the user.
    //

    Reference();       // incr ref since async data transfer is started
    SET_UF( this, ASYNC_TRANSFER);

    fTransmit = ( m_AioDataConnection.
                 TransmitFileTs( pOpenFileInfo,
                                 FileSize, // cbToSend ( send entire file)
                                 QueryCurrentOffset() )
                 );

    if ( !fTransmit) {

        dwError = GetLastError();

        IF_DEBUG( SEND) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " Unable to transmit file ( %s) (pOpenFile = %p)."
                        " Error = %u\n",
                        pszFileName,
                        pOpenFileInfo,
                        dwError));
        }

        // decr refcount since async tfr failed.
        DBG_REQUIRE( DeReference() > 0);
    }

    //
    //  Disconnect from client.
    //  ( will be done at the call back after completion of IO).
    //

    return ( dwError);

}   // USER_DATA::SendFileToUser()



VOID
USER_DATA::SetPassiveSocket( IN SOCKET sPassive )
/*++

  This function frees up an old Passive socket and resets the
    passive socket to the new Passive socket.

Arguments:
    sPassive - new passive socket to use

--*/
{

    SOCKET sPassiveOld;

    sPassiveOld = (SOCKET) InterlockedExchangePointer ( (PVOID *) &m_sPassiveDataListen,
                                                        (PVOID) sPassive);

    if ( sPassiveOld != INVALID_SOCKET) {

        FacDecrement( FacPassiveDataListens);
        DBG_REQUIRE( CloseSocket( sPassiveOld) == 0);
    }

    if ( sPassive != INVALID_SOCKET) {

        FacIncrement(FacPassiveDataListens);
    }


    return;
} // USER_DATA::SetPassiveSocket()

VOID
USER_DATA::CleanupPassiveSocket( BOOL fTellWatchThread )
/*++

  This function cleans up the resources associated with the current passive socket

Arguments:
   fTellWatchThread - flag indicating whether to tell thread waiting for an event on
   the current passive socket to clean up as well

Returns:
   Nothing
--*/
{
    SOCKET sPassiveOld;

    LockUser();

    if ( m_sPassiveDataListen == INVALID_SOCKET )
    {
        UnlockUser();

        return;
    }

    RemovePASVAcceptEvent( fTellWatchThread );

    DBG_REQUIRE( CloseSocket( m_sPassiveDataListen ) == 0 );

    m_sPassiveDataListen = INVALID_SOCKET;

    UnlockUser();
}


BOOL
USER_DATA::SetCommand( IN LPSTR pszCmd )
/*++

Routine Description:
     Used to set pointer to FTP cmd

Arguments :
     pszArgs - pointer to command to execute

Returns :
     BOOL indicating success/failure to set values
--*/
{
    BOOL fReturn = TRUE;

    if ( !pszCmd )
    {
        return FALSE;
    }

    //
    // Free any previous allocations
    //
    if ( m_pszCmd )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    if ( m_pszCmd = ( LPSTR ) TCP_ALLOC( strlen(pszCmd) +  1 ) )
    {
        strcpy( m_pszCmd, pszCmd );
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to allocate memory for command args !\n"));

        fReturn = FALSE;
    }

    return fReturn;
}

/************************************************************
 *  Auxiliary Functions
 ************************************************************/


VOID
ProcessUserAsyncIoCompletion(IN LPVOID pContext,
                             IN DWORD  cbIo,
                             IN DWORD  dwError,
                             IN LPASYNC_IO_CONNECTION pAioConn,
                             IN BOOL   fTimedOut
                             )
/*++
  This function processes the Async Io completion ( invoked as
    a callback from the ASYNC_IO_CONNECTION object).

  Arguments:
     pContext      pointer to the context information ( UserData object).
     cbIo          count of bytes transferred in Io
     dwError       DWORD containing the error code resulting from last tfr.
     pAioConn      pointer to AsyncIo connection object.

  Returns:
     None
--*/
{

    LPUSER_DATA   pUserData = (LPUSER_DATA ) pContext;

    DBG_ASSERT( pUserData != NULL);
    DBG_ASSERT( pAioConn  != NULL);

    IF_SPECIAL_DEBUG( CRITICAL_PATH) {

        CHAR    rgchBuffer[100];

        wsprintfA( rgchBuffer, " ProcessAio( cb=%u, err=%u, Aio=%x). ",
                  cbIo, dwError, pAioConn);

        pUserData->Print( rgchBuffer);
    }

    DBG_REQUIRE( pUserData->Reference()  > 0);

# if DBG

    if ( !IS_VALID_USER_DATA( pUserData)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    pUserData));
        pUserData->Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );

    pUserData->ProcessAsyncIoCompletion( cbIo, dwError, pAioConn, fTimedOut);

    DereferenceUserDataAndKill(pUserData);

    return;

} // ProcessUserAsyncIoCompletion()


VOID
USER_DATA::RemovePASVAcceptEvent( BOOL fTellWatchThread )
/*++

Routine Description:

    Routine that cleans up the state associated with a PASV accept event

Arguments:

    fTellWatchThread - BOOL indicating whether or not to inform the thread waiting on
    the event to stop waiting on it

Returns:

    Nothing
--*/
{
    DBG_ASSERT( m_sPassiveDataListen != INVALID_SOCKET );

    if ( m_hPASVAcceptEvent == NULL )
    {
        return;
    }

    //
    // Remove all network notifications for the PASV socket
    //
    if ( WSAEventSelect( m_sPassiveDataListen,
                         m_hPASVAcceptEvent,
                         0 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WSAEventSelect on socket %d failed : 0x%x\n",
                   m_sPassiveDataListen, WSAGetLastError()));
    }

    //
    // Stop watching for the event
    //
    if ( fTellWatchThread )
    {
        RemoveAcceptEvent( m_hPASVAcceptEvent,
                           this );
    }

    WSACloseEvent( m_hPASVAcceptEvent );

    m_hPASVAcceptEvent = NULL;
}

SOCKERR
USER_DATA::AddPASVAcceptEvent( BOOL *pfAcceptableSocket )
/*++

Routine Description:

    Routine that sets up the event to signal that the PASV socket is an accept()'able
    state

Arguments:

    pfAcceptableSocket - BOOL set to TRUE if socket can be accept()'ed at once, FALSE if
    NOT

Returns:

    Error code indicating success/failure

--*/
{
    DWORD dwRet = 0;
    SOCKERR serr = 0;
    BOOL fRegistered = FALSE;

    *pfAcceptableSocket = FALSE;

    if ( ( m_hPASVAcceptEvent = WSACreateEvent() ) == WSA_INVALID_EVENT )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to create event to wait for accept() : 0x%x\n",
                   WSAGetLastError()));

        return WSAGetLastError();
    }

    //
    // specify that we want to be alerted when the socket is accept()'able =)
    //
    if ( WSAEventSelect( m_sPassiveDataListen,
                         m_hPASVAcceptEvent,
                         FD_ACCEPT ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WSAEventSelect failed : 0x%x\n",
                   WSAGetLastError()));

        serr = WSAGetLastError();

        goto exit;
    }
    else
    {
        fRegistered = TRUE;
    }

    //
    // In order to deal as quickly as possible with legitimate clients and avoid rejecting them
    // because the queue is full, we'll wait for 0.1 sec to see whether the socket becomes
    // accept()'able before queueing it
    //
    dwRet = WSAWaitForMultipleEvents( 1,
                                      &m_hPASVAcceptEvent,
                                      FALSE,
                                      100,
                                      FALSE );

    switch ( dwRet )
    {
    case WSA_WAIT_EVENT_0:
    {
        //
        // we can call accept() at once on the socket, no need to muck around with waiting
        // for it
        //
        WSAEventSelect( m_sPassiveDataListen,
                        m_hPASVAcceptEvent,
                        0 );
        WSACloseEvent( m_hPASVAcceptEvent );

        m_hPASVAcceptEvent = 0;

        *pfAcceptableSocket = TRUE;

    }
    break;

    case WSA_WAIT_TIMEOUT:
    {
        //
        // Need to queue the socket
        //
        serr = AddAcceptEvent( m_hPASVAcceptEvent,
                               this );

    }
    break;

    default:
    {
        serr = WSAGetLastError();
    }
    break;
    }

exit:

    //
    // clean up if something failed
    //
    if ( serr != 0 )
    {
        if ( m_hPASVAcceptEvent )
        {
            if ( fRegistered )
            {
                WSAEventSelect( m_sPassiveDataListen,
                                m_hPASVAcceptEvent,
                                0 );
            }

            WSACloseEvent( m_hPASVAcceptEvent );

            m_hPASVAcceptEvent = NULL;
        }
    }

    return serr;
}




VOID
DereferenceUserDataAndKill(IN OUT LPUSER_DATA pUserData)
/*++
  This function dereferences User data and kills the UserData object if the
    reference count hits 0. Before killing the user data, it also removes
    the connection from the list of active connections.

--*/
{

    FTP_SERVER_INSTANCE * pinstance;

    IF_SPECIAL_DEBUG( CRITICAL_PATH) {

        pUserData->Print( " Deref ");
    }

    //
    // We must capture the instance pointer from the user data, as
    // USER_DATA::RemoveConnection() will set the pointer to NULL.
    // We must also reference the instance before locking it, as
    // removing the last user from the instance will cause the instance
    // to be destroyed. We'll defer this destruction until we're done
    // with the instance.
    //

    pinstance = pUserData->QueryInstance();

    pinstance->Reference();
    pinstance->LockConnectionsList();

    if ( !pUserData->DeReference())  {

        //
        // Deletion of the object USER_DATA is required.
        //

        IF_DEBUG( USER_DATABASE) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " UserData( %08x) is being deleted.\n",
                        pUserData));
        }

        pinstance->UnlockConnectionsList();

        pUserData->Cleanup();

        DBG_ASSERT( pUserData->QueryControlSocket() == INVALID_SOCKET );
        DBG_ASSERT( pUserData->QueryDataSocket() == INVALID_SOCKET );

        pinstance->RemoveConnection( pUserData);
    }
    else {

        pinstance->UnlockConnectionsList();
    }

    pinstance->Dereference();

} // DereferenceUserDataAndKill()




BOOL
PathAccessCheck(IN ACCESS_TYPE _access,
                IN DWORD       dwVrootAccessMask,
                IN BOOL        fUserRead,
                IN BOOL        fUserWrite
                )
/*++
  This function determines if the required privilege to access the specified
   virtual root with a given access mask exists.

  Arguments:

    access     - specifies type of acces desired.
    dwVrootAccessMask - DWORD containing the access mask for the virtual root.
    fUserRead  - user's permission to read  (general)
    fUserWrite - user's permission to write (general)

  Returns:
    BOOL  - TRUE if access is to be granted, else FALSE.

  History:
    MuraliK   20-Sept-1995

--*/
{
    BOOL        fAccessGranted = FALSE;

    DBG_ASSERT( IS_VALID_ACCESS_TYPE( _access ) );

    //
    //  Perform the actual access check.
    //

    switch( _access ) {

      case AccessTypeRead :

        fAccessGranted = (fUserRead &&
                          ((dwVrootAccessMask & VROOT_MASK_READ)
                           == VROOT_MASK_READ)
                          );
        break;

    case AccessTypeWrite :
    case AccessTypeCreate :
    case AccessTypeDelete :

        fAccessGranted = (fUserWrite &&
                          ((dwVrootAccessMask & VROOT_MASK_WRITE)
                           == VROOT_MASK_WRITE)
                          );
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT,
                   "PathAccessCheck - invalid access type %d\n",
                   _access ));
        DBG_ASSERT( FALSE );
        break;
    }

    if (!fAccessGranted) {

        SetLastError( ERROR_ACCESS_DENIED);
    }

    return ( fAccessGranted);
} // PathAccessCheck()


VOID SignalAcceptableSocket( LPUSER_DATA pUserData )
/*++

      Function that restarts processing the original command when a PASV data socket becomes
      accept()'able [ie the client has made the connection]

  Arguments:
      pUserData - USER_DATA context attached to socket

  Returns:
     Nothing
--*/
{
    PATQ_CONTEXT pAtqContext = pUserData->QueryControlAio()->QueryAtqContext();

    //
    // Stop waiting for events on this socket
    //
    pUserData->RemovePASVAcceptEvent( FALSE );

    pUserData->SetInFakeIOCompletion( TRUE );

    //
    // do a scary thing - fake an IO completion, to trigger re-processing of the FTP command
    //
    if ( !AtqPostCompletionStatus( pAtqContext,
                                   strlen( pUserData->QueryCmdString() ) + 1 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to post fake completion status to deal with PASV event : 0x%x\n",
                   GetLastError()));

        return;
    }
}


VOID CleanupTimedOutSocketContext( LPUSER_DATA pUserData )
/*++

      Function used to do cleanup when timeout for waiting for a PASV connection expires

  Arguments:
      pUserData - context pointer

  Returns:
     Nothing
--*/
{
    DBG_ASSERT( pUserData );

    pUserData->LockUser();

    pUserData->CleanupPassiveSocket( FALSE );

    CLEAR_UF( pUserData, PASSIVE );

    pUserData->SetHavePASVConn( FALSE );

    pUserData->SetWaitingForPASVConn( FALSE );

    ReplyToUser( pUserData,
                 REPLY_CANNOT_OPEN_CONNECTION,
                 PSZ_CANNOT_OPEN_DATA_CONNECTION );
    //
    // Remove our reference to this USER_DATA object
    //
    pUserData->DeReference();

    pUserData->UnlockUser();
}

/*******************************************************************

    NAME:       FtpMetaDataFree

    SYNOPSIS:   Frees a formatted meta data object when it's not in use.

    ENTRY:      pObject - Pointer to the meta data object.

    RETURNS:


    NOTES:


********************************************************************/

VOID
FtpMetaDataFree(
    PVOID       pObject
)
{
    PFTP_METADATA        pMD;

    pMD = (PFTP_METADATA)pObject;

    delete pMD;
}


BOOL
FTP_METADATA::HandlePrivateProperty(
    LPSTR                   pszURL,
    PIIS_SERVER_INSTANCE    pInstance,
    METADATA_GETALL_INTERNAL_RECORD  *pMDRecord,
    LPVOID                  pDataPointer,
    BUFFER                  *pBuffer,
    DWORD                   *pdwBytesUsed,
    PMETADATA_ERROR_INFO    pMDErrorInfo
    )
/*++

Routine Description:

    Handle metabase properties private to FTP service

Arguments:

    pszURL - URL of the requested object
    pInstance - FTP server instance
    pMDRecord - metadata record
    pDataPointer - pointer to metabase data
    pBuffer - Buffer available for storage space
    pdwBytesUsed - Pointer to bytes used in *pBuffer

Returns:

    BOOL  - TRUE success ( or not handled ), otherwise FALSE.

--*/
{
    return TRUE;
}

BOOL
FTP_METADATA::FinishPrivateProperties(
    BUFFER                  *pBuffer,
    DWORD                   dwBytesUsed,
    BOOL                    bSucceeded
    )
/*++

Routine Description:

    Handles completion of reading metabase properties private to FTP.

Arguments:

    pBuffer - Buffer previously used for storage space
    dwBytesUsed - bytes used in *pBuffer

Returns:

    BOOL  - TRUE success ( or not handled ), otherwise FALSE.

--*/
{
    return TRUE;
}


BOOL
USER_DATA::LookupVirtualRoot(
    IN  const CHAR * pszURL,
    OUT CHAR *       pszPath,
    OUT DWORD *      pcchDirRoot,
    OUT DWORD *      pdwAccessMask
    )
/*++

Routine Description:

    Looks up the virtual root to find the physical drive mapping.  If an
    Accept-Language header was sent by the client, we look for a virtual
    root prefixed by the language tag

Arguments:

    pstrPath - Receives physical drive path
    pszURL - URL to look for
    pcchDirRoot - Number of characters in the found physical path
    pdwMask - Access mask for the specified URL

  Returns:
    BOOL  - TRUE if success, otherwise FALSE.

--*/
{
    PFTP_METADATA       pMD;
    DWORD               dwDataSetNumber;
    PVOID               pCacheInfo;
    MB                  mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    STACK_STR(          strFullPath, MAX_PATH );
    METADATA_ERROR_INFO MDErrorInfo;
    BOOL                fOk;
    DWORD               dwError = NO_ERROR;



    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }

    // First read the data set number, and see if we already have it
    // cached.  We don't do a full open in this case.

    if ( !strFullPath.Copy( m_pInstance->QueryMDVRPath() ) ||
         !strFullPath.Append( ( *pszURL == '/' ) ? pszURL + 1 : pszURL ) )
    {
        goto LookupVirtualRoot_Error;
    }

    if (!mb.GetDataSetNumber( strFullPath.QueryStr(),
                              &dwDataSetNumber ))
    {
        goto LookupVirtualRoot_Error;
    }

    // See if we can find a matching data set already formatted.
    pMD = (PFTP_METADATA)TsFindMetaData(dwDataSetNumber, METACACHE_FTP_SERVER_ID);

    if (pMD == NULL)
    {
        pMD = new FTP_METADATA;

        if (pMD == NULL)
        {
            goto LookupVirtualRoot_Error;
        }

        if ( !pMD->ReadMetaData( m_pInstance,
                                 &mb,
                                 (LPSTR)pszURL,
                                 &MDErrorInfo ) )
        {
            delete pMD;
            goto LookupVirtualRoot_Error;
        }

        // We were succesfull, so try and add this metadata. There is a race
        // condition where someone else could have added it while we were
        // formatting. This is OK - we'll have two cached, but they should be
        // consistent, and one of them will eventually time out. We could have
        // AddMetaData check for this, and free the new one while returning a
        // pointer to the old one if it finds one, but that isn't worthwhile
        // now.

        pCacheInfo = TsAddMetaData(pMD, FtpMetaDataFree,
                            dwDataSetNumber, METACACHE_FTP_SERVER_ID);

    }

    m_pMetaData = pMD;

    if ( m_pMetaData->QueryVrError() )
    {
        dwError = m_pMetaData->QueryVrError();
        goto LookupVirtualRoot_Error;
    }

    //
    // Build physical path from VR_PATH & portion of URI not used to define VR_PATH
    //

    if (m_pInstance->QueryIsolationMode() == NoIsolation)
    {
        fOk = pMD->BuildPhysicalPath( (LPSTR)pszURL, &strFullPath );
    }
    else
    {
        fOk = pMD->BuildPhysicalPathWithAltRoot( (LPSTR)pszURL, &strFullPath, m_szRootDir );
    }

    if ( fOk &&
         *pcchDirRoot > strFullPath.QueryCCH() )
    {
        memcpy( pszPath, strFullPath.QueryStr(), strFullPath.QueryCCH()+1 );
        *pcchDirRoot = strFullPath.QueryCCH();
        if ( pdwAccessMask )
        {
            *pdwAccessMask = m_pMetaData->QueryAccessPerms();
        }

        return TRUE;
    }

LookupVirtualRoot_Error:

    if (dwError == NO_ERROR) {
        //
        // best error message to send to client
        //
        dwError = ERROR_FILE_NOT_FOUND;
    }

    SetLastError( dwError );

    return FALSE;
}


BOOL
USER_DATA::BindInstanceAccessCheck(
    )
/*++

Routine Description:

    Bind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    BOOL  - TRUE if success, otherwise FALSE.

--*/
{
    if ( m_rfAccessCheck.CopyFrom( m_pInstance->QueryMetaDataRefHandler() ) )
    {
        m_acAccessCheck.BindCheckList( (LPBYTE)m_rfAccessCheck.GetPtr(), m_rfAccessCheck.GetSize() );
        return TRUE;
    }
    return FALSE;
}


VOID
USER_DATA::UnbindInstanceAccessCheck()
/*++

Routine Description:

    Unbind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_acAccessCheck.UnbindCheckList();
    m_rfAccessCheck.Reset( (IMDCOM*) g_pInetSvc->QueryMDObject() );
}


BOOL
USER_DATA::IsFileNameShort( IN LPSTR pszFile)
/*++

  Check file name beeing short or not.

  Arguments:
    pszFile   pointer to null-terminated string containing the file name

  Returns:
    TRUE if filename is short.
--*/
{
    APIERR  err;
    CHAR   szCanonPath[MAX_PATH];
    DWORD  cbSize = MAX_PATH*sizeof(CHAR);
    CHAR   szVirtualPath[MAX_PATH+1];
    DWORD  cchVirtualPath = MAX_PATH;
    BOOL   fShort;
    BOOL   fRet = FALSE;

    DBG_ASSERT( pszFile != NULL );

    //
    // Close any file we might have open now
    // N.B. There shouldn't be an open file; we're just
    // being careful here.
    //

    if (m_pOpenFileInfo) {
        DBGPRINTF(( DBG_CONTEXT,
            "WARNING!! Closing [%08x], before opening %s\n",
            pszFile
            ));
        DBG_REQUIRE( CloseFileForSend() );
    }

    //
    // Open the requested file
    //
    err = VirtualCanonicalize(szCanonPath,
        &cbSize,
        pszFile,
        AccessTypeRead,
        NULL,
        szVirtualPath,
        &cchVirtualPath);

    if( err == NO_ERROR )
    {

        if ( strchr( szCanonPath, '~' ))
        {

            err = CheckIfShortFileName( (UCHAR *) szCanonPath, TsTokenToImpHandle( QueryUserToken()), &fShort );

            if ( !err  && fShort)
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Short filename being rejected \"%s\"\n",
                    szCanonPath ));
                fRet = TRUE;

            }

        }
    }



    return fRet;
} // USER_DATA::IsFileNameShort()



DWORD
USER_DATA::CheckIfShortFileName(
    IN  CONST UCHAR * pszPath,
    IN  HANDLE        hImpersonation,
    OUT BOOL *        pfShort
    )
/*++
    Description:

        This function takes a suspected NT/Win95 short filename and checks if there's
        an equivalent long filename.  For example, c:\foobar\ABCDEF~1.ABC is the same
        as c:\foobar\abcdefghijklmnop.abc.

        NOTE: This function should be called unimpersonated - the FindFirstFile() must
        be called in the system context since most systems have traverse checking turned
        off - except for the UNC case where we must be impersonated to get network access.

    Arguments:

        pszPath - Path to check
        hImpersonation - Impersonation handle if this is a UNC path - can be NULL if not UNC
        pfShort - Set to TRUE if an equivalent long filename is found

    Returns:

        Win32 error on failure
--*/
{
    DWORD              err = NO_ERROR;
    WIN32_FIND_DATA    FindData;
    UCHAR *            psz;
    BOOL               fUNC;

    psz      = _mbschr( (UCHAR *) pszPath, '~' );
    *pfShort = FALSE;
    fUNC     = (*pszPath == '\\');

    //
    //  Loop for multiple tildas - watch for a # after the tilda
    //

    while ( psz++ )
    {
        if ( *psz >= '0' && *psz <= '9' )
        {
            UCHAR achTmp[MAX_PATH];
            UCHAR * pchEndSeg;
            UCHAR * pchBeginSeg;
            HANDLE  hFind;

            //
            //  Isolate the path up to the segment with the
            //  '~' and do the FindFirst with that path
            //

            pchEndSeg = _mbschr( psz, '\\' );

            if ( !pchEndSeg )
            {
                pchEndSeg = psz + _mbslen( psz );
            }

            //
            //  If the string is beyond MAX_PATH then we allow it through
            //

            if ( ((INT) (pchEndSeg - pszPath)) >= sizeof( achTmp ))
            {
                return NO_ERROR;
            }

            memcpy( achTmp, pszPath, (INT) (pchEndSeg - pszPath) );
            achTmp[pchEndSeg - pszPath] = '\0';

            if ( fUNC && hImpersonation )
            {
                if ( !ImpersonateLoggedOnUser( hImpersonation ))
                {
                    return GetLastError();
                }
            }

            hFind = FindFirstFile( (CHAR *) achTmp, &FindData );

            if ( fUNC && hImpersonation )
            {
                RevertToSelf();
            }

            if ( hFind == INVALID_HANDLE_VALUE )
            {
                err = GetLastError();

                DBGPRINTF(( DBG_CONTEXT,
                            "FindFirst failed!! - \"%s\", error %d\n",
                            achTmp,
                            GetLastError() ));

                //
                //  If the FindFirstFile() fails to find the file then return
                //  success - the path doesn't appear to be a valid path which
                //  is ok.
                //

                if ( err == ERROR_FILE_NOT_FOUND ||
                     err == ERROR_PATH_NOT_FOUND )
                {
                    return NO_ERROR;
                }

                return err;
            }

            DBG_REQUIRE( FindClose( hFind ));

            //
            //  Isolate the last segment of the string which should be
            //  the potential short name equivalency
            //

            pchBeginSeg = _mbsrchr( achTmp, '\\' );
            DBG_ASSERT( pchBeginSeg );
            pchBeginSeg++;

            //
            //  If the last segment doesn't match the long name then this is
            //  the short name version of the path
            //

            if ( _mbsicmp( (UCHAR *) FindData.cFileName, pchBeginSeg ))
            {
                *pfShort = TRUE;
                return NO_ERROR;
            }
        }

        psz = _mbschr( psz, '~' );
    }

    return err;
}

/******************************* End Of File *************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\dbgutil.h ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

        Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Revision History:

       MuraliK   21-March-1995    Made local copy from template for FTP server
                                     This replaces old "debug.hxx" of FTPsvc.
       MuraliK   1-Npv-1996       Updated dbgutil.h 
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_

/************************************************************
 *     Include Headers
 ************************************************************/

// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

# include <pudebug.h>

//
//  Define the debugging constants
//

# define DEBUG_VIRTUAL_IO                 0x00001000
# define DEBUG_CLIENT                     0x00002000
# define DEBUG_ASYNC_IO                   0x00004000
# define DEBUG_DIR_LIST                   0x00008000

# define DEBUG_SOCKETS                    0x00010000
# define DEBUG_SEND                       0x00020000
# define DEBUG_RECV                       0x00040000
# define DEBUG_CONFIG                     0x00080000

# define DEBUG_INSTANCE                   0x00100000

# define DEBUG_SERVICE_CTRL               0x01000000
# define DEBUG_SECURITY                   0x02000000
# define DEBUG_USER_DATABASE              0x04000000
# define DEBUG_RPC                        0x08000000

# define DEBUG_CONNECTION                 0x10000000
# define DEBUG_PARSING                    0x20000000
# define DEBUG_COMMANDS                   0x40000000
# define DEBUG_CRITICAL_PATH              0x80000000

# define DEBUG_PASV                        0x00200000

# define IF_SPECIAL_DEBUG( arg)      IF_DEBUG( arg)


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\aap.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    aap.cxx

    This module contains implementation of the Asynchronous Accept Pool
    package.

    Functions exported by this module:

        AapInitialize
        AapTerminate
        AapAcquire
        AapRelease
        AapAccept
        AapAbort


    FILE HISTORY:
        KeithMo     01-Mar-1995 Created.

*/


#include "ftpdp.hxx"


//
//  Private constants.
//

#define MAX_IDLE_THREADS        10

#define AapLockLists()          EnterCriticalSection( &p_AapListLock )
#define AapUnlockLists()        LeaveCriticalSection( &p_AapListLock )


//
//  Private types.
//

typedef enum _AAP_STATE
{
    AapStateFirst = -1,                 // Must be first aap state!

    AapStateIdle,                       // Idle.
    AapStateActive,                     // Waiting for incoming connection.
    AapStateAbort,                      // Aborting, return to idle.
    AapStateShutdown,                   // Shutting down.

    AapStateLast                        // Must be last aap state!

} AAP_STATE;

#define IS_VALID_AAP_STATE(x)   (((x) > AapStateFirst) && ((x) < AapStateLast))

typedef struct _AAP_CONTEXT
{
    //
    //  Structure signature, for safety's sake.
    //

    DEBUG_SIGNATURE

    //
    //  Links onto a list of idle/active contexts.
    //

    LIST_ENTRY          ContextList;

    //
    //  Current state.
    //

    AAP_STATE           State;

    //
    //  The listening socket.
    //

    SOCKET              ListeningSocket;

    //
    //  An event object for synchronizing with the worker thread.
    //

    HANDLE              EventHandle;

    //
    //  A handle to the worker thread for synchronizing shutdown.
    //

    HANDLE              ThreadHandle;

    //
    //  The callback associated with this context.
    //

    LPAAP_CALLBACK      AapCallback;

    //
    //  A user-definable context.
    //

    LPVOID              UserContext;

} AAP_CONTEXT, * LPAAP_CONTEXT;

#if DBG
#define AAP_SIGNATURE           (DWORD)'cPaA'
#define AAP_SIGNATURE_X         (DWORD)'paaX'
#define INIT_AAP_SIG(p)         ((p)->Signature = AAP_SIGNATURE)
#define KILL_AAP_SIG(p)         ((p)->Signature = AAP_SIGNATURE_X)
#define IS_VALID_AAP_CONTEXT(p) (((p) != NULL) && ((p)->Signature == AAP_SIGNATURE))
#else   // !DBG
#define INIT_AAP_SIG(p)         ((void)(p))
#define KILL_AAP_SIG(p)         ((void)(p))
#define IS_VALID_AAP_CONTEXT(p) (((void)(p)), TRUE)
#endif  // DBG


//
//  Private globals.
//

LIST_ENTRY              p_AapIdleList;
LIST_ENTRY              p_AapActiveList;
CRITICAL_SECTION        p_AapListLock;
DWORD                   p_AapIdleCount;


//
//  Private prototypes.
//

LPAAP_CONTEXT
AappCreateContext(
    VOID
    );

VOID
AappFreeResources(
    LPAAP_CONTEXT AapContext
    );

DWORD
AappWorkerThread(
    LPVOID Param
    );


//
//  Public functions.
//

/*******************************************************************

    NAME:       AapInitialize

    SYNOPSIS:   Initializes the AAP package.

    EXIT:       APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
APIERR
AapInitialize(
    VOID
    )
{
    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "in AapInitialize\n" ));
    }

    //
    //  Initialize the critical section.
    //

    INITIALIZE_CRITICAL_SECTION( &p_AapListLock );

    //
    //  Initialize the worker lists.
    //

    InitializeListHead( &p_AapIdleList );
    InitializeListHead( &p_AapActiveList );

    p_AapIdleCount   = 0;

    //
    //  Success!
    //

    return 0;

}   // AapInitialize

/*******************************************************************

    NAME:       AapTerminate

    SYNOPSIS:   Terminates the AAP package.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
VOID
AapTerminate(
    VOID
    )
{
    PLIST_ENTRY Entry;

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "in AapTerminate\n" ));
    }

    //
    //  Lock the lists.
    //

    AapLockLists();

    //
    //  Scan the idle list and blow them away.
    //

    Entry = p_AapIdleList.Flink;

    while( Entry != &p_AapIdleList )
    {
        LPAAP_CONTEXT AapContext;

        AapContext = CONTAINING_RECORD( Entry, AAP_CONTEXT, ContextList );
        Entry      = Entry->Flink;
        DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );
        DBG_ASSERT( AapContext->State == AapStateIdle );

        IF_DEBUG( AAP )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AapTerminate: killing idle context @ %08lX\n",
                        AapContext ));
        }

        //
        //  Set the state to closing so the thread will know to exit.
        //

        AapContext->State = AapStateShutdown;

        //
        //  Signal the event to wake up the thread.
        //

        DBG_ASSERT( AapContext->EventHandle != NULL );
        TCP_REQUIRE( SetEvent( AapContext->EventHandle ) );
    }

    //
    //  Scan the active list and blow them away.
    //

    Entry = p_AapActiveList.Flink;

    while( Entry != &p_AapActiveList )
    {
        LPAAP_CONTEXT AapContext;
        SOCKET        Socket;

        AapContext = CONTAINING_RECORD( Entry, AAP_CONTEXT, ContextList );
        Entry      = Entry->Flink;
        DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );
        DBG_ASSERT( AapContext->State == AapStateActive );

        IF_DEBUG( AAP )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AapTerminate: killing active context @ %08lX\n",
                        AapContext ));
        }

        //
        //  Set the state to closing so the thread will know to exit.
        //

        AapContext->State = AapStateShutdown;

        //
        //  Close the listening socket to wake up the thread.
        //

        Socket = AapContext->ListeningSocket;
        DBG_ASSERT( Socket != INVALID_SOCKET );
        AapContext->ListeningSocket = INVALID_SOCKET;

        TCP_REQUIRE( closesocket( Socket ) == 0 );

        DBG_ASSERT( AapContext->EventHandle != NULL );
        TCP_REQUIRE( SetEvent( AapContext->EventHandle ) );
    }

    //
    //  Wait for the worker threads to exit.  Note that the list
    //  lock is currently held.
    //

    for( ; ; )
    {
        LPAAP_CONTEXT AapContext;

        //
        //  Find a thread to wait on.  If both lists are empty,
        //  then we're done.
        //

        if( IsListEmpty( &p_AapIdleList ) )
        {
            if( IsListEmpty( &p_AapActiveList ) )
            {
                break;
            }

            AapContext = CONTAINING_RECORD( p_AapActiveList.Flink,
                                            AAP_CONTEXT,
                                            ContextList );
        }
        else
        {
            AapContext = CONTAINING_RECORD( p_AapIdleList.Flink,
                                            AAP_CONTEXT,
                                            ContextList );
        }

        DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );
        DBG_ASSERT( AapContext->State == AapStateShutdown );

        //
        //  Unlock the lists, wait for the thread to exit, then
        //  relock the lists.
        //

        AapUnlockLists();
        WaitForSingleObject( AapContext->ThreadHandle, INFINITE );
        AapLockLists();

        //
        //  Note that worker threads will neither close their thread
        //  handles nor free their AAP_CONTEXT structures during shutdown.
        //  This is our responsibility.
        //

        AappFreeResources( AapContext );
    }

    DBG_ASSERT( p_AapIdleCount == 0 );

    //
    //  Unlock the lists.
    //

    AapUnlockLists();

}   // AapTerminate

/*******************************************************************

    NAME:       AapAcquire

    SYNOPSIS:   Acquires an AAP socket/thread pair for a future
                asynchronous accept request.

    ENTRY:      AapCallback - Pointer to a callback function to be
                    invoked when the accept() completes.

                UserContext - An uninterpreted context value passed
                    into the callback.

    EXIT:       AAP_HANDLE - A valid AAP handle if !NULL, NULL if
                    an error occurred.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
AAP_HANDLE
AapAcquire(
    LPAAP_CALLBACK AapCallback,
    LPVOID         UserContext
    )
{
    PLIST_ENTRY   Entry;
    LPAAP_CONTEXT AapContext;

    //
    //  Sanity check.
    //

    DBG_ASSERT( AapCallback != NULL );

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AapAcquire: callback @ %08lX, context = %08lX\n",
                    AapCallback,
                    UserContext ));
    }

    //
    //  See if there's something available on the idle list.
    //

    AapLockLists();

    if( !IsListEmpty( &p_AapIdleList ) )
    {
        Entry      = RemoveHeadList( &p_AapIdleList );
        AapContext = CONTAINING_RECORD( Entry, AAP_CONTEXT, ContextList );
        DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );
        DBG_ASSERT( AapContext->State == AapStateIdle );

        DBG_ASSERT( p_AapIdleCount > 0 );
        p_AapIdleCount--;

        IF_DEBUG( AAP )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AapAcquire: got idle context @ %08lX\n",
                        AapContext ));
        }
    }
    else
    {
        //
        //  Create a new one.
        //

        AapContext = AappCreateContext();
    }

    if( AapContext != NULL )
    {
        //
        //  Initialize it.
        //

        AapContext->AapCallback = AapCallback;
        AapContext->UserContext = UserContext;
        AapContext->State       = AapStateActive;

        //
        //  Put it on the active list.
        //

        InsertHeadList( &p_AapActiveList, &AapContext->ContextList );
    }

    //
    //  Unlock the lists & return the (potentially NULL) context.
    //

    AapUnlockLists();

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AapAcquire: returning context @ %08lX\n",
                    AapContext ));
    }

    return AapContext;

}   // AapAcquire

/*******************************************************************

    NAME:       AapRelease

    SYNOPSIS:   Releases an open AAP handle and makes the associated
                socket/thread pair available for use.

    ENTRY:      AapHandle - A valid AAP handle returned by AapAcquire().
                    After this API completes, the handle is no longer
                    valid.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
VOID
AapRelease(
    AAP_HANDLE AapHandle
    )
{
    //
    //  Sanity check.
    //

    DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapHandle ) );
    DBG_ASSERT( AapHandle->State == AapStateActive );

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AapRelease: releasing context @ %08lX\n",
                    AapHandle ));
    }

    //
    //  Lock the lists.
    //

    AapLockLists();

    //
    //  let it decide how to handle this.
    //

    AapHandle->State = AapStateAbort;

    DBG_ASSERT( AapHandle->EventHandle != NULL );
    TCP_REQUIRE( SetEvent( AapHandle->EventHandle ) );

    //
    //  Unlock the lists.
    //

    AapUnlockLists();

}   // AapRelease

/*******************************************************************

    NAME:       AapAccept

    SYNOPSIS:   Initiates an accept().  The callback associated with
                the AAP handle will be invoked when the accept()
                completes.

    ENTRY:      AapHandle - A valid AAP handle returned by AapAcquire().

    EXIT:       APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
APIERR
AapAccept(
    AAP_HANDLE AapHandle
    )
{
    //
    //  Sanity check.
    //

    DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapHandle ) );
    DBG_ASSERT( AapHandle->State == AapStateActive );

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AapAccept: context @ %08lX\n",
                    AapHandle ));
    }

    //
    //  Release the worker thread.
    //

    TCP_REQUIRE( SetEvent( AapHandle->EventHandle ) );

    return 0;

}   // AapAccept

/*******************************************************************

    NAME:       AapAbort

    SYNOPSIS:   Aborts a pending accept().

    ENTRY:      AapHandle - A valid AAP handle returned by AapAcquire().

    EXIT:       APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
APIERR
AapAbort(
    AAP_HANDLE AapHandle
    )
{
    //
    //  Sanity check.
    //

    DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapHandle ) );
    DBG_ASSERT( AapHandle->State == AapStateActive );

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AapAbort: context @ %08lX\n",
                    AapHandle ));
    }

    //
    //  Just zap the listening handle.  The worker thread will clean
    //  up after itself.
    //

    TCP_REQUIRE( closesocket( AapHandle->ListeningSocket ) == 0 );

    return 0;

}   // AapAbort


//
//  Private functions.
//

/*******************************************************************

    NAME:       AappCreateContext

    SYNOPSIS:   Creates a new AAP context, including the associated
                thread, socket, and synchronization objects.

    RETURNS:    LPAAP_CONTEXT - The newly created context if successful,
                    NULL otherwise.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
LPAAP_CONTEXT
AappCreateContext(
    VOID
    )
{
    LPAAP_CONTEXT AapContext;
    SOCKADDR_IN   LocalAddress;
    DWORD         ThreadId;

    //
    //  Create the context structure.
    //

    AapContext = (LPAAP_CONTEXT)TCP_ALLOC( sizeof(AAP_CONTEXT) );

    if( AapContext == NULL )
    {
        DBGERROR(( DBG_CONTEXT,
                    "AappCreateContext: allocation failure\n" ));

        goto FatalExit0;
    }

    RtlZeroMemory( AapContext, sizeof(AAP_CONTEXT) );
    INIT_AAP_SIG( AapContext );

    //
    //  Create the listening socket.
    //

    AapContext->ListeningSocket = socket( AF_INET, SOCK_STREAM, 0 );

    if( AapContext->ListeningSocket == INVALID_SOCKET)
    {
        DBGERROR(( DBG_CONTEXT,
                    "AappCreateContext: socket() failure %d\n",
                    WSAGetLastError() ));

        goto FatalExit1;
    }

    LocalAddress.sin_family      = AF_INET;
    LocalAddress.sin_port        = 0;
    LocalAddress.sin_addr.s_addr = 0;

    if( bind( AapContext->ListeningSocket,
              (LPSOCKADDR)&LocalAddress,
              sizeof(LocalAddress) ) != 0 )
    {
        DBGERROR(( DBG_CONTEXT,
                    "AappCreateContext: bind() failure %d\n",
                    WSAGetLastError() ));

        goto FatalExit2;
    }

    if( listen( AapContext->ListeningSocket, 2 ) != 0 )
    {
        DBGERROR(( DBG_CONTEXT,
                    "AappCreateContext: listen() failure %d\n",
                    WSAGetLastError() ));

        goto FatalExit2;
    }

    //
    //  Create the event object.
    //

    AapContext->EventHandle = CreateEvent( NULL,        // lpEventAttributes
                                           FALSE,       // bManualReset
                                           FALSE,       // bInitialState
                                           NULL );      // lpName

    if( AapContext->EventHandle == NULL )
    {
        DBGWARN(( DBG_CONTEXT,
                    "AappCreateContext: CreateEvent() failure %d\n",
                    GetLastError() ));

        goto FatalExit2;
    }

    //
    //  Create the worker thread.
    //

    AapContext->ThreadHandle = CreateThread( NULL,              // lpsa
                                             0,                 // cbStack
                                             AappWorkerThread,  // lpStartAddr
                                             AapContext,        // lpvThreadParm
                                             0,                 // fdwCreate
                                             &ThreadId );       // lpIDThread

    if( AapContext->ThreadHandle == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AappCreateContext: CreateThread() failure %d\n",
                    GetLastError() ));

        goto FatalExit3;
    }

    //
    //  Success!
    //

    return AapContext;

    //
    //  Cleanup from various levels of fatal error.
    //

FatalExit3:

    CloseHandle( AapContext->EventHandle );

FatalExit2:

    closesocket( AapContext->ListeningSocket );

FatalExit1:

    TCP_FREE( AapContext );

FatalExit0:

    return NULL;

}   // AappCreateContext

/*******************************************************************

    NAME:       AappFreeResources

    SYNOPSIS:   Frees the system resources associated with a given
                AAP_CONTEXT structure, then frees the structure
                itself.

                NOTE: This routine MUST be called with the list lock
                held!

    ENTRY:      AapContext - The AAP_CONTEXT structure to free.

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
VOID
AappFreeResources(
    LPAAP_CONTEXT AapContext
    )
{
    //
    //  Sanity check.
    //

    DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );

    IF_DEBUG( AAP )
    {
        DBGWARN(( DBG_CONTEXT,
                    "AappFreeResource: context @ %08lX\n",
                    AapContext ));
    }

    //
    //  Close the thread handle if open.
    //

    if( AapContext->ThreadHandle != NULL )
    {
        CloseHandle( AapContext->ThreadHandle );
    }

    //
    //  Remove this structure from the list.
    //

    RemoveEntryList( &AapContext->ContextList );

    //
    //  Free the structure.
    //

    KILL_AAP_SIG( AapContext );
    TCP_FREE( AapContext );

}   // AappFreeResources

/*******************************************************************

    NAME:       AappWorkerThread

    SYNOPSIS:   Worker thread for accept()ing incoming connections.

    ENTRY:      Param - Actually the LPAAP_CONTEXT structure for this
                    thread.

    RETURNS:    DWORD - Thread exit code (ignored).

    HISTORY:
        KeithMo     01-Mar-1995 Created.

********************************************************************/
DWORD
AappWorkerThread(
    LPVOID Param
    )
{
    LPAAP_CONTEXT  AapContext;
    AAP_STATE      AapState;
    LPAAP_CALLBACK AapCallback;
    LPVOID         UserContext;
    DWORD          WaitResult;
    BOOL           CallbackResult;
    SOCKET         ListeningSocket;
    SOCKET         AcceptedSocket;
    SOCKERR        SocketStatus;
    INT            RemoteAddressLength;
    SOCKADDR_IN    RemoteAddress;

    //
    //  Grab the context structure.
    //

    AapContext = (LPAAP_CONTEXT)Param;
    DBG_ASSERT( IS_VALID_AAP_CONTEXT( AapContext ) );

    IF_DEBUG( AAP )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AappWorkerThread: starting, context @ %08lX\n",
                    AapContext ));
    }

    //
    //  Capture some fields from the structure.
    //

    AapCallback     = AapContext->AapCallback;
    UserContext     = AapContext->UserContext;
    ListeningSocket = AapContext->ListeningSocket;

    //
    //  Loop forever, or at least until we're told to shutdown.
    //

    for( ; ; )
    {
        //
        //  Wait for a request.
        //

        WaitResult = WaitForSingleObject( AapContext->EventHandle,
                                          INFINITE );

        if( WaitResult != WAIT_OBJECT_0 )
        {
            DBGWARN(( DBG_CONTEXT,
                        "AappWorkerThread: wait failure %lu : %d\n",
                        WaitResult,
                        GetLastError() ));

            break;
        }

        //
        //  Check our state.
        //

        AapLockLists();
        AapState = AapContext->State;
        AapUnlockLists();

        if( AapState == AapStateShutdown )
        {
            IF_DEBUG( AAP )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "AappWorkerThread: context @ %08lX state == %d, exiting\n",
                            AapContext,
                            AapState ));
            }

            break;
        }

        for( ; ; )
        {
            //
            //  Wait for an incoming connection.
            //

            RemoteAddressLength = sizeof(RemoteAddress);

            AcceptedSocket = accept( ListeningSocket,
                                     (LPSOCKADDR)&RemoteAddress,
                                     &RemoteAddressLength );

            SocketStatus = ( AcceptedSocket == INVALID_SOCKET )
                                ? WSAGetLastError()
                                : 0;

            IF_DEBUG( AAP )
            {
                if( SocketStatus != 0 )
                {
                    DBGERROR(( DBG_CONTEXT,
                                "AappWorkerThread: accept() failure %d\n",
                                SocketStatus ));
                }
            }

            //
            //  Invoke the callback.
            //

            IF_DEBUG( AAP )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "AappWorkerThread: context @ %08lX calling %08lX[%08lX]\n",
                            AapContext,
                            AapCallback,
                            UserContext ));
            }

            CallbackResult = AapCallback( UserContext,
                                          SocketStatus,
                                          AcceptedSocket,
                                          (LPSOCKADDR)&RemoteAddress,
                                          RemoteAddressLength );

            //
            //  If the callback returned FALSE (indicating that it wants no
            //  further callbacks) OR if the accept() failed for any reason,
            //  then exit the accept() loop.
            //

            if( !CallbackResult || ( SocketStatus != 0 ) )
            {
                break;
            }
        }

        //
        //  If we hit a socket error, then bail.
        //

        if( SocketStatus != 0 )
        {
            IF_DEBUG( AAP )
            {
                DBGWARN(( DBG_CONTEXT,
                            "AappWorkerThread: context @ %08lX, exiting\n",
                            AapContext ));
            }

            break;
        }

        //
        //  If we haven't exhausted the idle thread quota, then add
        //  ourselves to the idle list.  Otherwise, exit the main
        //  processing loop & terminate this thread.
        //

        AapLockLists();

        if( ( AapContext->State == AapStateShutdown ) ||
            ( p_AapIdleCount >= MAX_IDLE_THREADS ) )
        {
            AapUnlockLists();
            break;
        }

        RemoveEntryList( &AapContext->ContextList );

        AapContext->State = AapStateIdle;
        InsertHeadList( &p_AapIdleList, &AapContext->ContextList );
        p_AapIdleCount++;


        IF_DEBUG( AAP )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AappWorkerThread: context @ %08lX put on idle list\n",
                        AapContext ));
        }

        AapUnlockLists();
    }

    //
    //  We only make it this far if it's time to die.
    //

    AapLockLists();

    if( AapContext->State != AapStateShutdown )
    {
        TCP_REQUIRE( CloseHandle( AapContext->EventHandle ) );
        TCP_REQUIRE( CloseHandle( AapContext->ThreadHandle ) );
        TCP_REQUIRE( closesocket( AapContext->ListeningSocket ) == 0 );

        AappFreeResources( AapContext );
    }

    AapUnlockLists();

    return 0;

}   // AappWorkerThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\globals.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    globals.cxx

    This module contains global variable definitions shared by the
    various FTPD Service components.

    Functions exported by this module:

        InitializeGlobals
        TerminateGlobals
        ReadParamsFromRegistry
        WriteParamsToRegistry


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     11-April-1995 Created new global ftp server config object

*/


#include "ftpdp.hxx"
#include "acptctxt.hxx"

#include <timer.h>


//
//  Private constants.
//

#ifdef _NO_TRACING_
#define DEFAULT_DEBUG_FLAGS             0
#else
#define DEFAULT_TRACE_FLAGS             0
#endif

#define DEFAULT_NO_EXTENDED_FILENAME    0



//
//  Socket transfer buffer size.
//

DWORD                   g_SocketBufferSize;

//
//  Statistics.
//

//
//  FTP Statistics structure.
//

LPFTP_SERVER_STATISTICS g_pFTPStats;

//
//  Miscellaneous data.
//

//
//  The FTP Server sign-on string.
//

LPSTR                   g_FtpServiceNameString;

//
//  key for the registry to read parameters
//
HKEY        g_hkeyParams = NULL;


//
// List holding all the PASV accept context entries
//
LIST_ENTRY g_AcceptContextList;

//
//  The number of threads currently blocked in Synchronous sockets
//  calls, like recv()
//

DWORD       g_ThreadsBlockedInSyncCalls = 0;

//
//  The maximum number of threads that will be allowed to block in
//  Synchronous sockets calls. Magic # that will be changed if the max # of
//  pool threads is less than 100.
//

DWORD       g_MaxThreadsBlockedInSyncCalls = 100;

//
//  The global variable lock.
//

CRITICAL_SECTION        g_GlobalLock;

#ifdef KEEP_COMMAND_STATS

//
//  Lock protecting per-command statistics.
//

CRITICAL_SECTION        g_CommandStatisticsLock;

#endif  // KEEP_COMMAND_STATS


//
//  By default, extended characters are allowed for file/directory names
//  in the data transfer commands. Reg key can disable this.
//

DWORD       g_fNoExtendedChars = FALSE;

#if DBG

//
//  Debug-specific data.
//

//
//  Debug output control flags.
//

#endif  // DBG


//
//  Public functions.
//

/*******************************************************************

    NAME:       InitializeGlobals

    SYNOPSIS:   Initializes global shared variables.  Some values are
                initialized with constants, others are read from the
                configuration registry.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

                Also, this routine is called before the event logging
                routines have been initialized.  Therefore, event
                logging is not available.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     05-April-1995 Added FTP server config object

********************************************************************/
APIERR
InitializeGlobals(
    VOID
    )
{
    APIERR      err = NO_ERROR;
    DWORD       dwDebugFlags;
    ACCEPT_CONTEXT_ENTRY *pAcceptEntry = NULL;
    UINT_PTR dwMaxThreads = 0;

    //
    //  Setup the service sign-on string.
    //

    g_FtpServiceNameString = "Microsoft FTP Service\0";  // must be double \0 terminated


    //
    // Set up PASV accept event variables
    //
    InitializeListHead( &g_AcceptContextList );

    if ( err = CreateInitialAcceptContext() )
    {
        return err;
    }

    //
    //  Create global locks.
    //

    INITIALIZE_CRITICAL_SECTION( &g_GlobalLock );

#ifdef KEEP_COMMAND_STATS

    INITIALIZE_CRITICAL_SECTION( &g_CommandStatisticsLock );

#endif  // KEEP_COMMAND_STATS


    //
    // Create an FTP server object and load values from registry.
    //

    //
    //  Connect to the registry.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        FTPD_PARAMETERS_KEY,
                        0,
                        KEY_ALL_ACCESS,
                        &g_hkeyParams );

    if( err != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "cannot open registry key %s, error %lu\n",
                   FTPD_PARAMETERS_KEY,
                    err ));

        //
        // Load Default values
        //
        err = NO_ERROR;
    }

    //
    // Figure out how many pool threads we can create maximally - if less than built-in
    // number, adjust accordingly
    //

    dwMaxThreads = AtqGetInfo( AtqMaxThreadLimit );

    if ( dwMaxThreads/2 < (UINT_PTR)g_MaxThreadsBlockedInSyncCalls )
    {
        g_MaxThreadsBlockedInSyncCalls = (DWORD)(dwMaxThreads/2);
    }

    DBGPRINTF((DBG_CONTEXT,
               "Max # of threads allowed to be blocked in sync calls : %d\n",
               g_MaxThreadsBlockedInSyncCalls));

# ifdef _NO_TRACING_
# if DBG

    dwDebugFlags  = ReadRegistryDword( g_hkeyParams,
                                      FTPD_DEBUG_FLAGS,
                                      DEFAULT_DEBUG_FLAGS );
    SET_DEBUG_FLAGS( dwDebugFlags);

# endif // DBG
# endif

    g_fNoExtendedChars = ReadRegistryDword( g_hkeyParams,
                                      FTPD_NO_EXTENDED_FILENAME,
                                      DEFAULT_NO_EXTENDED_FILENAME );

    g_pFTPStats = new FTP_SERVER_STATISTICS;
    if ( g_pFTPStats == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return ( err);

}   // InitializeGlobals()







/*******************************************************************

    NAME:       TerminateGlobals

    SYNOPSIS:   Terminate global shared variables.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

                Also, this routine is called after the event logging
                routines have been terminated.  Therefore, event
                logging is not available.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID
TerminateGlobals(
    VOID
    )
{

    if ( g_hkeyParams != NULL) {

        RegCloseKey( g_hkeyParams);
        g_hkeyParams = NULL;
    }


    DeleteAcceptContexts();

    DeleteCriticalSection( &g_GlobalLock );

#ifdef KEEP_COMMAND_STATS

    DeleteCriticalSection( &g_CommandStatisticsLock );

#endif  // KEEP_COMMAND_STATS

}   // TerminateGlobals


/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\acptctxt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    acptctxt.cxx

    This file contains the implementations of the PASV_ACCEPT_CONTEXT and ACCEPT_CONTEXT_ENTRY
    classes used to deal with async PASV connections

*/

#include "ftpdp.hxx"
#include "auxctrs.h"
#include "acptctxt.hxx"



PASV_ACCEPT_CONTEXT::PASV_ACCEPT_CONTEXT() :
m_dwErr( ERROR_SUCCESS ),
m_dwNumEvents( 0 ),
m_hWatchThread( NULL ),
m_dwThreadId( 0 ),
m_dwSignature( ACCEPT_CONTEXT_GOOD_SIG )
/*++

    Constructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{

    if ( ( m_ahEvents[NEEDUPDATE_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT ||
         ( m_ahEvents[CANUPDATE_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT  ||
         ( m_ahEvents[HAVEUPDATED_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT ||
         ( m_ahEvents[EXITTHREAD_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT )
                                                                                       
    {
        m_dwErr = WSAGetLastError();
        
        DBGWARN((DBG_CONTEXT,
                   "WSACreateEvent failed : 0x%x\n",
                   m_dwErr));

        return;
    }

    m_dwNumEvents = 4;

    INITIALIZE_CRITICAL_SECTION( &m_csLock );

    //
    // Create the watching thread
    //
    m_hWatchThread = CreateThread( NULL,
                                   0,
                                   AcceptThreadFunc,
                                   this,
                                   0,
                                   &m_dwThreadId );

    if ( !m_hWatchThread )
    {
        m_dwErr = GetLastError();

        DBGERROR((DBG_CONTEXT,
                   "Failed to create thread to watch for PASV accept events : 0x%x\n",
                   m_dwErr));
    }
}

PASV_ACCEPT_CONTEXT::~PASV_ACCEPT_CONTEXT()
/*++

    Destructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{
    DWORD dwRet = 0;


    //
    // Tell watch thread to shut down
    //
    if ( !WSASetEvent( m_ahEvents[EXITTHREAD_INDEX] ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WSASetEvent failed : 0x%x\n",
                   WSAGetLastError()));
    }

    //
    // wait for thread to shut down
    //
    if ( WaitForSingleObject( m_hWatchThread,
                              INFINITE ) == WAIT_FAILED )
    {
        DBGWARN((DBG_CONTEXT,
                   "Waiting for thread shutdown failed : 0x%x\n",
                   GetLastError()));
    }

    CloseHandle( m_hWatchThread );

    DeleteCriticalSection( &m_csLock );

    m_dwSignature = ACCEPT_CONTEXT_BAD_SIG;
}

BOOL PASV_ACCEPT_CONTEXT::RemoveAcceptEvent( IN WSAEVENT hEvent,
                                             IN USER_DATA *pUserData,
                                             OUT PBOOL pfFound )
/*++

   Removes the event to be signalled when a socket is accept()'able

  Arguments:
     hEvent - event to be removed
     pUserData - USER_DATA attached to signalled event
     pfFound - BOOL set to TRUE if event was found, FALSE if not 

  Returns:
    BOOL indicating success or failure 
--*/
{
    *pfFound = FALSE; 
    DWORD dwIndex = 0;
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwWait = 0;

    //
    // Look for the wanted event
    //
    for ( DWORD i = LASTPREALLOC_INDEX; i < m_dwNumEvents; i++ )
    {
        if ( m_ahEvents[i] == hEvent )
        {
            DBG_ASSERT( m_apUserData[i] == pUserData );

            *pfFound = TRUE;
            dwIndex = i;
            break;
        }
    }

    //
    // Didn't find the event, but function succeeded
    //
    if ( !*pfFound )
    {
        return TRUE;
    }

    //
    // Signal that we want to update the list of events
    //
    if ( !WSASetEvent( m_ahEvents[NEEDUPDATE_INDEX] ) )
    {
        dwRet = WSAGetLastError();

        DBGPRINTF((DBG_CONTEXT,
                   "WSASetEvent failed : 0x%x\n",
                   dwRet));

        goto exit;
    }
        
    //
    // Wait until we can update the list
    //
    dwWait = WSAWaitForMultipleEvents( 1,
                                       &(m_ahEvents[CANUPDATE_INDEX]),
                                       TRUE,
                                       900000, // 15 minutes should do it....
                                       FALSE );
    switch (dwWait) 
    {
    case WSA_WAIT_EVENT_0:
    {
        //
        // Remove the data associated with the socket 
        //

        //
        // we're not going to use the context any more, so remove the reference we hold to it
        //
        m_apUserData[dwIndex]->DeReference();

        memmove( (PVOID) (m_ahEvents + dwIndex),
                 (PVOID) (m_ahEvents + (dwIndex + 1) ),
                 sizeof(WSAEVENT) * (m_dwNumEvents - dwIndex - 1) );

        memmove( (PVOID) ( m_apUserData + dwIndex ),
                 (PVOID) (m_apUserData + (dwIndex + 1) ),
                 sizeof(LPUSER_DATA) * (m_dwNumEvents - dwIndex - 1) );

        memmove( (PVOID) (m_adwNumTimeouts + dwIndex),
                 (PVOID) (m_adwNumTimeouts + (dwIndex + 1) ),
                 sizeof(DWORD) * (m_dwNumEvents - dwIndex - 1) );
            
        m_dwNumEvents--;
        
        //
        // reset to known state
        //
        if ( !WSAResetEvent( m_ahEvents[CANUPDATE_INDEX] ) )
        {
            dwRet = WSAGetLastError();

            DBGWARN((DBG_CONTEXT,
                       "WSAResetEvent failed : 0x%x\n",
                       GetLastError()));

            goto exit;
        }

        //
        // signal that watch thread can start watching again
        //
        if ( !WSASetEvent( m_ahEvents[HAVEUPDATED_INDEX] ) )
        {
            dwRet = WSAGetLastError();

            DBGPRINTF((DBG_CONTEXT,
                       "WSASetEvent failed : 0x%x\n",
                       GetLastError()));

            goto exit;
        }
    }
    break;

    case WSA_WAIT_TIMEOUT:
    {
        IF_DEBUG( PASV )
        {
            DBGWARN((DBG_CONTEXT,
                       "Wait timed out ... \n"));
        }

        dwRet = ERROR_TIMEOUT;
        goto exit;
    }
    break;

    default:
    {
        DBGERROR((DBG_CONTEXT,
                   "Invalid return from WSAWaitForMultipleEvents : 0x%x\n",
                   dwWait));
        
        dwRet = ERROR_INVALID_PARAMETER;
    }

    }

exit:

    return ( dwRet == ERROR_SUCCESS ? TRUE : FALSE );
}

DWORD PASV_ACCEPT_CONTEXT::AddAcceptEvent( WSAEVENT hEvent,
                                           LPUSER_DATA pUserData )
/*++

    Adds an event to be signalled when a socket is accept()'able

  Arguments:
     hEvent - event that will be signalled
     pUserData - USER_DATA context to attach to signalled event

  Returns:
     Error code 
--*/
{
    DWORD dwRet = 0;
    DWORD dwWait = 0;

    if ( m_dwNumEvents == WSA_MAXIMUM_WAIT_EVENTS )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Signal that we want to update the list of events
    //
    if ( !WSASetEvent( m_ahEvents[NEEDUPDATE_INDEX] ) )
    {
        dwRet = WSAGetLastError();

        DBGWARN((DBG_CONTEXT,
                   "WSASetEvent failed : 0x%x\n",
                   dwRet));

        goto exit;
    }
        
    //
    // Wait until we can update the list
    //
    dwWait = WSAWaitForMultipleEvents( 1,
                                       &(m_ahEvents[CANUPDATE_INDEX]),
                                       TRUE,
                                       10000, //10 secs seems like a reasonable time to wait
                                       FALSE );
    switch (dwWait) 
    {
    case WSA_WAIT_EVENT_0:
    {
        //
        // cool, we can update the list
        //
        m_ahEvents[m_dwNumEvents] = hEvent;

        //
        // add a reference to make sure nobody deletes the context out from under us
        //
        pUserData->Reference();
        m_apUserData[m_dwNumEvents] = pUserData;

        m_adwNumTimeouts[m_dwNumEvents] = 0;
        m_dwNumEvents++;


        //
        // reset to known state
        //
        if ( !WSAResetEvent( m_ahEvents[CANUPDATE_INDEX] ) )
        {
            pUserData->DeReference();

            m_dwNumEvents--; //make sure event isn't still seen as valid  

            dwRet = WSAGetLastError();


            DBGWARN((DBG_CONTEXT,
                       "WSAResetEvent failed : 0x%x\n",
                       GetLastError()));

            goto exit;
        }

        //
        // signal that watch thread can start watching again
        //
        if ( !WSASetEvent( m_ahEvents[HAVEUPDATED_INDEX] ) )
        {
            pUserData->DeReference();

            m_dwNumEvents--; //make sure event isn't still seen as valid 

            dwRet = WSAGetLastError();

            DBGWARN((DBG_CONTEXT,
                       "WSASetEvent failed : 0x%x\n",
                       GetLastError()));

            goto exit;
        }

        IF_DEBUG ( PASV )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Added event for context 0x%x at index %d\n",
                       pUserData, m_dwNumEvents - 1));
        }
    }
    break;

    case WSA_WAIT_TIMEOUT:
    {
        IF_DEBUG( PASV )
        {
            DBGWARN((DBG_CONTEXT,
                       "Timed out waiting for permission to update PASV event list ... \n"));
        }

        dwRet = ERROR_TIMEOUT;
        goto exit;
    }
    break;

    default:
    {
        DBGERROR((DBG_CONTEXT,
                   "Invalid return from WSAWaitForMultipleEvents : 0x%x\n",
                   dwWait));
        
        dwRet = ERROR_INVALID_PARAMETER;
    }

    }

exit:

    return dwRet;
}



ACCEPT_CONTEXT_ENTRY::ACCEPT_CONTEXT_ENTRY()
/*++

    Constructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{
    m_pAcceptContext = new PASV_ACCEPT_CONTEXT();

    if ( !m_pAcceptContext )
    {
        DBGERROR((DBG_CONTEXT,
                   "Failed to allocate new PASV_ACCEPT_CONTEXT !\n"));
    }
}

ACCEPT_CONTEXT_ENTRY::~ACCEPT_CONTEXT_ENTRY()
/*++

    Destructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{
    if ( m_pAcceptContext )
    {
        delete m_pAcceptContext;
    }
}



DWORD CreateInitialAcceptContext()
/*++

    Creates the first PASV_ACCEPT_CONTEXT object 

  Arguments:
     None

  Returns:
     Error indicating success/failure
--*/
{
    ACCEPT_CONTEXT_ENTRY *pEntry =  NULL;
    DWORD dwRet = ERROR_SUCCESS;

    if ( !(pEntry = new ACCEPT_CONTEXT_ENTRY() ) )
    {
        DBGERROR((DBG_CONTEXT,
                   "Failed to allocate new ACCEPT_CONTEXT_ENTRY !\n"));
        
        return ERROR_OUTOFMEMORY;
    }

    if ( NULL == pEntry->m_pAcceptContext )
    {
        DBGERROR((DBG_CONTEXT,
                   "Failed to allocate new ACCEPT_CONTEXT_ENTRY::m_pAcceptContext !\n"));

        delete pEntry;
        return ERROR_OUTOFMEMORY;
    }
    if ( ( dwRet = pEntry->m_pAcceptContext->ErrorStatus() ) != ERROR_SUCCESS )
    {
        DBGERROR((DBG_CONTEXT,
                   "Error occurred constructing PASV_ACCEPT_CONTEXT : 0x%x\n",
                   pEntry->m_pAcceptContext->ErrorStatus()));

        delete pEntry;
        return dwRet;
    }

    InsertHeadList( &g_AcceptContextList, &pEntry->ListEntry );

    return dwRet;
}

VOID DeleteAcceptContexts()
/*++

    Deletes all of the PASV_ACCEPT_CONTEXT objects

  Arguments:
     None

  Returns:
     Nothing 
--*/

{
    while ( !IsListEmpty( &g_AcceptContextList ) )
    {
        ACCEPT_CONTEXT_ENTRY *pEntry = CONTAINING_RECORD( g_AcceptContextList.Flink,
                                                          ACCEPT_CONTEXT_ENTRY,
                                                          ListEntry );
        RemoveEntryList( &(pEntry->ListEntry) );

        delete pEntry;
    }
}

DWORD AddAcceptEvent( WSAEVENT hEvent,
                      LPUSER_DATA pUserData )
/*++

    Adds an accept event to an available PASV_ACCEPT_CONTEXT 

  Arguments:
      hEvent - handle to event to be added 
      pUserData - USER_DATA context to attach to event 

  Returns:
     Error code indicating success/failure
--*/
{
    LIST_ENTRY *pEntry = NULL;
    PPASV_ACCEPT_CONTEXT pAcceptContext = NULL;
    PACCEPT_CONTEXT_ENTRY pContextEntry = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL fFoundOne = FALSE;

    pUserData->FakeIOTimes = 0;

    //
    // Walk the list of contexts looking for one that can handle an additional
    // event. 
    // 
    // NB : currently [9/20/98], that list contains only a -single- context, so we can handle
    // up to a maximum of (WSA_MAXIMUM_WAIT_EVENTS - 4) events. If we want to get really 
    // fancy, we could add the necessary code to create a new PASV_ACCEPT_CONTEXT as necessary,
    // but that also creates a new thread, and actually opens us up even more to a Denial Of
    // Service attack, which is partly what this code is trying to avoid
    //
    for ( pEntry = g_AcceptContextList.Flink;
          pEntry != &g_AcceptContextList;
          pEntry = pEntry->Flink )
    {
        pContextEntry =  CONTAINING_RECORD( pEntry, ACCEPT_CONTEXT_ENTRY , ListEntry );
        pAcceptContext = pContextEntry->m_pAcceptContext;

        pAcceptContext->Lock();

        if ( pAcceptContext->QueryNumEvents() < WSA_MAXIMUM_WAIT_EVENTS )
        {
            dwRet = pAcceptContext->AddAcceptEvent( hEvent,
                                                    pUserData );
            
            fFoundOne = TRUE;
        }
        
        pAcceptContext->Unlock();
        
        if ( fFoundOne )
            break;
    }
    
    if (!fFoundOne )
    {
        dwRet = ERROR_OUTOFMEMORY; //not quite the right error 
    }

    return dwRet;
}

BOOL RemoveAcceptEvent( WSAEVENT hEvent,
                        LPUSER_DATA pUserData )
/*++

    Removes an accept event from the appropriate PASV_ACCEPT_CONTEXT 

  Arguments:
      hEvent - handle to event to be removed
      pUserData - USER_DATA context attached to event

  Returns:
      BOOL indicating success/failure
--*/
{
    LIST_ENTRY *pEntry = NULL;
    PPASV_ACCEPT_CONTEXT pAcceptContext = NULL;
    PACCEPT_CONTEXT_ENTRY pContextEntry = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL fFound = FALSE;
    BOOL fSuccess = FALSE;

    //
    // Walk the list of contexts looking for the one that holds the event 
    // event. 
    // 
    for ( pEntry = g_AcceptContextList.Flink;
          pEntry != &g_AcceptContextList;
          pEntry = pEntry->Flink )
    {
        pContextEntry =  CONTAINING_RECORD( pEntry, ACCEPT_CONTEXT_ENTRY , ListEntry );
        pAcceptContext = pContextEntry->m_pAcceptContext;

        pAcceptContext->Lock();

        fSuccess = pAcceptContext->RemoveAcceptEvent( hEvent,
                                                      pUserData,
                                                      &fFound );

        if ( fFound )
        {
            pAcceptContext->Unlock();
            return fSuccess;
        }

        pAcceptContext->Unlock();
    }

    return TRUE;
}

DWORD WINAPI PASV_ACCEPT_CONTEXT::AcceptThreadFunc( LPVOID pvContext )
/*++

      Thread function for the thread that waits on the accept events

  Arguments:
      pvContext - context pointer (pointer to PASV_ACCEPT_CONTEXT object)

  Returns:
     Nothing useful
--*/

{
    PPASV_ACCEPT_CONTEXT pAcceptContext = NULL;
    WSAEVENT *phAcceptEvents = NULL;
    DWORD dwNumEvents = 0;
    DWORD dwRet = 0;
    WSAEVENT *phNeedUpdate = NULL;
    WSAEVENT *phCanUpdate = NULL;
    WSAEVENT *phHaveUpdated = NULL;
    WSAEVENT *phExitThread = NULL;

    DBG_ASSERT( pvContext );

    pAcceptContext = (PPASV_ACCEPT_CONTEXT) pvContext;
    phAcceptEvents = pAcceptContext->m_ahEvents;
    dwNumEvents = pAcceptContext->m_dwNumEvents;
    phNeedUpdate = &phAcceptEvents[NEEDUPDATE_INDEX];
    phCanUpdate = &phAcceptEvents[CANUPDATE_INDEX];
    phHaveUpdated = &phAcceptEvents[HAVEUPDATED_INDEX];
    phExitThread = &phAcceptEvents[EXITTHREAD_INDEX];

loop:

    // wait timeout should be fairly small, so we can go through list and purge all
    // sockets that have been inactive a given # of timeouts

    dwRet = WSAWaitForMultipleEvents( dwNumEvents,
                                      phAcceptEvents,
                                      FALSE,
                                      PASV_TIMEOUT_INTERVAL,
                                      FALSE );

    if ( dwRet <= (WSA_WAIT_EVENT_0 + dwNumEvents - 1) )
    {
        //
        // One of the events was signalled
        //
        DWORD dwIndex = dwRet - WSA_WAIT_EVENT_0;

        switch (dwIndex)
        {
        case (NEEDUPDATE_INDEX):
        {
            //
            // Somebody wants to update the list of events to watch for, so signal that
            // they can do so and wait for them to tell us they're done with the update
            //
            if ( !WSAResetEvent( *phNeedUpdate ) ) //back to known state 
            {
                DBGWARN((DBG_CONTEXT,
                           "WSAResetEvent failed : 0x%x\n",
                           WSAGetLastError()));
            }

            if ( !WSASetEvent( *phCanUpdate ) )
            {
                DBGWARN((DBG_CONTEXT,
                           "WSASetEvent failed : 0x%x\n",
                           WSAGetLastError()));
            }

            if ( WSAWaitForMultipleEvents( 1,
                                           phHaveUpdated,
                                           TRUE,
                                           INFINITE,
                                           FALSE )  == WSA_WAIT_FAILED )
            {
                DBGERROR((DBG_CONTEXT,
                           "WSAWaitForMultipleEvents failed : 0x%x\n",
                           WSAGetLastError()));
            }

            if ( !WSAResetEvent( *phHaveUpdated ) ) //back to known state
            {
                DBGWARN((DBG_CONTEXT,
                           "WSAResetEvent failed : 0x%x\n",
                           WSAGetLastError()));
            }

            dwNumEvents = pAcceptContext->m_dwNumEvents;

            goto loop;
        }
        break;

        case (CANUPDATE_INDEX):
        case (HAVEUPDATED_INDEX):
        {
            //
            // Should never happen !
            //
            IF_DEBUG ( PASV )
            {
                DBGERROR((DBG_CONTEXT,
                           "Invalid event signalled !\n"));
            }
        }
        break;

        case (EXITTHREAD_INDEX):
        {
            //
            // We're all done 
            //
            IF_DEBUG ( PASV )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Exiting thread watching for PASV events....\n"));
            }

            return 0;
        }
        break;

        default:
        {
            LPUSER_DATA pUserData = NULL;

            //
            // One of the sockets has become accept()'able.
            //
            IF_DEBUG ( PASV )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Got an acceptable socket, index : %i, context : 0x%x\n",
                           dwIndex, pAcceptContext->m_apUserData[dwIndex]));
            }

            pUserData = pAcceptContext->m_apUserData[dwIndex];

            //
            // Remove the data associated with the socket 
            //
            memmove( (PVOID) (pAcceptContext->m_ahEvents + dwIndex),
                     (PVOID) (pAcceptContext->m_ahEvents + (dwIndex + 1) ),
                     sizeof(WSAEVENT) * (dwNumEvents - dwIndex - 1) );

            memmove( (PVOID) ( pAcceptContext->m_apUserData + dwIndex ),
                     (PVOID) (pAcceptContext->m_apUserData + (dwIndex + 1) ),
                     sizeof(LPUSER_DATA) * (dwNumEvents - dwIndex - 1) );

            memmove( (PVOID) (pAcceptContext->m_adwNumTimeouts + dwIndex),
                     (PVOID) (pAcceptContext->m_adwNumTimeouts + (dwIndex + 1) ),
                     sizeof(DWORD) * (dwNumEvents - dwIndex - 1) );
            
            pAcceptContext->m_dwNumEvents--;

            dwNumEvents = pAcceptContext->m_dwNumEvents;

            //
            // deal with restarting processing
            // 
            SignalAcceptableSocket( pUserData );

            goto loop;
        }
        }
    }
    else if ( dwRet == WSA_WAIT_TIMEOUT )
    {
        //
        // wait timed out, so go through the list of events and remove those that have
        // timed out too often
        //
        for ( DWORD i = LASTPREALLOC_INDEX;//skip the events that don't have a fixed # of timeouts
              i < dwNumEvents; 
              i++ )
        {
            if ( pAcceptContext->m_adwNumTimeouts[i] == MAX_PASV_TIMEOUTS )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "timing out socket at index %i, context 0x%x \n",
                           i,
                           pAcceptContext->m_apUserData[i]));

                CleanupTimedOutSocketContext( pAcceptContext->m_apUserData[i] );

                memmove( (PVOID) (pAcceptContext->m_ahEvents + i),
                         (PVOID) (pAcceptContext->m_ahEvents + (i+1) ),
                         sizeof(WSAEVENT) * (dwNumEvents - i - 1) );

                memmove( (PVOID) ( pAcceptContext->m_apUserData + i ),
                         (PVOID) (pAcceptContext->m_apUserData + (i+1) ),
                         sizeof(LPUSER_DATA) * (dwNumEvents - i - 1) );

                memmove( (PVOID) (pAcceptContext->m_adwNumTimeouts + i),
                         (PVOID) (pAcceptContext->m_adwNumTimeouts + (i+1) ),
                         sizeof(DWORD) * (dwNumEvents - i - 1) );

                //
                // need to readjust the index and number of items in the array
                //
                i--;
                dwNumEvents--;

                pAcceptContext->m_dwNumEvents--;
            }
            else
            {
                pAcceptContext->m_adwNumTimeouts[i]++;
            }
        }

        dwNumEvents = pAcceptContext->m_dwNumEvents;

        goto loop;
    }
    else if ( dwRet == WAIT_IO_COMPLETION )
    {
        DBGWARN((DBG_CONTEXT,
                   "Invalid value from WSAWaitForMultipleEvents !\n"));


        goto loop;
    }
    else 
    {
        DBGERROR((DBG_CONTEXT,
                   "WSAWaitForMultipleEvents returned 0x%x, error : 0x%x\n", 
                   dwRet, WSAGetLastError()));

        goto loop;
    }

    return 0;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\makefile.inc ===
#
# Supplemental rules for generating message file.
#

$(O)\msg.h $(O)\msg.rc $(O)\msg00001.bin: msg.mc ..\..\..\inc\inetamsg.mc
    copy /a ..\..\..\inc\inetamsg.mc + /a msg.mc $(O)\tmp.mc
    mc -h .\$(O) -r .\$(O) -v $(O)\tmp.mc
    move $(O)\tmp.h $(O)\msg.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\asyncio.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

       asyncio.cxx

   Abstract:

       This module implements functions for ASYNC_IO_CONNECTION Object.

   Author:

       Murali R. Krishnan    ( MuraliK )    27-March-1995

   Environment:

      User Mode -- Win32

   Project:

      Internet Services DLL

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
// need to include ftpdp.hxx here since precompiled header used.
# include "ftpdp.hxx"

# include "dbgutil.h"
# include "asyncio.hxx"
# include "..\..\infocomm\atq\atqtypes.hxx"


/************************************************************
 *   Functions
 ************************************************************/



ASYNC_IO_CONNECTION::ASYNC_IO_CONNECTION(
   IN  PFN_ASYNC_IO_COMPLETION  pfnAioCompletion,
   IN  SOCKET sClient OPTIONAL
   )
:   m_pAioContext      ( NULL),
    m_pfnAioCompletion ( pfnAioCompletion),
    m_sClient          ( sClient),
    m_sTimeout         ( DEFAULT_CONNECTION_IO_TIMEOUT),
    m_pAtqContext      ( NULL),
    m_endpointObject   ( NULL)
{
    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Created a new ASYNC_IO_CONNECTION object ( %08x)\n",
                    this
                    ));
    }

} // ASYNC_IO_CONNECTION::ASYNC_IO_CONNECTION()




ASYNC_IO_CONNECTION::~ASYNC_IO_CONNECTION( VOID)
/*++
  This function cleans up the ASYNC_IO_CONNECTION object. It also frees
  up sockets and ATQ context embedded in this object.

  THIS IS NOT MULTI_THREAD safe!

--*/
{

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Deleting the ASYNC_IO_CONNECTION object ( %08x) \n",
                    this
                    ));
    }

    if ( m_sClient != INVALID_SOCKET) {

        //
        // Shut and Close the socket. This can fail, if the socket is already
        //  closed by some other thread before this operation completes
        //

        StopIo( NO_ERROR);
    }

    if ( m_pAtqContext != NULL) {

       AtqFreeContext( m_pAtqContext, TRUE );
       m_pAtqContext = NULL;
    }

    DBG_ASSERT( m_sClient == INVALID_SOCKET);

} // ASYNC_IO_CONNECTION::~ASYN_IO_CONNECTION()





BOOL
ASYNC_IO_CONNECTION::ReadFile(
    OUT LPVOID   pvBuffer,
    IN DWORD     cbSize
    )
/*++
  This starts off an Asynchronous read operation for data from client
   into the supplied buffer.

  Arguments:
     pvBuffer         pointer to byte buffer which on successful
                        return will contain the data read from client
     cbSize           count of bytes of data available in the buffer.
                        ( limits the size of data that can be read)

  Returns:
    TRUE on success and FALSE if there is a failure in setting up read.
--*/
{
    BOOL fReturn = TRUE;

    DBG_ASSERT( pvBuffer != NULL);

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "ReadFile( %08x, %u)\n",
                    this, pvBuffer, cbSize
                    ));
    }

    if (( m_pAtqContext == NULL && !AddToAtqHandles()) ||
        !AtqReadFile( m_pAtqContext, pvBuffer, cbSize, NULL )) {

        IF_DEBUG( ASYNC_IO) {

            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::WriteFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::ReadFile()





BOOL
ASYNC_IO_CONNECTION::WriteFile(
    OUT LPVOID   pvBuffer,
    IN DWORD     cbSize
    )
/*++
  This starts off an Asynchronous write operation to send data to the client
    sending data from the supplied buffer. The buffer may not be freed
    until the data is sent out.

  Arguments:
     pvBuffer         pointer to byte buffer which contains the data to be sent
                       to the client.
     cbSize           count of bytes of data to be sent.

  Returns:
    TRUE on success and FALSE if there is a failure in setting up write.
--*/
{
    BOOL fReturn = TRUE;
    DBG_ASSERT( pvBuffer != NULL);

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "WriteFile( %08x, %u)\n",
                    this, pvBuffer, cbSize
                    ));
    }

    //
    // Check and add to create an atq context as well as perform
    //  the write operation.
    //
    if ( (m_pAtqContext == NULL && !AddToAtqHandles()) ||
        !AtqWriteFile( m_pAtqContext, pvBuffer, cbSize, NULL )) {

        IF_DEBUG( ASYNC_IO) {
            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::WriteFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::WriteFile()





BOOL
ASYNC_IO_CONNECTION::TransmitFile(
    IN HANDLE  hFile,
    IN LARGE_INTEGER & liSize,
    IN DWORD   dwOffset,
    IN LPTRANSMIT_FILE_BUFFERS   lpTransmitBuffers OPTIONAL
    )
/*++
  This starts off an Asynchronous TransmitFile operation to send file data
   to the client.

  Arguments:
    hFile            handle for the file to be transmitted.
    liSize           large integer containing size of file to be sent.
    Offset           Offset within the file to begin transmitting.
    lpTransmitBuffers pointer to File Transmit Buffers

  Returns:
    TRUE on success and FALSE if there is a failure in setting up read.
--*/
{
    BOOL fReturn = TRUE;
    DBG_ASSERT( hFile != INVALID_HANDLE_VALUE);

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "TransmitFile( %08x, %l, %ul, %08x)\n",
                    this, hFile, liSize.HighPart, liSize.LowPart,
                    lpTransmitBuffers
                    ));
    }

    if ( m_pAtqContext == NULL )
    {
        if (!AddToAtqHandles())
        {
            IF_DEBUG( ASYNC_IO)
            {
                DWORD dwError = GetLastError();
                DBGPRINTF(( DBG_CONTEXT,
                           "ASYNC_IO_CONNECTION(%08x)::AddToAtqHandles() failed."
                           " Error = %u\n",
                           this, dwError));
                SetLastError( dwError);
            }

            return FALSE;
        }
    }

    m_pAtqContext->Overlapped.Offset = dwOffset;

    if (!AtqTransmitFile( m_pAtqContext,
                          hFile,
                          ((liSize.HighPart == 0) ? liSize.LowPart : 0),
                          lpTransmitBuffers,
                          TF_DISCONNECT )
        )
    {

        IF_DEBUG( ASYNC_IO) {
            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::TransmitFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::TransmitFile()



BOOL
ASYNC_IO_CONNECTION::TransmitFileTs(
    IN TS_OPEN_FILE_INFO * pOpenFile,
    IN LARGE_INTEGER &     liSize,
    IN DWORD               dwOffset
    )
/*++
  This starts off an Asynchronous TransmitFile operation to send file data
   to the client.

  Arguments:
    hFile            handle for the file to be transmitted.
    liSize           large integer containing size of file to be sent.
    Offset           Offset within the file to begin transmitting.

  Returns:
    TRUE on success and FALSE if there is a failure in setting up read.
--*/
{
    BOOL   fReturn = TRUE;
    PBYTE  pFileBuffer = NULL;
    HANDLE hFile = NULL;
    TRANSMIT_FILE_BUFFERS TransmitBuffers;

    DBG_ASSERT( pOpenFile );

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "TransmitFile( %p, %p, %ul, %08x)\n",
                    this, pOpenFile, liSize.HighPart, liSize.LowPart
                    ));
    }

    if ( m_pAtqContext == NULL )
    {
        if (!AddToAtqHandles())
        {
            IF_DEBUG( ASYNC_IO)
            {
                DWORD dwError = GetLastError();
                DBGPRINTF(( DBG_CONTEXT,
                           "ASYNC_IO_CONNECTION(%08x)::AddToAtqHandles() failed."
                           " Error = %u\n",
                           this, dwError));
                SetLastError( dwError);
            }

            return FALSE;
        }
    }

    pFileBuffer = pOpenFile->QueryFileBuffer();
    if (pFileBuffer) {
        //
        // Transmit from memory
        //

        DBG_ASSERT( liSize.HighPart == 0 );

        TransmitBuffers.Head       = pFileBuffer + dwOffset;
        TransmitBuffers.HeadLength = liSize.LowPart;
        TransmitBuffers.Tail       = NULL;
        TransmitBuffers.TailLength = 0;
    } else {
        //
        // Transmit from a file
        //
        hFile = pOpenFile->QueryFileHandle();
        m_pAtqContext->Overlapped.Offset = dwOffset;

        if (liSize.HighPart != 0)
        {
            LARGE_INTEGER liTimeOut;
            ULONG Remainder;

            liTimeOut =
                RtlExtendedLargeIntegerDivide(
                liSize,
                (ULONG) 1024,
                &Remainder);

            if (liTimeOut.HighPart != 0)
            {
                ((PATQ_CONT) m_pAtqContext)->TimeOut = ATQ_INFINITE;
            } else
            {
                ((PATQ_CONT) m_pAtqContext)->TimeOut = liTimeOut.LowPart;
            }
        }
    }

    if (!AtqTransmitFile( m_pAtqContext,
                          hFile,
                          ((liSize.HighPart == 0) ? liSize.LowPart : 0),
                          pFileBuffer ? &TransmitBuffers : NULL,
                          TF_DISCONNECT )
        )
    {

        IF_DEBUG( ASYNC_IO) {
            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::TransmitFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::TransmitFile()




BOOL
ASYNC_IO_CONNECTION::StopIo( IN DWORD  dwErrorCode OPTIONAL)
/*++
  This function stops the io connection by performing a hard close on
  the socket that is used for IO. that is the only way one can easily kill the
  IO that is in progress.

  Arguments:
    dwErrorCode   DWORD containing the error code for stopping IO

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
{
    INT serr = 0;

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ASYNC_IO_CONNECTION( %08x)::StopIo( %u)\n",
                    this, dwErrorCode
                    ));
    }

    //
    // NYI! dwErrorCode is not at present used.
    //

    if ( m_sClient != INVALID_SOCKET) {

        SOCKET sOld = m_sClient;
        m_sClient = INVALID_SOCKET;

        // MuraliK  07/25/95  Shutdown causes problems in sending last msg.
# ifdef ENABLE_SHUT_DOWN

        // Shut the socket and close it
        // even if shut fails, still go ahead and close

        if ( shutdown( sOld, 0) == SOCKET_ERROR) {

            IF_DEBUG( ASYNC_IO) {
                DBGPRINTF((DBG_CONTEXT,
                           " ASYNC_IO_CONNECTION( %08x)::StopIo( %u)."
                           "shutdown(%08x,1) failed. Error = %d\n",
                           this, dwErrorCode, sOld, WSAGetLastError()));
            }

            DBGERROR((DBG_CONTEXT, "shutdown(%u, 0) failed. Error=%u\n",
                      sOld, WSAGetLastError()));
        }
#endif // ENABLE_SHUT_DOWN

        //
        // patch added on 11/2/95
        //  After AcceptEx addition, closing the ATQ'ed socket is
        //   is to be done by ATQ module.
        //

        if ( sOld != INVALID_SOCKET) {

            if (m_pAtqContext != NULL) {

                //
                // per the FTP RFC, the server must close the socket when killing a data
                // channel.
                //

                if (!AtqCloseSocket( m_pAtqContext, TRUE)) {

                    serr = GetLastError();
                }
            } else {

                // Ignore failures in Shutdown and close socket.
                if (closesocket( sOld) == SOCKET_ERROR) {

                    serr = WSAGetLastError();
                }
            }

            if ( serr != 0 ) {

                SetLastError( serr);
            }
        }
    }

    return ( serr == 0);
} // ASYNC_IO_CONNECTION::StopIo()




BOOL
ASYNC_IO_CONNECTION::SetNewSocket(IN SOCKET sNewSocket,
                                  IN PATQ_CONTEXT pNewAtqContext, // = NULL
                                  IN PVOID EndpointObject )
/*++

  This function changes the socket maintained for given ASYNC_IO_CONNECTION
  object. It changes it only if the current socket in the object is already
   freed (by calling StopIo()).

  If the Atq Context in this object is a valid one corresponding to old
   socket, it is also freed. So any new operation will create a new AtqContext.
  (This is essential, since there is a one-to-one-relationship between socket
   and ATQ context)


  Arguments:
    sNewSocket   new socket for the connection
     If sNewSocket == INVALID_SOCKET then this function does
       cleanup of old information.

    pNewAtqContext  new ATQ Context for the socket

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = TRUE;

    if ( m_sClient == INVALID_SOCKET) {

        //
        // Free the Atq Context if one already exists.
        //  ==> Reason: There is a one-to-one correspondence b/w ATQ Context
        //               and socket. The atq context if valid was created
        //               for old connection.
        //

        // To avoid race conditions, we exchange pointer with NULL
        //  and later on free the object as need be.
        // Should we necessarily use InterlockedExchange() ???
        //  Isn't it costly? NYI

        PATQ_CONTEXT pAtqContext =
          (PATQ_CONTEXT ) InterlockedExchangePointer( (PVOID *) &m_pAtqContext,
                                              (PVOID) pNewAtqContext);

        if ( pAtqContext != NULL) {

            AtqFreeContext( pAtqContext, TRUE );
        }

        m_sClient = sNewSocket;
        m_endpointObject = EndpointObject;

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::SetNewSocket()



# if DBG

VOID ASYNC_IO_CONNECTION::Print( VOID) const
{

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing ASYNC_IO_CONNECTION( %08x)\n"
                " CallBackFunction = %08x; Context = %08x\n"
                " Client Socket = %u; AtqContext = %08x;"
                " Timeout = %u sec; \n",
                this, m_pfnAioCompletion, m_pAioContext,
                m_sClient, m_pAtqContext, m_sTimeout));

    return;
} // ASYNC_IO_CONNECTION::Print()


# endif // DBG





VOID
ProcessAtqCompletion(IN LPVOID       pContext,
                     IN DWORD        cbIo,
                     IN DWORD        dwCompletionStatus,
                     IN OVERLAPPED * lpo
                     )
/*++

  This function processes the completion of an atq operation.
  It also sends a call back to the owner of this object ( ASYNC_IO_CONNECTION)
    object, once the operation is completed or if it is in error.

  ATQ module sends 2 messages whenever there is a timeout.
  Reason: The timeout itself is sent by a separate thread and completion port
   API does not support removal of a socket from the completion port. Combining
   these together, ATQ sends a separate timeout message and then when the
   application blows off the socket/handle, ATQ sends another error message
   implying failure of the connection.
    We handle this as follows:
      At timeout ATQ sends fIOCompletion == FALSE and
         dwCompletionStatus == ERROR_SEM_TIMEOUT.
      We send this as fTimedOut in call back.
      The application can check if it is fTimedOut and hence refrain from
       blowing the object completely away.

  Arguments:
     pContext     pointer to User supplied context information
                   ( here: pointer to ASYNC_IO_CONNECTION associated with
                           the IO completed)
     cbIo         count of bytes of IO performed
     dwCompletionStatus  DWORD containing error code if any
     lpo - !NULL if completion from IO

  Returns:
     None
--*/
{
    LPASYNC_IO_CONNECTION   pConn = (LPASYNC_IO_CONNECTION ) pContext;
    BOOL  fTimedOut = FALSE;

    if ( pConn == NULL) {

        // This should not happen....

        SetLastError( ERROR_INVALID_PARAMETER);

        DBG_ASSERT( pConn == NULL);
        return ;
    }

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "ProcessAtqCompletion(Aio=%08x, cb=%u, Status=%u,"
                    "IO Compltion=%s).\n",
                    pConn,  cbIo, dwCompletionStatus,
                    lpo != NULL ? "TRUE" : "FALSE" ));
    }

    if ( lpo != NULL ||
         (fTimedOut = (
                       lpo == NULL &&
                       dwCompletionStatus == ERROR_SEM_TIMEOUT))
        ) {

        //
        //  This is the right Atq object. Process the response by passing it
        //    to the owner of this object.
        //

        DBG_ASSERT( pConn->QueryPfnAioCompletion() != NULL);

        //
        // Invoke the call back function for completion of IO.
        //

        ( *pConn->QueryPfnAioCompletion())
          (pConn->QueryAioContext(), cbIo, dwCompletionStatus,
           pConn, fTimedOut);

    }

    return;

} // ProcessAtqCompletion()





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\ftpconf.cxx ===
/*++
   Copyright    (c)    1994        Microsoft Corporation

   Module Name:

        ftpconf.cxx

   Abstract:

        This module contains functions for FTP Server configuration
         class (FTP_SERVER_CONFIG).

   Author:

        Murali R. Krishnan    (MuraliK)    21-March-1995

   Project:
        FTP Server DLL

   Functions Exported:

        FTP_SERVER_CONFIG::FTP_SERVER_CONFIG()
        FTP_SERVER_CONFIG::~FTP_SERVER_CONFIG()
        FTP_SERVER_CONFIG::InitFromRegistry()
        FTP_SERVER_CONFIG::GetConfigInformation()
        FTP_SERVER_CONFIG::SetConfigInformation()
        FTP_SERVER_CONFIG::AllocNewConnection()
        FTP_SERVER_CONFIG::RemoveConnection()
        FTP_SERVER_CONFIG::DisconnectAllConnections()

        FTP_SERVER_CONFIG::Print()

   Revisions:

       MuraliK   26-July-1995    Added Allocation caching of client conns.

--*/

# include "ftpdp.hxx"

#include <ole2.h>
#include <imd.h>
#include <iiscnfgp.h>
#include <mb.hxx>

#include <mbstring.h>
# include <tchar.h>
#include <timer.h>

extern "C"
{
    #include "ntlsa.h"

}   // extern "C"



/************************************************************
 *  Symbolic Constants
 ************************************************************/


#define DEFAULT_ALLOW_ANONYMOUS         TRUE
#define DEFAULT_ALLOW_GUEST_ACCESS      TRUE
#define DEFAULT_ANONYMOUS_ONLY          FALSE

#define DEFAULT_READ_ACCESS_MASK        0
#define DEFAULT_WRITE_ACCESS_MASK       0
#define DEFAULT_MSDOS_DIR_OUTPUT        TRUE

#define DEFAULT_USE_SUBAUTH             TRUE
#define DEFAULT_LOGON_METHOD            LOGON32_LOGON_INTERACTIVE
#define DEFAULT_ANONYMOUS_PWD           ""

const TCHAR DEFAULT_EXIT_MESSAGE[] = TEXT("Goodbye.");
# define CCH_DEFAULT_EXIT_MESSAGE         (lstrlen( DEFAULT_EXIT_MESSAGE) + 1)

const TCHAR DEFAULT_MAX_CLIENTS_MSG[] =
   TEXT("Maximum clients reached, service unavailable.");

# define CCH_DEFAULT_MAX_CLIENTS_MSG  (lstrlen( DEFAULT_MAX_CLIENTS_MSG) + 1)

// this should be a double null terminated null terminated sequence.
const TCHAR DEFAULT_GREETING_MESSAGE[2] = { '\0', '\0' };
# define CCH_DEFAULT_GREETING_MESSAGE  ( 2)

// this should be a double null terminated null terminated sequence.
const TCHAR DEFAULT_BANNER_MESSAGE[2] = { '\0', '\0' };
# define CCH_DEFAULT_BANNER_MESSAGE  ( 2)


#define DEFAULT_ANNOTATE_DIRS           FALSE
#define DEFAULT_LOWERCASE_FILES         FALSE
#define DEFAULT_LISTEN_BACKLOG          1       /* reduce listen backlog */

#define DEFAULT_ENABLE_LICENSING        FALSE
#define DEFAULT_DEFAULT_LOGON_DOMAIN    NULL    // NULL == use primary domain

#define DEFAULT_ENABLE_PORT_ATTACK      FALSE
#define DEFAULT_ENABLE_PASV_THEFT       FALSE
#define DEFAULT_ALLOW_REPLACE_ON_RENAME FALSE
#define DEFAULT_SHOW_4_DIGIT_YEAR       FALSE


# define SC_NOTIFY_INTERVAL      3000    // milliseconds
# define CLEANUP_POLL_INTERVAL   2000    // milliseconds
# define CLEANUP_RETRY_COUNT     12      // iterations

//
//  Private Prototypes
//



APIERR
GetDefaultDomainName(
    CHAR  * pszDomainName,
    DWORD   cchDomainName
    );

BOOL
FtpdReadRegString(
    IN HKEY     hkey,
    OUT TCHAR * * ppchstr,
    IN LPCTSTR  pchValue,
    IN LPCTSTR  pchDefault,
    IN DWORD    cchDefault
    );

BOOL
GenMessageWithLineFeed(IN LPSTR pszzMessage,
                       IN LPSTR * ppszMessageWithLineFeed);


#if DBG

static CHAR * p_AccessTypes[] = { "read",
                                  "write",
                                  "create",
                                  "delete" };

#endif  // DBG


/************************************************************
 *    Member Functions of FTP_SERVER_INSTANCE
 ************************************************************/

FTP_SERVER_INSTANCE::FTP_SERVER_INSTANCE(
        IN PFTP_IIS_SERVICE pService,
        IN DWORD  dwInstanceId,
        IN USHORT sPort,
        IN LPCSTR lpszRegParamKey,
        IN LPWSTR lpwszAnonPasswordSecretName,
        IN LPWSTR lpwszRootPasswordSecretName,
        IN BOOL   fMigrateVroots
        )
/*++

  Description:

    Constructor Function for Ftp server Configuration object
     ( Initializes all members to be NULL)

    The valid flag may be initialized to TRUE only after reading values
      from registry.

--*/
        : IIS_SERVER_INSTANCE(
            pService,
            dwInstanceId,
            sPort,
            lpszRegParamKey,
            lpwszAnonPasswordSecretName,
            lpwszRootPasswordSecretName,
            fMigrateVroots
        ),
    m_cCurrentConnections    ( 0),
    m_cMaxCurrentConnections ( 0),
    m_fValid                 ( FALSE),
    m_fAllowAnonymous        ( TRUE),
    m_fAnonymousOnly         ( FALSE),
    m_fAllowGuestAccess      ( TRUE),
    m_fAnnotateDirectories   ( FALSE),
    m_fLowercaseFiles        ( FALSE),
    m_fMsdosDirOutput        ( FALSE),
    m_fFourDigitYear         ( FALSE),
    m_fEnableLicensing       ( FALSE),
    m_fEnablePortAttack      ( FALSE),
    m_fEnablePasvTheft       ( FALSE),
    m_pszGreetingMessageWithLineFeed( NULL),
    m_pszBannerMessageWithLineFeed( NULL),
    m_pszLocalHostName       (NULL),
    m_dwUserFlags            ( 0),
    m_ListenBacklog          ( DEFAULT_LISTEN_BACKLOG),
    m_pFTPStats              (NULL)
{

   InitializeListHead( &m_ActiveConnectionsList);
   INITIALIZE_CRITICAL_SECTION( &m_csLock);
   InitializeListHead( &m_FreeConnectionsList);
   INITIALIZE_CRITICAL_SECTION( &m_csConnectionsList);

   if( QueryServerState() == MD_SERVER_STATE_INVALID ) {
       return;
   }

   m_pFTPStats = new FTP_SERVER_STATISTICS;

   if ( m_pFTPStats == NULL )
   {
       SetServerState( MD_SERVER_STATE_INVALID, ERROR_NOT_ENOUGH_MEMORY );
       SetLastError( ERROR_NOT_ENOUGH_MEMORY );
   }

   return;

} // FTP_SERVER_INSTANCE::FTP_SERVER_INSTANCE()




FTP_SERVER_INSTANCE::~FTP_SERVER_INSTANCE( VOID)
/*++
     Description:

        Destructor function for server config object.
        ( Frees all dynamically allocated storage space)
--*/
{
    HRESULT             hRes;

    //
    // delete statistics object
    //

    if( m_pFTPStats != NULL )
    {
        delete m_pFTPStats;
        m_pFTPStats = NULL;
    }

    //
    //  The strings are automatically freed by a call to destructor
    //

    if ( m_pszLocalHostName != NULL) {

        delete [] ( m_pszLocalHostName);
    }

    if ( m_pszGreetingMessageWithLineFeed != NULL) {

        TCP_FREE( m_pszGreetingMessageWithLineFeed);
         m_pszGreetingMessageWithLineFeed = NULL;
    }

    if ( m_pszBannerMessageWithLineFeed != NULL) {

        TCP_FREE( m_pszBannerMessageWithLineFeed);
         m_pszBannerMessageWithLineFeed = NULL;
    }

    m_rfAccessCheck.Reset( (IMDCOM*)m_Service->QueryMDObject() );

    DBG_ASSERT( m_cCurrentConnections == 0);
    DBG_ASSERT( IsListEmpty( &m_ActiveConnectionsList));

    LockConnectionsList();
    DBG_REQUIRE(FreeAllocCachedClientConn());
    UnlockConnectionsList();

    DBG_ASSERT( IsListEmpty( &m_FreeConnectionsList));

    //
    // Delete the critical section object
    //

    DeleteCriticalSection( &m_csLock);
    DeleteCriticalSection( &m_csConnectionsList);


} /* FTP_SERVER_INSTANCE::~FTP_SERVER_INSTANCE() */




DWORD
FTP_SERVER_INSTANCE::StartInstance()
{
    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "FTP_SERVER_INSTANCE::StartInstance called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT(m_pFTPStats);
    m_pFTPStats->UpdateStopTime();

    DWORD dwError = IIS_SERVER_INSTANCE::StartInstance();

    if ( dwError)
    {
        IF_DEBUG(INSTANCE) {
            DBGPRINTF((
                DBG_CONTEXT,
                "FTO_SERVER_INSTANCE - IIS_SERVER_INSTANCE Failed. StartInstance returned 0x%x",
                dwError
                ));
        }

        return dwError;
    }

    dwError = InitFromRegistry( FC_FTP_ALL & ~FC_FTP_LOG_IN_UTF_8 & ~FC_FTP_USER_ISOLATION);


   if( dwError == NO_ERROR ) {
      dwError = ReadAuthentInfo();
   }

   if (dwError == NO_ERROR)
   {
        m_pFTPStats->UpdateStartTime();
   }

   return dwError;
}



DWORD
FTP_SERVER_INSTANCE::StopInstance()
{
    DBG_ASSERT(m_pFTPStats);

    m_pFTPStats->UpdateStopTime();
    return IIS_SERVER_INSTANCE::StopInstance();
}


DWORD
FTP_SERVER_INSTANCE::SetLocalHostName(IN LPCSTR pszHost)
/*++

  This function copies the host name specified in the given string to
  configuration object.

  Arguments:
     pszHost   pointer to string containing the local host name.

  Returns:
     NO_ERROR on success and ERROR_NOT_ENOUGH_MEMORY when no memory.
     ERROR_ALREADY_ASSIGNED  if value is already present.
--*/
{
    //
    //  if already a host name exists, return error.
    //  otherwise allocate memory and copy the local host name.
    //

    if ( m_pszLocalHostName != NULL) {

        return (ERROR_ALREADY_ASSIGNED);
    } else {
        m_pszLocalHostName = new CHAR[lstrlenA(pszHost) + 1];
        if ( m_pszLocalHostName == NULL) {

            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        lstrcpyA( m_pszLocalHostName, pszHost);
    }

    return (NO_ERROR);

} // FTP_SERVER_INSTANCE::SetLocalHostName()




DWORD
FTP_SERVER_INSTANCE::InitFromRegistry(
    IN FIELD_CONTROL   FieldsToRead)
/*++
    Description:
      Initializes server configuration data from registry.
      Some values are also initialized with constants.
      If invalid registry key or load data from registry fails,
        then use default values.

    Arguments:

      hkeyReg     handle to registry key

      FieldsToRead
        bitmask indicating the fields to read from the registry.
        This is useful when we try to read the new values after
            modifying the registry information as a result of
            SetAdminInfo call from the Admin UI

    Returns:

       NO_ERROR   if there are no errors.
       Win32 error codes otherwise

    Limitations:

        No validity check is performed on the data present in registry.
--*/
{
    BOOL                fSuccess = TRUE;
    DWORD               err = NO_ERROR;
    IMDCOM*             pMBCom;
    METADATA_HANDLE     hMB;
    HRESULT             hRes;
    METADATA_RECORD     mdRecord;
    DWORD               dwRequiredLen;
    BOOL                fMustRel;
    HKEY                hkeyReg = NULL;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );
    DWORD tmp;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        QueryRegParamKey(),
                        0,
                        KEY_ALL_ACCESS,
                        &hkeyReg );


    if ( hkeyReg == INVALID_HANDLE_VALUE ||
         hkeyReg == NULL) {

       //
       // Invalid Registry handle given
       //

       SetLastError( ERROR_INVALID_PARAMETER);
       return ( FALSE);
    }

    LockConfig();

    //
    //  Read metabase data.
    //

    if( !mb.Open( QueryMDPath() ) ) {

        RegCloseKey( hkeyReg );
        UnLockConfig();
        return FALSE;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_EXIT_MESSAGE ) ) {

        if( !mb.GetStr( "",
                        MD_EXIT_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_ExitMessage,
                        METADATA_INHERIT,
                        DEFAULT_EXIT_MESSAGE ) ) {

            fSuccess = FALSE;
            err = GetLastError();

        }

    }

    if( fSuccess && IsFieldSet( FieldsToRead, FC_FTP_GREETING_MESSAGE ) ) {

        if( !mb.GetMultisz( "",
                        MD_GREETING_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_GreetingMessage ) ) {

            if( !m_GreetingMessage.Copy(
                    DEFAULT_GREETING_MESSAGE,
                    CCH_DEFAULT_GREETING_MESSAGE
                    ) )  {

                fSuccess = FALSE;
                err = GetLastError();

            }

        }

        //
        // The m_pszGreetingMessage as read is a double null terminated
        // seq of strings (with one string per line)
        // A local copy of the string in the form suited for RPC Admin
        //   should be generated.
        //

        if( fSuccess ) {

            fSuccess = GenMessageWithLineFeed( m_GreetingMessage.QueryStr(),
                                               &m_pszGreetingMessageWithLineFeed);

            if( !fSuccess ) {
                err = GetLastError();
            }

        }

    }

    if( fSuccess && IsFieldSet( FieldsToRead, FC_FTP_BANNER_MESSAGE ) ) {

        if( !mb.GetMultisz( "",
                        MD_BANNER_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_BannerMessage ) ) {

            if( !m_BannerMessage.Copy(
                    DEFAULT_BANNER_MESSAGE,
                    CCH_DEFAULT_BANNER_MESSAGE
                    ) )  {

                fSuccess = FALSE;
                err = GetLastError();

            }

        }

        //
        // The m_pszBannerMessage as read is a double null terminated
        // seq of strings (with one string per line)
        // A local copy of the string in the form suited for RPC Admin
        //   should be generated.
        //

        if( fSuccess ) {

            fSuccess = GenMessageWithLineFeed( m_BannerMessage.QueryStr(),
                                               &m_pszBannerMessageWithLineFeed);

            if( !fSuccess ) {
                err = GetLastError();
            }

        }

    }

    if( fSuccess && IsFieldSet( FieldsToRead, FC_FTP_MAX_CLIENTS_MESSAGE ) ) {

        if( !mb.GetStr( "",
                        MD_MAX_CLIENTS_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_MaxClientsMessage,
                        METADATA_INHERIT,
                        DEFAULT_MAX_CLIENTS_MSG ) ) {

            fSuccess = FALSE;
            err = GetLastError();

        }

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_MSDOS_DIR_OUTPUT ) ) {

        if( !mb.GetDword( "",
                          MD_MSDOS_DIR_OUTPUT,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_MSDOS_DIR_OUTPUT;

        }

        m_fMsdosDirOutput = !!tmp;
        // clear and then set the MSDOS_DIR_OUTPUT in user flags
        m_dwUserFlags &= ~UF_MSDOS_DIR_OUTPUT;
        m_dwUserFlags |= (m_fMsdosDirOutput) ? UF_MSDOS_DIR_OUTPUT : 0;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_SHOW_4_DIGIT_YEAR) ) {

        if( !mb.GetDword( "",
                          MD_SHOW_4_DIGIT_YEAR,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_SHOW_4_DIGIT_YEAR;

        }

        m_fFourDigitYear = !!tmp;
        // clear and then set the 4_DIGIT_YEAR in user flags
        m_dwUserFlags &= ~UF_4_DIGIT_YEAR;
        m_dwUserFlags |= (m_fFourDigitYear) ? UF_4_DIGIT_YEAR : 0;
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ALLOW_ANONYMOUS ) ) {

        if( !mb.GetDword( "",
                          MD_ALLOW_ANONYMOUS,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_ALLOW_ANONYMOUS;

        }

        m_fAllowAnonymous = !!tmp;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ANONYMOUS_ONLY ) ) {

        if( !mb.GetDword( "",
                          MD_ANONYMOUS_ONLY,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_ANONYMOUS_ONLY;

        }

        m_fAnonymousOnly = !!tmp;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ALLOW_REPLACE_ON_RENAME ) ) {

        if( !mb.GetDword( "",
                          MD_ALLOW_REPLACE_ON_RENAME,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_ALLOW_REPLACE_ON_RENAME;

        }

        m_fAllowReplaceOnRename = !!tmp;

    }

    //
    //  Read registry data.
    //

    if( IsFieldSet( FieldsToRead, FC_FTP_LISTEN_BACKLOG ) )
    {
        m_ListenBacklog = ReadRegistryDword( hkeyReg,
                                            FTPD_LISTEN_BACKLOG,
                                            DEFAULT_LISTEN_BACKLOG );
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ALLOW_GUEST_ACCESS ) ) {

        m_fAllowGuestAccess = !!ReadRegistryDword( hkeyReg,
                                                  FTPD_ALLOW_GUEST_ACCESS,
                                                  DEFAULT_ALLOW_GUEST_ACCESS );
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ANNOTATE_DIRECTORIES ) ) {

        m_fAnnotateDirectories = !!ReadRegistryDword( hkeyReg,
                                                     FTPD_ANNOTATE_DIRS,
                                                     DEFAULT_ANNOTATE_DIRS );

        // clear and then set the ANNOTATE_DIRS in user flags
        m_dwUserFlags &= ~UF_ANNOTATE_DIRS;
        m_dwUserFlags |= (m_fAnnotateDirectories) ? UF_ANNOTATE_DIRS : 0;
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_LOWERCASE_FILES ) ) {

        m_fLowercaseFiles = !!ReadRegistryDword( hkeyReg,
                                                FTPD_LOWERCASE_FILES,
                                                DEFAULT_LOWERCASE_FILES );
    }

    // fEnablePortAttack is not controlled by RPC yet.
    m_fEnablePortAttack = !!ReadRegistryDword(hkeyReg,
                                              FTPD_ENABLE_PORT_ATTACK,
                                              DEFAULT_ENABLE_PORT_ATTACK);

    // fEnablePasvTheft is not controlled by RPC yet.
    m_fEnablePasvTheft = !!ReadRegistryDword(hkeyReg,
                                              FTPD_ENABLE_PASV_THEFT,
                                              DEFAULT_ENABLE_PASV_THEFT);

    if( fSuccess ) {

        //
        //  The following field is not supported in the admin API.
        //

        m_fEnableLicensing = !!ReadRegistryDword( hkeyReg,
                                                 FTPD_ENABLE_LICENSING,
                                                 DEFAULT_ENABLE_LICENSING );

    }

    if ( fSuccess )
    {
        m_rfAccessCheck.Reset( (IMDCOM*)m_Service->QueryMDObject() );

        pMBCom = (IMDCOM*)m_Service->QueryMDObject();
        hRes = pMBCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                            (BYTE *) QueryMDVRPath(),
                                            METADATA_PERMISSION_READ,
                                            5000,
                                            &hMB );
        if ( SUCCEEDED( hRes ) )
        {
            mdRecord.dwMDIdentifier  = MD_IP_SEC;
            mdRecord.dwMDAttributes  = METADATA_INHERIT | METADATA_REFERENCE;
            mdRecord.dwMDUserType    = IIS_MD_UT_FILE;
            mdRecord.dwMDDataType    = BINARY_METADATA;
            mdRecord.dwMDDataLen     = 0;
            mdRecord.pbMDData        = (PBYTE)NULL;

            hRes = pMBCom->ComMDGetMetaData( hMB,
                                             (LPBYTE)"",
                                             &mdRecord,
                                             &dwRequiredLen );
            if ( SUCCEEDED( hRes ) && mdRecord.dwMDDataTag )
            {
                m_rfAccessCheck.Set( mdRecord.pbMDData,
                                     mdRecord.dwMDDataLen,
                                     mdRecord.dwMDDataTag );
            }

            DBG_REQUIRE( SUCCEEDED(pMBCom->ComMDCloseMetaObject( hMB )) );
        }
        else
        if( HRESULTTOWIN32( hRes ) != ERROR_PATH_NOT_FOUND )
        {
            fSuccess = FALSE;
            err = HRESULTTOWIN32( hRes );
        }
    }

    UnLockConfig();

    IF_DEBUG( CONFIG) {
       Print();
    }

    m_fValid = TRUE;

    RegCloseKey( hkeyReg );
    return ( err);

} // FTP_SERVER_INSTANCE::InitFromRegistry()





static BOOL
RemoveInvalidsInPath( IN OUT TCHAR * pszPath)
/*++
  Eliminate path components consisting of '.' and '..'
     to prevent security from being overridden

    Arguments:

        pszPath pointer to string containing path

    Returns:
        TRUE on success and
        FALSE if there is any failure
--*/
{
    int idest;
    TCHAR * pszScan;

    //
    //  Check and eliminate the invalid path components
    //

    for( pszScan = pszPath; *pszScan != TEXT( '\0'); pszScan++) {

       if ( *pszScan == TEXT( '/')) {

          //
          // Check and kill invalid path components before next "\"
          //
          if ( *(pszScan + 1) == TEXT( '.')) {

            if ( *(pszScan +2) == TEXT('/')) {

               pszScan += 2;      // skip the /./ pattern

            } else
            if ( *(pszScan +2) == TEXT('.') &&
                 *(pszScan +3) == TEXT('/')) {

                //
                // We found the pattern  /../, elimiate it
                //
                pszScan += 3;
            }

            *pszPath++ = *pszScan;
            continue;

          } // found a single /.

       }

       *pszPath++ = *pszScan;

    } // for

    *pszPath = TEXT( '\0');

    return ( TRUE);

} // RemoveInvalidsInPath()





VOID
FTP_SERVER_INSTANCE::Print( VOID) const
/*++

    Description:

       Prints the configuration information for this server.
       To be used in debugging mode for verification.


    Returns:

       None.

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
               "FTP Server Configuration ( %08x).\n", this ));
#if 0
    READ_LOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    AnonymousUser = %s\n",
               g_pInetSvc->QueryAnonUserName() ));

    UNLOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n"
               "    %s = %d\n"
               "    %s = %u\n"
               "    %s = %u\n"
               "    %s = %u\n"
               "    %s = %u\n"
               "    %s = %u\n",
               FTPD_ALLOW_ANONYMOUS,
               m_fAllowAnonymous,
               FTPD_ALLOW_GUEST_ACCESS,
               m_fAllowGuestAccess,
               FTPD_ANONYMOUS_ONLY,
               m_fAnonymousOnly,
               FTPD_ENABLE_PORT_ATTACK,
               m_fEnablePortAttack,
               FTPD_ENABLE_PASV_THEFT,
               m_fEnablePasvTheft,
               "LogAnonymous",
               g_pInetSvc->QueryLogAnonymous(),
               "LogNonAnonymous",
               g_pInetSvc->QueryLogNonAnonymous()
               ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_ENABLE_LICENSING,
               m_fEnableLicensing  ));

    DBGPRINTF(( DBG_CONTEXT,
               "    MaxConnections = %lu\n",
               g_pInetSvc->QueryMaxConnections() ));

    DBGPRINTF(( DBG_CONTEXT,
               "    ConnectionTimeout = %lu\n",
               g_pInetSvc->QueryConnectionTimeout() ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_MSDOS_DIR_OUTPUT,
               m_fMsdosDirOutput ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_4_DIGIT_YEAR,
               m_f4DigitYear ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_ANNOTATE_DIRS,
               m_fAnnotateDirectories  ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %08lX\n",
               FTPD_DEBUG_FLAGS,
               GET_DEBUG_FLAGS()));

    READ_LOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    LogFileDirectory = %s\n",
               g_pInetSvc->QueryLogFileDirectory() ));

    UNLOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    LogFileAccess = %lu\n",
               g_pInetSvc->QueryLogFileType() ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %u\n",
               FTPD_LISTEN_BACKLOG,
               m_ListenBacklog ));

    DBGPRINTF(( DBG_CONTEXT,
               "    DefaultLogonDomain = %s\n",
               m_DefaultLogonDomain ));
#endif
    return;

} // FTP_SERVER_INSTANCE::Print()




PICLIENT_CONNECTION
FTP_SERVER_INSTANCE::AllocNewConnection()
/*++

  This function first checks that there is room for more connections
  as per the configured max connections.

  If there is no more connections allowed, it returns NULL
    with *pfMaxExceeded = TRUE

  Otherwise:
  This function creates a new CLIENT_CONNECTION (USER_DATA) object.
       The creation maybe fresh from heap or from cached free list.

  It increments the counter of currnet connections and returns
   the allocated object (if non NULL).


  We enter a critical section to avoid race condition
    among different threads. (this can be improved NYI).

  Returns:
      TRUE on success and
      FALSE if there is max Connections exceeded.
--*/
{
    PICLIENT_CONNECTION pConn = NULL;

    LockConnectionsList();

    //
    // We can add this new connection
    //

    pConn = AllocClientConnFromAllocCache();

    if ( pConn != NULL) {

        //
        //  Increment the count of connected users
        //
        m_cCurrentConnections++;

        IF_DEBUG( CLIENT) {
            DBGPRINTF((DBG_CONTEXT, " CurrentConnections = %u\n",
                   m_cCurrentConnections));
        }

        //
        // Update the current maximum connections
        //

        if ( m_cCurrentConnections > m_cMaxCurrentConnections) {

            m_cMaxCurrentConnections = m_cCurrentConnections;
        }

        //
        // Insert into the list of connected users.
        //

        InsertTailList( &m_ActiveConnectionsList, &pConn->QueryListEntry());
    }

   UnlockConnectionsList();

   return ( pConn);

} // FTP_SERVER_INSTANCE::AllocNewConnection()



VOID
FTP_SERVER_INSTANCE::RemoveConnection(
            IN OUT PICLIENT_CONNECTION  pcc
            )
/*++

--*/
{

    LockConnectionsList();

    //
    // Remove from list of connections
    //
    RemoveEntryList( &pcc->QueryListEntry());

    //
    // Decrement count of current users
    //
    m_cCurrentConnections--;

    IF_DEBUG( CLIENT) {
        DBGPRINTF((DBG_CONTEXT, " CurrentConnections = %u\n",
                   m_cCurrentConnections));
    }

    //
    // move the free connection to free list
    //

    FreeClientConnToAllocCache( pcc);

    UnlockConnectionsList();

} // FTP_SERVER_INSTANCE::RemoveConnection()





VOID
FTP_SERVER_INSTANCE::DisconnectAllConnections( VOID)
/*++

   Disconnects all user connections.

   Arguments:

     Instance - If NULL, then all users are disconnected. If !NULL, then
         only those users associated with the specified instance are
         disconnected.

--*/
{
#ifdef CHECK_DBG
    CHAR rgchBuffer[90];
#endif // CHECK_DBG

    DWORD        dwLastTick = GetTickCount();
    DWORD        dwCurrentTick;
    PLIST_ENTRY  pEntry;
    PLIST_ENTRY  pEntryNext;

    DBGPRINTF( ( DBG_CONTEXT,
                "Entering  FTP_SERVER_INSTANCE::DisconnectAllConnections()\n"));


    //
    // Let's empty the connection list immediately while in the lock to avoid a
    // shutdown deadlock
    //

    LockConnectionsList();

    pEntry = m_ActiveConnectionsList.Flink;

    InitializeListHead( &m_ActiveConnectionsList);

    UnlockConnectionsList();

    //
    //  close down all the active sockets.
    //
    for( pEntryNext = pEntry->Flink;
         pEntry != &m_ActiveConnectionsList;
         pEntry = pEntryNext) {

        PICLIENT_CONNECTION  pConn =
          GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        pEntryNext = pEntry->Flink; // cache next entry since pConn may die

        ASSERT( pConn != NULL);

# ifdef CHECK_DBG
        wsprintfA( rgchBuffer, "Kill UID=%u. Ref=%u\n",
                  pConn->QueryId(), pConn->QueryReference());

        OutputDebugString( rgchBuffer);
# endif // CHECK_DBG

        dwCurrentTick = GetTickCount();

        if ( (dwCurrentTick - dwLastTick) >= ( SC_NOTIFY_INTERVAL)) {

            //
            // We seem to take longer time for cleaning up than
            //  expected. Let us ask service controller to wait for us.
            //

            g_pInetSvc->
              DelayCurrentServiceCtrlOperation(SC_NOTIFY_INTERVAL * 2);

            dwLastTick = dwCurrentTick;
        }

        pConn->Reference();
        pConn->DisconnectUserWithError( ERROR_SERVER_DISABLED, TRUE);
        DBG_REQUIRE( pConn->DeReference() > 0 );   // remove ref added above
        if( pConn->RemoveActiveReference() ) {

            //
            // This connection is due for deletion. Kill it.
            //
            // Remove from list of connections
            //

            pConn->Cleanup();
            RemoveEntryList( &pConn->QueryListEntry());

            //
            // Decrement count of current users
            //
            m_cCurrentConnections--;

            // move the connection to free list
            FreeClientConnToAllocCache( pConn);
        }
    } // for

    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    //

    //
    //  Wait for the users to die.
    //

    for( int i = 0 ;
        ( i < CLEANUP_RETRY_COUNT ) && ( m_cCurrentConnections > 0);
        i++ )
    {

        DBGPRINTF(( DBG_CONTEXT, "Sleep Iteration %d; Time=%u millisecs."
                   " CurrentConn=%d.\n",
                   i,  CLEANUP_POLL_INTERVAL, m_cCurrentConnections));

        g_pInetSvc->
          DelayCurrentServiceCtrlOperation( CLEANUP_POLL_INTERVAL * 2);
        Sleep( CLEANUP_POLL_INTERVAL );
    }

    return;

} // FTP_SERVER_INSTANCE::DisconnectAllConnections()



BOOL
FTP_SERVER_INSTANCE::EnumerateConnection(
   IN PFN_CLIENT_CONNECTION_ENUM  pfnConnEnum,
   IN LPVOID  pContext,
   IN DWORD   dwConnectionId)
/*++
  This function iterates through all the connections in the current connected
   users list and enumerates each of them. If the connectionId matches then
   given callback function is called. If the ConnectionId is 0, then the
   callback is called for each and every connection active currently.

  During such a call the reference count of the connection is bumped up.
  Call this function after obtaining the ConnectionsList Lock.

  Arguments:
     pfnConnEnum      pointer to function to be called when a match is found.
     pContext         pointer to context information to be passed in
                       for callback
     dwConnectionId   DWORD containing the Connection Id. IF 0 match all the
                        connections.

  Returns:
    FALSE if no match is found
    TRUE if atleast one match is found.
--*/
{
    BOOL fReturn = FALSE;
    BOOL fFoundOne  = FALSE;
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pEntryNext;

    DBG_ASSERT( pfnConnEnum != NULL);

    //
    //  Loop through the list of connections and call the callback
    //  for each connection  that matches condition
    //

    for ( pEntry  = m_ActiveConnectionsList.Flink,
              pEntryNext = &m_ActiveConnectionsList;
          pEntry != &m_ActiveConnectionsList;
          pEntry  = pEntryNext
         ) {

        PICLIENT_CONNECTION pConn =
          GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        pEntryNext = pEntry->Flink; // cache next entry since pConn may die

        if ( dwConnectionId == 0 || dwConnectionId == pConn->QueryId()) {

            pConn->Reference();

            fReturn = ( pfnConnEnum)( pConn, pContext);

            if ( !pConn->DeReference()) {

                // Blowaway the connection and update the count of entries.
                //
                // Remove from list of connections
                //

                pConn->Cleanup();
                RemoveEntryList( &pConn->QueryListEntry());

                //
                // Decrement count of current users
                //
                m_cCurrentConnections--;

                IF_DEBUG( CLIENT) {
                    DBGPRINTF((DBG_CONTEXT, " CurrentConnections = %u\n",
                               m_cCurrentConnections));
                }
            }

            if (!fReturn) {

                break;
            }

            fFoundOne = TRUE;
        }
    } // for

    //
    //  If we didn't find any, assume that there was no match.
    //

    if ( !fFoundOne ) {

        SetLastError( ERROR_NO_MORE_ITEMS );
        fReturn = FALSE;
    }

    return ( fReturn);
} // FTP_SERVER_INSTANCE::EnumerateConnection()




DWORD
FTP_SERVER_INSTANCE::GetConfigInformation(OUT LPFTP_CONFIG_INFO pConfig)
/*++
  This function copies the ftp server configuration into the given
   structure (pointed to).

  Arguments:
    pConfig -- pointer to FTP_CONFIG_INFO which on success will contain
                 the ftp server configuration

  Returns:
    Win32 error code. NO_ERROR on success.
--*/
{
    DWORD dwError = NO_ERROR;

    memset( pConfig, 0, sizeof(*pConfig) );

    pConfig->FieldControl = FC_FTP_ALL;

    //
    // mask out the properties that are not supported in FTP 5.1
    //

    pConfig->FieldControl &= ~FC_FTP_LOG_IN_UTF_8 & ~FC_FTP_USER_ISOLATION;


    LockConfig();

    pConfig->fAllowAnonymous            = m_fAllowAnonymous;
    pConfig->fAllowGuestAccess          = m_fAllowGuestAccess;
    pConfig->fAnnotateDirectories       = m_fAnnotateDirectories;
    pConfig->fAnonymousOnly             = m_fAnonymousOnly;
    pConfig->dwListenBacklog            = m_ListenBacklog;
    pConfig->fLowercaseFiles            = m_fLowercaseFiles;
    pConfig->fMsdosDirOutput            = m_fMsdosDirOutput;

    if( !ConvertStringToRpc( &pConfig->lpszExitMessage,
                             QueryExitMsg() ) ||
        !ConvertStringToRpc( &pConfig->lpszGreetingMessage,
                             m_pszGreetingMessageWithLineFeed ) ||
        !ConvertStringToRpc( &pConfig->lpszBannerMessage,
                             m_pszBannerMessageWithLineFeed ) ||
        !ConvertStringToRpc( &pConfig->lpszMaxClientsMessage,
                             QueryMaxClientsMsg() ) )
    {
        dwError = GetLastError();
    }

    UnLockConfig();

    if ( dwError == NO_ERROR) {

        pConfig->lpszHomeDirectory  = NULL;  // use query virtual roots.
    }

    if ( dwError != NO_ERROR) {

        FreeRpcString( pConfig->lpszExitMessage );
        FreeRpcString( pConfig->lpszGreetingMessage );
        FreeRpcString( pConfig->lpszBannerMessage );
        FreeRpcString( pConfig->lpszHomeDirectory );
        FreeRpcString( pConfig->lpszMaxClientsMessage );
    }

    return (dwError);

} // FTP_SERVER_INSTANCE::GetConfigurationInformation()





// Private Functions ...


BOOL
FTP_SERVER_INSTANCE::FreeAllocCachedClientConn( VOID)
/*++
  This function frees all the alloc cached client connections
  It walks through the list of alloc cached entries and frees them.

  This function should be called when Server module is terminated and when
   no other thread can interfere in processing a shared object.

  Arguments:
    NONE

  Returns:
    TRUE on success and FALSE on failure.

--*/
{
    register PLIST_ENTRY  pEntry;
    register PLIST_ENTRY  pEntryNext;
    register PICLIENT_CONNECTION pConn;

    for( pEntry = m_FreeConnectionsList.Flink;
         pEntry != &m_FreeConnectionsList; ) {


        PICLIENT_CONNECTION  pConn =
          GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        pEntryNext = pEntry->Flink; // cache next entry since pConn may die

        DBG_ASSERT( pConn->QueryReference() == 0);

        RemoveEntryList( pEntry );        // Remove this context from list

        // delete the object itself
        delete pConn;

        pEntry = pEntryNext;

    } // for

    return (TRUE);

} // USER_DATA::FreeAllocCachedClientConn()



PICLIENT_CONNECTION
FTP_SERVER_INSTANCE::AllocClientConnFromAllocCache(
                        VOID
                        )
/*++
  This function attempts to allocate a client connection object from
  the allocation cache, using the free list of connections available.

  If none is available, then a new object is allocated using new ()
   and returned to the caller.
  Eventually the object will enter free list and will be available
   for free use.

  Arguments:
     None

  Returns:
    On success a valid pointer to client connection object.

  Issues:
     This function should be called while holding the ConnectionsLock.
--*/
{
    PLIST_ENTRY pEntry  = m_FreeConnectionsList.Flink;
    PICLIENT_CONNECTION pConn;

    if ( pEntry != &m_FreeConnectionsList) {

        pConn = GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        DBG_ASSERT( pConn != NULL);
        RemoveEntryList( pEntry);  // remove entry from free list

        DBG_ASSERT( pConn->QueryInstance() == NULL );
        pConn->SetInstance( this );

    } else {

        //
        // create a new object, since allocation cache is empty
        //

        pConn = new USER_DATA( this );
    }

    return (pConn);

} // FTP_SERVER_INSTANCE::AllocClientConnFromAllocCache()



VOID
FTP_SERVER_INSTANCE::FreeClientConnToAllocCache(
                        IN PICLIENT_CONNECTION pClient
                        )
/*++
  This function releases the given Client connection to the allocation cache.
  It adds the given object to allocation cache.

  Arguments:
    pClient  pointer to client connection object which needs to be freed.

  Returns:
    None

  Issues:
    This function should be called after holding the ConnectionsList
     critical section.

    Should we limit the number of items that can be on free list and
      to release the remaining to global pool?  NYI (depends on # CPUs)
--*/
{
    PLIST_ENTRY pEntry = &pClient->QueryListEntry();

    //
    // empty out instance pointer
    //

    pClient->QueryInstance()->DecrementCurrentConnections();
    pClient->QueryInstance()->Dereference( );
    pClient->SetInstance( NULL );

    InsertHeadList( &m_FreeConnectionsList, pEntry);
    return;

} // FTP_SERVER_INSTANCE::FreeClientConnToAllocCache()





/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.

********************************************************************/

APIERR
GetDefaultDomainName(
    STR * pstrDomainName
    )
{

    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    APIERR                      err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "cannot open lsa policy, error %08lX\n",
                    NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Query the domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&DomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "cannot query lsa policy info, error %08lX\n",
                    NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Compute the required length of the ANSI name.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // dwFlags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  NULL,                 // lpMultiByteStr
                                  0,                    // cchMultiByte
                                  NULL,                 // lpDefaultChar
                                  NULL                  // lpUsedDefaultChar
                                  );

    if( Result <= 0 )
    {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Resize the output string as appropriate, including room for the
    //  terminating '\0'.
    //

    if( !pstrDomainName->Resize( (UINT)Result + 1 ) )
    {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Convert the name from UNICODE to ANSI.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // flags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  pstrDomainName->QueryStr(),
                                  pstrDomainName->QuerySize() - 1,  // for '\0'
                                  NULL,
                                  NULL
                                  );

    if( Result <= 0 )
    {
        err = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
                    "cannot convert domain name to ANSI, error %d\n",
                    err ));

        goto Cleanup;
    }

    //
    //  Ensure the ANSI string is zero terminated.
    //

    DBG_ASSERT( (DWORD)Result < pstrDomainName->QuerySize() );

    pstrDomainName->QueryStr()[Result] = '\0';

    //
    //  Success!
    //

    DBG_ASSERT( err == 0 );

    IF_DEBUG( CONFIG )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetDefaultDomainName: default domain = %s\n",
                    pstrDomainName->QueryStr() ));
    }

Cleanup:

    if( DomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)DomainInfo );
    }

    if( LsaPolicyHandle != NULL )
    {
        LsaClose( LsaPolicyHandle );
    }

    return err;

}   // GetDefaultDomainName()



BOOL
GenMessageWithLineFeed(IN LPTSTR pszzMessage,
                       IN LPTSTR * ppszMessageWithLineFeed)
{
    DWORD   cchLen = 0;
    DWORD   cchLen2;
    DWORD   nLines = 0;
    LPCTSTR  pszNext = pszzMessage;
    LPTSTR   pszDst = NULL;

    DBG_ASSERT( ppszMessageWithLineFeed != NULL);

    //
    // 1. Find the length of the the complete message
    //

    for ( cchLen = _tcslen( pszzMessage), nLines = 0;
          *(pszzMessage + cchLen + 1) != TEXT('\0');
          cchLen +=  1+_tcslen( pszzMessage + cchLen + 1), nLines++
         )
      ;

    //
    // 2. Allocate sufficient space to hold the data
    //

    if ( *ppszMessageWithLineFeed != NULL) {

        TCP_FREE( *ppszMessageWithLineFeed);
    }


    *ppszMessageWithLineFeed = (TCHAR *) TCP_ALLOC((cchLen + nLines + 3)
                                         * sizeof(TCHAR));


    if ( *ppszMessageWithLineFeed == NULL) {


        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (FALSE);
    }

    //
    // 3.
    // Copy the message from double null terminated string to the
    //  new string, taking care to replace the nulls with \n for linefeed
    //

    pszDst = * ppszMessageWithLineFeed;
    _tcscpy( pszDst, pszzMessage);
    cchLen2 = _tcslen( pszzMessage) + 1;
    *(pszDst+cchLen2 - 1) = TEXT('\n');  // replacing the '\0' with '\n'

    for( pszNext = pszzMessage + cchLen2;
         *pszNext != '\0';
        pszNext = pszzMessage + cchLen2
        ) {

        _tcscpy( pszDst + cchLen2, pszNext);
        cchLen2 += _tcslen(pszNext) + 1;
        *(pszDst + cchLen2 - 1) = TCHAR('\n'); // replacing the '\0' with '\n'

    } // for

    //
    // Reset the last line feed.
    //
    *(pszDst + cchLen2 - 1) = TCHAR('\0');

    // if following assertion is not true, we are writing into heap!!!
    if ( cchLen + nLines + 3 <= cchLen2) {

        return ( FALSE);
    }

    DBG_ASSERT( cchLen + nLines + 3 >= cchLen2);

    return ( TRUE);
} // GenMessageWithLineFeed()




TCHAR *
FtpdReadRegistryString(IN HKEY     hkey,
                       IN LPCTSTR  pszValueName,
                       IN LPCTSTR  pchDefaultValue,
                       IN DWORD    cbDefaultValue)
/*++
  This function reads a string (REG_SZ/REG_MULTI_SZ/REG_EXPAND_SZ) without
   expanding the same. It allocates memory for reading the data from registry.

  Arguments:
    hkey    handle for the registry key.
    pszValueName   pointer to string containing the name of value to be read.
    pchDefaultValue pointer to default value to be used for reading the string
                   this may be double null terminated sequence of string for
                    REG_MULTI_SZ strings
    cchDefaultValue  count of characters in default value string,
                     including double null characters.

  Return:
    pointer to newly allocated string containing the data read from registry
      or the default string.

--*/
{
    TCHAR   * pszBuffer1 = NULL;
    DWORD     err;


    if( hkey == NULL ) {

        //
        //  Pretend the key wasn't found.
        //

        err = ERROR_FILE_NOT_FOUND;

    } else {

        DWORD     cbBuffer = 0;
        DWORD     dwType;

        //
        //  Determine the buffer size.
        //

        err = RegQueryValueEx( hkey,
                              pszValueName,
                              NULL,
                              &dwType,
                              NULL,
                              &cbBuffer );

        if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) ) {

            if(( dwType != REG_SZ ) &&
               ( dwType != REG_MULTI_SZ ) &&
               ( dwType != REG_EXPAND_SZ )
               ) {

                //
                //  Type mismatch, registry data NOT a string.
                //  Use default.
                //

                err = ERROR_FILE_NOT_FOUND;

            } else {

                //
                //  Item found, allocate a buffer.
                //

                pszBuffer1 = (TCHAR *) TCP_ALLOC( cbBuffer+sizeof(TCHAR) );

                if( pszBuffer1 == NULL ) {

                    err = GetLastError();
                } else {

                    //
                    //  Now read the value into the buffer.
                    //

                    err = RegQueryValueEx( hkey,
                                           pszValueName,
                                           NULL,
                                           NULL,
                                           (LPBYTE)pszBuffer1,
                                           &cbBuffer );
                }
            }
        }
    }

    if( err == ERROR_FILE_NOT_FOUND ) {

        //
        //  Item not found, use default value.
        //

        err = NO_ERROR;

        if( pchDefaultValue != NULL ) {

            if ( pszBuffer1 != NULL) {

                TCP_FREE( pszBuffer1);
            }

            pszBuffer1 = (TCHAR *)TCP_ALLOC((cbDefaultValue) *
                                            sizeof(TCHAR));

            if( pszBuffer1 == NULL ) {

                err = GetLastError();
            } else {

                memcpy(pszBuffer1, pchDefaultValue,
                       cbDefaultValue*sizeof(TCHAR) );
            }
        }
    }

    if( err != NO_ERROR ) {

        //
        //  Something tragic happend; free any allocated buffers
        //  and return NULL to the caller, indicating failure.
        //

        if( pszBuffer1 != NULL ) {

            TCP_FREE( pszBuffer1 );
            pszBuffer1 = NULL;
          }

        SetLastError( err);
    }


    return pszBuffer1;

} // FtpdReadRegistryString()




BOOL
FtpdReadRegString(
    IN HKEY     hkey,
    OUT TCHAR * * ppchstr,
    IN LPCTSTR  pchValue,
    IN LPCTSTR  pchDefault,
    IN DWORD    cchDefault
    )
/*++

   Description

     Gets the specified string from the registry.  If *ppchstr is not NULL,
     then the value is freed.  If the registry call fails, *ppchstr is
     restored to its previous value.

   Arguments:

      hkey - Handle to open key
      ppchstr - Receives pointer of allocated memory of the new value of the
        string
      pchValue - Which registry value to retrieve
      pchDefault - Default string if value isn't found
      cchDefault - count of characters in default value

   Note:

--*/
{
    CHAR * pch = *ppchstr;

    *ppchstr = FtpdReadRegistryString(hkey,
                                      pchValue,
                                      pchDefault,
                                      cchDefault);

    if ( !*ppchstr )
    {
        *ppchstr = pch;
        return FALSE;
    }

    if ( pch ) {

        //
        // use TCP_FREE since FtpdReadRegistryString() uses TCP_ALLOC
        //  to allocate the chunk of memory
        //

        TCP_FREE( pch );
    }

    return TRUE;

} // FtpdReadRegString()


BOOL
FTP_IIS_SERVICE::AddInstanceInfo(
    IN DWORD dwInstance,
    IN BOOL fMigrateRoots
    )
{
    PFTP_SERVER_INSTANCE pInstance;
    CHAR                 szHost[MAXGETHOSTSTRUCT];

    IF_DEBUG(SERVICE_CTRL) {
        DBGPRINTF(( DBG_CONTEXT,
            "AddInstanceInfo: instance %d reg %s\n", dwInstance, QueryRegParamKey() ));
    }

    // Guard against startup race where another thread might be adding
    // instances before the MSFTPSVC thread is finished with initializing
    // the g_pInetSvc pointer.

    if ( g_pInetSvc == NULL )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    //
    // Get the current host name.
    //

    if( gethostname( szHost, sizeof(szHost) ) < 0 ) {

        return FALSE;

    }

    //
    // Create the new instance
    //

    pInstance = new FTP_SERVER_INSTANCE(
                                this,
                                dwInstance,
                                IPPORT_FTP,
                                QueryRegParamKey(),
                                FTPD_ANONYMOUS_SECRET_W,
                                FTPD_ROOT_SECRET_W,
                                fMigrateRoots
                                );

    if (pInstance == NULL) {
        SetLastError( E_OUTOFMEMORY );
        return FALSE;
    }

    if( !AddInstanceInfoHelper( pInstance ) ) {
        return FALSE;
    }

    if( pInstance->SetLocalHostName( szHost ) != NO_ERROR ) {
        RemoveServerInstance( pInstance );
        return FALSE;
    }

    return TRUE;

}   // FTP_IIS_SERVICE::AddInstanceInfo

DWORD
FTP_IIS_SERVICE::DisconnectUsersByInstance(
    IN IIS_SERVER_INSTANCE * pInstance
    )
/*++

    Virtual callback invoked by IIS_SERVER_INSTANCE::StopInstance() to
    disconnect all users associated with the given instance.

    Arguments:

        pInstance - All users associated with this instance will be
            forcibly disconnected.

--*/
{

    ((FTP_SERVER_INSTANCE *)pInstance)->DisconnectAllConnections();
    return NO_ERROR;

}   // FTP_IIS_SERVICE::DisconnectUsersByInstance

VOID
FTP_SERVER_INSTANCE::MDChangeNotify(
    MD_CHANGE_OBJECT * pco
    )
/*++

    Handles metabase change notifications.

    Arguments:

        pco - Path and ID that changed.

--*/
{

    FIELD_CONTROL control = 0;
    DWORD i;
    DWORD err;
    DWORD id;
    PCSTR pszURL;
    DWORD dwURLLength;

    //
    // Let the parent deal with it.
    //

    IIS_SERVER_INSTANCE::MDChangeNotify( pco );

    //
    // Now flush the metacache and relevant file handle cache entries.
    //

    TsFlushMetaCache(METACACHE_FTP_SERVER_ID, FALSE);

    if ( !_mbsnbicmp((PUCHAR)pco->pszMDPath, (PUCHAR)QueryMDVRPath(),
                     _mbslen( (PUCHAR)QueryMDVRPath() )) )
    {
        pszURL = (CHAR *)pco->pszMDPath + QueryMDVRPathLen() - 1;

        //
        // Figure out the length of the URL. Unless this is the root,
        // we want to strip the trailing slash.

        if (memcmp(pszURL, "/", sizeof("/")) != 0)
        {
            dwURLLength = strlen(pszURL) - 1;
        }
        else
        {
            dwURLLength = sizeof("/") - 1;
        }

    }
    else
    {
        //
        // Presumably this is for a change above the root URL level, i.e. a
        // change of a property at the service level. Since this affects
        // everything, flush starting at the root.
        //

        pszURL = "/";
        dwURLLength = sizeof("/") - 1;
    }

    DBG_ASSERT(pszURL != NULL);
    DBG_ASSERT(*pszURL != '\0');

    TsFlushURL(GetTsvcCache(), pszURL, dwURLLength, RESERVED_DEMUX_URI_INFO);

    //
    // Interpret the changes.
    //

    for( i = 0 ; i < pco->dwMDNumDataIDs ; i++ ) {

        id = pco->pdwMDDataIDs[i];

        switch( id ) {

        case MD_EXIT_MESSAGE :
            control |= FC_FTP_EXIT_MESSAGE;
            break;

        case MD_GREETING_MESSAGE :
            control |= FC_FTP_GREETING_MESSAGE;
            break;

        case MD_BANNER_MESSAGE :
            control |= FC_FTP_BANNER_MESSAGE;
            break;

        case MD_MAX_CLIENTS_MESSAGE :
            control |= FC_FTP_MAX_CLIENTS_MESSAGE;
            break;

        case MD_MSDOS_DIR_OUTPUT :
            control |= FC_FTP_MSDOS_DIR_OUTPUT;
            break;

        case MD_ALLOW_ANONYMOUS :
            control |= FC_FTP_ALLOW_ANONYMOUS;
            break;

        case MD_ANONYMOUS_ONLY :
            control |= FC_FTP_ANONYMOUS_ONLY;
            break;

        case MD_ALLOW_REPLACE_ON_RENAME :
            control |= FC_FTP_ALLOW_REPLACE_ON_RENAME;
            break;

        case MD_SHOW_4_DIGIT_YEAR :
            control |= FC_FTP_SHOW_4_DIGIT_YEAR;
            break;

        case MD_ANONYMOUS_USER_NAME :
        case MD_ANONYMOUS_PWD :
        case MD_ANONYMOUS_USE_SUBAUTH :
        case MD_DEFAULT_LOGON_DOMAIN :
        case MD_LOGON_METHOD :
            err = ReadAuthentInfo( FALSE, id );

            if( err != NO_ERROR ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "FTP_SERVER_INSTANCE::MDChangeNotify() cannot read authentication info, error %d\n",
                    err
                    ));

            }
            break;

        }

    }

    if( control != 0 ) {

        err = InitFromRegistry( control );

        if( err != NO_ERROR ) {

            DBGPRINTF((
                DBG_CONTEXT,
                "FTP_SERVER_INSTANCE::MDChangeNotify() cannot read config, error %lx\n",
                err
                ));

        }

    }

}   // FTP_SERVER_INSTANCE::MDChangeNotify


DWORD
FTP_SERVER_INSTANCE::ReadAuthentInfo(
    IN BOOL ReadAll,
    IN DWORD SingleItemToRead
    )
/*++

    Reads per-instance authentication info from the metabase.

    Arguments:

        ReadAll - If TRUE, then all authentication related items are
            read from the metabase. If FALSE, then only a single item
            is read.

        SingleItemToRead - The single authentication item to read if
            ReadAll is FALSE. Ignored if ReadAll is TRUE.

    Returns:

        DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD tmp;
    DWORD err = NO_ERROR;
    BOOL rebuildAcctDesc = FALSE;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    //
    // Lock our configuration (since we'll presumably be making changes)
    // and open the metabase.
    //

    LockConfig();

    if( !mb.Open( QueryMDPath() ) ) {

        err = GetLastError();

        DBGPRINTF((
            DBG_CONTEXT,
            "ReadAuthentInfo: cannot open metabase, error %lx\n",
            err
            ));

    }

    //
    // Read the anonymous username if necessary. Note this is a REQUIRED
    // property. If it is missing from the metabase, bail.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_USER_NAME ) ) {

        if( mb.GetStr(
                "",
                MD_ANONYMOUS_USER_NAME,
                IIS_MD_UT_SERVER,
                &m_TcpAuthentInfo.strAnonUserName
                ) ) {

            rebuildAcctDesc = TRUE;

        } else {

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: cannot read MD_ANONYMOUS_USER_NAME, error %lx\n",
                err
                ));

        }

    }

    //
    // Read the "use subauthenticator" flag if necessary. This is an
    // optional property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_USE_SUBAUTH ) ) {

        if( !mb.GetDword(
                "",
                MD_ANONYMOUS_USE_SUBAUTH,
                IIS_MD_UT_SERVER,
                &tmp
                ) ) {

            tmp = DEFAULT_USE_SUBAUTH;

        }

        m_TcpAuthentInfo.fDontUseAnonSubAuth = !tmp;

    }

    //
    // Read the anonymous password if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_PWD ) ) {

        if( mb.GetStr(
                "",
                MD_ANONYMOUS_PWD,
                IIS_MD_UT_SERVER,
                &m_TcpAuthentInfo.strAnonUserPassword,
                METADATA_INHERIT,
                DEFAULT_ANONYMOUS_PWD
                ) ) {

            rebuildAcctDesc = TRUE;

        } else {

            //
            // Since we provided a default value to mb.GetStr(), it should
            // only fail if something catastrophic occurred, such as an
            // out of memory condition.
            //

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: cannot read MD_ANONYMOUS_PWD, error %lx\n",
                err
                ));

        }

    }

    //
    // Read the default logon domain if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_DEFAULT_LOGON_DOMAIN ) ) {

        if( !mb.GetStr(
                "",
                MD_DEFAULT_LOGON_DOMAIN,
                IIS_MD_UT_SERVER,
                &m_TcpAuthentInfo.strDefaultLogonDomain
                ) ) {

            //
            // Generate a default domain name.
            //

            err = GetDefaultDomainName( &m_TcpAuthentInfo.strDefaultLogonDomain );

            if( err != NO_ERROR ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "ReadAuthentInfo: cannot get default domain name, error %d\n",
                    err
                    ));

            }

        }

    }

    //
    // Read the logon method if necessary. This is an optional property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_LOGON_METHOD ) ) {

        if( !mb.GetDword(
                "",
                MD_LOGON_METHOD,
                IIS_MD_UT_SERVER,
                &tmp
                ) ) {

            tmp = DEFAULT_LOGON_METHOD;

        }

        m_TcpAuthentInfo.dwLogonMethod = tmp;

    }

    //
    // If anything changed that could affect the anonymous account
    // descriptor, then rebuild the descriptor.
    //

    if( err == NO_ERROR && rebuildAcctDesc ) {

        if( !BuildAnonymousAcctDesc( &m_TcpAuthentInfo ) ) {

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: BuildAnonymousAcctDesc() failed\n"
                ));

            err = ERROR_NOT_ENOUGH_MEMORY;  // SWAG

        }

    }

    UnLockConfig();
    return err;

}   // FTP_SERVER_INSTANCE::ReadAuthentInfo


BOOL
FTP_IIS_SERVICE::GetGlobalStatistics(
    IN DWORD dwLevel,
    OUT PCHAR *pBuffer
    )
{
    APIERR err = NO_ERROR;


    switch( dwLevel ) {
        case 0 : {

            LPFTP_STATISTICS_0 pstats0;

            pstats0 = (LPFTP_STATISTICS_0)
                       MIDL_user_allocate(sizeof(FTP_STATISTICS_0));

            if( pstats0 == NULL ) {

                err = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                ATQ_STATISTICS      atqStat;

                ZeroMemory( pstats0, sizeof( FTP_STATISTICS_0 ) );

                g_pFTPStats->CopyToStatsBuffer( pstats0 );

                *pBuffer = (PCHAR)pstats0;
            }

        }

        break;

     default :
        err = ERROR_INVALID_LEVEL;
        break;
    }



    SetLastError(err);
    return(err == NO_ERROR);
}   // FTP_IIS_SERVICE::GetGlobalStatistics



BOOL
FTP_IIS_SERVICE::AggregateStatistics(
        IN PCHAR    pDestination,
        IN PCHAR    pSource
        )
{
    LPFTP_STATISTICS_0   pStatDest = (LPFTP_STATISTICS_0) pDestination;
    LPFTP_STATISTICS_0   pStatSrc  = (LPFTP_STATISTICS_0) pSource;

    if ((NULL == pDestination) || (NULL == pSource))
    {
        return FALSE;
    }

    pStatDest->TotalBytesSent.QuadPart      += pStatSrc->TotalBytesSent.QuadPart;
    pStatDest->TotalBytesReceived.QuadPart  += pStatSrc->TotalBytesReceived.QuadPart;

    pStatDest->TotalFilesSent               += pStatSrc->TotalFilesSent;
    pStatDest->TotalFilesReceived           += pStatSrc->TotalFilesReceived;
    pStatDest->CurrentAnonymousUsers        += pStatSrc->CurrentAnonymousUsers;
    pStatDest->CurrentNonAnonymousUsers     += pStatSrc->CurrentNonAnonymousUsers;
    pStatDest->TotalAnonymousUsers          += pStatSrc->TotalAnonymousUsers;
    pStatDest->MaxAnonymousUsers            += pStatSrc->MaxAnonymousUsers;
    pStatDest->MaxNonAnonymousUsers         += pStatSrc->MaxNonAnonymousUsers;

    pStatDest->CurrentConnections           += pStatSrc->CurrentConnections;
    pStatDest->MaxConnections               += pStatSrc->MaxConnections;
    pStatDest->ConnectionAttempts           += pStatSrc->ConnectionAttempts;
    pStatDest->LogonAttempts                += pStatSrc->LogonAttempts;
    pStatDest->ServiceUptime                = pStatSrc->ServiceUptime;


    // bandwidth throttling info. Not relevant for FTP

    /*
    pStatDest->CurrentBlockedRequests       += pStatSrc->CurrentBlockedRequests;
    pStatDest->TotalBlockedRequests         += pStatSrc->TotalBlockedRequests;
    pStatDest->TotalAllowedRequests         += pStatSrc->TotalAllowedRequests;
    pStatDest->TotalRejectedRequests        += pStatSrc->TotalRejectedRequests;
    pStatDest->MeasuredBandwidth            += pStatSrc->MeasuredBandwidth;
    */

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\ftpcmd.cxx ===
/*++


   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      ftpcmd.cxx

   Abstract:

      This module defines the FTP commands supported by this FTP server
        and provides a table of functions to be called for processing
        such command requests.
      ( Some parts of the code are from old engine.cxx ( KeithMo's FTP server))

   Author:

       Murali R. Krishnan    ( MuraliK )     28-Mar-1995

   Environment:

       User Mode -- Win32

   Project:

       FTP Server DLL

   Functions Exported:

       ParseCommand
       ()

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <ftpdp.hxx>
# include "ftpcmd.hxx"
# include "lsaux.hxx"
# include "auxctrs.h"

#define MAX_COMMAND_NAME_LEN    ( 30)
# define MAX_HELP_LINE_SIZE     ( 80)
# define MAX_HELP_AUX_SIZE      (100) // fixed sized aux info with HELP
# define HelpMsgSize( nCommands)   ((1 + nCommands) * MAX_HELP_LINE_SIZE + \
                                    MAX_HELP_AUX_SIZE)

#define IS_7BIT_ASCII(c)   ((UINT)(c) <= 127)


/************************************************************
 *    Static Data containing command lookups
 ************************************************************/



# define UsP           ( UserStateWaitingForPass)
# define UsUP          ( UserStateWaitingForUser | UsP)
# define UsL           ( UserStateLoggedOn)
# define UsUPL         ( UsL | UsUP)

//
// Store the commands in alphabetical order ( manually stored so!)
//   to enable faster search.
//
// Format is:
//  Name   Help Information   FunctionToCall  ArgumentType  ValidStates
//

FTPD_COMMAND MainCommands[] ={

    { "ABOR", "(abort operation)",            MainABOR, ArgTypeNone,    UsL},
    { "ACCT", "(specify account)",            MainACCT, ArgTypeRequired,UsL},
    { "ALLO", "(allocate storage vacuously)", MainALLO, ArgTypeRequired,UsL},
    { "APPE", "<sp> file-name",               MainAPPE, ArgTypeRequired,UsL},
    { "CDUP", "change to parent directory",   MainCDUP, ArgTypeNone,    UsL},
    { "CWD",  "[ <sp> directory-name ]",      MainCWD , ArgTypeOptional,UsL},
    { "DELE", "<sp> file-name",               MainDELE, ArgTypeRequired,UsL},
    { "HELP", "[ <sp> <string>]",             MainHELP, ArgTypeOptional,UsUPL},
    { "LIST", "[ <sp> path-name ]",           MainLIST, ArgTypeOptional,UsL},
    { "MDTM", "(sp) file-name",               MainMDTM, ArgTypeRequired,UsL },
    { "MKD",  "<sp> path-name",               MainMKD , ArgTypeRequired,UsL},
    { "MODE", "(specify transfer mode)",      MainMODE, ArgTypeRequired,UsUPL},
    { "NLST", "[ <sp> path-name ]",           MainNLST, ArgTypeOptional,UsL},
    { "NOOP", "",                             MainNOOP, ArgTypeNone,    UsUPL},
    { "PASS", "<sp> password",                MainPASS, ArgTypeOptional, UsP},
    { "PASV", "(set server in passive mode)", MainPASV, ArgTypeNone,    UsL},
    { "PORT", "<sp> b0,b1,b2,b3,b4,b5",       MainPORT, ArgTypeRequired,UsUPL},
    { "PWD",  "(return current directory)",   MainPWD , ArgTypeNone,    UsL},
    { "QUIT", "(terminate service)",          MainQUIT, ArgTypeNone,    UsUPL},
    { "REIN", "(reinitialize server state)",  MainREIN, ArgTypeNone,    UsL},
    { "REST", "<sp> marker",                  MainREST, ArgTypeRequired,UsL},
    { "RETR", "<sp> file-name",               MainRETR, ArgTypeRequired,UsL},
    { "RMD",  "<sp> path-name",               MainRMD , ArgTypeRequired,UsL },
    { "RNFR", "<sp> file-name",               MainRNFR, ArgTypeRequired,UsL},
    { "RNTO", "<sp> file-name",               MainRNTO, ArgTypeRequired,UsL },
    { "SITE", "(site-specific commands)",     MainSITE, ArgTypeOptional,UsL },
    { "SIZE", "(sp) file-name",               MainSIZE, ArgTypeRequired,UsL },
    { "SMNT", "<sp> pathname",                MainSMNT, ArgTypeRequired,UsL },
    { "STAT", "(get server status)",          MainSTAT, ArgTypeOptional,UsL },
    { "STOR", "<sp> file-name",               MainSTOR, ArgTypeRequired,UsL },
    { "STOU", "(store unique file)",          MainSTOU, ArgTypeNone,    UsL},
    { "STRU", "(specify file structure)",     MainSTRU, ArgTypeRequired,UsUPL},
    { "SYST", "(get operating system type)",  MainSYST, ArgTypeNone,    UsL },
    { "TYPE", "<sp> [ A | E | I | L ]",       MainTYPE, ArgTypeRequired,UsL },
    { "USER", "<sp> username",                MainUSER, ArgTypeRequired,UsUPL},
    { "XCUP", "change to parent directory",   MainCDUP, ArgTypeNone,    UsL},
    { "XCWD", "[ <sp> directory-name ]",      MainCWD , ArgTypeOptional,UsL },
    { "XMKD", "<sp> path-name",               MainMKD , ArgTypeRequired,UsL },
    { "XPWD", "(return current directory)",   MainPWD , ArgTypeNone,    UsL },
    { "XRMD", "<sp> path-name",               MainRMD , ArgTypeRequired,UsL }
};

#define NUM_MAIN_COMMANDS ( sizeof(MainCommands) / sizeof(MainCommands[0]) )




FTPD_COMMAND SiteCommands[] = {

    { "CKM",      "(toggle directory comments)", SiteCKM    , ArgTypeNone,UsL},
    { "DIRSTYLE", "(toggle directory format)",  SiteDIRSTYLE, ArgTypeNone,UsL},
    { "HELP",     "[ <sp> <string>]",           SiteHELP    , ArgTypeOptional,
                                                                     UsL}

#ifdef KEEP_COMMAND_STATS

    ,{ "STATS",    "(display per-command stats)", SiteSTATS , ArgTypeNone, UsL}

#endif  // KEEP_COMMAND_STATS

    };


#define NUM_SITE_COMMANDS ( sizeof(SiteCommands) / sizeof(SiteCommands[0]) )



#ifdef KEEP_COMMAND_STATS
extern CRITICAL_SECTION g_CommandStatisticsLock;
#endif  // KEEP_COMMAND_STATS


#ifdef FTP_AUX_COUNTERS

LONG g_AuxCounters[NUM_AUX_COUNTERS];

#endif // FTP_AUX_COUNTERS




char  PSZ_COMMAND_NOT_UNDERSTOOD[] = "'%s': command not understood";
char  PSZ_INVALID_PARAMS_TO_COMMAND[] = "'%s': Invalid number of parameters";
char  PSZ_ILLEGAL_PARAMS[] = "'%s': illegal parameters";



/************************************************************
 *    Functions
 ************************************************************/



LPFTPD_COMMAND
FindCommandByName(
    LPSTR          pszCommandName,
    LPFTPD_COMMAND pCommandTable,
    INT            cCommands
    );


VOID
HelpWorker(
    LPUSER_DATA    pUserData,
    LPSTR          pszSource,
    LPSTR          pszCommand,
    LPFTPD_COMMAND pCommandTable,
    INT            cCommands,
    INT            cchMaxCmd
    );


/*******************************************************************

    NAME:       ParseCommand

    SYNOPSIS:   Parses a command string, dispatching to the
                appropriate implementation function.

    ENTRY:      pUserData - The user initiating  the request.

                pszCommandText - pointer to command text. This array of
                 characters will be munged while parsing.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     08-18-1995  Eliminated local copy of the command text

********************************************************************/
VOID
ParseCommand(
    LPUSER_DATA pUserData,
    LPSTR       pszCommandText
    )
{
    LPFTPD_COMMAND pcmd;
    LPFN_COMMAND   pfnCmd;
    LPSTR          pszSeparator;
    LPSTR          pszInvalidCommandText = PSZ_INVALID_PARAMS_TO_COMMAND;
    CHAR           chSeparator;
    BOOL           fValidArguments;
    BOOL           fReturn = FALSE;

    DBG_ASSERT( pszCommandText != NULL );
    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );
    DBG_ASSERT( IS_VALID_USER_STATE( pUserData->UserState ) );

    IF_DEBUG( PARSING) {

        DBGPRINTF( ( DBG_CONTEXT, "ParseCommand( %08x, %s)\n",
                    pUserData, pszCommandText));
    }

    //
    //  Ensure we didn't get entered in an invalid state.
    //


//BOGUS:    DBG_ASSERT( ( pUserData->UserState != UserStateEmbryonic ) &&
//BOGUS:                 ( pUserData->UserState != UserStateDisconnected ) );

    pUserData->UpdateOffsets();

    //
    //  The command will be terminated by either a space or a '\0'.
    //

    pszSeparator = strchr( pszCommandText, ' ' );

    if( pszSeparator == NULL )
    {
        pszSeparator = pszCommandText + strlen( pszCommandText );
    }

    //
    //  Try to find the command in the command table.
    //

    chSeparator   = *pszSeparator;
    *pszSeparator = '\0';

    pcmd = FindCommandByName( pszCommandText,
                              MainCommands,
                              NUM_MAIN_COMMANDS );

    if( chSeparator != '\0' )
    {
        *pszSeparator++ = chSeparator;
    }

    //
    //  If this is an unknown command, reply accordingly.
    //

    if( pcmd == NULL )
    {
        FacIncrement( FacUnknownCommands);

        ReplyToUser( pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    PSZ_COMMAND_NOT_UNDERSTOOD,
                    pszCommandText );
        return;
    }

    //
    //  Retrieve the implementation routine.
    //

    pfnCmd = pcmd->Implementation;

    //
    //  If this is an unimplemented command, reply accordingly.
    //

    if( pfnCmd == NULL )
    {
        ReplyToUser( pUserData,
                    REPLY_COMMAND_NOT_IMPLEMENTED,
                    PSZ_COMMAND_NOT_UNDERSTOOD,
                    pcmd->CommandName );

        return;
    }


    //
    //  Ensure we're in a valid state for the specified command.
    //

    if ( ( pcmd->dwUserState & pUserData->UserState) == 0) {

        if( pfnCmd == MainPASS ) {

            ReplyToUser( pUserData,
                        REPLY_BAD_COMMAND_SEQUENCE,
                        "Login with USER first." );
        } else {

            ReplyToUser( pUserData,
                        REPLY_NOT_LOGGED_IN,
                        "Please login with USER and PASS." );
        }

        return;
    }

    //
    //  Do a quick & dirty preliminary check of the argument(s).
    //

    fValidArguments = FALSE;

    while( ( *pszSeparator == ' ' ) && ( *pszSeparator != '\0' ) ) {

        pszSeparator++;
    }

    switch( pcmd->ArgumentType ) {

      case ArgTypeNone :
        fValidArguments = ( *pszSeparator == '\0' );
        break;

      case ArgTypeOptional :
        fValidArguments = TRUE;
        break;

      case ArgTypeRequired :
        fValidArguments = ( *pszSeparator != '\0' );
        break;

      default:
        DBGPRINTF(( DBG_CONTEXT,
                   "ParseCommand - invalid argtype %d\n",
                   pcmd->ArgumentType ));
        DBG_ASSERT( FALSE );
        break;
    }


    //
    // check we did not get extended chars if we are configured not to allow that
    //

    if( g_fNoExtendedChars /* && !pUserDate->QueryUTF8Option() */) {

        LPSTR pszCh = pszSeparator;

        while( *pszCh ) {

            if( !IS_7BIT_ASCII( *pszCh++ ) ) {

               fValidArguments = FALSE;
               pszInvalidCommandText = PSZ_ILLEGAL_PARAMS;
               break;
            }
        }
    }

    if( fValidArguments ) {

        //
        //  Invoke the implementation routine.
        //

        if( *pszSeparator == '\0' )
        {
            pszSeparator = NULL;
        }

        IF_DEBUG( PARSING )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "invoking %s command, args = %s\n",
                        pcmd->CommandName,
                        _strnicmp( pcmd->CommandName, "PASS", 4 )
                            ? pszSeparator
                            : "{secret...}" ));
        }

#ifdef KEEP_COMMAND_STATS
        EnterCriticalSection( &g_CommandStatisticsLock );

        //
        // only increment the count if we're not re-processing a command
        //
        if ( !pUserData->QueryInFakeIOCompletion() )
        {
            pcmd->UsageCount++;
        }
        LeaveCriticalSection( &g_CommandStatisticsLock );
#endif  // KEEP_COMMAND_STATS

        //
        // Keep track of what command is being executed, in case command processing doesn't
        // complete in this thread and another thread has to finish processing it
        // [can happen if we're in PASV mode and doing async accept on the data connection]
        // Only need to do this if this thread isn't handling an IO completion we generated
        // ourselves because a PASV socket became accept()'able - if it is, we've already
        // set the command.
        //
        if ( !pUserData->QueryInFakeIOCompletion() )
        {
            if ( !pUserData->SetCommand( pszCommandText ) )
            {
                ReplyToUser( pUserData,
                             REPLY_LOCAL_ERROR,
                             "Failed to allocate necessary memory.");
            }
        }
        fReturn = (pfnCmd)( pUserData, pszSeparator );

        if ( !fReturn) {

            //
            // Invalid number of arguments. Inform the client.
            //
            ReplyToUser(pUserData,
                        REPLY_UNRECOGNIZED_COMMAND,
                        PSZ_COMMAND_NOT_UNDERSTOOD,
                        pszCommandText);
        }

    } else {

        // Invalid # of arguments

        ReplyToUser(pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    pszInvalidCommandText,
                    pszCommandText);
    }

    return;
}   // ParseCommand()






/*******************************************************************

    NAME:       MainSITE

    SYNOPSIS:   Implementation for the SITE command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
BOOL
MainSITE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    LPFTPD_COMMAND pcmd;
    LPFN_COMMAND   pfnCmd;
    LPSTR          pszSeparator;
    CHAR           chSeparator;
    BOOL           fValidArguments;
    CHAR           szParsedCommand[MAX_COMMAND_LENGTH+1];

    DBG_ASSERT( pUserData != NULL );


    //
    //  If no arguments were given, just return the help text.
    //

    if( pszArg == NULL )
    {
        SiteHELP( pUserData, NULL );
        return TRUE;
    }

    //
    //  Save a copy of the command so we can muck around with it.
    //

    P_strncpy( szParsedCommand, pszArg, MAX_COMMAND_LENGTH );

    //
    //  The command will be terminated by either a space or a '\0'.
    //

    pszSeparator = strchr( szParsedCommand, ' ' );

    if( pszSeparator == NULL )
    {
        pszSeparator = szParsedCommand + strlen( szParsedCommand );
    }

    //
    //  Try to find the command in the command table.
    //

    chSeparator   = *pszSeparator;
    *pszSeparator = '\0';

    pcmd = FindCommandByName( szParsedCommand,
                              SiteCommands,
                              NUM_SITE_COMMANDS );

    if( chSeparator != '\0' )
    {
        *pszSeparator++ = chSeparator;
    }

    //
    //  If this is an unknown command, reply accordingly.
    //

    if( pcmd == NULL ) {

        //
        //  Syntax error in command.
        //

        ReplyToUser( pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    "'SITE %s': command not understood",
                    pszArg );

        return (TRUE);
    }

    //
    //  Retrieve the implementation routine.
    //

    pfnCmd = pcmd->Implementation;

    //
    //  If this is an unimplemented command, reply accordingly.
    //

    if( pfnCmd == NULL )
    {
        ReplyToUser( pUserData,
                    REPLY_COMMAND_NOT_IMPLEMENTED,
                    "SITE %s command not implemented.",
                    pcmd->CommandName );

        return TRUE;
    }


    //
    //  Ensure we're in a valid state for the specified command.
    //

    if ( ( pcmd->dwUserState & pUserData->UserState) == 0) {

        ReplyToUser( pUserData,
                    REPLY_NOT_LOGGED_IN,
                    "Please login with USER and PASS." );
        return (FALSE);
    }

    //
    //  Do a quick & dirty preliminary check of the argument(s).
    //

    fValidArguments = FALSE;

    while( ( *pszSeparator == ' ' ) && ( *pszSeparator != '\0' ) )
    {

        pszSeparator++;
    }

    switch( pcmd->ArgumentType ) {

      case ArgTypeNone:
        fValidArguments = ( *pszSeparator == '\0' );
        break;

      case ArgTypeOptional:
        fValidArguments = TRUE;
        break;

      case ArgTypeRequired:
        fValidArguments = ( *pszSeparator != '\0' );
        break;

      default:
        DBGPRINTF(( DBG_CONTEXT,
                    "MainSite - invalid argtype %d\n",
                   pcmd->ArgumentType ));
        DBG_ASSERT( FALSE );
        break;
    }

    if( fValidArguments ) {

        //
        //  Invoke the implementation routine.
        //

        if( *pszSeparator == '\0' )
        {
            pszSeparator = NULL;
        }

        IF_DEBUG( PARSING )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "invoking SITE %s command, args = %s\n",
                       pcmd->CommandName,
                       pszSeparator ));
        }

        if( (pfnCmd)( pUserData, pszSeparator ) )
        {
            return TRUE;
        }
    } else {

        // Invalid # of arguments

        ReplyToUser(pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    PSZ_INVALID_PARAMS_TO_COMMAND,
                    pszArg);
    }

    return TRUE;

}   // MainSITE()





/*******************************************************************

    NAME:       MainHELP

    SYNOPSIS:   Implementation for the HELP command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
BOOL
MainHELP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    DBG_ASSERT( pUserData != NULL );

    HelpWorker(pUserData,
               "",
               pszArg,
               MainCommands,
               NUM_MAIN_COMMANDS,
               4 );

    return TRUE;

}   // MainHELP







/*******************************************************************

    NAME:       SiteHELP

    SYNOPSIS:   Implementation for the site-specific HELP command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-May-1993 Created.

********************************************************************/
BOOL
SiteHELP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    DBG_ASSERT( pUserData != NULL );

    HelpWorker(pUserData,
               "SITE ",
               pszArg,
               SiteCommands,
               NUM_SITE_COMMANDS,
               8 );

    return TRUE;

}   // SiteHELP






#ifdef KEEP_COMMAND_STATS
/*******************************************************************

    NAME:       SiteSTATS

    SYNOPSIS:   Implementation for the site-specific STATS command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     26-Sep-1994 Created.

********************************************************************/
BOOL
SiteSTATS(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    SOCKET  ControlSocket;
    LPFTPD_COMMAND pCmd;
    INT            i;
    CHAR    rgchUsageStats[NUM_MAIN_COMMANDS * 25]; //  25 chars per command

    pCmd   = MainCommands;

    DBG_ASSERT( NUM_MAIN_COMMANDS > 0); // we know this very well!

    // Print the stats for first command.
    EnterCriticalSection( &g_CommandStatisticsLock );

    // Find first non-zero entry.
    for( i = 0; i < NUM_MAIN_COMMANDS && pCmd->UsageCount <= 0; i++, pCmd++)
      ;

    if ( i < NUM_MAIN_COMMANDS) {

        // There is some non-zero entry.

        CHAR *  pszStats = rgchUsageStats;
        DWORD   cch = 0;

        // print the stats for first command
        cch = wsprintfA( pszStats + cch, "%u-%-4s : %lu\r\n",
                        REPLY_COMMAND_OK,
                        pCmd->CommandName,
                        pCmd->UsageCount);

        for( i++, pCmd++ ; i < NUM_MAIN_COMMANDS ; i++, pCmd++) {

            if( pCmd->UsageCount > 0 ) {

                cch += wsprintfA( pszStats + cch,
                                 "    %-4s : %lu\r\n",
                                 pCmd->CommandName,
                                 pCmd->UsageCount );
                DBG_ASSERT( cch < NUM_MAIN_COMMANDS * 25);
            }

        } // for

        // Ignoring the error code here! probably socket closed
        SockSend( pUserData, pUserData->QueryControlSocket(),
                         rgchUsageStats, cch);
    }

    LeaveCriticalSection( &g_CommandStatisticsLock );

#ifdef  FTP_AUX_COUNTERS

    CHAR *  pszStats = rgchUsageStats;
    DWORD   cch = 0;

    // print the stats for first counter
    cch = wsprintfA( pszStats + cch, "%u-Aux[%d] : %lu\r\n",
                    REPLY_COMMAND_OK,
                    0,
                    FacCounter(0));

    for( i = 1; i < NUM_AUX_COUNTERS; i++) {

        cch += wsprintfA( pszStats + cch,
                         "    Aux[%d] : %lu\r\n",
                         i,
                         FacCounter(i));
        DBG_ASSERT( cch < NUM_MAIN_COMMANDS * 25);
      }

    if ( cch > 0) {

        SockSend( pUserData, pUserData->QueryControlSocket(),
                 rgchUsageStats, cch);
    }

# endif // FTP_AUX_COUNTERS

    ReplyToUser( pUserData,
                REPLY_COMMAND_OK,
                "End of stats." );

    return TRUE;

}   // SiteSTATS
#endif KEEP_COMMAND_STATS





/*******************************************************************

    NAME:       FindCommandByName

    SYNOPSIS:   Searches the command table for a command with this
                specified name.

    ENTRY:      pszCommandName - The name of the command to find.

                pCommandTable - An array of FTPD_COMMANDs detailing
                    the available commands.

                cCommands - The number of commands in pCommandTable.

    RETURNS:    LPFTPD_COMMAND - Points to the command entry for
                    the named command.  Will be NULL if command
                    not found.

    HISTORY:
        KeithMo     10-Mar-1993 Created.
        MuraliK     28-Mar-1995 Completely rewrote to support binary search.

********************************************************************/
LPFTPD_COMMAND
FindCommandByName(
                  LPSTR          pszCommandName,
                  LPFTPD_COMMAND pCommandTable,
                  INT            cCommands
                  )
{
    int  iLower = 0;
    int  iHigher = cCommands  - 1; // store the indexes
    LPFTPD_COMMAND pCommandFound = NULL;

    DBG_ASSERT( pszCommandName != NULL );
    DBG_ASSERT( pCommandTable != NULL );
    DBG_ASSERT( cCommands > 0 );

    //
    //  Search for the command in our table.
    //

    _strupr( pszCommandName );


    while ( iLower <= iHigher) {

        int iMid = ( iHigher + iLower) / 2;

        int comp = strcmp( pszCommandName, pCommandTable[ iMid].CommandName);

        if ( comp == 0) {

            pCommandFound = ( pCommandTable + iMid);
            break;

        } else if ( comp < 0) {

            // reset the higher bound
            iHigher = iMid - 1;
        } else {

            // reset the lower bound
            iLower = iMid + 1;
        }
    }

    return ( pCommandFound);

}   // FindCommandByName()





/*******************************************************************

    NAME:       HelpWorker

    SYNOPSIS:   Worker function for HELP & site-specific HELP commands.

    ENTRY:      pUserData - The user initiating the request.

                pszSource - The source of these commands.

                pszCommand - The command to get help for.  If NULL,
                    then send a list of available commands.

                pCommandTable - An array of FTPD_COMMANDs, one for
                    each available command.

                cCommands - The number of commands in pCommandTable.

                cchMaxCmd - Length of the maximum command.

    HISTORY:
        KeithMo     06-May-1993 Created.
        Muralik     08-May-1995 Added Buffering for performance.

********************************************************************/
VOID
HelpWorker(
           LPUSER_DATA    pUserData,
           LPSTR          pszSource,
           LPSTR          pszCommand,
           LPFTPD_COMMAND pCommandTable,
           INT            cCommands,
           INT            cchMaxCmd
           )
{
    LPFTPD_COMMAND pcmd;
    DWORD  dwError;

    //
    // We should cache the following message and use the cached message for
    //  sending purposes ==> improves performance.
    //  MuraliK   NYI
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pCommandTable != NULL );
    DBG_ASSERT( cCommands > 0 );

    if( pszCommand == NULL ) {

        DWORD          cch;
        LS_BUFFER      lsb;
        CHAR szTmp[MAX_HELP_LINE_SIZE];

        if ((dwError = lsb.AllocateBuffer(HelpMsgSize(cCommands)))!= NO_ERROR){

            IF_DEBUG( ERROR) {

                DBGPRINTF(( DBG_CONTEXT,
                           "Buffer Allocation ( %d bytes) failed.\n",
                           HelpMsgSize(cCommands)));
            }

            ReplyToUser(pUserData,
                        REPLY_HELP_MESSAGE,
                        "HELP command failed." );
            return;
        }

        cch = wsprintfA( lsb.QueryAppendPtr(),
                        "%u-The following %s commands are recognized"
                        "(* ==>'s unimplemented).\r\n",
                        REPLY_HELP_MESSAGE,
                        pszSource);
        lsb.IncrementCB( cch * sizeof( CHAR));

        for( pcmd = pCommandTable; pcmd < pCommandTable + cCommands; pcmd++) {

            cch = sprintf( szTmp,
                          "   %-*s%c\r\n",
                          cchMaxCmd,
                          pcmd->CommandName,
                          pcmd->Implementation == NULL ? '*' : ' ' );

            DBG_ASSERT( cch*sizeof(CHAR) < sizeof(szTmp));

            //
            // since we calculate and preallocate the buffer, we dont
            //  need to worry about the overflow of the buffer.
            //

            DBG_ASSERT( cch*sizeof(CHAR) < lsb.QueryRemainingCB());

            if ( cch * sizeof(CHAR) >= lsb.QueryRemainingCB()) {

                // This is added for retail code where ASSERT may fail.

                dwError = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            strncpy( lsb.QueryAppendPtr(), szTmp, cch);
            lsb.IncrementCB( cch*sizeof(CHAR));

        } // for ( all commands)

        if ( dwError == NO_ERROR) {

            // Append the ending sequence for success in generating HELP.
            cch = sprintf( szTmp,
                          "%u  %s\r\n",
                          REPLY_HELP_MESSAGE,
                          "HELP command successful." );

            if ( cch*sizeof(CHAR) >= lsb.QueryRemainingCB()) {

                dwError = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                // copy the completion message
                strncpy( lsb.QueryAppendPtr(), szTmp, cch);
                lsb.IncrementCB( cch*sizeof(CHAR));
            }
        }

        if ( dwError == NO_ERROR) {

            // Send the chunk of data

            dwError = SockSend( pUserData,
                               pUserData->QueryControlSocket(),
                               lsb.QueryBuffer(),
                               lsb.QueryCB());
        } else {

            IF_DEBUG( ERROR) {

                DBGPRINTF(( DBG_CONTEXT,
                           "Error = %u. Should Not happen though...\n",
                           dwError));
            }

            ReplyToUser( pUserData,
                        REPLY_HELP_MESSAGE,
                        "HELP command failed.");
        }

        lsb.FreeBuffer();

        // Ignore the errors if any from propagating outside

    } else {

        pcmd = FindCommandByName(pszCommand,
                                 pCommandTable,
                                 cCommands );

        if( pcmd == NULL ) {

            ReplyToUser( pUserData,
                        REPLY_PARAMETER_SYNTAX_ERROR,
                        "Unknown command %s.",
                        pszCommand );
        } else {

            ReplyToUser( pUserData,
                        REPLY_HELP_MESSAGE,
                        "Syntax: %s%s %s",
                        pszSource,
                        pcmd->CommandName,
                        pcmd->HelpText );
        }
    }

    return;

}   // HelpWorker()


/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\connect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    connect.cxx

    This module contains the main function for handling new connections.
    After receiving a new connection this module creates a new USER_DATA
    object to contain the information about a connection for processing.


    Functions exported by this module:

        FtpdNewConnction
        FtpdNewConnectionEx


    FILE HISTORY:
        KeithMo     08-Mar-1993 Created.
        MuraliK     03-April-1995
           Rewrote to separate the notion of one thread/control connection +
           other mods.
        MuraliK    11-Oct-1995
           Completely rewrote to support AcceptEx connections

*/


#include "ftpdp.hxx"


static CHAR PSZ_SERVICE_NOT_AVAILABLE[] =
  "Service not available, closing control connection.";


//
//  Private prototypes.
//



VOID
FtpReqResolveCallback(
    ADDRCHECKARG pArg,
    BOOL fSt,
    LPSTR pName
    )
{
    // ignore fSt : DNS name is simply unavailable

    //((LPUSER_DATA)pArg)->Reference();

    if ( !AtqPostCompletionStatus( ((LPUSER_DATA)pArg)->QueryControlAio()->QueryAtqContext(),
                                   0 ))
    {
        DereferenceUserDataAndKill( ((LPUSER_DATA)pArg) );
    }
}



BOOL
ProcessNewClient(
    IN SOCKET       sNew,
    IN PVOID        EndpointObject,
    IN FTP_SERVER_INSTANCE *pInstance,
    IN BOOL         fMaxConnExceeded,
    IN PSOCKADDR_IN psockAddrRemote,
    IN PSOCKADDR_IN psockAddrLocal = NULL,
    IN PATQ_CONTEXT patqContext    = NULL,
    IN PVOID        pvBuff         = NULL,
    IN DWORD        cbWritten      = 0,
    OUT LPBOOL      pfAtqToBeFreed = NULL
    )
{
    LPUSER_DATA     pUserData = NULL;

    DWORD           err     = NO_ERROR;
    BOOL            fReturn  = FALSE;
    DBG_CODE( CHAR  pchAddr[32];);
    BOOL            fSockToBeFreed = TRUE;
    BOOL            fDereferenceInstance = FALSE;
    AC_RESULT       acIpAccess;
    BOOL            fNeedDnsCheck = FALSE;
    BOOL            fValid;
    BOOL            fUnbindOnFail;

    DBG_CODE( InetNtoa( psockAddrRemote->sin_addr, pchAddr));

    if ( pfAtqToBeFreed != NULL) {
        *pfAtqToBeFreed = TRUE;
    }

    //
    // Create a new connection object
    //

    if ( !fMaxConnExceeded ) {
        pUserData = pInstance->AllocNewConnection();
    }

    if ( pUserData != NULL) {

        pUserData->QueryAccessCheck()->BindAddr( (PSOCKADDR)psockAddrRemote );
        if ( !pUserData->BindInstanceAccessCheck() ) {
            fValid = FALSE;
            fUnbindOnFail = FALSE;
        }
        else {
            fUnbindOnFail = TRUE;
            acIpAccess = pUserData->QueryAccessCheck()->CheckIpAccess( &fNeedDnsCheck );

            if ( (acIpAccess == AC_IN_DENY_LIST) ||
                 ((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) ) {

                SockPrintf2(
                    NULL,
                    sNew,
                    "%u Connection refused, unknown IP address.",
                    REPLY_NOT_LOGGED_IN
                    );

                fValid = FALSE;
            }
            else {
                fValid = TRUE;
            }
        }

        //
        // Start off processing this client connection.
        //
        //  Once we make a reset call, the USER_DATA object is created
        //    with the socket and atq context.
        //  From now on USER_DATA will take care of freeing
        // ATQ context & socket
        //

        fSockToBeFreed = FALSE;

        if ( fValid && pUserData->Reset(sNew,
                              EndpointObject,
                              psockAddrRemote->sin_addr,
                              psockAddrLocal,
                              patqContext,
                              pvBuff,
                              cbWritten,
                              acIpAccess )
            ) {

#ifndef _NO_TRACING_
            IF_CHKDEBUG( CLIENT) {

                CHKINFO( ( DBG_CONTEXT,
                            " Established a new connection to %s"
                            " ( Socket = %d)\n",
                            pchAddr,
                            sNew));
#else
            IF_DEBUG( CLIENT) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Established a new connection to %s"
                            " ( Socket = %d)\n",
                            pchAddr,
                            sNew));
#endif
            }

            //
            // At this point we have the context for the AcceptExed socket.
            //  Set the context in the AtqContext if need be.
            //

            if ( patqContext != NULL) {

                //
                // Associate client connection object with this control socket
                //  handle for future completions.
                //

                AtqContextSetInfo(patqContext,
                                  ATQ_INFO_COMPLETION_CONTEXT,
                                  (ULONG_PTR) pUserData->QueryControlAio());
            }

            if ( fNeedDnsCheck )
            {
                if ( !pUserData->QueryAccessCheck()->IsDnsResolved() ) {

                    BOOL fSync;
                    LPSTR pDns;

                    pUserData->SetNeedDnsCheck( TRUE );

                    if ( pUserData->QueryAccessCheck()->QueryDnsName( &fSync,
                            (ADDRCHECKFUNCEX)FtpReqResolveCallback,
                            (ADDRCHECKARG)pUserData,
                            &pDns )
                         && !fSync ) {

                        return TRUE;
                    }
                }
            }
            else {
                pUserData->UnbindInstanceAccessCheck();
            }

            DBG_REQUIRE( pUserData->Reference() > 0);

            fReturn = pUserData->ProcessAsyncIoCompletion(0, NO_ERROR,
                                                          pUserData->
                                                          QueryControlAio()
                                                          );

            if ( !fReturn) {

                err = GetLastError();

#ifndef _NO_TRACING_
                IF_CHKDEBUG( ERROR) {

                    CHKINFO(( DBG_CONTEXT,
                               " Unable to start off a read to client(%s,%d)."
                               " Error = %lu\n",
                               pchAddr,
                               sNew,
                               err ));
#else
                IF_DEBUG( ERROR) {

                    DBGPRINTF(( DBG_CONTEXT,
                               " Unable to start off a read to client(%s,%d)."
                               " Error = %lu\n",
                               pchAddr,
                               sNew,
                               err ));
#endif
                }
            }

            //
            // Decrement the ref count and free the connection.
            //

            DBG_ASSERT( (err == NO_ERROR) || pUserData->QueryReference() == 1);

            DereferenceUserDataAndKill( pUserData);

        } else {

            if ( fUnbindOnFail )
            {
                pUserData->UnbindInstanceAccessCheck();
            }

            // reset operation failed. relase memory and exit.
            err = GetLastError();

            pUserData->Cleanup();
            pInstance->RemoveConnection( pUserData);
            pUserData = NULL;
        }

    } else {

        err = GetLastError();
        fDereferenceInstance = TRUE;
    }

    if ( (pUserData == NULL) || (err != NO_ERROR) ) {

        //
        // Failed to allocate new connection
        // Reasons:
        //   1) Max connecitons might have been exceeded.
        //   2) Not enough memory is available.
        //   3) Access check failed
        //
        //  handle the failures and notify client.
        //

        if ( fMaxConnExceeded) {

            CHAR rgchBuffer[MAX_REPLY_LENGTH];
            DWORD len;

            //
            // Unable to insert new connection.
            //  The maxConnections may have exceeded.
            // Destroy the client connection object and return.
            // Possibly need to send an error message.
            //

#ifndef _NO_TRACING_
            IF_CHKDEBUG( ERROR) {

                CHKINFO( ( DBG_CONTEXT,
                            " MaxConnections Exceeded. "
                            " Connection from %s refused at socket %d\n",
                            pchAddr, sNew));
#else
            IF_DEBUG( ERROR) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " MaxConnections Exceeded. "
                            " Connection from %s refused at socket %d\n",
                            pchAddr, sNew));
#endif
            }

            // Format a message to send for the error case.

            pInstance->LockConfig();

            LPCSTR  pszMsg = pInstance->QueryMaxClientsMsg();
            pszMsg = (pszMsg == NULL) ? PSZ_SERVICE_NOT_AVAILABLE : pszMsg;

            len = FtpFormatResponseMessage(REPLY_SERVICE_NOT_AVAILABLE,
                                           pszMsg,
                                           rgchBuffer,
                                           MAX_REPLY_LENGTH);

            pInstance->UnLockConfig();
            DBG_ASSERT( len < MAX_REPLY_LENGTH);

            // Send the formatted message
            // Ignore error in sending this message.
            SockSend( NULL, sNew, rgchBuffer, len);

        } else {

            // not enough memory for running this client connection

            const CHAR * apszSubStrings[1];
            CHAR pchAddr2[32];

            InetNtoa( psockAddrRemote->sin_addr, pchAddr2 );

            apszSubStrings[0] = pchAddr2;

            g_pInetSvc->LogEvent(FTPD_EVENT_CANNOT_CREATE_CLIENT_THREAD,
                                  1,
                                  apszSubStrings,
                                  err );

#ifndef _NO_TRACING_
            IF_CHKDEBUG( ERROR) {

                CHKINFO(( DBG_CONTEXT,
                           "Cannot create Client Connection for %s,"
                           " Error %lu\n",
                           pchAddr,
                           err ));
#else
            IF_DEBUG( ERROR) {

                DBGPRINTF(( DBG_CONTEXT,
                           "Cannot create Client Connection for %s,"
                           " Error %lu\n",
                           pchAddr,
                           err ));
#endif
            }

            //
            // Send a message to client if the socket is to be freed.
            // If it is already freed, then we cannot send message
            //

            if ( fSockToBeFreed) {

                SockPrintf2(NULL, sNew,
                            "%u Service not available,"
                            " closing control connection.",
                            REPLY_SERVICE_NOT_AVAILABLE );
            } else {

                IF_DEBUG( CLIENT) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                " Unable to send closed error message to "
                                " %s (%d)\n",
                                pchAddr2, sNew
                                ));
                }
            }
        }


        //
        // Unable to create a new connection object.
        //  Report error and shut this.
        //

#ifndef _NO_TRACING_
        IF_CHKDEBUG( ERROR) {

            CHKINFO( ( DBG_CONTEXT,
                        "Cannot create new FTP Request object to %s."
                        " Error= %u\n",
                        pchAddr,
                        err));
#else
        IF_DEBUG( ERROR) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Cannot create new FTP Request object to %s."
                        " Error= %u\n",
                        pchAddr,
                        err));
#endif
        }

        if ( fSockToBeFreed ) {

            if ( patqContext != NULL) {

                // ensure that socket is shut down.
                DBG_REQUIRE( AtqCloseSocket( patqContext, TRUE));
            } else {

                CloseSocket( sNew);
            }
        }

        fReturn = (FALSE);

    }  // if ( pcc == NULL)


    if ( pfAtqToBeFreed != NULL) {

        *pfAtqToBeFreed = fSockToBeFreed;
    }

    if ( fDereferenceInstance ) {

        pInstance->DecrementCurrentConnections();
        pInstance->Dereference();
    }

    return (fReturn);

} // ProcessNewClient()



//
//  Public functions.
//



VOID
FtpdNewConnection(
    IN SOCKET sNew,
    IN SOCKADDR_IN * psockaddr,
    IN PVOID EndpointContext,
    IN PVOID EndpointObject
    )
/*++

  Call back function for processing the connections from clients.
  This function creates a new UserData object if permitted for the new
   client request and starts off a receive for the given connection
   using Async read on control channel established.

  Arguments:
     sNew       control socket for the new client connection
     psockAddr  pointer to the client's address.

  Returns:
     None

  History:
        KeithMo     08-Mar-1993 Created.
        MuraliK     04-April-1995
                         ReCreated for using async Io threading model.
--*/
{
    SOCKERR         serr;
    BOOL            fProcessed;
    BOOL            fMaxConnExceeded;
    INT             cbAddr = sizeof(SOCKADDR);
    SOCKADDR_IN     sockaddr;

    FTP_SERVER_INSTANCE *pInstance;

    DBG_ASSERT( sNew != INVALID_SOCKET );
    DBG_ASSERT( psockaddr != NULL );
    DBG_ASSERT( psockaddr->sin_family == AF_INET );     // temporary

    g_pFTPStats->IncrConnectionAttempts();

    if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {

#ifndef _NO_TRACING_
        IF_CHKDEBUG( ERROR) {
#else
        IF_DEBUG( ERROR) {
#endif

            DBG_CODE( CHAR pchAddr[32];);

            DBG_CODE( InetNtoa(((SOCKADDR_IN *) psockaddr)->sin_addr,
                               pchAddr));

#ifndef _NO_TRACING_
            CHKINFO( ( DBG_CONTEXT,
                        "Service is not running or AccessCheck failed for"
                        " Connection from %s\n",
                        pchAddr));
#else
            DBGPRINTF( ( DBG_CONTEXT,
                        "Service is not running or AccessCheck failed for"
                        " Connection from %s\n",
                        pchAddr));
#endif
        }

        SockPrintf2(NULL,
                    sNew,
                    "%u %s",  // the blank after %u is essential
                    REPLY_SERVICE_NOT_AVAILABLE,
                    "Service not available, closing control connection." );

        goto error_exit;

    }

    if (getsockname( sNew, (PSOCKADDR)&sockaddr, &cbAddr ) != 0) {
        goto error_exit;
    }

    //
    // Find Instance
    //

    pInstance = (FTP_SERVER_INSTANCE *)
        ((PIIS_ENDPOINT)EndpointContext)->FindAndReferenceInstance(
                                (LPCSTR)NULL,
                                sockaddr.sin_addr.s_addr,
                                &fMaxConnExceeded
                                );

    if ( pInstance == NULL ) {

        //
        //  Site is not permitted to access this server.
        //  Dont establish this connection. We should send a message.
        //

        SockPrintf2(NULL, sNew,
                    "%u Connection refused, unknown IP address.",
                    REPLY_NOT_LOGGED_IN);

        goto error_exit;
    }

    fProcessed = ProcessNewClient( sNew,
                                   EndpointObject,
                                   pInstance,
                                   fMaxConnExceeded,
                                   psockaddr);

    if ( fProcessed) {
        pInstance->QueryStatsObj()->CheckAndSetMaxConnections();
    }

    return;

error_exit:

    CloseSocket( sNew);
    return;

} // FtpdNewConnection()



VOID
FtpdNewConnectionEx(
   IN VOID *       patqContext,
   IN DWORD        cbWritten,
   IN DWORD        dwError,
   IN OVERLAPPED * lpo
   )
/*++
    Description:

        Callback function for new connections when using AcceptEx.
        This function verifies if this is a valid connection
         ( maybe using IP level authentication)
         and creates a new connection object

        The connection object is added to list of active connections.
        If the max number of connections permitted is exceeded,
          the client connection object is destroyed and
          connection is rejected.

    Arguments:

       patqContext:   pointer to ATQ context for the IO operation
       cbWritten:     count of bytes available from first read operation
       dwError:       error if any from initial operation
       lpo:           indicates if this function was called as a result
                       of IO completion or due to some error.

    Returns:

        None.

--*/
{
    DWORD           err = NO_ERROR;
    BOOL            fProcessed = FALSE;
    BOOL            fAtqContextToBeFreed = TRUE;
    BOOL            fMaxConnExceeded;
    PSOCKADDR_IN    psockAddrLocal  = NULL;
    PSOCKADDR_IN    psockAddrRemote = NULL;
    SOCKET          sNew   = INVALID_SOCKET;
    PVOID           pvBuff = NULL;
    PIIS_ENDPOINT   pEndpoint;
    FTP_SERVER_INSTANCE *pInstance;

    if ( (dwError != NO_ERROR) || !lpo) {

        DBGPRINTF(( DBG_CONTEXT, "FtpdNewConnectionEx() completion failed."
                   " Error = %d. AtqContext=%08x\n",
                   dwError, patqContext));

        //
        // For now free up the resources.
        //

        goto exit;
    }

    g_pFTPStats->IncrConnectionAttempts();

    DBG_ASSERT( patqContext != NULL);

    AtqGetAcceptExAddrs( (PATQ_CONTEXT ) patqContext,
                         &sNew,
                         &pvBuff,
                         (PVOID*)&pEndpoint,
                         (PSOCKADDR *)&psockAddrLocal,
                         (PSOCKADDR *)&psockAddrRemote);

    DBG_ASSERT( pEndpoint != NULL );
    IF_DEBUG( CONNECTION ) {

        DBGPRINTF(( DBG_CONTEXT,
                   " New connection. AtqCont=%08x, buff=%08x, cb=%d\n",
                   patqContext, pvBuff, cbWritten));
    }

    if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {

        DBGPRINTF((DBG_CONTEXT,"Connection attempt on inactive service\n"));

        SockPrintf2(NULL,
                    sNew,
                    "%u %s",  // the blank after %u is essential
                    REPLY_SERVICE_NOT_AVAILABLE,
                    "Service not available, closing control connection." );

        goto exit;
    }

    //
    // Find Instance
    //

    pInstance = (FTP_SERVER_INSTANCE*)pEndpoint->FindAndReferenceInstance(
                                (LPCSTR)NULL,
                                psockAddrLocal->sin_addr.s_addr,
                                &fMaxConnExceeded
                                );

    if (pInstance == NULL ) {

        //
        //  Site is not permitted to access this server.
        //  Dont establish this connection. We should send a message.
        //

        DBGPRINTF((DBG_CONTEXT,
            "Unable to find instance [err %d]\n",GetLastError()));
        goto exit;
    }

    //
    //  Set the timeout for future IOs on this context
    //

    AtqContextSetInfo( (PATQ_CONTEXT) patqContext,
                       ATQ_INFO_TIMEOUT,
                       (ULONG_PTR) pInstance->QueryConnectionTimeout()
                       );

    if ( pInstance->QueryBandwidthInfo() )
    {
        AtqContextSetInfo( (PATQ_CONTEXT) patqContext,
                           ATQ_INFO_BANDWIDTH_INFO,
                           (ULONG_PTR) pInstance->QueryBandwidthInfo() );
    }

    fProcessed = ProcessNewClient( sNew,
                                   NULL,
                                   pInstance,
                                   fMaxConnExceeded,
                                   psockAddrRemote,
                                   psockAddrLocal,
                                   (PATQ_CONTEXT ) patqContext,
                                   pvBuff,
                                   cbWritten,
                                   &fAtqContextToBeFreed);

    if ( fProcessed) {
        pInstance->QueryStatsObj()->CheckAndSetMaxConnections();
    }

exit:

    if ( !fProcessed && fAtqContextToBeFreed ) {

        //
        // We failed to process this connection. Free up resources properly
        //

        DBG_REQUIRE( AtqCloseSocket( (PATQ_CONTEXT )patqContext, FALSE));
        AtqFreeContext( (PATQ_CONTEXT ) patqContext, TRUE );
    }

    return;

} // FtpdNewConnectionEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\engine.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993-1995           **/
/**********************************************************************/

/*
    engine.cxx

    Command parser & execution for FTPD Service.  This module parses
    and executes the commands received from the control socket.

    Functions exported by this module:
      All function for processing FTP commands

    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     21-March-1995  Modified to use common TsLogonUser()
                                      supporting anonymous logon.
        MuraliK     27-Mar - April 1995
              Cleaning up FTP server engine for
                 - to support new Internet services interface.
                 - to support Async Io Transfers
                 - split and move the command tables to ftpcmd.cxx
                 - to replace USER_DATA::DataSocket with
                       USER_DATA::m_AioDataConnection
                 - moved SiteSTATS and statistics to ftpcmd.cxx
                 - replaced SockReply2 with ReplyToUser()
                 - modified MainREIN and MainQUIT to use
                       new USER_DATA functions.
                 - modified usage of listing functions.
                 - SendErrorToClient() used for managing and sending
                       error message to client.
                 - message strings removed to be top of the file and defined.
                 - size of file sent along before file is transferred.
        terryk      18-Sep-1996 add MainSize
*/

#include "ftpdp.hxx"
#include "ftpcmd.hxx"
#include <stdlib.h>
#include <limits.h>

//
//  Private constants.
//


//
// Since the default RFC port for ftp is 21, we calculate the Data port
//   value from it.
// However, an admin at a site may change the port number to something else
//  ==> this will create PROBLEMS..... NYI
//

/**************************************************
 *  Constant Message Strings used by this Module
 **************************************************/

//
// Below is a list of strings, which are in
//   CStrM( StringName,  ActualString)  format
// The following table contains globally all strings used within this module
//  Advantage:  One place to look for various strings
//               + possible internationalization
//  Be careful. None of these messages may be modified. Protocol may break.
//  This will be expanded into
//  const char  PSZ_StringName[] = ActualString;   and
//  enumerated value  LEN_StringName = sizeof( ActualString).
//
# define ConstantStringsForThisModule()            \
  CStrM( CANNOT_OPEN_DATA_CONNECTION, "Can't open data connection.")   \
  CStrM( TRANSFER_ABORTED,    "Connection closed; transfer aborted.")  \
  CStrM( USER_NOT_LOGGED_IN,          "User %s cannot log in.")        \
  CStrM( INSUFFICIENT_RESOURCES, "Insufficient system resources.")     \
  CStrM( REQUEST_ID_FOR_ANONYMOUS,                                     \
         "Anonymous access allowed, send identity (e-mail name) as password.")\
  CStrM( REQUEST_PASSWORD_FOR_USER,  "Password required for %s.")      \
  CStrM( COMMAND_NOT_IMPLEMENTED,    "%s command not implemented." )   \
  CStrM( COMMAND_SUCCESSFUL,         "%s command successful." )        \
  CStrM( SERVICE_READY,              "Service ready for new user.")    \
  CStrM( ENTERING_PASSIVE_MODE,      \
        "Entering Passive Mode (%d,%d,%d,%d,%d,%d).")                  \
  CStrM( FORM_MESSAGE,                "Form must be N or T." )         \
  CStrM( TYPE_NOT_IMPLEMENTED,        "Type %c not implemented.")      \
  CStrM( BYTE_SIZE_SPEC,              "Byte size must be 8." )         \
  CStrM( TYPE_SET_TO,                 "Type set to %c.")               \
  CStrM( UNIMPLEMENTED_STRU_TYPE,     "Unimplemented STRU type." )     \
  CStrM( INVALID_STRU_TYPE,           "Invalid STRU type." )     \
  CStrM( STRU_TYPE_OK,                "STRU %c ok.")                   \
  CStrM( UNIMPLEMENTED_MODE,          "Unimplemented MODE type.")      \
  CStrM( MODE_OK,                     "Mode %c ok.")                   \
  CStrM( REPLY_MARKER_SPEC,           "Reply marker is invalid.")       \
  CStrM( REPLY_RESTARTING,            "Restarting at %s." )             \
  CStrM( READY_FOR_DEST_FILE, "File exists, ready for destination name" )   \
  CStrM( BAD_COMMAND_SEQUENCE,        "Bad sequence of commands." )    \
  CStrM( CURRENT_DIRECTORY,           "\"%s\" is current directory.")  \
  CStrM( VERSION_INFO,                "Windows_NT")                    \
  CStrM( SERVER_STATUS_BEGIN,         " %s Windows NT FTP Server status:")  \
  CStrM( SERVER_STATUS_END,           "End of status.")                \
  CStrM( FILE_STATUS,                 "status of %s:")                 \
  CStrM( MSDOS_DIRSTYLE,              "MSDOS-like directory output is %s") \
  CStrM( DIRECTORY_ANNOTATION,        "directory annotation is %s")    \
  CStrM( LOGGED_IN_USER_MESSAGE,      "Anonymous user logged in%s.") \
  CStrM( USER_LOGGED_IN,              "User %s logged in%s.")          \
  CStrM( USER_CANNOT_LOG_IN,          "User %s cannot log in.")        \
  CStrM( INACCESSIBLE_HOME_DIR,                                        \
        "User %s cannot log in, home directory inaccessible.")         \
  CStrM( LICENSE_QUOTA_EXCEEDED,                                       \
        "User %s cannot log in, license quota exceeded.")              \
  CStrM( NO_GUEST_ACCESS,                                              \
        "User %s cannot log in, guest access not allowed.")            \
  CStrM( ANONYMOUS_NAME,              "Anonymous")                     \
  CStrM( FTP_NAME,                    "Ftp")                           \
  CStrM( ARGS_DELIMITER,              " \t")                           \
  CStrM( NO_FILE_OR_DIRECTORY,        "No such file or directory.")    \
  CStrM( DIRECTORY_CREATE,            "\"%s\" directory created.")     \
  CStrM( CANNOT_CREATE_FILE,          "Cannot create file.")           \
  CStrM( CANNOT_CREATE_UNIQUE_FILE,   "Cannot create unique file.")    \
  CStrM( INVALID_COMMAND,             "Invalid %s Command.")           \
  CStrM( RESPONSE_ON,                 "on")                            \
  CStrM( RESPONSE_OFF,                "off")                           \
  CStrM( GUEST_ACCESS,                " (guest access)" )              \
  CStrM( CREATE_VERB,                 "created" )                      \
  CStrM( APPEND_VERB,                 "appended" )                     \
  CStrM( USER_VERB,                   "USER" )                         \
  CStrM( PASSWORD_VERB,               "PASS" )                         \
  CStrM( QUIT_VERB,                   "QUIT" )                         \
  CStrM( ABORT_VERB,                  "ABORT" )                        \
  CStrM( REIN_VERB,                   "REIN" )                         \
  CStrM( DESTINATION_FILE_EXISTS,     "Destination file already exists.") \
  CStrM( RNFR_VERB,                   "RNFR" )                         \
  CStrM( RNTO_VERB,                   "RNTO" )                         \
  CStrM( DELE_VERB,                   "DELE" )                         \
  CStrM( RMD_VERB,                    "RMD" )                          \
  CStrM( MKD_VERB,                    "MKD" )                          \
  CStrM( DUMMY_END,  "DummyMsg. Add string before this one")


//
// Generate the strings ( these are private globals of this module).
//

# define CStrM( StringName, ActualString)   \
     const char PSZ_ ## StringName[] = ActualString ;

ConstantStringsForThisModule()

# undef CStrM



//
//  Private prototypes.
//

BOOL
ParseStringIntoAddress(
    LPSTR     pszString,
    LPIN_ADDR pinetAddr,
    LPPORT    pport
    );

DWORD
ReceiveFileFromUserAndClose(
    LPUSER_DATA pUserData,
    LPSTR       pszFileName,
    LPHANDLE    phFile
    );

BOOL
MyLogonUser(
    LPUSER_DATA pUserData,
    LPSTR       pszPassword,
    LPBOOL      pfAsGuest,
    LPBOOL      pfHomeDirFailure,
    LPBOOL      pfLicenseExceeded
    );

DWORD
DetermineUserAccess(FTP_SERVER_INSTANCE *pInstance);

//
//  Public functions.
//



//
//  Functions Implementing FTP functionality.
//


BOOL
MainUSER(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  Implements the USER command.
  Format:    USER <userName>

  Arguments:
    pUserData  - the user initiating the request.
    pszArg     - Command arguments. Will be NULL if no arguments given.

  Returns:
    BOOL - TRUE if arguments are OK; FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    LPFTP_SERVER_STATISTICS pStatsObj = pUserData->QueryInstance()->QueryStatsObj();

    DBG_ASSERT( pStatsObj != NULL );

    if( pUserData->IsLoggedOn()) {

        if( TEST_UF( pUserData, ANONYMOUS ) ) {
            pStatsObj->DecrCurrentAnonymousUsers();
        } else {
            pStatsObj->DecrCurrentNonAnonymousUsers();
        }

        SET_UF( pUserData, LOGGED_ON);
    }

    //
    //  Squirrel away a copy of the domain\user name for later.
    //  If the name is too long, then don't let them logon.
    //

    if ( strlen( pszArg ) >= ( MAX_USERNAME_LENGTH ) ) {

        ReplyToUser(pUserData,
                    REPLY_NOT_LOGGED_IN,
                    PSZ_USER_NOT_LOGGED_IN,
                    pszArg );

    } else {

        BOOL   fNameIsAnonymous;
        LPCSTR pszReply;

        fNameIsAnonymous = ( ( _stricmp( pszArg, PSZ_ANONYMOUS_NAME ) == 0 ) ||
                            ( _stricmp( pszArg, PSZ_FTP_NAME ) == 0 )
                            );

        pUserData->SetUserName( pszArg );

        if( fNameIsAnonymous ) {

            SET_UF( pUserData, ANONYMOUS );
        } else {

            CLEAR_UF( pUserData, ANONYMOUS );
        }

        //
        // remember that we're waiting for PASS command in case we
        // get disconnected.
        //
        SET_UF( pUserData, WAIT_PASS );

        //
        //  If we already have an impersonation token, then remove it.
        //  This will allow us to impersonate the new user.
        //

        pUserData->FreeUserToken();

        //
        //  Tell the client that we need a password.
        //

        pszReply =(((fNameIsAnonymous) && pUserData->QueryInstance()->AllowAnonymous())
                   ? PSZ_REQUEST_ID_FOR_ANONYMOUS
                   : PSZ_REQUEST_PASSWORD_FOR_USER);

        ReplyToUser( pUserData,
                    REPLY_NEED_PASSWORD,
                    pszReply,
                    pszArg);

        pUserData->LockUser();
        if( pUserData->QueryState() != UserStateDisconnected ) {
            pUserData->SetState( UserStateWaitingForPass);
        }
        pUserData->UnlockUser();
    }

    pUserData->WriteLogRecord( PSZ_USER_VERB, pszArg);

    return TRUE;

}   // MainUSER()



BOOL
MainPASS(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  Implements the PASS command.
  Format:  PASS <password>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DWORD dwError = NO_ERROR;

    DBG_ASSERT( pUserData != NULL );

    //
    //  PASS command only valid in WaitingForPass state.
    //

    DBG_ASSERT( pUserData->QueryState() == UserStateWaitingForPass );

    if( ( pszArg != NULL ) && ( strlen( pszArg ) > PWLEN ) ) {

        return FALSE;
    }

    //
    //  Try to logon the user.
    //
    BOOL   fAsGuest;
    BOOL   fHomeDirFailure;
    BOOL   fLicenseExceeded;

    DBG_ASSERT( pUserData->QueryUserToken() == NULL );

    //
    // we got the PASS command we we're waiting for
    //
    CLEAR_UF( pUserData, WAIT_PASS );

    pUserData->QueryInstance()->QueryStatsObj()->IncrLogonAttempts();

    if( MyLogonUser(pUserData,
                    pszArg,
                    &fAsGuest,
                    &fHomeDirFailure,
                    &fLicenseExceeded )
       ) {

        const CHAR * pszGuestAccess =
          ( ( fAsGuest) ? PSZ_GUEST_ACCESS : "");

        //
        //  Successful logon.
        //

        if( *pUserData->QueryUserName() != '-' )  {

            PCSTR pszMsg;

            pUserData->QueryInstance()->LockConfig();

            pszMsg = pUserData->QueryInstance()->QueryGreetingMsg();

            if( pszMsg && *pszMsg ) {

                pUserData->SendMultilineMessage(
                                             REPLY_USER_LOGGED_IN,
                                             pszMsg,
                                             TRUE,                    // first reply line
                                             FALSE);                  // lst reply line
            }

            pUserData->QueryInstance()->UnLockConfig();

            if( TEST_UF( pUserData, ANNOTATE_DIRS )) {

                pUserData->SendDirectoryAnnotation(
                                             REPLY_USER_LOGGED_IN,
                                             FALSE);                  // first reply line
            }
        }

        LPFTP_SERVER_STATISTICS pStats = pUserData->QueryInstance()->QueryStatsObj();
        DBG_ASSERT( pStats != NULL );

        if( TEST_UF( pUserData, ANONYMOUS ) ) {

            pStats->IncrAnonymousUsers();

            ReplyToUser(pUserData,
                        REPLY_USER_LOGGED_IN,
                        PSZ_LOGGED_IN_USER_MESSAGE,
                        pszGuestAccess );

        } else {

            pStats->IncrNonAnonymousUsers();

            ReplyToUser(pUserData,
                        REPLY_USER_LOGGED_IN,
                        PSZ_USER_LOGGED_IN,
                        pUserData->QueryUserName(),
                        pszGuestAccess );
        }

        pUserData->LockUser();
        if( pUserData->QueryState() != UserStateDisconnected ) {
            pUserData->SetState( UserStateLoggedOn);
            SET_UF( pUserData, LOGGED_ON);
        }
        pUserData->UnlockUser();

    } else {

        const CHAR * pszReply = PSZ_USER_CANNOT_LOG_IN;

        //
        //  Logon failure.
        //

        dwError = GetLastError();

        if( fHomeDirFailure ) {

            pszReply = PSZ_INACCESSIBLE_HOME_DIR;

        } else if ( fLicenseExceeded) {

            pszReply = PSZ_LICENSE_QUOTA_EXCEEDED;

        } else if ( fAsGuest && ! pUserData->QueryInstance()->AllowGuestAccess()) {

            pszReply = PSZ_NO_GUEST_ACCESS;
        }

        ReplyToUser(pUserData,
                    REPLY_NOT_LOGGED_IN,
                    pszReply,
                    pUserData->QueryUserName() );

        pUserData->LockUser();
        if( pUserData->QueryState() != UserStateDisconnected ) {
            pUserData->SetState( UserStateWaitingForUser);
            CLEAR_UF( pUserData, LOGGED_ON);
            pUserData->ClearUserName();
        }
        pUserData->UnlockUser();
    }

    pUserData->WriteLogRecord( PSZ_PASSWORD_VERB,
                              (TEST_UF( pUserData, ANONYMOUS)) ? pszArg : NULL,
                              dwError);

    return TRUE;

}   // MainPASS()



BOOL
MainACCT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the ACCT command.
  This is at present not implemented...

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_SUPERFLUOUS,
                PSZ_COMMAND_NOT_IMPLEMENTED,
                "ACCT");

    return TRUE;

}   // MainACCT()




BOOL
MainCWD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the CWD command -- Change Working Directory.
  Format:  CWD <newDirectoryName>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  If argument is NULL or "~", CD to home directory.
    //

    if( ( pszArg == NULL ) || ( strcmp( pszArg, "~" ) == 0 ) ) {

        err = pUserData->CdToUsersHomeDirectory( PSZ_ANONYMOUS_NAME);

    } else {

        err = VirtualChDir( pUserData, pszArg);
    }

    if( err == NO_ERROR ) {

        if( TEST_UF( pUserData, ANNOTATE_DIRS ) &&
           ( *pUserData->QueryUserName() != '-' )
           ) {

            pUserData->SendDirectoryAnnotation(
                                           REPLY_FILE_ACTION_COMPLETED,
                                           TRUE);                        // first reply line
        }

        ReplyToUser(pUserData,
                    REPLY_FILE_ACTION_COMPLETED,
                    PSZ_COMMAND_SUCCESSFUL,
                    "CWD");
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    return TRUE;

}   // MainCWD()



BOOL
MainCDUP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  CDUP -- changes to the parent directory if possible.
--*/
{
    return MainCWD( pUserData, ".." );
}   // MainCDUP


BOOL
MainSIZE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements SIZE command - used for retrieving the size of a file.
  Format:  SIZE pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err = (!NO_ERROR);

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to open the file.
    //

    if (pUserData->ImpersonateUser()){
	    err = pUserData->OpenFileForSend( pszArg );
		pUserData->RevertToSelf();
	}
	else
	{
		err = GetLastError();
    }

    if( err == NO_ERROR ) {

        // just return the file size
        err = pUserData->GetFileSize();
    }

    if( err != NO_ERROR ) {

        pUserData->SendErrorToClient(pszArg, err,
                                     PSZ_NO_FILE_OR_DIRECTORY);

        pUserData->WriteLogRecordForSendError( err );
    }

    pUserData->CloseFileForSend( err);  // close the file, now that we're done.
    return TRUE;

}   // MainSIZE()

BOOL
MainMDTM(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the MDTM command - used for retrieving the last
  modified time for a file. We open the file, get the file mod time, format
  it and send it.

  Format:  SIZE pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR      err = (!NO_ERROR);
    SYSTEMTIME  SystemTime;
    CHAR        rgchBuffer[sizeof("YYYYMMDDHHMMSS")];

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to open the file.
    //

    if (pUserData->ImpersonateUser()){
	    err = pUserData->OpenFileForSend( pszArg );
		pUserData->RevertToSelf();
	}
	else
	{
		err = GetLastError();
    }

    if( err == NO_ERROR ) {

        // Get the last write time.

        err = pUserData->GetFileModTime(&SystemTime);

        if (err == NO_ERROR) {
            // Format the time.
            wsprintfA(rgchBuffer, "%.4hu%.2hu%.2hu%.2hu%.2hu%.2hu",
                        SystemTime.wYear,
                        SystemTime.wMonth,
                        SystemTime.wDay,
                        SystemTime.wHour,
                        SystemTime.wMinute,
                        SystemTime.wSecond );

            ReplyToUser( pUserData, REPLY_FILE_STATUS, rgchBuffer );
        }
    }

    if( err != NO_ERROR ) {

        pUserData->SendErrorToClient(pszArg, err,
                                     PSZ_NO_FILE_OR_DIRECTORY);

        pUserData->WriteLogRecordForSendError( err );
    }

    pUserData->CloseFileForSend( err);  // close the file, now that we're done.
    return TRUE;

}   // MainMDTM()


BOOL
MainSMNT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the SMNT command.
  This is at present not implemented...

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_SUPERFLUOUS,
                PSZ_COMMAND_NOT_IMPLEMENTED,
                "SMNT");

    return TRUE;

}   // MainSMNT()




BOOL
MainQUIT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the QUIT command.
  Format:  QUIT

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    CHAR    rgchBuffer[MAX_REPLY_LENGTH];
    DWORD   len;
    LPCSTR  pszMsg;
    SOCKERR serr;

    DBG_ASSERT( pUserData != NULL );

    SET_UF( pUserData, CONTROL_QUIT);

    //
    //  Reply to the quit command.
    //

    pUserData->QueryInstance()->LockConfig();

    pszMsg = pUserData->QueryInstance()->QueryExitMsg();
    DBG_ASSERT( pszMsg != NULL);

    len = FtpFormatResponseMessage(REPLY_CLOSING_CONTROL,
                                   pszMsg,
                                   rgchBuffer,
                                   MAX_REPLY_LENGTH);
    pUserData->QueryInstance()->UnLockConfig();

    DBG_ASSERT( len <= MAX_REPLY_LENGTH);

    serr = SockSend( pUserData, pUserData->QueryControlSocket(),
                    rgchBuffer, len);

    //
    //  Cause a disconnection of the user.
    //  This will blow away the sockets first. Blowing off sockets
    //    will cause ATQ to wake up for pending data calls
    //    and send a call back indicating failure.
    //  Since we disconnect now, we will not submit any
    //    Reads to control socket ==> no more control calls come back from ATQ.
    //  At the call back processing we will decrement reference counts
    //    appropriate for cleanup.
    //

    pUserData->DisconnectUserWithError( NO_ERROR, FALSE);

    pUserData->WriteLogRecord( PSZ_QUIT_VERB, "");

    return TRUE;

}   // MainQUIT()



BOOL
MainREIN(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function executes REIN command - ReInitialize
  Format:  REIN

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DBG_ASSERT( pUserData != NULL );

    pUserData->ReInitializeForNewUser();

    ReplyToUser(pUserData,
                REPLY_SERVICE_READY,
                PSZ_SERVICE_READY);

    pUserData->WriteLogRecord( PSZ_REIN_VERB, pszArg);

    return TRUE;

}   // MainREIN()



BOOL
MainPORT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the PORT command.
  Format:  PORT <ipAddress>,<portNumber>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    IN_ADDR DataIpAddress;
    PORT    DataPort;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Parse the string into address/port pair.
    //

    if( !ParseStringIntoAddress( pszArg,
                                 &DataIpAddress,
                                 &DataPort ) )
    {
        return FALSE;
    }

    //
    //  Determine if someone is trying to give us a bogus address/port.
    //  If the port number is less than IPPORT_RESERVED,
    //    then there is a possibility of port attack. Allow this only
    //    if port attack flag is enabled
    //

    if (!pUserData->QueryInstance()->IsEnablePortAttack())
    {
	    if ( ( DataIpAddress.s_addr != pUserData->HostIpAddress.s_addr ) ||
    	     ( DataPort != CONN_PORT_TO_DATA_PORT(pUserData->LocalIpPort) &&
        	   ntohs( DataPort ) < IPPORT_RESERVED) )
        	{

            ReplyToUser(pUserData,
                        REPLY_UNRECOGNIZED_COMMAND,
                        PSZ_INVALID_COMMAND,
                        "PORT");

            return TRUE;
        }
    }


    //
    //  Save the address/port pair into per-user data.
    //

    pUserData->DataIpAddress = DataIpAddress;
    pUserData->DataPort = DataPort;

    //
    //  Disable passive mode for this user.
    //

    CLEAR_UF( pUserData, PASSIVE );

    //
    // Nuke any open data socket.
    //
    pUserData->CleanupPassiveSocket( TRUE );

    //
    //  Let the client know we accepted the port command.
    //

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_COMMAND_SUCCESSFUL,
                "PORT");

    return TRUE;

}   // MainPORT()



BOOL
MainPASV(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the PASV command - used for setting passive mode.
  Format:  PASV

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    SOCKET        DataSocket = INVALID_SOCKET;
    SOCKERR       serr  = 0;
    SOCKADDR_IN   saddrLocal;
    INT           cbLocal;

    DBG_ASSERT( pUserData != NULL );

    //
    // Nuke the old passive socket
    //
    pUserData->CleanupPassiveSocket( TRUE );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Create a new data socket.
    //

    serr = CreateFtpdSocket( &DataSocket,
                             pUserData->LocalIpAddress.s_addr,
                             0,
                             pUserData->QueryInstance() );

    if( serr == 0 )
    {
        //
        //  Determine the port number for the new socket.
        //

        cbLocal = sizeof(saddrLocal);

        if( getsockname( DataSocket, (SOCKADDR *)&saddrLocal, &cbLocal ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Success!
        //

        SET_UF( pUserData, PASSIVE );
        pUserData->SetPassiveSocket( DataSocket);
        pUserData->DataIpAddress = saddrLocal.sin_addr;
        pUserData->DataPort = saddrLocal.sin_port;

        ReplyToUser(pUserData,
                    REPLY_PASSIVE_MODE,
                    PSZ_ENTERING_PASSIVE_MODE,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b1,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b2,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b3,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b4,
                    HIBYTE( ntohs( saddrLocal.sin_port ) ),
                    LOBYTE( ntohs( saddrLocal.sin_port ) ) );

    } else {

        //
        //  Failure during data socket creation/setup.  If
        //  we managed to actually create it, nuke it.
        //

        if( DataSocket != INVALID_SOCKET )
        {
            CloseSocket( DataSocket );
            DataSocket = INVALID_SOCKET;
        }

        //
        //  Tell the user the bad news.
        //

        ReplyToUser(pUserData,
                    REPLY_CANNOT_OPEN_CONNECTION,
                    PSZ_CANNOT_OPEN_DATA_CONNECTION);
    }

    return TRUE;

}   // MainPASV()





BOOL
MainTYPE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the TYPE command - used for setting type.
  Format:  TYPE type form <addl arguments>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    XFER_TYPE   newType;
    CHAR        chType;
    CHAR        chForm;
    LPSTR       pszToken;
    BOOL        fValidForm = FALSE;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    pszToken = strtok( pszArg, PSZ_ARGS_DELIMITER);

    if( pszToken == NULL ) {

        return FALSE;
    }

    //
    //  Ensure we got a valid form type
    //  (only type N supported).
    //

    if( pszToken[1] != '\0' ) {

        return FALSE;
    }

    chType = *pszToken;


    pszToken = strtok( NULL, PSZ_ARGS_DELIMITER );

    if( pszToken == NULL ) {

        chForm     = 'N';       // default
        fValidForm = TRUE;

    } else {

        switch( *pszToken ) {

          case 'n':
          case 'N':
            chForm     = 'N';
            fValidForm = TRUE;
            break;

          case 't':
          case 'T':
            chForm     = 'T';
            fValidForm = TRUE;
            break;

          case 'c':
          case 'C':
            chForm     = 'C';
            fValidForm = TRUE;
            break;

          default:
            fValidForm = FALSE;
            break;
        } // switch

    }

    //
    //  Determine the new transfer type.
    //

    switch( chType ) {

      case 'a':
      case 'A':
        if( !fValidForm ) {

            return FALSE;
        }

        if( ( chForm != 'N' ) && ( chForm != 'T' ) ) {

            ReplyToUser(pUserData,
                        REPLY_PARAMETER_NOT_IMPLEMENTED,
                        PSZ_FORM_MESSAGE);
            return TRUE;
        }

        newType = XferTypeAscii;
        chType  = 'A';
        break;

      case 'e':
      case 'E':
        if( !fValidForm ) {

            return FALSE;
        }

        if( ( chForm != 'N' ) && ( chForm != 'T' ) ) {

            ReplyToUser(pUserData,
                        REPLY_PARAMETER_NOT_IMPLEMENTED,
                        PSZ_FORM_MESSAGE);
            return TRUE;
        }

        ReplyToUser(pUserData,
                    REPLY_PARAMETER_NOT_IMPLEMENTED,
                    PSZ_TYPE_NOT_IMPLEMENTED, 'E');
        return TRUE;

      case 'i':
      case 'I':
        if( pszToken != NULL ) {

            return FALSE;
        }

        newType = XferTypeBinary;
        chType  = 'I';
        break;

    case 'l':
    case 'L':
        if( pszToken == NULL ) {

            return FALSE;
        }

        if( strcmp( pszToken, "8" ) != 0 ) {

            if( IsDecimalNumber( pszToken ) ) {

                ReplyToUser(pUserData,
                            REPLY_PARAMETER_NOT_IMPLEMENTED,
                            PSZ_BYTE_SIZE_SPEC);

                return TRUE;
            } else {

                return FALSE;
            }
        }

        newType = XferTypeBinary;
        chType  = 'L';
        break;

      default:
        return FALSE;
    } // switch (chType)

    IF_DEBUG( COMMANDS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "setting transfer type to %s\n",
                    TransferType( newType ) ));
    }

    pUserData->SetXferType( newType);

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_TYPE_SET_TO,
                chType);

    return TRUE;

}   // MainTYPE()




BOOL
MainSTRU(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the STRU command - structure information
  Format:  STRU fileName

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    CHAR     chStruct;
    CHAR   * pszToken;

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg != NULL );

    pszToken = strtok( pszArg, PSZ_ARGS_DELIMITER );

    if( pszToken == NULL ) {

        return FALSE;
    }

    //
    //  Ensure we got a valid structure type
    //  (only type F supported).
    //

    chStruct = *pszToken;

    if( pszToken[1] != '\0' ) {

        return FALSE;
    }

    switch( chStruct ) {

      case 'f':
      case 'F':
        chStruct = 'F';
        break;

      case 'r':
      case 'R':
      case 'p':
      case 'P':
        ReplyToUser(pUserData,
                    REPLY_PARAMETER_NOT_IMPLEMENTED,
                    PSZ_UNIMPLEMENTED_STRU_TYPE);
        return TRUE;

      default:

        return FALSE;
    }

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_STRU_TYPE_OK,
                chStruct );

    return TRUE;

}   // MainSTRU()



BOOL
MainMODE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the MODE command - to set mode of tfr.
  Format:  MODE newMode

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    XFER_MODE   newMode;
    CHAR        chMode;
    LPSTR       pszToken;

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg != NULL );

    pszToken = strtok( pszArg, PSZ_ARGS_DELIMITER );

    if( pszToken == NULL ) {

        return FALSE;
    }

    //
    //  Ensure we got a valid mode type
    //  (only type S supported).
    //

    if( pszToken[1] != '\0' ) {

        return FALSE;
    }
    chMode = *pszToken;


    switch( chMode )
    {
    case 's' :
    case 'S' :
        newMode = XferModeStream;
        chMode  = 'S';
        break;

    case 'b' :
    case 'B' :
        ReplyToUser(pUserData,
                    REPLY_PARAMETER_NOT_IMPLEMENTED,
                    PSZ_UNIMPLEMENTED_MODE );
        return TRUE;

    default :
        return FALSE;
    }

    IF_DEBUG( COMMANDS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "setting transfer mode to %s\n",
                    TransferMode( newMode ) ));
    }

    pUserData->SetXferMode(newMode);

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_MODE_OK,
                chMode );

    return TRUE;

}   // MainMODE()



BOOL
MainRETR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RETR command - used for retrieving a file.
  Format:  RETR pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
#define MAX_FILE_SIZE_SPEC (32)

    APIERR err = (!NO_ERROR);
    BOOL   fErrorSent = FALSE;
    BOOL   fTriedToOpenFile = FALSE;
    LARGE_INTEGER FileSize;
    DWORD         dwAttribs;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    CHAR rgchSize[MAX_FILE_SIZE_SPEC];
    CHAR rgchBuffer[MAX_FILE_SIZE_SPEC + 10];

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    if (pUserData->ImpersonateUser()){
	    err = pUserData->OpenFileForSend( pszArg );
		pUserData->RevertToSelf();
	}
	else
	{
		err = GetLastError();
    }

    fTriedToOpenFile = TRUE;

    if ( err != NO_ERROR ) {
        goto retr_exit;
    }

    pOpenFileInfo = pUserData->QueryOpenFileInfo();

    if ( pOpenFileInfo == NULL )
    {
        err = ERROR_FILE_NOT_FOUND;
        goto retr_exit;
    }

    //
    // Get the file size
    //

    if ( !pOpenFileInfo->QuerySize(FileSize) )
    {
        err = GetLastError();

        if ( err != NO_ERROR ) {
            goto retr_exit;
        }
    }

    if( FileSize.HighPart != 0 ) {
        //
        // we do not support files >4GB.
        //
        ReplyToUser(pUserData,
                    REPLY_FILE_NOT_ALLOWED,
                    "Cannot send file larger than 4 gigabytes." );

        fErrorSent = TRUE;
        err = ERROR_MESSAGE_EXCEEDS_MAX_SIZE;
        goto retr_exit;
    }

    // removed to fix copatibility problem with cute ftp
    // when FTP service should report always a total size of file to be
    // transfered not a remainder like it was before
    //FileSize.QuadPart -= (LONGLONG)pUserData->QueryCurrentOffset();

    IsLargeIntegerToDecimalChar( &FileSize, rgchSize);
    wsprintfA( rgchBuffer, "(%s bytes)", rgchSize);

    //
    // Establish a data connection
    //
    err = pUserData->EstablishDataConnection( pszArg, rgchBuffer );

    if ( err != NO_ERROR )
    {
        if ( err == ERROR_IO_PENDING )
        {
            //
            // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
            // client to establish a data connection - it takes care of setting up an event that
            // allows us to deal asynchronously with the client connecting [or failing to do so].
            // It indicates this asynchrony by returning ERROR_IO_PENDING
            //

            DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                        !pUserData->QueryHavePASVConn() );

            if ( fTriedToOpenFile )
            {
                pUserData->CloseFileForSend( err);  // close it always on error
            }

            return TRUE;
        }

        fErrorSent = TRUE;

        goto retr_exit;
    }


    err = pUserData->SendFileToUser( pszArg, &fErrorSent);

    if ( err != NO_ERROR)
    {
        //
        // Disconnect connection, since we are in error.
        //
        DBG_REQUIRE( pUserData->DestroyDataConnection( err ));

        // since there was a failure we will close the handle right away.

        IF_DEBUG( ASYNC_IO) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SendFileToUser ( %s) failed"
                        " err = %u\n",
                        pszArg, err));
        }
    }

retr_exit:

    if( err != NO_ERROR )
    {
        //
        // This command failed, so drop out of PASV mode
        //
        CLEAR_UF( pUserData, PASSIVE );

        //
        // Clean up the PASV flags if necessary
        //
        if ( pUserData->QueryInFakeIOCompletion() )
        {
            pUserData->CleanupPASVFlags();
        }

        if ( !fErrorSent)
        {
            pUserData->SendErrorToClient(pszArg, err,
                                         PSZ_NO_FILE_OR_DIRECTORY);
        }

        pUserData->WriteLogRecordForSendError( err );

        if ( fTriedToOpenFile )
        {
            pUserData->CloseFileForSend( err);  // close it always on error
        }
    }

    return TRUE;

}   // MainRETR()




BOOL
MainSTOR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements STOR command - used for storing a file.
  Format:  STOR pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    HANDLE hFile;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to create the file.
    //

    err = VirtualCreateFile( pUserData,
                             &hFile,
                             pszArg,
                             FALSE );

    if( err != NO_ERROR )
    {
        pUserData->SendErrorToClient(pszArg, err, PSZ_CANNOT_CREATE_FILE);
    }
    else
    {

        //
        // Establish a connection to the user
        //
        err = pUserData->EstablishDataConnection( pszArg );

        if ( err != NO_ERROR )
        {
            CloseHandle( hFile );

            if ( err == ERROR_IO_PENDING )
            {
                //
                // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
                // client to establish a data connection - it takes care of setting up an event that
                // allows us to deal asynchronously with the client connecting [or failing to do so].
                // It indicates this asynchrony by returning ERROR_IO_PENDING and we don't do
                // any further processing
                //

                DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                            !pUserData->QueryHavePASVConn() );


                return TRUE;
            }

            goto stor_exit;
        }


        //
        //  Let the worker do the dirty work. ( blocking call)
        //  On return, hFile is closed
        //

        err = ReceiveFileFromUserAndClose( pUserData, pszArg, &hFile );

        if( err != NO_ERROR )
        {
            VirtualDeleteFile( pUserData,
                pszArg );
        }
    }

stor_exit:

    pUserData->WriteLogRecord(PSZ_CREATE_VERB, pszArg, err);

    return TRUE;

}   // MainSTOR()



BOOL
MainSTOU(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements STOU command - used for storing in unique file.
  Format:  STOU <noArgs>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    HANDLE hFile;
    CHAR   szTmpFile[MAX_PATH]; // contains entire path
    CHAR * pszTmpFileName;  // contains only the file name

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg == NULL );

    //
    //  Try to create the file.
    //

    szTmpFile[0] = '\0';
    err = VirtualCreateUniqueFile( pUserData,
                                   &hFile,
                                   szTmpFile );


    //
    // extract the file name alone
    //

    pszTmpFileName = strrchr( szTmpFile, '\\');
    if (NULL == pszTmpFileName)
      {  pszTmpFileName = szTmpFile; }
    else
      { pszTmpFileName++; }

    if( err != NO_ERROR )
    {

        pUserData->SendErrorToClient(pszTmpFileName, err,
                                     PSZ_CANNOT_CREATE_UNIQUE_FILE);
    }
    else
    {

        //
        // Establish a connection to the user
        //
        err = pUserData->EstablishDataConnection( pszTmpFileName );

        if ( err != NO_ERROR )
        {
            CloseHandle( hFile );

            if ( err == ERROR_IO_PENDING )
            {
                //
                // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
                // client to establish a data connection - it takes care of setting up an event that
                // allows us to deal asynchronously with the client connecting [or failing to do so].
                // It indicates this asynchrony by returning ERROR_IO_PENDING and we don't do
                // any further processign

                DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                            !pUserData->QueryHavePASVConn() );

                return TRUE;
            }

            goto stou_exit;
        }

        //
        //  Let the worker do the dirty work.
        //  On return, hFile is closed
        //

        err = ReceiveFileFromUserAndClose( pUserData, pszTmpFileName, &hFile );

        if( err != NO_ERROR ) {
            //
            // Note that VirtualCreateUniqueFile() returns a fully
            // qualified physical path to the temporary file. Because
            // of this, we cannot call VirtualDeleteFile(), as that will
            // attempt to "re-canonicalize" the file, which will fail.
            // So, we'll just call the DeleteFile() Win32 API directly.
            //

            DeleteFile( szTmpFile );
        }
    }



stou_exit:

    pUserData->WriteLogRecord(PSZ_CREATE_VERB, szTmpFile, err);

    return TRUE;

}   // MainSTOU()



BOOL
MainAPPE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements APPE command - used for appending to a file.
  Format:  APPE filename

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to create the file.
    //

    err = VirtualCreateFile( pUserData,
                             &hFile,
                             pszArg,
                             TRUE );



    if( err != NO_ERROR )
    {

        pUserData->SendErrorToClient(pszArg, err, PSZ_CANNOT_CREATE_FILE);
    }
    else
    {

        //
        // Establish a connection to the user
        //
        err = pUserData->EstablishDataConnection( pszArg );

        if ( err != NO_ERROR )
        {

            CloseHandle(hFile);

            if ( err == ERROR_IO_PENDING )
            {
                //
                // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
                // client to establish a data connection - it takes care of setting up an event that
                // allows us to deal asynchronously with the client connecting [or failing to do so].
                // It indicates this asynchrony by returning ERROR_IO_PENDING and we don't do
                // any further processing
                //

                DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                            !pUserData->QueryHavePASVConn() );

                return TRUE;
            }

            goto appe_exit;
        }



        //
        //  Let the worker do the dirty work.
        //  On return, hFile is closed
        //

        err = ReceiveFileFromUserAndClose( pUserData, pszArg, &hFile );
    }

appe_exit:

    pUserData->WriteLogRecord( PSZ_APPEND_VERB, pszArg, err);

    return TRUE;

}   // MainAPPE()




BOOL
MainALLO(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements ALLO command - used for allocating space for file.
  Format:  ALLO filename

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    //
    //  Since we don't need to pre-reserve storage space for
    //  files, we'll treat this command as a noop.
    //

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_COMMAND_SUCCESSFUL,
                "ALLO");

    return TRUE;

}   // MainALLO()



BOOL
MainREST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements REST command - used for restarting file write
  Format:  REST offset

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    LPSTR       pszEndPtr;
    DWORD       dwOffset;

    DBG_ASSERT( pUserData != NULL );

    DBG_ASSERT( pszArg != NULL );

    // Convert the input parameter to a number, and save it for the next command.

    dwOffset = strtoul(pszArg, &pszEndPtr, 10);

    if( (pszEndPtr == pszArg) || (*pszEndPtr != '\0') ||
        (*pszArg == '-') ||
        (dwOffset == ULONG_MAX && strcmp(pszArg, "4294967295")) )
    {
        ReplyToUser(pUserData,
                    REPLY_PARAMETER_SYNTAX_ERROR,
                    PSZ_REPLY_MARKER_SPEC );
    } else {

        pUserData->SetNextOffset( dwOffset );

        ReplyToUser(pUserData,
                    REPLY_NEED_MORE_INFO,
                    PSZ_REPLY_RESTARTING,
                    pszArg);
    }

    return TRUE;

}   // MainREST()



BOOL
MainRNFR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RNFR command - rename from filename
  Format:  RNFR FromFileName

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    CHAR   szCanon[MAX_PATH];
    DWORD  cbSize = MAX_PATH;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Ensure file/directory exists.
    //

    if (pUserData->IsFileNameShort(pszArg))
    {
        err = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        err = pUserData->VirtualCanonicalize(szCanon,
                                             &cbSize,
                                             pszArg,
                                             AccessTypeDelete );
    }

    if( err == NO_ERROR ) {


        if ( pUserData->ImpersonateUser() ) {
            if( GetFileAttributes( szCanon ) == (DWORD)-1L ) {

                err = GetLastError();
            }

            pUserData->RevertToSelf();
        } else {
            err = ERROR_ACCESS_DENIED;
        }

        if(( err == NO_ERROR ) && ( pUserData->RenameSourceBuffer == NULL )){

            pUserData->RenameSourceBuffer = (CHAR *)TCP_ALLOC( MAX_PATH );

            if( pUserData->RenameSourceBuffer == NULL ) {

                err = GetLastError();
            }
        }

        if( err == NO_ERROR ) {

            strcpy( pUserData->RenameSourceBuffer, pszArg );
            SET_UF( pUserData, RENAME );
        }
    }

    if( err == NO_ERROR )
    {
        ReplyToUser(pUserData,
                    REPLY_NEED_MORE_INFO,
                    PSZ_READY_FOR_DEST_FILE);
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }


    pUserData->WriteLogRecord( PSZ_RNFR_VERB, pszArg, err);

    return TRUE;

}   // MainRNFR()



BOOL
MainRNTO(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RNTO command - rename to filename
  Format:  RNTO ToFileName

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Ensure previous command was a RNFR.
    //

    if( !TEST_UF( pUserData, RENAME ) )
    {
        ReplyToUser(pUserData,
                    REPLY_BAD_COMMAND_SEQUENCE,
                    PSZ_BAD_COMMAND_SEQUENCE);
    } else {

        CLEAR_UF( pUserData, RENAME );

        //
        //  Rename the file.
        //

        err = VirtualRenameFile( pUserData,
                                pUserData->RenameSourceBuffer,
                                pszArg );

        if( err == NO_ERROR ) {

            ReplyToUser(pUserData,
                        REPLY_FILE_ACTION_COMPLETED,
                        PSZ_COMMAND_SUCCESSFUL, "RNTO");

        } else if( err == ERROR_FILE_EXISTS ) {

            pUserData->SendErrorToClient(
                pszArg,
                err,
                PSZ_DESTINATION_FILE_EXISTS,
                REPLY_FILE_NOT_ALLOWED
                );

        } else {

            pUserData->SendErrorToClient(
                pszArg,
                err,
                PSZ_NO_FILE_OR_DIRECTORY,
                REPLY_FILE_NOT_FOUND
                );

        }
    }

    pUserData->WriteLogRecord( PSZ_RNTO_VERB, pszArg, err);

    return TRUE;

}   // MainRNTO()



BOOL
MainABOR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements ABOR command - abort any ongoing data transfer
  Format:  ABOR

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                TEST_UF( pUserData, OOB_DATA )
                    ? REPLY_TRANSFER_OK
                    : REPLY_CONNECTION_OPEN,
                PSZ_COMMAND_SUCCESSFUL, "ABOR");

    //
    //  Clear any remaining oob flag.
    //

    CLEAR_UF( pUserData, OOB_DATA );

    pUserData->WriteLogRecord(PSZ_ABORT_VERB, "");

    return TRUE;

}   // MainABOR()



BOOL
MainDELE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements DELE command - used to delete a file
  Format:  DELE filename

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());


    if (pUserData->IsFileNameShort(pszArg))
    {
        err = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        err = VirtualDeleteFile( pUserData, pszArg );
    }

    if( err == NO_ERROR ) {

        ReplyToUser(pUserData,
                    REPLY_FILE_ACTION_COMPLETED,
                    PSZ_COMMAND_SUCCESSFUL, "DELE");

    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->WriteLogRecord( PSZ_DELE_VERB, pszArg, err);

    return TRUE;

}   // MainDELE()



BOOL
MainRMD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RMD command - used to delete a directory
  Format:  RMD directory

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    if (pUserData->IsFileNameShort(pszArg))
    {
        err = ERROR_PATH_NOT_FOUND;
    }
    else
    {
        err = VirtualRmDir( pUserData, pszArg );
    }

    if( err == NO_ERROR ) {

        ReplyToUser(pUserData,
                    REPLY_FILE_ACTION_COMPLETED,
                    PSZ_COMMAND_SUCCESSFUL, "RMD");
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->WriteLogRecord( PSZ_RMD_VERB, pszArg, err);

    return TRUE;

}   // MainRMD()



BOOL
MainMKD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements MKD command - used to create a directory
  Format:  MKD directory

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    err = VirtualMkDir( pUserData, pszArg );

    if( err == NO_ERROR ) {

        ReplyToUser(pUserData,
                    REPLY_FILE_CREATED,
                    PSZ_DIRECTORY_CREATE, pszArg);
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->WriteLogRecord( PSZ_MKD_VERB, pszArg, err);

    return TRUE;

}   // MainMKD()



BOOL
MainPWD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements PWD command - used to query path to working dir.
  Format:  PWD

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    CHAR     szDir[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    // We will be sending back the current directory in virtual form
    // Ofcourse the client should/need not worry about the exact path info.
    //
    strcpy( szDir, pUserData->QueryCurrentDirectory() );

    if( !TEST_UF( pUserData, MSDOS_DIR_OUTPUT ) ) {

        FlipSlashes( szDir );
    }

    ReplyToUser(pUserData,
                REPLY_FILE_CREATED,
                PSZ_CURRENT_DIRECTORY,
                szDir );

    return TRUE;

}   // MainPWD()





/*******************************************************************

    NAME:       MainLIST

    SYNOPSIS:   Implementation for the LIST command.  Similar to NLST,
                except defaults to long format display.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
BOOL
MainLIST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements LIST command - used for getting dir list.
    It is similar to NLST, only that this defaults to long format.
  Format:  LIST [options]* [path]*

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR serr = 0;
    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Let the worker do the dirty work.
    //

    serr = pUserData->EstablishDataConnection("/bin/ls");

    //
    // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
    // client to establish a data connection - it takes care of setting up an event that
    // allows us to deal asynchronously with the client connecting [or failing to do so].
    // It indicates this asynchrony by returning ERROR_IO_PENDING
    //
    if ( serr == ERROR_IO_PENDING )
    {
        DBG_ASSERT( TEST_UF( pUserData, PASSIVE ) );
        DBG_ASSERT( pUserData->QueryWaitingForPASVConn() );
        DBG_ASSERT( !pUserData->QueryHavePASVConn() );

        return TRUE;
    }

    if ( serr == 0) {

        DWORD dwError;

        serr = SimulateLs(pUserData,
                          pszArg,   // switches for path
                          TRUE,     // use data socket
                          TRUE);    // generate default long format

        dwError = ( (!TEST_UF(pUserData, OOB_ABORT) && (serr == 0))
                   ? NO_ERROR : serr);

        if ( dwError != NO_ERROR) {

            //
            // Send a soft error message indicating failure
            //

            pUserData->SendErrorToClient((pszArg != NULL) ? pszArg : ".",
                                         dwError,
                                         PSZ_NO_FILE_OR_DIRECTORY);

            // since we already reported error, now just reset transfer.
            CLEAR_UF( pUserData, TRANSFER);
        }

        DBG_REQUIRE( pUserData->DestroyDataConnection(dwError));

    } else {

        //
        // could not establish a connection send error!
        //  Error is already sent by EstablishDataConnection()
        //

        IF_DEBUG( ERROR) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "EstablishDataConnection( %08x) failed for LIST\n",
                        pUserData));
        }
    }

    return TRUE;

}   // MainLIST()



BOOL
MainNLST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements NLST command - used for getting dir list.
    generates a short form of dir listing.
  Format:  NLST [options]* [path]*

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    BOOL fSpecialLs;
    APIERR serr;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  If any switches are present, use the simulated "ls"
    //  command.  Otherwise (no switches) use the special
    //  file list.
    //

    // Estabalish a data connection for transfer of data and simulate Ls.

    fSpecialLs = ( ( pszArg == NULL) || ( *pszArg != '-')); // no switches

    serr = pUserData->EstablishDataConnection( (fSpecialLs)
                                              ? "file list" : "/bin/ls"
                                              );

    //
    // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
    // client to establish a data connection - it takes care of setting up an event that
    // allows us to deal asynchronously with the client connecting [or failing to do so].
    // It indicates this asynchrony by returning ERROR_IO_PENDING
    //
    if ( serr == ERROR_IO_PENDING )
    {
        DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                    !pUserData->QueryHavePASVConn() );

        return TRUE;
    }

    if ( serr == 0) {

        DWORD  dwError;

        serr = ( ( fSpecialLs) ?
                SpecialLs(pUserData,
                          pszArg,
                          TRUE)
                : SimulateLs(pUserData,
                             pszArg,      // switches & search path
                             TRUE)
                );

        dwError = ((!TEST_UF(pUserData, OOB_DATA) && (serr == 0))
                   ?NO_ERROR: serr);

        if ( dwError != NO_ERROR) {

            //
            // Send a soft error message indicating failure
            //

            pUserData->SendErrorToClient((pszArg != NULL) ? pszArg : ".",
                                         dwError,
                                         PSZ_NO_FILE_OR_DIRECTORY);

            // since we already reported error, now just reset transfer.
            CLEAR_UF( pUserData, TRANSFER);
        }

        DBG_REQUIRE(pUserData->DestroyDataConnection( dwError));

    } else {

        //
        // could not establish a connection send error!
        //  Error is already sent by EstablishDataConnection()
        //

        IF_DEBUG( ERROR) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "EstablishDataConnection( %08x) failed for LIST\n",
                        pUserData));
        }
    }

    return TRUE;

}   // MainNLST()



BOOL
MainSYST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements SYST command - used for getting system info.
  Format:  SYST

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_SYSTEM_TYPE,
                PSZ_VERSION_INFO );

    return TRUE;

}   // MainSYST()




# define MAX_STAT_BUFFER_SIZE        (900)

BOOL
MainSTAT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements STAT command - used for getting system stats.
  Format:  STAT

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    CHAR rgchBuffer[MAX_STAT_BUFFER_SIZE];
    DWORD cchBuf;
    DWORD dwError;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    if( pszArg == NULL )
    {
        HOSTENT * pHost;

        //
        //  Determine the name of the user's host machine.
        //

        pHost = gethostbyaddr((CHAR *)&pUserData->HostIpAddress.s_addr,
                              4,        // size of the s_addr structure
                              PF_INET ) ;

        //
        //  Just dump connection info.
        //

        cchBuf = wsprintfA( rgchBuffer,
                           "%u-%s status:\r\n"
                           "     Connected to %s\r\n"
                           "     Logged in as %s\r\n"
                           "     TYPE: %s, FORM: %s; STRUcture: %s;"
                           " transfer MODE: %s\r\n"
                           "     %s\r\n"
                           ,
                           REPLY_SYSTEM_STATUS,
                           g_FtpServiceNameString,
                           ( ( pHost != NULL )
                            ? pHost->h_name
                            : inet_ntoa( pUserData->HostIpAddress)),
                           pUserData->QueryUserName(),
                           TransferType( pUserData->QueryXferType() ),
                           "Nonprint",
                           "File",
                           TransferMode( pUserData->QueryXferMode()),
                           ( ( pUserData->QueryDataSocket() == INVALID_SOCKET )
                            ? "No data connection"
                            : "Data connection established")
                           );

        if ( cchBuf < MAX_STAT_BUFFER_SIZE &&
             pUserData->QueryControlSocket() != INVALID_SOCKET) {

            dwError = SockSend(pUserData,
                               pUserData->QueryControlSocket(),
                               rgchBuffer,
                               cchBuf);

            IF_DEBUG( SOCKETS) {

                DBGPRINTF((DBG_CONTEXT,
                           " Sending STAT results %d bytes [%s]. Error= %u\n",
                           cchBuf, rgchBuffer, dwError));
            }

        } else {

            dwError = ERROR_INSUFFICIENT_BUFFER;
        }

        ReplyToUser(pUserData,
                    REPLY_SYSTEM_STATUS,
                    PSZ_SERVER_STATUS_END );
    } else {

        //
        //  This should be similar to LIST, except it sends data
        //  over the control socket, not a data socket.
        //

        cchBuf = wsprintfA( rgchBuffer,
                           "%u-status of %s:\r\n",
                           REPLY_FILE_STATUS,
                           pszArg );

        if ( cchBuf < MAX_STAT_BUFFER_SIZE &&
             pUserData->QueryControlSocket() != INVALID_SOCKET) {

            dwError = SockSend(pUserData,
                               pUserData->QueryControlSocket(),
                               rgchBuffer,
                               cchBuf);

            // Error code is ignored after this point!
        }

        SimulateLs(pUserData,
                   pszArg,
                   FALSE,   // use control socket
                   TRUE);   // generate default long format

        ReplyToUser(pUserData,
                    REPLY_FILE_STATUS,
                    PSZ_SERVER_STATUS_END);
    }

    return TRUE;

}   // MainSTAT()



BOOL
MainNOOP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  The DO Nothing  NOOP command.
--*/
{

    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_COMMAND_SUCCESSFUL, "NOOP");

    return TRUE;

}   // MainNOOP()



BOOL
SiteDIRSTYLE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements DIRSTYLE command - used for getting site specific
     directory style. It also toggles the style
  Format:  DIRSTYLE

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    const CHAR *   pszResponse = NULL;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg == NULL );

    //
    //  Toggle the dir output flag.
    //

    if( TEST_UF( pUserData, MSDOS_DIR_OUTPUT ) )
    {
        CLEAR_UF( pUserData, MSDOS_DIR_OUTPUT );
        pszResponse = PSZ_RESPONSE_OFF;
    }
    else
    {
        SET_UF( pUserData, MSDOS_DIR_OUTPUT );
        pszResponse = PSZ_RESPONSE_ON;
    }

    DBG_ASSERT( pszResponse != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_MSDOS_DIRSTYLE,
                pszResponse );

    return TRUE;

}   // SiteDIRSTYLE()




BOOL
SiteCKM(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements CKM command - used for getting site specific
     Annotate Directories flag. It also toggles the flag.
  Format:  CKM

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    const CHAR   * pszResponse = NULL;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg == NULL );

    //
    //  Toggle the directory annotation flag.
    //

    if( TEST_UF( pUserData, ANNOTATE_DIRS ) )
    {
        CLEAR_UF( pUserData, ANNOTATE_DIRS );
        pszResponse = PSZ_RESPONSE_OFF;
    }
    else
    {
        SET_UF( pUserData, ANNOTATE_DIRS );
        pszResponse = PSZ_RESPONSE_ON;
    }

    DBG_ASSERT( pszResponse != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_DIRECTORY_ANNOTATION,
                pszResponse );

    return TRUE;

}   // SiteCKM()




BOOL
ParseStringIntoAddress(
    LPSTR     pszString,
    LPIN_ADDR pinetAddr,
    LPPORT    pport
    )
/*++
  Parse a comma-separated list of six decimal numbers
   into an IP address and a port number. The address and the port are
   in network byte order ( most significant bytes first).

  Arguments:
    pszString - string to be parsed. Should be of the form:
                 dd,dd,dd,dd,dd,dd where 'dd' us the decimal representation
                 of a byte (0-255)
    pinetAddr - will receive the IP Address
    pport     - will receive the port.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    INT     i;
    UCHAR   chBytes[6];
    UCHAR   chSum;

    chSum = 0;
    i     = 0;

    while( *pszString != '\0' )
    {
        UCHAR chCurrent = (UCHAR)*pszString++;

        if( ( chCurrent >= '0' ) && ( chCurrent <= '9' ) )
        {
            chSum = ( chSum * 10 ) + chCurrent - '0';
        }
        else
        if( ( chCurrent == ',' ) && ( i < 5 ) )
        {
            chBytes[i++] = chSum;
            chSum = 0;
        }
        else
        {
            return FALSE;
        }
    }

    chBytes[i] = chSum;

    if( i != 5 )
    {
        return FALSE;
    }

    pinetAddr->S_un.S_un_b.s_b1 = chBytes[0];
    pinetAddr->S_un.S_un_b.s_b2 = chBytes[1];
    pinetAddr->S_un.S_un_b.s_b3 = chBytes[2];
    pinetAddr->S_un.S_un_b.s_b4 = chBytes[3];

    *pport = (PORT)( chBytes[4] + ( chBytes[5] << 8 ) );

    return TRUE;

}   // ParseStringIntoAddress()



/*******************************************************************

    NAME:       ReceiveFileFromUserAndClose

    SYNOPSIS:   Worker function for STOR, STOU, and APPE commands.
                Will establish a connection via the (new) data
                socket, then receive a file over that socket.

    ENTRY:      pUserData - The user initiating the request.

                pszFileName - The name of the file to receive.

                phFile - An handle to the file being received.
                    This handle is closed before this
                    routine returns.

    Returns:
       Win32 Error codes (or socket errors) as DWORD

    HISTORY:
        KeithMo     16-Mar-1993 Created.
        MuraliK     05-April-1995 Dont free hFile here +
                                    Alloc IoTransBuffer locally

********************************************************************/
DWORD
ReceiveFileFromUserAndClose(
    LPUSER_DATA pUserData,
    LPSTR       pszFileName,
    LPHANDLE    phFile
    )
{
    BOOL    fResult;
    DWORD   cbRead = 0;
    DWORD   cbWritten;
    DWORD   dwError;
    SOCKET  DataSocket;
    LPVOID  IoTransferBuffer;
    DWORD dwNumThreads;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszFileName != NULL );
    DBG_ASSERT( *phFile != INVALID_HANDLE_VALUE );

    //
    // We're about to make a blocking call to SockRecv(), so increment the # of threads in the
    // ATQ thread pool.
    // The decision whether to process this request is made based on how many threads are already
    // blocked in a synchronous call.  We do it after accepting/establishing the
    // data connection, so that the clients's connect will succeed in the non-passive case, and
    // then have the request aborted. This prevents clients hangs.
    //

    dwNumThreads = InterlockedIncrement( (long *) &g_ThreadsBlockedInSyncCalls );

    if (dwNumThreads > g_MaxThreadsBlockedInSyncCalls)
    {

        //
        // Blow away the data connection
        //

        InterlockedDecrement( (long *) &g_ThreadsBlockedInSyncCalls );

        dwError = ERROR_NOT_ENOUGH_MEMORY;

        DBG_REQUIRE(pUserData->DestroyDataConnection( dwError));

        goto RecevieFileFromUser_exit;
    }

    AtqSetInfo( AtqIncMaxPoolThreads, 0 );

    //
    //  Allocate an i/o buffer if not already allocated.
    //

    IoTransferBuffer = TCP_ALLOC( g_SocketBufferSize );

    if( IoTransferBuffer == NULL ) {

        ReplyToUser(pUserData,
                    REPLY_LOCAL_ERROR,
                    PSZ_INSUFFICIENT_RESOURCES);

        InterlockedDecrement( (long *) &g_ThreadsBlockedInSyncCalls );
        AtqSetInfo( AtqDecMaxPoolThreads, 0 );

        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto RecevieFileFromUser_exit;
    }

    //
    //  Blast the file from the user to a local file.
    //

    DataSocket = pUserData->QueryDataSocket();

    for( ; ; )
    {
        //
        //  Read a chunk from the socket.
        //

        dwError = SockRecv( pUserData,
                           DataSocket,
                           IoTransferBuffer,
                           g_SocketBufferSize,
                           &cbRead );

        if( TEST_UF( pUserData,  OOB_DATA ) ||
           ( dwError != NO_ERROR ) || ( cbRead == 0 ) )
        {
            //
            //  Socket error during read or end of file or transfer aborted.
            //

            break;
        }

        pUserData->IncrementCbRecvd( cbRead);

        //
        //  Write the current buffer to the local file.
        //

        fResult = WriteFile( *phFile,
                             IoTransferBuffer,
                             cbRead,
                             &cbWritten,
                             NULL );

        if( !fResult )
        {
            dwError = GetLastError();
            break;
        }
    }

    if ( TEST_UF( pUserData, OOB_DATA)) {

        dwError = ERROR_OPERATION_ABORTED;
    }

    IF_DEBUG( COMMANDS )
    {
        if( !fResult )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot write file %s, error %lu\n",
                        pszFileName,
                        dwError ));
        } else if( dwError != NO_ERROR ) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot read data from client, error %d\n",
                       dwError ));
        }

        if( TEST_UF( pUserData,  OOB_DATA ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "transfer aborted by client\n" ));
        }
    }

    //
    // Close file handle before disconnecting from client. This is to serialize
    // requests. If we disconnect first, then an append to this file may follow
    // which may result in a sharing violation of the file (if this write has
    // not been flushed and closed yet).
    //

    DBG_REQUIRE( CloseHandle( *phFile ) );
    *phFile = INVALID_HANDLE_VALUE;

    //
    //  Disconnect from client.
    //

    DBG_REQUIRE(pUserData->DestroyDataConnection( dwError));

    if( IoTransferBuffer != NULL )
    {
        TCP_FREE( IoTransferBuffer );
        IoTransferBuffer = NULL;
    }

    if ( dwError == NO_ERROR) {

        pUserData->QueryInstance()->QueryStatsObj()->IncrTotalFilesReceived();
    }

    InterlockedDecrement( (long *) &g_ThreadsBlockedInSyncCalls );
    AtqSetInfo( AtqDecMaxPoolThreads, 0 );

RecevieFileFromUser_exit:

    if( *phFile != INVALID_HANDLE_VALUE ) {

       CloseHandle( *phFile );
       *phFile = INVALID_HANDLE_VALUE;
    }

    return (dwError);
}   // ReceiveFileFromUserAndClose()




/*******************************************************************

    NAME:       MyLogonUser

    SYNOPSIS:   Validates a user's credentials, then sets the
                impersonation for the current thread.  In effect,
                the current thread "becomes" the user.

    ENTRY:      pUserData - The user initiating the request.

                pszPassword - The user's password.  May be NULL.

                pfAsGuest - Will receive TRUE if the user was validated
                    with guest privileges.

                pfHomeDirFailure - Will receive TRUE if the user failed
                    to logon because the home directory was inaccessible.

                pfLicenseExceeded - Will receive TRUE if the logon
                    was denied due to license restrictions.

    RETURNS:    BOOL - If user validated & impersonation was
                    successful, returns TRUE.  Otherwise returns
                    TRUE.

    HISTORY:
        KeithMo     18-Mar-1993 Created.

********************************************************************/
BOOL
MyLogonUser(
    LPUSER_DATA pUserData,
    LPSTR       pszPassword,
    LPBOOL      pfAsGuest,
    LPBOOL      pfHomeDirFailure,
    LPBOOL      pfLicenseExceeded
    )
{
    BOOL     fReturn = TRUE;
    DWORD    dwUserAccess;
    TS_TOKEN UserToken;
    BOOL     fAsAnonymous;
    BOOL     fAsAnonymous2;
    BOOL     fEmptyPassword;
    const CHAR   * pszUser;

    //
    //  Validate parameters & state.
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pUserData->UserToken == NULL );
    DBG_ASSERT( pfAsGuest != NULL );
    DBG_ASSERT( pfHomeDirFailure != NULL );
    DBG_ASSERT( pfLicenseExceeded != NULL );

    //
    //  Setup.
    //

    *pfAsGuest         = FALSE;
    *pfHomeDirFailure  = FALSE;
    *pfLicenseExceeded = FALSE; // NOT YET SUPPORTED IN GHIA APIS!

    fEmptyPassword = ( pszPassword == NULL ) || ( *pszPassword == '\0' );

    pszUser = pUserData->QueryUserName();
    DBG_ASSERT( pszUser != NULL );
    DBG_ASSERT( *pszUser != '\0' );

    //
    //  Check for invalid logon type.
    //

    fAsAnonymous = TEST_UF( pUserData, ANONYMOUS);

    if( !pUserData->QueryInstance()->IsAllowedUser(fAsAnonymous)) {

        // conflict between what is allowed and type of the client.
        SetLastError( ERROR_LOGON_FAILURE);
        return FALSE;
    }

    //
    //  Check for anonymous logon.
    //

    if( fAsAnonymous )
    {
        //
        //  At this point, we could copy the password specified by the
        //  user into the pUserData->UserName field.  There's a convention
        //  among Internetters that the password specified for anonymous
        //  logon should actually be your login name.  So, if we wanted
        //  honor this convention, we could copy the password into the
        //  pUserData->UserName field so the Administration UI
        // could display it.
        //
        //  If the user didn't enter a password, we'll just copy over
        //  "Anonymous" so we'll have SOMETHING to display...
        //

        pUserData->SetUserName( fEmptyPassword ? PSZ_ANONYMOUS_NAME : pszPassword);

        //
        // TsLogon User will logon as anonymous only when we specify the
        //  UserName == NULL and pszPassword == NULL.
        //
        pszUser = NULL;
        pszPassword = NULL;
    }

    //
    //  Do that logon thang.
    //

    pUserData->QueryInstance()->LockConfig();

    // dumb TsLogonUser() does not take const CHAR * for pszUser :(
    UserToken = TsLogonUser( (CHAR *) pszUser,
                            pszPassword,
                            pfAsGuest,
                            &fAsAnonymous2,
                            pUserData->QueryInstance(),
                            pUserData->QueryInstance()->QueryAuthentInfo() );

    pUserData->QueryInstance()->UnLockConfig();

    //
    // Recheck the logon requirements, just in case the user is trying
    // to do something tricky, like logon with the special IUSR_xxx
    // account name.
    //

    if( UserToken != NULL &&
        !pUserData->QueryInstance()->IsAllowedUser(fAsAnonymous2) ) {

        TsDeleteUserToken( UserToken );
        UserToken = NULL;
        SetLastError( ERROR_LOGON_FAILURE );

    }

    if( UserToken != NULL ) {

        // reset it again even if it was anonymous
        pszUser = pUserData->QueryUserName();

        //
        //  Save away the impersonation token so we can delete
        //  it when the user disconnects or this client thread
        //  otherwise terminates.
        //

        pUserData->UserToken = UserToken;

        //
        //  User validated, now impersonate.
        //

        if( !pUserData->ImpersonateUser()) {

            //
            //  Impersonation failure.
            //

            IF_DEBUG( ERROR) {

                DBGPRINTF(( DBG_CONTEXT,
                           "Impersonate User %08x failed. Error=%lu\n",
                           UserToken, GetLastError()));
            }

            fReturn = FALSE;

        } else {

            //
            //  We're now running in the context of the connected user.
            //  Check the user's access to the FTP Server.
            //

            dwUserAccess = DetermineUserAccess(pUserData->QueryInstance());

            if( dwUserAccess == 0 ) {

                //
                //  User cannot access the FTP Server.
                //

                IF_DEBUG( SECURITY ) {

                    DBGPRINTF(( DBG_CONTEXT,
                               "user %s denied FTP access\n",
                               pszUser ));
                }

                fReturn = FALSE;

            } else {

                const CHAR * apszSubStrings[2];
                DWORD  eventId = 0;

                apszSubStrings[0] = pszUser;

                pUserData->Flags &= ~( UF_READ_ACCESS | UF_WRITE_ACCESS );
                pUserData->Flags |= dwUserAccess;

                IF_DEBUG( SECURITY ) {

                    CHAR * pszTmp = NULL;

                    if( TEST_UF( pUserData, READ_ACCESS ) ) {

                        pszTmp = ( TEST_UF( pUserData, WRITE_ACCESS )
                                  ? "read and write"
                                  : "read"
                                  );
                    } else {

                        DBG_ASSERT( TEST_UF( pUserData, WRITE_ACCESS ) );

                        pszTmp = "write";
                    }

                    DBG_ASSERT( pszTmp != NULL );

                    DBGPRINTF(( DBG_CONTEXT,
                               "user %s granted %s FTP access\n",
                               pszUser,
                               pszTmp ));
                }

                //
                //  Try to CD to the user's home directory.  Note that
                //  this is VERY important for setting up some of the
                //  "virtual current directory" structures properly.
                //

                if( pUserData->CdToUsersHomeDirectory( PSZ_ANONYMOUS_NAME)
                   != NO_ERROR ) {

                    //
                    //  Home directory inaccessible.
                    //

                    eventId = FTPD_EVENT_BAD_HOME_DIRECTORY;

                } else if (fAsAnonymous &&
                          pUserData->QueryInstance()->QueryLogAnonymous() &&
                          !fEmptyPassword ) {

                    //
                    //  If this is an anonymous user, and we're to log
                    //  anonymous logons, OR if this is not an anonymous
                    //  user, and we're to log nonanonymous logons, then
                    //  do it.
                    //
                    //  Note that we DON'T log the logon if the user is
                    //  anonymous but specified no password.
                    //

                    eventId =  FTPD_EVENT_ANONYMOUS_LOGON;

                } else if (!fAsAnonymous &&
                          pUserData->QueryInstance()->QueryLogNonAnonymous()
                          ) {

                    DBG_ASSERT( *pszUser != '\0');
                    eventId = FTPD_EVENT_NONANONYMOUS_LOGON;
                }

                //
                //  Log an event so the poor admin can figure out
                //  what's going on.
                //

                switch ( eventId) {

                  case FTPD_EVENT_ANONYMOUS_LOGON:
                  case FTPD_EVENT_NONANONYMOUS_LOGON:
                    apszSubStrings[1] = inet_ntoa( pUserData->HostIpAddress);

                    g_pInetSvc->LogEvent( eventId,
                                          2,
                                          apszSubStrings,
                                          0 );
                    break;

                  case FTPD_EVENT_BAD_HOME_DIRECTORY:

                    pUserData->QueryInstance()->LockThisForRead();

                    apszSubStrings[1] = pUserData->QueryInstance()->QueryRoot();

                    *pfHomeDirFailure = TRUE;
                    g_pInetSvc->LogEvent( eventId,
                                          2,
                                          apszSubStrings,
                                          0 );

                    pUserData->QueryInstance()->UnlockThis();

                    fReturn = FALSE;  // bad directory is a failure.
                    break;

                  default:
                    // do nothing
                    break;
                } // switch
            } // user Access Succeeded

            pUserData->RevertToSelf();  // get out the impersonation

        } // Impersonation succeeded.

    } else {

        fReturn = FALSE;
    }

    //
    //  Determine if we logged in with guest access, and
    //  if so, if guest access is allowed in our server.
    //

    if( *pfAsGuest && !pUserData->QueryInstance()->AllowGuestAccess() ) {

        TsDeleteUserToken( pUserData->QueryUserToken() );

        pUserData->UserToken = NULL;

        fReturn = FALSE;
    }

    //
    //  Success!
    //

    return ( fReturn);

}   // MyLogonUser()



DWORD
DetermineUserAccess(FTP_SERVER_INSTANCE *pInstance)
/*++
  This function determines the current user's access to FTP server.
  This is done by testing different RegOpenKey APIs against
  the FTPD_ACCESS_KEY. This key (if it exists) will be "under" the
  FTPD_PARAMETERS_KEY key.

  Arguments:
    None

  Returns:
    DWORD -- will be an OR Combination of UF_READ_ACCESS and UF_WRITE_ACCESS.
    IF this is zero, then the user cannot access FTP server.

  History:
    KeithMo     06-May-1993 Created.
    MuraliK     24-July-1995  Call this function with Impersonation.

  NYI:  Improve performance by avoiding reg opens per connection....
--*/
{
    DWORD  dwAccess = 0;
    HKEY   hkey;
    APIERR err;

    //
    //  Test for read access.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        FTPD_ACCESS_KEY,
                        0,
                        KEY_READ,
                        &hkey );

    if( err == NO_ERROR )
    {
        //
        //  Success.
        //

        dwAccess |= UF_READ_ACCESS;
        RegCloseKey( hkey );
    }
    else
    if( err == ERROR_FILE_NOT_FOUND )
    {
        //
        //  Key doesn't exist.
        //

        dwAccess |= UF_READ_ACCESS;
    }

    //
    //  Test for write access.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        FTPD_ACCESS_KEY,
                        0,
                        KEY_WRITE,
                        &hkey );

    if( err == NO_ERROR )
    {
        //
        //  Success.
        //

        dwAccess |= UF_WRITE_ACCESS;
        RegCloseKey( hkey );
    }
    else
    if( err == ERROR_FILE_NOT_FOUND )
    {
        //
        //  Key doesn't exist.
        //

        dwAccess |= UF_WRITE_ACCESS;
    }

    return dwAccess;
} // DetermineUserAccess()


/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\stats.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module Name :
    
       stats.cxx

   Abstract:
    
       Defines functions required for FTP server statistics

   Author:

       Murali R. Krishnan    ( MuraliK )     04-Nov-1994
   
   Project:

       Web Server DLL

   Functions Exported:

               FTP_SERVER_STATISTICS::FTP_SERVER_STATISTICS( VOID) 
       VOID    FTP_SERVER_STATISTICS::ClearStatistics( VOID)
       DWORD   CopyToStatsBuffer( LPFTP_STATISTICS_0 lpStat)

   Revision History:

       Sophia Chung ( SophiaC )     20-Nov-1996

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "ftpdp.hxx"
#include <timer.h>
#include <time.h>


/************************************************************
 *    Functions 
 ************************************************************/


FTP_SERVER_STATISTICS::FTP_SERVER_STATISTICS( VOID) 
/*++
     Initializes statistics information for server.
--*/
{
    INITIALIZE_CRITICAL_SECTION( & m_csStatsLock);

    ClearStatistics();

} // FTP_SERVER_STATISTICS::FTP_SERVER_STATISTICS();


VOID
FTP_SERVER_STATISTICS::ClearStatistics( VOID)
/*++

    Clears the counters used for statistics information

--*/ 
{
    LockStatistics();

    memset( &m_FTPStats, 0, sizeof(FTP_STATISTICS_0) );
    m_FTPStats.TimeOfLastClear       = GetCurrentTimeInSeconds();

    UnlockStatistics();

} // FTP_SERVER_STATISTICS::ClearStatistics()



DWORD
FTP_SERVER_STATISTICS::CopyToStatsBuffer( LPFTP_STATISTICS_0 lpStat)
/*++
    Description:
        copies the statistics data from the server statistcs structure
        to the FTP_STATISTICS_0 structure for RPC access.

    Arugments:
        lpStat  pointer to FTP_STATISTICS_0 object which contains the 
                data on successful return

    Returns:
        Win32 error codes. NO_ERROR on success. 

--*/
{

    DBG_ASSERT( lpStat != NULL);

    LockStatistics();

    CopyMemory( lpStat, &m_FTPStats, sizeof(FTP_STATISTICS_0) );

    if (lpStat->ServiceUptime)
    {
        lpStat->ServiceUptime = GetCurrentTimeInSeconds() - lpStat->ServiceUptime;
    }

    UnlockStatistics();

    return ( NO_ERROR);

} // CopyToStatsBuffer()


// gets currenttime and stores it inside stats structure
void 
FTP_SERVER_STATISTICS::UpdateStartTime()
{
    m_FTPStats.ServiceUptime = GetCurrentTimeInSeconds();
}



void 
FTP_SERVER_STATISTICS::UpdateStopTime()
{
    m_FTPStats.ServiceUptime = 0;
}


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\lsaux.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :
      lsaux.cxx

   Abstract:
      This modules defines the functions supporting list processing.

   Author:

       Murali R. Krishnan    ( MuraliK )     2-May-1995

   Environment:
       User Mode -- Win32

   Project:

       FTP Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include "ftpdp.hxx"
# include "lsaux.hxx"

/************************************************************
 *    Functions
 ************************************************************/


const FILETIME *
PickFileTime(IN const WIN32_FIND_DATA * pfdInfo,
             IN const LS_OPTIONS  * pOptions)
/*++

  This function selects and returns proper FILETIME structure
   to display based on the current sort method and filesystem
   capabilities.

  Arguments:
    pfdInfo   pointer to file information for a directory entry.
    pOptions  the current ls options

  Returns:
    FILETIME   -- pointer to proper time required

  History:
    MuraliK      25-Apr-1995

   This is a costly operation too. Given that this one is called once every
     directory entry is getting formatted. Can we avoid the cost ?
    YES, if we can use the offsets in the pfdInfo to chose the time object.
    NYI
--*/
{
    const FILETIME *  pliTime;

    switch ( pOptions->SortMethod) {

      case LsSortByName:
      case LsSortByWriteTime:
        pliTime = &pfdInfo->ftLastWriteTime;
        break;

      case LsSortByCreationTime:
        pliTime = &pfdInfo->ftCreationTime;
        break;

      case LsSortByAccessTime:
        pliTime = &pfdInfo->ftLastAccessTime;
        break;

      default:
        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                       "Invalid Sort %d!\n", pOptions->SortMethod ));
        }
        DBG_ASSERT( FALSE );
        pliTime = &pfdInfo->ftLastWriteTime;
        break;

    } // switch()

    //
    //  If the selected time field is not supported on
    //  the current filesystem, default to ftLastWriteTime
    //  (all filesystems support this field).
    //

    if( NULL_FILE_TIME( *pliTime ) ) {

        pliTime = &pfdInfo->ftLastWriteTime;
    }

    return ( pliTime);
} // PickFileTime()




BOOL __cdecl
FtpFilterFileInfo(
    IN const WIN32_FIND_DATA * pfdInfo,
    IN LPVOID  pContext
    )
/*++
  This function tries to filter out the file information using
   Ftp service "ls" specific filter.

  Arguments:
    pfdInfo   pointer to file information that contains the current
               file information object for filtering.
    pContext  pointer to FTP_LS_FILTER_INFO  used for filtering.

  Returns:
    TRUE if there is a match and that this file info should not be
      eliminated.
    FALSE if this file info object can be dropped out of generated list.
--*/
{
    register FTP_LS_FILTER_INFO * pfls = (FTP_LS_FILTER_INFO *) pContext;
    DWORD dwAttribs;
    BOOL  fReturn;

    if ( pfdInfo == NULL ||
        pfdInfo->dwFileAttributes == INVALID_FILE_ATTRIBUTES) {

        return ( FALSE);
    }

    //
    // We dont need to expose hidden/system files unless necessary.
    //

    dwAttribs = pfdInfo->dwFileAttributes;

    if (pfls->fFilterHidden && IS_HIDDEN( dwAttribs) ||
        pfls->fFilterSystem && IS_SYSTEM( dwAttribs)) {

        return ( FALSE);       // unwanted files.
    }

    // Always filter away "." and ".."
    const CHAR * pszFileName = ( pfdInfo->cFileName);

    if (pfls->fFilterDotDot && pszFileName[0] == '.' ||
        strcmp( pszFileName, ".") == 0 ||
        strcmp( pszFileName, "..") == 0) {

        return ( FALSE);
    }

    DBG_ASSERT( pfls->pszExpression == NULL || *pfls->pszExpression != '\0');

    //
    // Check about the file name.
    //  If the expression is not a regular expression, use simple StringCompare
    //  else  use a regular expression comparison.
    //  Return TRUE if there is a match else return FALSE.
    //

    return ( pfls->pszExpression == NULL ||  // null-expr ==> all match.
            (( pfls->fRegExpression)
             ? IsNameInRegExpressionA(pfls->pszExpression, pszFileName,
                                      pfls->fIgnoreCase)
             : !strcmp(pszFileName, pfls->pszExpression)
             ));

} // FtpFilterFileInfo()



APIERR
GetDirectoryInfo(
    IN LPUSER_DATA pUserData,
    OUT TS_DIRECTORY_INFO   * pTsDirInfo,
    IN CHAR     *  pszSearchPath,
    IN const FTP_LS_FILTER_INFO * pfls,
    IN PFN_CMP_WIN32_FIND_DATA pfnCompare
    )
/*++
  This function creates a directory listing for given directory,
    filters out unmatched files and sorts the resulting elements
    using the sort function.

  Arguments:
    pUserData    pointer to UserData structure.
    pTsDirInfo   pointer to Directory Information object that will be
                   filled in with the directory information.

    pszSearchPath  pointer to null-terminated string containing
                     the absolute path for directory along with
                     the possible filter specification.
                     eg: d:\foo\bar

    pfls         pointer to filter information used for filtering.

    pfnCompare   pointer to function used for sorting.

  Returns:
    NO_ERROR on success and Win32 error code if there are any failure.

  History:
      MuraliK      25-Apr-1995
--*/
{
    DWORD dwError = NO_ERROR;

    DBG_ASSERT( pTsDirInfo != NULL && pszSearchPath != NULL);
    DBG_ASSERT( !pTsDirInfo->IsValid());  // no dir list yet.

    IF_DEBUG(DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "GetDirListing( dir=%s, Filter=%08x (Sz=%s), "
                   "user=%08x, cmp=%08x)\n",
                   pszSearchPath, pfls, pfls->pszExpression,
                   pUserData->QueryUserToken(), pfnCompare));
    }

    CHAR  rgDirPath[MAX_PATH+10];
    CHAR * pszDirPath;
    DWORD len = strlen( pszSearchPath);

    // check to see if the last character is a "\" in the dir path
    // if not append one to make sure GetDirectoryListing works fine.
    if ( *CharPrev( pszSearchPath, pszSearchPath + len ) != '\\') {
        DBG_ASSERT( len < sizeof(rgDirPath) - 2);
        wsprintf( rgDirPath, "%s\\", pszSearchPath);
        pszDirPath = rgDirPath;
    } else {

        pszDirPath = pszSearchPath;
    }

    if ( !pTsDirInfo->GetDirectoryListingA(pszDirPath,
                                           pUserData->QueryUserToken())
        ) {

        dwError = GetLastError();
    }


    if ( dwError == NO_ERROR) {

        //
        //  we got the directory listing.
        //  We need to apply filters to restrict the directory listing.
        //  Next we need to sort the resulting mix based on the
        //    sorting options requested by the list command.
        //

        //
        // We need to identify the appropriate filter
        //   file spec to be applied. For present use *.*
        // Filtering should not fail unless tsDirInfo is invalid.
        //

        if ( pfls != NULL) {

            DBG_REQUIRE(pTsDirInfo->FilterFiles(FtpFilterFileInfo,
                                                (LPVOID )pfls)
                        );
        }

        //
        // Sort only if sort function specified
        //

        if ( pfnCompare != NULL) {

            DBG_REQUIRE( pTsDirInfo->SortFileInfoPointers( pfnCompare));
        }
    }

    return ( dwError);
} // GetDirectoryInfo()




/**************************************************
 *   Comparison Functions
 **************************************************/


int __cdecl
CompareNamesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the two directory entries by name of the files.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);

    return ( lstrcmpi((LPCSTR )pFileInfo1->cFileName,
                      (LPCSTR )pFileInfo2->cFileName));

} // CompareNamesInFileInfo()



int __cdecl
CompareNamesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the two directory entries by name of the files.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     -1 if pvFileInfo1 > pvFileInfo2
     +1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
}   // CompareNamesRevInFileInfo()





int __cdecl
CompareWriteTimesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the write times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);


    INT nResult;

    nResult = CompareFileTime(&pFileInfo1->ftLastWriteTime,
                              &pFileInfo2->ftLastWriteTime );

    if( nResult == 0 ) {

        nResult = CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
    }

    return nResult;

}   // CompareWriteTimesInFileInfo()





int __cdecl
CompareWriteTimesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the write times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     -1 if pvFileInfo1 > pvFileInfo2
     +1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareWriteTimesInFileInfo( pvFileInfo1, pvFileInfo2);

}   // CompareWriteTimesRevInFileInfo()



int __cdecl
CompareCreationTimesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the creation times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);


    INT nResult;

    if ( NULL_FILE_TIME( pFileInfo1->ftCreationTime)) {

        nResult = CompareFileTime(&pFileInfo1->ftLastWriteTime,
                                  &pFileInfo2->ftLastWriteTime );
    } else {

        nResult = CompareFileTime(&pFileInfo1->ftCreationTime,
                                  &pFileInfo2->ftCreationTime );
    }

    if( nResult == 0 ) {

        nResult = CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
    }

    return nResult;

}   // CompareCreationTimesInFileInfo()



int __cdecl
CompareCreationTimesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the creation times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareCreationTimesInFileInfo( pvFileInfo1, pvFileInfo2 );

}   // CompareCreationTimesRevInFileInfo()



int __cdecl
CompareAccessTimesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the last access times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);


    INT nResult;

    if ( NULL_FILE_TIME( pFileInfo1->ftLastAccessTime)) {

        nResult = CompareFileTime(&pFileInfo1->ftLastWriteTime,
                                  &pFileInfo2->ftLastWriteTime );
    } else {

        nResult = CompareFileTime(&pFileInfo1->ftLastAccessTime,
                                  &pFileInfo2->ftLastAccessTime );
    }

    if( nResult == 0 ) {

        nResult = CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
    }

    return nResult;

}   // CompareAccessTimesInFileInfo()



int __cdecl
CompareAccessTimesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++

  Compares the last access times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareAccessTimesInFileInfo( pvFileInfo1, pvFileInfo2 );

}   // CompareAccessTimesRevInFileInfo()






DWORD
ComputeModeBits(
    IN HANDLE            hUserToken,
    IN const CHAR *      pszPathPart,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN DWORD           * pcLinks,
    IN BOOL              fVolumeReadable,
    IN BOOL              fVolumeWritable
    )
/*++
  This function computes the mode buts r-w-x for a specific file.

  Arguments:
    hUserToken   - The security token of the user that initiated the request.
    pszPathPart  - contains the search path for this directory.
    pfdInfo      - pointer to File information
    pcLinks      - will receive the count of symbolic links to this file.
    fVolumeReadable - TRUE if volume is readable
    fVolumeWritable - TRUE if volume is writable

  Returns:
    DWORD - A combination of FILE_MODE_R, FILE_MODE_W, and FILE_MODE_X bits.

  HISTORY:
    KeithMo     01-Jun-1993 Created.
    MuraliK     26-Apr-1995 Modified to support new pfdInfo
--*/
{
    APIERR err;
    DWORD  dwAccess;
    DWORD  dwMode = 0;

    DBG_ASSERT( hUserToken != NULL );
    DBG_ASSERT( pszPathPart != NULL );
    DBG_ASSERT( pfdInfo != NULL );
    DBG_ASSERT( pcLinks != NULL );
    DBG_ASSERT( pszPathPart[1] == ':' );
    DBG_ASSERT( pszPathPart[2] == '\\' );

    if( !( GetFsFlags( *pszPathPart ) & FS_PERSISTENT_ACLS ) )
    {
        //
        //  Short-circuit if on a non-NTFS partition.
        //

        *pcLinks = 1;
        dwAccess = FILE_ALL_ACCESS;

        err = NO_ERROR;
    }
    else
    {
        CHAR   szPath[MAX_PATH*2];
        CHAR * pszEnd;
        INT    len;

        //
        //  Determine the maximum file access allowed.
        //

        DBG_ASSERT( strlen( pszPathPart) +
                   strlen( pfdInfo->cFileName) < MAX_PATH * 2);

        len = strlen( pszPathPart );
        memcpy( szPath, pszPathPart, len );
        szPath[len] = '\0';
        pszEnd = CharPrev( szPath, szPath + len );
        if( *pszEnd != '\\' && *pszEnd != '/' ) {
            pszEnd = szPath + len;
            *pszEnd = '\\';
        }
        strcpy( pszEnd + 1, pfdInfo->cFileName );

        err = ComputeFileInfo( hUserToken,
                               szPath,
                               &dwAccess,
                               pcLinks );
    }

    if( err == NO_ERROR )
    {


        //
        //  Map various NT access to unix-like mode bits.
        //

        if( fVolumeReadable && ( dwAccess & FILE_READ_DATA ) )
        {
            dwMode |= FILE_MODE_R;
        }

        if( fVolumeReadable && ( dwAccess & FILE_EXECUTE ) )
        {
            dwMode |= FILE_MODE_X;
        }

        if( fVolumeWritable &&
            !( pfdInfo->dwFileAttributes & FILE_ATTRIBUTE_READONLY ) &&
            ( dwAccess & FILE_WRITE_DATA  ) &&
            ( dwAccess & FILE_APPEND_DATA ) )
        {
            dwMode |= FILE_MODE_W;
        }
    }

    return dwMode;

}   // ComputeModeBits()




#define DEFAULT_SECURITY_DESC_SIZE ( 2048)
#define DEFAULT_PRIV_SET_SIZE      ( 1024)


APIERR
ComputeFileInfo(
    HANDLE   hUserToken,
    CHAR   * pszFile,
    DWORD  * pdwAccessGranted,
    DWORD  * pcLinks
    )
/*++
  This function uses internal Nt security api's to determine if the
   valid access is granted.

  BEWARE: this function is extremely costly! We need to simplify the cost.
  ==>> NYI

  Arguments:
    hUserToken - handle for the user, for whom we are determining the
                    access and links
    pszFile  - full path for the file.
    pdwAccessGranted - pointer to DWORD which will receive the granted access.
    pcLinks - pointer to count of links for the file.

  Returns:
    Win32 Error code if there is any failure.
    NO_ERROR on success.
--*/
{
    NTSTATUS                    NtStatus;
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    APIERR                      err;
    SECURITY_DESCRIPTOR       * psd      = NULL;
    PRIVILEGE_SET             * pps      = NULL;
    DWORD                       cbsd;
    DWORD                       cbps;
    GENERIC_MAPPING             mapping  = { 0, 0, 0, FILE_ALL_ACCESS };
    HANDLE                      hFile    = INVALID_HANDLE_VALUE;
    BOOL                        fStatus;

    DBG_ASSERT( hUserToken != NULL );
    DBG_ASSERT( pszFile != NULL );
    DBG_ASSERT( pdwAccessGranted != NULL );
    DBG_ASSERT( pcLinks != NULL );

    //
    //  Setup.
    //

    *pdwAccessGranted = 0;
    *pcLinks          = 1;

    //
    //  Open the target file/directory.
    //

    err = OpenPathForAccess( &hFile,
                            pszFile,
                            GENERIC_READ,
                            ( FILE_SHARE_READ | FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE),
                            hUserToken
                            );

    if( err != NO_ERROR )
    {
        return err;
    }

    //
    //  Determine the number of symbolic links.
    //

    if ( GetFileInformationByHandle( hFile,
                                     &FileInfo)
        ) {

        *pcLinks = FileInfo.nNumberOfLinks;
    } else {

        //
        //  We won't let this be serious enough to abort
        //  the entire operation.
        //

        *pcLinks = 1;
    }

    //
    //  Get the file's security descriptor.
    //

    cbsd = DEFAULT_SECURITY_DESC_SIZE;
    psd  = (SECURITY_DESCRIPTOR *)TCP_ALLOC( cbsd );

    if( psd == NULL )
    {
        err = GetLastError();
        goto Cleanup;
    }

    do
    {
        err = NO_ERROR;

        //
        // Replace NtQuerySecurityObject() by GetFileSecurity()
        //

        if (!GetFileSecurity( pszFile,
                             OWNER_SECURITY_INFORMATION
                             | GROUP_SECURITY_INFORMATION
                             | DACL_SECURITY_INFORMATION,
                             psd,
                             cbsd,
                             &cbsd )
            ) {

            err = GetLastError();
        }

        if( err == ERROR_INSUFFICIENT_BUFFER )
        {
            TCP_FREE( psd );
            psd = (SECURITY_DESCRIPTOR *)TCP_ALLOC( cbsd );

            if( psd == NULL )
            {
                err = GetLastError();
                break;
            }
        }

    } while( err == ERROR_INSUFFICIENT_BUFFER );

    if( err != NO_ERROR ) {

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot get security for %s, error %lu\n",
                       pszFile,
                       err ));
        }

        goto Cleanup;
    }

    //
    //  Check access.
    //

    cbps = DEFAULT_PRIV_SET_SIZE;
    pps  = (PRIVILEGE_SET *)TCP_ALLOC( cbps );

    if( pps == NULL )
    {
        err = GetLastError();
        goto Cleanup;
    }

    do
    {
        if( AccessCheck( psd,
                         hUserToken,
                         MAXIMUM_ALLOWED,
                         &mapping,
                         pps,
                         &cbps,
                         pdwAccessGranted,
                         &fStatus ) )
        {
            err = fStatus ? NO_ERROR : GetLastError();

            if( err != NO_ERROR )
            {
                IF_DEBUG( DIR_LIST) {
                    DBGPRINTF(( DBG_CONTEXT,
                               "AccessCheck() failure. Error=%d\n", err ));
                }
                break;
            }
        }
        else
        {
            err = GetLastError();

            if( err == ERROR_INSUFFICIENT_BUFFER )
            {
                TCP_FREE( pps );
                pps = (PRIVILEGE_SET *)TCP_ALLOC( cbps );

                if( pps == NULL )
                {
                    err = GetLastError();
                    break;
                }
            }
        }

    } while( err == ERROR_INSUFFICIENT_BUFFER );

    if( err != NO_ERROR )
    {
        IF_DEBUG(DIR_LIST) {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot get check access for %s, error %lu\n",
                       pszFile,
                       err ));
        }

        goto Cleanup;
    }

Cleanup:

    if( psd != NULL )
    {
        TCP_FREE( psd );
    }

    if( pps != NULL )
    {
        TCP_FREE( pps );
    }

    if( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    }

    return err;

}   // ComputeFileInfo()





# define INVALID_FS_FLAGS        ((DWORD ) -1L)


DWORD
GetFsFlags( IN CHAR chDrive)
/*++

  This function uses GetVolumeInformation to retrieve the file system
    flags for the given drive.

  Arguments:
    chDrive   the drive letter to check for. Must be A-Z.

  Returns:
    DWORD containing the FS flags. 0 if unknown.

  History:
    MuraliK   25-Apr-1995
--*/
{
    INT      iDrive;
    DWORD    Flags = INVALID_FS_FLAGS;

    static DWORD  p_FsFlags[26] = {
        // One per DOS drive (A - Z).
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS
      };

    //
    //  Validate the parameter & map to uppercase.
    //

    chDrive = (INT)toupper( chDrive );
    DBG_ASSERT( ( chDrive >= 'A' ) && ( chDrive <= 'Z' ) );

    iDrive = (INT)( chDrive - 'A' );

    //
    //  If we've already touched this drive, use the
    //  cached value.
    //

    Flags = p_FsFlags[iDrive];

    if( Flags == INVALID_FS_FLAGS )
    {
        CHAR  szRoot[] = "d:\\";

        //
        //  Retrieve the flags.
        //

        szRoot[0] = chDrive;

        GetVolumeInformation( szRoot,       // lpRootPathName
                              NULL,         // lpVolumeNameBuffer
                              0,            // nVolumeNameSize
                              NULL,         // lpVolumeSerialNumber
                              NULL,         // lpMaximumComponentLength
                              &Flags,       // lpFileSystemFlags
                              NULL,         // lpFileSYstemNameBuffer,
                              0 );          // nFileSystemNameSize

        p_FsFlags[iDrive] = Flags;
    }

    return ( Flags == INVALID_FS_FLAGS ) ? 0 : Flags;

}   // GetFsFlags()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\newls.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/
/*
   newls.cxx

    Implements a simulated "ls" command for the FTP Server service,
     with buffering and possibly caching of the results generated.

    Functions exported by this module:

        SimulateLs()
        SpecialLs()

    FILE HISTORY:
        MuraliK     19-April-1995  Created.
*/

# include "ftpdp.hxx"
# include "tsunami.hxx"
# include "lsaux.hxx"
# include <mbstring.h>


/**********************************************************************
 *  Private Globals
 **********************************************************************/

// Following message is required to send error msg when the file
//  or directory is absent.
extern CHAR * p_NoFileOrDirectory;              // This lives in engine.c.

static const char * PSZ_DEFAULT_SEARCH_PATH = "";

static const char * PSZ_WILD_CHARACTERS = "*?<>";  // include DOS wilds!


/**********************************************************************
 *  Prototypes of Functions
 **********************************************************************/

DWORD
FormatFileInfoLikeMsdos(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO  * pFormatInfo
    );

DWORD
FormatFileInfoLikeUnix(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO *  pFormatInfo
    );


APIERR
SimulateLsWorker(
    IN USER_DATA * pUserData,
    IN BOOL       fUseDataSocket,
    IN CHAR *     pszSearchPath,
    IN const LS_OPTIONS * pOptions,
    IN BOOL       fSendHeader = FALSE,
    IN BOOL       fSendBlank  = FALSE
    );


APIERR
SpecialLsWorker(
    IN USER_DATA *pUserData,
    IN BOOL       fUseDataSocket,
    CHAR *        pszSearchPath,
    BOOL          fShowDirectories,
    IN OUT LS_BUFFER * plsb
    );


//
//  The following is a table consisting of the sort methods used
//   for generating various dir listing. The table is indexed by LS_SORT.
//  This is used for finding the appropriate compare function for
//   any given sort method.
//  THE ORDER OF FUNCTIONS IN THIS ARRAY MUST MATCH THE ORDER IN LS_SORT!
//

static PFN_CMP_WIN32_FIND_DATA CompareRoutines[] = {

    CompareNamesInFileInfo,              // Normal sort order.
    CompareWriteTimesInFileInfo,
    CompareCreationTimesInFileInfo,
    CompareAccessTimesInFileInfo,

    CompareNamesRevInFileInfo,           // Reversed sort order.
    CompareWriteTimesRevInFileInfo,
    CompareCreationTimesRevInFileInfo,
    CompareAccessTimesRevInFileInfo
  };

// method,direction are used for indexing.
#define SORT_INDEX(method, dirn)   ((INT)(method) + \
                                    ((dirn) ? (INT)MaxLsSort : 0))





/**********************************************************************
 *  Functions
 **********************************************************************/

static
BOOL
SeparateOutFilterSpec( IN OUT CHAR * szPath, IN BOOL fHasWildCards,
                       OUT LPCSTR * ppszFilterSpec)
/*++
  The path has the form  c:\ftppath\foo\bar\*.*
  Check to see if the path is already a directory.
  If so set filter as nothing.
  This function identifies the last "\" and terminates the
   path at that point. The remaining forms a filter (here: *.*)
--*/
{
    char * pszFilter;
    BOOL fDir = FALSE;

    IF_DEBUG( DIR_LIST) {
        DBGPRINTF((DBG_CONTEXT, "SeparateOutFilter( %s, %d)\n",
                   szPath, fHasWildCards));
    }

    DBG_ASSERT( ppszFilterSpec != NULL);
    *ppszFilterSpec = NULL;  // initialize.

    if ( !fHasWildCards) {

        // Identify if the path is a directory

        DWORD dwAttribs = GetFileAttributes( szPath);

        if ( dwAttribs == INVALID_FILE_ATTRIBUTES) {

            return ( FALSE);
        } else {

            fDir = ( IS_DIR(dwAttribs));
        }
    }

    if ( !fDir ) {
        pszFilter = (PCHAR)_mbsrchr( (PUCHAR)szPath, '\\');

        //This has to exist, since valid path was supplied.
        DBG_ASSERT( pszFilter != NULL);
        *pszFilter = '\0';  // terminate the old path.
        pszFilter++;        // skip past the terminating null character.

        *ppszFilterSpec = (*pszFilter == '\0') ? NULL : pszFilter;

        IF_DEBUG(DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, "Path = %s; Filter = %s\n",
                       szPath, *ppszFilterSpec));
        }
    }

    return (TRUE);

} // SeparateOutFilterSpec()




APIERR
SimulateLs(
    IN USER_DATA * pUserData,
    IN OUT CHAR *  pszArg,
    IN BOOL        fUseDataSocket,
    IN BOOL        fDefaultLong
    )
/*++
  This function simulates an LS command. This simulated ls command supports
    the following switches:

                    -C  = Multi column, sorted down.
                    -l  = Long format output.
                    -1  = One entry per line (default).
                    -F  = Directories have '/' appended.
                    -t  = Sort by time of last write.
                    -c  = Sort by time of creation.
                    -u  = Sort by time of last access.
                    -r  = Reverse sort direction.
                    -a  = Show all files (including .*).
                    -A  = Show all files (except . and ..).
                    -R  = Recursive listing.

  Arguments:
    pUserData  --  the user initiating the request.
    pszArg     --  contains the search path, preceded by switches.
      Note: The argument is destroyed during processing!!!!
    fUseDataSocket -- if TRUE use Data socket, else use control socket.
    fDefaultLong  -- should the default be long ? ( if TRUE)

  Returns:
    APIERR,   0 on success.
--*/
{
    APIERR      serr = 0;
    LS_OPTIONS   options;
    CHAR       * pszToken = pszArg;
    CHAR       * pszDelimiters = " \t";

    DBG_ASSERT( pUserData != NULL );

    //
    //  Setup default ls options.
    //

    options.OutputFormat  = (( fDefaultLong) ?
                             LsOutputLongFormat : LsOutputSingleColumn);
    options.SortMethod    = LsSortByName;
    options.fReverseSort  = FALSE;
    options.fDecorate     = FALSE;
    options.fShowAll      = FALSE;
    options.fShowDotDot   = FALSE;
    options.fRecursive    = FALSE;
    options.lsStyle       = ( TEST_UF( pUserData, MSDOS_DIR_OUTPUT)
                             ? LsStyleMsDos
                             : LsStyleUnix
                             );
    options.fFourDigitYear= TEST_UF( pUserData, 4_DIGIT_YEAR);

    //
    //  Process switches in the input, if any
    //

    // simplify things by skipping whitespace...

    if (pszArg && isspace(*pszArg)) {
        while (isspace(*pszArg))
            pszArg++;
    }

    // now we should be pointing to the options, or the filename

    if (pszArg && (*pszArg == '-')) {

        for( pszToken = strtok( pszArg, pszDelimiters ); // getfirst Tok.
            ( ( pszToken != NULL ) && ( *pszToken == '-' ) );
            pszToken  = strtok( NULL, pszDelimiters)     // get next token
            ) {

            DBG_ASSERT( *pszToken == '-' );

            // process all the switches in single token

            //  for( pszToken++; *pszToken;  pszToken++)  is written as follows
            while ( *++pszToken) {

                switch( *pszToken ) {

                  case 'C' :
                  case '1' :
                    options.OutputFormat = LsOutputSingleColumn;
                    break;

                  case 'l' :
                    options.OutputFormat = LsOutputLongFormat;
                    break;

                  case 'F' :
                    options.fDecorate = TRUE;
                    break;

                  case 'r' :
                    options.fReverseSort = TRUE;
                    break;

                  case 't' :
                    options.SortMethod = LsSortByWriteTime;
                    break;

                  case 'c' :
                    options.SortMethod = LsSortByCreationTime;
                    break;

                  case 'u' :
                    options.SortMethod = LsSortByAccessTime;
                    break;

                  case 'a' :
                    options.fShowAll    = TRUE;
                    options.fShowDotDot = TRUE;
                    break;

                  case 'A' :
                    options.fShowAll    = TRUE;
                    options.fShowDotDot = FALSE;
                    break;

                  case 'R' :
                    options.fRecursive = TRUE;
                    break;

                  default:
                    IF_DEBUG( COMMANDS ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                   "ls: skipping unsupported option '%c'\n",
                                   *pszToken ));
                    }
                    break;
                } // switch()
            } // process all switches in a token

        } // for
    }

    //
    //  If the user is requesting an MSDOS-style long-format listing,
    //  then enable display of "." and "..".  This will make the MSDOS-style
    //  long-format output look a little more like MSDOS.
    //

    options.fShowDotDot = ( options.fShowDotDot ||
                           ( options.lsStyle == LsStyleMsDos &&
                            ( options.OutputFormat == LsOutputLongFormat ))
                           );


    //
    // since LIST is sent out synchronously, bump up thread count
    //  before beginning to send out the response for LIST
    //
    // A better method:
    //   Make LIST generate response in a buffer and use async IO
    //   operations for sending response.
    //   TBD (To Be Done)
    //
    AtqSetInfo( AtqIncMaxPoolThreads, 0);


    //
    //  At this point, pszToken is either NULL or points
    //  to the first (of potentially many) LS search paths.
    //

        serr = SimulateLsWorker(pUserData, fUseDataSocket, pszToken, &options);
#if 0
    // the following code supported handling a list of files to send info
    // back for - delimited by spaces.  However, the spec doesn't support
    // multiple arguments on an LS call.

    if( pszToken == NULL ) {

        //
        // Get the directory listing for current directory.
        //  Send in NULL for the path to be listed.
        //

        serr = SimulateLsWorker(pUserData, fUseDataSocket, NULL, &options);

    } else {

        //
        // There is a sequence of tokens on the command line.
        //  Process them all.
        //
        BOOL  fSendHeader = FALSE;

        while( pszToken != NULL ) {

            CHAR * pszNextToken = strtok( NULL, pszDelimiters );

            //
            //  Send the directory.
            //
            serr = SimulateLsWorker(pUserData,
                                    fUseDataSocket,
                                    pszToken,
                                    &options,
                                    fSendHeader || (pszNextToken != NULL),
                                    fSendHeader);

            //
            //  If there are more directories to send,
            //  send a blank line as a separator.
            //

            pszToken    = pszNextToken;
            fSendHeader = TRUE; // turn on for subsequent sends

            if( TEST_UF( pUserData, OOB_DATA ) || ( serr != 0 ) )
            {
                break;
            }
        } // while
    } // multiple arguments
#endif

    //
    // bring down the thread count when response is completed
    // TBD: Use Async send reponse()
    //

    AtqSetInfo( AtqDecMaxPoolThreads, 0);


    return ( serr);
}   // SimulateLs()




APIERR
SpecialLs(
    USER_DATA * pUserData,
    CHAR      * pszArg,
    IN BOOL     fUseDataSocket
    )
/*++
  This produces a special form of the directory listing that is required
    when an NLST command is received with no switches. Most of the FTP clients
    require this special form in order to get the MGET and MDEL commands
    to work. This produces atmost one level of directory information.

  Arguments:
    pUserData  - the user initiating the request.
    pszArg     - pointer to null-terminated string containing the argument.
                  NULL=current directory for UserData.
    fUseDataSocket - if TRUE use Data Socket, else use the ContorlSocket.

  Returns:
    APIERR   - 0 if successful, !0 if not.
--*/
{
    APIERR     dwError = 0;
    LS_BUFFER   lsb;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( ( pszArg == NULL ) || ( *pszArg != '-' ) ); // No options



    if ((dwError = lsb.AllocateBuffer( DEFAULT_LS_BUFFER_ALLOC_SIZE))
        != NO_ERROR) {

        IF_DEBUG(ERROR) {

            DBGPRINTF((DBG_CONTEXT, "Buffer allocation(%d bytes) failed.\n",
                       DEFAULT_LS_BUFFER_ALLOC_SIZE));
        }

        return (dwError);
    }



    //
    // since LIST is sent out synchronously, bump up thread count
    //  before beginning to send out the response for LIST
    //
    // A better method:
    //   Make LIST generate response in a buffer and use async IO
    //   operations for sending response.
    //   TBD (To Be Done)
    //
    AtqSetInfo( AtqIncMaxPoolThreads, 0);


    //
    //  Let the worker do the dirty work.
    //
    dwError = SpecialLsWorker(pUserData,
                              fUseDataSocket,
                              pszArg,         // search path (no switches)
                              TRUE,           // show directories
                              &lsb);

#if 0
    // the following code supported handling a list of files to send info
    // back for - delimited by spaces.  However, the spec doesn't support
    // multiple arguments on an LS call.

    if( pszArg == NULL )
    {
        dwError = SpecialLsWorker(pUserData,
                                  fUseDataSocket,
                                  pszArg,         // search path (no switches)
                                  TRUE,           // show directories
                                  &lsb);
    }
    else
    {
        CHAR  * pszToken;
        CHAR  * pszDelimiters = " \t";

        dwError = NO_ERROR;
        for( pszToken = strtok( pszArg, pszDelimiters ); // get first token
             pszToken != NULL && dwError == NO_ERROR;
             pszToken = strtok( NULL, pszDelimiters)     // get next token
            ) {

            dwError = SpecialLsWorker(pUserData,
                                      fUseDataSocket,
                                      pszToken,   // search path (no switches)
                                      TRUE,       // show directories
                                      &lsb);

            if( TEST_UF( pUserData, OOB_DATA )) {

                break;
            }
        } // for
    }
#endif
    if ( dwError == NO_ERROR) {

        // send all the remaining bytes in the buffer and then free memory.

        if ( lsb.QueryCB() != 0) {

            SOCKET sock = ((fUseDataSocket) ? pUserData->QueryDataSocket() :
                           pUserData->QueryControlSocket());

            dwError = SockSend(pUserData, sock,
                               lsb.QueryBuffer(),
                               lsb.QueryCB()/sizeof(CHAR));
        }

        lsb.FreeBuffer();
    }


    //
    // bring down the thread count when response is completed
    // TBD: Use Async send reponse()
    //

    AtqSetInfo( AtqDecMaxPoolThreads, 0);

    return ( dwError);

}   // SpecialLs()





//
//  Private functions.
//
APIERR
SimulateLsWorker(
    USER_DATA  * pUserData,
    IN BOOL      fUseDataSocket,
    IN CHAR    * pszSearchPath,
    IN const LS_OPTIONS * pOptions,
    IN BOOL      fSendHeader,
    IN BOOL      fSendBlank
    )
/*++
   Worker function for SimulateLs function, forms directory listing
    for requested directory, formats the directory listing and
    sends it to the client.

   Arguments:
      pUserData - The user initiating the request.

      pszSearchPath - Search directory, NULL = current dir.

      pOptions - LS options set by command line switches.

      fSendHeader - if TRUE send header with directory name in it.
      fSendBlank  - also add a blank if there is one that has to be sent.

  Returns:
     APIERR - 0 if successful, !0 if not.

  HISTORY:
     MuraliK     24-Apr-1995 ReCreated.
--*/
{
    SOCKET        sock;
    BOOL          fLikeMsdos;
    CHAR          szSearch[MAX_PATH];
    CHAR        * pszFilePart;
    CHAR          rgchLowFileName[MAX_PATH];  // used for lower casing filename
    BOOL          fMapToLowerCase = FALSE;
    DWORD         dwAccessMask = 0;
    BOOL          fImpersonated = FALSE;

    LS_BUFFER     lsb;
    LS_FORMAT_INFO lsfi;        // required only for long formatting.

    BOOL          fHasWildCards   = FALSE;
    BOOL          fHasTrailingDot = FALSE;
    DWORD         dwError         = NO_ERROR;
    APIERR        serr            = 0;
    TS_DIRECTORY_INFO   tsDirInfo( pUserData->QueryInstance()->GetTsvcCache());


    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT, " SimulateLsWorker( %08x, %d, %s)\n",
                   pUserData, fUseDataSocket, pszSearchPath));
    }

    DBG_ASSERT( pUserData != NULL && pOptions != NULL);

    //
    // Check for emptiness of path or wildcards in search path.
    // We are only concerned about wild cards in user input. The reason
    //   is all trailing '.' will be removed when we canonicalize
    //   the path ( which user may not appreciate).
    //

    if ( IS_EMPTY_PATH(pszSearchPath)) {

        // we know pszSearchPath will not change the buffer!
        pszSearchPath = (char *) PSZ_DEFAULT_SEARCH_PATH;

    } else if (( pszSearchPath != NULL) &&
               ( strpbrk( pszSearchPath, PSZ_WILD_CHARACTERS ) != NULL)
               ){

        //
        //  Search path contains wildcards.
        //

        fHasWildCards = TRUE;
    }

    //
    //  Canonicalize the search path.
    //

    DWORD cbSize = MAX_PATH;
    dwError = pUserData->VirtualCanonicalize(szSearch, &cbSize,
                                             pszSearchPath,
                                             AccessTypeRead,
                                             &dwAccessMask);

    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);

    if( dwError == NO_ERROR ) {

        FTP_LS_FILTER_INFO  fls;  // required for generating directory listing
        PFN_CMP_WIN32_FIND_DATA  pfnCompare;

        //
        //  VirtualCanonicalize() when sanitizing the path removes
        //     trailing dots from the path. Replace them here
        //
        DBG_ASSERT( !fHasWildCards || strlen(pszSearchPath) >= 1);

        if( fHasWildCards && (pszSearchPath[strlen(pszSearchPath)-1] == '.')) {

            DBG_ASSERT( strlen(szSearch) < MAX_PATH - 1);
            strcat( szSearch, "." );
        }

        //
        //  Build the directory list.
        //

        pfnCompare = CompareRoutines[SORT_INDEX(pOptions->SortMethod,
                                                pOptions->fReverseSort)
                                     ];

        // Separate the filter out ( that is the last component)

        if (pUserData->ImpersonateUser() &&
            SeparateOutFilterSpec( szSearch, fHasWildCards, &fls.pszExpression)
            ) {

            fls.fFilterHidden = !pOptions->fShowAll;
            fls.fFilterSystem = !pOptions->fShowAll;
            fls.fFilterDotDot = !pOptions->fShowDotDot;

            fls.fRegExpression = ( fls.pszExpression != NULL && fHasWildCards);
            fls.fIgnoreCase    = pUserData->QueryInstance()->QueryLowercaseFiles();

            dwError = GetDirectoryInfo(pUserData,
                                       &tsDirInfo,
                                       szSearch,
                                       &fls,
                                       pfnCompare);

            pUserData->RevertToSelf();
        } else {

            dwError = GetLastError();
        }
    }

    //
    //  If there were any errors, tell them the bad news now.
    //

    if( dwError != NO_ERROR ) {

        return  (dwError);
    }

    sock  = ((fUseDataSocket) ? pUserData->QueryDataSocket() :
             pUserData->QueryControlSocket());

    DBG_ASSERT( tsDirInfo.IsValid());

    int cDirEntries = tsDirInfo.QueryFilesCount();

    if ( cDirEntries > 0) {

        //
        // put out the header block before starting dir listing
        //

        if( fSendHeader ) {

            serr = SockPrintf2( pUserData, sock,
                               "%s%s:",
                               (fSendBlank)? "\r\n" : "",  // send \r\n
                               pszSearchPath);

            if ( serr != 0) {

                return (serr);
            }
        }
    }

    fLikeMsdos  = (pOptions->lsStyle == LsStyleMsDos);

    lsfi.fFourDigitYear = pOptions->fFourDigitYear;

    if( !fLikeMsdos ) {

        //
        //  Initialize the information in lsfi if we are doing
        //   long format output.
        //

        if ( pOptions->OutputFormat == LsOutputLongFormat) {

            SYSTEMTIME    timeNow;
            BOOL fUserRead, fUserWrite;

            //
            //  Obtain the current time.
            //  The Unix-like output requires current year
            //

            GetLocalTime( &timeNow );

            lsfi.wCurrentYear = timeNow.wYear;
            lsfi.hUserToken   = TsTokenToImpHandle(pUserData->QueryUserToken());

            //
            // Since szSearch contains the complete path, we call
            //  PathAccessCheck directly without resolving
            //    from absolute to virtual
            //

            fUserRead  = TEST_UF( pUserData, READ_ACCESS);
            fUserWrite = TEST_UF( pUserData, WRITE_ACCESS);

            lsfi.fVolumeReadable =
              PathAccessCheck(AccessTypeRead,
                              dwAccessMask,
                              fUserRead,
                              fUserWrite);

            lsfi.fVolumeWritable =
              PathAccessCheck(AccessTypeWrite,
                              dwAccessMask,
                              fUserRead,
                              fUserWrite);


            lsfi.pszPathPart = szSearch;
            lsfi.pszFileName = NULL;
            lsfi.pszDecorate = NULL;
        } // if ( long format output)

        //
        // We need to be impersonated only for UNIX-style listing.
        //  For UNIX style listing, we make some NTsecurity queries
        //   and they work only under the context of an impersonation.
        //

        if ( !(fImpersonated = pUserData->ImpersonateUser())) {

            dwError = GetLastError();
        }
    }

    //
    //  Loop for each directory entry
    //

    if (dwError != NO_ERROR ||
        (dwError = lsb.AllocateBuffer( DEFAULT_LS_BUFFER_ALLOC_SIZE))
        != NO_ERROR) {

        IF_DEBUG(ERROR) {

            DBGPRINTF((DBG_CONTEXT,
                       "Impersonation or Buffer allocation(%d bytes)",
                       " failed.\n",
                       DEFAULT_LS_BUFFER_ALLOC_SIZE));
        }

        if ( fImpersonated) {

            pUserData->RevertToSelf();
        }

        return (dwError);
    }

    //
    //  Only map to lower case if not a remote drive AND the lower-case file
    //  names flag is set AND this is not a case perserving file system.
    //

    if (*szSearch != '\\') {
        fMapToLowerCase = pUserData->QueryInstance()->QueryLowercaseFiles();
    }

    for( int idx = 0; serr == 0 && idx < cDirEntries; idx++) {

        const WIN32_FIND_DATA * pfdInfo = tsDirInfo[idx];
        DBG_ASSERT( pfdInfo != NULL);
        const CHAR * pszFileName = pfdInfo->cFileName;
        DWORD dwAttribs = pfdInfo->dwFileAttributes;

        //
        //  Dump it.
        //

        // We may need to convert all filenames to lower case if so desired!!
        if( fMapToLowerCase ) {

            //
            // copy file name to local scratch and change the ptr pszFileName
            // because we cannot destroy pfdInfo->cFileName
            //
            strcpy( rgchLowFileName, pszFileName);
            CharLower( rgchLowFileName);
            pszFileName = rgchLowFileName;
        }

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF((DBG_CONTEXT, "Dir list for %s\n",
                       pszFileName));
        }

        //
        // Send the partial data obtained so far.
        //  Use buffering to minimize number of sends occuring
        //

        if ( dwError == NO_ERROR) {

            if ( lsb.QueryRemainingCB() < MIN_LS_BUFFER_SIZE) {

                // send the bytes available in buffer and reset the buffer
                serr = SockSend(pUserData, sock,
                                lsb.QueryBuffer(), lsb.QueryCB()/sizeof(CHAR));
                lsb.ResetAppendPtr();
            }

        } else {

            serr = dwError;
        }

        //
        //  Check for socket errors on send or pending OOB data.
        //

        if( TEST_UF( pUserData, OOB_DATA ) || ( serr != 0 ) )
        {
            break;
        }


        CHAR * pszDecorate = ( (pOptions->fDecorate && IS_DIR(dwAttribs) )
                            ? "/" : "");

        if( pOptions->OutputFormat == LsOutputLongFormat )
        {
            FILETIME ftLocal;

            //
            //  Long format output.  Just send the file/dir info.
            //

            //
            //  Map the file's last write time to (local) system time.
            //
            if ( !FileTimeToLocalFileTime(
                     PickFileTime( pfdInfo, pOptions),
                     &ftLocal) ||
                 ! FileTimeToSystemTime(
                                       &ftLocal,
                                       &lsfi.stFile)
                ) {

                dwError = GetLastError();

                IF_DEBUG( ERROR) {
                    DBGPRINTF(( DBG_CONTEXT,
                               "Error in converting largeintger time %lu\n",
                               dwError));
                }
            } else {

                lsfi.pszDecorate = pszDecorate;
                lsfi.pszFileName = pszFileName;

                if( fLikeMsdos ) {

                    dwError = FormatFileInfoLikeMsdos(&lsb,
                                                      pfdInfo,
                                                      &lsfi);

                    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);
                } else {

                    dwError = FormatFileInfoLikeUnix(&lsb,
                                                     pfdInfo,
                                                     &lsfi);

                    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);
                }
            }

        } else {

            //
            //  Short format output.
            //

            DWORD cchSize = wsprintfA(lsb.QueryAppendPtr(), "%s%s\r\n",
                                      pszFileName, pszDecorate);
            lsb.IncrementCB( cchSize * sizeof(CHAR));
        }

    } // for()

    //
    // Get out of being impersonated.
    //
    if ( fImpersonated) {

        pUserData->RevertToSelf();
    }

    if ( dwError == NO_ERROR) {

        // send all the remaining bytes in the buffer and then free memory.

        if ( lsb.QueryCB() != 0) {

            serr = SockSend(pUserData, sock,
                            lsb.QueryBuffer(), lsb.QueryCB()/sizeof(CHAR));
        }

        lsb.FreeBuffer();
    } else {

        return ( dwError);  // an error has occured. stop processing
    }


    if( serr == 0 && !TEST_UF( pUserData, OOB_DATA) && pOptions->fRecursive )
    {
        //
        //  The user want's a recursive directory search...
        //

        CHAR   szOriginal[ MAX_PATH*2];
        CHAR * pszOriginalFilePart;


        // Obtain a copy of the path in the szOriginal so that we
        //  can change it while recursively calling ourselves.

        if ( pszSearchPath == PSZ_DEFAULT_SEARCH_PATH) {

            // means that we had all files/dir of current directory.

            strcpy( szOriginal, fLikeMsdos ? ".\\" : "./" );

        } else {

            DBG_ASSERT( strlen(pszSearchPath) < MAX_PATH);
            strcpy( szOriginal, pszSearchPath );

            // strip off the wild cards if any present
            if( fHasWildCards )
              {
                  CHAR * pszTmp;

                  pszTmp = (PCHAR)_mbsrchr( (PUCHAR)szOriginal, '\\');

                  pszTmp = pszTmp ? pszTmp : strrchr( szOriginal, '/' );
                  pszTmp = pszTmp ? pszTmp : strrchr( szOriginal, ':' );

                  pszTmp = ( pszTmp) ? pszTmp+1 : szOriginal;

                  *pszTmp = '\0';
              } else {
                  CHAR ch;
                  int cb = strlen( szOriginal);

                  DBG_ASSERT( cb > 0);
                  ch = *CharPrev( szOriginal, szOriginal + cb );
                  if( !IS_PATH_SEP( ch ) ) {

                      // to add "/"
                      DBG_ASSERT( strlen( szOriginal) + 2 < MAX_PATH);
                      strcat( szOriginal, fLikeMsdos ? "\\" : "/" );
                  }
              }
        }

        pszOriginalFilePart = szOriginal + strlen(szOriginal);

        DBG_ASSERT( tsDirInfo.IsValid());
        DBG_ASSERT( cDirEntries == tsDirInfo.QueryFilesCount());

        for( int idx = 0; serr == 0 && idx < cDirEntries; idx++) {

            const WIN32_FIND_DATA * pfdInfo = tsDirInfo[idx];
            DBG_ASSERT( pfdInfo != NULL);
            const char * pszFileName = pfdInfo->cFileName;
            DWORD dwAttribs = pfdInfo->dwFileAttributes;

            //
            //  Filter out non-directories.
            //

            if( !IS_DIR( dwAttribs) ) {

                continue;
            }

            //
            //  Dump it.
            //

            DBG_ASSERT( strlen( pszOriginalFilePart) + strlen(pszFileName)
                       < MAX_PATH * 2);
            strcpy( pszOriginalFilePart, pszFileName );

            serr = SimulateLsWorker(pUserData,
                                    fUseDataSocket,
                                    szOriginal,
                                    pOptions,
                                    TRUE, TRUE);

            //
            //  Check for socket errors on send or pending OOB data.
            //

            if( TEST_UF( pUserData, OOB_DATA ) || ( serr != 0 ) )
              {
                  break;
              }

        } // for( directory looping)

    } // if ( fRecursive)


    // At the end of directory listing. Return back.

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "SimulateLsWorker() for User %08x, Dir %s returns %d\n",
                   pUserData, pszSearchPath, serr));
    }


    return serr;
}   // SimulateLsWorker()




APIERR
SpecialLsWorker(
    USER_DATA * pUserData,
    IN BOOL     fUseDataSocket,
    CHAR      * pszSearchPath,
    BOOL        fShowDirectories,
    IN OUT LS_BUFFER * plsb
    )
/*++
  This is the worker function for Special Ls function. It is similar to
   the the SimulateLsWorker, only in that it shows directory if the
   fShowDirectories flag is set.

  The reason for this comes from a special FTP command which inquires about
    all the files in the first level and second level of current directory,
    which is not a recursive listing at all. This function when it recursively
    calls itself, always sets the fShowDirectories as FALSE.

  Arguments:
    pUserData     pointer to user data object that initiated the request.
    fUseDataSocket  if TRUE use DataSocket of UserData else
                       use the control socket of UserData.
    pszSearchPath  pointer to null-terminated string for requested directory.
                       NULL means use current directory.
    fShowDirectories  only show directories if TRUE.
    plsb          pointer to buffer to accumulate the data generated and send
                     it out in a single bulk.

  Returns:
    APIERR   0  if successful.

  History:
     KeithMo     17-Mar-1993 Created.
     MuraliK     26-Apr-1995 ReCreated to use new way of generation.
--*/
{
    CHAR        chSeparator;
    CHAR  *     pszRecurse;
    SOCKET      sock;
    BOOL        fHasWildCards = FALSE;
    DWORD       dwError       = NO_ERROR;
    TS_DIRECTORY_INFO  tsDirInfo( pUserData->QueryInstance()->GetTsvcCache());
    CHAR        szSearch[MAX_PATH];
    CHAR        szRecurse[MAX_PATH];
    BOOL        fMapToLowerCase = FALSE;
    CHAR        rgchLowFileName[MAX_PATH];  // used for lower casing filename
    BOOL        fHadOneComponent = FALSE;

    DBG_ASSERT( pUserData != NULL);

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "Entering SpecialLsWorker( %08x, %s)\n",
                   pUserData, pszSearchPath));
    }


    chSeparator = TEST_UF( pUserData, MSDOS_DIR_OUTPUT ) ? '\\' : '/';

    //
    //  Check for wildcards in search path.
    //

    if( ( pszSearchPath != NULL ) && ( *pszSearchPath != '\0' ) )
    {
        //
        //  Setup for recursive directory search.  We'll set things up
        //  so we can strcpy a new directory to pszRecurse, then
        //  recursively call ourselves with szRecurse as the search
        //  path.
        //
        //  We also use szRecurse as a "prefix" to display before each
        //  file/directory.  The FTP Client software needs this for the
        //  MDEL & MGET commands.
        //
        if ( strlen(pszSearchPath) >= MAX_PATH -1 )
        {
            return ERROR_BUFFER_OVERFLOW;
        }

        strcpy( szRecurse, pszSearchPath );

        // get slash.
        pszRecurse = (PCHAR)_mbsrchr( (PUCHAR)szRecurse, '\\');
        pszRecurse = ((pszRecurse == NULL) ?
                      strrchr( szRecurse, '/') : pszRecurse);
        fHadOneComponent = (pszRecurse == NULL);

        if( strpbrk( szRecurse, PSZ_WILD_CHARACTERS) != NULL )
        {
            //
            //  Search path contains wildcards.
            //

            fHasWildCards = TRUE;

            // we do not care about components when wild card is present
            fHadOneComponent = FALSE;

            //
            //  Strip the wildcard pattern from the search path.
            // look for both kind of slashes ( since precanonicalized)
            //

            //
            // If we found right-most dir component, skip path separator
            //  else set it to start of search path.
            //
            pszRecurse = ( ( pszRecurse != NULL)
                          ? pszRecurse + 1
                          : szRecurse
                          );
        } else {

            //
            //  No wildcards, so the argument must be a path.
            //  Ensure it is terminated with a path separator.
            //

            pszRecurse = CharPrev( szRecurse, szRecurse + strlen(szRecurse) );

            if( !IS_PATH_SEP( *pszRecurse ) )
            {
                *++pszRecurse = chSeparator;
            }

            pszRecurse++;  // skip the path separator
        }
    } else {

        //
        //  No arguments.
        //

        pszRecurse = szRecurse;


        //
        //  Munge the arguments around a bit.  NULL = *.* in current
        //  directory.  If the user specified a directory (like d:\foo)
        //  then append *.*.
        //

        pszSearchPath = (char *) PSZ_DEFAULT_SEARCH_PATH;
    }

    *pszRecurse = '\0';

    //
    //  Canonicalize the search path.
    //
    DWORD cbSize = MAX_PATH;
    dwError = pUserData->VirtualCanonicalize(szSearch, &cbSize,
                                             pszSearchPath,
                                             AccessTypeRead);

    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);

    if( dwError == NO_ERROR ) {

        FTP_LS_FILTER_INFO  fls;  // required for generating directory listing
        LPCSTR  pszFilter = NULL;

        //
        //  VirtualCanonicalize() when sanitizing the path removes
        //     trailing dots from the path. Replace them here
        //

        if( fHasWildCards && (pszSearchPath[strlen(pszSearchPath)-1] == '.')) {

            strcat( szSearch, "." );
        }

        //
        //  Build the directory list.
        //

        if (pUserData->ImpersonateUser() &&
            SeparateOutFilterSpec( szSearch, fHasWildCards, &fls.pszExpression)
            ) {

            fls.fFilterHidden = TRUE;
            fls.fFilterSystem = TRUE;
            fls.fFilterDotDot = TRUE;

            fls.fRegExpression = ( fls.pszExpression != NULL && fHasWildCards);
            fls.fIgnoreCase    = pUserData->QueryInstance()->QueryLowercaseFiles();


            dwError = GetDirectoryInfo(pUserData,
                                       &tsDirInfo,
                                       szSearch,
                                       &fls,
                                       NULL);  // unsorted list

            pUserData->RevertToSelf();

        } else {

            dwError = GetLastError();
        }
    }

    //
    //  If there were any errors, tell them the bad news now.
    //

    if( dwError != NO_ERROR ) {

        return  ( dwError);
    }

    if ( fHadOneComponent) {

        // HARD CODE! Spend some time and understand this....

        //
        // Adjust the szRecurse buffer to contain appropriate path
        //  such that in presence of one component we generate proper
        //  result.
        //

        // the given path is either invalid or non-directory
        //  so reset the string stored in szRecurse.
        szRecurse[0] = '\0';
        pszRecurse = szRecurse;
    }


    //
    //  Only map to lower case if not a remote drive AND the lower-case file
    //  names flag is set AND this is not a case perserving file system.
    //

    if (*szSearch != '\\') {
        fMapToLowerCase = pUserData->QueryInstance()->QueryLowercaseFiles();
    }

    //
    //  Loop until we're out of files to find.
    //

    sock = ((fUseDataSocket) ? pUserData->QueryDataSocket() :
            pUserData->QueryControlSocket());

    int cDirEntries = tsDirInfo.QueryFilesCount();

    for( int idx = 0; dwError == NO_ERROR && idx < cDirEntries; idx++) {

        const WIN32_FIND_DATA * pfdInfo = tsDirInfo[idx];
        DBG_ASSERT( pfdInfo != NULL);
        const CHAR * pszFileName = pfdInfo->cFileName;
        DWORD dwAttribs = pfdInfo->dwFileAttributes;

        if ( !fShowDirectories && IS_DIR( dwAttribs)) {

            continue;
        }

        //
        //  Dump it.
        //

        // We may need to convert all filenames to lower case if so desired!!
        if( fMapToLowerCase ) {

            //
            // copy file name to local scratch and change the ptr pszFileName
            // because we cannot destroy pfdInfo->cFileName
            //
            strcpy( rgchLowFileName, pszFileName);
            CharLower( rgchLowFileName );
            pszFileName = rgchLowFileName;
        }

        //
        // Send the partial data obtained so far.
        //  Use buffering to minimize number of sends occuring
        //

        if ( dwError == NO_ERROR) {

            if ( plsb->QueryRemainingCB() < MIN_LS_BUFFER_SIZE) {

                // send the bytes available in buffer and reset the buffer
                dwError = SockSend(pUserData, sock,
                                   plsb->QueryBuffer(),
                                   plsb->QueryCB()/sizeof(CHAR));
                plsb->ResetAppendPtr();
            }

        }

        //
        //  Test for aborted directory listing or socket error.
        //

        if( TEST_UF( pUserData, OOB_DATA ) || ( dwError != NO_ERROR ) )
        {
            break;
        }

        //
        //  If no wildcards were given, then just dump out the
        //  file/directory.  If wildcards were given, AND this
        //  is a directory, then recurse (one level only) into
        //  the directory.  The mere fact that we don't append
        //  any wildcards to the recursed search path will
        //  prevent a full depth-first recursion of the file system.
        //

        if( fHasWildCards && IS_DIR(dwAttribs) ) {

            DBG_ASSERT(strcmp( pszFileName, "." ) != 0);
            DBG_ASSERT(strcmp( pszFileName, "..") != 0);

            DBG_ASSERT(strlen(szRecurse)+strlen( pszFileName) < MAX_PATH);
            strcpy( pszRecurse, pszFileName );
            strcat( pszRecurse, "/"); // indicating this is a directory

            dwError = SpecialLsWorker(pUserData,
                                      fUseDataSocket,
                                      szRecurse,
                                      FALSE,
                                      plsb);
        } else {

            DWORD cchSize;

            *pszRecurse = '\0';  // as a side effect this terminates szRecurse.

            //
            //  Short format output.
            //

            cchSize = wsprintfA(plsb->QueryAppendPtr(),
                                "%s%s\r\n",
                                szRecurse,
                                pszFileName);
            plsb->IncrementCB( cchSize*sizeof(CHAR));

        }

    } // for


    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "Leaving SpecialLsWorker() with Error = %d\n",
                   dwError));
    }

    return (dwError);

}   // SpecialLsWorker()




/**************************************************
 *   Formatting functions.
 **************************************************/



DWORD
FormatFileInfoLikeMsdos(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO  * pFormatInfo
    )
/*++

  Forms an MSDOS like directory entry for the given dir info object.

  Arguments:

    plsb    pointer to buffer into which the dir line is generated.

    pfdInfo    pointer to dir information element.
    pFormatInfo pointer to information required for formatting.
     ( use the file name in pFormatInfo, becauze it may have been
       made into lower case if necessary)

  Returns:
    Win32 error code and NO_ERROR on success.

  History:
    MuraliK      25-Apr-1995
--*/
{
    DWORD        dwError = NO_ERROR;
    CHAR         szSizeOrDir[32];
    BOOL         fDir;
    DWORD        cbReqd;

    DBG_ASSERT(plsb != NULL && pfdInfo != NULL   && pFormatInfo != NULL);

    if ( IS_DIR( pfdInfo->dwFileAttributes)) {

        strcpy( szSizeOrDir, "<DIR>         " );
    } else {

        LARGE_INTEGER li;
        li.HighPart = pfdInfo->nFileSizeHigh;
        li.LowPart  = pfdInfo->nFileSizeLow;

        IsLargeIntegerToDecimalChar( &li, szSizeOrDir);
    }

    DBG_ASSERT( strlen(szSizeOrDir) <= 20);

    cbReqd = ( 10       // size for the date field
              + 10      // size for time field
              + 20      // space for size/dir
              + strlen( pFormatInfo->pszFileName)
              + 8       // addl space + decoration ...
              ) * sizeof(CHAR);

    DBG_ASSERT( cbReqd <= MIN_LS_BUFFER_SIZE);

    if ( cbReqd < plsb->QueryRemainingCB()) {

        register const SYSTEMTIME * pst = &pFormatInfo->stFile;
        WORD   wHour;
        char * pszAmPm;
        DWORD  cchUsed;

        wHour   = pst->wHour;
        pszAmPm = ( wHour < 12 ) ? "AM" : "PM";

        if ( wHour == 0 ) {            wHour = 12;  }
        else if ( wHour > 12) {        wHour -= 12; }

        if (pFormatInfo->fFourDigitYear) {
            cchUsed = wsprintfA(plsb->QueryAppendPtr(),
                           "%02u-%02u-%04u  %02u:%02u%s %20s %s%s\r\n",
                           pst->wMonth,
                           pst->wDay,
                           pst->wYear,
                           wHour,
                           pst->wMinute,
                           pszAmPm,
                           szSizeOrDir,
                           pFormatInfo->pszFileName,
                           pFormatInfo->pszDecorate);
        }
        else {
            cchUsed = wsprintfA(plsb->QueryAppendPtr(),
                           "%02u-%02u-%02u  %02u:%02u%s %20s %s%s\r\n",
                           pst->wMonth,
                           pst->wDay,
                           pst->wYear%100,  //instead of wYear - 1900
                           wHour,
                           pst->wMinute,
                           pszAmPm,
                           szSizeOrDir,
                           pFormatInfo->pszFileName,
                           pFormatInfo->pszDecorate);
        }

        DBG_ASSERT( cchUsed * sizeof(CHAR) <= cbReqd);
        plsb->IncrementCB(cchUsed * sizeof(CHAR));

    } else {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    }


    return ( dwError);

}   // FormatFileInfoLikeMsdos()




DWORD
FormatFileInfoLikeUnix(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO * pFormatInfo
    )
/*++
  This function formats file information for a UNIX stle client.

  Arguments:

    plsb        pointer to buffer into which the dir line is generated.
    pfdInfo     pointer to dir information element.
    pFormatInfo pointer to information required for long formatting.

  Returns:
    Win32 error code and NO_ERROR on success.

  History:
    MuraliK      25-Apr-1995
--*/
{
    DWORD         dwError = NO_ERROR;
    CHAR        * pszFileOwner;
    CHAR        * pszFileGroup;
    const SYSTEMTIME * pst;
    DWORD         dwMode;
    DWORD         cLinks;
    NTSTATUS      status;
    LARGE_INTEGER li;
    CHAR          attrib[4];
    CHAR          szTimeOrYear[12];
    CHAR          szSize[32];

    DWORD         cbReqd;

    static CHAR * apszMonths[] = { "   ", "Jan", "Feb", "Mar", "Apr",
                                   "May", "Jun", "Jul", "Aug", "Sep",
                                   "Oct", "Nov", "Dec" };

    DBG_ASSERT( plsb != NULL);
    DBG_ASSERT( pFormatInfo != NULL );
    DBG_ASSERT( pFormatInfo->hUserToken != NULL );
    DBG_ASSERT( pFormatInfo->pszPathPart != NULL );
    DBG_ASSERT( pfdInfo != NULL );


    //
    //  Build the attribute triple.  Note that we only build one,
    //  and replicate it three times for the owner/group/other fields.
    //

    dwMode = ComputeModeBits( pFormatInfo->hUserToken,
                              pFormatInfo->pszPathPart,
                              pfdInfo,
                              &cLinks,
                              pFormatInfo->fVolumeReadable,
                              pFormatInfo->fVolumeWritable );

    attrib[0] = ( dwMode & FILE_MODE_R ) ? 'r' : '-';
    attrib[1] = ( dwMode & FILE_MODE_W ) ? 'w' : '-';
    attrib[2] = ( dwMode & FILE_MODE_X ) ? 'x' : '-';
    attrib[3] = '\0';

    pst = &pFormatInfo->stFile;

    // NYI: can we make the following a single wsprintf call ??
    if( pst->wYear == pFormatInfo->wCurrentYear ) {

        //
        //  The file's year matches the current year, so
        //  display the hour & minute of the last write.
        //

        wsprintfA( szTimeOrYear, "%2u:%02u", pst->wHour, pst->wMinute );
    } else {

        //
        //  The file's year does not match the current
        //  year, so display the year of the last write.
        //

        wsprintfA( szTimeOrYear, "%4u", pst->wYear );
    }

    //
    //  CODEWORK:  How expensive would it be do
    //  get the proper owner & group names?
    //

    pszFileOwner = "owner";
    pszFileGroup = "group";

    //
    //  Get the size in a displayable form.
    //

    li.HighPart = pfdInfo->nFileSizeHigh;
    li.LowPart  = pfdInfo->nFileSizeLow;

    IsLargeIntegerToDecimalChar( &li, szSize);

    //
    //  Dump it.
    //
    DBG_ASSERT( strlen(szSize) <= 12);
    cbReqd = ( 3*strlen(attrib) + strlen( pszFileOwner)
              + strlen( pszFileGroup) + 12 + 20 // date
              + strlen( pFormatInfo->pszFileName)
              + strlen( pFormatInfo->pszDecorate) + 20 // 20 for spaces etc.
              ) * sizeof(CHAR);
    DBG_ASSERT( cbReqd < MIN_LS_BUFFER_SIZE);

    if ( cbReqd < plsb->QueryRemainingCB()) {

        DWORD cchUsed = wsprintfA( plsb->QueryAppendPtr(),
                          "%c%s%s%s %3lu %-8s %-8s %12s %s %2u %5s %s%s\r\n",
                          (IS_DIR(pfdInfo->dwFileAttributes) ? 'd' : '-'),
                          attrib,
                          attrib,
                          attrib,
                          cLinks,
                          pszFileOwner,
                          pszFileGroup,
                          szSize,
                          apszMonths[pst->wMonth],
                          pst->wDay,
                          szTimeOrYear,
                          pFormatInfo->pszFileName,
                          pFormatInfo->pszDecorate);

        DBG_ASSERT( cchUsed * sizeof(CHAR) <= cbReqd);
        plsb->IncrementCB( cchUsed*sizeof(CHAR));

    } else {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    }

    return ( dwError);

}   // FormatFileInfoLikeUnix()

/************************ End of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for the FTPD Service.

    Functions exported by this module:

        ServiceEntry


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        KeithMo     07-Jan-1994 Made it a DLL (part of TCPSVCS.EXE).
        MuraliK     21-March-1995 Modified it to use InternetServices
                                        common dll ( tcpsvcs.dll)
        MuraliK     11-April-1995 Added global ftp server config objects etc.
                       ( removed usage of Init and Terminate UserDatabase)

*/


#include <ftpdp.hxx>
#include <apiutil.h>
#include <inetsvcs.h>

//
//  Private constants.
//

#define FTPD_MODULE_NAME_A          "ftpsvc2.dll"
#define DEFAULT_RECV_BUFFER_SIZE    (8192)

//
// Global variables for service info and debug variables.
//

DEFINE_TSVC_INFO_INTERFACE( );
DECLARE_DEBUG_PRINTS_OBJECT();
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisFtpGuid, 
0x784d891F, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif

//
// The following critical section synchronizes execution in ServiceEntry().
// This is necessary because the NT Service Controller may reissue a service
// start notification immediately after we have set our status to stopped.
// This can lead to an unpleasant race condition in ServiceEntry() as one
// thread cleans up global state as another thread is initializing it.
//

CRITICAL_SECTION g_csServiceEntryLock;

//
//  Private prototypes.
//

APIERR
InitializeService(
    LPVOID lpContext
    );

APIERR
TerminateService(
    LPVOID lpContext
    );

extern
VOID
FtpdNewConnection(
    IN SOCKET sNew,
    IN SOCKADDR_IN * psockaddr,
    IN PVOID EndpointContext,
    IN PVOID EndpointObject
    );


extern
VOID
FtpdNewConnectionEx(
    IN PVOID        patqContext,
    IN DWORD        cbWritten,
    IN DWORD        dwError,
    IN OVERLAPPED * lpo
    );


DWORD
PrintOutCurrentTime(
            IN CHAR * pszFile,
            IN int lineNum
            );

# ifdef CHECK_DBG
# define PRINT_CURRENT_TIME_TO_DBG()  PrintOutCurrentTime( __FILE__, __LINE__)
# else
# define PRINT_CURRENT_TIME_TO_DBG()  ( NO_ERROR)
# endif // CHECK_DBG



VOID
ServiceEntry(
    DWORD                   cArgs,
    LPSTR                   pArgs[],
    PTCPSVCS_GLOBAL_DATA    pGlobalData     // unused
    )
/*++

    Routine:
        This is the "real" entrypoint for the service.  When
                the Service Controller dispatcher is requested to
                start a service, it creates a thread that will begin
                executing this routine.

    Arguments:
        cArgs - Number of command line arguments to this service.

        pArgs - Pointers to the command line arguments.

    Returns:
        None.  Does not return until service is stopped.

--*/
{
    APIERR err = NO_ERROR;
    BOOL fInitSvcObject = FALSE;

    EnterCriticalSection( &g_csServiceEntryLock );

    if ( !InitCommonDlls() )
    {
        err = GetLastError();
        LeaveCriticalSection( &g_csServiceEntryLock );
        goto notify_scm;
    }

    //
    //  Initialize the service status structure.
    //

    g_pInetSvc = new FTP_IIS_SERVICE(
                            FTPD_SERVICE_NAME,
                            FTPD_MODULE_NAME_A,
                            FTPD_PARAMETERS_KEY_A,
                            INET_FTP_SVC_ID,
                            INET_FTP_SVCLOC_ID,
                            FALSE,
                            0,
                            FtpdNewConnection,
                            FtpdNewConnectionEx,
                            ProcessAtqCompletion
                            );

    //
    //  If we couldn't allocate memory for the service info structure,
    //  then we're totally hozed.
    //

    if( (g_pInetSvc != NULL) && g_pInetSvc->IsActive() ) {
        fInitSvcObject = TRUE;

        //
        //  Start the service. This blocks until the service is shutdown.
        //

        err = g_pInetSvc->StartServiceOperation(
                                    SERVICE_CTRL_HANDLER(),
                                    InitializeService,
                                    TerminateService
                                    );

        if( err != NO_ERROR) {

            //
            //  The event has already been logged.
            //

            DBGPRINTF(( DBG_CONTEXT,
                       "FTP ServiceEntry: StartServiceOperation returned %d\n",
                       err ));
        }

    } else {

        if ( g_pInetSvc ) {
            err = g_pInetSvc->QueryCurrentServiceError();
        } else {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
        

    if( g_pInetSvc != NULL ) {

        //
        // delete the service object
        //

        g_pInetSvc->CloseService( );
        g_pInetSvc = NULL;
    }

    TerminateCommonDlls();
    LeaveCriticalSection( &g_csServiceEntryLock );    

notify_scm:
    //
    // We need to tell the Service Control Manager that the service
    // is stopped if we haven't called g_pInetSvc->StartServiceOperation.
    //  1) InitCommonDlls fails, or
    //  2) new operator failed, or
    //  3) FTP_IIS_SERVICE constructor couldn't initialize properly
    //

    if ( !fInitSvcObject ) {
        SERVICE_STATUS_HANDLE hsvcStatus;
        SERVICE_STATUS svcStatus;

        hsvcStatus = RegisterServiceCtrlHandler( FTPD_SERVICE_NAME,
                                                 SERVICE_CTRL_HANDLER() );


        if ( hsvcStatus != NULL_SERVICE_STATUS_HANDLE ) {
            svcStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
            svcStatus.dwCurrentState = SERVICE_STOPPED;
            svcStatus.dwWin32ExitCode = err;
            svcStatus.dwServiceSpecificExitCode = err;
            svcStatus.dwControlsAccepted = 0;
            svcStatus.dwCheckPoint = 0;
            svcStatus.dwWaitHint = 0;

            SetServiceStatus( hsvcStatus, (LPSERVICE_STATUS) &svcStatus );
        }
    }
    
} // ServiceEntry()




//
//  Private functions.
//

DWORD
InitializeInstances(
    PFTP_IIS_SERVICE pService
    )
/*++

Routine Description:

    Read the instances from the registry

Arguments:

    pService - Server instance added to.

Return Value:

    Win32

--*/
{
    DWORD                err = NO_ERROR;
    DWORD                i;
    DWORD                cInstances = 0;
    MB                   mb( (IMDCOM*) pService->QueryMDObject() );
    BUFFER               buff;
    CHAR                 szKeyName[MAX_PATH+1];
    BOOL                 fMigrateRoots = FALSE;

    //
    //  Open the metabase for write to get an atomic snapshot
    //

    if ( !mb.Open( "/LM/MSFTPSVC/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "InitializeInstances: Cannot open path %s, error %lu\n",
                    "/LM/MSFTPSVC/", GetLastError() ));

#if 1 // Temporary until setup is modified to create the instances in the metabase
        if ( !mb.Open( METADATA_MASTER_ROOT_HANDLE,
               METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ||
             !mb.AddObject( "/LM/MSFTPSVC/" ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create service, error %d\n",
                        GetLastError() ));

            return GetLastError();
        }
#else
        return GetLastError();
#endif
    }

TryAgain:
    i = 0;
    while ( mb.EnumObjects( "",
                            szKeyName,
                            i++ ))
    {
        BOOL fRet;
        DWORD dwInstance;
        CHAR szRegKey[MAX_PATH+1];

        //
        // Get the instance id
        //

        dwInstance = atoi( szKeyName );
        if ( dwInstance == 0 ) {
            continue;
        }

        if ( buff.QuerySize() < (cInstances + 1) * sizeof(DWORD) )
        {
            if ( !buff.Resize( (cInstances + 10) * sizeof(DWORD)) )
            {
                return GetLastError();
            }
        }

        ((DWORD *) buff.QueryPtr())[cInstances++] = dwInstance;
    }

    if ( cInstances == 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "No defined instances\n" ));

        if ( !mb.AddObject( "1" ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create first instance, error %d\n",
                        GetLastError() ));

            return GetLastError();
        }

        fMigrateRoots = TRUE; // Force reg->metabase migration of virtual directories
        goto TryAgain;
    }

    DBG_REQUIRE( mb.Close() );

    for ( i = 0; i < cInstances; i++ )
    {
        DWORD dwInstance = ((DWORD *)buff.QueryPtr())[i];

        if( !g_pInetSvc->AddInstanceInfo( dwInstance, fMigrateRoots ) ) {

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "InitializeInstances: cannot create instance %lu, error %lu\n",
                dwInstance,
                err
                ));

            break;

        }

    }

    return err;

}   // InitializeInstances


APIERR
InitializeService(
    LPVOID lpContext
    )
/*++

    Routine:
        This function initializes the various FTPD Service components.

    Arguments:
        lpContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    APIERR err = NO_ERROR;
    PFTP_IIS_SERVICE  pInetSvc = (PFTP_IIS_SERVICE)lpContext;
    PFTP_SERVER_INSTANCE pServer;

    DBG_ASSERT( lpContext == g_pInetSvc);

    IF_DEBUG( SERVICE_CTRL ) {
        DBGPRINTF(( DBG_CONTEXT,"Initializing ftp service\n" ));
    }

    //
    //  Initialize various components.  The ordering of the
    //  components is somewhat limited.
    //  We should initialize connections as the last item,
    //   since it kicks off the connection thread.
    //

    err = PRINT_CURRENT_TIME_TO_DBG();

    if(( err = InitializeGlobals() )          != NO_ERROR ||
       ( err = PRINT_CURRENT_TIME_TO_DBG())   != NO_ERROR ||
       ( err = pInetSvc->InitializeSockets()) != NO_ERROR ||
       ( err = PRINT_CURRENT_TIME_TO_DBG())   != NO_ERROR ||
       ( err = pInetSvc->InitializeDiscovery( )) != NO_ERROR ||
       ( err = PRINT_CURRENT_TIME_TO_DBG())   != NO_ERROR ) {

       DBGPRINTF(( DBG_CONTEXT,
                     "cannot initialize ftp service, error %lu\n",err ));

        goto exit;

    } else {

          //
          //  Success!
          //

          DBG_ASSERT( err == NO_ERROR);

          //
          // From discusssions with KeithMo, we decided to punt on the
          //   default buffer size for now. Later on if performance is
          //   critical, we will try to improve on this by proper values
          //   for listen socket.
          //

          g_SocketBufferSize = DEFAULT_RECV_BUFFER_SIZE;

          IF_DEBUG( SERVICE_CTRL )  {

              DBGPRINTF(( DBG_CONTEXT, " %s service initialized\n",
                         pInetSvc->QueryServiceName())
                        );
          }
    }

    //
    // Initialize all instances
    //
    InitializeInstances(pInetSvc);


    g_pFTPStats->UpdateStartTime();

exit:

    PRINT_CURRENT_TIME_TO_DBG();

    return ( err);

} // InitializeService()





APIERR
TerminateService(
    LPVOID lpContext
    )
/*++

    Routine:
        This function cleans up the various FTPD Service components.

    Arguments:
        lpContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    APIERR err = NO_ERROR;
    PFTP_IIS_SERVICE pInetSvc = (PFTP_IIS_SERVICE)lpContext;

    DBG_ASSERT( lpContext == g_pInetSvc);


    IF_DEBUG( SERVICE_CTRL ) {
        DBGPRINTF(( DBG_CONTEXT, "terminating service\n" ));
    }

    PRINT_CURRENT_TIME_TO_DBG();

    g_pFTPStats->UpdateStopTime();

    //
    //  Components should be terminated in reverse
    //  initialization order.
    //

    g_pInetSvc->ShutdownService( );

    PRINT_CURRENT_TIME_TO_DBG();
    IF_DEBUG( SERVICE_CTRL ) {
        DBGPRINTF(( DBG_CONTEXT, "Ftp service terminated\n" ));
    }

    PRINT_CURRENT_TIME_TO_DBG();
    err = pInetSvc->TerminateDiscovery();

    if ( err != NO_ERROR) {
        DBGPRINTF( ( DBG_CONTEXT,
                    "CleanupService( %s):"
                    " TerminateDiscovery failed, err=%lu\n",
                    pInetSvc->QueryServiceName(),
                    err));
    }

    PRINT_CURRENT_TIME_TO_DBG();
    pInetSvc->CleanupSockets();

    PRINT_CURRENT_TIME_TO_DBG();

    TsCacheFlush( INET_FTP_SVC_ID );
    TsFlushMetaCache(METACACHE_FTP_SERVER_ID, TRUE);
    TerminateGlobals();

    return ( err);

} // TerminateService()



# ifdef CHECK_DBG
DWORD PrintOutCurrentTime(IN CHAR * pszFile, IN int lineNum)
/*++
  This function generates the current time and prints it out to debugger
   for tracing out the path traversed, if need be.

  Arguments:
      pszFile    pointer to string containing the name of the file
      lineNum    line number within the file where this function is called.

  Returns:
      NO_ERROR always.
--*/
{
    CHAR    szBuffer[1000];

    sprintf( szBuffer, "[%u]( %40s, %10d) TickCount = %u\n",
            GetCurrentThreadId(),
            pszFile,
            lineNum,
            GetTickCount()
            );

    OutputDebugString( szBuffer);

    return ( NO_ERROR);

} // PrintOutCurrentTime()

# endif // CHECK_DBG

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpvReserved
    )
{


    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( FTPD_SERVICE_NAME);
#else
        CREATE_DEBUG_PRINT_OBJECT( FTPD_SERVICE_NAME, IisFtpGuid);
#endif
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            return FALSE;  // Nothing can be done. Debug Print object failed!
        }

        DBG_REQUIRE( DisableThreadLibraryCalls( hDll ) );
        INITIALIZE_CRITICAL_SECTION( &g_csServiceEntryLock );
        break;

    case DLL_PROCESS_DETACH:
        DELETE_DEBUG_PRINT_OBJECT();
        DeleteCriticalSection( &g_csServiceEntryLock );
        break;

    }

    return TRUE;

}   // DLLEntry

}   // extern "C"

/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\sockutil.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    sockutil.cxx

    This module contains utility routines for managing & manipulating
    sockets.

    Functions exported by this module:

        InitializeSockets
        TerminateSockets
        CreateDataSocket
        CreateFtpdSocket
        CloseSocket
        ResetSocket
        AcceptSocket
        SockSend
        SockRecv
        SockPrintf2
        ReplyToUser()
        SockReadLine
        SockMultilineMessage2



    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     April-1995 Misc modifications (removed usage of various
                                  socket functions/modified them)

*/


#include "ftpdp.hxx"


//
//  Private constants.
//

#define DEFAULT_BUFFER_SIZE     4096    // bytes

//
//  Private globals.
//


//
//  Private prototypes.
//

SOCKERR
vSockPrintf(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPCSTR      pszFormat,
    va_list     args
    );

SOCKERR
vSockReply(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    UINT        ReplyCode,
    CHAR        chSeparator,
    LPCSTR      pszFormat,
    va_list     args
    );

BOOL
vTelnetEscapeIAC(
    PCHAR       pszBuffer,
    PINT        pcchBufChars,
    INT         ccbMaxLen
    );

//
//  Public functions.
//


/*******************************************************************

    NAME:       CreateDataSocket

    SYNOPSIS:   Creates a data socket for the specified address & port.

    ENTRY:      psock - Will receive the new socket ID if successful.

                addrLocal - The local Internet address for the socket
                    in network byte order.

                portLocal - The local port for the socket in network
                    byte order.

                addrRemote - The remote Internet address for the socket
                    in network byte order.

                portRemote - The remote port for the socket in network
                    byte order.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     10-Mar-1993 Created.
        KeithMo     07-Sep-1993 Enable SO_REUSEADDR.

********************************************************************/
SOCKERR
CreateDataSocket(
    SOCKET * psock,
    ULONG    addrLocal,
    PORT     portLocal,
    ULONG    addrRemote,
    PORT     portRemote
    )
{
    SOCKET      sNew = INVALID_SOCKET;
    SOCKERR     serr = 0;
    SOCKADDR_IN sockAddr;

    //
    //  Just to be paranoid...
    //

    DBG_ASSERT( psock != NULL );
    *psock = INVALID_SOCKET;

    //
    //  Create the socket.
    //

    sNew = WSASocketW(AF_INET,
                      SOCK_STREAM,
                      IPPROTO_TCP,
                      NULL,
                      0,
                      WSA_FLAG_OVERLAPPED);

    serr = ( sNew == INVALID_SOCKET ) ? WSAGetLastError() : 0;

    if( serr == 0 )
    {
        BOOL fReuseAddr = TRUE;

        //
        //  Since we always bind to the same local port,
        //  allow the reuse of address/port pairs.
        //

        if( setsockopt( sNew,
                        SOL_SOCKET,
                        SO_REUSEADDR,
                        (CHAR *)&fReuseAddr,
                        sizeof(fReuseAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Bind the local internet address & port to the socket.
        //

        sockAddr.sin_family      = AF_INET;
        sockAddr.sin_addr.s_addr = addrLocal;
        sockAddr.sin_port        = portLocal;

        if( bind( sNew, (SOCKADDR *)&sockAddr, sizeof(sockAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Connect to the remote internet address & port.
        //

        sockAddr.sin_family      = AF_INET;
        sockAddr.sin_addr.s_addr = addrRemote;
        sockAddr.sin_port        = portRemote;

        if( connect( sNew, (SOCKADDR *)&sockAddr, sizeof(sockAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Success!  Return the socket to the caller.
        //

        DBG_ASSERT( sNew != INVALID_SOCKET );
        *psock = sNew;

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "data socket %d connected from (%08lX,%04X) to (%08lX,%04X)\n",
                        sNew,
                        ntohl( addrLocal ),
                        ntohs( portLocal ),
                        ntohl( addrRemote ),
                        ntohs( portRemote ) ));
        }
    }
    else
    {
        //
        //  Something fatal happened.  Close the socket if
        //  managed to actually open it.
        //

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "no data socket from (%08lX,%04X) to (%08lX, %04X), error %d\n",
                        ntohl( addrLocal ),
                        ntohs( portLocal ),
                        ntohl( addrRemote ),
                        ntohs( portRemote ),
                        serr ));

        }

        if( sNew != INVALID_SOCKET )
        {
            ResetSocket( sNew );
        }
    }

    return serr;

}   // CreateDataSocket




/*******************************************************************

    NAME:       CreateFtpdSocket

    SYNOPSIS:   Creates a new socket at the FTPD port.
                  This will be used by the passive data transfer.

    ENTRY:      psock - Will receive the new socket ID if successful.

                addrLocal - The lcoal Internet address for the socket
                    in network byte order.

                portLocal - The local port for the socket in network
                    byte order.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     08-Mar-1993 Created.

********************************************************************/
SOCKERR
CreateFtpdSocket(
    SOCKET * psock,
    ULONG    addrLocal,
    PORT     portLocal,
    FTP_SERVER_INSTANCE *pInstance
    )
{
    SOCKET  sNew = INVALID_SOCKET;
    SOCKERR serr = 0;

    //
    //  Just to be paranoid...
    //

    DBG_ASSERT( psock != NULL );
    *psock = INVALID_SOCKET;

    //
    //  Create the connection socket.
    //

    sNew = WSASocketW(AF_INET,
                      SOCK_STREAM,
                      IPPROTO_TCP,
                      NULL,
                      0,
                      WSA_FLAG_OVERLAPPED);


    serr = ( sNew == INVALID_SOCKET ) ? WSAGetLastError() : 0;

    if( serr == 0 )
    {
        BOOL fReuseAddr = FALSE;

        //
        //  Muck around with the socket options a bit.
        //  Berkeley FTPD does this.
        //

        if( setsockopt( sNew,
                        SOL_SOCKET,
                        SO_REUSEADDR,
                        (CHAR *)&fReuseAddr,
                        sizeof(fReuseAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        SOCKADDR_IN sockAddr;

        //
        //  Bind an address to the socket.
        //

        sockAddr.sin_family      = AF_INET;
        sockAddr.sin_addr.s_addr = addrLocal;
        sockAddr.sin_port        = portLocal;

        if( bind( sNew, (SOCKADDR *)&sockAddr, sizeof(sockAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Put the socket into listen mode.
        //

        if( listen( sNew, (INT)pInstance->NumListenBacklog()) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Success!  Return the socket to the caller.
        //

        DBG_ASSERT( sNew != INVALID_SOCKET );
        *psock = sNew;

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "connection socket %d created at (%08lX,%04X)\n",
                        sNew,
                        ntohl( addrLocal ),
                        ntohs( portLocal ) ));
        }
    }
    else
    {
        //
        //  Something fatal happened.  Close the socket if
        //  managed to actually open it.
        //

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "no connection socket at (%08lX, %04X), error %d\n",
                        ntohl( addrLocal ),
                        ntohs( portLocal ),
                        serr ));

        }

        if( sNew != INVALID_SOCKET )
        {
            ResetSocket( sNew );
        }
    }

    return serr;

}   // CreateFtpdSocket



/*******************************************************************

    NAME:       CloseSocket

    SYNOPSIS:   Closes the specified socket.  This is just a thin
                wrapper around the "real" closesocket() API.

    ENTRY:      sock - The socket to close.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     26-Apr-1993 Created.

********************************************************************/
SOCKERR
CloseSocket(
    SOCKET sock
    )
{
    SOCKERR serr = 0;

    //
    //  Close the socket.
    //

    if( closesocket( sock ) != 0 )
    {
        serr = WSAGetLastError();
    }

    IF_DEBUG( SOCKETS )
    {
        if( serr == 0 )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "closed socket %d\n",
                        sock ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot close socket %d, error %d\n",
                        sock,
                        serr ));
        }
    }

    return serr;

}   // CloseSocket


/*******************************************************************

    NAME:       ResetSocket

    SYNOPSIS:   Performs a "hard" close on the given socket.

    ENTRY:      sock - The socket to close.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     08-Mar-1993 Created.

********************************************************************/
SOCKERR
ResetSocket(
    SOCKET sock
    )
{
    SOCKERR serr = 0;
    LINGER  linger;

    //
    //  Enable linger with a timeout of zero.  This will
    //  force the hard close when we call closesocket().
    //
    //  We ignore the error return from setsockopt.  If it
    //  fails, we'll just try to close the socket anyway.
    //

    linger.l_onoff  = TRUE;
    linger.l_linger = 0;

    setsockopt( sock,
                SOL_SOCKET,
                SO_LINGER,
                (CHAR *)&linger,
                sizeof(linger) );

    //
    //  Close the socket.
    //

    if( closesocket( sock ) != 0 )
    {
        serr = WSAGetLastError();
    }

    IF_DEBUG( SOCKETS )
    {
        if( serr == 0 )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "reset socket %d\n",
                        sock ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot reset socket %d, error %d\n",
                        sock,
                        serr ));
        }
    }

    return serr;

}   // ResetSocket



/*******************************************************************

    NAME:       AcceptSocket

    SYNOPSIS:   Waits for a connection to the specified socket.
                The socket is assumed to be "listening".

    ENTRY:      sockListen - The socket to accept on.

                psockNew - Will receive the newly "accepted" socket
                    if successful.

                paddr - Will receive the client's network address.

                fEnforceTimeout - If TRUE, this routine will enforce
                    the idle-client timeout.  If FALSE, no timeouts
                    are enforced (and this routine may block
                    indefinitely).

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     27-Apr-1993 Created.

********************************************************************/
SOCKERR
AcceptSocket(
    SOCKET          sockListen,
    SOCKET *        psockNew,
    LPSOCKADDR_IN   paddr,
    BOOL            fEnforceTimeout,
    FTP_SERVER_INSTANCE *pInstance
    )
{
    SOCKERR serr    = 0;
    SOCKET  sockNew = INVALID_SOCKET;
    BOOL    fRead = FALSE;

    DBG_ASSERT( psockNew != NULL );
    DBG_ASSERT( paddr != NULL );

    if( fEnforceTimeout ) {

        //
        //  Timeouts are to be enforced, so wait for a connection
        //  to the socket.
        //

        serr = WaitForSocketWorker(
                            sockListen,
                            INVALID_SOCKET,
                            &fRead,
                            NULL,
                            pInstance->QueryConnectionTimeout()
                            );
    }

    if( serr == 0 )
    {
        INT cbAddr = sizeof(SOCKADDR_IN);

        //
        //  Wait for the actual connection.
        //

        sockNew = accept( sockListen, (SOCKADDR *)paddr, &cbAddr );

        if( sockNew == INVALID_SOCKET )
        {
            serr = WSAGetLastError();
        }
    }

    //
    //  Return the (potentially invalid) socket to the caller.
    //

    *psockNew = sockNew;

    return serr;

}   // AcceptSocket



/*******************************************************************

    NAME:       SockSend

    SYNOPSIS:   Sends a block of bytes to a specified socket.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pBuffer - Contains the data to send.

                cbBuffer - The size (in bytes) of the buffer.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     13-Mar-1993 Created.

********************************************************************/
SOCKERR
SockSend(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPVOID      pBuffer,
    DWORD       cbBuffer
    )
{
    SOCKERR     serr = 0;
    INT         cbSent;
    DWORD       dwBytesSent = 0;

    DBG_ASSERT( pBuffer != NULL );

    //
    //  Loop until there's no more data to send.
    //

    while( cbBuffer > 0 ) {

        //
        //  Wait for the socket to become writeable.
        //
        BOOL  fWrite = FALSE;

        serr = WaitForSocketWorker(
                        INVALID_SOCKET,
                        sock,
                        NULL,
                        &fWrite,
                        (pUserData != NULL) ?
                            pUserData->QueryInstance()->QueryConnectionTimeout():
                            FTP_DEF_SEND_TIMEOUT
                        );

        if( serr == 0 )
        {
            //
            //  Write a block to the socket.
            //

            cbSent = send( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

            if( cbSent < 0 )
            {
                //
                //  Socket error.
                //

                serr = WSAGetLastError();
            }
            else
            {
                dwBytesSent += (DWORD)cbSent;

                IF_DEBUG( SEND )
                {
                    if( pUserData && TEST_UF( pUserData, TRANSFER ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "send %d bytes @%p to socket %d\n",
                                    cbSent,
                                    pBuffer,
                                    sock ));
                    }
                }
            }
        }


        // added a check for special case when we are sending and thinking that we are sending
        // synchronoulsy on socket which was set to non blocking mode. In that case when buffer space
        // in winsock becomes exhausted send return WSAEWOULDBLOCK. So then we just retry.

        if ( serr != WSAEWOULDBLOCK )
        {
            if( serr != 0 )
            {
                break;
            }

            pBuffer   = (LPVOID)( (LPBYTE)pBuffer + cbSent );
            cbBuffer -= (DWORD)cbSent;
        }
    }

    if( serr != 0 )
    {
        IF_DEBUG( SEND )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "socket error %d during send on socket %d.\n",
                        serr,
                        sock));
        }
    }

    if( pUserData != NULL ) {
        pUserData->QueryInstance()->QueryStatsObj()->UpdateTotalBytesSent(
                                                                dwBytesSent );
    }

    return serr;

}   // SockSend



/*******************************************************************

    NAME:       SockRecv

    SYNOPSIS:   Receives a block of bytes from a specified socket.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pBuffer - Will receive the data.

                cbBuffer - The size (in bytes) of the buffer.

                pbReceived - Will receive the actual number of bytes
                    received.  This value is undefined if this function
                    fails.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     13-Mar-1993 Created.

********************************************************************/
SOCKERR
SockRecv(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPVOID      pBuffer,
    DWORD       cbBuffer,
    LPDWORD     pbReceived
    )
{
    SOCKERR     serr = 0;
    DWORD       cbTotal = 0;
    INT         cbReceived;
    DWORD       dwBytesRecv = 0;

    DBG_ASSERT( pBuffer != NULL );
    DBG_ASSERT( pbReceived != NULL );

    //
    //  Loop until the buffer's full.
    //

    while (cbBuffer > 0) {

        BOOL fRead = FALSE;

        //
        //  Wait for the socket to become readable.
        //

        serr = WaitForSocketWorker(
                            sock,
                            INVALID_SOCKET,
                            &fRead,
                            NULL,
                            (pUserData != NULL) ?
                                pUserData->QueryInstance()->QueryConnectionTimeout():
                                FTP_DEF_RECV_TIMEOUT
                            );

        if( serr == 0 )
        {
            //
            //  Read a block from the socket.
            //
            DBG_ASSERT( fRead);

            cbReceived = recv( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

            if( cbReceived < 0 )
            {
                //
                //  Socket error.
                //

                serr = WSAGetLastError();
            }
            else
            {
                dwBytesRecv += (DWORD)cbReceived;

                IF_DEBUG( RECV )
                {
                    if( pUserData && TEST_UF( pUserData, TRANSFER ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "received %d bytes @%p from socket %d\n",
                                    cbReceived,
                                    pBuffer,
                                    sock ));
                    }
                }
            }
        }

        if( ( serr != 0 ) || ( cbReceived == 0 ) )
        {
            //
            //  End of file, socket closed, timeout, or socket error.
            //

            break;
        }

        pBuffer   = (LPVOID)( (LPBYTE)pBuffer + cbReceived );
        cbBuffer -= (DWORD)cbReceived;
        cbTotal  += (DWORD)cbReceived;
    }

    if( serr == 0 )
    {
        //
        //  Return total byte count to caller.
        //

        *pbReceived = cbTotal;
    }
    else
    {
        IF_DEBUG( RECV )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "socket error %d during recv on socket %d\n",
                        serr,
                        sock ));
        }
    }

    if( pUserData != NULL ) {
        pUserData->QueryInstance()->QueryStatsObj()->UpdateTotalBytesReceived(
                                                                dwBytesRecv );
    }

    return serr;

}   // SockRecv



/*******************************************************************

    NAME:       SockPrintf2

    SYNOPSIS:   Send a formatted string to a specific socket.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pszFormat - A printf-style format string.

                ... - Any other parameters needed by the format string.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     10-Mar-1993 Created.

********************************************************************/
SOCKERR
__cdecl
SockPrintf2(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPCSTR      pszFormat,
    ...
    )
{
    va_list ArgPtr;
    SOCKERR serr;

    //
    //  Let the worker do the dirty work.
    //

    va_start( ArgPtr, pszFormat );

    serr = vSockPrintf( pUserData,
                        sock,
                        pszFormat,
                        ArgPtr );

    va_end( ArgPtr );

    return serr;

}   // SockPrintf2



SOCKERR
__cdecl
ReplyToUser(
    IN LPUSER_DATA pUserData,
    IN UINT        ReplyCode,
    IN LPCSTR      pszFormat,
    ...
    )
/*++

  This function sends an FTP reply to the user data object. The reply
   is usually sent over the control socket.

  Arguments:
     pUserData    pointer to UserData object initiating the reply
     ReplyCode    One of the REPLY_* manifests.
     pszFormat    pointer to null-terminated string containing the format
     ...          additional paramters if any required.

  Returns:
     SOCKET error code. 0 on success and !0 on failure.

  History:
     MuraliK
--*/
{
    va_list ArgPtr;
    SOCKERR serr;

    DBG_ASSERT( pUserData != NULL);

    pUserData->SetLastReplyCode( ReplyCode );

    if ( pUserData->QueryControlSocket() != INVALID_SOCKET) {

        //
        //  Let the worker do the dirty work.
        //

        va_start( ArgPtr, pszFormat );

        serr = vSockReply( pUserData,
                          pUserData->QueryControlSocket(),
                          ReplyCode,
                          ' ',
                          pszFormat,
                          ArgPtr );

        va_end( ArgPtr );
    } else {

        serr = WSAECONNABORTED;
    }


    return serr;

}   // ReplyToUser()


// Private functions

/*******************************************************************

    NAME:       vSockPrintf

    SYNOPSIS:   Worker function for printf-to-socket functions.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pszFormat - The format string.

                args - Variable number of arguments.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     17-Mar-1993 Created.

********************************************************************/
SOCKERR
vSockPrintf(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPCSTR      pszFormat,
    va_list     args
    )
{
    INT     cchBuffer = 0;
    INT     buffMaxLen;
    SOCKERR serr = 0;
    CHAR    szBuffer[MAX_REPLY_LENGTH];

    DBG_ASSERT( pszFormat != NULL );

    //
    //  Render the format into our local buffer.
    //


    DBG_ASSERT( MAX_REPLY_LENGTH > 3);
    buffMaxLen = MAX_REPLY_LENGTH - 3;
    cchBuffer = _vsnprintf( szBuffer,
                           buffMaxLen,
                           pszFormat, args );
    //
    // The string length is long, we get back -1.
    //   so we get the string length for partial data.
    //

    if ( cchBuffer == -1 ) {

        //
        // terminate the string properly,
        //   since _vsnprintf() does not terminate properly on failure.
        //
        cchBuffer = buffMaxLen;
        szBuffer[ buffMaxLen] = '\0';
    }

    IF_DEBUG( SOCKETS ) {
        DBGPRINTF(( DBG_CONTEXT, "sending '%s'\n", szBuffer ));
    }

    //
    // Escape all telnet IAC bytes with a second IAC
    //
    vTelnetEscapeIAC( szBuffer, &cchBuffer, MAX_REPLY_LENGTH - 3 );

    strcpy( szBuffer + cchBuffer, "\r\n" );
    cchBuffer += 2;

    //
    //  Blast it out to the client.
    //

    serr = SockSend( pUserData, sock, szBuffer, cchBuffer );
    return serr;

} // vSockPrintf



/*******************************************************************

    NAME:       vSockReply

    SYNOPSIS:   Worker function for reply functions.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                ReplyCode - A three digit reply code from RFC 959.

                chSeparator - Should be either ' ' (normal reply) or
                    '-' (first line of multi-line reply).

                pszFormat - The format string.

                args - Variable number of arguments.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     17-Mar-1993 Created.

********************************************************************/
SOCKERR
vSockReply(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    UINT        ReplyCode,
    CHAR        chSeparator,
    LPCSTR      pszFormat,
    va_list     args
    )
{
    INT     cchBuffer;
    INT     cchBuffer1;
    INT     buffMaxLen;
    SOCKERR serr = 0;
    CHAR    szBuffer[MAX_REPLY_LENGTH];

    DBG_ASSERT( ( ReplyCode >= 100 ) && ( ReplyCode < 600 ) );

    //
    //  Render the format into our local buffer.
    //

    cchBuffer = wsprintfA( szBuffer,
                          "%u%c",
                          ReplyCode,
                          chSeparator );

    DBG_ASSERT( MAX_REPLY_LENGTH > cchBuffer + 3);
    buffMaxLen = MAX_REPLY_LENGTH - cchBuffer - 3;
    cchBuffer1 = _vsnprintf( szBuffer + cchBuffer,
                            buffMaxLen,
                            pszFormat, args );
    //
    // The string length is long, we get back -1.
    //   so we get the string length for partial data.
    //

    if ( cchBuffer1 == -1 ) {

        //
        // terminate the string properly,
        //   since _vsnprintf() does not terminate properly on failure.
        //
        cchBuffer = buffMaxLen;
        szBuffer[ buffMaxLen] = '\0';
    } else {

        cchBuffer += cchBuffer1;
    }

    IF_DEBUG( SOCKETS ) {
        DBGPRINTF(( DBG_CONTEXT, "sending '%s'\n",szBuffer ));
    }

    //
    // Escape all telnet IAC bytes with a second IAC
    //
    vTelnetEscapeIAC( szBuffer, &cchBuffer, MAX_REPLY_LENGTH - 3 );

    strcpy( szBuffer + cchBuffer, "\r\n" );
    cchBuffer += 2;

    //
    //  Blast it out to the client.
    //

    serr = SockSend( pUserData, sock, szBuffer, cchBuffer );

    return serr;

}   // vSockReply


DWORD
FtpFormatResponseMessage( IN UINT     uiReplyCode,
                          IN LPCTSTR  pszReplyMsg,
                          OUT LPTSTR  pszReplyBuffer,
                          IN DWORD    cchReplyBuffer)
/*++
  This function formats the message to be sent to the client,
    given the reply code and the message to be sent.

  The formatting function takes care of the reply buffer length
    and ensures the safe write of data. If the reply buffer is
    not sufficient to hold the entire message, the reply msg is trunctaed.

  Arguments:
    uiReplyCode   reply code to be used.
    pszReplyMsg   pointer to string containing the reply message
    pszReplyBuffer pointer to character buffer where the reply message
                   can be sent.
    cchReplyBuffer character count for the length of reply buffer.

  Returns:
    length of the data written to the reply buffer.

--*/
{
    DWORD len;

    DBG_ASSERT( pszReplyMsg != NULL && pszReplyBuffer != NULL);

    len = lstrlen( pszReplyMsg) + 10;   // 10 chars are required for aux info.

    if ( len >= cchReplyBuffer) {

        // truncate the message since length is too high.

        len = wsprintf( pszReplyBuffer, TEXT("%u \r\n"),
                        uiReplyCode);

        DBG_ASSERT( len >= 3);  // length greater than formatting string
        DBG_ASSERT( len < cchReplyBuffer);

        lstrcpyn( pszReplyBuffer + len, pszReplyMsg, cchReplyBuffer - len);

        len = lstrlen( pszReplyBuffer);
        DBG_ASSERT( len < cchReplyBuffer);

    } else {

        len = wsprintf( pszReplyBuffer, TEXT("%u %s\r\n"),
                        uiReplyCode,
                        pszReplyMsg);
        DBG_ASSERT( len >= 4);
        DBG_ASSERT( len <= cchReplyBuffer);
    }

    return (len);
} // FtpFormatResponseMessage()


/*******************************************************************

    NAME:       vTelnetEscapeIAC

    SYNOPSIS:   replace (in place) all 0xFF bytes in a buffer with 0xFF 0xFF.
                This is the TELNET escape sequence for an IAC value data byte.

    ENTRY:      pszBuffer - data buffer.

                pcchBufChars - on entry, current number of chars in buffer.
                               on return, number of chars in buffer.

                cchMaxLen - maximum characters in the output buffer

    RETURNS:    TRUE - success, FALSE - overflow.

    HISTORY:
        RobSol     25-April-2001 Created.

********************************************************************/
BOOL
vTelnetEscapeIAC( IN OUT PCHAR pszBuffer,
                  IN OUT PINT  pcchBufChars,
                  IN     INT   cchMaxLen)
{

#   define CHAR_IAC ((CHAR)(-1))

    PCHAR  pszFirstIAC;
    PCHAR  pSrc, pDst;
    BOOL   fReturn = TRUE;
    CHAR   szBuf[MAX_REPLY_LENGTH];
    INT    cCharsInDst;

    DBG_ASSERT( pszBuffer );
    DBG_ASSERT( pcchBufChars );
    DBG_ASSERT( cchMaxLen <= MAX_REPLY_LENGTH );

    if ((pszFirstIAC = strchr( pszBuffer, CHAR_IAC)) == NULL) {

        //
        // no IAC - return.
        //

        return TRUE;
    }

    //
    // we'll expand the string into a temp buffer, then copy back.
    //

    pSrc = pszFirstIAC;
    pDst = szBuf;
    cCharsInDst = DIFF(pszFirstIAC - pszBuffer);

    do {
       if (*pSrc == CHAR_IAC) {

          //
          // this is a char to escape
          //

          if ((cCharsInDst + 1) < cchMaxLen) {

              //
              // we have space to escape the char, so do it.
              //

              cCharsInDst++;
              *pDst++ = CHAR_IAC;
          } else {

              //
              // overflow.
              //

              fReturn = FALSE;
              break;
          }
       }

       *pDst++ = *pSrc++;

    } while ((++cCharsInDst < cchMaxLen) && (*pSrc != '\0'));

    //
    // copy the expanded data back into the input buffer and terminate the string
    //

    memcpy( pszFirstIAC, szBuf, pDst - szBuf);
    pszBuffer[ cCharsInDst ] = '\0';

    *pcchBufChars = cCharsInDst;

    return fReturn;
}

/************************ End of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\rpcex.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        rpcex.cxx

   Abstract:

        This module defines K2 rpc support.

   Author:

        Johnson Apacible    (JohnsonA)      June-19-1996

--*/

#include "ftpdp.hxx"
#include "time.h"
#include "timer.h"

# define ASSUMED_AVERAGE_USER_NAME_LEN         ( 40)
# define CONN_LEEWAY                           ( 3)

//
//  Private functions.
//

BOOL
GenDoubleNullStringFromMultiLine( IN LPCWSTR lpsz,
                                  IN OUT LPWSTR * ppszz,
                                  IN OUT LPDWORD  pcchLen)
{
    DWORD cchLen;
    DWORD nLines;
    LPWSTR pszNext;
    LPCWSTR pszSrc;

    DBG_ASSERT( lpsz != NULL && ppszz != NULL && pcchLen != NULL);

    // Initialize
    *ppszz = NULL;
    *pcchLen = 0;

    //
    // 1. Find the length of the the complete message including new lines
    //  For each new line we may potentially need an extra blank char
    //  So allocate space = nLines + length + 2 terminating null chars.
    //

    cchLen = lstrlenW( lpsz);

    for ( pszSrc = lpsz, nLines = 0;  *pszSrc != L'\0'; pszSrc++) {

        if ( *pszSrc == L'\n')   { nLines++; }
    } // for


    // Allocate sufficient space for the string.
    *ppszz = (LPWSTR ) TCP_ALLOC( (cchLen + nLines + 3) * sizeof(WCHAR));
    if ( *ppszz == NULL) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (FALSE);
    }


    //
    // walk down the local copy and convert all the line feed characters to
    //   be null char
    //

    //
    // Since the MULTI_SZ string cannot contain empty strings
    //  we convert empty lines (ones with just \n into " \0"
    //  i.e.  with a blank character.
    //

    pszSrc = lpsz;
    LPWSTR pszDst = *ppszz;

    if ( *pszSrc == L'\n') {

        // first line is a linefeed. insert a blank and proceed to next line.
        *pszDst = L' ';
        *(pszDst + 1) = L'\0';

        // move forward
        pszDst += 2;
        pszSrc++;
    }

    for( ; *pszSrc != L'\0';  pszSrc++, pszDst++) {

        if ( *pszSrc == L'\n') {

            // we are at boundary of new line.

            if ( pszSrc > lpsz && *(pszSrc - 1) == L'\n') {

                // we detected an empty line. Store an additional blank.

                *pszDst++ = L' ';
            }

            *pszDst = L'\0';  // put null char in place of line feed.

        } else {

            *pszDst = *pszSrc;
        }
    } // for

    *pszDst++   = L'\0';  // terminate with 1st null chars.
    *pszDst++ = L'\0';  // terminate with 2nd null chars.

    *pcchLen = DIFF(pszDst - *ppszz);

    DBG_ASSERT( *pcchLen <= cchLen + nLines + 3);

    return ( TRUE);
} // GenDoubleNullStringFromMultiline()


BOOL
FTP_SERVER_INSTANCE::WriteParamsToRegistry(
    LPFTP_CONFIG_INFO pConfig
    )
/*++
  This function writes parameters to the registry

  Arguments:
    hkey         HKEY for registry entry of parameters of FTP server.
    pConfig      pointer to configuration information.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    DWORD   err = NO_ERROR;
    BOOL    fRet = TRUE;

    HKEY    hkey = NULL;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        QueryRegParamKey(),
                        0,
                        KEY_ALL_ACCESS,
                        &hkey );

    if( hkey == NULL )
    {
        err = ERROR_INVALID_HANDLE;
        SetLastError( err);
        DBGPRINTF(( DBG_CONTEXT,
                    "Invalid Registry key given. error %lu\n",
                    err ));

        return FALSE;
    }

    //
    //  Write the registry data.
    //

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ALLOW_ANONYMOUS ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ALLOW_ANONYMOUS,
                                  pConfig->fAllowAnonymous );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ALLOW_GUEST_ACCESS ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ALLOW_GUEST_ACCESS,
                                  pConfig->fAllowGuestAccess );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ANNOTATE_DIRECTORIES ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ANNOTATE_DIRS,
                                  pConfig->fAnnotateDirectories );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ANONYMOUS_ONLY ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ANONYMOUS_ONLY,
                                  pConfig->fAnonymousOnly );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_LISTEN_BACKLOG ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_LISTEN_BACKLOG,
                                  pConfig->dwListenBacklog );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_LOWERCASE_FILES ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_LOWERCASE_FILES,
                                  pConfig->fLowercaseFiles );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_MSDOS_DIR_OUTPUT ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_MSDOS_DIR_OUTPUT,
                                  pConfig->fMsdosDirOutput );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_SHOW_4_DIGIT_YEAR ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_SHOW_4_DIGIT_YEAR,
                                  pConfig->fFourDigitYear );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_EXIT_MESSAGE ) )
    {
        err = RegSetValueExW( hkey,
                              FTPD_EXIT_MESSAGE_W,
                              0,
                              REG_SZ,
                              (BYTE *)pConfig->lpszExitMessage,
                              ( wcslen( pConfig->lpszExitMessage ) + 1 ) *
                                  sizeof(WCHAR) );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_GREETING_MESSAGE ) )
    {

        LPWSTR pszzGreetingMessage = NULL;
        DWORD   cchLen = 0;

        if (GenDoubleNullStringFromMultiLine( pConfig->lpszGreetingMessage,
                                             &pszzGreetingMessage,
                                             &cchLen)
            ) {

            DBG_ASSERT( pszzGreetingMessage != NULL);

            err = RegSetValueExW( hkey,
                                 FTPD_GREETING_MESSAGE_W,
                                 0,
                                 REG_MULTI_SZ,
                                 (BYTE *) pszzGreetingMessage,
                                 cchLen * sizeof(WCHAR));

            TCP_FREE( pszzGreetingMessage);
        } else {

            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_BANNER_MESSAGE ) )
    {

        LPWSTR pszzBannerMessage = NULL;
        DWORD   cchLen = 0;

        if (GenDoubleNullStringFromMultiLine( pConfig->lpszBannerMessage,
                                             &pszzBannerMessage,
                                             &cchLen)
            ) {

            DBG_ASSERT( pszzBannerMessage != NULL);

            err = RegSetValueExW( hkey,
                                 FTPD_BANNER_MESSAGE_W,
                                 0,
                                 REG_MULTI_SZ,
                                 (BYTE *) pszzBannerMessage,
                                 cchLen * sizeof(WCHAR));

            TCP_FREE( pszzBannerMessage);
        } else {

            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }


    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_MAX_CLIENTS_MESSAGE ) )
    {
        err = RegSetValueExW( hkey,
                              FTPD_MAX_CLIENTS_MSG_W,
                              0,
                              REG_SZ,
                              (BYTE *)pConfig->lpszMaxClientsMessage,
                              ( wcslen( pConfig->lpszMaxClientsMessage ) + 1 ) *
                                  sizeof(WCHAR) );
    }

    if( err )
    {
        SetLastError( err );
        return FALSE;
    }

    return TRUE;

}   // WriteParamsToRegistry



DWORD
FTP_IIS_SERVICE::GetServiceConfigInfoSize(
                    IN DWORD dwLevel
                    )
{
    switch (dwLevel) {
    case 1:
        return sizeof(FTP_CONFIG_INFO);
    }

    return 0;

} // FTP_IIS_SERVICE::GetServerConfigInfoSize


BOOL
FTP_SERVER_INSTANCE::SetServiceConfig(
    IN PCHAR pBuffer
    )
/*++

   Description

       Sets the common service admin information for the servers specified
       in dwServerMask.

   Arguments:

       pConfig - Admin information to set

   Note:

--*/
{
    LPFTP_CONFIG_INFO pConfig = (LPFTP_CONFIG_INFO)pBuffer;
    DWORD err = NO_ERROR;

    HKEY hKey;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        QueryRegParamKey(),
                        0,
                        KEY_ALL_ACCESS,
                        &hKey );

    if ( err != NO_ERROR )
    {
        return(TRUE);
    }

    //
    //  If success, then Write the new info to the registry, then read it back.
    //

    if( WriteParamsToRegistry( pConfig )) {

        err = InitFromRegistry( pConfig->FieldControl);
    } else {

        err = GetLastError();
    }

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "FtpSetServiceConfig returns with %d %lu\n",
                   err ));
    }

    return(err == NO_ERROR);

} // FTP_SERVER_INSTANCE::SetServiceConfig




BOOL
FTP_SERVER_INSTANCE::GetServiceConfig(
    IN  PCHAR   pBuffer,
    IN  DWORD   dwLevel
    )
/*++

   Description

       Retrieves the admin information

   Arguments:

       pBuffer - Buffer to fill up.
       dwLevel - info level of information to return.

   Note:

--*/
{

    LPFTP_CONFIG_INFO pConfig = (LPFTP_CONFIG_INFO)pBuffer;
    DWORD err = NO_ERROR;

    ZeroMemory( pConfig, sizeof(FTP_CONFIG_INFO) );

    //
    //  Obtain and Return the admin information.
    //

    err = GetConfigInformation( pConfig);

    IF_DEBUG( RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "FtprGetAdminInformation() returns Error=%u\n",
                   err));
    }

    return (err == NO_ERROR);

} // FTP_SERVER_INSTANCE::GetServiceConfig


BOOL
FTP_SERVER_INSTANCE::EnumerateUsers(
    OUT PCHAR * pBuffer,
    OUT PDWORD  nRead
    )
/*++

   Description

       Enumerates the connected users.

   Arguments:

       pBuffer - Buffer to fill up.
       nRead - number of entries filled

--*/
{
    DWORD err;
    DWORD cbBuffer;
    LPIIS_USER_INFO_1 pInfo;

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,"Entering FtpEnumerateUsers\n"));
    }

    //
    //  Determine the necessary buffer size.
    //

    cbBuffer = (GetCurrentConnectionsCount() + CONN_LEEWAY)
                * sizeof( IIS_USER_INFO_1 );

    *nRead = 0;

    pInfo = (LPIIS_USER_INFO_1)MIDL_user_allocate( cbBuffer);

    if (pInfo == NULL) {

        err = ERROR_NOT_ENOUGH_MEMORY;
    } else {

        //
        // Make a first attempt at enumerating the user info
        //

        err = NO_ERROR;
        if ( !::EnumerateUsers( (PCHAR)pInfo, &cbBuffer, nRead, this )) {

            //
            // Free up old buffer and allocate big one now.
            // We will try once more to get the data again
            //   with a larger buffer.
            //

            if ( cbBuffer > 0) {

                MIDL_user_free( pInfo );
                pInfo = (LPIIS_USER_INFO_1)MIDL_user_allocate(cbBuffer);

                if( pInfo == NULL ) {

                    err = ERROR_NOT_ENOUGH_MEMORY;
                } else {

                    //
                    // Since we do not lock the active connections list
                    // it is possible some one came in now and hence the
                    //  buffer is insufficient to hold all people.
                    // Ignore this case, as we are never
                    //  going to be accurate
                    //

                    ::EnumerateUsers( (PCHAR)pInfo, &cbBuffer, nRead, this );
                    if ( *nRead == 0 ) {
                        MIDL_user_free(pInfo);
                        pInfo = NULL;
                    }
                }

            } // cbBuffer > 0

        } // if unsuccessful at first attempt
    }

    if( err != NO_ERROR ) {

        IF_DEBUG( RPC ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "I_FtprEnumerateUsers failed. Error = %lu\n",
                       err ));
        }
        SetLastError(err);
        return(FALSE);
    }

    *pBuffer = (PCHAR)pInfo;

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "FtpEnumerateUsers returns %d entries, buffer [%x]\n",
                   *nRead, *pBuffer ));
    }
    return TRUE;

} // EnumerateUsers


BOOL
FTP_SERVER_INSTANCE::DisconnectUser(
                        IN DWORD dwIdUser
                        )
/*++

   Description

       Disconnect the user

   Arguments:

       dwIdUser - Identifies the user to disconnect.  If 0,
           then disconnect ALL users.

--*/
{
    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
            "Entering FtpDisconnectUsers with id[%d]\n", dwIdUser));
    }

    if ( !::DisconnectUser( dwIdUser, this ) ) {

        IF_DEBUG( RPC ) {
            DBGPRINTF(( DBG_CONTEXT,
                "DisconnectUser failed with %d\n", GetLastError()));
        }
        SetLastError(NERR_UserNotFound);
        return(FALSE);
    }

    return(TRUE);
} // DisconnectUser


BOOL
FTP_SERVER_INSTANCE::GetStatistics(
                        IN DWORD dwLevel,
                        OUT PCHAR* pBuffer
                        )
/*++

   Description

       Disconnect Queries the server statistics

   Arguments:

       dwLevel - Info level.  Currently only level 0 is
           supported.

       pBuffer - Will receive a pointer to the statistics
           structure.

--*/
{
    APIERR err = NO_ERROR;

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "FtpQueryStatistics2, level %lu\n", dwLevel ));
    }

    //
    //  Return the proper statistics based on the infolevel.
    //

    switch( dwLevel ) {
        case 0 : {

            LPFTP_STATISTICS_0 pstats0;

            pstats0 = (LPFTP_STATISTICS_0)
                       MIDL_user_allocate(sizeof(FTP_STATISTICS_0));

            if( pstats0 == NULL ) {

                err = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                ATQ_STATISTICS      atqStat;

                ZeroMemory( pstats0, sizeof( FTP_STATISTICS_0 ) );

                QueryStatsObj()->CopyToStatsBuffer( pstats0 );

                //
                //  Get instance's bandwidth throttling statistics
                //

                if ( QueryBandwidthInfo() )
                {
                    if ( AtqBandwidthGetInfo( QueryBandwidthInfo(),
                                              ATQ_BW_STATISTICS,
                                              (ULONG_PTR *) &atqStat ) )
                    {
                        pstats0->TotalBlockedRequests = atqStat.cBlockedRequests;
                        pstats0->TotalRejectedRequests = atqStat.cRejectedRequests;
                        pstats0->TotalAllowedRequests = atqStat.cAllowedRequests;
                        pstats0->CurrentBlockedRequests = atqStat.cCurrentBlockedRequests;
                        pstats0->MeasuredBandwidth = atqStat.MeasuredBandwidth;
                    }
                }

                pstats0->TimeOfLastClear = GetCurrentTimeInSeconds() -
                                           pstats0->TimeOfLastClear;

                //
                //  Copy Global statistics counter values
                //

                pstats0->ConnectionAttempts =
                    g_pFTPStats->QueryStatsObj()->ConnectionAttempts;

                *pBuffer = (PCHAR)pstats0;
            }

        }

        break;

     default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "FtpQueryStatistics2 returns Error = %lu\n",
                   err ));
    }

    SetLastError(err);
    return(err == NO_ERROR);

} // QueryStatistics



BOOL
FTP_SERVER_INSTANCE::ClearStatistics(
                        VOID
                        )
/*++

   Description

       Clears the server statistics

   Arguments:

        None.

--*/
{

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT, "Entering FtpClearStatistics2\n"));
    }

    QueryStatsObj()->ClearStatistics();
    return TRUE;

} // ClearStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\test\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr| DbgOutputKdb)


// end_user_modifiable


/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>



//
//  Define the debugging constants 
// 

# define DEBUG_ENTRY                      DEBUG_API_ENTRY
# define DEBUG_RESPONSE                   0x00001000
# define DEBUG_ITERATION                  0x00002000


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\test\ftps.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      ftps.cxx

   Abstract:

      This file defines the ftp server stress client

   Author:

       Murali R. Krishnan    ( MuraliK )     25-July-1995

   Environment:

       Win32 - uses Wininet extensions

   Project:

       FTP Server DLL

   Functions Exported:



   Revision History:
      MuraliK   05-Nov-1995    Added support for GetFile tests

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include <windows.h>
# include <wininet.h>
# include <stdio.h>
# include <stdlib.h>
# include <iostream.h>
# include <winsock2.h>

#define DEFAULT_TRACE_FLAGS     (DEBUG_ITERATION)

# include <dbgutil.h>


# define DEFAULT_NUMBER_OF_THREADS        (10)
# define DEFAULT_NUMBER_OF_ITERATIONS     (100)

# define MAX_BUFFER_SIZE    64000  // 64K approx

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisFtptestGuid, 
0x784d8914, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif
DECLARE_DEBUG_PRINTS_OBJECT();



static const char PSZ_APPLICATION_NAME[] = "murali's stresser";
static char * g_lpszServerAddress;

BOOL
GenUsageMessage( int argc, char * argv[]);

// Tests the raw connectivity to server.
BOOL TestConnections( int argc, char * argv[]);

// Tests the raw get file from server.
BOOL TestGetFile( int argc, char * argv[]);


//
//  The following DefineAllCommands() defines a template for all commands.
//  Format: CmdCodeName     CommandName         Function Pointer   Comments
//
//  To add addditional test commands, add just another line to the list
//  Dont touch any macros below, they are all automatically generated.
//  Always the first entry should be usage function.
//

#define  DefineAllCommands()    \
 Cmd( CmdUsage,             "usage",                GenUsageMessage,   \
        " Commands Available" )                                        \
 Cmd( CmdConnections,       "conn",                TestConnections,    \
        " Raw Connections to server" )                                 \
 Cmd( CmdGetFile,           "get",                 TestGetFile,        \
        " Simple Get File (/readme.txt) from server" )                 \


// Define command codes

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)       CmdCode,

typedef enum  _CmdCodes {
    DefineAllCommands()
    maxCmdCode
} CmdCodes;

#undef Cmd

// Define the functions and array of mappings

// General command function type
typedef BOOL ( * CMDFUNC)( int argc, char * argv[]);

typedef  struct _CmdStruct {
    CmdCodes    cmdCode;
    char *      pszCmdName;
    CMDFUNC     cmdFunc;
    char *      pszCmdComments;
} CmdStruct;


// Define Prototypes of command functions
# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)    \
    BOOL CmdFunc(int argc, char * argv[]);

// Cause an expansion to generate prototypes
// DefineAllCommands()
// Automatic generation causes a problem when we have NULL in Function ptrs :(
// Let the user explicitly define the prototypes

#undef Cmd

//
// Define the global array of commands
//

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)        \
    { CmdCode, CmdName, CmdFunc, CmdComments},

static CmdStruct   g_cmds[] = {

    DefineAllCommands()
    { maxCmdCode, NULL, NULL}       // sentinel command
};

#undef Cmd



/************************************************************
 *    Functions
 ************************************************************/

BOOL
GenUsageMessage( int argc, char * argv[])
{
    CmdStruct * pCmd;

    printf( " Usage:\n %s <server-name/address> <cmd name> <cmd arguments>\n",
            argv[0]);
    for( pCmd = g_cmds; pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {
        printf( "\t%s\t%s\n", pCmd->pszCmdName, pCmd->pszCmdComments);
    }

    return ( TRUE);
} // GenUsageMessage()



static
CmdStruct * DecodeCommand( char * pszCmd)
{
    CmdStruct * pCmd;
    if ( pszCmd != NULL) {

        for( pCmd = g_cmds;
             pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {

            if ( _stricmp( pszCmd, pCmd->pszCmdName) == 0) {
                 return ( pCmd);
            }
        } // for
    }

    return ( &g_cmds[0]);      // No match found, return usage message
} // DecodeCommand()


/************************************************************
 *    Functions
 ************************************************************/


inline
VOID
GenUserName( OUT LPSTR pszBuffer, IN LPCSTR pszPrefix, IN DWORD iteration)
{
    // assume sufficient buffer space

    // Format of response:   UserPrefix@pProcessId.tThreadId.Iteration

    sprintf( pszBuffer, "%s@p%d.t%d.%d",
            pszPrefix,
            GetCurrentProcessId(),
            GetCurrentThreadId(),
            iteration);

    return;

} // GenUserName()



DWORD
TestConnectionsInOneThread( IN CHAR * pszServer, IN DWORD nIterations)
{
    HINTERNET hinet;
    HINTERNET hFtp;
    DWORD NumSuccess = 0;
    CHAR  rgchBuffer[300];
    CHAR  rgchUserName[100];
    DWORD cbBuffer;
    DWORD dwError;
    DWORD iter;
    BOOL  fReturn2;


    hinet = InternetOpen( PSZ_APPLICATION_NAME, 0, NULL, 0, 0);

    IF_DEBUG( ENTRY) {

        DBGPRINTF(( DBG_CONTEXT, "InternetOpen()==> %08x\n", hinet));
    }

    if ( hinet == NULL) {

        return (0);
    }

    for( iter = 0 ; iter < nIterations; iter++) {

        IF_DEBUG( ITERATION) {

            DBGPRINTF(( DBG_CONTEXT, "Iteration = %u\n", iter));
        }

        GenUserName( rgchUserName, "conn", iter);

        hFtp = InternetConnect( hinet, pszServer, 0, "anonymous",
                               rgchUserName,
                               INTERNET_SERVICE_FTP, 0, NULL);
        IF_DEBUG( ENTRY) {

            DBGPRINTF(( DBG_CONTEXT, "    InternetConnect()==> %08x\n",
                       hFtp));
        }

        if ( hFtp == NULL) {

            continue;
        }

        IF_DEBUG( ENTRY) {

            DBGPRINTF(( DBG_CONTEXT, "       InternetGetLastResponse()\n"));
        }
        cbBuffer = sizeof(rgchBuffer) - 1;
        if ( InternetGetLastResponseInfo( &dwError, rgchBuffer, &cbBuffer)) {

            IF_DEBUG( RESPONSE) {

                rgchBuffer[cbBuffer] = '\0';
                cout << " ErrorCode = " << dwError
                  << "\tResponse = " << rgchBuffer;
            }
        }

        IF_DEBUG( ENTRY) {

            DBGPRINTF(( DBG_CONTEXT, "    InternetCloseHandle(%08x)\n",
                       hFtp));
        }

        if ( InternetCloseHandle(hFtp)) {
            NumSuccess++;
        }
    } // for()

    IF_DEBUG( ENTRY) {

        DBGPRINTF(( DBG_CONTEXT, "InternetCloseHandle(%08x)\n",
                   hinet));
    }

    fReturn2 = InternetCloseHandle(hinet);

    return ( NumSuccess);

} // TestConnectionsInOneThread()




BOOL TestConnections( int argc, char * argv[])
/*++
  This function routinely establishes and throws away connections.
  It does not do any other work.
  This is used for testing logon and quit sequences of FTP server.

  Arguments:
     argc  count of arguments
     argv  arguments
      argv[0] = "conn"  -- name of this test function
      argv[1] = # of thread to use for execution
      argv[2] = # of iterations for each thread.

--*/
{
    DWORD NumThreads = DEFAULT_NUMBER_OF_THREADS;
    DWORD NumIterations = DEFAULT_NUMBER_OF_ITERATIONS;
    DWORD NumSuccesses;


    if (argc >= 2 && argv[1] != NULL) {

        NumThreads = atoi(argv[1]);
    }

    if (argc >= 3 && argv[2] != NULL) {

        NumIterations = atoi(argv[2]);
    }

    // We will implement multithreading later on.

    // for now just one thread is used. ( current thread)
    NumSuccesses = TestConnectionsInOneThread(g_lpszServerAddress,
                                              NumIterations);

    cout << " Tested for Iterations : " << NumIterations;
    cout << "   Successes = " << NumSuccesses;
    cout << "   Failures  = " << (NumIterations - NumSuccesses) << endl;

    return ( NumSuccesses == NumIterations);

} // TestConnections()




DWORD
ReadFtpFile( IN HINTERNET hFtp, IN LPCSTR pszFileName, IN DWORD sTimeout)
{
    HINTERNET hFtpFile;
    CHAR  chBuffer[MAX_BUFFER_SIZE];
    DWORD dwBytesRead = 0;
    DWORD dwError = NO_ERROR;
    BOOL  fRead;

    if ( hFtp == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }

    hFtpFile = FtpOpenFile( hFtp, pszFileName, GENERIC_READ,
                           FTP_TRANSFER_TYPE_ASCII, 0);

    IF_DEBUG( ENTRY) {

        DBGPRINTF(( DBG_CONTEXT, "\t\tFtpOpenFile(%s) ==> %08x\n",
                   pszFileName, hFtpFile));
    }

    if ( hFtpFile == NULL) {

        return ( GetLastError());
    }

    //===================================
    //
    // Start copying the file from the
    // server to the client
    //
    //====================================


    if ( sTimeout != 0) {

        //
        // sleep causes data time out to occur.
        // If there is a non-zero timeout then we will have
        //  problems with data sockets timing out on server.
        //

        cout << " Requested " << pszFileName <<
          "  Sleeping for " << sTimeout << " seconds" << endl;
        Sleep( sTimeout * 1000);
    }


    do {

        dwError = NO_ERROR;

        // read and discard the data.
        fRead = InternetReadFile(
                                 hFtpFile,
                                 (LPVOID) chBuffer,
                                 (DWORD) MAX_BUFFER_SIZE,
                                 (LPDWORD) &dwBytesRead);

        if ( !fRead) {

            dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT, " InternetReadFile(%s) failed."
                       " Error=%d\n",
                       pszFileName, dwError));
        }

        IF_DEBUG( ENTRY) {

            DBGPRINTF(( DBG_CONTEXT, " InternetReadFile(%08x, %s) ==> %d"
                       " (Err=%d)\n",
                       hFtpFile, pszFileName, fRead, dwError));
        }


    } while (fRead && dwBytesRead > 0);

    //
    // Close the handle for read file
    //

    if (!InternetCloseHandle(hFtpFile)) {

        if ( dwError != NO_ERROR) {

            DBGERROR(( DBG_CONTEXT, " Double Errors are occuring Old=%d\n",
                       dwError));
        }

        dwError =  ( GetLastError());
    }

    return ( dwError);

} // ReadFtpFile()



DWORD
TestGetFileInOneThread(IN CHAR *   pszServer,
                       IN LPCSTR   pszFileName,
                       IN DWORD    nIterations,
                       IN DWORD    sTimeout)
{
    HINTERNET hinet;
    HINTERNET hFtp;
    DWORD NumSuccess = 0;
    CHAR  rgchBuffer[300];
    CHAR  rgchUserName[100];
    DWORD cbBuffer;
    DWORD dwError;
    DWORD iter;
    BOOL  fReturn2;


    hinet = InternetOpen( PSZ_APPLICATION_NAME, 0, NULL, 0, 0);

    IF_DEBUG( ENTRY) {

        DBGPRINTF(( DBG_CONTEXT, "InternetOpen()==> %08x\n", hinet));
    }

    if ( hinet == NULL) {

        return (0);
    }


    for( iter = 0 ; iter < nIterations; iter++) {

        DWORD dwReadError = NO_ERROR;


        IF_DEBUG( ITERATION) {

            DBGPRINTF(( DBG_CONTEXT, "Iteration = %u\n", iter));
        }

        GenUserName( rgchUserName, "getFile", iter);
        hFtp = InternetConnect( hinet, pszServer, 0, "anonymous", rgchUserName,
                               INTERNET_SERVICE_FTP, 0, NULL);
        IF_DEBUG( ENTRY) {

            DBGPRINTF(( DBG_CONTEXT, "    InternetConnect()==> %08x\n",
                       hFtp));
        }

        if ( hFtp == NULL) {

            continue;
        }

        dwReadError = ReadFtpFile( hFtp, pszFileName, sTimeout);

        if ( dwReadError != NO_ERROR) {

            cout << " Read File failed: Error = " << dwReadError << endl;
        }

        IF_DEBUG( ENTRY) {

            DBGPRINTF(( DBG_CONTEXT, "       InternetGetLastResponse()\n"));
        }

        cbBuffer = sizeof(rgchBuffer) - 1;
        if ( InternetGetLastResponseInfo( &dwError, rgchBuffer, &cbBuffer)) {

            IF_DEBUG( RESPONSE) {

                rgchBuffer[cbBuffer] = '\0';
                cout << " ErrorCode = " << dwError
                  << "\tResponse = " << rgchBuffer << endl;
            }
        }

        IF_DEBUG( ENTRY) {

            DBGPRINTF(( DBG_CONTEXT, "    InternetCloseHandle(%08x)\n",
                       hFtp));
        }

        if ( InternetCloseHandle(hFtp) && dwReadError == NO_ERROR) {
            NumSuccess++;
        }
    } // for()

    IF_DEBUG( ENTRY) {

        DBGPRINTF(( DBG_CONTEXT, "InternetCloseHandle(%08x)\n",
                   hinet));
    }

    fReturn2 = InternetCloseHandle(hinet);

    return ( NumSuccess);

} // TestGetFileInOneThread()




BOOL TestGetFile( int argc, char * argv[])
/*++
  This function routinely establishes and throws away connections.
  It does not do any other work.
  This is used for testing logon and quit sequences of FTP server.

  Arguments:
     argc  count of arguments
     argv  arguments
      argv[0] = "get"  -- name of this test function
      argv[1] = # of thread to use for execution
      argv[2] = # of iterations for each thread.
      argv[3] = Name of file/path to get from server.
       (default = /readme.txt)
      argv[4] = Sleep time for enabling test of data transfer timeouts
        Units = seconds
        ( default = 0 ==> do not sleep).

--*/
{
    DWORD NumThreads = DEFAULT_NUMBER_OF_THREADS;
    DWORD NumIterations = DEFAULT_NUMBER_OF_ITERATIONS;
    DWORD NumSuccesses;
    LPSTR pszFileToGet = "/readme.txt";
    DWORD sTimeout = 0;
    int   i;

    i = argc;  //  "i" is the running counter.
    switch ( argc) {

      case 5:
        --i;
        DBG_ASSERT( argv[i] != NULL);
        sTimeout = atoi(argv[i]);

        // Fall Through

      case 4:
        --i;
        DBG_ASSERT( argv[i] != NULL);
        pszFileToGet = argv[i];

        // Fall Through

      case 3:
        --i;
        DBG_ASSERT( argv[i] != NULL);
        NumIterations = atoi(argv[i]);

        // Fall through

      case 2:
        --i;
        DBG_ASSERT( argv[i] != NULL);
        NumThreads = atoi( argv[i]);

        // Fall through

      default:
      case 1: case 0:
        break;
    } // switch

    // We will implement multithreading later on.

    // for now just one thread is used. ( current thread)
    NumSuccesses = TestGetFileInOneThread(g_lpszServerAddress,
                                          pszFileToGet,
                                          NumIterations,
                                          sTimeout);

    cout << " Tested GetFile for Iterations: " << NumIterations << endl;
    cout << "   Timeout for Sleep = " << sTimeout << " seconds" << endl;
    cout << "   Successes = " << NumSuccesses;
    cout << "   Failures  = " << (NumIterations - NumSuccesses) << endl;

    return ( NumSuccesses == NumIterations);

} // TestGetFile()



int __cdecl
main( int argc, char * argv[])
{

    DWORD err = NO_ERROR;
    char ** ppszArgv;       // arguments for command functions
    int     cArgs;           // arg count for command functions
    char *  pszCmdName;
    CmdStruct  * pCmd;
    CMDFUNC pCmdFunc = NULL;

#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "ftpstress", IisFtptestGuid);
    CREATE_INITIALIZE_DEBUG();
#else
    CREATE_DEBUG_PRINT_OBJECT( "ftpstress");
    SET_DEBUG_FLAGS( DEBUG_ITERATION);
#endif

    if ( argc < 3 || argv[1] == NULL ) {

      // Insufficient arguments
       GenUsageMessage( argc, argv);
       return ( 1);
    }

    pszCmdName = argv[2];
    if (( pCmd = DecodeCommand( pszCmdName)) == NULL
        || pCmd->cmdFunc == NULL) {
        printf( "Internal Error: Invalid Command %s\n", pszCmdName);
        GenUsageMessage( argc, argv);
        return ( 1);
    }

    g_lpszServerAddress = argv[1];   // get server address
    cArgs = argc - 2;
    ppszArgv = argv + 2;

    if ( !(*pCmd->cmdFunc)( cArgs, ppszArgv)) {     // call the test function

        // Test function failed.
        printf( "Command %s failed. Error = %d\n", pszCmdName, GetLastError());
        return ( 1);
    }

    printf( " Command %s succeeded\n", pszCmdName);

    DELETE_DEBUG_PRINT_OBJECT();

    return ( 0);        // success
} // main()




/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\utility.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    utility.cxx

    This module contains routines of general utility.

    Functions exported by this module:

        TransferType
        TransferMode
        DisplayBool
        IsDecimalNumber
        AllocErrorText
        FreeErrorText
        OpenDosPath
        FlipSlashes
        OpenLogFile
        P_strncpy


    FILE HISTORY:
        KeithMo     17-Mar-1993 Created.

*/


#include "ftpdp.hxx"

extern "C" {

    # include <ntlsa.h>
};

//
//  Public functions.
//

/*******************************************************************

    NAME:       TransferType

    SYNOPSIS:   Generates printable form of a transfer type.

    ENTRY:      type - From the XFER_TYPE enumerator.

    RETURNS:    CHAR * - "ASCII", "BINARY", etc.

    HISTORY:
        KeithMo     12-Mar-1993 Created.

********************************************************************/
CHAR *
TransferType(
    XFER_TYPE type
    )
{
    CHAR * pszResult = NULL;

    switch( type )
    {
    case XferTypeAscii :
        pszResult = "ASCII";
        break;

    case XferTypeBinary :
        pszResult = "BINARY";
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT,
                    "invalid transfer type %d\n",
                    type ));
        DBG_ASSERT( FALSE );
        pszResult = "ASCII";
        break;
    }

    DBG_ASSERT( pszResult != NULL );

    return pszResult;

}   // TransferType

/*******************************************************************

    NAME:       TransferMode

    SYNOPSIS:   Generates printable form of a transfer mode.

    ENTRY:      mode - From the XFER_MODE enumerator.

    RETURNS:    CHAR * - "STREAM", "BLOCK", etc.

    NOTES:      Currently, only the STREAM mode is suppored.

    HISTORY:
        KeithMo     12-Mar-1993 Created.

********************************************************************/
CHAR *
TransferMode(
    XFER_MODE mode
    )
{
    CHAR * pszResult = NULL;

    switch( mode )
    {
    case XferModeStream :
        pszResult = "STREAM";
        break;

    case XferModeBlock :
        pszResult = "BLOCK";
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT,
                    "invalid transfer mode %d\n",
                    mode ));
        DBG_ASSERT( FALSE );
        pszResult = "STREAM";
        break;
    }

    DBG_ASSERT( pszResult != NULL );

    return pszResult;

}   // TransferMode

/*******************************************************************

    NAME:       DisplayBool

    SYNOPSIS:   Generates printable form of a boolean.

    ENTRY:      fFlag - The BOOL to display.

    RETURNS:    CHAR * - "TRUE" or "FALSE".

    HISTORY:
        KeithMo     17-Mar-1993 Created.

********************************************************************/
CHAR *
DisplayBool(
    BOOL fFlag
    )
{
    return fFlag ? "TRUE" : "FALSE";

}   // DisplayBool

/*******************************************************************

    NAME:       IsDecimalNumber

    SYNOPSIS:   Determines if a given string represents a decimal
                number.

    ENTRY:      psz - The string to scan.

    RETURNS:    BOOL - TRUE if this is a decimal number, FALSE
                    otherwise.

    HISTORY:
        KeithMo     12-Mar-1993 Created.

********************************************************************/
BOOL
IsDecimalNumber(
    CHAR * psz
    )
{
    BOOL fResult = ( *psz != '\0' );
    CHAR ch;

    while( ch = *psz++ )
    {
        if( ( ch < '0' ) || ( ch > '9' ) )
        {
            fResult = FALSE;
            break;
        }
    }

    return fResult;

}   // IsDecimalNumber

/*******************************************************************

    NAME:       AllocErrorText

    SYNOPSIS:   Maps a specified Win32 error code to a textual
                description.  In the interest of multithreaded
                safety, this routine will allocate a block of memory
                to contain the text and return a pointer to that
                block.  It is up to the caller to free the block
                with FreeErrorText.

    ENTRY:      err - The error to map.

    RETURNS:    CHAR * - A textual description of err.  Will be NULL
                    if an error occurred while mapping err to text.

    HISTORY:
        KeithMo     27-Apr-1993 Created.

********************************************************************/
CHAR *
AllocErrorText(
    APIERR err
    )
{
    APIERR   fmerr   = NO_ERROR;
    CHAR   * pszText = NULL;

    if( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER
                           | FORMAT_MESSAGE_IGNORE_INSERTS
                           | FORMAT_MESSAGE_FROM_SYSTEM
                           | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                       NULL,
                       (DWORD)err,
                       g_pInetSvc->IsSystemDBCS()   // always use english for
                           ? 0x409                  // FarEast NT system
                           : 0,
                       (LPTSTR)&pszText,
                       0,
                       NULL ) == 0 )
    {
        fmerr = GetLastError();
    }
    else
    {

    }

    IF_DEBUG( COMMANDS )
    {
        if( fmerr == NO_ERROR )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "mapped error %lu to %s\n",
                        err,
                        pszText ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot map error %lu to text, error %lu\n",
                        err,
                        fmerr ));
        }
    }

    return pszText;

}   // AllocErrorText

/*******************************************************************

    NAME:       FreeErrorText

    SYNOPSIS:   Frees the pointer returned by AllocErrorText.

    ENTRY:      pszText - The text to free.  Must be a pointer
                    returned by AllocErrorText.

    HISTORY:
        KeithMo     27-Apr-1993 Created.

********************************************************************/
VOID
FreeErrorText(
    CHAR * pszText
    )
{
    LocalFree( (HLOCAL)pszText );

}   // FreeErrorText




DWORD
OpenPathForAccess(
    LPHANDLE    phFile,
    LPSTR       pszPath,
    ULONG       DesiredAccess,
    ULONG       ShareAccess,
    HANDLE      hImpersonation
    )
/*++
  This function opens a path for access to do some verification
    or holding on to the file/directory when a user is logged on.

  Arguments:
    phFile   - pointer to handle, where a handle is stored on
                successful return.

    pszPath  - pointer to null terminated string containing the path
                for path to be opened.

    DesiredAccess - Access type to the file.

    ShareAccess - access flags for shared opens.

    hImpersonation - Impersonation token for this user - used for
                      long filename check

  Returns:
     Win32 error code - NO_ERROR on success

  Author:
     MuraliK  14-Nov-1995
--*/
{
    DWORD  dwError = NO_ERROR;

    if ( phFile == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }

    *phFile = CreateFile( pszPath,        // path for the file
                         DesiredAccess,   // fdwAccess
                         ShareAccess,     // fdwShareMode
                         NULL,            // Security attributes
                         OPEN_EXISTING,   // fdwCreate
                         FILE_FLAG_BACKUP_SEMANTICS,  // fdwAttrsAndFlags
                         NULL );          // hTemplateFile

    if ( *phFile == INVALID_HANDLE_VALUE) {

        dwError = GetLastError();
    }
    else {

        if ( strchr( pszPath, '~' )) {

            BOOL  fShort;

            RevertToSelf();

            dwError = CheckIfShortFileName( (UCHAR *) pszPath,
                                            hImpersonation,
                                            &fShort );

            if ( !dwError && fShort )
            {
                dwError = ERROR_FILE_NOT_FOUND;
                DBG_REQUIRE( CloseHandle( *phFile ));
                *phFile = INVALID_HANDLE_VALUE;
            }
        }
    }

    return ( dwError);

} // OpenPathForAccess()



/*******************************************************************

    NAME:       FlipSlashes

    SYNOPSIS:   Flips the DOS-ish backslashes ('\') into Unix-ish
                forward slashes ('/').

    ENTRY:      pszPath - The path to munge.

    RETURNS:    CHAR * - pszPath.

    HISTORY:
        KeithMo     04-Jun-1993 Created.

********************************************************************/
CHAR *
FlipSlashes(
    CHAR * pszPath
    )
{
    CHAR   ch;
    CHAR * pszScan = pszPath;

    while( ( ch = *pszScan ) != '\0' )
    {
        //
        //  skip DBCS character
        //
        if ( IsDBCSLeadByte( ch ) && *(pszScan+1) )
        {
            pszScan++;
        }
        else
        if( ch == '\\' )
        {
            *pszScan = '/';
        }

        pszScan++;
    }

    return pszPath;

}   // FlipSlashes

//
//  Private functions.
//


/*******************************************************************

    NAME:

    SYNOPSIS:   strncpy, that always terminates with a '\0'

    ENTRY:      same as strncpy.

    RETURNS:    same as strncpy.

    HISTORY:
        RobSol     02-Apr-2001 Created.

********************************************************************/
PSTR
P_strncpy(
    PSTR dst,
    PCSTR src,
    DWORD cnt)
{
    strncpy( dst, src, cnt);

    dst[ cnt - 1] = '\0';

    return dst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\virtual.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    virtual.cxx

    This module contains the virtual I/O package.

    Under Win32, the "current directory" is an attribute of a process,
    not a thread.  This causes some grief for the FTPD service, since
    it is impersonating users on the server side.  The users must
    "think" they can change current directory at will.  We'll provide
    this behaviour in this package.

    Functions exported by this module:

        VirtualCreateFile
        VirtualCreateUniqueFile
        Virtual_fopen

        VirtualDeleteFile
        VirtualRenameFile
        VirtualChDir
        VirtualRmDir
        VirtualMkDir


    FILE HISTORY:
        KeithMo     09-Mar-1993 Created.

        MuraliK     28-Mar-1995 Enabled FILE_FLAG_OVERLAPPED in OpenFile()
        MuraliK     28-Apr-1995 modified to use new canonicalization
                    11-May-1995 made parameters to be const unless otherwise
                                required.
                    12-May-1995 eliminated the old log file access

*/


#include "ftpdp.hxx"


//
//  Private prototypes.
//

VOID
VirtualpSanitizePath(
    CHAR * pszPath
    );



//
//  Public functions.
//



/*******************************************************************

    NAME:       VirtualCreateFile

    SYNOPSIS:   Creates a new (or overwrites an existing) file.
                Also handles moving the file pointer and truncating the
                file in the case of a REST command sequence.

    ENTRY:      pUserData - The user initiating the request.

                phFile - Will receive the file handle.  Will be
                    INVALID_HANDLE_VALUE if an error occurs.

                pszFile - The name of the new file.

                fAppend - If TRUE, and pszFile already exists, then
                    append to the existing file.  Otherwise, create
                    a new file.  Note that FALSE will ALWAYS create
                    a new file, potentially overwriting an existing
                    file.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.
        MuraliK     28-Apr-1995 modified to use new canonicalization

********************************************************************/
APIERR
VirtualCreateFile(
    USER_DATA * pUserData,
    HANDLE    * phFile,
    LPSTR       pszFile,
    BOOL        fAppend
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    APIERR err;
    CHAR   szCanonPath[MAX_PATH];
    DWORD  cbSize = MAX_PATH;
    DWORD  dwOffset;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( phFile != NULL );
    DBG_ASSERT( pszFile != NULL );

    dwOffset = pUserData->QueryCurrentOffset();

    // We'll want to do pretty much the same thing whether we're
    // actually appending or just starting at an offset due to a REST
    // command, so combine them here.

    fAppend = fAppend || (dwOffset != 0);

    err = pUserData->VirtualCanonicalize(szCanonPath,
                                         &cbSize,
                                         pszFile,
                                         AccessTypeCreate );

    if( err == NO_ERROR ) {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "creating %s\n", szCanonPath ));
        }

        if ( pUserData->ImpersonateUser()) {

            hFile = CreateFile( szCanonPath,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );
            //
            //  Disallow usage of short names
            //

            pUserData->RevertToSelf();

            if ( hFile != INVALID_HANDLE_VALUE )
            {
                if ( GetFileType( hFile ) != FILE_TYPE_DISK )
                {
                    DBG_REQUIRE( CloseHandle( hFile ) );
                    SetLastError( ERROR_ACCESS_DENIED );
                    hFile = INVALID_HANDLE_VALUE;
                }
                else if ( strchr( szCanonPath, '~' )) {

                    BOOL  fShort;
                    DWORD err;

                    err = CheckIfShortFileName( (UCHAR *) szCanonPath,
                                                pUserData->QueryImpersonationToken(),
                                                &fShort );

                    if ( !err && fShort ) {

                        err = ERROR_FILE_NOT_FOUND;
                    }

                    if ( err ) {

                        DBG_REQUIRE( CloseHandle( hFile ));
                        hFile = INVALID_HANDLE_VALUE;
                        SetLastError( err );
                    }
                }
            }
        }

        if( hFile == INVALID_HANDLE_VALUE ) {

            err = GetLastError();
        }

        if( fAppend && ( err == NO_ERROR ) ) {

            if (dwOffset == 0) {
                // This is a real append, not a restart sequence.
                if( SetFilePointer( hFile,
                                    0,
                                    NULL,
                                    FILE_END )
                   == (DWORD)-1L ) {

                    err = GetLastError();
                }
            } else {

                // We're in part of a restart sequence. Set the file pointer
                // to the offset, and truncate the file there.

                if (SetFilePointer( hFile,
                                    dwOffset,
                                    NULL,
                                    FILE_BEGIN)
                    == (DWORD)-1L &&
                    (dwOffset != (DWORD)-1L) ) {

                    err = GetLastError();
                }
                else {

                    if (SetEndOfFile( hFile ) == 0) {

                        err = GetLastError();

                    }
                }

            }

            if (err != NO_ERROR ) {

                CloseHandle( hFile );
                hFile = INVALID_HANDLE_VALUE;

            }

        }
    }

    if ( err != NO_ERROR) {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot create %s, error %lu\n",
                        szCanonPath,
                        err ));
        }
    }

    *phFile = hFile;

    return err;

}   // VirtualCreateFile


/*******************************************************************

    NAME:       VirtualCreateUniqueFile

    SYNOPSIS:   Creates a new unique (temporary) file in the current
                    virtual directory.

    ENTRY:      pUserData - The user initiating the request.

                phFile - Will receive the file handle.  Will be
                    INVALID_HANDLE_VALUE if an error occurs.

                pszTmpFile - Will receive the name of the temporary
                    file.  This buffer MUST be at least MAX_PATH
                    characters long.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     16-Mar-1993 Created.
        MuraliK     28-Apr-1995 modified to use new canonicalization

********************************************************************/
APIERR
VirtualCreateUniqueFile(
    USER_DATA * pUserData,
    HANDLE    * phFile,
    LPSTR       pszTmpFile
    )
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    APIERR      err   = NO_ERROR;
    DWORD       cbSize = MAX_PATH;
    CHAR        szCanon[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( phFile != NULL );
    DBG_ASSERT( pszTmpFile != NULL );

    //
    // Obtain the virtual to real path conversion.
    //

    err = pUserData->VirtualCanonicalize(szCanon,
                                         &cbSize,
                                         "", // current directory
                                         AccessTypeCreate);

    if( err == NO_ERROR )
      {
          IF_DEBUG( VIRTUAL_IO ) {

              DBGPRINTF(( DBG_CONTEXT,
                        "creating unique file %s\n", pszTmpFile ));
          }

          if ( pUserData->ImpersonateUser()) {

              if ( GetTempFileName(szCanon,
                                   "FTPD",
                                   0, pszTmpFile ) != 0
                  ) {

                  hFile = CreateFile( pszTmpFile,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL );
              }

              pUserData->RevertToSelf();
          }

          if( hFile == INVALID_HANDLE_VALUE ) {

              err = GetLastError();
          }
      }

    if( err != 0 )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot create unique file, error %lu\n",
                        err ));
        }
    }

    *phFile = hFile;

    return err;

}   // VirtualCreateUniqueFile()



/*******************************************************************

    NAME:       Virtual_fopen

    SYNOPSIS:   Opens an file stream.

    ENTRY:      pUserData - The user initiating the request.

                pszFile - The name of the file to open.

                pszMode - The type of access required.

    RETURNS:    FILE * - The open file stream, NULL if file cannot
                    be opened.

    NOTES:      Since this is only used for accessing the ~FTPSVC~.CKM
                    annotation files, we don't log file accesses here.

    HISTORY:
        KeithMo     07-May-1993 Created.
        MuraliK     28-Apr-1995 modified to use new canonicalization

********************************************************************/
FILE *
Virtual_fopen(
    USER_DATA * pUserData,
    LPSTR       pszFile,
    LPSTR       pszMode
    )
{
    FILE   * pfile = NULL;
    APIERR   err;
    CHAR     szCanonPath[MAX_PATH];
    DWORD    cbSize = MAX_PATH;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszFile != NULL );
    DBG_ASSERT( pszMode != NULL );

    err = pUserData->VirtualCanonicalize(szCanonPath,
                                         &cbSize,
                                         pszFile,
                                         *pszMode == 'r'
                                         ? AccessTypeRead
                                         : AccessTypeWrite );

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "opening %s\n", szCanonPath ));
        }

        if ( pUserData->ImpersonateUser()) {

            pfile = fopen( szCanonPath, pszMode );

            pUserData->RevertToSelf();
        }

        if( pfile == NULL )
        {
            err = ERROR_FILE_NOT_FOUND; // best guess
        }
    }

    IF_DEBUG( VIRTUAL_IO )
    {
        if( err != NO_ERROR )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot open %s, error %lu\n",
                        pszFile,
                        err ));
        }
    }

    return pfile;

}   // Virtual_fopen




/*******************************************************************

    NAME:       VirtualDeleteFile

    SYNOPSIS:   Deletes an existing file.

    ENTRY:      pUserData - The user initiating the request.

                pszFile - The name of the file.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
APIERR
VirtualDeleteFile(
    USER_DATA * pUserData,
    LPSTR       pszFile
    )
{
    APIERR err;
    DWORD  cbSize = MAX_PATH;
    CHAR   szCanonPath[MAX_PATH];
    DWORD  dwAccessMask = 0;

    DBG_ASSERT( pUserData != NULL );

    //
    //  We'll canonicalize the path, asking for *read* access.  If
    //  the path canonicalizes correctly, we'll then try to open the
    //  file to ensure it exists.  Only then will we check for delete
    //  access to the path.  This mumbo-jumbo is necessary to get the
    //  proper error codes if someone trys to delete a nonexistent
    //  file on a read-only volume.
    //

    err = pUserData->VirtualCanonicalize(szCanonPath,
                                         &cbSize,
                                         pszFile,
                                         AccessTypeRead,
                                         &dwAccessMask);

    if( err == NO_ERROR )
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;

        if ( pUserData->ImpersonateUser()) {

            hFile = CreateFile( szCanonPath,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

            pUserData->RevertToSelf();
        }

        if( hFile == INVALID_HANDLE_VALUE )
        {
            err = GetLastError();
        }
        else
        {
            //
            //  The file DOES exist.  Close the handle, then check
            //  to ensure we really have delete access.
            //

            CloseHandle( hFile );

            if( !PathAccessCheck( AccessTypeDelete,
                                 dwAccessMask,
                                 TEST_UF(pUserData, READ_ACCESS),
                                 TEST_UF(pUserData, WRITE_ACCESS)
                                 )
               ) {

                err = ERROR_ACCESS_DENIED;
            }
        }
    }

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "deleting %s\n", szCanonPath ));
        }

        if ( pUserData->ImpersonateUser()) {

            if( !DeleteFile( szCanonPath ) ) {

                err = GetLastError();

                IF_DEBUG( VIRTUAL_IO ) {

                    DBGPRINTF(( DBG_CONTEXT,
                               "cannot delete %s, error %lu\n",
                               szCanonPath,
                               err ));
                }
            }

            pUserData->RevertToSelf();
        } else {

            err = GetLastError();
        }
    }
    else
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot canonicalize %s - %s, error %lu\n",
                        pUserData->QueryCurrentDirectory(),
                        pszFile,
                        err ));
        }
    }

    return err;

}   // VirtualDeleteFile()



/*******************************************************************

    NAME:       VirtualRenameFile

    SYNOPSIS:   Renames an existing file or directory.

    ENTRY:      pUserData - The user initiating the request.

                pszExisting - The name of an existing file or directory.

                pszNew - The new name for the file or directory.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     10-Mar-1993 Created.

********************************************************************/
APIERR
VirtualRenameFile(
    USER_DATA * pUserData,
    LPSTR       pszExisting,
    LPSTR       pszNew
    )
{
    APIERR err;
    DWORD  cbSize = MAX_PATH;
    CHAR   szCanonExisting[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );

    err = pUserData->VirtualCanonicalize(szCanonExisting,
                                         &cbSize,
                                         pszExisting,
                                         AccessTypeDelete );

    if( err == NO_ERROR ) {

        CHAR   szCanonNew[MAX_PATH];
        cbSize = MAX_PATH;

        err = pUserData->VirtualCanonicalize(szCanonNew,
                                             &cbSize,
                                             pszNew,
                                             AccessTypeCreate );

        if( err == NO_ERROR ) {

            IF_DEBUG( VIRTUAL_IO ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "renaming %s to %s\n",
                           szCanonExisting,
                           szCanonNew ));
            }

            if ( pUserData->ImpersonateUser()) {

                if( !MoveFileEx( szCanonExisting,
                                 szCanonNew,
                                 pUserData->QueryInstance()->AllowReplaceOnRename()
                                     ? MOVEFILE_REPLACE_EXISTING
                                     : 0 )
                   ){

                    err = GetLastError();

                    IF_DEBUG( VIRTUAL_IO ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                   "cannot rename %s to %s, error %lu\n",
                                   szCanonExisting,
                                   szCanonNew,
                                   err ));
                    }
                }

                pUserData->RevertToSelf();

            } else {
                err = GetLastError();
            }

        } else  {

            IF_DEBUG( VIRTUAL_IO ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "cannot canonicalize %s - %s, error %lu\n",
                           pUserData->QueryCurrentDirectory(),
                           pszExisting,
                           err ));
            }
        }
    } else {

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                        "cannot canonicalize %s - %s, error %lu\n",
                       pUserData->QueryCurrentDirectory(),
                       pszExisting,
                       err ));
        }
    }

    return err;

}   // VirtualRenameFile()




APIERR
VirtualChDir(
    USER_DATA * pUserData,
    LPSTR       pszDir
    )
/*++
  This function sets the current directory to newly specified directory.

  Arguments:
     pUserData -- the user initiating the request
     pszDir  -- pointer to null-terminated buffer containing the
                   new directory name.
  Returns:
     APIERR  -- NO_ERROR if successful, otherwise a Win32 error code.

  History:
     MuraliK   28-Apr-1995  Modified to use symbolic roots.
--*/
{
    CHAR     rgchVirtual[MAX_PATH];
    APIERR   err = NO_ERROR;
    DWORD    cbSize;
    CHAR     szCanonDir[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );

    if (pszDir == NULL || *pszDir == '\0') {

        //
        // Nothing new specified.
        //

        return ( NO_ERROR);
    }


    //
    // Form the complete virtual path for the given path.
    //  We have to form a compelete virtual path and sanitize it, because:
    //     if this new directory is valid, we have to store the
    //      sanitized path in the CurrentDirectory member of USER_DATA.
    //

    if ( !IS_PATH_SEP( *pszDir)) {

        const CHAR * pszNewDir = pUserData->QueryCurrentDirectory();

        //
        // This is a relative path. append it to currrent directory
        //

        if ( strlen(pszNewDir) + strlen(pszDir) + 2 <= MAX_PATH) {

            // copy the current directory
            wsprintfA( rgchVirtual, "%s/%s",
                      pszNewDir, pszDir);
            pszDir = rgchVirtual;

        } else {

            // long path --> is not supported.
            DBGPRINTF((DBG_CONTEXT, "Long Virtual Path %s---%s\n",
                       pszNewDir, pszDir));

            return ( ERROR_PATH_NOT_FOUND);
        }

    }

    DBG_ASSERT( IS_PATH_SEP(*pszDir));
    VirtualpSanitizePath( pszDir);


    //
    //  Canonicalize the new path.
    //  Canonicalize() automatically updates the current directory if need be
    //

    cbSize = sizeof(szCanonDir);
    err = pUserData->VirtualCanonicalize(szCanonDir,
                                         &cbSize,
                                         pszDir,
                                         AccessTypeRead );

    if ( err == ERROR_ACCESS_DENIED) {

        //
        // this maybe a write only virtual root directory.
        // Let us try again to find we have Write access atleast
        //

        cbSize = sizeof(szCanonDir);
        err = pUserData->VirtualCanonicalize(szCanonDir,
                                             &cbSize,
                                             pszDir,
                                             AccessTypeWrite );
    }

    if( err != NO_ERROR )
    {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot canonicalize %s - %s, error %lu\n",
                       pUserData->QueryCurrentDirectory(),
                       pszDir,
                       err ));
        }

        return err;
    }

    //
    //  Try to open the directory and get a handle for the same.
    //

    // This is possibly a new place to change directory to.

    if ( pUserData->ImpersonateUser()) {

        HANDLE CurrentDirHandle = INVALID_HANDLE_VALUE;

        err = OpenPathForAccess( &CurrentDirHandle,
                                szCanonDir,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                pUserData->QueryImpersonationToken()
                                );

        if( err == ERROR_ACCESS_DENIED ) {
            err = OpenPathForAccess( &CurrentDirHandle,
                                    szCanonDir,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    pUserData->QueryImpersonationToken()
                                    );
        }

        if( err == NO_ERROR ) {

            BY_HANDLE_FILE_INFORMATION fileInfo;
            BOOL fRet;

            fRet = GetFileInformationByHandle( CurrentDirHandle,
                                              &fileInfo);

            if ( !fRet) {

                err = GetLastError();

                // Error in getting the file information.
                // close handle and return.

                CloseHandle( CurrentDirHandle);

            } else {

                if ( (fileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    != FILE_ATTRIBUTE_DIRECTORY) {

                    //
                    // this file is not a directory.
                    // Do not change directory. But return error.
                    //

                    err = ERROR_DIRECTORY;
                    CloseHandle( CurrentDirHandle);
                } else {

                    //
                    //  Directory successfully opened.  Save the handle
                    //  in the per-user data. This handle is maintained to
                    //  prevent accidental deletion of the directory.
                    //

                    if( pUserData->CurrentDirHandle != INVALID_HANDLE_VALUE ) {

                        IF_DEBUG( VIRTUAL_IO ) {

                            DBGPRINTF(( DBG_CONTEXT,
                                       "closing dir handle %08lX for %s\n",
                                       pUserData->CurrentDirHandle,
                                       pUserData->QueryCurrentDirectory()));
                        }

                        CloseHandle( pUserData->CurrentDirHandle );
                    }

                    pUserData->CurrentDirHandle = CurrentDirHandle;

                    IF_DEBUG( VIRTUAL_IO ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                   "opened directory %s, handle = %08lX\n",
                                   szCanonDir,
                                   CurrentDirHandle ));
                    }

                    // update the current directory
                    pUserData->SetCurrentDirectory( pszDir );

                }
            }
        }

        pUserData->RevertToSelf();

    } else {

        // Impersonation failed
        err = GetLastError();
    }

    IF_DEBUG( VIRTUAL_IO ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "chdir to %s  returns error = %d\n", szCanonDir, err ));
    }

    return ( err);

}   // VirtualChDir()



/*******************************************************************

    NAME:       VirtualRmDir

    SYNOPSIS:   Removes an existing directory.

    ENTRY:      pUserData - The user initiating the request.

                pszDir - The name of the directory to remove.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
APIERR
VirtualRmDir(
    USER_DATA * pUserData,
    LPSTR      pszDir
    )
{
    APIERR err;
    DWORD  cbSize = MAX_PATH;
    CHAR   szCanonDir[MAX_PATH];

    err = pUserData->VirtualCanonicalize(szCanonDir,
                                         &cbSize,
                                         pszDir,
                                         AccessTypeDelete );

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "rmdir %s\n", szCanonDir ));
        }

        if ( pUserData->ImpersonateUser()) {

            if( !RemoveDirectory( szCanonDir ) ) {

                err = GetLastError();

                IF_DEBUG( VIRTUAL_IO ) {

                    DBGPRINTF(( DBG_CONTEXT,
                               "cannot rmdir %s, error %lu\n",
                               szCanonDir,
                               err ));
                }
            }
            pUserData->RevertToSelf();
        } else {
            err = GetLastError();
        }
    } else {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot canonicalize %s - %s, error %lu\n",
                        pUserData->QueryCurrentDirectory(),
                        pszDir,
                        err ));
        }
    }

    return err;

}   // VirtualRmDir



/*******************************************************************

    NAME:       VirtualMkDir

    SYNOPSIS:   Creates a new directory.

    ENTRY:      pUserData - The user initiating the request.

                pszDir - The name of the directory to create.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
APIERR
VirtualMkDir(
    USER_DATA * pUserData,
    LPSTR      pszDir
    )
{
    APIERR err;
    DWORD  cbSize = MAX_PATH;
    CHAR   szCanonDir[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );

    err = pUserData->VirtualCanonicalize(szCanonDir,
                                         &cbSize,
                                         pszDir,
                                         AccessTypeCreate );

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "mkdir %s\n", szCanonDir ));
        }

        if ( pUserData->ImpersonateUser()) {

            if( !CreateDirectory( szCanonDir, NULL ) ) {

                err = GetLastError();

                IF_DEBUG( VIRTUAL_IO )
                  {
                      DBGPRINTF(( DBG_CONTEXT,
                                 "cannot mkdir %s, error %lu\n",
                                 szCanonDir,
                                 err ));
                  }
            }
            pUserData->RevertToSelf();
        } else {
            err = GetLastError();
        }
    } else {

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot canonicalize %s - %s, error %lu\n",
                       pUserData->QueryCurrentDirectory(),
                       pszDir,
                       err ));
        }
    }

    return err;

}   // VirtualMkDir




//
//  Private constants.
//

#define ACTION_NOTHING              0x00000000
#define ACTION_EMIT_CH              0x00010000
#define ACTION_EMIT_DOT_CH          0x00020000
#define ACTION_EMIT_DOT_DOT_CH      0x00030000
#define ACTION_BACKUP               0x00040000
#define ACTION_MASK                 0xFFFF0000


//
//  Private globals.
//

INT p_StateTable[4][4] =
    {
        {   // state 0
            1 | ACTION_EMIT_CH,             // "\"
            0 | ACTION_EMIT_CH,             // "."
            4 | ACTION_EMIT_CH,             // EOS
            0 | ACTION_EMIT_CH              // other
        },

        {   // state 1
            1 | ACTION_NOTHING,             // "\"
            2 | ACTION_NOTHING,             // "."
            4 | ACTION_EMIT_CH,             // EOS
            0 | ACTION_EMIT_CH              // other
        },

        {   // state 2
            1 | ACTION_NOTHING,             // "\"
            3 | ACTION_NOTHING,             // "."
            4 | ACTION_EMIT_CH,             // EOS
            0 | ACTION_EMIT_DOT_CH          // other
        },

        {   // state 3
            1 | ACTION_BACKUP,              // "\"
            0 | ACTION_EMIT_DOT_DOT_CH,     // "."
            4 | ACTION_BACKUP,              // EOS
            0 | ACTION_EMIT_DOT_DOT_CH      // other
        }
    };



/*******************************************************************

    NAME:       VirtualpSanitizePath

    SYNOPSIS:   Sanitizes a path by removing bogus path elements.

                As expected, "/./" entries are simply removed, and
                "/../" entries are removed along with the previous
                path element.

                To maintain compatibility with URL path semantics
                 additional transformations are required. All backward
                 slashes "\\" are converted to forward slashes. Any
                 repeated forward slashes (such as "///") are mapped to
                 single backslashes.  Also, any trailing path elements
                 consisting solely of dots "/....." are removed.

                Thus, the path "/foo\./bar/../tar\....\......" is
                mapped to "/foo/tar".

                A state table (see the p_StateTable global at the
                beginning of this file) is used to perform most of
                the transformations.  The table's rows are indexed
                by current state, and the columns are indexed by
                the current character's "class" (either slash, dot,
                NULL, or other).  Each entry in the table consists
                of the new state tagged with an action to perform.
                See the ACTION_* constants for the valid action
                codes.

                After the FSA is finished with the path, we make one
                additional pass through it to remove any trailing
                backslash, and to remove any trailing path elements
                consisting solely of dots.

    ENTRY:      pszPath - The path to sanitize.

    HISTORY:
        KeithMo     07-Sep-1994 Created.
        MuraliK     28-Apr-1995 Adopted this for symbolic paths

********************************************************************/
VOID
VirtualpSanitizePath(
    CHAR * pszPath
    )
{
    CHAR * pszSrc;
    CHAR * pszDest;
    CHAR * pszHead;
    CHAR   ch;
    INT    State;
    INT    Class;
    BOOL   fDBCS = FALSE;

    //
    //  Ensure we got a valid symbolic path (something starting "/"
    //

    DBG_ASSERT( pszPath != NULL );
//     DBG_ASSERT( pszPath[0] == '/');

    //
    //  Start our scan at the first "/.
    //

    pszHead = pszSrc = pszDest = pszPath;

    //
    //  State 0 is the initial state.
    //

    State = 0;

    //
    //  Loop until we enter state 4 (the final, accepting state).
    //

    while( State != 4 )
    {
        //
        //  Grab the next character from the path and compute its
        //  character class.  While we're at it, map any forward
        //  slashes to backward slashes.
        //

        ch = *pszSrc++;

        switch( ch )
        {
        case '\\' :
            //
            //  fDBCS is always false for non-DBCS system
            //

            if ( fDBCS )
            {
                Class = 3;
                break;
            }
            ch = '/';  // convert it to symbolic URL path separator char.
            /* fall through */

        case '/' :
            Class = 0;
            break;

        case '.' :
            Class = 1;
            break;

        case '\0' :
            Class = 2;
            break;

        default :
            Class = 3;
            break;
        }

        //
        //  Advance to the next state.
        //

        State = p_StateTable[State][Class];

        //
        //  Perform the action associated with the state.
        //

        switch( State & ACTION_MASK )
        {
        case ACTION_EMIT_DOT_DOT_CH :
            *pszDest++ = '.';
            /* fall through */

        case ACTION_EMIT_DOT_CH :
            *pszDest++ = '.';
            /* fall through */

        case ACTION_EMIT_CH :
            *pszDest++ = ch;
            /* fall through */

        case ACTION_NOTHING :
            break;

        case ACTION_BACKUP :
            if( pszDest > ( pszHead + 1 ) )
            {
                pszDest--;
                DBG_ASSERT( *pszDest == '/' );

                *pszDest = '\0';
                pszDest = strrchr( pszPath, '/') + 1;
            }

            *pszDest = '\0';
            break;

        default :
            DBG_ASSERT( !"Invalid action code in state table!" );
            State = 4;
            *pszDest++ = '\0';
            break;
        }

        State &= ~ACTION_MASK;
        if ( !fDBCS )
        {
            if ( IsDBCSLeadByte( ch ) )
            {
                fDBCS = TRUE;
            }
        }
        else
        {
            fDBCS = FALSE;
        }
    }

    //
    //  Remove any trailing slash.
    //

    pszDest -= 2;

    if( ( strlen( pszPath ) > 3 ) && ( *pszDest == '/' ) )
    {
        *pszDest = '\0';
    }

    //
    //  If the final path elements consists solely of dots, remove them.
    //

    while( strlen( pszPath ) > 3 )
    {
        pszDest = strrchr( pszPath, '/');
        DBG_ASSERT( pszDest != NULL );

        pszHead = pszDest;
        pszDest++;

        while( ch = *pszDest++ )
        {
            if( ch != '.' )
            {
                break;
            }
        }

        if( ch == '\0' )
        {
            //
            // this is probably dead code left over from
            // when we used physical paths.
            //
            if( pszHead == ( pszPath + 2 ) )
            {
                pszHead++;
            }
            // end of dead code

            //
            // Don't remove the first '/'
            //
            if ( pszHead == pszPath )
            {
                pszHead++;
            }

            *pszHead = '\0';
        }
        else
        {
            break;
        }
    }

}   // VirtualpSanitizePath


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\ftp\server51\userdb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    userdb.cxx

    This module manages the user database for the FTPD Service.

    Functions exported by this module:


        DisconnectUser()
        DisconnectUsersWithNoAccess()
        EnumerateUsers()

        USER_DATA::USER_DATA()
        USER_DATA::Reset()
        USER_DATA::~USER_DATA()
        USER_DATA::Cleanup()
        USER_DATA::ProcessAsyncIoCompletion()
        USER_DATA::ReInitializeForNewUser()
        USER_DATA::ReadCommand()
        USER_DATA::DisconnectUserWithError()
        USER_DATA::SendMultilineMessage()
        USER_DATA::SendDirectoryAnnotation()
        USER_DATA::GetFileSize();

        ProcessUserAsyncIoCompletion()

    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     March-May, 1995
                      Adding support for Async Io/Transfers
                      + new USER_DATA class functions defined.
                      + oob_inline enabled; ReadCommand() issued after
                          data socket is established.
                      + added member functions for common operations
                      + added ProcessAsyncIoCompletion()
                      + added Establish & Destroy of Data connection

       MuraliK   26-July-1995    Added Allocation caching of client conns.
       Terryk    18-Sep-1996     Added GetFileSize
       AMallet   Sep 1998        Added support for AcceptEx() of PASV data connections
*/


#include "ftpdp.hxx"
# include "tsunami.hxx"
#include <timer.h>
# include "auxctrs.h"
# include <mbstring.h>
#include "acptctxt.hxx"

#define FIRST_TELNET_COMMAND    240
#define TELNET_DM_COMMAND       242
#define TELNET_IP_COMMAND       244
#define TELNET_SB_CODE          250
#define TELNET_SB_CODE_MIN      251
#define TELNET_SB_CODE_MAX      254
#define TELNET_IAC_CODE         255

# define  MAX_FILE_SIZE_SPEC           ( 32)


//
//  Private globals.
//

#define PSZ_DEFAULT_SUB_DIRECTORY   "Default"

static const char PSZ_SENT_VERB[]  = "sent";
static const char PSZ_CONNECTION_CLOSED_VERB[]  = "closed";
static const char PSZ_FILE_ERROR[] = "%s: %s";
static const char PSZ_TRANSFER_COMPLETE[]  = "Transfer complete.";
static const char PSZ_TRANSFER_ABORTED[] =
    "Connection closed; transfer aborted.";
static const char PSZ_TRANSFER_STARTING[] =
    "Data connection already open; Transfer starting.";
static const char PSZ_INSUFFICIENT_RESOURCES[] =
    "Insufficient system resources.";
static const char PSZ_TOO_MANY_PASV_USERS[] =
    "Too many passive-mode users.";
static const char PSZ_OPENING_DATA_CONNECTION[] =
    "Opening %s mode data connection for %s%s.";
static const char PSZ_CANNOT_OPEN_DATA_CONNECTION[] =
    "Can't open data connection.";
static const char PSZ_COMMAND_TOO_LONG[] =
    "Command was too long";

static DWORD  p_NextUserId = 0;        // Next available user id.

//
//  Private prototypes.
//

DWORD
UserpGetNextId(
    VOID
    );



inline VOID
StopControlRead( IN LPUSER_DATA pUserData)
/*++
  Stops control read operation, if one is proceeding.
  Resets the CONTROL_READ flag as well as decrements ref count in user data.

--*/
{
    if ( TEST_UF( pUserData, CONTROL_READ)) {

        if ( InterlockedDecrement( &pUserData->m_nControlRead) < 0 ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "StopControLRead: no read active!!!\n"));
            DBG_ASSERT( FALSE);
        }

        DBG_REQUIRE( pUserData->DeReference() > 0);
        CLEAR_UF( pUserData, CONTROL_READ);
    }

} // StopControlRead()


BOOL
FilterTelnetCommands(IN CHAR * pszLine, IN DWORD cchLine,
                     IN LPBOOL pfLineEnded,
                     IN LPDWORD  pcchRequestRecvd)
/*++
  Filters out the Telnet commands and
  terminates the command line with  linefeed.

  Also this function filters out the out of band data.
  This works similar to the Sockutil.cxx::DiscardOutOfBandData().
  We scan for the pattern "ABOR\r\n" and
   set the OOB_DATA flag if it is present.

  Arguments:
   pszLine   pointer to null terminated string containing the input data.
   cchLine   count  of characters of data received
   pfLineEnded  pointer to Boolean flag which is set to true if complete
             line has been received.
   pcchRequestRecvd  pointer to DWORD which on return contains the number
                      of bytes received.

  Returns:
    TRUE if the filtering is successful without any out of band abort request.
    FALSE if there was any abort request in the input.

--*/
{
    BOOL    fDontAbort = TRUE;
    BOOL    fStateTelnetCmd = FALSE;
    BOOL    fStateTelnetSB = FALSE;
    BOOL    fFoundTelnetIP = FALSE;
    CHAR *  pszSrc;
    CHAR *  pszDst;

    LPCSTR  pszAbort = "ABOR\r\n";
    LPCSTR  pszNext  = pszAbort;

    DBG_ASSERT( pszLine != NULL && cchLine > 0 &&
               pfLineEnded != NULL && pcchRequestRecvd != NULL);

    *pfLineEnded = FALSE;

    for( pszSrc = pszDst = pszLine; pszSrc < pszLine + cchLine &&  *pszSrc;
        pszSrc++) {

        CHAR ch = *pszSrc;
        BYTE uch = (BYTE)ch;

        //
        // Filter out TELNET commands. these are of the form: IAC <cmd> or
        // IAC SB <op> (IAC = 255, SB = 250, op 251..254, cmd > 240)
        //

        if( fStateTelnetCmd ) {
           //
           // we are in a Telbent command sequence
           //

           fStateTelnetCmd = FALSE;

           DBG_ASSERT( uch >= FIRST_TELNET_COMMAND );

           if( fStateTelnetSB ) {
              //
              // we are in a Telnet subsequence command
              //

              fStateTelnetSB = FALSE;

              DBG_ASSERT( (uch >= TELNET_SB_CODE_MIN) &&
                          (uch <= TELNET_SB_CODE_MAX) );

              if( uch >= FIRST_TELNET_COMMAND ) {
                 //
                 // consider it a valid Telnet command, as long as it's in
                 // the Telnet range. Filter this char out.
                 //

                 continue;
              }

              //
              // this is a TELNET protocol error, we'll ignore it.
              //
              // fall through with this char
              //

           } else if( uch == TELNET_SB_CODE ) {
              //
              // enter Telnet subsequense command state
              //

              fStateTelnetCmd = fStateTelnetSB = TRUE;
              continue;

           } else if( uch == TELNET_IAC_CODE ) {
              //
              // this is an escape sequence for a 255 data byte
              //
              // let it fall through
              //

           } else if ( uch == TELNET_IP_COMMAND ) {
              //
              // remember this, it is the first in a SYNCH sequence
              //

              fFoundTelnetIP = TRUE;
              continue;

           } else if ( uch == TELNET_DM_COMMAND ) {
              //
              // if in a SYNCH sequence, this resets the input stream
              //

              if( fFoundTelnetIP ) {
                  pszDst = pszLine;
                  fFoundTelnetIP = FALSE; // completed the SYNCH sequence
              }
              continue;

           } else {
              //
              // we expect a Telnet command code here. filter it out
              //

              DBG_ASSERT( uch >= FIRST_TELNET_COMMAND );

              if ( uch >= FIRST_TELNET_COMMAND ) {
                 continue;
              }

              //
              // this is a TELNET protocol error, we'll ignore it.
              //
              // fall through with this char
              //
           }
        } else if( uch == TELNET_IAC_CODE ) {
           //
           // entering Telnet command parsing state
           //

           fStateTelnetCmd = TRUE;
           continue;
        } else if( uch == TELNET_DM_COMMAND ) {
            //
            // FTP.EXE on Win2k is sending an unexpected SYNCH sequence: DM, IAC, IP. See if this is it.
            //

            if( ( pszSrc == pszLine ) &&
                ( cchLine >= 3 ) &&
                ( (UINT)*(pszSrc+1) == TELNET_IAC_CODE ) &&
                ( (UINT)*(pszSrc+2) == TELNET_DM_COMMAND ) ) {
                //
                // just filter the sequence out
                //

                pszSrc += 2;

                continue;

            } else if( fFoundTelnetIP ) {
                //
                // or, it could be a single byte URGENT notification in the telnet Sync
                //

                pszDst = pszLine;

                fFoundTelnetIP = FALSE; // completed the SYNCH sequence

                continue;
            }
        }

        //
        // if we have seen a Telnet IP, then skip everything up to a DM
        //

        if (fFoundTelnetIP) {
            continue;
        }

        //
        // try matching ABOR\r\n
        //

        if ( *pszNext != ch) {

            // the pattern match failed. reset to start at the beginning.

            pszNext = pszAbort;
        }

        if ( *pszNext == ch) {

            // pattern match at this character. move forward
            pszNext++;

            if ( *pszNext == '\0') {   // end of string==> all matched.

                // only consider this an OOB Abort if at the beginning of
                // a (reset) line

                if( (pszDst - pszLine + 2) == (pszNext - pszAbort) ) {
                    fDontAbort = FALSE;
                }

                pszNext = pszAbort;
            }
        }

        //
        //  don't copy <CR> and <LF> to the output
        //

        if ( (ch != '\r') && ( ch != '\n')) {

            *pszDst++ = ch;

        } else if ( ch == '\n') {

            // terminate at the linefeed
            *pfLineEnded = TRUE;
            break;
        }

    } // for

    //
    // remember Telnet IP if we have seen it
    //

    if (fFoundTelnetIP) {

       //
       // we can safely do this, as we have filtered the 2 byte sequence out earlier
       //

       *(UCHAR*)pszDst++ = TELNET_IAC_CODE;
       *(UCHAR*)pszDst++ = TELNET_IP_COMMAND;
    }

    //
    // remember Telnet command states
    //
    if( fStateTelnetCmd ) {

       *(UCHAR*)pszDst++ = TELNET_IAC_CODE;

       if( fStateTelnetSB ) {
          *(UCHAR*)pszDst++ = TELNET_SB_CODE;
       }
    }

    *pszDst = '\0';

    *pcchRequestRecvd = DIFF(pszDst - pszLine);
    DBG_ASSERT( *pcchRequestRecvd <= cchLine);

    return (fDontAbort);

} // FilterTelnetCommands()



//
//  Public functions.
//





USER_DATA::USER_DATA(
    IN FTP_SERVER_INSTANCE *pInstance
    )
/*++
  This function creates a new UserData object for the information
    required to process requests from a new User connection ( FTP).

  Arguments:
     sControl   Socket used for control channel in FTP connection
     clientIpAddress  strcuture containing the client Ip address

  Returns:
     a newly constructed USER_DATA object.
     Check IsValid() to ensure the object was properly created.

  NOTE:
    This function is to be used for dummy creation of the object so
      allocation cacher can use this object.
    Fields are randomly initialized. Reset() will initialize them properly.

    However when a new effective USER_DATA object is needed, after allocation
     one can call USER_DATA::Reset() to initialize all vars.
--*/
:
  m_References              ( 0),
  m_ActiveRefAdded          ( 0),
  m_cchRecvBuffer           ( 0),
  m_cbRecvd                 ( 0),
  m_cchPartialReqRecvd      ( 0),
  m_pOpenFileInfo           ( NULL),
  Flags                     ( 0),
  UserToken                 ( NULL),
  m_UserId                  ( 0),
  DataPort                  ( 0),
  UserState                 ( UserStateEmbryonic),
  m_AioControlConnection    ( ProcessUserAsyncIoCompletion),
  m_AioDataConnection       ( ProcessUserAsyncIoCompletion),
  m_sPassiveDataListen      ( INVALID_SOCKET),
  CurrentDirHandle          ( INVALID_HANDLE_VALUE),
  RenameSourceBuffer        ( NULL),
  m_fCleanedup              ( FALSE),
  m_pMetaData               ( NULL),
  m_pInstance               ( pInstance ),
  m_acCheck                 ( AC_NOT_CHECKED ),
  m_fNeedDnsCheck           ( FALSE ),
  m_dwLastReplyCode         ( 0 ),
  m_fHavePASVConn           ( FALSE ),
  m_fWaitingForPASVConn     ( FALSE ),
  m_fFakeIOCompletion       ( FALSE ),
  m_pszCmd                  ( NULL ),
  m_hPASVAcceptEvent        ( NULL )
#if DBG
  ,m_RefTraceLog( NULL )
#endif
{
    DWORD dwTimeout = m_pInstance->QueryConnectionTimeout();

    INITIALIZE_CRITICAL_SECTION( &m_UserLock );

    //
    //  Setup the structure signature.
    //

    INIT_USER_SIG( this );

    m_AioControlConnection.SetAioInformation( this, dwTimeout);
    m_AioDataConnection.SetAioInformation( this, dwTimeout);

    InitializeListHead( &ListEntry);

    ZeroMemory( m_recvBuffer, DEFAULT_REQUEST_BUFFER_SIZE);

    IF_DEBUG( USER_DATABASE ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "user_data object created  @ %08lX.\n",
                   this));
    }

    m_licbSent.QuadPart = 0;

#if DBG
    m_RefTraceLog = CreateRefTraceLog( TRACE_LOG_SIZE, 0 );
#endif

        FakeIOTimes = 0;

} // USER_DATA::USER_DATA()



USER_DATA::~USER_DATA(VOID)
{

    if ( !m_fCleanedup) {
        Cleanup();
    }

    if( RenameSourceBuffer != NULL ) {
        TCP_FREE( RenameSourceBuffer);
        RenameSourceBuffer = NULL;
    }

    if ( m_pszCmd != NULL )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    if ( m_hPASVAcceptEvent != NULL )
    {
        RemovePASVAcceptEvent( TRUE );
    }

    if ( m_pInstance != NULL ) {
        m_pInstance->DecrementCurrentConnections();
        m_pInstance->Dereference();
        m_pInstance = NULL;
    }

#if DBG
    if( m_RefTraceLog != NULL ) {
        DestroyRefTraceLog( m_RefTraceLog );
    }
#endif

    DeleteCriticalSection( &m_UserLock );

} // USER_DATA::~USER_DATA()



BOOL
USER_DATA::Reset(IN SOCKET          sControl,
                 IN PVOID           EndpointObject,
                 IN IN_ADDR         clientIpAddress,
                 IN const SOCKADDR_IN * psockAddrLocal /* = NULL */ ,
                 IN PATQ_CONTEXT    pAtqContext         /* = NULL */ ,
                 IN PVOID           pvInitialRequest    /* = NULL */ ,
                 IN DWORD           cbWritten           /* = 0    */ ,
                 IN AC_RESULT       acCheck
                 )
{
    BOOL  fReturn = TRUE;

    //
    //  Setup the structure signature.
    //

    INIT_USER_SIG( this );

    m_References    = 1;  // set to 1 to prevent immediate deletion.
    m_ActiveRefAdded=  1;
    m_fCleanedup    = FALSE;
    Flags           = m_pInstance->QueryUserFlags();
    UserState       = UserStateEmbryonic;

#if DBG
    if( m_RefTraceLog != NULL ) {
        ResetTraceLog( m_RefTraceLog );
    }
#endif

    m_pOpenFileInfo = NULL;
    UserToken       = NULL;
    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }
    m_UserId        = UserpGetNextId();
    m_xferType      = XferTypeAscii;
    m_xferMode      = XferModeStream;
    m_msStartingTime= 0;
    m_acCheck       = acCheck;
    m_fNeedDnsCheck = FALSE;
    m_dwLastReplyCode = 0;

    HostIpAddress   = clientIpAddress;
    DataIpAddress   = clientIpAddress;

    m_cbRecvd       = 0;
    m_cchRecvBuffer = sizeof( m_recvBuffer) - sizeof(m_recvBuffer[0]);
    m_cchPartialReqRecvd = 0;

    CurrentDirHandle   = INVALID_HANDLE_VALUE;
    RenameSourceBuffer = NULL;
    m_TimeAtConnection = GetCurrentTimeInSeconds();
    m_TimeAtLastAccess = m_TimeAtConnection;


    m_pvInitialRequest  = pvInitialRequest;
    m_cbInitialRequest  = cbWritten;

    //
    // clean up the stuff needed to deal async with PASV command
    //
    if ( m_pszCmd )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    if ( m_hPASVAcceptEvent )
    {
        RemovePASVAcceptEvent( TRUE );
    }

    CleanupPASVFlags();

    // set up the async io contexts
    m_AioControlConnection.SetNewSocket( sControl, pAtqContext, EndpointObject );
    m_AioDataConnection.SetNewSocket(INVALID_SOCKET);
    m_sPassiveDataListen = ( INVALID_SOCKET);

    m_rgchFile[0] = '\0';
    m_szUserName[0]  = '\0';             // no user name available yet.
    m_szCurrentDirectory[0] = '\0';      // initialize to no virtual dir.

    m_licbSent.QuadPart = 0;

    m_pInstance->QueryStatsObj()->IncrCurrentConnections();

    m_dwCurrentOffset = 0;
    m_dwNextOffset = 0;

    //
    //  get the local Ip address
    //

    if ( psockAddrLocal != NULL) {

        LocalIpAddress = psockAddrLocal->sin_addr;
        LocalIpPort = psockAddrLocal->sin_port;
    } else {

        SOCKADDR_IN  saddrLocal;
        INT   cbLocal;

        cbLocal = sizeof( saddrLocal);
        if ( getsockname( sControl, (SOCKADDR *) &saddrLocal, &cbLocal) != 0) {

            DWORD err = WSAGetLastError();

            fReturn = FALSE;

            IF_DEBUG( ERROR) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Failure in getsockname( sock=%d). Error = %u\n",
                            sControl, err));
            }

            SetLastError( err);

        } else  {

            LocalIpAddress = saddrLocal.sin_addr;
            LocalIpPort = saddrLocal.sin_port;
        }
    }

    DataPort = CONN_PORT_TO_DATA_PORT(LocalIpPort);

    //
    //  Success!
    //

    IF_DEBUG( CLIENT) {

        time_t now;
        time( & now);
        CHAR pchAddr[32];

        InetNtoa( clientIpAddress, pchAddr);

        DBGPRINTF( ( DBG_CONTEXT,
                    " Client Connection for %s:%d starting @ %s",
                    pchAddr, sControl,
                    asctime( localtime( &now))));
    }

    IF_DEBUG( USER_DATABASE ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "user %lu reset @ %08lX.\n",
                   QueryId(), this));
    }

    m_nControlRead = 0;

    FakeIOTimes = 0;

    return (fReturn);

} // USER_DATA::Reset()




VOID
USER_DATA::Cleanup( VOID)
/*++
  This cleans up data stored in the user data object.

 Returns:
    None

--*/
{
    DBG_ASSERT( QueryReference() == 0);

    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG( USER_DATABASE ) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Cleaning up user %lu  @ %08lX.\n",
                   QueryId(), this));
    }

    DBG_ASSERT( m_nControlRead == 0);

    //
    // Clean up stuff needed to deal with PASV connections
    //
    if ( m_hPASVAcceptEvent )
    {
        RemovePASVAcceptEvent( TRUE );
    }


    if ( m_pszCmd )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    //
    //  Close any open sockets & handles.
    //

    CloseSockets( FALSE );

    // invalidate the connections
    m_AioControlConnection.SetNewSocket(INVALID_SOCKET);
    m_AioDataConnection.SetNewSocket(INVALID_SOCKET);


    //
    //  Update the statistics.
    //

    if( IsLoggedOn()
        && !TEST_UF( this, WAIT_PASS ) )
    {
        if( TEST_UF( this, ANONYMOUS))
        {
            m_pInstance->QueryStatsObj()->DecrCurrentAnonymousUsers();
        }
        else
        {
            m_pInstance->QueryStatsObj()->DecrCurrentNonAnonymousUsers();
        }
    }

    m_pInstance->QueryStatsObj()->DecrCurrentConnections();

    if( UserToken != NULL )
    {
        TsDeleteUserToken( UserToken );
        UserToken = NULL;
    }

    if( CurrentDirHandle != INVALID_HANDLE_VALUE )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "closing directory handle %08lX\n",
                        CurrentDirHandle ));
        }

        CloseHandle( CurrentDirHandle );
        CurrentDirHandle = INVALID_HANDLE_VALUE;
    }

    if ( m_pOpenFileInfo != NULL) {

        DBG_REQUIRE( CloseFileForSend());
    }

    //
    //  Release the memory attached to this structure.
    //


    if( RenameSourceBuffer != NULL ) {

        // do not free this location until end of usage.
        RenameSourceBuffer[0] = '\0';
    }

    m_UserId        = 0;  // invalid User Id

    //
    //  Kill the structure signature.
    //

    KILL_USER_SIG( this );

    IF_DEBUG( CLIENT) {

        time_t now;
        time( & now);

        DBGPRINTF( ( DBG_CONTEXT,
                    " Client Connection for %s:%d ending @ %s",
                    inet_ntoa( HostIpAddress), QueryControlSocket(),
                    asctime( localtime( &now))));
    }


    //
    // There is a possible race condition. If the socket was abruptly closed
    //   and there was any pending Io, they will get blown away. This will
    //   cause a call-back from the ATQ layer. That is unavoidable.
    //  In such cases it is possible that the object was deleted.
    //   This can lead to problems. We need to be careful.
    //  But Reference Count protects against such disasters. So tread
    //   carefully and use Reference count.
    //

    DBG_ASSERT( m_sPassiveDataListen == INVALID_SOCKET);

    m_fCleanedup = TRUE; // since we  just cleaned up this object

    return;

} // USER_DATA::Cleanup()






VOID
USER_DATA::ReInitializeForNewUser( VOID)
/*++

  This function reinitializes the user data information for a new user to
  communicate with the server using existing control socket connection.

--*/
{

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    //
    //  Update the statistics.
    //

    if( IsLoggedOn())
    {
        if( TEST_UF( this, ANONYMOUS))
        {
            m_pInstance->QueryStatsObj()->DecrCurrentAnonymousUsers();
        }
        else
        {
            m_pInstance->QueryStatsObj()->DecrCurrentNonAnonymousUsers();
        }
    }

    CLEAR_UF_BITS( this, (UF_LOGGED_ON | UF_ANONYMOUS | UF_PASSIVE));

    LockUser();
    if( QueryState() != UserStateDisconnected ) {
        SetState( UserStateWaitingForUser );
    }
    UnlockUser();

    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }
    m_TimeAtConnection= GetCurrentTimeInSeconds();
    m_TimeAtLastAccess= m_TimeAtConnection;
    m_xferType        = XferTypeAscii;
    m_xferMode        = XferModeStream;
    DataIpAddress     = HostIpAddress;
    DataPort          = CONN_PORT_TO_DATA_PORT(LocalIpPort);

    m_szUserName[0] = '\0';
    m_szCurrentDirectory[0] = '\0';

    if( UserToken != NULL )
    {
        TsDeleteUserToken( UserToken );
        UserToken = NULL;
    }

    if( CurrentDirHandle != INVALID_HANDLE_VALUE )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "closing directory handle %08lX\n",
                        CurrentDirHandle ));
        }

        CloseHandle( CurrentDirHandle );
        CurrentDirHandle = INVALID_HANDLE_VALUE;
    }

    if ( m_pOpenFileInfo != NULL) {

        DBG_REQUIRE( CloseFileForSend());
    }

    m_licbSent.QuadPart = 0;

    m_pvInitialRequest  = NULL;
    m_cbInitialRequest  = 0;

    CleanupPassiveSocket( TRUE );

    return;

} // USER_DATA::ReInitializeForNewUser()






BOOL
USER_DATA::ProcessAsyncIoCompletion(
    IN DWORD cbIo,
    IN DWORD dwError,
    IN LPASYNC_IO_CONNECTION  pAioConn,
    IN BOOL  fTimedOut)
/*++
  This function processes the Async Io completion.
  ( invoked due to a callback from the ASYNC_IO_CONNECTION object)

  Arguments:
     pContext      pointer to the context information ( UserData object).
     cbIo          count of bytes transferred in Io
     dwError       DWORD containing the error code resulting from last tfr.
     pAioConn      pointer to AsyncIo connection object.
     fTimedOut     flag indicating if the current call was made
                     because of timeout.

  Returns:
     None
--*/
{
    BOOL        fReturn = FALSE;
    AC_RESULT   acDnsAccess;
    DWORD       dwOriginalError;

    dwOriginalError = dwError;

    //
    // Special processing if it's an IO completion on the control connection - we might
    // be processing a completion we posted ourselves to signal that the data socket for the PASV
    // data connection is now accept()'able.
    //

    if ( pAioConn == &m_AioControlConnection && QueryInFakeIOCompletion() )
    {
        // Here is a horrible race condition:
        // If the FTP client closes the control socket
        // right after having finished receiving the transmitted file
        // than there may be a thread that enters this
        // code path (because the FakeIO flag is set, and the
        // Control Socket is involved) before the IO completion
        // for the data sonnection has traveled this same function,
        // cleaning the FakeIO flag
        // Here is the race condition:
        // A thread enter here, and see that the FakeIO is set
        // the normal behavior is reprocessing a command like
        // "RETR foo.txt", while now the command if a zero length string.
        // the Second thread enter this function with the DataConnection
        // it clears the flag (at a non specified point of the
        // processing of the other thread) and it exit.
        // the original thread is now processing a saved string
        // (because of the FakeIO flag) while it is not supposed to.
        // this causes problems to the time-out algorithm, because
        // of a ref-count problem in the USER_DATA

        LONG CurVal = InterlockedIncrement(&(this->FakeIOTimes));
        if (CurVal>1){
            goto NormalProcessing;
        }

        //
        // Remove the reference used to deal with the race condition between an IO
        // thread doing clean-up and the thread watching for the data socket to become
        // accept()'able and holding on to this USER_DATA object
        //
        DeReference();

        //
        // There is a race condition between the thread watching for a socket to become
        // accept()'able and an IO thread being woken up because the client has (unexpectedly)
        // disconnected. The thread watching the socket will post a fake IO completion to
        // indicate that an accept() on the socket will succeed; however, if the client
        // disconnects (the control connection) before the fake completion is processed,
        // we don't want to do any more processing.
        //
        if ( UserState == UserStateDisconnected )
        {
            return TRUE;
        }
        else
        {
            //
            // Fast-path if we know this is the second time around we're trying to process the
            // command, which happens when we're in PASV mode
            //
            DBG_ASSERT( UserState == UserStateLoggedOn );
            goto ProcessCommand;
        }
    }

NormalProcessing:

    if( dwError != NO_ERROR &&
        dwError != ERROR_SEM_TIMEOUT )
    {

        //
        // Geezsh, I hate my life.
        //
        // Once upon a time, there was a bug in ATQ that cause it to
        // always pass NO_ERROR as the status to the async completion
        // routine. This bug caused, among other things, FTP to never
        // time out idle connections, because it never saw the
        // ERROR_SEM_TIMEOUT status. So, I fixed the bug in ATQ.
        //
        // Now, this completion routine gets the actual status. Well,
        // that breaks service shutdown when there are connected users.
        // Basically, when a shutdown occurs, the connected sockets are
        // closed, causing the IO to complete with ERROR_NETNAME_DELETED.
        // USER_DATA::ProcessAsyncIoCompletion() is not handling this
        // error properly, which causes 1) an assertion failure because
        // USER_DATA::DisconnectUserWithError() is getting called *twice*
        // and 2) the service never stops because of a dangling reference
        // on the USER_DATA structure.
        //
        // Of course, the proper thing to do would be to fix the offending
        // code in USER_DATA::ProcessAsyncIoCompletion() so that it DID
        // handle the error properly. Unfortunately, that fix requires a
        // nontrivial amount of surgery, and we're a scant three days
        // from releasing K2 Beta 1. So...
        //
        // As a quick & dirty work around for K2 Beta 1, we'll map all
        // errors other than ERROR_SEM_TIMEOUT to NO_ERROR. This should
        // provide the lower software layers with the old ATQ behavior
        // they're expecting.
        //
        // REMOVE THIS POST BETA 1 AND FIX USER_DATA PROPERLY!!!!
        //
        // 3/12/98
        //
        // N.B. The debug output below has been changed to be a little
        // more customer friendly but I hate to prevent future developers
        // for enjoying the original message which read:
        // "Mapping error %d to NO_ERROR to mask FTP bug (FIX!)\n"
        //
        // I'm removing this message because it was the source of some
        // embarrasment, when a checked version of this DLL was sent to
        // Ernst & Young to track the now famous bug #138566.
        //

        DBGPRINTF((
            DBG_CONTEXT,
            "Mapping error %d to NO_ERROR\n",
            dwError
            ));

        dwError = NO_ERROR;

    }

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG


    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[%lu] Entering USER_DATA( %08x)::Process( %u, %u, %08x)."
                    " RefCount = %d. State = %d\n",
                    GetTickCount(),
                    this, cbIo, dwError, pAioConn, QueryReference(),
                    QueryState()));
    }

    if ( m_fNeedDnsCheck )
    {
        acDnsAccess = QueryAccessCheck()->CheckDnsAccess();

        UnbindInstanceAccessCheck();

        m_fNeedDnsCheck = FALSE;

        if ( (acDnsAccess == AC_IN_DENY_LIST) ||
             (acDnsAccess == AC_NOT_IN_GRANT_LIST) ||
             ((m_acCheck == AC_NOT_IN_GRANT_LIST) &&
              (acDnsAccess != AC_IN_GRANT_LIST) ) ) {

            ReplyToUser(this,
                        REPLY_NOT_LOGGED_IN,
                        "Connection refused, unknown IP address." );

            DisconnectUserWithError( NO_ERROR );

            return TRUE;
        }
    }

    if ( pAioConn == &m_AioDataConnection)
    {

        //
        // a Data transfer operation has completed.
        //

        DBG_REQUIRE( IsLoggedOn());

        // Update last access time
        m_TimeAtLastAccess = GetCurrentTimeInSeconds();

        if ( dwError == NO_ERROR || !fTimedOut)
        {

            // dwError == NO_ERROR  ==> No error in transmitting data
            //   so decrease ref count and blow away the sockets.

            // if dwError != NO_ERROR then
            //    if timeout occured ==> ATQ will send another callback
            //                      so do not decrease ref count now.
            //    if no timeout ==> then decrement ref count now.

            DBG_REQUIRE( DeReference() > 0);
        }
        else
        {

            if ( fTimedOut)
            {
                SET_UF( this, DATA_TIMEDOUT);
            }
            else
            {
                SET_UF( this, DATA_ERROR);
            }

        }

# ifdef CHECK_DBG
        if ( dwError != NO_ERROR)
        {

            CHAR szBuffer[100];
            sprintf( szBuffer, " Data Socket Error = %u ", dwError);
            Print( szBuffer);
        }
# endif // CHECK_DBG

        CLEAR_UF( this, ASYNC_TRANSFER);

        //
        // Destroy the data connection.
        //  Send message accordingly to indicate if this was a failure/success
        //  That is done by DestroyDataConnection.
        //
        DBG_REQUIRE( DestroyDataConnection( dwOriginalError));


        if ( m_pOpenFileInfo != NULL)
        {
            //
            // set number of bytes actually sent
            //
            m_licbSent.QuadPart += cbIo;

            DBG_REQUIRE( CloseFileForSend( dwOriginalError));
        }

        if ( dwError == NO_ERROR)
        {

            //
            // Process any Pending commands, due to the parallel
            //    control channel operation for this user Connection.
            // For the present, we dont buffer commands ==> No processing
            //   to be done effectively.   NYI
            // Just ensure that there is a read-operation pending on
            //  control channel.
            //

            // BOGUS: DBG_ASSERT( TEST_UF( this, CONTROL_READ));
        }

        fReturn = TRUE;   // since this function went on well.
    }
    else if ( pAioConn == &m_AioControlConnection)
    {

        //
        // a control socket operation has completed.
        //

        if ( dwError != NO_ERROR)
        {

            //
            // There is an error in processing the control connection request.
            // the only ASYNC_IO request we submit on control is:
            //         Read request on control socket
            //

            if ( fTimedOut)
            {

                if ( TEST_UF( this, TRANSFER))
                {

                    // A data transfer is going on.
                    // allow client to send commands later
                    // (client may not be async in control/data io,so allow it)

                    // resubmit the control read operation
                    //  after clearing old one

                    //
                    // Since there is a pending IO in atq.
                    //  Just resume the timeout processing in ATQ for
                    //  this context.
                    //

                    pAioConn->ResumeIoOperation();
                    fReturn = TRUE;
                }
                else
                {

                    // For timeouts, ATQ sends two call backs.
                    //  So be careful to decrement reference count only once.

                    DBG_ASSERT( fReturn == FALSE);

                    DBG_ASSERT( TEST_UF( this, CONTROL_READ));
                    SET_UF( this, CONTROL_TIMEDOUT);
                }

            }
            else
            {

                // Either there should be a control read pending or
                // control socket should have received a timeout.
                DBG_ASSERT( TEST_UF( this, CONTROL_READ) ||
                            TEST_UF( this, CONTROL_TIMEDOUT)
                           );

                // a non-timeout error has occured. ==> stop read operation.
                StopControlRead(this);
                DBG_ASSERT( fReturn == FALSE);
                SET_UF( this, CONTROL_ERROR);
            }

        }
        else
        {

            // If this connection had an outstanding IO on wait queue, it
            //   got completed. Hence get rid of the reference count.
            StopControlRead( this);

            switch ( UserState)
            {

              case UserStateEmbryonic:

                fReturn = StartupSession( m_pvInitialRequest,
                                          m_cbInitialRequest);

                if ( m_pvInitialRequest == NULL)
                {
                    // No initial buffer. Wait for read to complete
                    break;
                }

                cbIo = m_cbInitialRequest;  // fake the bytes read.

                // Fall Through for processing request

              case UserStateWaitingForUser:
              case UserStateWaitingForPass:
              case UserStateLoggedOn:

            ProcessCommand:
                //
                // Input already read. Process request and submit another read.
                //

                fReturn = ParseAndProcessRequest(cbIo/sizeof(CHAR));

                if ( fReturn && IsDisconnected() &&
                     TEST_UF( this, CONTROL_TIMEDOUT))
                {

                    // disconnect only if no pending control read
                    // if there is a pending control read,
                    //  atq will pop this up for cleanup.
                    fReturn = !(TEST_UF( this, CONTROL_READ));

                    IF_DEBUG( ERROR) {
                        DBGPRINTF(( DBG_CONTEXT,
                                   "%08x ::Timeout killed conn while "
                                   " processing!\n State = %d(%x),"
                                   " Ref = %d, Id = %d, fRet=%d\n",
                                   this, QueryState(), Flags,
                                   QueryReference(), QueryId(), fReturn
                               ));
                    }
                    FacIncrement( CacTimeoutWhenProcessing);
                }
                break;

              case UserStateDisconnected:

                fReturn = TRUE;
                if ( TEST_UF( this, CONTROL_TIMEDOUT))
                {

                    // Timeout thread raced against me :(

                    IF_DEBUG( ERROR) {
                        DBGPRINTF(( DBG_CONTEXT,
                                   "%08x :: Conn already Disconnected !!!\n"
                                   " State = %d(%x), Ref = %d, Id = %d\n",
                                   this, QueryState(), Flags,
                                   QueryReference(), QueryId()
                                   ));
                    }
                    FacIncrement( CacTimeoutInDisconnect);
                    fReturn = FALSE;
                }
                break;

              default:

                DBG_ASSERT( !"Invalid UserState for processing\n");
                SetLastError( ERROR_INVALID_PARAMETER);
                break;
            } // switch

            dwError = ( fReturn) ? NO_ERROR : GetLastError();
        }

        if ( !fReturn)
        {
            DisconnectUserWithError( dwError, fTimedOut);
        }
    }
    else
    {

        DBG_ASSERT( !"call to Process() with wrong parameters");
    }

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[%lu] Leaving USER_DATA( %08x)::Process()."
                    " RefCount = %d. State = %d\n",
                    GetTickCount(),
                    this, QueryReference(), QueryState())
                  );
    }

    return ( fReturn);
} // USER_DATA::ProcessAsyncIoCompletion()






# define  min(a, b)    (((a) < (b)) ? (a) : (b))

BOOL
USER_DATA::StartupSession(IN PVOID  pvInitialRequest,
                          IN DWORD  cbInitialRequest
                          )
/*++
  This function allocates a buffer for receiving request from the client
   and also sets up initial read from the control socket to
   get client requests.

  Arguments:
    pvInitialRequest   pointer to initial request buffer
    cbInitialRequest   count of bytes of data in the initial request

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    SOCKERR serr;
    BOOL fReturn = FALSE;
    PCSTR pszBanner;

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG


    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    DBG_ASSERT( QueryState() == UserStateEmbryonic);

    //
    //  Reply to the initial connection message. ( Greet the new user).
    //

    pszBanner = QueryInstance()->QueryBannerMsg();

    if( pszBanner && *pszBanner ) {
        serr = SendMultilineMessage(
                                   REPLY_SERVICE_READY,
                                   g_FtpServiceNameString,
                                   TRUE,
                                   FALSE);

        serr = serr || SendMultilineMessage(
                                   REPLY_SERVICE_READY,
                                   pszBanner,
                                   FALSE,
                                   TRUE);
    } else {
        serr = ReplyToUser( this,
                           REPLY_SERVICE_READY,
                           "%s",
                           g_FtpServiceNameString );
    }

    if ( serr != 0) {

        IF_DEBUG( ERROR) {
            DBGPRINTF( ( DBG_CONTEXT,
                        " Cannot reply with initial connection message."
                        " Error = %lu\n",
                        serr));
        }

    } else {

        //
        //  enable OOB_INLINE since we are using that for our control socket
        //
        BOOL  fOobInline = TRUE;

        serr = setsockopt( QueryControlSocket(), SOL_SOCKET,
                           SO_OOBINLINE, (const char *) &fOobInline,
                          sizeof( fOobInline));

        m_cchPartialReqRecvd = 0;

        if ( serr == 0) {

            //
            // Try to set up the buffer and enter the mode for reading
            //  requests from the client
            //

            LockUser();
            if( QueryState() != UserStateDisconnected ) {
                SetState( UserStateWaitingForUser);
            }
            UnlockUser();

            if ( pvInitialRequest != NULL && cbInitialRequest > 0) {

                //
                // No need to issue a read, since we have the data required.
                // Do a safe copy to the buffer.
                //

                CopyMemory( QueryReceiveBuffer(), pvInitialRequest,
                       min( cbInitialRequest, QueryReceiveBufferSize())
                       );

                fReturn = TRUE;

            } else {

                fReturn = ReadCommand();
            }

        } else {

            IF_DEBUG( ERROR) {
                DBGPRINTF((DBG_CONTEXT,
                           " SetsockOpt( OOB_INLINE) failed. Error = %lu\n",
                           WSAGetLastError()));
            }

        }
    }

    IF_DEBUG( CLIENT) {

        DWORD  dwError = (fReturn) ? NO_ERROR : GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                    " connection ( %08x)::StartupSession() returns %d."
                    " Error = %lu\n",
                    this, fReturn,
                    dwError));

        if (fReturn)    {   SetLastError( dwError); }
    }

    return ( fReturn);

} // USER_DATA::StartupSession()



VOID
CheckAndProcessAbortOperation( IN LPUSER_DATA pUserData)
{
    if ( TEST_UF( pUserData, OOB_ABORT)) {

        //
        // An abort was requested by client. So our processing
        // has unwound and we are supposed to send some message
        //  to the client. ==> simulate processing ABOR command
        // ABORT was not processed yet; so process now.
        //

        DBGPRINTF((DBG_CONTEXT,
                   "Executing simulated Abort for %08x\n",
                   pUserData));

        FacIncrement( FacSimulatedAborts);

        // To avoid thread races, check twice.

        if ( TEST_UF( pUserData, OOB_ABORT)) {

          //
          // we need this stack variable (szAbort), so that
          //  ParseCommand() can freely modify the string!
          CHAR szAbort[10];

          CLEAR_UF( pUserData, OOB_ABORT);

          CopyMemory( szAbort, "ABOR", sizeof("ABOR"));
          ParseCommand( pUserData, szAbort);
        }
    }

    return;

} // CheckAndProcessAbortOperation()



BOOL
USER_DATA::ParseAndProcessRequest(IN DWORD cchRequest)
/*++
  This function parses the incoming request from client, identifies the
   command to execute and executes the same.
  Before parsing, the input is pre-processed to remove any of telnet commands
   or OOB_inlined data.

  Arguments:
    cchRequest         count of characters of request received.

--*/
{
    BOOL fLineEnded = FALSE;
    DWORD cchRequestRecvd = 0;
    CHAR szCommandLine[ MAX_COMMAND_LENGTH + 1];

# if DBG

    if ( !IS_VALID_USER_DATA( this))
    {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG


    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG( CLIENT)
    {

        DBGPRINTF( ( DBG_CONTEXT,
                    "UserData(%08x)::ParseAndProcessRequest( %d chars)\n",
                    this, cchRequest));
    }


    //
    // Fast-path if we're re-processing this command, which happens in PASV mode
    //
    if ( QueryInFakeIOCompletion() )
    {
        goto FastPathLabel;
    }


    if ( cchRequest > 0)
    {
        // We have a valid request. Process it

        // Update last access time
        m_TimeAtLastAccess = GetCurrentTimeInSeconds();

        m_pInstance->QueryStatsObj()->UpdateTotalBytesReceived(
                                                cchRequest*sizeof(CHAR));

        if ( m_cchPartialReqRecvd + cchRequest >=  MAX_COMMAND_LENGTH)
        {

            CHAR  szCmdFailed[600];
            wsprintfA( szCmdFailed,
                      " Command is too long:  Partial=%d bytes. Now=%d \n"
                      "  UserDb(%08x) = %s from Host: %s\n",
                      m_cchPartialReqRecvd, cchRequest,
                      this, QueryUserName(), QueryClientHostName());

            DBGPRINTF((DBG_CONTEXT, szCmdFailed));

            DisconnectUserWithError( ERROR_BUSY);

            return ( TRUE);  // we are done with this connection.
        }

        CopyMemory(szCommandLine, m_recvBuffer,
               m_cchPartialReqRecvd + cchRequest);
        szCommandLine[m_cchPartialReqRecvd + cchRequest] = '\0';

        if ( !::FilterTelnetCommands(szCommandLine,
                                     m_cchPartialReqRecvd + cchRequest,
                                     &fLineEnded,    &cchRequestRecvd))
        {

            if ( TEST_UF( this, TRANSFER))
            {

                //
                // I am in data transfer mode. Some other thread is sending
                //  data for this client. Just post a OOB_DATA and OOB_ABORT
                // OOB_DATA will cause the call-stack of other thread to unwind
                //   and get out of the command.
                // Then check if any async transfer was occuring. If so
                //  process abort with disconnect now.
                //

                SET_UF_BITS( this, (UF_OOB_DATA | UF_OOB_ABORT));

                if ( TEST_UF( this, ASYNC_TRANSFER))
                {

                    //
                    // An async transfer is occuring. Stop it
                    //
                    DestroyDataConnection( ERROR_OPERATION_ABORTED);

                    CheckAndProcessAbortOperation( this);
                }

# ifdef CHECK_DBG

                Print( " OOB_ABORT ");

# endif // CHECK_DBG

                IF_DEBUG( CLIENT) {

                    DBGPRINTF((DBG_CONTEXT,
                               "[%08x]Set up the implied ABORT command\n",
                               this));
                }

                IF_DEBUG( COMMANDS) {

                    DBGPRINTF((DBG_CONTEXT, " ***** [%08x] OOB_ABORT Set \n",
                               this));
                }

                // Ignore the rest of the commands that may have come in.
            }
            else
            {

                //
                // Since no command is getting processed.
                //   atleast process the abort command, otherwise clients hang.
                //

                //
                // we need this stack variable (szAbort), so that
                //  ParseCommand() can freely modify the string!
                CHAR szAbort[10];

                CopyMemory( szAbort, "ABOR", sizeof("ABOR"));
                ParseCommand( this, szAbort);
                CLEAR_UF( this, OOB_ABORT);  // clear the abort flag!
            }

        }
        else
        {

            if ( TEST_UF( this, TRANSFER))
            {

                //
                // we are transferring data, sorry no more commands accepted.
                // This could hang clients. Hey! they asked for it :( NYI
                //

                // Do nothing
                IF_DEBUG( COMMANDS) {

                    DBGPRINTF((DBG_CONTEXT,
                               "***** [%08x] Received Request %s during"
                               " transfer in progress\n",
                               this, szCommandLine));
                }

            }
            else
            {
                //
                //  Let ParseCommand do the dirty work.
                //


                // Remember the count of partial bytes received.
                m_cchPartialReqRecvd = cchRequestRecvd;

                if ( !fLineEnded)
                {

                    // In case if command was long enough to fill all buffer but
                    // we haven't found new line  simply tell to user about the error
                    // and disconnect. Some ftp clients will not see that msg, becuase
                    // connection was disconnected, but thats a bug in client code

                    if ( m_cchPartialReqRecvd >=  MAX_COMMAND_LENGTH - 1)
                    {
                        ReplyToUser( this,
                                     REPLY_UNRECOGNIZED_COMMAND,
                                     PSZ_COMMAND_TOO_LONG);
                        DisconnectUserWithError( ERROR_BUSY );

                        return ( TRUE);  // we are done with this connection.
                    }


                    //
                    // Complete line is not received. Continue reading
                    //   the requests, till we receive the complete request
                    //

                }
                else
                {

                    StartProcessingTimer();

                    //
                    // set the partial received byte count to zero.
                    //  we will not use this value till next incomplete request
                    //

                    m_cchPartialReqRecvd = 0;

FastPathLabel:
                    ParseCommand( this, ( QueryInFakeIOCompletion() ? QueryCmdString() :
                                                                      szCommandLine ) );

                    CheckAndProcessAbortOperation( this);

                } // if TRANSFER is not there...

            } //Parse if complete

        } // if FilterTelnetCommands()
    }
    else
    {
        // if (cchRequest <= 0)

        SET_UF( this, CONTROL_ZERO);

        //
        // after a quit a client is expected to wait for quit message from
        //  the server. if the client prematurely closes connection, then
        //  the server receives it as a receive with zero byte read.
        //  since, we should not be having outstanding read at this time,
        //   atq should not be calling us. On the contrary we are getting
        //  called by ATQ. Let us track this down.
        //

        if ( !TEST_UF( this, CONTROL_QUIT))
        {
            DisconnectUserWithError( NO_ERROR);
        }
        else
        {

            // Quit message is received and then ZeroBytes Received!!
            DBGPRINTF((DBG_CONTEXT,
                       " (%08x)::ZeroBytes recvd after QUIT message!!."
                       " State = %d(%x), Ref = %d\n",
                       this,
                       QueryState(), Flags,
                       QueryReference()
                       ));
            // Do nothing. Since Quit will take care of cleanup
            return (TRUE);
        }
    }

    //
    // If the connection is not yet disconnected, submit a read command.
    //  else return that everything is fine (someone had disconnected it).
    //

    return ( IsDisconnected() ? TRUE : ReadCommand());
} // USER_DATA::ParseAndProcessRequest()





BOOL
USER_DATA::ReadCommand( VOID)
{
    BOOL fReturn = TRUE;

    DBG_CODE(
             if ( !IS_VALID_USER_DATA( this)) {

                 DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                             this));
                 Print();
             }
             );

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );
    if ( TEST_UF( this, CONTROL_TIMEDOUT) || IsDisconnected()) {

        SetLastError( ERROR_SEM_TIMEOUT);
        return (FALSE);
    }

    //
    // Submit a read on control socket only if there is none pending!
    // Otherwise, behave in idempotent manner.
    //

    if ( !TEST_UF( this, CONTROL_READ)) {

        Reference();         // since we are going to set up async read.

        InterlockedIncrement( &m_nControlRead);

        DBG_ASSERT( m_nControlRead <= 1);

        SET_UF( this, CONTROL_READ);  // a read will be pending

        if ( !m_AioControlConnection.ReadFile(QueryReceiveBuffer(),
                                              QueryReceiveBufferSize())
            ) {

            CLEAR_UF( this, CONTROL_READ);  // since read failed.

            DBG_REQUIRE( DeReference() > 0);
            InterlockedDecrement( &m_nControlRead);

            DWORD dwError = GetLastError();

            IF_DEBUG( ERROR) {
                DBGPRINTF( ( DBG_CONTEXT,
                            " User( %08x)::ReadCommand() failed. Ref = %d."
                            " Error = %d\n",
                            this, QueryReference(), dwError));
            }

            SetLastError( dwError);
            fReturn = FALSE;
        }

    }

    return ( fReturn);
} // USER_DATA::ReadCommand()




BOOL
USER_DATA::DisconnectUserWithError(IN DWORD dwError,
                                   IN BOOL fNextMsg OPTIONAL)
/*++
  This function disconnects a user with the error code provided.
  It closes down the control connection by stopping ASYNC_IO.
  If the fNextMsg is not set, then it also decrements the reference count
    for the user data object, to be freed soon.

--*/
{
    CHAR   szBuffer[120];

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG ( CLIENT) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " USER_DATA( %08x)::DisconnectUserWithError( %lu, %d)."
                    " RefCount = %d\n",
                    this, dwError, fNextMsg, QueryReference()));
    }


    if (!fNextMsg) {
        RemoveActiveReference();
    }

    LockUser();

    if ( QueryState() == UserStateDisconnected) {

        //
        // It is already in disconnected state. Do nothing for disconnect.
        //

        UnlockUser();

    } else {

        SetState( UserStateDisconnected );
        UnlockUser();

        if( dwError == ERROR_SEM_TIMEOUT) {

            const CHAR * apszSubStrings[3];

            IF_DEBUG( CLIENT )
              {
                  DBGPRINTF(( DBG_CONTEXT,
                             "client (%08x) timed-out\n", this ));
              }

            sprintf( szBuffer, "%lu", m_pInstance->QueryConnectionTimeout() );

            apszSubStrings[0] = QueryUserName();
            apszSubStrings[1] = inet_ntoa( HostIpAddress );
            apszSubStrings[2] = szBuffer;

            g_pInetSvc->LogEvent( FTPD_EVENT_CLIENT_TIMEOUT,
                                  3,
                                  apszSubStrings,
                                  0 );

            ReplyToUser(this,
                        REPLY_SERVICE_NOT_AVAILABLE,
                        "Timeout (%lu seconds): closing control connection.",
                        m_pInstance->QueryConnectionTimeout() );
        }

        if ( dwError != NO_ERROR) {

# ifdef CHECK_DBG
            sprintf( szBuffer, " Control Socket Error=%u ", dwError);
            Print( szBuffer);
# endif // CHECK_DBG

            if( dwError != ERROR_SEM_TIMEOUT ) {
                SetLastReplyCode( REPLY_TRANSFER_ABORTED );
            }

            // Produce a log record indicating the cause for failure.
            WriteLogRecord( PSZ_CONNECTION_CLOSED_VERB, "", dwError);
        }

        //
        //  Force close the connection's sockets.  This will cause the
        //  thread to awaken from any blocked socket operation.  It
        //  is the destructor's responsibility to do any further cleanup.
        //  (such as calling UserDereference()).
        //

        CloseSockets(dwError != NO_ERROR);
    }

    return ( TRUE);

} // USER_DATA::DisconnectUserWithError()






static BOOL
DisconnectUserWorker( IN LPUSER_DATA  pUserData, IN LPVOID pContext)
/*++
  This disconnects (logically) a user connection, by resetting the
   control connection and stopping IO. Later on the blown away socket
   will cause an ATQ relinquish to occur to blow away of this connection.

  Arguments:
    pUserData   pointer to User data object for connection to be disconnected.
    pContext    pointer to context information
    ( in this case to DWORD containing error code indicating reasong for
         disconnect).

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DWORD  dwError;
    BOOL   retVal;
    DBG_ASSERT( pContext != NULL && pUserData != NULL);
    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );


    dwError = *(LPDWORD ) pContext;


    retVal = pUserData->DisconnectUserWithError( dwError, TRUE);

    // fix for bug 268175 : if we disconnected user we need to do normal cleanup
    // for that connection

    // this check is not very necessary but I leave it for future
    // DisconnectUserWithError always returns TRUE

    if (retVal)
    {
        DereferenceUserDataAndKill(pUserData);
    }


    return retVal;
} // DisconnectUserWorker()




BOOL
DisconnectUser( IN DWORD UserId, FTP_SERVER_INSTANCE *pInstance )
/*++
  This function disconnects a specified user identified using the UserId.
  If UserId specified == 0, then all the users will be disconnected.

  Arguments:
     UserId   user id for the connection to be disconnected.

  Returns:
     TRUE if atleast one of the connections is disconnected.
     FALSE if no user connetion found.

  History:
     06-April-1995 Created.
--*/
{
    BOOL   fFound;
    DWORD  dwError = ERROR_SERVER_DISABLED;

    pInstance->Reference();
    pInstance->LockConnectionsList();

    fFound = ( pInstance->
               EnumerateConnection( DisconnectUserWorker,
                                   (LPVOID ) &dwError,
                                   UserId));

    pInstance->UnlockConnectionsList();
    pInstance->Dereference();

    IF_DEBUG( CLIENT) {

        DWORD dwError = (fFound) ? NO_ERROR: GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                     " DisconnectUser( %d) returns %d. Error = %lu\n",
                    UserId, fFound, dwError));

        if (fFound)   { SetLastError( dwError); }
    }

    return ( fFound);
}   // DisconnectUser()





static BOOL
DisconnectUserWithNoAccessWorker( IN LPUSER_DATA  pUserData,
                                  IN LPVOID pContext)
/*++
  This disconnects (logically) a user connection with no access.
  This occurs by resetting the control connection and stopping IO.
  Later on the blown away thread
   will cause an ATQ relinquish to occur to blow away of this connection.

  Arguments:
    pUserData   pointer to User data object for connection to be disconnected.
    pContext    pointer to context information
    ( in this case to DWORD containing error code indicating reasong for
         disconnect).

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL fSuccess = TRUE;
    DBG_ASSERT( pUserData != NULL);

    // Ignode the pContext information.

    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );

    //
    //  We're only interested in connected users.
    //

    if( pUserData->IsLoggedOn()) {

        //
        //  If this user no longer has access to their
        //  current directory, blow them away.
        //

        if( !pUserData->VirtualPathAccessCheck(AccessTypeRead )) {

            const CHAR * apszSubStrings[2];

            IF_DEBUG( SECURITY ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "User %s (%lu) @ %08lX retroactively"
                           " denied access to %s\n",
                           pUserData->QueryUserName(),
                           pUserData->QueryId(),
                           pUserData,
                           pUserData->QueryCurrentDirectory() ));
            }


            fSuccess = ( pUserData->
                           DisconnectUserWithError(ERROR_ACCESS_DENIED,
                                                   TRUE)
                        );

            //
            //  Log an event to tell the admin what happened.
            //

            apszSubStrings[0] = pUserData->QueryUserName();
            apszSubStrings[1] = pUserData->QueryCurrentDirectory();

            g_pInetSvc->LogEvent( FTPD_EVENT_RETRO_ACCESS_DENIED,
                                  2,
                                  apszSubStrings,
                                  0 );
        } // no access

    } // logged on user

    IF_DEBUG( CLIENT) {

        DWORD dwError = (fSuccess) ? NO_ERROR: GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                    " DisconnectUsersWithNoAccessWorker( %d) returns %d."
                    " Error = %lu\n",
                    pUserData->QueryId(), fSuccess,
                    dwError)
                  );

        if (fSuccess)   { SetLastError( dwError); }
    }

    return ( fSuccess);
} // DisconnectUserWithNoAccessWorker()



VOID
DisconnectUsersWithNoAccess(FTP_SERVER_INSTANCE *pInstance )
/*++
  This function disconnects all users who do not have read access to
  their current directory. This is typically called when the access masks
  have been changed.

  Arguments:
    None

  Returns:
    None.
--*/
{
    BOOL   fFound;
    DWORD  dwError = ERROR_ACCESS_DENIED;

    pInstance->Reference();
    pInstance->LockConnectionsList();

    fFound = ( pInstance->
               EnumerateConnection( DisconnectUserWithNoAccessWorker,
                                   (LPVOID ) &dwError,
                                   0));

    pInstance->UnlockConnectionsList();
    pInstance->Dereference();

    IF_DEBUG( CLIENT) {

        DWORD dwError = (fFound) ? NO_ERROR: GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                    " DisconnectUsersWithNoAccess() returns %d."
                    " Error = %lu\n",
                    fFound, dwError)
                  );

        if (fFound)   { SetLastError( dwError); }
    }


}   // DisconnectUsersWithNoAccess




/*++
  The following structure UserEnumBuffer is required to carry the context
  information for enumerating the users currently connected.
  It contains a pointer to array of USER_INFO structures which contain the
   specific information for the user. The user name is stored in the buffer
   from the end ( so that null terminated strings are formed back to back.
   This permits efficient storage of variable length strings.

   The member fResult is used to carry forward the partial result of
    success/failure from one user to another ( since the enumeration has
    to walk through all the elements to find out all user information).


  History: MuraliK ( 12-April-1995)

--*/
struct  USER_ENUM_BUFFER {

    DWORD   cbSize;                   // pointer to dword containing size of
    IIS_USER_INFO_1 * pUserInfo;      // pointer to start of array of USER_INFO
    DWORD   cbRequired;               // incremental count of bytes required.
    DWORD   nEntry;      // number of current entry ( index into  pUserInfo)
    DWORD   dwCurrentTime;            // current time
    WCHAR * pszNext;                  // pointer to next string location.
    BOOL    fResult;             // boolean flag accumulating partial results
};

typedef USER_ENUM_BUFFER  * PUSER_ENUM_BUFFER;


BOOL
EnumerateUserInBufferWorker( IN LPUSER_DATA pUserData,
                             IN LPVOID pContext)
{
# ifdef CHECK_DBG
    CHAR   szBuffer[400];
# endif // CHECK_DBG

    PUSER_ENUM_BUFFER  pUserEnumBuffer = (PUSER_ENUM_BUFFER ) pContext;
    DWORD     tConnect;
    DWORD     cbUserName;
    LPDWORD   pcbBuffer;

    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );

    //
    //  We're only interested in connected users.
    //

    if( pUserData->IsDisconnected()) {

        return ( TRUE);
    }

    //
    //  Determine required buffer size for current user.
    //

    cbUserName  = ( strlen( pUserData->QueryUserName() ) + 1 ) * sizeof(WCHAR);
    pUserEnumBuffer->cbRequired += sizeof(IIS_USER_INFO_1);

    //
    //  If there's room for the user data, store it.
    //

    tConnect = ( pUserEnumBuffer->dwCurrentTime -
                pUserData->QueryTimeAtConnection());

    if( pUserEnumBuffer->fResult &&
       ( pUserEnumBuffer->cbRequired <= pUserEnumBuffer->cbSize)
       ) {

        LPIIS_USER_INFO_1 pUserInfo =
          &pUserEnumBuffer->pUserInfo[ pUserEnumBuffer->nEntry];

        pUserInfo->idUser     = pUserData->QueryId();
        pUserInfo->pszUser    = (WCHAR *)MIDL_user_allocate( cbUserName );

        if( pUserInfo->pszUser ) {

            pUserInfo->fAnonymous = ( pUserData->Flags & UF_ANONYMOUS ) != 0;
            pUserInfo->inetHost   = (DWORD)pUserData->HostIpAddress.s_addr;
            pUserInfo->tConnect   = tConnect;

            if( !MultiByteToWideChar( CP_OEMCP,
                                     0,
                                     pUserData->QueryUserName(),
                                     -1,
                                     pUserInfo->pszUser,
                                     (int)cbUserName )
               ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "MultiByteToWideChar failed???\n" ));

                pUserEnumBuffer->fResult = ( pUserEnumBuffer->fResult && FALSE);
            } else {
                pUserEnumBuffer->nEntry++;
            }
        }
        else {

            //
            // Unable to allocate memory
            //
            pUserEnumBuffer->fResult = ( pUserEnumBuffer->fResult && FALSE);
        }

    } else {

        pUserEnumBuffer->fResult = ( pUserEnumBuffer->fResult && FALSE);
    }

# ifdef CHECK_DBG

    sprintf( szBuffer, " Enum  tLastAction=%u;  tConnect=%u. " ,
            ( pUserEnumBuffer->dwCurrentTime -
             pUserData->QueryTimeAtLastAccess()),
            tConnect
            );

    pUserData->Print( szBuffer);

# endif // CHECK_DBG

    return ( TRUE);
} // EnumerateUserInBufferWorker()



BOOL
EnumerateUsers(
    PCHAR   pBuffer,
    PDWORD  pcbBuffer,
    PDWORD  nRead,
    FTP_SERVER_INSTANCE *pInstance
    )
/*++
  Enumerates the current active users into the specified buffer.

  Arguments:
    pvEnum   pointer to enumeration buffer which will receive the number of
                   entries and the user information.
    pcbBuffer  pointer to count of bytes. On entry this contains the size in
                   bytes of the enumeration buffer. It receives the count
                   of bytes for enumerating all the users.
    nRead - pointer to a DWORD to return the number of user entries filled.

  Returns:
    TRUE  if enumeration is successful ( all connected users accounted for)
    FALSE  otherwise

--*/
{
    USER_ENUM_BUFFER       userEnumBuffer;
    BOOL   fSuccess;

    DBG_ASSERT( pcbBuffer != NULL );

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering EnumerateUsers( %08x, %08x[%d]).\n",
                    pBuffer, pcbBuffer, *pcbBuffer));
    }

    //
    //  Setup the data in user enumeration buffer.
    //

    userEnumBuffer.cbSize     = *pcbBuffer;
    userEnumBuffer.cbRequired = 0;
    userEnumBuffer.pUserInfo  = (LPIIS_USER_INFO_1)pBuffer;
    userEnumBuffer.nEntry     = 0;
    userEnumBuffer.dwCurrentTime = GetCurrentTimeInSeconds();
    userEnumBuffer.fResult    = TRUE;

    //
    // CODEWORK
    // This field is obsolete it now points to the extra CONN_LEEWAY
    // buffer.
    //
    userEnumBuffer.pszNext    = ((WCHAR *)( pBuffer + *pcbBuffer));


    //
    //  Scan the users and get the information required.
    //

    pInstance->Reference();
    pInstance->LockConnectionsList();

    fSuccess = (pInstance->
                EnumerateConnection( EnumerateUserInBufferWorker,
                                    (LPVOID ) &userEnumBuffer,
                                    0));

    pInstance->UnlockConnectionsList();
    pInstance->Dereference();

    //
    //  Update enum buffer header.
    //

    *nRead             = userEnumBuffer.nEntry;
    *pcbBuffer         = userEnumBuffer.cbRequired;

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF((DBG_CONTEXT,
                   " Leaving EnumerateUsers() with %d."
                   " Entries read =%d. BufferSize required = %d\n",
                   userEnumBuffer.fResult,
                   userEnumBuffer.nEntry, userEnumBuffer.cbRequired));
    }

    return ( userEnumBuffer.fResult);

}   // EnumerateUsers




SOCKERR
USER_DATA::SendMultilineMessage(
    IN UINT  nReplyCode,
    IN LPCSTR pszzMessage,
    IN BOOL fIsFirst,
    IN BOOL fIsLast)
/*++
  Sends a multiline message to the control socket of the client.

  Arguments:
    nReplyCode   the reply code to use for the first line of the multi-line
                  message.
    pszzMessage  pointer to double null terminated sequence of strings
                  containing the message to be sent.
    fIsFirst     flag to indicate we are starting the multiline reply. if FALSE,
                  don't print the code for the first line, as it was already emmited elsewhere
    fIsLast      flag to indicate we are finishing the multiline reply. if FALSE,
                  don't print the code for the first line, as it was already emmited elsewhere

    If the message is empty, we do not print anything. If there is only one line, then if
    fIsLast is TRUE, we only print the terminating line, otherwise we do print the openning
    line if fIsFirst is TRUE.

  Returns:
    SOCKERR  - 0 if successful, !0 if not.

  History:
    MuraliK    12-April-1995
--*/
{
    SOCKERR   serr = 0;
    LPCSTR    pszMsg, pszNext;

    //
    // return if there is nothing to send
    //

    if ( pszzMessage == NULL || *pszzMessage == '\0') {
        return serr;
    }


    for ( pszMsg = pszzMessage;  serr == 0 && *pszMsg != '\0';  pszMsg = pszNext) {

        //
        // find next message so that we can check of pszMsg is the last line
        //

        pszNext = pszMsg + strlen( pszMsg) + 1;

        if( fIsLast && *pszNext == '\0' ) {
            //
            // This is globally the last line. Print it pefixed with the reply code.
            //
            serr = SockPrintf2(this, QueryControlSocket(),
                               "%u %s",
                               nReplyCode,
                               pszMsg);

        } else if( fIsFirst ) {
            //
            // this is globally the first line of reply, and it is not globally the last one.
            // print it with '-'.
            //
            serr = SockPrintf2(this, QueryControlSocket(),
                               "%u-%s",
                               nReplyCode,
                               pszMsg);

            fIsFirst = FALSE;
        } else {
            //
            // this is either an intermediate line, or the last line in this batch (but
            // not globally), so print it idented without the reply code.
            //
            serr = SockPrintf2(this, QueryControlSocket(),
                               "    %s",
                               pszMsg);
        }
    } // for

    return ( serr);

} // USER_DATA::SendMultilineMessge()






SOCKERR
USER_DATA::SendDirectoryAnnotation( IN UINT ReplyCode, IN BOOL fIsFirst)
/*++
    SYNOPSIS:   Tries to open the FTPD_ANNOTATION_FILE (~~ftpsvc~~.ckm)
                file in the user's current directory.  If it can be
                opened, it is sent to the user over the command socket
                as a multi-line reply.

    ENTRY:
                ReplyCode - The reply code to send as the first line
                    of this multi-line reply.

                fIsFirst - flag to indicate if this is the first line in the multi-line
                    reply. If not, the ReplyCode is not shown

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     06-May-1993 Created.
        MuraliK     12-Apr-1995 Made it to be part of USER_DATA
--*/
{
    FILE    * pfile;
    SOCKERR   serr = 0;
    CHAR      szLine[MAX_REPLY_LENGTH+1];


    //
    //  Try to open the annotation file.
    //

    pfile = Virtual_fopen( this,
                           FTPD_ANNOTATION_FILE,
                           "r" );

    if( pfile == NULL )
    {
        //
        //  File not found.  Blow it off.
        //

        return 0;
    }


    // protection agians attack when CKM file islarge, somebody is downloading it
    // slowly on many connections and uses all ATQ threads. Note that attack is still possible
    // but much more difficult to achieve

    AtqSetInfo( AtqIncMaxPoolThreads, 0);

    //
    //  While there's more text in the file, blast
    //  it to the user.
    //

    while( fgets( szLine, MAX_REPLY_LENGTH, pfile ) != NULL )
    {
        CHAR * pszTmp = szLine + strlen(szLine) - 1;

        //
        //  Remove any trailing CR/LFs in the string.
        //

        while( ( pszTmp >= szLine ) &&
               ( ( *pszTmp == '\n' ) || ( *pszTmp == '\r' ) ) )
        {
            *pszTmp-- = '\0';
        }

        //
        //  Ensure we send the proper prefix for the
        //  very *first* line of the file.
        //

        if( fIsFirst )
        {
            serr = SockPrintf2(this,
                               QueryControlSocket(),
                               "%u-%s",
                               ReplyCode,
                               szLine );

            fIsFirst = FALSE;
        }
        else
        {
            serr = SockPrintf2(this,
                               QueryControlSocket(),
                               "   %s",
                               szLine );
        }

        if( serr != 0 )
        {
            //
            //  Socket error sending file.
            //

            break;
        }
    }

    AtqSetInfo( AtqDecMaxPoolThreads, 0);

    //
    //  Cleanup.
    //

    if ( 0 != fclose( pfile )) {

        IF_DEBUG( ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "[%08x]::SendAnnotationFile() file close failed. "
                       " Error = %d\n",
                       this,
                       GetLastError()
                       ));
        }
    }

    return serr;

}   // USER_DATA::SendDirectoryAnnotation()




SOCKERR
USER_DATA::SendErrorToClient(
   IN LPCSTR pszPath,
   IN DWORD  dwError,
   IN LPCSTR pszDefaultErrorMsg,
   IN UINT nReplyCode
   )
/*++
  Send an error message indicating that the path is not found or
   a particular error occured in a path.

  Arguments:
    sock       socket to be used for synchronously sending message
    pszPath    pointer to path to be used.
    dwError    DWORD containing the error code, used for getting error text.
    pszDefaultErrorMsg  pointer to null-terminated string containing the
                     error message to be used if we can't alloc error text.
    nReplyCode UINT containing the FTP reply code.

  Returns:
    SOCKERR.  0 if successful and !0 if failure.
--*/
{
    BOOL    fDelete = TRUE;
    LPCSTR  pszText;
    APIERR serr;

    DBG_ASSERT( pszPath != NULL);
    pszText = AllocErrorText( dwError );

    if( pszText == NULL ) {

        pszText = pszDefaultErrorMsg;
        fDelete = FALSE;
    }

    serr = ReplyToUser( this,
                        nReplyCode,
                        PSZ_FILE_ERROR,
                        pszPath,
                        pszText );

    if( fDelete ) {

        FreeErrorText( (char *) pszText );
    }

    return ( serr);
} // USER_DATA::SendErrorToClient()





BOOL
USER_DATA::FreeUserToken( VOID)
/*++

   This function frees the user token if present already.
   Otherwise does nothing.
--*/
{
    BOOL fReturn = TRUE;

    if( UserToken != NULL ) {

        fReturn = TsDeleteUserToken( UserToken );

        UserToken = NULL;
        ::RevertToSelf();
    }

    return ( fReturn);
} // USER_DATA::FreeUserToken()




APIERR
USER_DATA::CdToUsersHomeDirectory(IN const CHAR * pszAnonymousName)
/*++
  This function changes user's home directory.
  First, a CD to the virtual root is attempted.
  If this succeeds, a CD to pszUser is attempted.
  If this fails, a CD to DEFAULT_SUB_DIRECTORY is attempted.

  Returns:
    APIERR.  NO_ERROR on success.
--*/

{
    APIERR   err;
    LPSTR    pszUser;
    CHAR     rgchRoot[MAX_PATH];

    //
    //  Find the appropriate user name.
    //

    if( TEST_UF( this, ANONYMOUS ) ) {

        pszUser = (char *) pszAnonymousName;
    } else {

        pszUser = (PCHAR)_mbspbrk( (PUCHAR)m_szUserName, (PUCHAR)"/\\" );
        pszUser = ( pszUser == NULL) ? m_szUserName : pszUser + 1;
    }

    //
    //  Try the top-level home directory.  If this fails, bag out.
    //   Set and try to change directory to symbolic root.
    //

    m_szCurrentDirectory[0] = '\0'; // initially nothing.

    m_pInstance->LockThisForRead();
    DBG_ASSERT( strlen( m_pInstance->QueryRoot()) < MAX_PATH);
    P_strncpy( rgchRoot, m_pInstance->QueryRoot(), MAX_PATH);
    m_pInstance->UnlockThis();

    err = VirtualChDir( this, rgchRoot); // change to default dir.

    if( err == NO_ERROR ) {

        //
        //  We successfully CD'd into the top-level home
        //  directory.  Now see if we can CD into pszUser.
        //

        if( VirtualChDir( this, pszUser ) != NO_ERROR ) {

            //
            //  Nope, try DEFAULT_SUB_DIRECTORY. If this fails, just
            //  hang-out at the top-level home directory.
            //

            VirtualChDir( this, PSZ_DEFAULT_SUB_DIRECTORY );
        }
    }

    return ( err);

}   // USER_DATA::CdToUsersHomeDirectory()





APIERR
USER_DATA::OpenFileForSend( IN LPSTR pszFile)
/*++
  Open an existing file for transmission using TransmitFile.
  This function converts the given relative path into canonicalized full
    path and opens the file through the cached file handles manager.

  Arguments:
    pszFile   pointer to null-terminated string containing the file name

  Returns:
    TRUE on success and FALSE if any failure.
--*/
{
    APIERR  err;
    CHAR   szCanonPath[MAX_PATH];
    DWORD  cbSize = MAX_PATH*sizeof(CHAR);
    CHAR   szVirtualPath[MAX_PATH+1];
    DWORD  cchVirtualPath = MAX_PATH;

    DBG_ASSERT( pszFile != NULL );

    //
    // Close any file we might have open now
    // N.B. There shouldn't be an open file; we're just
    // being careful here.
    //

    if (m_pOpenFileInfo) {
        DBGPRINTF(( DBG_CONTEXT,
                   "WARNING!! Closing [%08x], before opening %s\n",
                   pszFile
                   ));
        DBG_REQUIRE( CloseFileForSend() );
    }

    //
    // Open the requested file
    //
    err = VirtualCanonicalize(szCanonPath,
                              &cbSize,
                              pszFile,
                              AccessTypeRead,
                              NULL,
                              szVirtualPath,
                              &cchVirtualPath);

    if( err == NO_ERROR ) {

        DWORD                   dwCreateFlags = 0;

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                        "Opening File: %s\n", szCanonPath ));
        }

        // store the virtual path name of file.
        P_strncpy( m_rgchFile, szVirtualPath, sizeof(m_rgchFile));

        dwCreateFlags = TS_FORBID_SHORT_NAMES | TS_NOT_IMPERSONATED ;


        if ( m_pMetaData )
        {
            if ( m_pMetaData->QueryDoCache() )
            {
                dwCreateFlags |= TS_CACHING_DESIRED;
            }
        }
        else
        {
            dwCreateFlags |= TS_CACHING_DESIRED;
        }

        m_pOpenFileInfo = TsCreateFile( m_pInstance->GetTsvcCache(),
                                szCanonPath,
                                QueryImpersonationToken(),
                                dwCreateFlags
                                );
                                // caching desired.

        if( m_pOpenFileInfo == NULL ) {

            err = GetLastError();

        } else {

            DWORD dwAttrib = m_pOpenFileInfo->QueryAttributes();

            FacIncrement( FacFilesOpened);

            DBG_ASSERT( dwAttrib != 0xffffffff);

            if (dwAttrib == 0xFFFFFFFF ||   // invalid attributes
                dwAttrib & (FILE_ATTRIBUTE_DIRECTORY |
                            FILE_ATTRIBUTE_HIDDEN |
                            FILE_ATTRIBUTE_SYSTEM)
                ) {

                FacIncrement( FacFilesInvalid);

                err =  ERROR_FILE_NOT_FOUND;
            }

        }
    }

    if( err != NO_ERROR ) {

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot open %s, error %lu\n",
                       pszFile,
                       err ));
        }
    }

    return ( err);
} // USER_DATA::OpenFileForSend()





BOOL
USER_DATA::CloseFileForSend( IN DWORD dwError)
{
    BOOL fReturn = TRUE;
    TS_OPEN_FILE_INFO * pOpenFileInfo;

    // make sure it includes the full path
    DBG_ASSERT( m_rgchFile[0] == '/');

    pOpenFileInfo = (TS_OPEN_FILE_INFO *) InterlockedExchangePointer(
                                              (PVOID *) &m_pOpenFileInfo,
                                              NULL
                                              );

    if ( pOpenFileInfo != NULL) {

        //
        // Fabricate an appropriate reply code based on the incoming
        // error code. WriteLogRecord() will pick up this reply code
        // and use it in the activity log.
        //

        SetLastReplyCode(
            ( dwError == NO_ERROR )
                ? REPLY_TRANSFER_OK
                : REPLY_TRANSFER_ABORTED
                );

        FacIncrement( FacFilesClosed);
        TsCloseHandle( m_pInstance->GetTsvcCache(), pOpenFileInfo);
        WriteLogRecord( PSZ_SENT_VERB, m_rgchFile, dwError);
    }

    return ( fReturn);
} // USER_DATA::CloseFileForSend()






# define MAX_ERROR_MESSAGE_LEN   ( 500)
VOID
USER_DATA::WriteLogRecord( IN LPCSTR  pszVerb,
                           IN LPCSTR  pszPath,
                           IN DWORD   dwError)
/*++
  This function writes the log record for current request made to the
   Ftp server by the client.

  Arguments:
    pszVerb    - pointer to null-terminated string containing the verb
                 of operation done
    pszPath    - pointer to string containing the path for the verb
    dwError    - DWORD containing the error code for operation

  Returns:
    None.
--*/
{
    INETLOG_INFORMATION   ilRequest;
    DWORD dwLog;
    CHAR  pszClientHostName[50];
    CHAR  pszServerIpAddress[50];
    CHAR  rgchRequest[MAX_PATH + 20];
    DWORD cch;
    static CHAR szFTPVersion[]="FTP";

    BOOL  fDontLog = m_pMetaData && m_pMetaData->DontLog();

    if (!fDontLog)
    {

                //
                // Fill in the information that needs to be logged.
                //

                ZeroMemory(&ilRequest, sizeof(ilRequest));

                strcpy( pszClientHostName, (char *)QueryClientHostName());
                ilRequest.pszClientHostName       = pszClientHostName;
                ilRequest.cbClientHostName       = strlen(pszClientHostName);

                ilRequest.pszClientUserName       = (char *)QueryUserName();
                strcpy( pszServerIpAddress, inet_ntoa( LocalIpAddress ));
                ilRequest.pszServerAddress        = pszServerIpAddress;

                ilRequest.msTimeForProcessing     = QueryProcessingTime();
                ilRequest.dwBytesSent             = m_licbSent.LowPart;
                ilRequest.dwBytesRecvd            = m_cbRecvd;
                ilRequest.dwProtocolStatus        = GetLastReplyCode();
                ilRequest.dwWin32Status           = dwError;
                ilRequest.dwPort                  = ntohs ((WORD)LocalIpPort);

                cch = wsprintfA( rgchRequest, "[%d]%s", QueryId(), pszVerb);
                DBG_ASSERT( cch < MAX_PATH + 20);

                ilRequest.pszOperation            = rgchRequest;
                if ( rgchRequest != NULL ) {
                        ilRequest.cbOperation            = strlen(rgchRequest);
                } else {
                        ilRequest.cbOperation            = 0;
                }

                ilRequest.pszTarget               = (char *)pszPath;
                if ( pszPath != NULL ) {
                        ilRequest.cbTarget               = strlen((char *)pszPath);
                } else {
                        ilRequest.cbTarget               = 0;
                }

                ilRequest.pszParameters             = "";
                ilRequest.pszVersion                = szFTPVersion;

                dwLog = m_pInstance->m_Logging.LogInformation( &ilRequest);

                if ( dwLog != NO_ERROR) {
                        IF_DEBUG( ERROR) {

                                DBGPRINTF((DBG_CONTEXT,
                                                   " Unable to log information to logger. Error = %u\n",
                                                   dwLog));

                                DBGPRINTF((DBG_CONTEXT,
                                                   " Request From %s, User %s. Request = %s %s\n",
                                                   ilRequest.pszClientHostName,
                                                   ilRequest.pszClientUserName,
                                                   ilRequest.pszOperation,
                                                   ilRequest.pszTarget));
                        }
                }

                //
                // LogInformation() should not fail.
                //  If it does fail, the TsvcInfo will gracefully suspend logging
                //    for now.
                //  We may want to gracefully handle the same.
        //
    }

    m_cbRecvd = 0;        // reset since we wrote the record

    m_pInstance->QueryStatsObj()->UpdateTotalBytesSent( m_licbSent.QuadPart );
    m_licbSent.QuadPart = 0;

    return;
} // USER_DATA::WriteLogRecord()

VOID
USER_DATA::WriteLogRecordForSendError( DWORD dwError )
{
    //
    // We put this into its own method in this file so it can access
    // the common PSZ_SENT_VERB global.
    //

    WriteLogRecord(
        PSZ_SENT_VERB,
        m_rgchFile,
        dwError
        );

}   // USER_DATA::WriteLogRecordForSendError



//
//  Private functions.
//

VOID
USER_DATA::CloseSockets(IN BOOL fWarnUser)
/*++
  Closes sockets (data and control) opened by the user for this session.

  Arguments:
    fWarnUser  - If TRUE, send the user a warning shot before closing
                   the sockets.
--*/
{
    SOCKET PassiveSocket;
    SOCKET ControlSocket;

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    //
    //  Close any open sockets.  It is very important to set
    //  PassiveDataListen socket & ControlSocket to INVALID_SOCKET
    //   *before* we actually close the sockets.
    //  Since this routine is called to
    //  disconnect a user, and may be called from the RPC thread,
    //  closing one of the sockets may cause the client thread
    //  to unblock and try to access the socket.  Setting the
    //  values in the per-user area to INVALID_SOCKET before
    //  closing the sockets keeps this from being a problem.
    //
    //  This was a problem created by the Select or WaitForMultipleObjects()
    //   Investigate if such race conditions occur with   Asynchronous IO?
    //      NYI
    //

    CleanupPassiveSocket( TRUE );

    //
    // Get rid of the async io connection used for data transfer.
    //

    m_AioDataConnection.StopIo( NO_ERROR);

    ControlSocket = QueryControlSocket();

    if( ControlSocket != INVALID_SOCKET )
    {
        if( fWarnUser )
        {
            //
            //  Since this may be called in a context other than
            //  the user we're disconnecting, we cannot rely
            //  on the USER_DATA fields.  So, we cannot call
            //  SockReply, so we'll kludge one together with
            //  SockPrintf2.
            //

            SockPrintf2( this,
                         ControlSocket,
                         "%d Terminating connection.",
                         REPLY_SERVICE_NOT_AVAILABLE );
        }

        StopControlIo(); // to stop the io on control socket.
    }

    return;

}   // USER_DATA::CloseSockets()


/*******************************************************************

    NAME:       UserpGetNextId

    SYNOPSIS:   Returns the next available user id.

    RETURNS:    DWORD - The user id.

    HISTORY:
        KeithMo     23-Mar-1993 Created.

********************************************************************/
DWORD
UserpGetNextId(
    VOID
    )
{
    DWORD userId;

    // Increment the global counter, avoiding it from becoming 0.
    InterlockedIncrement( (LPLONG ) &p_NextUserId);

    if ((userId = p_NextUserId) == 0) {

        InterlockedIncrement( (LPLONG ) &p_NextUserId);
        userId = p_NextUserId;
    }

    DBG_ASSERT( userId != 0);

    return userId;

}   // UserpGetNextId





VOID
USER_DATA::Print( IN LPCSTR pszMsg) const
/*++

  Prints the UserData object in debug mode.

  History:
     MuraliK  28-March-1995  Created.
--*/
{

# ifdef CHECK_DBG
    CHAR   szBuffer[1000];

    sprintf( szBuffer,
            "[%d] %s: {%u} \"%s\" State=%u. Ref=%u.\n"
            "    Ctrl sock=%u; Atq=%x. Data sock=%u; Atq=%x. CtrlRead=%u\n"
            "    LastCmd= \"%s\"\n",
            GetCurrentThreadId(), pszMsg,
            QueryId(), QueryUserName(),
            QueryState(), QueryReference(),
            QueryControlSocket(), m_AioControlConnection.QueryAtqContext(),
            QueryDataSocket(), m_AioDataConnection.QueryAtqContext(),
            TEST_UF( this, CONTROL_READ), m_recvBuffer
            );

    OutputDebugString( szBuffer);

# endif // CHECK_DBG

#ifndef _NO_TRACING_
    CHKINFO( ( DBG_CONTEXT,
                " Printing USER_DATA( %08x)   Signature: %08x\n"
                " RefCount  = %08x;  UserState = %08x;\n"
                " ControlSocket = %08x; PassiveL = %08x\n"
                " FileInfo@ = %08x; CurDir( %s) Handle = %08x\n"
                " UserName = %s; UserToken = %08x; UserId = %u\n"
                " Behaviour Flags = %08x; XferType = %d; XferMode = %d\n",
                this, Signature, m_References, UserState,
                QueryControlSocket(), m_sPassiveDataListen,
                m_pOpenFileInfo, QueryCurrentDirectory(), CurrentDirHandle,
                QueryUserName(), UserToken, QueryId(),
                Flags, m_xferType, m_xferMode));
#else
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing USER_DATA( %08x)   Signature: %08x\n"
                " RefCount  = %08x;  UserState = %08x;\n"
                " ControlSocket = %08x; PassiveL = %08x\n"
                " FileInfo@ = %08x; CurDir( %s) Handle = %08x\n"
                " UserName = %s; UserToken = %08x; UserId = %u\n"
                " Behaviour Flags = %08x; XferType = %d; XferMode = %d\n",
                this, Signature, m_References, UserState,
                QueryControlSocket(), m_sPassiveDataListen,
                m_pOpenFileInfo, QueryCurrentDirectory(), CurrentDirHandle,
                QueryUserName(), UserToken, QueryId(),
                Flags, m_xferType, m_xferMode));
#endif

    DBGPRINTF( ( DBG_CONTEXT,
                " Local IpAddr = %s; HostIpAddr = %s; DataIpAddr = %s;\n"
                " Port = %d; TimeAtConnection = %08x;\n",
                inet_ntoa( LocalIpAddress), inet_ntoa( HostIpAddress),
                inet_ntoa( DataIpAddress),
                DataPort,
                m_TimeAtConnection));

    DBGPRINTF(( DBG_CONTEXT, " ASYNC_IO_CONN Control=%08x; Data=%08x\n",
               &m_AioControlConnection, m_AioDataConnection));

    IF_DEBUG( ASYNC_IO) {

# if DBG
        m_AioControlConnection.Print();
        m_AioDataConnection.Print();
# endif // DBG
    }

    return;
} // USER_DATA::Print()




BOOL
USER_DATA::VirtualPathAccessCheck(IN ACCESS_TYPE  _access, IN  char * pszPath)
/*++
  checks to see if the access is allowed for accessing the path
    using pszPath after canonicalizing it.

 Arguments:
    access     the access desired
    pszPath    pointer to string containing the path

 Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DWORD  dwError;
    DWORD  dwSize = MAX_PATH;
    CHAR   rgchPath[MAX_PATH];


    // this following call converts the symbolic path into absolute
    //  and also does path access check.
    dwError = VirtualCanonicalize(rgchPath, &dwSize,
                                  pszPath, _access);

    return ( dwError);

} // USER_DATA::VirtualPathAccessCheck()





APIERR
USER_DATA::VirtualCanonicalize(
    OUT CHAR *   pszDest,
    IN OUT LPDWORD  lpdwSize,
    IN OUT CHAR *   pszSearchPath,
    IN ACCESS_TYPE  _access,
    OUT LPDWORD     pdwAccessMask,
    OUT CHAR *      pchVirtualPath,             /* OPTIONAL */
    IN OUT LPDWORD  lpcchVirtualPath            /* OPTIONAL */
    )
/*++
  This function canonicalizes the path, taking into account the current
    user's current directory value.

  Arguments:
     pszDest   string that will on return contain the complete
                      canonicalized path. This buffer will be of size
                      specified in *lpdwSize.

     lpdwSize  Contains the size of the buffer pszDest on entry.
                  On return contains the number of bytes written
                   into the buffer or number of bytes required.

     pszSearchPath  pointer to string containing the path to be converted.
       IF NULL, use the current directory only

     accesss   Access type for this path ( read, write, etc.)

     pdwAccessMask  pointer to DWORD which on succesful deciphering
                     will contain the  access mask.

     pchVirtualPath  pointer to string which will contain the sanitized
                     virtual path on return (on success)
     lpcchVirtualPath  pointer to DWORD containing the length of buffer
                     (contains the length on return).

  Returns:

     Win32 Error Code - NO_ERROR on success

     MuraliK   24-Apr-1995   Created.

--*/
{
    DWORD dwError = NO_ERROR;
    CHAR  rgchVirtual[MAX_PATH];

    DBG_ASSERT( pszDest != NULL);
    DBG_ASSERT( lpdwSize != NULL);
    DBG_ASSERT( pszSearchPath != NULL);

    IF_DEBUG( VIRTUAL_IO) {

        DBGPRINTF(( DBG_CONTEXT,
                   "UserData(%08x)::VirtualCanonicalize(%08x, %08x[%u],"
                   " %s, %d)\n",
                   this, pszDest, lpdwSize, *lpdwSize, pszSearchPath, _access));
    }

    if ( pdwAccessMask != NULL) {

        *pdwAccessMask = 0;
    }

    //
    // Form the virtual path for the given path.
    //

    if ( !IS_PATH_SEP( *pszSearchPath)) {

        const CHAR * pszNewDir = QueryCurrentDirectory(); // get virtual dir.

        //
        // This is a relative path. append it to currrent directory
        //

        if ( strlen(pszNewDir) + strlen(pszSearchPath) + 2 <= MAX_PATH) {

            // copy the current directory
            wsprintfA( rgchVirtual, "%s/%s",
                      pszNewDir, pszSearchPath);
            pszSearchPath = rgchVirtual;

        } else {

            // long path --> is not supported.
            DBGPRINTF((DBG_CONTEXT, "Long Virtual Path %s---%s\n",
                       pszNewDir, pszSearchPath));

            dwError = ERROR_PATH_NOT_FOUND;
        }

    } else {

        // This is an absolute virtual path.
        // need to overwrite this virtual path with absolute
        // path of the root.  Do nothing.
    }

    if ( dwError == NO_ERROR) {

        DWORD dwAccessMask = 0;
        DBG_ASSERT( IS_PATH_SEP(*pszSearchPath));

        //
        // Now we have the complete symbolic path to the target file.
        //  Translate it into the absolute path
        //

        VirtualpSanitizePath( pszSearchPath);

        if ( !LookupVirtualRoot( pszSearchPath,
                                 pszDest,
                                 lpdwSize,
                                 &dwAccessMask ) ) {

            dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "LookupVirtualRoot Failed. Error = %d. pszDest = %s. BReq=%d\n",
                       dwError, pszDest, *lpdwSize));
        } else if ( !PathAccessCheck( _access, dwAccessMask,
                                     TEST_UF( this, READ_ACCESS),
                                     TEST_UF( this, WRITE_ACCESS))
                   ) {

            dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "PathAccessCheck Failed. Error = %d. pszDest = %s\n",
                       dwError, pszDest));
        } else if ( lpcchVirtualPath != NULL) {

            // successful in getting the path.

            DWORD cchVPath = strlen( pszSearchPath);

            if ( *lpcchVirtualPath > cchVPath && pchVirtualPath != NULL) {

                // copy the virtual path, since we have space.
                strcpy( pchVirtualPath, pszSearchPath);
            }

            *lpcchVirtualPath = cchVPath;   // set the length to required size.
        }

        if ( dwError == NO_ERROR ) {
            // IP check

            AC_RESULT       acIpAccess;
            AC_RESULT       acDnsAccess;
            BOOL            fNeedDnsCheck;

            BindPathAccessCheck();
            acIpAccess = QueryAccessCheck()->CheckIpAccess( &fNeedDnsCheck );

            if ( (acIpAccess == AC_IN_DENY_LIST) ||
                 ((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) ) {
                dwError = ERROR_INCORRECT_ADDRESS;
            }
            else if ( fNeedDnsCheck ) {
                if ( !QueryAccessCheck()->IsDnsResolved() ) {
                    BOOL fSync;
                    LPSTR pDns;

                    if ( !QueryAccessCheck()->QueryDnsName( &fSync,
                            (ADDRCHECKFUNCEX)NULL,
                            (ADDRCHECKARG)NULL,
                            &pDns ) ) {
                        dwError = ERROR_INCORRECT_ADDRESS;
                    }
                }
                if ( dwError == NO_ERROR ) {
                    acDnsAccess = QueryAccessCheck()->CheckDnsAccess();

                    if ( (acDnsAccess == AC_IN_DENY_LIST) ||
                         (acDnsAccess == AC_NOT_IN_GRANT_LIST) ||
                         ((m_acCheck == AC_NOT_IN_GRANT_LIST) &&
                          (acDnsAccess != AC_IN_GRANT_LIST) ) ) {
                        dwError = ERROR_INCORRECT_ADDRESS;
                    }
                }
            }
            UnbindPathAccessCheck();
        }

        if ( pdwAccessMask != NULL) {

            *pdwAccessMask = dwAccessMask;
        }
    }


    IF_DEBUG( VIRTUAL_IO) {

        if ( dwError != NO_ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       " Cannot Canonicalize %s -- %s, Error = %lu\n",
                       QueryCurrentDirectory(),
                       pszSearchPath,
                       dwError));
        } else {

            DBGPRINTF(( DBG_CONTEXT,
                       "Canonicalized path is: %s\n",
                       pszDest));
        }
    }

    return ( dwError);
} // USER_DATA::VirtualCanonicalize()





/*******************************************************************

********************************************************************/
SOCKERR
USER_DATA::EstablishDataConnection(
    IN LPCSTR   pszReason,
    IN LPCSTR   pszSize
    )
/*++

  Connects to the client's data socket.

  Arguments:
     pszReason - The reason for the transfer (file list, get, put, etc).
     pszSize   - size of data being transferred.

  Returns:
    socket error code on any error.
--*/
{
    SOCKERR     serr  = 0;
    SOCKET      DataSocket = INVALID_SOCKET;
    BOOL        fPassive;
    BOOL        fAcceptableSocket = FALSE;

    //
    // if we're in passive mode and aren't dealing with a fake IO completion [ie reprocessing
    // the command], we just set up the event that will get signalled when the client
    // actually connects.
    //

    if ( TEST_UF( this, PASSIVE ) &&
         !QueryInFakeIOCompletion() )
    {
        //
        //  Ensure we actually created a passive listen data socket.
        //    no data transfer socket is in AsyncIo object.
        //

        DBG_ASSERT( m_sPassiveDataListen != INVALID_SOCKET );

        //
        // To avoid blocking while waiting for the client to connect, we're going to use
        // WSAEventSelect() to wait for the socket to be accept()'able.
        //
        //

        if ( ( serr = AddPASVAcceptEvent( &fAcceptableSocket ) ) != 0 )
        {
            ReplyToUser( this,
                         REPLY_LOCAL_ERROR,
                         PSZ_TOO_MANY_PASV_USERS );

            return ( serr );
        }

        //
        // No need to wait around, we can call accept() on the socket right now
        //
        if ( fAcceptableSocket )
        {
            goto continue_label;
        }

        m_fWaitingForPASVConn = TRUE;
        m_fHavePASVConn = FALSE;

        return ERROR_IO_PENDING;
    }

    DBG_ASSERT( !TEST_UF(this, PASSIVE) || QueryInFakeIOCompletion() );


continue_label:
    //
    //  Reset any oob flag.
    //

    CLEAR_UF( this, OOB_DATA );

    //
    //  Capture the user's passive flag, then reset to FALSE.
    //

    fPassive = TEST_UF( this, PASSIVE );
    CLEAR_UF( this, PASSIVE );

    //
    //  If we're in passive mode, then accept a connection to
    //  the data socket.
    //
    //  Calling accept() on this socket should -not- block because shouldn't get this
    //  far without being sure that calling accept() won't block - that's the point of
    //  jumping through the WSAEventSelect() hoops mentioned above
    //

    if( fPassive )
    {

        SOCKADDR_IN saddrClient;

        //
        //  Ensure we actually created a passive listen data socket.
        //    no data transfer socket is in AsyncIo object.
        //

        DBG_ASSERT( m_sPassiveDataListen != INVALID_SOCKET );

        //
        //  Wait for a connection.
        //

        IF_DEBUG( CLIENT )
        {

            DBGPRINTF(( DBG_CONTEXT,
                        "waiting for passive connection on socket %d\n",
                       m_sPassiveDataListen ));
        }

        serr = AcceptSocket( m_sPassiveDataListen,
                             &DataSocket,
                             &saddrClient,
                             TRUE,
                             m_pInstance );            // enforce timeouts


        //
        //  We can kill m_sPassiveDataListen now.
        //  We only allow one connection in passive mode.
        //

        CleanupPassiveSocket( TRUE );

        // PASV Theft is disabled, so you MUST have the same IP
        // address ad the Control Connection
        if (!(QueryInstance()->IsEnablePasvTheft()))
        {
            if (!(HostIpAddress.S_un.S_addr == saddrClient.sin_addr.S_un.S_addr))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Unmatching IP - Control: %d.%d.%d.%d Data: %d.%d.%d.%d \n",
                           HostIpAddress.S_un.S_un_b.s_b1,
                           HostIpAddress.S_un.S_un_b.s_b2,
                           HostIpAddress.S_un.S_un_b.s_b3,
                           HostIpAddress.S_un.S_un_b.s_b4,
                           saddrClient.sin_addr.S_un.S_un_b.s_b1,
                           saddrClient.sin_addr.S_un.S_un_b.s_b2,
                           saddrClient.sin_addr.S_un.S_un_b.s_b3,
                           saddrClient.sin_addr.S_un.S_un_b.s_b4));

                CloseSocket( DataSocket);
                DataSocket = INVALID_SOCKET;
                serr = WSA_OPERATION_ABORTED;
            };
        };

        if( serr == 0 )
        {

            //
            //  Got one.
            //

            DBG_ASSERT( DataSocket != INVALID_SOCKET );

            m_fHavePASVConn = TRUE;
            m_fWaitingForPASVConn = FALSE;

            FacIncrement( FacPassiveDataConnections);

            if ( m_AioDataConnection.SetNewSocket( DataSocket))
            {

                ReplyToUser(this,
                            REPLY_TRANSFER_STARTING,
                            PSZ_TRANSFER_STARTING);
            }
            else
            {

                //
                // We are possibly running low on resources. Send error.
                //

                ReplyToUser( this,
                            REPLY_LOCAL_ERROR,
                            PSZ_INSUFFICIENT_RESOURCES);

                CloseSocket( DataSocket);
                DataSocket = INVALID_SOCKET;
                serr = WSAENOBUFS;
            }
        }
        else
        {

            IF_DEBUG( CLIENT )
            {

                DBGPRINTF(( DBG_CONTEXT,
                            "cannot wait for connection, error %d\n",
                            serr ));
            }

            ReplyToUser(this,
                        REPLY_TRANSFER_ABORTED,
                        PSZ_TRANSFER_ABORTED);
        }

    }
    else
    {

        //
        //  Announce our intentions of establishing a connection.
        //

        ReplyToUser(this,
                    REPLY_OPENING_CONNECTION,
                    PSZ_OPENING_DATA_CONNECTION,
                    TransferType(m_xferType ),
                    pszReason,
                    pszSize);

        //
        //  Open data socket.
        //

        serr = CreateDataSocket(&DataSocket,           // Will receive socket
                                0,                   // Local address
                                CONN_PORT_TO_DATA_PORT(LocalIpPort),
                                DataIpAddress.s_addr,// RemoteAddr
                                DataPort ); // Remote port

        if ( serr == 0 )
        {

            DBG_ASSERT( DataSocket != INVALID_SOCKET );

            FacIncrement( FacActiveDataConnections);

            if ( !m_AioDataConnection.SetNewSocket( DataSocket))
            {

                CloseSocket( DataSocket);
                DataSocket = INVALID_SOCKET;

                serr = WSAENOBUFS;
            }
        }

        if ( serr != 0)
        {

            ReplyToUser(this,
                        REPLY_CANNOT_OPEN_CONNECTION,
                        PSZ_CANNOT_OPEN_DATA_CONNECTION);

            IF_DEBUG( COMMANDS )
            {

                DBGPRINTF(( DBG_CONTEXT,
                           "could not create data socket, error %d\n",
                           serr ));
            }
        }
    }


    if( serr == 0 )
    {

        // set this to indicate a transfer might start
        SET_UF( this, TRANSFER );

        //
        // Submit a read command on control socket, since we
        //  have to await possibility of an abort on OOB_INLINE.
        // Can we ignore possibility of an error on read request?
        //

        if ( !ReadCommand())
        {

            DWORD  dwError = GetLastError();

# ifdef CHECK_DBG
            CHAR   szBuffer[100];
            sprintf( szBuffer, " Read while DataTfr failed Error = %u. ",
                    dwError);
            Print( szBuffer);
# endif // CHECK_DBG

            IF_DEBUG(CLIENT) {

                DBGPRINTF((DBG_CONTEXT,
                           " %08x::ReadCommand() failed. Error = %u\n",
                           this, dwError));
                SetLastError( dwError);
            }
        }

    }

    return ( serr);

}   // USER_DATA::EstablishDataConnection()






BOOL
USER_DATA::DestroyDataConnection( IN DWORD dwError)
/*++
  Tears down the connection to the client's data socket that was created
    using EstablishDataConnection()

  Arguments:
    dwError      = NO_ERROR if data is transferred successfully.
                 Win32 error code otherwise

--*/
{
    UINT   replyCode;
    LPCSTR pszReply;
    BOOL   fTransfer;

    fTransfer = TEST_UF( this, TRANSFER);
    CLEAR_UF( this, TRANSFER );

    CleanupPASVFlags();

    //
    //  Close the data socket.
    //

    DBG_ASSERT( m_sPassiveDataListen == INVALID_SOCKET);


    // Stop Io occuring on data connection
    m_AioDataConnection.StopIo(dwError);

    if ( fTransfer) {

        //
        //  Tell the client we're done with the transfer.
        //

        if ( dwError == NO_ERROR) {

            replyCode = REPLY_TRANSFER_OK;
            pszReply  = PSZ_TRANSFER_COMPLETE;
        } else {

            replyCode = REPLY_TRANSFER_ABORTED;
            pszReply  = PSZ_TRANSFER_ABORTED;
        }

        ReplyToUser(this, replyCode, pszReply);
    }

    return (TRUE);
} // USER_DATA::DestroyDataConnection()


APIERR
USER_DATA::GetFileSize()
{
    LARGE_INTEGER FileSize;
    DWORD         dwError = NO_ERROR;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    CHAR rgchSize[MAX_FILE_SIZE_SPEC];

    pOpenFileInfo = m_pOpenFileInfo;

    if ( pOpenFileInfo == NULL) {

        return ( ERROR_FILE_NOT_FOUND);
    }

    if ( !pOpenFileInfo->QuerySize(FileSize)) {

        dwError = GetLastError();

        if( dwError != NO_ERROR ) {

            return ( dwError);
        }
    }

    IsLargeIntegerToDecimalChar( &FileSize, rgchSize);

    ReplyToUser( this, REPLY_FILE_STATUS, rgchSize );
    return(dwError);
}

APIERR
USER_DATA::GetFileModTime(LPSYSTEMTIME lpSystemTime)
{
    DWORD         dwError = NO_ERROR;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    FILETIME      FileTime;

    pOpenFileInfo = m_pOpenFileInfo;

    DBG_ASSERT( pOpenFileInfo != NULL );

    if ( !pOpenFileInfo->QueryLastWriteTime(&FileTime)) {

        dwError = GetLastError();
        return ( dwError);
    }

    if (!FileTimeToSystemTime(&FileTime, lpSystemTime)) {

        return GetLastError();
    }

    return NO_ERROR;
}


APIERR
USER_DATA::SendFileToUser( IN LPSTR  pszFileName,
                          IN OUT LPBOOL pfErrorSent)
/*++
  This is a worker function for RETR command of FTP. It will establish
  connection via the ( new ) data socket, then send a file over that
   socket. This uses Async io for transmitting the file.

  Arguments:
     pszFileName    pointer to null-terminated string containing the filename
     pfErrorSent    pointer to boolean flag indicating if an error has
                       been already sent to client.
                    The flag should be used only when return value is error.

  Returns:
     NO_ERROR on success and Win32 error code if error.

  History:
     30-April-1995   MuraliK
--*/
{
    LARGE_INTEGER FileSize;
    DWORD         dwError = NO_ERROR;
    BOOL          fTransmit;
    DWORD         dwAttribs;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    CHAR rgchSize[MAX_FILE_SIZE_SPEC];
    CHAR rgchBuffer[MAX_FILE_SIZE_SPEC + 10];


    DBG_ASSERT( pszFileName != NULL && pfErrorSent != NULL);

    *pfErrorSent = FALSE;

    IF_DEBUG( SEND) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " USER_DATA ( %08x)::SendFileToUser( %s,"
                    " pfErrorSent = %08x).\n",
                    this, pszFileName, pfErrorSent));
    }

    //
    //  Get file size.
    //
    pOpenFileInfo = m_pOpenFileInfo;

    if ( pOpenFileInfo == NULL) {

        return ( ERROR_FILE_NOT_FOUND);
    }

    // Get the file size

    if ( !pOpenFileInfo->QuerySize(FileSize)) {

        dwError = GetLastError();

        if( dwError != NO_ERROR ) {

            return ( dwError);
        }
    }

    FileSize.QuadPart -= (LONGLONG)QueryCurrentOffset();

    IsLargeIntegerToDecimalChar( &FileSize, rgchSize);
    wsprintfA( rgchBuffer, "(%s bytes)", rgchSize);

    m_pInstance->QueryStatsObj()->IncrTotalFilesSent();

    //
    //  Blast the file from a local file to the user.
    //

    Reference();       // incr ref since async data transfer is started
    SET_UF( this, ASYNC_TRANSFER);

    fTransmit = ( m_AioDataConnection.
                 TransmitFileTs( pOpenFileInfo,
                                 FileSize, // cbToSend ( send entire file)
                                 QueryCurrentOffset() )
                 );

    if ( !fTransmit) {

        dwError = GetLastError();

        IF_DEBUG( SEND) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " Unable to transmit file ( %s) (pOpenFile = %p)."
                        " Error = %u\n",
                        pszFileName,
                        pOpenFileInfo,
                        dwError));
        }

        // decr refcount since async tfr failed.
        DBG_REQUIRE( DeReference() > 0);
    }

    //
    //  Disconnect from client.
    //  ( will be done at the call back after completion of IO).
    //

    return ( dwError);

}   // USER_DATA::SendFileToUser()



VOID
USER_DATA::SetPassiveSocket( IN SOCKET sPassive )
/*++

  This function frees up an old Passive socket and resets the
    passive socket to the new Passive socket.

Arguments:
    sPassive - new passive socket to use

--*/
{

    SOCKET sPassiveOld;

    sPassiveOld = (SOCKET) InterlockedExchangePointer ( (PVOID *) &m_sPassiveDataListen,
                                                        (PVOID) sPassive);

    if ( sPassiveOld != INVALID_SOCKET) {

        FacDecrement( FacPassiveDataListens);
        DBG_REQUIRE( CloseSocket( sPassiveOld) == 0);
    }

    if ( sPassive != INVALID_SOCKET) {

        FacIncrement(FacPassiveDataListens);
    }


    return;
} // USER_DATA::SetPassiveSocket()

VOID
USER_DATA::CleanupPassiveSocket( BOOL fTellWatchThread )
/*++

  This function cleans up the resources associated with the current passive socket

Arguments:
   fTellWatchThread - flag indicating whether to tell thread waiting for an event on
   the current passive socket to clean up as well

Returns:
   Nothing
--*/
{
    SOCKET sPassiveOld;

    LockUser();

    if ( m_sPassiveDataListen == INVALID_SOCKET )
    {
        UnlockUser();

        return;
    }

    RemovePASVAcceptEvent( fTellWatchThread );

    DBG_REQUIRE( CloseSocket( m_sPassiveDataListen ) == 0 );

    m_sPassiveDataListen = INVALID_SOCKET;

    UnlockUser();
}


BOOL
USER_DATA::SetCommand( IN LPSTR pszCmd )
/*++

Routine Description:
     Used to set pointer to FTP cmd

Arguments :
     pszArgs - pointer to command to execute

Returns :
     BOOL indicating success/failure to set values
--*/
{
    BOOL fReturn = TRUE;

    if ( !pszCmd )
    {
        return FALSE;
    }

    //
    // Free any previous allocations
    //
    if ( m_pszCmd )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    if ( m_pszCmd = ( LPSTR ) TCP_ALLOC( strlen(pszCmd) +  1 ) )
    {
        strcpy( m_pszCmd, pszCmd );
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to allocate memory for command args !\n"));

        fReturn = FALSE;
    }

    return fReturn;
}

/************************************************************
 *  Auxiliary Functions
 ************************************************************/


VOID
ProcessUserAsyncIoCompletion(IN LPVOID pContext,
                             IN DWORD  cbIo,
                             IN DWORD  dwError,
                             IN LPASYNC_IO_CONNECTION pAioConn,
                             IN BOOL   fTimedOut
                             )
/*++
  This function processes the Async Io completion ( invoked as
    a callback from the ASYNC_IO_CONNECTION object).

  Arguments:
     pContext      pointer to the context information ( UserData object).
     cbIo          count of bytes transferred in Io
     dwError       DWORD containing the error code resulting from last tfr.
     pAioConn      pointer to AsyncIo connection object.

  Returns:
     None
--*/
{

    LPUSER_DATA   pUserData = (LPUSER_DATA ) pContext;

    DBG_ASSERT( pUserData != NULL);
    DBG_ASSERT( pAioConn  != NULL);

    IF_SPECIAL_DEBUG( CRITICAL_PATH) {

        CHAR    rgchBuffer[100];

        wsprintfA( rgchBuffer, " ProcessAio( cb=%u, err=%u, Aio=%x). ",
                  cbIo, dwError, pAioConn);

        pUserData->Print( rgchBuffer);
    }

    DBG_REQUIRE( pUserData->Reference()  > 0);

# if DBG

    if ( !IS_VALID_USER_DATA( pUserData)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    pUserData));
        pUserData->Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );

    pUserData->ProcessAsyncIoCompletion( cbIo, dwError, pAioConn, fTimedOut);

    DereferenceUserDataAndKill(pUserData);

    return;

} // ProcessUserAsyncIoCompletion()


VOID
USER_DATA::RemovePASVAcceptEvent( BOOL fTellWatchThread )
/*++

Routine Description:

    Routine that cleans up the state associated with a PASV accept event

Arguments:

    fTellWatchThread - BOOL indicating whether or not to inform the thread waiting on
    the event to stop waiting on it

Returns:

    Nothing
--*/
{
    DBG_ASSERT( m_sPassiveDataListen != INVALID_SOCKET );

    if ( m_hPASVAcceptEvent == NULL )
    {
        return;
    }

    //
    // Remove all network notifications for the PASV socket
    //
    if ( WSAEventSelect( m_sPassiveDataListen,
                         m_hPASVAcceptEvent,
                         0 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WSAEventSelect on socket %d failed : 0x%x\n",
                   m_sPassiveDataListen, WSAGetLastError()));
    }

    //
    // Stop watching for the event
    //
    if ( fTellWatchThread )
    {
        RemoveAcceptEvent( m_hPASVAcceptEvent,
                           this );
    }

    WSACloseEvent( m_hPASVAcceptEvent );

    m_hPASVAcceptEvent = NULL;
}

SOCKERR
USER_DATA::AddPASVAcceptEvent( BOOL *pfAcceptableSocket )
/*++

Routine Description:

    Routine that sets up the event to signal that the PASV socket is an accept()'able
    state

Arguments:

    pfAcceptableSocket - BOOL set to TRUE if socket can be accept()'ed at once, FALSE if
    NOT

Returns:

    Error code indicating success/failure

--*/
{
    DWORD dwRet = 0;
    SOCKERR serr = 0;
    BOOL fRegistered = FALSE;

    *pfAcceptableSocket = FALSE;

    if ( ( m_hPASVAcceptEvent = WSACreateEvent() ) == WSA_INVALID_EVENT )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to create event to wait for accept() : 0x%x\n",
                   WSAGetLastError()));

        return WSAGetLastError();
    }

    //
    // specify that we want to be alerted when the socket is accept()'able =)
    //
    if ( WSAEventSelect( m_sPassiveDataListen,
                         m_hPASVAcceptEvent,
                         FD_ACCEPT ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WSAEventSelect failed : 0x%x\n",
                   WSAGetLastError()));

        serr = WSAGetLastError();

        goto exit;
    }
    else
    {
        fRegistered = TRUE;
    }

    //
    // In order to deal as quickly as possible with legitimate clients and avoid rejecting them
    // because the queue is full, we'll wait for 0.1 sec to see whether the socket becomes
    // accept()'able before queueing it
    //
    dwRet = WSAWaitForMultipleEvents( 1,
                                      &m_hPASVAcceptEvent,
                                      FALSE,
                                      100,
                                      FALSE );

    switch ( dwRet )
    {
    case WSA_WAIT_EVENT_0:
    {
        //
        // we can call accept() at once on the socket, no need to muck around with waiting
        // for it
        //
        WSAEventSelect( m_sPassiveDataListen,
                        m_hPASVAcceptEvent,
                        0 );
        WSACloseEvent( m_hPASVAcceptEvent );

        m_hPASVAcceptEvent = 0;

        *pfAcceptableSocket = TRUE;

    }
    break;

    case WSA_WAIT_TIMEOUT:
    {
        //
        // Need to queue the socket
        //
        serr = AddAcceptEvent( m_hPASVAcceptEvent,
                               this );

    }
    break;

    default:
    {
        serr = WSAGetLastError();
    }
    break;
    }

exit:

    //
    // clean up if something failed
    //
    if ( serr != 0 )
    {
        if ( m_hPASVAcceptEvent )
        {
            if ( fRegistered )
            {
                WSAEventSelect( m_sPassiveDataListen,
                                m_hPASVAcceptEvent,
                                0 );
            }

            WSACloseEvent( m_hPASVAcceptEvent );

            m_hPASVAcceptEvent = NULL;
        }
    }

    return serr;
}




VOID
DereferenceUserDataAndKill(IN OUT LPUSER_DATA pUserData)
/*++
  This function dereferences User data and kills the UserData object if the
    reference count hits 0. Before killing the user data, it also removes
    the connection from the list of active connections.

--*/
{

    FTP_SERVER_INSTANCE * pinstance;

    IF_SPECIAL_DEBUG( CRITICAL_PATH) {

        pUserData->Print( " Deref ");
    }

    //
    // We must capture the instance pointer from the user data, as
    // USER_DATA::RemoveConnection() will set the pointer to NULL.
    // We must also reference the instance before locking it, as
    // removing the last user from the instance will cause the instance
    // to be destroyed. We'll defer this destruction until we're done
    // with the instance.
    //

    pinstance = pUserData->QueryInstance();

    pinstance->Reference();
    pinstance->LockConnectionsList();

    if ( !pUserData->DeReference())  {

        //
        // Deletion of the object USER_DATA is required.
        //

        IF_DEBUG( USER_DATABASE) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " UserData( %08x) is being deleted.\n",
                        pUserData));
        }

        pinstance->UnlockConnectionsList();

        pUserData->Cleanup();

        DBG_ASSERT( pUserData->QueryControlSocket() == INVALID_SOCKET );
        DBG_ASSERT( pUserData->QueryDataSocket() == INVALID_SOCKET );

        pinstance->RemoveConnection( pUserData);
    }
    else {

        pinstance->UnlockConnectionsList();
    }

    pinstance->Dereference();

} // DereferenceUserDataAndKill()




BOOL
PathAccessCheck(IN ACCESS_TYPE _access,
                IN DWORD       dwVrootAccessMask,
                IN BOOL        fUserRead,
                IN BOOL        fUserWrite
                )
/*++
  This function determines if the required privilege to access the specified
   virtual root with a given access mask exists.

  Arguments:

    access     - specifies type of acces desired.
    dwVrootAccessMask - DWORD containing the access mask for the virtual root.
    fUserRead  - user's permission to read  (general)
    fUserWrite - user's permission to write (general)

  Returns:
    BOOL  - TRUE if access is to be granted, else FALSE.

  History:
    MuraliK   20-Sept-1995

--*/
{
    BOOL        fAccessGranted = FALSE;

    DBG_ASSERT( IS_VALID_ACCESS_TYPE( _access ) );

    //
    //  Perform the actual access check.
    //

    switch( _access ) {

      case AccessTypeRead :

        fAccessGranted = (fUserRead &&
                          ((dwVrootAccessMask & VROOT_MASK_READ)
                           == VROOT_MASK_READ)
                          );
        break;

    case AccessTypeWrite :
    case AccessTypeCreate :
    case AccessTypeDelete :

        fAccessGranted = (fUserWrite &&
                          ((dwVrootAccessMask & VROOT_MASK_WRITE)
                           == VROOT_MASK_WRITE)
                          );
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT,
                   "PathAccessCheck - invalid access type %d\n",
                   _access ));
        DBG_ASSERT( FALSE );
        break;
    }

    if (!fAccessGranted) {

        SetLastError( ERROR_ACCESS_DENIED);
    }

    return ( fAccessGranted);
} // PathAccessCheck()


VOID SignalAcceptableSocket( LPUSER_DATA pUserData )
/*++

      Function that restarts processing the original command when a PASV data socket becomes
      accept()'able [ie the client has made the connection]

  Arguments:
      pUserData - USER_DATA context attached to socket

  Returns:
     Nothing
--*/
{
    PATQ_CONTEXT pAtqContext = pUserData->QueryControlAio()->QueryAtqContext();

    //
    // Stop waiting for events on this socket
    //
    pUserData->RemovePASVAcceptEvent( FALSE );

    pUserData->SetInFakeIOCompletion( TRUE );

    //
    // do a scary thing - fake an IO completion, to trigger re-processing of the FTP command
    //
    if ( !AtqPostCompletionStatus( pAtqContext,
                                   strlen( pUserData->QueryCmdString() ) + 1 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to post fake completion status to deal with PASV event : 0x%x\n",
                   GetLastError()));

        return;
    }
}


VOID CleanupTimedOutSocketContext( LPUSER_DATA pUserData )
/*++

      Function used to do cleanup when timeout for waiting for a PASV connection expires

  Arguments:
      pUserData - context pointer

  Returns:
     Nothing
--*/
{
    DBG_ASSERT( pUserData );

    pUserData->LockUser();

    pUserData->CleanupPassiveSocket( FALSE );

    CLEAR_UF( pUserData, PASSIVE );

    pUserData->SetHavePASVConn( FALSE );

    pUserData->SetWaitingForPASVConn( FALSE );

    ReplyToUser( pUserData,
                 REPLY_CANNOT_OPEN_CONNECTION,
                 PSZ_CANNOT_OPEN_DATA_CONNECTION );
    //
    // Remove our reference to this USER_DATA object
    //
    pUserData->DeReference();

    pUserData->UnlockUser();
}

/*******************************************************************

    NAME:       FtpMetaDataFree

    SYNOPSIS:   Frees a formatted meta data object when it's not in use.

    ENTRY:      pObject - Pointer to the meta data object.

    RETURNS:


    NOTES:


********************************************************************/

VOID
FtpMetaDataFree(
    PVOID       pObject
)
{
    PFTP_METADATA        pMD;

    pMD = (PFTP_METADATA)pObject;

    delete pMD;
}


BOOL
FTP_METADATA::HandlePrivateProperty(
    LPSTR                   pszURL,
    PIIS_SERVER_INSTANCE    pInstance,
    METADATA_GETALL_INTERNAL_RECORD  *pMDRecord,
    LPVOID                  pDataPointer,
    BUFFER                  *pBuffer,
    DWORD                   *pdwBytesUsed,
    PMETADATA_ERROR_INFO    pMDErrorInfo
    )
/*++

Routine Description:

    Handle metabase properties private to FTP service

Arguments:

    pszURL - URL of the requested object
    pInstance - FTP server instance
    pMDRecord - metadata record
    pDataPointer - pointer to metabase data
    pBuffer - Buffer available for storage space
    pdwBytesUsed - Pointer to bytes used in *pBuffer

Returns:

    BOOL  - TRUE success ( or not handled ), otherwise FALSE.

--*/
{
    return TRUE;
}

BOOL
FTP_METADATA::FinishPrivateProperties(
    BUFFER                  *pBuffer,
    DWORD                   dwBytesUsed,
    BOOL                    bSucceeded
    )
/*++

Routine Description:

    Handles completion of reading metabase properties private to FTP.

Arguments:

    pBuffer - Buffer previously used for storage space
    dwBytesUsed - bytes used in *pBuffer

Returns:

    BOOL  - TRUE success ( or not handled ), otherwise FALSE.

--*/
{
    return TRUE;
}


BOOL
USER_DATA::LookupVirtualRoot(
    IN  const CHAR * pszURL,
    OUT CHAR *       pszPath,
    OUT DWORD *      pcchDirRoot,
    OUT DWORD *      pdwAccessMask
    )
/*++

Routine Description:

    Looks up the virtual root to find the physical drive mapping.  If an
    Accept-Language header was sent by the client, we look for a virtual
    root prefixed by the language tag

Arguments:

    pstrPath - Receives physical drive path
    pszURL - URL to look for
    pcchDirRoot - Number of characters in the found physical path
    pdwMask - Access mask for the specified URL

  Returns:
    BOOL  - TRUE if success, otherwise FALSE.

--*/
{
    PFTP_METADATA       pMD;
    DWORD               dwDataSetNumber;
    PVOID               pCacheInfo;
    MB                  mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    STACK_STR(          strFullPath, MAX_PATH );
    METADATA_ERROR_INFO MDErrorInfo;
    DWORD               dwError = NO_ERROR;



    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }

    // First read the data set number, and see if we already have it
    // cached.  We don't do a full open in this case.

    if ( !strFullPath.Copy( m_pInstance->QueryMDVRPath() ) ||
         !strFullPath.Append( ( *pszURL == '/' ) ? pszURL + 1 : pszURL ) )
    {
        goto LookupVirtualRoot_Error;
    }

    if (!mb.GetDataSetNumber( strFullPath.QueryStr(),
                              &dwDataSetNumber ))
    {
        goto LookupVirtualRoot_Error;
    }

    // See if we can find a matching data set already formatted.
    pMD = (PFTP_METADATA)TsFindMetaData(dwDataSetNumber, METACACHE_FTP_SERVER_ID);

    if (pMD == NULL)
    {
        pMD = new FTP_METADATA;

        if (pMD == NULL)
        {
            goto LookupVirtualRoot_Error;
        }

        if ( !pMD->ReadMetaData( m_pInstance,
                                 &mb,
                                 (LPSTR)pszURL,
                                 &MDErrorInfo ) )
        {
            delete pMD;
            goto LookupVirtualRoot_Error;
        }

        // We were succesfull, so try and add this metadata. There is a race
        // condition where someone else could have added it while we were
        // formatting. This is OK - we'll have two cached, but they should be
        // consistent, and one of them will eventually time out. We could have
        // AddMetaData check for this, and free the new one while returning a
        // pointer to the old one if it finds one, but that isn't worthwhile
        // now.

        pCacheInfo = TsAddMetaData(pMD, FtpMetaDataFree,
                            dwDataSetNumber, METACACHE_FTP_SERVER_ID);

    }

    m_pMetaData = pMD;

    if ( m_pMetaData->QueryVrError() )
    {
        dwError =  m_pMetaData->QueryVrError();
        goto LookupVirtualRoot_Error;
    }

    //
    // Build physical path from VR_PATH & portion of URI not used to define VR_PATH
    //

    if ( pMD->BuildPhysicalPath( (LPSTR)pszURL, &strFullPath ) &&
            *pcchDirRoot > strFullPath.QueryCCH() )
    {
        memcpy( pszPath, strFullPath.QueryStr(), strFullPath.QueryCCH()+1 );
        *pcchDirRoot = strFullPath.QueryCCH();
        if ( pdwAccessMask )
        {
            *pdwAccessMask = m_pMetaData->QueryAccessPerms();
        }

        return TRUE;
    }

LookupVirtualRoot_Error:

    if (dwError == NO_ERROR) {
        //
        // best error message to send to client
        //
        dwError = ERROR_FILE_NOT_FOUND;
    }

    SetLastError( dwError );

    return FALSE;
}


BOOL
USER_DATA::BindInstanceAccessCheck(
    )
/*++

Routine Description:

    Bind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    BOOL  - TRUE if success, otherwise FALSE.

--*/
{
    if ( m_rfAccessCheck.CopyFrom( m_pInstance->QueryMetaDataRefHandler() ) )
    {
        m_acAccessCheck.BindCheckList( (LPBYTE)m_rfAccessCheck.GetPtr(), m_rfAccessCheck.GetSize() );
        return TRUE;
    }
    return FALSE;
}


VOID
USER_DATA::UnbindInstanceAccessCheck()
/*++

Routine Description:

    Unbind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_acAccessCheck.UnbindCheckList();
    m_rfAccessCheck.Reset( (IMDCOM*) g_pInetSvc->QueryMDObject() );
}


BOOL
USER_DATA::IsFileNameShort( IN LPSTR pszFile)
/*++

  Check file name beeing short or not.

  Arguments:
    pszFile   pointer to null-terminated string containing the file name

  Returns:
    TRUE if filename is short.
--*/
{
    APIERR  err;
    CHAR   szCanonPath[MAX_PATH];
    DWORD  cbSize = MAX_PATH*sizeof(CHAR);
    CHAR   szVirtualPath[MAX_PATH+1];
    DWORD  cchVirtualPath = MAX_PATH;
    BOOL   fShort;
    BOOL   fRet = FALSE;

    DBG_ASSERT( pszFile != NULL );

    //
    // Close any file we might have open now
    // N.B. There shouldn't be an open file; we're just
    // being careful here.
    //

    if (m_pOpenFileInfo) {
        DBGPRINTF(( DBG_CONTEXT,
            "WARNING!! Closing [%08x], before opening %s\n",
            pszFile
            ));
        DBG_REQUIRE( CloseFileForSend() );
    }

    //
    // Open the requested file
    //
    err = VirtualCanonicalize(szCanonPath,
        &cbSize,
        pszFile,
        AccessTypeRead,
        NULL,
        szVirtualPath,
        &cchVirtualPath);

    if( err == NO_ERROR )
    {

        if ( strchr( szCanonPath, '~' ))
        {

            err = CheckIfShortFileName( (UCHAR *) szCanonPath, TsTokenToImpHandle( QueryUserToken()), &fShort );

            if ( !err  && fShort)
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Short filename being rejected \"%s\"\n",
                    szCanonPath ));
                fRet = TRUE;

            }

        }
    }



    return fRet;
} // USER_DATA::IsFileNameShort()



DWORD
USER_DATA::CheckIfShortFileName(
    IN  CONST UCHAR * pszPath,
    IN  HANDLE        hImpersonation,
    OUT BOOL *        pfShort
    )
/*++
    Description:

        This function takes a suspected NT/Win95 short filename and checks if there's
        an equivalent long filename.  For example, c:\foobar\ABCDEF~1.ABC is the same
        as c:\foobar\abcdefghijklmnop.abc.

        NOTE: This function should be called unimpersonated - the FindFirstFile() must
        be called in the system context since most systems have traverse checking turned
        off - except for the UNC case where we must be impersonated to get network access.

    Arguments:

        pszPath - Path to check
        hImpersonation - Impersonation handle if this is a UNC path - can be NULL if not UNC
        pfShort - Set to TRUE if an equivalent long filename is found

    Returns:

        Win32 error on failure
--*/
{
    DWORD              err = NO_ERROR;
    WIN32_FIND_DATA    FindData;
    UCHAR *            psz;
    BOOL               fUNC;

    psz      = _mbschr( (UCHAR *) pszPath, '~' );
    *pfShort = FALSE;
    fUNC     = (*pszPath == '\\');

    //
    //  Loop for multiple tildas - watch for a # after the tilda
    //

    while ( psz++ )
    {
        if ( *psz >= '0' && *psz <= '9' )
        {
            UCHAR achTmp[MAX_PATH];
            UCHAR * pchEndSeg;
            UCHAR * pchBeginSeg;
            HANDLE  hFind;

            //
            //  Isolate the path up to the segment with the
            //  '~' and do the FindFirst with that path
            //

            pchEndSeg = _mbschr( psz, '\\' );

            if ( !pchEndSeg )
            {
                pchEndSeg = psz + _mbslen( psz );
            }

            //
            //  If the string is beyond MAX_PATH then we allow it through
            //

            if ( ((INT) (pchEndSeg - pszPath)) >= sizeof( achTmp ))
            {
                return NO_ERROR;
            }

            memcpy( achTmp, pszPath, (INT) (pchEndSeg - pszPath) );
            achTmp[pchEndSeg - pszPath] = '\0';

            if ( fUNC && hImpersonation )
            {
                if ( !ImpersonateLoggedOnUser( hImpersonation ))
                {
                    return GetLastError();
                }
            }

            hFind = FindFirstFile( (CHAR *) achTmp, &FindData );

            if ( fUNC && hImpersonation )
            {
                RevertToSelf();
            }

            if ( hFind == INVALID_HANDLE_VALUE )
            {
                err = GetLastError();

                DBGPRINTF(( DBG_CONTEXT,
                            "FindFirst failed!! - \"%s\", error %d\n",
                            achTmp,
                            GetLastError() ));

                //
                //  If the FindFirstFile() fails to find the file then return
                //  success - the path doesn't appear to be a valid path which
                //  is ok.
                //

                if ( err == ERROR_FILE_NOT_FOUND ||
                     err == ERROR_PATH_NOT_FOUND )
                {
                    return NO_ERROR;
                }

                return err;
            }

            DBG_REQUIRE( FindClose( hFind ));

            //
            //  Isolate the last segment of the string which should be
            //  the potential short name equivalency
            //

            pchBeginSeg = _mbsrchr( achTmp, '\\' );
            DBG_ASSERT( pchBeginSeg );
            pchBeginSeg++;

            //
            //  If the last segment doesn't match the long name then this is
            //  the short name version of the path
            //

            if ( _mbsicmp( (UCHAR *) FindData.cFileName, pchBeginSeg ))
            {
                *pfShort = TRUE;
                return NO_ERROR;
            }
        }

        psz = _mbschr( psz, '~' );
    }

    return err;
}



/******************************* End Of File *************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\gopher\gdspace.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

       gdspace.h

   Abstract:
   
       Defines the APIs used for gopher space administration.
 

   Author:

       Murali R. Krishnan    ( MuraliK )    06-Dec-1994

   Project:
   
       Gopher Space Admin  DLL

   Revision History:

--*/

# ifndef _GDSPACE_H_
# define _GDSPACE_H_

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus


/************************************************************
 *     Include Headers
 ************************************************************/

//
// Make sure you include all standard windows.h files for predefined types
// 


/***************************************************
 * NOTE: ( Dec 6, 1994)
 *  Present implementation only allows ASCII information
 *   in the tag file.
 *  The Gopher protocol does not support UNICODE as of now.
 *   hence the tag file information will live to be ASCII.
 * 
 *   Gs_ prefix is used to mean Gopher Space.
 ***************************************************/

/************************************************************
 *    Symbolic Constants
 ************************************************************/

//
// Symbolic Constants (single character) used to identify gopher object types
//  Included here for common use by server, adminUI, and gopher space admin
//  GOBJ_  Prefix used to identify Gopher OBJect
//

# define   GOBJ_TEXT          '0'         // Text Object
# define   GOBJ_DIRECTORY     '1'         // Directory listing
# define   GOBJ_ERROR         '3'         // Error object

# define   GOBJ_SEARCH        '7'         // Content Search Item
# define   GOBJ_BINARY        '9'         // Binary information

# define   GOBJ_IMAGES        ':'         // Bit Images
# define   GOBJ_MOVIES        ';'         // Movie Information
# define   GOBJ_SOUND         '<'         // Sound information

# define   GOBJ_HTML          'h'         //  HTML docs
# define   GOBJ_PC_ITEM       '5'         // this is a pc file
# define   GOBJ_GIF           'g'         // this is a gif item
# define   GOBJ_MAC_BINHEX_ITEM  '4'      // BinHex'ed Macintosh File
# define   GOBJ_TELNET        '8'         // TelNet Link

typedef   char        GOBJ_TYPE;          // Type for "gopher object type"
typedef   GOBJ_TYPE * LPGOBJ_TYPE;

/*++ 
 Following are a few unsupported Gopher Object Types:
           Type      Explanation
 >          2 A CSO phone-book server
 >          6 A Unix uuencoded file
 >          c A calendar or calendar of events
 >          i An in-line text that is not an item
 >          m A BSD format mbox file
 >          P A PDF document
 >          T A tn3270 mainframe session
 >          + A redundant server.
 >And have seen occasional (or conflicting) references for:
 >          e ????
 >          I Another kind of image file????
# define   GOBJ_TELNET        '8'         // Telnet session

--*/



# include "fsconst.h"


# define INVALID_PORT_NUMBER        ( 0)



# ifndef COMPILE_GOPHER_SERVER_DLL

//
// include following APIs only when we deal with 
//  compilation of dlls that are not part of the main gopher server dll.
//


//
//  Define an opaque handle for Gopher Tag file information
//

typedef PVOID  HGDTAG;

# define INVALID_HGDTAG_VALUE              ( NULL)


//
// Define an opaque handle for iterating thru
//  the attributes for Gopher+ Tag file
//

typedef PVOID  HGD_ATTRIB_ITERATOR;
typedef HGD_ATTRIB_ITERATOR  *   LPHGD_ATTRIB_ITERATOR;

# define INVALID_HGD_ATTRIB_ITERATOR_VALUE          ( NULL) 

HGDTAG
GsOpenTagInformation(
    IN LPCTSTR     lpszDirectory,     // directory of the file
    IN LPCTSTR     lpszFileName,      // name of the file 
    IN BOOL        fDirectory,
    IN BOOL        fCreate,           // TRUE if new file to be created
    IN DWORD       dwFileSystem
    );


DWORD
GsWriteTagInformation(
   IN OUT HGDTAG   hgdTag             // Gopher Tag handle
   );

DWORD
GsCloseTagInformation( 
    IN OUT HGDTAG  * hgdTag           // Gopher Tag handle
    );


DWORD
GsSetGopherInformation(
    IN OUT HGDTAG  hgdTag,            // Gopher Tag handle
    IN GOBJ_TYPE   gobjType,          // Type of gopher object
    IN LPCSTR      lpszFriendlyName   // friendly name of the gopher object
    );


DWORD
GsSetLinkInformation(
    IN OUT HGDTAG  hgdTag,            // Gopher Tag handle,
    IN LPCSTR      lpszSelector,      // Gopher selector or Search expression
    IN LPCSTR      lpszHostName,      // == NULL ==> current host
    IN DWORD       dwPortNumber       // == 0    ==> current server port
    );


DWORD 
GsSetAdminAttribute( 
    IN OUT HGDTAG  hgdTag,            // Gopher Tag handle
    IN LPCSTR      lpszAdminName,     // == NULL ==> current administrator
    IN LPCSTR      lpszAdminEmail     // == NULL ==> current admin's email
    );

//
// Call following API GsSetAttribute()
//       for all Gopher+ attributes, except "VIEWS" and "ADMIN"
//

DWORD
GsSetAttribute(
    IN OUT HGDTAG  hgdTag,
    IN LPCSTR      lpszAttributeName,
    IN LPCSTR      lpszAttributeValue
    );



BOOL
IsValidGopherType( IN GOBJ_TYPE   gobjType);

DWORD
GsGetGopherInformation(
    IN HGDTAG      hgdTag,           // Gopher Tag handle
    OUT LPGOBJ_TYPE lpGobjType,      // pointer to contain GOBJ_TYPE
    OUT LPSTR      lpszBuffer,       // ptr to buffer to contain friendly name
    IN OUT LPDWORD lpcbBuffer,       // ptr to location containing no. of bytes
    OUT LPBOOL     lpfLink           // return TRUE if link or search file.
    );

DWORD
GsGetLinkInformation(
    IN OUT HGDTAG  hgdTag,            // Gopher Tag handle,
    OUT LPSTR      lpszSelectorBuffer,// pointer to buffer to contain selector
    IN OUT LPDWORD lpcbSelector,      // count of bytes for selector
    OUT LPSTR      lpszHostName,      // pointer to buffer containing hostname
    IN OUT LPDWORD lpcbHostName,      // count of bytes for host name
    OUT LPDWORD    lpdwPortNumber     // server port number
    );


DWORD 
GsGetAdminAttribute( 
    IN OUT HGDTAG  hgdTag,            // Gopher Tag handle
    OUT LPSTR      lpszAdminName,     // == NULL ==> current administrator  
    IN OUT LPDWORD lpcbAdminName,     // count of bytes for admin name
    OUT LPSTR      lpszAdminEmail,    // == NULL ==> current admin's email
    IN OUT LPDWORD lpcbAdminEmail     // count of bytes for admin email
    );


//
// Call following API GsSetAttribute()
//       for all Gopher+ attributes, except "VIEWS" and "ADMIN"
//

DWORD
GsStartFindAttribute(
    IN OUT HGDTAG     hgdTag,
    OUT  LPHGD_ATTRIB_ITERATOR lphgdAttribIter
    );


DWORD
GsFindNextAttribute(
    IN OUT HGD_ATTRIB_ITERATOR hgdAttribIter,
    OUT LPSTR      lpszAttributeName,
    IN OUT LPDWORD lpcbAttributeName,
    OUT LPSTR      lpszAttributeValue,
    IN OUT LPDWORD lpcbAttributeValue
    );


DWORD
GsFindCloseAttribute(
    IN OUT LPHGD_ATTRIB_ITERATOR  lphgdAttribIter
    );



# endif // COMPILE_GOPHER_SERVER_DLL


# ifdef __cplusplus
};
# endif // __cplusplus


# endif // _GDSPACE_H_


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\gopher\client\gdadmin.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        main.c

   Abstract:
        main program to test the working of RPC APIs

   Author:

           Murali R. Krishnan    ( MuraliK )     22-Nov-1994

   Project:

          Gopher Server Admin Test Program

   Functions Exported:



   Revision History:

      21-Apr-1995    Updated configuration to remove Admin Name and Email.

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include "inetinfo.h"
# include "apiutil.h"

//
//  size of half dword in bits
//
# define HALF_DWORD_SIZE    ( sizeof(DWORD) * 8 / 2)

//
//  To Avoid overflows I multiply using two parts
//
# define LargeIntegerToDouble( li)      \
        ( ( 1 << HALF_DWORD_SIZE) * \
           (( double) (li).HighPart) * ( 1 << HALF_DWORD_SIZE) + \
          ((li).LowPart) \
        )


static LPWSTR g_lpszServerAddress = NULL;

//
// Prototypes of Functions
//

BOOL GenUsageMessage( int argc, char * argv[]);

BOOL TestGetStatistics( int argc, char * argv[]);

BOOL TestClearStatistics( int argc, char * argv[]);

BOOL TestGetAdminInfo( int argc, char * argv[]);

BOOL TestSetAdminInfo( int argc, char * argv[]);

BOOL TestInetGetAdminInfo( int argc, char * argv[]);

BOOL TestInetSetAdminInfo( int argc, char * argv[]);


//
//  The following DefineAllCommands() defines a template for all commands.
//  Format: CmdCodeName     CommandName         Function Pointer   Comments
//
//  To add addditional test commands, add just another line to the
//      given list
//  Dont touch any macros below, they are all automatically generated.
//  Always the first entry should be usage function.
//

#define  DefineAllCommands()    \
 Cmd( CmdUsage,             "usage",                GenUsageMessage,    \
        " Commands Available" )                                         \
 Cmd( CmdGetStatistics,     "getstatistics",        TestGetStatistics,  \
        " Get Statistics From Gopher Server" )                          \
 Cmd( CmdClearStatistics,   "clearstatistics",      TestClearStatistics,\
        " Clear Gopher Server Statistics" )                             \
 Cmd( CmdGetAdminInfo,      "getadmininfo",         TestGetAdminInfo,   \
        " Get Administrative Information" )                             \
 Cmd( CmdSetAdminInfo,      "setadmininfo",         TestSetAdminInfo,   \
        " Set Administrative Information for Gopher Server" )           \
 Cmd( CmdInetGetAdminInfo,      "igetadmininfo",        TestInetGetAdminInfo, \
        " Get Gopher's common Internet Administrative Information" )    \
 Cmd( CmdInetSetAdminInfo,      "isetadmininfo",        TestInetSetAdminInfo, \
        " Set Gopher's common Internet Administrative Information" )    \
 Cmd( CmdDebugFlags,        "debug",                NULL,               \
        " isetadmininfo: Set Debugging flags for the server" )          \
 Cmd( CmdPortNumber,        "port",                 NULL,               \
        " isetadmininfo: Set the port number for server")               \
 Cmd( CmdMaxConnections,    "maxconn",              NULL,               \
        " isetadmininfo: Set the max connections allowed in server")    \
 Cmd( CmdConnectionTimeout, "timeout",              NULL,               \
        " isetadmininfo: Set the Connection Timeout interval( in seconds)") \
 Cmd( CmdLogAnonymous,      "loganon",              NULL,               \
        " isetadmininfo: Set the LogAnonymous Flag")                    \
 Cmd( CmdLogNonAnonymous,   "lognonanon",           NULL,               \
        " isetadmininfo: Set the LogNonAnonymous Flag")                 \
 Cmd( CmdAnonUserName,      "anonuser",              NULL,              \
        " isetadmininfo: Set the Anonymous User Name ")                 \
  /* following are string data */   \
                                    \
 Cmd( CmdSite,              "site",                 NULL,               \
        " setadmininfo: Set the Site of the server ")                   \
 Cmd( CmdOrganization,      "organization",         NULL,               \
        " setadmininfo: Set the Organization ")                         \
 Cmd( CmdLocation,         "location",              NULL,               \
        " setadmininfo: Set the Location of the server  ")              \
 Cmd( CmdGeography,         "geography",              NULL,             \
        " setadmininfo: Set the Geography Data for server location ")   \
 Cmd( CmdLanguage,         "language",              NULL,               \
        " setadmininfo: Set the Language for server location ")         \
 Cmd( CmdCheckForWaisDb,   "checkforwaisdb",        NULL,               \
        " setadmininfo: Sets the checkfor WaisDb flag to given value ") \


// Define command codes

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)       CmdCode,

typedef enum  _CmdCodes {
    DefineAllCommands()
    maxCmdCode
} CmdCodes;

#undef Cmd

// Define the functions and array of mappings

// General command function type
typedef BOOL ( * CMDFUNC)( int argc, char * argv[]);

typedef  struct _CmdStruct {
    CmdCodes    cmdCode;
    char *      pszCmdName;
    CMDFUNC     cmdFunc;
    char *      pszCmdComments;
} CmdStruct;


// Define Prototypes of command functions
# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)    \
    BOOL CmdFunc(int argc, char * argv[]);

// Cause an expansion to generate prototypes
// DefineAllCommands()
// Automatic generation causes a problem when we have NULL in Function ptrs :(
// Let the user explicitly define the prototypes

#undef Cmd

//
// Define the global array of commands
//

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)        \
    { CmdCode, CmdName, CmdFunc, CmdComments},

static CmdStruct   g_cmds[] = {

    DefineAllCommands()
    { maxCmdCode, NULL, NULL}       // sentinel command
};

#undef Cmd



/************************************************************
 *    Functions
 ************************************************************/

BOOL
GenUsageMessage( int argc, char * argv[])
{
    CmdStruct * pCmd;

    printf( " Usage:\n %s <server-name/address> <cmd name> <cmd arguments>\n",
            argv[0]);
    for( pCmd = g_cmds; pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {
        printf( "\t%s\t%s\n", pCmd->pszCmdName, pCmd->pszCmdComments);
    }

    return ( TRUE);
} // GenUsageMessage()



static
CmdStruct * DecodeCommand( char * pszCmd)
{
    CmdStruct * pCmd;
    if ( pszCmd != NULL) {

        for( pCmd = g_cmds;
             pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {

            if ( _stricmp( pszCmd, pCmd->pszCmdName) == 0) {
                 return ( pCmd);
            }
        } // for
    }

    return ( &g_cmds[0]);      // No match found, return usage message
} // DecodeCommand()



static
LPWSTR
ConvertToUnicode( char * psz)
/*++
    Converts a given string into unicode string (after allocating buffer space)
    Returns NULL on failure. Use GetLastError() for details.
--*/
{
    LPWSTR  pszUnicode;
    int     cch;

    cch = strlen( psz) + 1;
    pszUnicode = ( LPWSTR ) malloc( cch * sizeof( WCHAR));

    if ( pszUnicode != NULL) {

       // Success. Copy the string now
       int iRet;

       iRet = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                                   psz,    cch,
                                   pszUnicode,  cch);

       if ( iRet == 0 || iRet != cch) {

            free( pszUnicode);      // failure so free the block
            pszUnicode = NULL;
       }
    } else {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    }

    return ( pszUnicode);
} // ConvertToUnicode()


static
VOID
PrintStatisticsInfo( IN LPGOPHERD_STATISTICS_INFO   pStat)
{
    if ( pStat == NULL) {

        return ;
    }

    printf( " Printing Statistics Information: \n");
    printf( "%20s = %4.3g\n", "Bytes Sent",
           LargeIntegerToDouble( pStat->TotalBytesSent));
    printf( "%20s = %4.3g\n", "Bytes Received",
           LargeIntegerToDouble(pStat->TotalBytesRecvd));
    printf( "%20s = %ld\n", "Files Sent ", pStat->TotalFilesSent);
    printf( "%20s = %ld\n", "Directory Listings",
           pStat->TotalDirectoryListings);
    printf( "%20s = %ld\n", "Searches Done ", pStat->TotalSearches);
    printf( "%20s = %ld\n", "Current Anon Users",
           pStat->CurrentAnonymousUsers);
    printf( "%20s = %ld\n", "Current NonAnon Users",
           pStat->CurrentNonAnonymousUsers);
    printf( "%20s = %ld\n", "Total Anon Users", pStat->TotalAnonymousUsers);
    printf( "%20s = %ld\n", "Total NonAnon Users",
           pStat->TotalNonAnonymousUsers);
    printf( "%20s = %ld\n", "Max Anon Users", pStat->MaxAnonymousUsers);
    printf( "%20s = %ld\n", "Max NonAnon Users", pStat->MaxNonAnonymousUsers);
    printf( "%20s = %ld\n", "Current Connections", pStat->CurrentConnections);
    printf( "%20s = %ld\n", "Total Connections", pStat->TotalConnections);
    printf( "%20s = %ld\n", "Max Connections", pStat->MaxConnections);
    printf( "%20s = %ld\n", "Connection Attempts", pStat->ConnectionAttempts);
    printf( "%20s = %ld\n", "Logon Attempts", pStat->LogonAttempts);
    printf( "%20s = %ld\n", "Aborted Attempts", pStat->AbortedAttempts);
    printf( "%20s = %ld\n", "Errored Connections", pStat->ErroredConnections);
    printf( "%20s = %ld\n", "Gopher+ Requests", pStat->GopherPlusRequests);

    return;

} // PrintStatisticsInfo()



static
VOID
PrintStatsForTime( IN LPGOPHERD_STATISTICS_INFO   pStatStart,
                   IN LPGOPHERD_STATISTICS_INFO   pStatEnd,
                   IN DWORD sInterval)
/*++
  Print the statistics information over a time interval sInterval seconds.
  Arguments:
    pStatStart  pointer to statistics information for starting sample
    pStatEnd    pointer to statistics information for ending sample
    sInterval   Time interval in seconds for the sample

  Returns:
     None

--*/
{
    LARGE_INTEGER  liDiff;

    if ( pStatStart == NULL || pStatEnd == NULL ) {

        return ;
    }

    printf( "Gopher Stats.              Time: %u seconds\n", sInterval);
    printf( "%20s\t %10s\t%10s\t%10s\n\n",
           "Item", "Start Sample", "End Sample", "Difference");

    liDiff.QuadPart = ( pStatEnd->TotalBytesSent.QuadPart -
                        pStatStart->TotalBytesSent.QuadPart);

    printf( "%20s\t %10.3g\t %10.3g\t %10.3g\n",
           "Bytes Sent",
           LargeIntegerToDouble( pStatStart->TotalBytesSent),
           LargeIntegerToDouble( pStatStart->TotalBytesSent),
           LargeIntegerToDouble( liDiff)
           );

    liDiff.QuadPart = ( pStatEnd->TotalBytesRecvd.QuadPart -
                        pStatStart->TotalBytesRecvd.QuadPart);

    printf( "%20s\t %10.3g\t %10.3g\t %10.3g\n",
           "Bytes Received",
           LargeIntegerToDouble(pStatStart->TotalBytesRecvd),
           LargeIntegerToDouble(pStatEnd->TotalBytesRecvd),
           LargeIntegerToDouble(liDiff)
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Files Sent ",
           pStatStart->TotalFilesSent,
           pStatEnd->TotalFilesSent,
           pStatEnd->TotalFilesSent - pStatStart->TotalFilesSent
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Directory Listings",
           pStatStart->TotalDirectoryListings,
           pStatEnd->TotalDirectoryListings,
           pStatEnd->TotalDirectoryListings -
           pStatStart->TotalDirectoryListings
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Searches Done ",
           pStatStart->TotalSearches,
           pStatEnd->TotalSearches,
           pStatEnd->TotalSearches - pStatStart->TotalSearches
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Current Anon Users",
           pStatStart->CurrentAnonymousUsers,
           pStatEnd->CurrentAnonymousUsers,
           pStatEnd->CurrentAnonymousUsers - pStatStart->CurrentAnonymousUsers
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Current NonAnon Users",
           pStatStart->CurrentNonAnonymousUsers,
           pStatEnd->CurrentNonAnonymousUsers,
           pStatStart->CurrentNonAnonymousUsers -
           pStatEnd->CurrentNonAnonymousUsers
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Total Anon Users",
           pStatStart->TotalAnonymousUsers,
           pStatEnd->TotalAnonymousUsers,
           pStatEnd->TotalAnonymousUsers - pStatStart->TotalAnonymousUsers
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Total NonAnon Users",
           pStatStart->TotalNonAnonymousUsers,
           pStatEnd->TotalNonAnonymousUsers,
           pStatEnd->TotalNonAnonymousUsers -pStatStart->TotalNonAnonymousUsers
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Max Anon Users",
           pStatStart->MaxAnonymousUsers,
           pStatEnd->MaxAnonymousUsers,
           pStatEnd->MaxAnonymousUsers - pStatStart->MaxAnonymousUsers
           );
    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Max NonAnon Users",
           pStatStart->MaxNonAnonymousUsers,
           pStatEnd->MaxNonAnonymousUsers,
           pStatEnd->MaxNonAnonymousUsers - pStatStart->MaxNonAnonymousUsers
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Current Connections",
           pStatStart->CurrentConnections,
           pStatEnd->CurrentConnections,
           pStatEnd->CurrentConnections - pStatStart->CurrentConnections
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Total Connections",
           pStatStart->TotalConnections,
           pStatEnd->TotalConnections,
           pStatEnd->TotalConnections - pStatStart->TotalConnections
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Max Connections",
           pStatStart->MaxConnections,
           pStatEnd->MaxConnections,
           pStatEnd->MaxConnections - pStatStart->MaxConnections
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Connection Attempts",
           pStatStart->ConnectionAttempts,
           pStatEnd->ConnectionAttempts,
           pStatEnd->ConnectionAttempts - pStatStart->ConnectionAttempts
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Logon Attempts",
           pStatStart->LogonAttempts,
           pStatEnd->LogonAttempts,
           pStatEnd->LogonAttempts - pStatStart->LogonAttempts
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Aborted Attempts",
           pStatStart->AbortedAttempts,
           pStatEnd->AbortedAttempts,
           pStatEnd->AbortedAttempts - pStatStart->AbortedAttempts
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Errored Connections",
           pStatStart->ErroredConnections,
           pStatEnd->ErroredConnections,
           pStatEnd->ErroredConnections - pStatStart->ErroredConnections
           );

    printf( "%20s\t %10ld\t %10ld\t %10ld\n",
           "Gopher+ Requests",
           pStatStart->GopherPlusRequests,
           pStatEnd->GopherPlusRequests,
           pStatEnd->GopherPlusRequests - pStatStart->GopherPlusRequests
           );

    return;

} // PrintStatisticsInfo()




BOOL
TestGetStatistics( int argc, char * argv[] )
/*++
   Gets Gopher Statistics from server and prints it.
   If the optional time information is given, then this function
   obtains the statistics, sleeps for specified time interval and then
    again obtains new statistics and prints the difference, neatly formatted.

   Arguments:
      argc = count of arguments
      argv  array of strings for command
            argv[0] = stats
            argv[1] = time interval if specified in seconds
--*/
{
    DWORD   err;
    DWORD   timeToSleep = 0;
    GOPHERD_STATISTICS_INFO     stat1;
    GOPHERD_STATISTICS_INFO  *  pStat1 = &stat1;

    if ( argc > 1 && argv[1] != NULL) {

        timeToSleep = atoi( argv[1]);
    }

    err = GdGetStatistics(  g_lpszServerAddress,
                            (LPBYTE ) pStat1);

    if ( err == NO_ERROR) {

        if ( timeToSleep <= 0) {

            PrintStatisticsInfo( pStat1);
        } else {

            GOPHERD_STATISTICS_INFO     stat2;
            GOPHERD_STATISTICS_INFO  *  pStat2 = &stat2;

            printf( "\nGopher Statistics For Time Interval %u seconds\n\n",
                   timeToSleep);

            Sleep( timeToSleep * 1000);   // sleep for the interval
            err = GdGetStatistics( g_lpszServerAddress,
                                  (LPBYTE ) pStat2);

            if ( err == NO_ERROR) {

                PrintStatsForTime( pStat1, pStat2, timeToSleep);
            }
        }
    }

    SetLastError( err);
    return ( err == NO_ERROR);
} // TestGetStatistics()



BOOL
TestClearStatistics( int argc, char * argv[])
{
    DWORD   err;

    printf( " GdClearStatistics called at: Time = %d\n",
            GetTickCount());
    err = GdClearStatistics(  g_lpszServerAddress);

    printf( " Time = %d\n",
            GetTickCount());
    printf( "Cleared the statistics Err = %d\n", err);

    SetLastError( err);
    return ( err == NO_ERROR);
} // TestClearStatistics()



static VOID
PrintAdminInformation( IN LPGOPHERD_CONFIG_INFO pConfigInfo)
{
    if ( pConfigInfo == NULL)
        return;

    printf( "\n Printing Config Information in %08x\n", pConfigInfo);
    printf( "%20s= %S\n", "Site  Name",     pConfigInfo->lpszSite);
    printf( "%20s= %S\n", "Organization",   pConfigInfo->lpszOrganization);
    printf( "%20s= %S\n", "Location",       pConfigInfo->lpszLocation);
    printf( "%20s= %S\n", "Geography",      pConfigInfo->lpszGeography);
    printf( "%20s= %S\n", "Language",       pConfigInfo->lpszLanguage);
    printf( "%20s= %d\n", "CheckForWaisDb", pConfigInfo->fCheckForWaisDb);
    printf( "%20s= %x\n",  "Debugging Flags",    pConfigInfo->dwDebugFlags);

    return;
} // PrintAdminInformation()




static BOOL
TestGetAdminInfo( int argc, char * argv[] )
{
    DWORD err;
    LPGOPHERD_CONFIG_INFO   pConfig = NULL;


    printf( " GdGetAdminInformation() called at: Time = %d\n",
            GetTickCount());

    err = GdGetAdminInformation( g_lpszServerAddress, &pConfig);

    printf( " Time = %d\n", GetTickCount());

    printf( "GdGetAdminInformation returned Error Code = %d\n", err);

    if ( err == NO_ERROR) {
        PrintAdminInformation( pConfig);
        MIDL_user_free( ( LPVOID) pConfig);
    }


    SetLastError( err);
    return ( err == NO_ERROR);
} // TestGetAdminInfo()


DWORD
SetAdminField(
    IN LPGOPHERD_CONFIG_INFO  pConfigIn,
    IN char * pszSubCmd,
    IN char * pszValue)
{
    DWORD err = NO_ERROR;
    CmdStruct * pCmd = DecodeCommand( pszSubCmd); // get command struct

    if ( pCmd == NULL) {
        // ignore invalid commands
        printf( " Invalid SubCommand for set admin info %s. Ignoring...\n",
                pszSubCmd);
        return ( ERROR_INVALID_PARAMETER);
    }

    switch ( pCmd->cmdCode) {

# if DBG
      case CmdDebugFlags:
        SetField( pConfigIn->FieldControl, GDA_DEBUG_FLAGS);
        pConfigIn->dwDebugFlags = atoi( pszValue);
        break;

# endif // DBG


      case CmdSite:
        SetField( pConfigIn->FieldControl, GDA_SITE);
        pConfigIn->lpszSite = ConvertToUnicode( pszValue);
        if ( pConfigIn->lpszSite == NULL) {

            err = GetLastError();
        }
        break;

      case CmdOrganization:
        SetField( pConfigIn->FieldControl, GDA_ORGANIZATION);
        pConfigIn->lpszOrganization = ConvertToUnicode( pszValue);
        if ( pConfigIn->lpszOrganization == NULL) {
            err = GetLastError();
        }
        break;

      case CmdLocation:
        SetField( pConfigIn->FieldControl, GDA_LOCATION);
        pConfigIn->lpszLocation = ConvertToUnicode( pszValue);
        if ( pConfigIn->lpszLocation == NULL) {
            err = GetLastError();
        }
        break;

      case CmdGeography:
        SetField( pConfigIn->FieldControl, GDA_GEOGRAPHY);
        pConfigIn->lpszGeography = ConvertToUnicode( pszValue);
        if ( pConfigIn->lpszGeography == NULL) {
            err = GetLastError();
        }
        break;

      case CmdLanguage:
        SetField( pConfigIn->FieldControl, GDA_LANGUAGE);
        pConfigIn->lpszLanguage = ConvertToUnicode( pszValue);
        if ( pConfigIn->lpszLanguage == NULL) {

            err = GetLastError();
        }
        break;

      case CmdCheckForWaisDb:
        SetField( pConfigIn->FieldControl, GDA_CHECK_FOR_WAISDB);
        pConfigIn->fCheckForWaisDb = (atoi(pszValue) != 0) ? TRUE: FALSE;
        break;

      default:
        printf( " Invalid Sub command %s for SetConfigInfo(). Ignoring.\n",
               pszSubCmd);
        err = ERROR_INVALID_PARAMETER;
        break;

    }  // switch


    return ( err);
} // SetAdminField()


static VOID
FreeBuffer( IN PVOID * ppBuffer)
{
    if ( *ppBuffer != NULL) {
        free( * ppBuffer);
        *ppBuffer = NULL;       // reset the old value
    }
    return;
} // FreeBuffer()

VOID
FreeStringsInAdminInfo( IN OUT LPGOPHERD_CONFIG_INFO pConfigInfo)
{
    FreeBuffer( (PVOID *) & pConfigInfo->lpszSite);
    FreeBuffer( (PVOID *) & pConfigInfo->lpszOrganization);
    FreeBuffer( (PVOID *) & pConfigInfo->lpszLocation);
    FreeBuffer( (PVOID *) & pConfigInfo->lpszGeography);
    FreeBuffer( (PVOID *) & pConfigInfo->lpszLanguage);
} // FreeStringsInAdminInfo()


BOOL
TestSetAdminInfo( int argc, char * argv[])
/*++
    Arguments:
        argc = count of arguments
        argv  array of strings for command
            argv[0] = setadmininfo
            argv[1] = sub function within set info for testing
            argv[2] = value for sub function
 for all information to be set, give <sub command name> <value>
--*/
{
    DWORD err = ERROR_CALL_NOT_IMPLEMENTED;
    LPGOPHERD_CONFIG_INFO * ppConfigOut = NULL;
            // config value obtained from server
    GOPHERD_CONFIG_INFO  configIn;   // config values that are set

    if ( argc < 1 || ( (argc & 0x1) != 0x1 ) ) {  // argc should be > 1 and odd

        printf( "Invalid Number of arguments for %s\n", argv[0]);
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // form the admin info block to set the information
    //
    memset( ( LPVOID) &configIn, 0, sizeof( configIn)); // init to Zeros

    // extract each field and value to set in configIn

    for( ; --argc > 1; argc -= 2) {

        if ( SetAdminField( &configIn, argv[argc - 1], argv[argc])
             != NO_ERROR)  {

            break;
        }

    } // for() to extract and set all fields

    if ( err != NO_ERROR) {
        // Now make RPC call to set the fields
        err = GdSetAdminInformation( g_lpszServerAddress,
                                     &configIn);
    }

    // Need to free all the buffers allocated for the strings
    FreeStringsInAdminInfo( &configIn);

    SetLastError( err );
    return ( err == NO_ERROR );
} // TestSetAdminInfo()





static VOID
PrintInetAdminInformation( IN LPINET_INFO_CONFIG_INFO  pConfigInfo)
{
    if ( pConfigInfo == NULL)
        return;

    printf( "\n Printing InetA Config Information in %08x\n", pConfigInfo);
    printf( "%20s= %d\n", "LogAnonymous",   pConfigInfo->fLogAnonymous);
    printf( "%20s= %d\n", "LogNonAnonymous",pConfigInfo->fLogNonAnonymous);
    printf( "%20s= %08x\n", "Authentication Flags",
           pConfigInfo->dwAuthentication);
    printf( "%20s= %d\n", "Port",           pConfigInfo->sPort);
    printf( "%20s= %d\n", "Connection Timeout",
           pConfigInfo->dwConnectionTimeout);
    printf( "%20s= %d\n",  "Max Connections",
           pConfigInfo->dwMaxConnections);
    printf( "%20s= %S\n", "AnonUserName",   pConfigInfo->lpszAnonUserName);
    printf( "%20s= %S\n", "AnonPassword",   pConfigInfo->szAnonPassword);

    //
    // IP lists and Grant lists not included now. Later.
    //

    return;
} // PrintInetAdminInformation()



static BOOL
TestInetGetAdminInfo( int argc, char * argv[] )
/*++
   Gets the configuration information using InetInfoGetAdminInformation()

--*/
{
    DWORD err;
    LPINET_INFO_CONFIG_INFO  pConfig = NULL;

    printf( " InetInfoGetAdminInformation() called at: Time = %d\n",
            GetTickCount());

    err = InetInfoGetAdminInformation( g_lpszServerAddress,
                                       INET_GOPHER,
                                       &pConfig);

    printf( "Finished at Time = %d\n", GetTickCount());
    printf( "InetInfoGetAdminInformation returned Error Code = %d\n", err);

    if ( err == NO_ERROR) {
        PrintInetAdminInformation( pConfig);
        MIDL_user_free( ( LPVOID) pConfig);
    }


    SetLastError( err);
    return ( err == NO_ERROR);
} // TestInetGetAdminInfo()


DWORD
SetInetAdminField(
    IN LPINET_INFO_CONFIG_INFO  pConfigIn,
    IN char * pszSubCmd,
    IN char * pszValue)
{
    DWORD err = NO_ERROR;
    CmdStruct * pCmd = DecodeCommand( pszSubCmd); // get command struct

    if ( pCmd == NULL) {
        // ignore invalid commands
        printf( " Invalid SubCommand for set admin info %s. Ignoring...\n",
                pszSubCmd);
        return ( ERROR_INVALID_PARAMETER);
    }

    switch ( pCmd->cmdCode) {

        case CmdPortNumber:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_PORT_NUMBER);
            pConfigIn->sPort = atoi( pszValue);
            break;

        case CmdConnectionTimeout:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_CONNECTION_TIMEOUT);
            pConfigIn->dwConnectionTimeout = atoi( pszValue);
            break;

        case CmdMaxConnections:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_MAX_CONNECTIONS);
            pConfigIn->dwMaxConnections = atoi( pszValue);
            break;

          case CmdLogAnonymous:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_LOG_ANONYMOUS);
            pConfigIn->fLogAnonymous = atoi( pszValue);
            break;

          case CmdLogNonAnonymous:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_LOG_NONANONYMOUS);
            pConfigIn->fLogNonAnonymous = atoi( pszValue);
            break;

          case CmdAnonUserName:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_ANON_USER_NAME);
            pConfigIn->lpszAnonUserName = ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszAnonUserName == NULL) {
                err = GetLastError();
            }
            break;


        default:
            printf( " Invalid Sub command %s for SetConfigInfo(). Ignoring.\n",
                    pszSubCmd);
            err = ERROR_INVALID_PARAMETER;
            break;

    }  // switch


    return ( err);
} // SetAdminField()


VOID
FreeStringsInInetConfigInfo( IN OUT LPINET_INFO_CONFIG_INFO pConfigInfo)
{
    FreeBuffer( (PVOID *) & pConfigInfo->lpszAnonUserName);

} // FreeStringsInInetConfigInfo()


BOOL
TestInetSetAdminInfo( int argc, char * argv[])
/*++
    Arguments:
        argc = count of arguments
        argv  array of strings for command
            argv[0] = setadmininfo
            argv[1] = sub function within set info for testing
            argv[2] = value for sub function
 for all information to be set, give <sub command name> <value>
--*/
{
    DWORD err = ERROR_CALL_NOT_IMPLEMENTED;
    LPINET_INFO_CONFIG_INFO  * ppConfigOut = NULL;
    INET_INFO_CONFIG_INFO  configIn;   // config values that are set

    if ( argc < 1 || ( (argc & 0x1) != 0x1 ) ) {  // argc should be > 1 and odd

        printf( "Invalid Number of arguments for %s\n", argv[0]);
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // form the admin info block to set the information
    //
    memset( ( LPVOID) &configIn, 0, sizeof( configIn)); // init to Zeros

    // extract each field and value to set in configIn

    for( ; --argc > 1; argc -= 2) {

        if ( SetInetAdminField( &configIn, argv[argc - 1], argv[argc])
             != NO_ERROR)  {

            break;
        }

    } // for() to extract and set all fields

    if ( err != NO_ERROR) {
        // Now make RPC call to set the fields
        err = InetInfoSetAdminInformation( g_lpszServerAddress,
                                           INET_GOPHER,
                                           &configIn);
    }

    // Need to free all the buffers allocated for the strings
    FreeStringsInInetConfigInfo( &configIn);

    SetLastError( err );
    return ( err == NO_ERROR );
} // TestSetInetAdminInfo()







int __cdecl
main( int argc, char * argv[])
{
    DWORD err = NO_ERROR;
    char ** ppszArgv;       // arguments for command functions
    int     cArgs;           // arg count for command functions
    char * pszCmdName;
    CmdStruct  * pCmd;
    CMDFUNC pCmdFunc = NULL;

    if ( argc < 3 || argv[1] == NULL ) {

      // Insufficient arguments
       GenUsageMessage( argc, argv);
       return ( 1);
    }

    pszCmdName = argv[2];
    if (( pCmd = DecodeCommand( pszCmdName)) == NULL || pCmd->cmdFunc == NULL) {
        printf( "Internal Error: Invalid Command %s\n", pszCmdName);
        GenUsageMessage( argc, argv);
        return ( 1);
    }

    g_lpszServerAddress = ConvertToUnicode( argv[1]);   // get server address

    cArgs = argc - 2;
    ppszArgv = argv + 2;     // position at the start of the command name

    if ( !(*pCmd->cmdFunc)( cArgs, ppszArgv)) {     // call the test function

        // Test function failed.
        printf( "Command %s failed. Error = %d\n", pszCmdName, GetLastError());
        return ( 1);
    }

    printf( " Command %s succeeded\n", pszCmdName);
    return ( 0);        // success

} // main()





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\gopher\mib\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll/obj is used.
     
   Author:

        Murali R. Krishnan    ( MuraliK )    23-Febt-1995

   Project:
       SNMP Extension agent for Gopher Service on Windows NT.

   Revision History:


   Note: 
      Most of the macros defined here are used only if DBG is set. Otherwise
         they just default to some null values, which compiler can take 
         care of.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   (  DbgOutputStderr | DbgOutputKdb)


// end_user_modifiable

/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 

# define DEBUG_SNMP_INIT                  0x00001000
# define DEBUG_SNMP_TRAP                  0x00002000
# define DEBUG_SNMP_QUERY                 0x00004000
# define DEBUG_SNMP_RESOLVE               0x00008000


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\gopher\client\gdbind.c ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        
        gdbind.c

   Abstract:
       
        Routines that use RPC bind and unbind of the client to 
         Gopher service.

   Author:

           Murali R. Krishnan    ( MuraliK )     15-Nov-1994 
   
   Project:

          Gopher Server Admin DLL

   Functions Exported:
         
        GOPHERD_IMPERSONATE_HANDLE_bind()
        GOPHERD_IMPERSONATE_HANDLE_unbind()

   Revision History:
       MuraliK   15-Nov-1995  Modified to support binding w/o Net api functions
       MuraliK   21-Dec-1995  Support binding over TCP/IP

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# define  UNICODE


# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windef.h>
# include "gd_cli.h"
# include "apiutil.h"


/************************************************************
 *    Functions 
 ************************************************************/


handle_t
GOPHERD_IMPERSONATE_HANDLE_bind(
    IN GOPHERD_IMPERSONATE_HANDLE       pszServer
    )
/*++
    
    Description:
       This function is called by Gopher service admin client stubs
        when it is necessary to create an RPC binding to the server end
        with the impersonation level of security.

    Arguments:
        pszServer   
            pointer to null-terminated string containing the name of the
            server to bind to.
   
    Returns:
        The binding handle required for the stub routine.
        If the bind is unsuccessful a NULL is returned.

--*/
{
    handle_t    hBinding = NULL;

    RPC_STATUS  rpcStatus;

    rpcStatus = RpcBindHandleForServer(&hBinding,
                                       pszServer,
                                       GOPHERD_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );

    return ( hBinding);

} // GOPHERD_IMPERSONATE_HANDLE_bind()




void
GOPHERD_IMPERSONATE_HANDLE_unbind(
    GOPHERD_IMPERSONATE_HANDLE  pszServer,
    handle_t   hBinding
    )
/*++
    Description:
        This function calls the common unbind routine shared by all services.
        This function is called by the Gopher service client stubs when it is 
         required to unbind from the server end.
    
    Arguments:
        pszServer
            pointer to a null-terminated string containing the name of server
                from which to unbind.
       
        hBinding
            handle that is to be closed by unbinding
   
    Returns:
        None
--*/
{
    UNREFERENCED_PARAMETER( pszServer);

    (VOID ) RpcBindHandleFree(& hBinding);

    return;
} // GOPHERD_IMPERSONATE_HANDLE_unbind()



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\gopher\mib\main.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    main.c

Abstract:

    SNMP Extension Agent for Gopher Service on Windows NT.

Created:

  MuraliK   22-Feb-1995

Revision History:

--*/

/************************************************************
 *   Include Headers
 ************************************************************/

# include "mib.h"

# include "dbgutil.h"

/************************************************************
 *   Variable Definitions
 ************************************************************/

//
// Definition of the MIB objects
//

//
//  The InternetServer section of the OID tree is organized as follows:
//
//      iso(1)
//          org(3)
//              dod(6)
//                  internet(1)
//                      private(4)
//                          enterprises(1)
//                              microsoft(311)
//                                  software(1)
//                                      InternetServer(7)
//                                          InetSrvCommon(1)
//                                              InetSrvStatistics(1)
//                                          FtpServer(2)
//                                              FtpStatistics(1)
//                                          W3Server(3)
//                                              W3Statistics(1)
//                                          GopherServer(4)
//                                              GopherStatistics(1)
//

static UINT   sg_rguiPrefix[] =  { 1, 3, 6, 1, 4, 1, 311, 1, 7, 4};
static AsnObjectIdentifier sg_MibOidPrefix =
                      OID_FROM_UINT_ARRAY( sg_rguiPrefix);

# define GOPHER_PREFIX_OID_LENGTH    ( GET_OID_LENGTH( sg_MibOidPrefix))

# define GOPHER_STATISTICS_OID_SUFFIX            ( 1)


//
// Following is the global description of all MIB Entries ( Mibe s) for
//   Gopher Service.
// Definition appears as:
//  Mibe( MIB Entry Name, Index in MIB Block, GopherStatisticsField)
//
//   Incidentally, MIB Entry suffix coincides with the entry name in OID Tree
//
//  Any New MIB should be added here. and dont change use of after this defn.
//

# define ALL_MIB_ENTRIES()    \
Mibe( TotalBytesSent_HighWord,     1,    TotalBytesSent.HighPart) \
Mibe( TotalBytesSent_LowWord,      2,    TotalBytesSent.LowPart)  \
Mibe( TotalBytesReceived_HighWord, 3,    TotalBytesRecvd.HighPart)\
Mibe( TotalBytesReceived_LowWord,  4,    TotalBytesRecvd.LowPart) \
Mibe( TotalFilesSent,              5,    TotalFilesSent)          \
Mibe( TotalDirectorySent,          6,    TotalDirectoryListings)  \
Mibe( TotalSearchesSent,           7,    TotalSearches)           \
Mibe( CurrentAnonymousUsers,       8,    CurrentAnonymousUsers)   \
Mibe( CurrentNonAnonymousUsers,    9,    CurrentNonAnonymousUsers)\
Mibe( TotalAnonymousUsers,         10,   TotalAnonymousUsers)     \
Mibe( TotalNonAnonymousUsers,      11,   TotalNonAnonymousUsers)  \
Mibe( MaxAnonymousUsers,           12,   MaxAnonymousUsers)       \
Mibe( MaxNonAnonymousUsers,        13,   MaxNonAnonymousUsers)    \
Mibe( CurrentConnections,          14,   CurrentConnections)      \
Mibe( MaxConnections,              15,   MaxConnections)          \
Mibe( ConnectionAttempts,          16,   ConnectionAttempts)      \
Mibe( LogonAttempts,               17,   LogonAttempts)           \
Mibe( AbortedAttempts,             18,   AbortedAttempts)         \



//
// Individual OID Definitions.
//   All Leaf variables should have a zero appended to their OID to indicate
//   that it is the only instance of this variable and that it exists.
//  Declare just the id's starting from next to the prefix given above.
//


//
// Few Convenience Macros for MIB entries addition.
//

# define MIB_VAR_NAME( NameSuffix)       MIB_ ## NameSuffix

# define DEFINE_MIBOID( NameSuffix, uiArray)   \
           UINT MIB_VAR_NAME( NameSuffix)[] = uiArray

# define DEFINE_MIBOID_LEAF( NameSuffix, NodeNumber) \
           UINT MIB_VAR_NAME( NameSuffix)[] = \
                          { GOPHER_STATISTICS_OID_SUFFIX, ( NodeNumber), 0 }

//
// Define all the OIDs. First define the higher level node and then leaves.
//
DEFINE_MIBOID( Statistics,     { GOPHER_STATISTICS_OID_SUFFIX} );

//
//  Define the Leaf OIDs.
//
# define Mibe( NameSuffix, Index, FieldName)  \
     DEFINE_MIBOID_LEAF( NameSuffix, Index);

//
// Expand the macro ALL_MIB_ENTRIES to obtain definitions of MIB Leafs.
//
ALL_MIB_ENTRIES()

# undef Mibe


//
//  MIB Variable definition
//

//
// Define Mibe()  to be for variable definitions of counters.
//  Note that the comma is appearing before a new counter name. It is used
//   for structure initialization.
//

# define OFFSET_IN_GOPHER_STATISTICS( Field)    \
     FIELD_OFFSET( GOPHERD_STATISTICS_INFO,   Field)

# define Mibe( NameSuffix, Index, Field)        \
     , MIB_COUNTER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( NameSuffix)), \
                    OFFSET_IN_GOPHER_STATISTICS(Field),              \
                    MibStatisticsWorker)

static MIB_ENTRY  sg_rgGopherMib[] = {

    //
    // Statistics
    //

    MIB_ENTRY_HEADER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( Statistics)))
    ALL_MIB_ENTRIES()
};

# undef Mibe




static MIB_ENTRIES  sg_GopherMibs =
  {
    &sg_MibOidPrefix,
    ( sizeof( sg_rgGopherMib) / sizeof( MIB_ENTRY)),
    sg_rgGopherMib
  };



DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();





/************************************************************
 *    Functions
 ************************************************************/


BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    Gopher MIB DLL. It initialises local variables and prepares the
    interface for the process to use SNMP Extension Agents for Gopher service.

 Messages            Actions

    ProcessAttach        Initializes winsock and data structures.
                          It fails if winsock has not already been started.

    ProcessDetach        Cleans up local data structures and disconnects from
                         winsock.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  BOOL    fReturn = TRUE;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH: {

        //
        // Initialize various modules
        //

        OutputDebugString( "Initialized Gopher MIB Module\n");
        break;
    } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH: {

       //
       // Only cleanup when we are called because of a FreeLibrary().
       //  i.e., when lpvContext == NULL
       // If we are called because of a process termination, dont free anything
       //   the system will free resources and memory for us.
       //


       OutputDebugString( "Quitting the Gopher Mib DLL\n");

       if ( lpvContext == NULL) {

           //
           // Code to be executed on successful termination
           //

           DELETE_DEBUG_PRINT_OBJECT();
       }

       break;
   } /* case DLL_PROCESS_DETACH */

   default:
       break;
  }    /* switch */

  return ( fReturn);
}  /* DllLibMain() */





/************************************************************
 *  Entry Points of SNMP Extension DLL For Gopher Service
 ************************************************************/

//
//  Extension Agent DLLs need access to elapsed time agent has been active.
//  This is implemented by initializing the Extension Agent with a time zero
//  reference, and allowing the agent to compute elapsed time by subtracting
//  the time zero reference from the current system time.  This example
//  Extension Agent implements this reference with dwTimeZero.
//

DWORD dwTimeZero = 0;




BOOL
SnmpExtensionInit(
    IN  DWORD                 dwTimeZeroReference,
    OUT HANDLE              * phPollForTrapEvent,
    OUT AsnObjectIdentifier * pAsnOidSupportedView
    )
/*++
  Description:
     The Extension Agent DLLs provide this entry point SnmpExtensionInit()
     to co-ordinate the initializations of the extension agent and the
     extendible  agent.
     The Extendible agent provides extension agent with a time zero reference.
     The Extension Agent provides Extendible agent with an Event Handle
         for communicating occurences of traps.
     The Extension Agent also provides Extendible agent with an ObjectId
         representing the root of the MIB structure
         that it (extension) supports.

  Arguments:
     dwTimeZeroReference    DWORD containing the Time Zero Reference for sync.
     phPollForTrapEvent     pointer to handle which on successful return
                             may contain an event handle to be polled for
                             traps.
     pAsnOidSupportedView   pointer to ASN ( Abstract Syntax Notation OID)
                             that contains the oid representing root of the
                             MIB structure.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{

    CREATE_DEBUG_PRINT_OBJECT( "gdmib");
    SET_DEBUG_FLAGS( DEBUG_SNMP_RESOLVE);    // enable flags if needed.

    IF_DEBUG( SNMP_INIT) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Entering SnmpExtensionInit( %u, %08x, %08x)\n",
                    dwTimeZeroReference,
                    phPollForTrapEvent,
                    pAsnOidSupportedView));
    }


    //
    //  Record the time reference provided by the Extendible Agent.
    //

    dwTimeZero = dwTimeZeroReference;

    //
    //  Indicate the MIB view supported by this Extension Agent, an object
    //  identifier representing the sub root of the MIB that is supported.
    //

    *pAsnOidSupportedView = sg_MibOidPrefix; // NOTE!  structure copy

    //
    // Though the following is a handle, dont use INVALID_HANDLE_VALUE ( -1)
    //  because that constant is only for few people ( Win32). But all through
    //  NT invalid handle value is NULL ( 0).
    //

    *phPollForTrapEvent = NULL;

    //
    //  Indicate that Extension Agent initialization was sucessfull.
    //

    return ( TRUE);

}   // SnmpExtensionInit()




BOOL
SnmpExtensionTrap(
    OUT AsnObjectIdentifier * pAsnOidEnterprise,
    OUT AsnInteger          * pAsniGenericTrap,
    OUT AsnInteger          * pAsniSpecificTrap,
    OUT AsnTimeticks        * pAsnTimeStamp,
    OUT RFC1157VarBindList  * pRfcVariableBindings
    )
/*++
  Description:
     This function is used to communicate traps to the Extendible Agent.
     The Extendible Agent will invoke this entry point when the trap event
      ( supplied at the initialization time) is asserted, which indicates
      that zero or more traps had occured.
     The Extendible agent will repeatedly query this function till this
      function returns FALSE.

  Arguments:
    pAsnOidEnterprise      pointer to ASN OID for Enterprise, indicating
                             original enterprise generating trap.
    pAsniGenericTrap       pointer to ASN Integer which on return will
                             contain the indication of the generic trap.
    pAsniSpecificTrap      pointer to ASN Integer which on return will
                             contain the specific trap generated.
    pAsnTimeStamp          pointer to ASN containing the received Time-Stamp.
    pRfcVariableBindings   pointer to RFC 1157 compliant variable bindings.


  Returns:
    TRUE if success and there are more traps to be queried.
    FALSE if all traps are answered and work done.

--*/
{

    IF_DEBUG( SNMP_TRAP) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering SnmpExtensionTrap( pOidE=%08x, pGenTrap=%08x,"
                    " pSpecificTrap = %08x, pTimeStamp=%08x, pVars=%08x)\n",
                    pAsnOidEnterprise,
                    pAsniGenericTrap,
                    pAsniSpecificTrap,
                    pAsnTimeStamp,
                    pRfcVariableBindings));
    }

    //
    //  We don't support traps (yet).
    //

    return ( FALSE);

}   // SnmpExtensionTrap()





BOOL
SnmpExtensionQuery(
    IN BYTE                     bRequestType,
    IN OUT RFC1157VarBindList * pRfcVariableBindings,
    OUT AsnInteger         *    pAsniErrorStatus,
    OUT AsnInteger         *    pAsniErrorIndex
    )
/*++
  Description:
    This function is called by Extendible Agent to resolve the SNMP requests
    for queries on MIB Variables in the Extension Agent's supported MIB view.
    ( which was supplied at initialization time).
    The Request Type is GET, GETNEXT, and SET.

  Arguments:
    bRequestType    byte containing the type of request.
                    It can be one of
                     ASN_RFC1157_GETREQUEST
                     ASN_RFC1157_GETNEXTREQUEST
                     ASN_RFC1157_SETREQUEST

    pRfcVariableBindings
                   pointer to RFC 1157 compliant variable bindings.

    pAsniErrorStatus
                   pointer to ASN Integer for Error Status

    pAsniErrorIndex
                  pointer to ASN INteger giving the index for error.

  Returns:
    TRUE on success and FALSE on failure.
--*/

{
    LPGOPHERD_STATISTICS_INFO  pStatistics;
    NET_API_STATUS     Status;


    IF_DEBUG( SNMP_QUERY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering SnmpExtensionQuery( Req=0x%x, pVars=%08x,"
                    " pAsniError=%08x, pAsniIndex=%08x).\n",
                    bRequestType, pRfcVariableBindings,
                    pAsniErrorStatus, pAsniErrorIndex));
    }


    //
    //  Try to query the statistics now so we'll have a consitent
    //  view across all variable bindings.
    //

    Status = GdQueryStatistics2(
                        NULL,                    // pszServer
                        0,
                        INET_INSTANCE_GLOBAL,
                        0,
                        (LPBYTE* ) &pStatistics );

    if ( Status != NO_ERROR) {
      return ( SNMP_ERRORSTATUS_GENERR);
    }

    //
    //  Status Errors not checked for  here!
    //  Reason:
    //    If the verb is GET_NEXT beyond the block we support,
    //           then there is no need to worry about the error at all.
    //    If the verb is GET within the block, it will get NULL value
    //           ( due the memset() done above).
    //

    try
    {
        //
        //  Iterate through the variable bindings list to resolve individual
        //  variable bindings.
        //

        RFC1157VarBind * pVarBinding;

        for( pVarBinding = pRfcVariableBindings->list;
            pVarBinding < ( pRfcVariableBindings->list +
                            pRfcVariableBindings->len);
            pVarBinding++ ) {

            *pAsniErrorStatus = ResolveVarBinding( pVarBinding,
                                                  bRequestType,
                                                  pStatistics,
                                                  &sg_GopherMibs);

            //
            //  Test and handle case where Get Next past end of MIB view
            //  supported by this Extension Agent occurs.  Special
            //  processing is required to communicate this situation to
            //  the Extendible Agent so it can take appropriate action,
            //  possibly querying other Extension Agents.
            //

            if(( *pAsniErrorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ) &&
               ( bRequestType == MIB_GETNEXT ) ) {

                IF_DEBUG( SNMP_QUERY) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                "At the End of Mib View for this Agent."
                                "Incrementing the variable to next block.\n"));
                }

                *pAsniErrorStatus = SNMP_ERRORSTATUS_NOERROR;

                //
                //  Modify variable binding of such variables so the OID
                //  points just outside the MIB view supported by this
                //  Extension Agent.  The Extendible Agent tests for this,
                //  and takes appropriate action.
                //

                SNMP_oidfree( &pVarBinding->name );
                SNMP_oidcpy( &pVarBinding->name, &sg_MibOidPrefix);
                pVarBinding->name.ids[ GOPHER_PREFIX_OID_LENGTH - 1]++;
            }

            //
            //  If an error was indicated, communicate error status and error
            //  index to the Extendible Agent.  The Extendible Agent will
            //  ensure that the origional variable bindings are returned in
            //  the response packet.

            *pAsniErrorIndex =
              (( *pAsniErrorStatus != SNMP_ERRORSTATUS_NOERROR ) ?
               (( pVarBinding - pRfcVariableBindings->list) + 1) : 0);

        } // for

    } // try
    except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  For now do nothing.
        //

        IF_DEBUG( SNMP_QUERY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Exception occured while resolving "
                        " SnmpExtensionQuery()"));
        }

    }


    IF_DEBUG( SNMP_QUERY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Returning from GophMib::Query() with "
                    " Error Status = %u. Error Index = %u.\n",
                    *pAsniErrorStatus,
                    *pAsniErrorIndex));
    }

    return ( SNMPAPI_NOERROR);
}   // SnmpExtensionQuery()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\gopher\mib\mib.c ===
/*++  BUILD Version: 0001   // Increment this if a change has global effects.

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :
 
      mib.c 

   Abstract:

      This defines Auxiliary functions for defining an SNMP Extension Agent 
         for collecting and querying Statistical information.

   Author:

       Murali R. Krishnan    ( MuraliK )     23-Feb-1995 

   Environment:
    
       User Mode -- Win32
       
   Project:

       SNMP Extension DLL for Gopher Service DLL

   Functions Exported:

     UINT  ResolveVarBinding();
     UINT  MibStatisticsWorker();
   
   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "mib.h"

# include "dbgutil.h"

static UINT
MibLeafFunction( 
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  );

static UINT 
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics
  );


static VOID
PrintAsnObjectIdentifier( IN char * pszOidDescription,
                          IN AsnObjectIdentifier * pAsno)
{

# if DBG

    UINT len = pAsno->idLength;
    UINT i;

    DBG_ASSERT( pAsno != NULL);

    DBGPRINTF( ( DBG_CONTEXT,
                "Printing Oid %s = %08x. Length = %u.\n",
                pszOidDescription,
                pAsno, len));

    for(i = 0; i < len; i++) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "AsnOid[ %u] = %u\n",
                    i, pAsno->ids[i]));
    }

# endif // DBG

    return;
} // PrintAsnObjectIdentifier()




/************************************************************
 *    Functions 
 ************************************************************/

UINT
ResolveVarBinding( 
   IN OUT RFC1157VarBind   * pRfcVarBinding,
   IN BYTE                   pduAction,
   IN LPVOID                 pStatistics,
   IN LPMIB_ENTRIES          pMibEntries
  )
/*++
  Description:
    This function resolves a single variable binding. Modifies the variable
       on a GET or a GET-NEXT.

  Arguments:
     pRfcVarBinding    pointer to RFC Variable Bindings
     pduAction      Protocol Data Unit Action specified.
     pStatistics    pointer to statisitcs data structure containing 
                      values of counter data.
     pMibEntries    pointer to MIB_ENTRIES context information
                      which contains prefix, array of MIB_ENTRIES and 
                      count of the entries.
  Returns:
    Standard PDU error codes.

  Note:
--*/
{
    AsnObjectIdentifier  AsnTempOid;
    LPMIB_ENTRY  pMibScan;
    UINT         pduResult = SNMP_ERRORSTATUS_NOERROR;
    LPMIB_ENTRY pMibUpperBound = 
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // Search for the variable binding name in the mib.
    //

    IF_DEBUG( SNMP_RESOLVE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ResolveVarBinding( Var=%08x, Action=%x) called.\n",
                    pRfcVarBinding, pduAction));
        
        PrintAsnObjectIdentifier( " Variable to Resolve",
                                 &pRfcVarBinding->name);
    }

    for( pMibScan = pMibEntries->prgMibEntry; 
        pMibScan < pMibUpperBound;
        pMibScan++) {

        int iCmpResult;

        //
        // Create a fully qualified OID for the current item in the MIB.
        //  and use it for comparing against variable to be resolved.
        //
        
        SNMP_oidcpy( &AsnTempOid, pMibEntries->pOidPrefix);
        SNMP_oidappend( &AsnTempOid, &pMibScan->asnOid);
        
        iCmpResult = SNMP_oidcmp( &pRfcVarBinding->name, &AsnTempOid);
        SNMP_oidfree( &AsnTempOid);

        IF_DEBUG( SNMP_RESOLVE) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " Comparing with suffix Oid  %08x yields %d\n",
                        &pMibScan->asnOid, iCmpResult));
            PrintAsnObjectIdentifier( " StatisticsSuffix", 
                                      &pMibScan->asnOid);
        }

        if ( iCmpResult == 0) {
            
            // 
            // Found a match. Stop the search and process.
            //

            break;
            
        } else 
          if ( iCmpResult < 0) {

              //
              // This could be the OID of a leaf ( withoug a trailing 0) or
              //  it could contain an invalid OID ( between valid OIDs).
              //

              if ( pduAction == MIB_GETNEXT) {
               
                  //
                  // Advance the variable binding to next entry
                  //
                  SNMP_oidfree( &pRfcVarBinding->name);
                  SNMP_oidcpy( &pRfcVarBinding->name, 
                                pMibEntries->pOidPrefix);
                  SNMP_oidappend( &pRfcVarBinding->name, &pMibScan->asnOid);
                  
                  if ( ( pMibScan->bType != ASN_RFC1155_OPAQUE) &&
                       ( pMibScan->bType != ASN_SEQUENCE)) {

                      pduAction = MIB_GET;
                  }

              } else {

                  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
              }
              
              //
              // Stop and process the appropriate entry.
              //

              break;
          } // ( iCmpResult < 0)
        
    } // for
    

    if ( pMibScan >= pMibUpperBound) {

        pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    }
    
    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) {

        //
        // A match is found or further processing is required.
        //
        
        DBG_ASSERT( pMibScan < pMibUpperBound);
        if ( pMibScan->pMibFunc == NULL) {
            
            //
            // This happens only if the match is for Group OID
            //
            
            pduResult = ( ( pduAction != MIB_GETNEXT) ?
                       SNMP_ERRORSTATUS_NOSUCHNAME:
                         MibGetNextVar( pRfcVarBinding,
                                       pMibScan,
                                       pMibEntries,
                                       pStatistics));
        } else {
            
            pduResult = ( pMibScan->pMibFunc) ( pRfcVarBinding,
                                               pduAction, 
                                               pMibScan,
                                               pMibEntries,
                                               pStatistics);
        }
    }


    IF_DEBUG( SNMP_RESOLVE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ResolveVarBinding returns %u.\n",
                    pduResult));
    }
    
    return ( pduResult);

} // ResolveVarBinding()






UINT 
MibStatisticsWorker( 
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT   pduResult = SNMP_ERRORSTATUS_NOERROR; 
                 // default indicating action to be done at end of switch

    switch( pduAction) {

      case MIB_SET:
      case MIB_GETNEXT:
        
        // action is performed at the end of switch statement.
        break;


      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  If no statistics do no action.
        //  If this is the header field ( non-leaf) do no action
        //   Otherwise, perform action as if this is the leaf node.
        //

        if ( pStatistics == NULL || pMibeCurrent->lFieldOffset == -1) {

            pduResult = SNMP_ERRORSTATUS_GENERR;
        } 

        // Action on this node is performed at the end of the switch statement.
        break;

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch()

    
    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) {

        //
        // Use the generic leaf function to perform the action specified.
        //
        pduResult = MibLeafFunction( pRfcVarBinding, pduAction, pMibeCurrent,
                                    pMibEntries, pStatistics);
    }
    
    return ( pduResult);
    
} // MibStatisticsWorker()




static UINT
MibLeafFunction( 
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics
    and that this is a leaf node of the MIB tree.
  This is a generic function for leaf nodes.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;  // default is error value.

    switch( pduAction ) {

      case MIB_GETNEXT:
        
        //
        //  Determine if we're within the range and not at the end.
        //  If not within the range the above default pduResult == NOSUCHNAME
        //         is the required error message.
        //
        
        if ( ( pMibeCurrent >= pMibEntries->prgMibEntry) &&
             ( pMibeCurrent < 
              ( pMibEntries->prgMibEntry + pMibEntries->cMibEntries))) {

            pduResult = MibGetNextVar( pRfcVarBinding, 
                                      pMibeCurrent, 
                                      pMibEntries,
                                      pStatistics);
        }

        break;
        
      case MIB_GETFIRST:
      case MIB_GET:
        
        //
        //  Make sure that this variable's ACCESS is GET'able.
        //  If the access prohibits from GETting it, report error as
        //    NOSUCHNAME ( default value of pduResult in initialization above)
        //
        
        if(( pMibeCurrent->uiAccess == MIB_ACCESS_READ ) ||
           ( pMibeCurrent->uiAccess == MIB_ACCESS_READWRITE ) ) {
            
            DWORD  dwValue;
            
            //
            //  Setup pRfcVarBinding's return value.
            //
            
            DBG_ASSERT( pStatistics != NULL);

            pRfcVarBinding->value.asnType = pMibeCurrent->bType;
            dwValue = *( (LPDWORD )((LPBYTE )pStatistics +
                                    pMibeCurrent->lFieldOffset));

            pduResult = SNMP_ERRORSTATUS_NOERROR;  // we found a value.

            switch( pMibeCurrent->bType)  {
                
              case ASN_RFC1155_GAUGE:
                pRfcVarBinding->value.asnValue.gauge = (AsnGauge ) dwValue;
                break;
                
              case ASN_RFC1155_COUNTER:
                pRfcVarBinding->value.asnValue.counter = (AsnCounter ) dwValue;
                break;
                
              case ASN_INTEGER:
                pRfcVarBinding->value.asnValue.number = (AsnInteger ) dwValue;
                break;
                
              case ASN_RFC1155_IPADDRESS:
              case ASN_OCTETSTRING:
                //
                //  Not supported for this MIB (yet).
                //  Fall through to indicate generic error.
                //
                
              default:
                
                //
                // Sorry! Type in Mibe does not suit our purpose. 
                //   Indicate generic error.
                //
                pduResult = SNMP_ERRORSTATUS_GENERR;
                break;
            } // innner switch
            
        } // if ( valid read access) 

        break;
        
      case MIB_SET:
        
        //
        //  We don't support settable variables (yet).
        //   Fall through for error.
        //
        
      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch ( pduAction)
    

    return ( pduResult);

} // MibLeafFunction()





static UINT 
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics)
/*++
  Description:
     This function sets the binding variable to iterate to the next variable.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.

  Returns:
     PDU Error Codes.
--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    LPMIB_ENTRY pMibUpperBound = 
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // If within the range of MIB ENTRIES process.
    //

    if ( pMibeCurrent >= pMibEntries->prgMibEntry) {

        //
        //  Scan through the remaining MIB Entries
        //

        LPMIB_ENTRY  pMibeScan;

        for( pMibeScan = pMibeCurrent+1; 
             pMibeScan < pMibUpperBound;
             pMibeScan++ ) {

            //
            // Setup variable bindings for the next MIB variable
            //
            
            SNMP_oidfree( &pRfcVarBinding->name);
            SNMP_oidcpy( &pRfcVarBinding->name, pMibEntries->pOidPrefix);
            SNMP_oidappend( &pRfcVarBinding->name, &pMibeScan->asnOid);

            //
            //  If the function pointer is not NULL and the type of the MIB
            //  variable is anything but OPAQUE, then call the function to
            //  process the MIB variable.
            //
            
            if(( pMibeScan->pMibFunc != NULL ) &&
               ( pMibeScan->bType    != ASN_RFC1155_OPAQUE ) ) {
                
                pduResult = ( pMibeScan->pMibFunc)( pRfcVarBinding,
                                                   MIB_GETFIRST,
                                                   pMibeScan,
                                                   pMibEntries,
                                                   pStatistics);
                break;
            }

            //
            // On failure in the scan, pduResult will have default value
            //    as initialized above in declaration.
            //

        } // for
    } 

    return ( pduResult);

} // MibGetNextVar()   

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\gopher\client\gdstubs.c ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        
        gdstubs.c

   Abstract:
        Client Stubs for RPC API for Gopher server

   Author:

           Murali R. Krishnan    ( MuraliK )     16-Nov-1994 
   
   Project:

          Gopher Server Admin DLL

   Functions Exported:

        DWORD   GdGetAdminInformation( 
                    IN      LPWSTR       pszServer  OPTIONAL,
                    OUT     LPGOPHERD_CONFIG_INFO * ppConfigInfo)

        DWORD   GdSetAdminInformation(
                    IN      LPWSTR       pszServer OPTIONAL,
                    IN      LPGOPHERD_CONFIG_INFO pConfigInfo)


        DWORD   GdEnumerateUsers(
                    IN      LPWSTR      pszServer OPTIONAL,
                    OUT     LPDWORD     lpnEntriesRead,
                    OUT     LPGOPHERD_USER_INFO * lpUserBuffer)

        DWORD   GdDisconnectUser(
                    IN      LPWSTR      pszServer  OPTIONAL,
                    IN      DWORD       dwIdUser)

        DWORD   GdGetStatistics(
                    IN      LPWSTR      pszServer  OPTIONAL,
                    OUT     LPBYTE      lpStatBuffer)


        DWORD   GdClearStatistics(
                    IN      LPWSTR      pszServer  OPTIONAL)

   Revision History:

   --*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include "gd_cli.h"

/************************************************************
 *    Functions 
 ************************************************************/


DWORD
NET_API_FUNCTION
GdGetAdminInformation( 
    IN      LPWSTR       pszServer  OPTIONAL,
    OUT     LPGOPHERD_CONFIG_INFO * ppConfigInfo
    )
{

    DWORD   status;

    RpcTryExcept {

        //
        // Try the RPC call
        //
        status = R_GdGetAdminInformation( 
                    pszServer,
                    ppConfigInfo);
    }
    RpcExcept (1) {

        status = RpcExceptionCode();
    }

    RpcEndExcept

    return ( status);

} // GdGetAdminInformation()





DWORD
NET_API_FUNCTION
GdSetAdminInformation(
    IN      LPWSTR       pszServer OPTIONAL,
    IN      LPGOPHERD_CONFIG_INFO pConfigInfo
    )
{

    DWORD   status;

    RpcTryExcept {

        //
        // Try the RPC call
        //
        status = R_GdSetAdminInformation( 
                    pszServer,
                    pConfigInfo);
    }
    RpcExcept (1) {

        status = RpcExceptionCode();
    }

    RpcEndExcept

    return ( status);

} // GdSetAdminInformation()




DWORD
NET_API_FUNCTION
GdEnumerateUsers(
    IN      LPWSTR      pszServer OPTIONAL,
    OUT     LPDWORD     lpnEntriesRead,
    OUT     LPGOPHERD_USER_INFO * lpUserBuffer
    )
{
    DWORD status;
    GOPHERD_USER_ENUM_STRUCT  gdUsers;

    RpcTryFinally {

        status = R_GdEnumerateUsers( 
                    pszServer,
                    &gdUsers
                    );
        *lpnEntriesRead  = gdUsers.dwEntriesRead;
        *lpUserBuffer = gdUsers.lpUsers;
    }
    RpcExcept( 1) {

        status = RpcExceptionCode();

    }
    RpcEndExcept

    return ( status);

} // GdEnumerateUsers()





DWORD
NET_API_FUNCTION
GdDisconnectUser(
    IN      LPWSTR      pszServer  OPTIONAL,
    IN      DWORD       dwIdUser
    )
{
    DWORD status;
 
    RpcTryFinally {

        status = R_GdDisconnectUser( 
                    pszServer,
                    dwIdUser
                    );
    }
    RpcExcept( 1) {

        status = RpcExceptionCode();

    }
    RpcEndExcept

    return ( status);
} // GdDisconnectUser()




DWORD
NET_API_FUNCTION
GdGetStatistics(
    IN      LPWSTR      pszServer  OPTIONAL,
    OUT     LPBYTE      lpStatBuffer        // pass LPGOPHERD_STATISTICS_INFO
    )
{
    DWORD status;
 
    RpcTryFinally {

        status = R_GdGetStatistics( 
                    pszServer,
                    ( LPGOPHERD_STATISTICS_INFO ) lpStatBuffer
                    );
    }
    RpcExcept( 1) {

        status = RpcExceptionCode();

    }
    RpcEndExcept

    return ( status);
} // GdGetStatistics()




DWORD
NET_API_FUNCTION
GdClearStatistics(
    IN      LPWSTR      pszServer  OPTIONAL
    )
{
    DWORD status;
 
    RpcTryFinally {

        status = R_GdClearStatistics( 
                    pszServer
                    );
    }
    RpcExcept( 1) {

        status = RpcExceptionCode();

    }
    RpcEndExcept

    return ( status);
} // GdClearStatistics()




/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\gopher\mib\mib.h ===
/*++  BUILD Version: 001   // Increment this if a change has global effects

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.h

   Abstract:

     Generic Macros and Functions for SNMP Extension Agent for
       gathering statistics information for Internet Services on NT.

   Author:

       Murali R. Krishnan    ( MuraliK )    22-Feb-1995

   Environment:

      User Mode -- Win32

   Project:

      Gopher Server SNMP MIB DLL

   Revision History:

--*/

# ifndef _MIB_H_
# define _MIB_H_

/************************************************************
 *     Include Headers
 ************************************************************/

#include <windows.h>
#include <snmp.h>

#include <lm.h>
#include <iisinfo.h>


/************************************************************
 *    Symbolic Constants
 ************************************************************/

//
//  MIB function actions.
//

#define MIB_GET         ( ASN_RFC1157_GETREQUEST)
#define MIB_SET         ( ASN_RFC1157_SETREQUEST)
#define MIB_GETNEXT     ( ASN_RFC1157_GETNEXTREQUEST)
#define MIB_GETFIRST    ( ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0 )


//
//  MIB Variable access privileges.
//

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS           3



/************************************************************
 *   Type Definitions
 ************************************************************/


typedef UINT ( * LPMIBFUNC)(
                            RFC1157VarBind    *  pRfcVarBind,
                            UINT                 Action,
                            struct _MIB_ENTRY *  pMibeCurrent,
                            struct _MIB_ENTRIES* pMibEntries,
                            LPVOID               pStatistics
                            );


typedef struct _MIB_ENTRY  {

    AsnObjectIdentifier   asnOid;       // OID for mib variable
    LONG                  lFieldOffset; // filed offset
    UINT                  uiAccess;     // type of accesss( R, W, R/W, None)
    LPMIBFUNC             pMibFunc;     // ptr to function managing this var.
    BYTE                  bType;        // Type( integer, counter, gauage).

} MIB_ENTRY, FAR * LPMIB_ENTRY;


typedef struct  _MIB_ENTRIES {

    AsnObjectIdentifier  *  pOidPrefix;  // Oid with prefix for MIB ENTRIES
    int                     cMibEntries; // count of MIB_ENTRIES in the array
    LPMIB_ENTRY             prgMibEntry; // ptr to array of MIB_ENTRIES

} MIB_ENTRIES, FAR * LPMIB_ENTRIES;


/************************************************************
 *    Macros convenient for defining above MIB_ENTRY objects
 ************************************************************/

//
// GET_OID_LENGTH( oid)  gets the length of the oid.
//

# define  GET_OID_LENGTH( oid)           ((oid).idLength)

//
//  Macro to determine number of sub-oid's in an array of UINTs.
//

#define OID_SIZEOF( uiArray )      ( sizeof( uiArray) / sizeof(UINT) )

//
// OID_FROM_UINT_ARRAY():  Macro to define OID from an Array of UINTs
//
# define OID_FROM_UINT_ARRAY( uiArray)   { OID_SIZEOF( uiArray), uiArray }


//
// Macros for creating MIB Entries ( as specified in struct _MIB_ENTRY above)
//  MIB_ENTRY_HEADER:  creates a generic MIB_ENTRY for a MIB group header.
//  MIB_ENTRY_ITEM:    creates a generic MIB_ENTRY for a MIB variable.
//  MIB_COUNTER:       creates a counter type MIB_ENTRY
//  MIB_INTEGER:       creates an integer type MIB_ENTRY
//

# define MIB_ENTRY_HEADER( oid)             \
           {   oid,                         \
               -1,                          \
               MIB_NOACCESS,                \
               NULL,                        \
               ASN_RFC1155_OPAQUE,          \
           }

# define MIB_ENTRY_ITEM( oid, offset, access, type, func)  \
           {   oid,            \
               offset,         \
               access,         \
               ( func),        \
               ( type),        \
           }

# define MIB_COUNTER( oid, field, func)    \
     MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_RFC1155_COUNTER, func)

# define MIB_INTEGER( oid, field, func)    \
           MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_INTEGER, func)



/************************************************************
 *    Function Prototypes
 ************************************************************/

UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind * pRfcVarBinding,
   IN BYTE                 pduAction,
   IN LPVOID               pStatistics,
   IN LPMIB_ENTRIES        pMibEntries
  );


UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   );



# endif // _MIB_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iiscrmap\sources.inc ===
!IF 0


Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Murali R. Krishnan    09-Oct-1995
          This sources.inc file is copied off from original sources file
           to support building two dlls.

Revision History:

!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

TARGETTYPE=DYNLINK
TARGETPATH=obj

USE_MSVCRT=1
DLLENTRY=DLLEntry

RAW_TARGETLIBS=\
            $(SDK_LIB_PATH)\kernel32.lib    \
            $(SDK_LIB_PATH)\user32.lib      \
            $(SDK_LIB_PATH)\advapi32.lib    \
            $(SDK_LIB_PATH)\crypt32.lib

TARGETLIBS=$(RAW_TARGETLIBS) \
            $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib	\
            $(IISBASEDIR)\svcs\infocomm\info\server\$(O)\infocomm.lib	\
            $(IISBASEDIR)\svcs\iismap\$(O)\iismap.lib

INCLUDES=..\iismap;

SOURCES=\
	iiscrmap.cxx	\
	iiscrmap.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iiscrmap\iiscrmap.cxx ===
/*++





opyright (c) 1996  Microsoft Corporation

Module Name:

    iiscrmap.cxx

Abstract:

    Certificate to NT account mapper

Author:

    Philippe Choquier (phillich)    17-may-1996
    Alex Mallet  (amallet) 13-Feb-1998

--*/

#ifdef __cplusplus
extern "C" {
#endif


# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>

#include <stdio.h>
#if 1 // DBCS
#include <mbstring.h>
#endif

#include <schnlsp.h>

#include <wincrypt.h>
#include <issperr.h>
#include <certmap.h>
#include <cmnull.hxx>
#include <lmcons.h>

#ifdef __cplusplus
};
#endif

#include <iis64.h>
#include <iiscrmap.hxx>

extern "C" {

#include <tchar.h>

#include <iisfiltp.h>

} // extern "C"

#include <tslogon.hxx>

#include <iismap.hxx>
#include <iiscmr.hxx>
#include "mapmsg.h"

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>
#include <iiscnfgp.h>
#include <reftrace.h>
#include <iiscert.hxx>
#include <iisctl.hxx>
#include <capiutil.hxx>
#include <sslinfo.hxx>

#define CALLC   WINAPI

CRITICAL_SECTION    g_csInitCritSec;
DWORD g_dwNumLocators;
extern MAPPER_VTABLE g_MapperVtable;
HANDLE g_hModule;

//
//
//
DECLARE_DEBUG_PRINTS_OBJECT();
#include <initguid.h>
DEFINE_GUID(IisCrMapGuid, 
0x784d8913, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);


extern "C"
BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT( "IISCRMAP" );
#else
        CREATE_DEBUG_PRINT_OBJECT( "IISCRMAP" , IisCrMapGuid);
#endif
        INITIALIZE_CRITICAL_SECTION( &g_csInitCritSec );
        g_dwNumLocators = 0;
        g_hModule = hDll;

        break;

    case DLL_PROCESS_DETACH:
        
        if ( g_dwNumLocators )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Still have %d locators left !\n",
                       g_dwNumLocators));
        }

        DELETE_DEBUG_PRINT_OBJECT();
        DeleteCriticalSection( &g_csInitCritSec );
        break;

    default:
        break;
    }

    return TRUE;
}



extern "C"
DWORD CALLC
CreateInstance(
    OUT HMAPPER** pHMapper
    )
/*++

Routine Description:

    Called to initialize the mapper

Arguments:

    None

Returns:

    Ptr to mapper vtable if success, otherwise NULL

--*/
{
    IisMapper *pMap;

    if ( !(pMap = (IisMapper*)LocalAlloc( LMEM_FIXED, sizeof(IisMapper) )) )
    {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    memcpy ( &pMap->mvtEntryPoints, &g_MapperVtable, sizeof(MAPPER_VTABLE) );

    pMap->hMapper.m_vtable = &pMap->mvtEntryPoints;
    pMap->hMapper.m_dwMapperVersion = MAPPER_INTERFACE_VER;
    pMap->hMapper.m_Reserved1 = NULL;
    pMap->lRefCount = 1;
    pMap->fIsIisCompliant = TRUE;
    pMap->hInst = (HINSTANCE)g_hModule;
    pMap->pCert11Mapper = NULL;
    pMap->pCertWMapper = NULL;
    pMap->pvInfo = NULL;

    pMap->dwSignature = IIS_MAPPER_SIGNATURE;

    *pHMapper = (HMAPPER*)pMap;

    return SEC_E_OK;
}


extern "C"
LONG CALLC
IisReferenceMapper(
    OUT HMAPPER*    pMap
    )
/*++

Routine Description:

    Increment reference count to mapper

Arguments:

    pMap - ptr to mapper struct

Returns:

    Ref count

--*/
{
    LONG l;

    EnterCriticalSection( &g_csInitCritSec );
    l = ++((IisMapper*)pMap)->lRefCount;
    LeaveCriticalSection( &g_csInitCritSec );

    return l;
}


extern "C"
LONG CALLC
IisDeReferenceMapper(
    OUT HMAPPER*    pMap
    )
/*++

Routine Description:

    Decrement reference count to mapper

Arguments:

    pMap - ptr to mapper struct

Returns:

    Ref count

--*/
{
    LONG l;

    EnterCriticalSection( &g_csInitCritSec );
    if ( !(l = --((IisMapper*)pMap)->lRefCount) )
    {
        LocalFree( pMap );
    }
    LeaveCriticalSection( &g_csInitCritSec );

    return l;
}


extern "C"
DWORD CALLC
IisGetChallenge(
    HMAPPER*,
    PBYTE,
    DWORD,
    PBYTE,
    LPDWORD
    )
/*++

Routine Description:

    Get challenge for auth sequence

Arguments:

    Not used

Returns:

    FALSE ( not supported )

--*/
{
    return SEC_E_UNSUPPORTED_FUNCTION; 
}


extern "C"
DWORD CALLC
IisGetIssuerList(
    IN HMAPPER*            phMapper,
    IN LPVOID              pvReserved,
    OUT LPBYTE              pIssuer,
    IN OUT DWORD *             pdwIssuer
    )
/*++

Routine Description:

    Called to retrieve the list of preferred cert issuers

Arguments:

    phMapper - pointer to mapper object 
    pvReserved - nothing useful, right now
    pIssuer -- updated with ptr buffer of issuers. If NULL, caller wants to get size of buffer
    required for issuer list 
    pdwIssuer -- updated with issuers buffer size

Returns:

    SEC_E_* error code

--*/
{
    IIS_SSL_INFO *pSslInfo = (IIS_SSL_INFO *) ((IisMapper*) phMapper)->pvInfo;
    BOOL fSuccess = FALSE;

    //
    // Can't get at any instance-specific information, so we'll just pretend
    // that nothing happened
    //
    if ( !pSslInfo )
    {
        *pdwIssuer = 0;
        return SEC_E_OK;
    }

    //
    // Pull out all the trusted CAs
    //
    PCCERT_CONTEXT *apContexts = NULL;
    PCCERT_CONTEXT pCert = NULL;
    DWORD dwCertsFound = 0;
    DWORD dwCertsInCTL = 0;
    DWORD dwTotalSize = 0;
    DWORD dwPosition = 0;

    if ( !pSslInfo->GetTrustedIssuerCerts( &apContexts,
                                           &dwCertsFound ) )
    {
        return SEC_E_UNTRUSTED_ROOT;
    }


    //
    // Figure out total size of chain and whether the buffer passed in is big 
    // enough. Each cert is to be encoded as [MSB of length] [LSB of length] [cert], 
    // so two extra bytes need to be added to the length for each cert 
    //
    for ( DWORD dwIndex = 0; dwIndex < dwCertsFound; dwIndex++ )
    {
        dwTotalSize += apContexts[dwIndex]->cbCertEncoded;
    }
    dwTotalSize += 2*dwCertsFound;

    //
    // Caller is only interested in size or buffer is too small
    //
    if ( !pIssuer || ( pIssuer && 
                       (*pdwIssuer < dwTotalSize) ) )
    {
        *pdwIssuer = dwTotalSize;
        goto cleanup;
    }

    //
    // Fill in the cert info : [MSB of length] [LSB of length] [Actual cert]
    //
    for ( dwIndex = 0 ; dwIndex < dwCertsFound; dwIndex++ )
    {
        pIssuer[dwPosition++] = (BYTE) ((apContexts[dwIndex]->cbCertEncoded) & 0xFF00) >> 8;
        pIssuer[dwPosition++] = (BYTE) (apContexts[dwIndex]->cbCertEncoded) & 0xFF;
        memcpy( pIssuer + dwPosition, apContexts[dwIndex]->pbCertEncoded, 
                apContexts[dwIndex]->cbCertEncoded );
        dwPosition += apContexts[dwIndex]->cbCertEncoded;
    }

    DBG_ASSERT( dwPosition == dwTotalSize );

    *pdwIssuer = dwTotalSize;

    fSuccess = TRUE;

cleanup:
    if ( apContexts )
    {
        for ( dwIndex = 0; dwIndex < dwCertsFound; dwIndex++ )
        {
            CertFreeCertificateContext( apContexts[dwIndex] );
        }
        delete [] apContexts;
    }
    
    return fSuccess ? SEC_E_OK : SEC_E_UNTRUSTED_ROOT;

#if 0
    return ((CIisCert11Mapper*)(((IisMapper*)phMapper)->pCert11Mapper))->GetIssuerBuffer( (LPBYTE)pIssuer, pdwIssuer );
#endif
}


extern "C"
__declspec( dllexport )
DWORD CALLC
MapperFree(
    LPVOID  pvBuff
    )
/*++

Routine Description:

    Called to delete list of issuers returned by GetIssuerList

Arguments:

    pvBuff -- ptr to buffer alloced by the mapper DLL

Returns:

    SEC_E_* error code

--*/
{
    //
    // Dead code, I believe
    //
    DBG_ASSERT( TRUE );

    LocalFree( pvBuff );
    
    return SEC_E_OK;
}



extern "C"
BOOL CALLC
TerminateMapper(
    VOID
    )
/*++

Routine Description:

    Called to terminate the mapper

Arguments:

    None

Returns:

--*/
{
    return TRUE;
}


extern "C"
DWORD CALLC
IisMapCredential(
    IN HMAPPER *   phMapper,
    IN DWORD       dwCredentialType,
    IN PVOID       pCredential,        
    IN PVOID       pAuthority,  
    OUT HLOCATOR *  phToken
    )
/*++

Routine Description:

    Called to map a certificate to a NT account

Arguments:

    phMapper - ptr to hmapper struct
    dwCredentialType -- type of credential
    pCredential - ptr to client cert
    pAuthority - ptr to Certifying Authority cert
    phToken -- updated with impersonation access token

Returns:

    SEC_E_* error code

--*/
{
    CIisMapping *           pQuery = NULL;
    CIisMapping *           pResult = NULL;
    BOOL                    fSt;
    LPSTR                   pAcct;
    LPSTR                   pPwd;
    LPSTR                   pA;
    DWORD                   dwA;
    DWORD                   dwD;
    int                     x;
    BOOL                    fAllocedAcct = FALSE;
    CHAR                    achDomain[256];
    CHAR                    achUser[64];
    CHAR                    achCookie[64];
    CIisCert11Mapper*       pCertMapper;
    CIisRuleMapper*         pCertWildcard;
    LPSTR                   pEnabled;
    DWORD                   dwE;
    DWORD                   dwP;
    CHAR                    achPwd[PWLEN + 1];
    PCERT_CONTEXT           pClientCert = (PCERT_CONTEXT) pCredential;

    DBG_ASSERT( pClientCert );

    //
    // Reject request if we do not understand the format
    //

    if ( dwCredentialType != X509_ASN_CHAIN )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return SEC_E_NOT_SUPPORTED;
    }

    //
    // IIS 4 used the pAuthority parameter; IIS 5 doesn't, and Schannel always passes in
    // NULL, so remove the error check for it
    //
#if 0
    //
    // Reject request if CA not recognized
    //

    //
    // Removing IsCeritificateVerified() since we don't have what
    // we need to do the appropriate queries
    //

    if ( pAuthority == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return SEC_E_INTERNAL_ERROR;
    }
#endif 

    pCertMapper = (CIisCert11Mapper*)((IisMapper*)phMapper)->pCert11Mapper;
    pCertWildcard = (CIisRuleMapper*)((IisMapper*)phMapper)->pCertWMapper;

    if ( !pCertMapper )
    {
        goto wildcard_mapper;
    }



#if DBG
    CHAR szSubjectName[1024];
    CHAR szIssuerName[1024];
    if ( CertGetNameString( pClientCert,
                            CERT_NAME_SIMPLE_DISPLAY_TYPE,
                            0,
                            NULL,
                            szSubjectName,
                            1024 ) &&
         CertGetNameString( pClientCert,
                            CERT_NAME_SIMPLE_DISPLAY_TYPE,
                            CERT_NAME_ISSUER_FLAG,
                            NULL,
                            szIssuerName,
                            1024 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "[IisMapCredential] Trying to map client cert for subject %s, issued by %s \n", 
                   szSubjectName,
                   szIssuerName));
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT,
               "[IisMapCredential] Couldn't get subject or issuer name for client cert : 0x%x\n",
                   GetLastError()));
    }
#endif 

    //
    // Create a mapping request object
    //

    if ( !(pQuery = pCertMapper->CreateNewMapping( pClientCert->pbCertEncoded,
                                                   pClientCert->cbCertEncoded ) ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "[IisMapCredential] Failed to create cert mapping query !\n"));
        return SEC_E_INTERNAL_ERROR;
    }

    //
    // Look for a match. If not found, log event
    //

    pCertMapper->Lock();

    if ( pCertMapper->FindMatch( pQuery,
                                 &pResult ) )
    {
        if ( !pResult->MappingGetField( IISMDB_INDEX_CERT11_NT_ACCT,
                                        &pAcct,
                                        &dwA,
                                        FALSE ) ||
             !pResult->MappingGetField( IISMDB_INDEX_CERT11_ENABLED,
                                        &pEnabled,
                                        &dwE,
                                        FALSE ) ||
             !pResult->MappingGetField( IISMDB_INDEX_CERT11_NT_PWD,
                                        &pPwd,
                                        &dwP,
                                        FALSE ) )
        {
            pCertMapper->Unlock();
            delete pQuery;
            return SEC_E_INTERNAL_ERROR;
        }

        strncpy( achPwd, 
                 pPwd,
                 sizeof( achPwd ) - 1 );

        delete pQuery;

        //
        // if mapping not enabled, ignore it
        //

        if ( !dwE ||
             ( dwE == sizeof(DWORD) && *(UNALIGNED64 DWORD *)pEnabled == 0 ) ||
             ( dwE && *pEnabled == '0' ) )
        {
            pCertMapper->Unlock();
            pCertMapper = NULL;
            goto wildcard_mapper;
        }
    }
    else
    {
#if 0
        //
        // log event
        //

        LPCTSTR pA[CERT_MAP_NB_FIELDS];
        for ( UINT x = 0 ; x < CERT_MAP_NB_FIELDS ; ++x )
        {
            if ( !pQuery->MappingGetField( x, (LPSTR*)(pA+x) ) || pA[x] == NULL )
            {
                pA[x] = "";
            }
        }
        ReportIisMapEvent( EVENTLOG_INFORMATION_TYPE,
                IISMAP_EVENT_NO_MAPPING,
                CERT_MAP_NB_FIELDS,
                pA );
#endif

        pCertMapper->Unlock();
        pCertMapper = NULL;

        delete pQuery;

        //
        // Try to find a match using wildcard mapper
        //

wildcard_mapper:

        if ( pCertWildcard )
        {
            if ( !pCertWildcard->Match( pClientCert,
                                        (PCERT_CONTEXT)pAuthority,
                                        achCookie,
                                        achPwd ) )
            {
                //
                // Set token to special value '1' for mappings that deny access
                //
                if ( GetLastError() == ERROR_ACCESS_DENIED )
                {
                    *phToken = (HLOCATOR)1;
                    return SEC_E_OK;
                }
                else
                {
                    pAcct = NULL;
                }
            }
            else
            {
                pAcct = achCookie;
                dwA = strlen( pAcct );
            }
        }
        else
        {
            pAcct = NULL;
        }
    }

    if ( pAcct == NULL )
    {
        if ( pCertMapper )
        {
            pCertMapper->Unlock();
        }

        return SEC_E_UNKNOWN_CREDENTIALS;
    }

    // break in domain & user name
    // copy to local storage so we can unlock mapper object

    LPSTR pSep;
    LPSTR pUser;
#if 1 // DBCS enabling for user name
    // pAcct is always zero terminated
    if ( (pSep = (LPSTR)_mbschr( (PUCHAR)pAcct, '\\' )) )
#else
    if ( (pSep = (LPSTR)memchr( pAcct, '\\', dwA )) )
#endif
    {
        if ( (pSep - pAcct) < sizeof(achDomain) )
        {
            memcpy( achDomain, pAcct, DIFF(pSep - pAcct) );
            achDomain[pSep - pAcct] = '\0';
        }
        else
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            pCertMapper->Unlock();
            return SEC_E_UNKNOWN_CREDENTIALS;
        }
        pUser = pSep + 1;
        dwA -= DIFF(pSep - pAcct) + 1;
    }
    else
    {
        achDomain[0] = '\0';
        pUser = pAcct;
    }
    if ( dwA >= sizeof(achUser) || dwA <= 0 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        pCertMapper->Unlock();
        return SEC_E_UNKNOWN_CREDENTIALS;
    }
    memcpy( achUser, pUser, dwA );
    achUser[dwA] = '\0';

    if ( pCertMapper )
    {
        pCertMapper->Unlock();
    }

    if ( fAllocedAcct )
    {
        LocalFree( pAcct );
    }

    DBGPRINTF((DBG_CONTEXT,
               "Found a mapping, %s\\%s\n",
               (achDomain[0] == '\0' ? "<no domain>" : achDomain), 
               achUser));

    fSt = LogonUserA( achUser,
                      achDomain,
                      achPwd,
                      LOGON32_LOGON_INTERACTIVE,
                      LOGON32_PROVIDER_DEFAULT,
                      (HANDLE*)phToken );

    if ( !fSt )
    {
        LPCTSTR pA[2];
        CHAR    achAcct[128];

        DBGPRINTF((DBG_CONTEXT,
                   "Logon of %s\\%s failed, error 0x%x\n",
                   (achDomain[0] == '\0' ? "<no domain>" : achDomain),
                   achUser,
                   GetLastError()));

        wsprintf( achAcct, "%s\\%s", achDomain, achUser );
        if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPSTR)&pA[1],
                0,
                NULL ) )
        {
            pA[0] = achAcct;

            ReportIisMapEvent( EVENTLOG_ERROR_TYPE,
                    IISMAP_EVENT_ERROR_LOGON,
                    sizeof(pA)/sizeof(LPCTSTR),
                    pA );

            LocalFree( (LPVOID)pA[1] );
        }
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT,
                   "[IisMapCredential] Successful logon, token 0x%p\n",
                   *phToken));

        g_dwNumLocators++;
    }

    return fSt ? SEC_E_OK : SEC_E_UNKNOWN_CREDENTIALS;
}

extern "C"
DWORD CALLC IisQueryMappedCredentialAttributes( IN HMAPPER     *phMapper,  
                                                IN HLOCATOR    hLocator,   
                                                IN ULONG       ulAttribute, 
                                                OUT PVOID      pBuffer,
                                                IN OUT DWORD   *pcbBuffer )
{
    if ( !pBuffer || ( *pcbBuffer < sizeof( HLOCATOR ) ) )
    {
        *pcbBuffer = sizeof( HLOCATOR );
    }
    else
    {    
        *((HLOCATOR*)pBuffer) = hLocator;
    }
    
    return SEC_E_OK;
}

extern "C"
DWORD CALLC
IisGetAccessToken(
    IN HMAPPER* phMapper,
    IN HLOCATOR tokenhandle,
    OUT HANDLE *phToken
    )
/*++

Routine Description:

    Called to retrieve an access token from a mapping

Arguments:

    phMapper - pointer to mapper to use 
    tokenhandle -- HLOCATOR returned by MapCredential
    phToken -- updated with potentially new token

Returns:

    SEC_E_* error code

--*/
{

#if 1
    *phToken = (HANDLE) tokenhandle;

    return SEC_E_OK;
#else
    //
    // Special value '1' is used to denote mappings that -deny- access
    //
    if ( tokenhandle == 1 )
    {
        *phToken = (HANDLE)tokenhandle;
    }
    else 
    {
        if ( !DuplicateTokenEx( (HANDLE)tokenhandle,
                                TOKEN_ALL_ACCESS,
                                NULL,
                                SecurityImpersonation,
                                TokenPrimary,
                                phToken ))
        {
            return SEC_E_INVALID_TOKEN;
        }
    }

    return SEC_E_OK;
#endif 
}


extern "C"
DWORD CALLC
IisCloseLocator(
    IN HMAPPER* phMapper,
    IN HLOCATOR tokenhandle
    )
/*++

Routine Description:

    Called to close a HLOCATOR returned by MapCredential

Arguments:

    tokenhandle -- HLOCATOR

Returns:

    SEC_E_* error code

--*/
{
    DBG_ASSERT( g_dwNumLocators > 0 );

    if ( tokenhandle != 1 && tokenhandle != NULL )
    {
        CloseHandle( (HANDLE)tokenhandle );
        g_dwNumLocators--;
    }
    
    return SEC_E_OK;
}


MAPPER_VTABLE g_MapperVtable={
    (REF_MAPPER_FN)IisReferenceMapper,
    (DEREF_MAPPER_FN)IisDeReferenceMapper,
    (GET_ISSUER_LIST_FN)IisGetIssuerList,
    (GET_CHALLENGE_FN)IisGetChallenge,
    (MAP_CREDENTIAL_FN)IisMapCredential,
    (GET_ACCESS_TOKEN_FN)IisGetAccessToken,
    (CLOSE_LOCATOR_FN)IisCloseLocator,
    (QUERY_MAPPED_CREDENTIAL_ATTRIBUTES_FN)IisQueryMappedCredentialAttributes
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iismap\ber.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __BER_H__
#define __BER_H__


#define BER_UNIVERSAL           0x00
#define BER_APPLICATION         0x40
#define BER_CONTEXT_SPECIFIC    0x80
#define BER_PRIVATE             0xC0

#define BER_PRIMITIVE           0x00
#define BER_CONSTRUCTED         0x20

#define BER_BOOL                1
#define BER_INTEGER             2
#define BER_BIT_STRING          3
#define BER_OCTET_STRING        4
#define BER_NULL                5
#define BER_OBJECT_ID           6
#define BER_OBJECT_DESC         7
#define BER_EXTERNAL            8
#define BER_REAL                9
#define BER_ENUMERATED          10

#define BER_SEQUENCE            (16 | BER_CONSTRUCTED)
#define BER_SET                 (17 | BER_CONSTRUCTED)

#define BER_NUMERIC_STRING      0x12
#define BER_PRINTABLE_STRING    0x13
#define BER_TELETEX_STRING      0x14
#define BER_VIDEOTEX_STRING     0x15
#define BER_IA5STRING           0x16
#define BER_GRAPHIC_STRING      0x19

#define BER_UTC_TIME            23

typedef int (* OutputFn)(char *, ...);
typedef BOOL (* StopFn)(void);

int
ber_decode(
    OutputFn Out,
    StopFn  Stop,
    LPBYTE  pBuffer,
    int   Indent,
    int   Offset,
    int   TotalLength,
    int   BarDepth);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iismap\encode.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <windows.h>
#define SP_ASSERT(a)
#define DebugLog(a)
#define SP_LOG_RESULT(a) (a)

#include "ber.h"
#include "encode.h"


/************************************************************/
/* EncodeLength ASN1 encodes a length field.  The parameter */
/* dwLen is the length to be encoded, it is a DWORD and     */
/* therefore may be no larger than 2^32.  The pbEncoded     */
/* parameter is the encoded result, and memory must be      */
/* allocated for it by the caller.  The Writeflag parameter */
/* indicates if the result is to be written to the pbEncoded*/
/* parameter.  The function returns a -1 if it fails and    */
/* otherwise returns the number of total bytes in the       */
/* encoded length.                                          */
/************************************************************/

typedef struct __Algorithms {
    DWORD       Id;
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
} _Algorithms;

typedef struct __CryptAlgs {
    DWORD       Id;
    DWORD       idHash;
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
} _CryptAlgs;

#define iso_member          0x2a,               /* iso(1) memberbody(2) */
#define us                  0x86, 0x48,         /* us(840) */
#define rsadsi              0x86, 0xf7, 0x0d,   /* rsadsi(113549) */
#define pkcs              iso_member us rsadsi 0x01,  /* pkcs */

#define pkcs_len            7
#define rsa_dsi             iso_member us rsadsi
#define rsa_dsi_len         6

#define joint_iso_ccitt_ds  0x55,
#define attributetype       0x04,

#define attributeType       joint_iso_ccitt_ds attributetype
#define attrtype_len        2


#if 0
_Algorithms     KnownSigAlgs[] = {
                                      {PCT_SIG_RSA_MD2, {pkcs 1, 1}, pkcs_len + 2},
                                      {PCT_SIG_RSA_MD2, {pkcs 1, 2}, pkcs_len + 2},
                                      {PCT_SIG_RSA_MD5, {pkcs 1, 4}, pkcs_len + 2}
                                  };


_Algorithms     KnownKeyExchAlgs[] = {{PCT_EXCH_RSA_PKCS1, {pkcs 1, 1}, pkcs_len + 2},
                                      {PCT_EXCH_RSA_PKCS1, {pkcs 1, 2}, pkcs_len + 2},
                                      {PCT_EXCH_RSA_PKCS1, {pkcs 1, 4}, pkcs_len + 2}
                                 };
_CryptAlgs     KnownCryptAlgs[] =  {
                                      {PCT_CIPHER_RC4 | PCT_ENC_BITS_128 | PCT_MAC_BITS_128, PCT_HASH_MD5, {rsa_dsi 3, 4}, rsa_dsi_len + 2}
                                    };
#endif

typedef struct _NameTypes {
    PSTR        Prefix;
    UCHAR       Sequence[12];
    DWORD       SequenceLen;
} NameTypes;

// DO NOT change the order in this table !

NameTypes   KnownNameTypes[] = { {"CN=", {attributeType 3}, attrtype_len + 1},
                                 {"C=", {attributeType 6}, attrtype_len + 1},
                                 {"L=", {attributeType 7}, attrtype_len + 1},
                                 {"S=", {attributeType 8}, attrtype_len + 1},
                                 {"O=", {attributeType 10}, attrtype_len + 1},
                                 {"OU=", {attributeType 11}, attrtype_len + 1},
                                 {"Email=", {pkcs 9, 1}, pkcs_len + 2},
                                 {"Name=", {pkcs 9, 2}, pkcs_len + 2},
                                 {"Addr=", {pkcs 9, 8}, pkcs_len + 2}
                               };





/************************************************************/
/* DecodeLength decodes an ASN1 encoded length field.  The  */
/* pbEncoded parameter is the encoded length. pdwLen is     */
/* used to return the length therefore the length may be no */
/* larger than 2^32. The function returns a -1 if it fails  */
/* and otherwise returns the number of total bytes in the   */
/* encoded length.                                          */
/************************************************************/
long
DecodeLength(
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD cEncoded)
{
    long    index = 0;
    BYTE    count;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    if(cEncoded < 1) {
       DebugLog((DEB_TRACE, "cEncode overflow %d\n", cEncoded));
       return(SP_LOG_RESULT(-1));
    }


    /* determine what the length of the length field is */
    if ((count = pbEncoded[0]) > 0x80)
    {

        /* if there is more than one byte in the length field then */
        /* the lower seven bits tells us the number of bytes */
        count = count ^ 0x80;

        /* this function only allows the length field to be 3 bytes */
        /* if the field is longer then the function fails */
        if (count > 2)
        {
            DebugLog((DEB_WARN, "Length field reported to be over 3 bytes\n"));
            return(SP_LOG_RESULT(-1));
        }

        if(count > cEncoded) {
            DebugLog((DEB_TRACE, "cEncode overflow %d\n", cEncoded));
           return(SP_LOG_RESULT(-1));
    }

        *pdwLen = 0;

        /* go through the bytes of the length field */
        for (index = 1; index <= count; index++)
        {
            *pdwLen = (*pdwLen << 8) + (DWORD) (pbEncoded[index]);
        }

    }

    /* the length field is just one byte long */
    else
    {
        *pdwLen = (DWORD) (pbEncoded[0]);
        index = 1;
    }

    /* return how many bytes there were in the length field */
    return index;
}


#if 0
/************************************************************/
/* DecodeSigAlgid decodes an ASN1 encoded algorithm identifier.*/
/* pbEncoded parameter is the encoded identifier. pAlgid is */
/* the parameter used to return the ALG_ID type algorithm   */
/* identifier.  The Writeflag parameter tells the function  */
/* whether to write to pAlgid or not, if TRUE write wlse    */
/* don't. The function returns a -1 if it fails and         */
/* otherwise returns the number of total bytes in the       */
/* encoded algorithm identifier.                            */
/************************************************************/

long
DecodeSigAlgid(
    DWORD *     pAlgid,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL    Writeflag)
{

    DWORD   i;
    DWORD   len;

    SP_ASSERT(pbEncoded != NULL);
    SP_ASSERT(pAlgid != NULL);

    SP_ASSERT((!Writeflag) || (pAlgid != NULL));
    if(cEncoded < 2)
    {
        return(SP_LOG_RESULT(-1));
    }

    if (*pbEncoded++ != OBJECT_ID_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    len = *pbEncoded++;

    if(cEncoded < 2 + len) return(SP_LOG_RESULT(-1));

    for (i = 0; i < sizeof(KnownSigAlgs) / sizeof(_Algorithms) ; i++ )
    {
        if (KnownSigAlgs[i].SequenceLen == len)
        {
            if (memcmp(pbEncoded, KnownSigAlgs[i].Sequence, len) == 0)
            {
                if (Writeflag)
                {
                    *pAlgid = KnownSigAlgs[i].Id;
                }
                return(len + 2);
            }
        }
    }
    return(SP_LOG_RESULT(-1));
}

/************************************************************/
/* DecodeSigAlgid decodes an ASN1 encoded algorithm identifier.*/
/* pbEncoded parameter is the encoded identifier. pAlgid is */
/* the parameter used to return the ALG_ID type algorithm   */
/* identifier.  The Writeflag parameter tells the function  */
/* whether to write to pAlgid or not, if TRUE write wlse    */
/* don't. The function returns a -1 if it fails and         */
/* otherwise returns the number of total bytes in the       */
/* encoded algorithm identifier.                            */
/************************************************************/

long
DecodeCryptAlgid(
    DWORD *     pAlgid,
    DWORD *     pHashid,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL    Writeflag)
{

    DWORD   i;
    DWORD   len;

    SP_ASSERT(pbEncoded != NULL);
    SP_ASSERT(pAlgid != NULL);

    SP_ASSERT((!Writeflag) || (pAlgid != NULL));
    if(cEncoded < 2) return(SP_LOG_RESULT(-1));

    if (*pbEncoded++ != OBJECT_ID_TAG) 
    {
        return(SP_LOG_RESULT(-1));
    }

    len = *pbEncoded++;

    if(cEncoded < 2 + len) 
    {
        return(SP_LOG_RESULT(-1));
    }

    for (i = 0; i < sizeof(KnownCryptAlgs) / sizeof(_Algorithms) ; i++ )
    {
        if (KnownCryptAlgs[i].SequenceLen == len)
        {
            if (memcmp(pbEncoded, KnownCryptAlgs[i].Sequence, len) == 0)
            {
                if (Writeflag)
                {
                    *pAlgid = KnownCryptAlgs[i].Id;
                    *pHashid = KnownCryptAlgs[i].idHash;
                }
                return(len + 2);
            }
        }
    }
    return(SP_LOG_RESULT(-1));
}


/************************************************************/
/* DecodeKeyExchId decodes an ASN1 encoded algorithm identifier.*/
/* pbEncoded parameter is the encoded identifier. pAlgid is */
/* the parameter used to return the ALG_ID type algorithm   */
/* identifier.  The Writeflag parameter tells the function  */
/* whether to write to pAlgid or not, if TRUE write wlse    */
/* don't. The function returns a -1 if it fails and         */
/* otherwise returns the number of total bytes in the       */
/* encoded algorithm identifier.                            */
/************************************************************/

long
DecodeKeyExchAlgid(
    DWORD *     pKeyId,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL    Writeflag)
{

    DWORD   i;
    DWORD   len;

    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pKeyId != NULL));
    if(cEncoded < 2) 
    {
        return(SP_LOG_RESULT(-1));
    }

    if (*pbEncoded++ != OBJECT_ID_TAG) 
    {
        return(SP_LOG_RESULT(-1));
    }

    len = *pbEncoded++;

    if(cEncoded < 2 + len) 
    {
        return(SP_LOG_RESULT(-1));
    }

    for (i = 0; i < sizeof(KnownCryptAlgs) / sizeof(_Algorithms) ; i++ )
    {
        if (KnownKeyExchAlgs[i].SequenceLen == len)
        {
            if (memcmp(pbEncoded, KnownKeyExchAlgs[i].Sequence, len) == 0)
            {
                if (Writeflag)
                {
                    *pKeyId = KnownKeyExchAlgs[i].Id;
                }
                return(len + 2);
            }
        }
    }
    return(SP_LOG_RESULT(-1));
}
#endif


/************************************************************/
/* DecodeHeader decodes an ASN1 encoded sequence type header.*/
/* pbEncoded parameter is the encoded header.  pdwLen is    */
/* the parameter used to return the length of the encoded   */
/* sequence. The function returns a -1 if it fails and      */
/* otherwise returns the number of total bytes in the       */
/* encoded header, not including the content.               */
/************************************************************/

long
DecodeHeader(
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD cEncoded)
{
    long    len;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    if(cEncoded < 1) 
    {
       DebugLog((DEB_TRACE, "Buffer Overflow\n"));
       return(SP_LOG_RESULT(-1));
    }

    /* make sure this is a sequence type */
    if (pbEncoded[0] != SEQUENCE_TAG) 
    {
        DebugLog((DEB_WARN, "Sequence Tag not found, %x instead\n", pbEncoded[0]));
        return(SP_LOG_RESULT(-1));
    }

    /* decode the length */
    if ((len = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-1)) == -1) 
    {
        DebugLog((DEB_TRACE, "Bad Length Decode\n"));
        return(SP_LOG_RESULT(-1));
    }

    return (len + 1);
}



/************************************************************/
/* DecodeSetOfHeader decodes an ASN1 encoded set of type    */
/* header. pbEncoded parameter is the encoded header. pdwLen*/
/* is the parameter used to return the length of the encoded*/
/* set of. The function returns a -1 if it fails and        */
/* otherwise returns the number of total bytes in the       */
/* encoded header, not including the content.               */
/************************************************************/

long
DecodeSetOfHeader(
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD cEncoded)
{
    long    len;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);


    if(cEncoded < 1) 
    {
        return(SP_LOG_RESULT(-1));
    }

    /* make sure this is a sequence type */
    if (*pbEncoded != SET_OF_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* decode the length */
    if ((len = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
        return(-1);

    return (len + 1);
}

long
DecodeSetHeader(
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD cEncoded)
{
    long len;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    if(cEncoded < 1) 
    {
        return(SP_LOG_RESULT(-1));
    }

    if (*pbEncoded != BER_SET)
    {
        return(SP_LOG_RESULT(-1));
    }

    if((len = DecodeLength(pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
        return(-1);
    }
    return(len + 1);
}

/****************************************************************/
/* DecodeInteger decodes an ASN1 encoded integer.  The encoded  */
/* integer is passed into the function with the pbEncoded       */
/* parameter.  The pbInt parameter is used to pass back the     */
/* integer as an array of bytes, and dwLen is the number of     */
/* in the array.  The least significant byte of the integer     */
/* is the zeroth byte of the array.  The Writeflag indicates    */
/* indicates if the result is to be written to the pbInt        */
/* parameter. The function returns a -1 if it fails and         */
/* otherwise returns the number of total bytes in the encoded   */
/* integer.                                                     */
/* This implementation will only deal with positive integers.   */
/****************************************************************/

long
DecodeInteger(
    BYTE *  pbInt,
    DWORD   cbBuff,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag)
{
    long    count;
    long    i;


    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pbInt != NULL));

    if(cEncoded < 1)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* make sure this is tagged as an integer */
    if (pbEncoded[0] != INTEGER_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    count = 1;

    /* decode the length field */
    if ((i = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-count)) == -1)
    {
        return(-1);
    }

    count += i;


    if(cEncoded < count+*pdwLen) 
    {
        return(SP_LOG_RESULT(-1));
    }

    /* write the integer out if suppose to */
    if (Writeflag)
    {
        if (pbEncoded[count] == 0)
        {
            count++;
            (*pdwLen)--;
        }

        if(*pdwLen > cbBuff) return -1;

        i = (*pdwLen) - 1;

        while (i >= 0)
        {
            pbInt[i--] = pbEncoded[count++];

        }
    }
    else
    {
        count += (long) *pdwLen;
    }

    /* return the length of the encoded integer */
    return (count);
}


/****************************************************************/
/* DecodeString decodes an ASN1 encoded a character string.  The*/
/* encoded string is passed into the function with the pbEncoded*/
/* parameter.  The pbStr is used to pass the decoded string back*/
/* to the caller, and pdwLen is the number of characters in the */
/* decoded array.  The Writeflag indicates if the result is to  */
/* be written to the pbStr parameter.  The function returns a   */
/* -1 if it fails and otherwise returns the number of bytes in  */
/* the encoded string.                                          */
/****************************************************************/
long
DecodeString(
    BYTE *  pbStr,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag)
{
    long    index;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pbStr != NULL));

    if(cEncoded < 1) 
    {
        return(SP_LOG_RESULT(-1));
    }

    if ((*pbEncoded != BER_PRINTABLE_STRING) &&
        (*pbEncoded != BER_TELETEX_STRING) &&
        (*pbEncoded != BER_GRAPHIC_STRING) &&
        (*pbEncoded != BER_IA5STRING))
    {
        return(SP_LOG_RESULT(-1));
    }

    /* determine how long the string is */
    if ((index = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
        return(-1);
    }

    index++;

    if(cEncoded < index + *pdwLen) 
    {
        return(SP_LOG_RESULT(-1));
    }

    if (Writeflag)
    {
        CopyMemory(pbStr, pbEncoded + index, *pdwLen);
    }

    return (index + *pdwLen);
}


/****************************************************************/
/* DecodeOctetString decodes an ASN1 encoded a octet string. The*/
/* encoded string is passed into the function with the pbEncoded*/
/* parameter.  The pbStr is used to pass the decoded string back*/
/* to the caller, and pdwLen is the number of characters in the */
/* decoded array.  The Writeflag indicates if the result is to  */
/* be written to the pbStr parameter.  The function returns a   */
/* -1 if it fails and otherwise returns the number of bytes in  */
/* the encoded string.                                          */
/****************************************************************/
long
DecodeOctetString(
    BYTE *  pbStr,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag)
{
    long    index;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pbStr != NULL));


    if(cEncoded < 1) 
    { 
         DebugLog((DEB_TRACE, "cEncoded Overflow:%d\n", cEncoded));
         return(SP_LOG_RESULT(-1)); 
    }

    if (pbEncoded[0] != OCTET_STRING_TAG) 
    { 
        DebugLog((DEB_TRACE, "Invalid Tag, expected OCTET_STRING, got %d\n", pbEncoded[0]));
        return(SP_LOG_RESULT(-1)); 
    }

    /* determine how long the string is */
    if ((index = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
    { 
        return(-1); 
    }

    index++;
    if(cEncoded < index+*pdwLen) 
    { 
        return(SP_LOG_RESULT(-1)); 
    }

    if (Writeflag)
    {
        CopyMemory(pbStr, pbEncoded + index, *pdwLen);
    }

    return (index + *pdwLen);
}


/****************************************************************/
/* DecodeBitString decodes an ASN1 encoded a bit string. The    */
/* encoded string is passed into the function with the pbEncoded*/
/* parameter.  The pbStr is used to pass the decoded string back*/
/* to the caller, and pdwLen is the number of characters in the */
/* decoded array.  The Writeflag indicates if the result is to  */
/* be written to the pbStr parameter.  The function returns a   */
/* -1 if it fails and otherwise returns the number of bytes in  */
/* the encoded string.  The DER are used in the decoding.       */
/****************************************************************/
long
DecodeBitString(
    BYTE *  pbStr,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag)
{
    long    index;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pbStr != NULL));

    if(cEncoded < 1) 
    {
        return(SP_LOG_RESULT(-1));
    }

    if (pbEncoded[0] != BIT_STRING_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* determine how long the string is */
    if ((index = DecodeLength (pdwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
        return(-1);
    }

    /* move the index up two bytes, one for the tag and one for the byte after */
    /* the length which tells the number of unused bits in the last byte, that */
    /* byte is always zero in this implementation, so it is ignored */
    index += 2;

    /* subtract one from the length of the bit string (in bytes) since, */
    /* to account for the byte after the length */
    (*pdwLen)--;

    if(cEncoded < index + *pdwLen) 
    {
        return(SP_LOG_RESULT(-1));
    }

    if (Writeflag)
    {
        CopyMemory(pbStr, pbEncoded + index, *pdwLen);
    }

    return (index + *pdwLen);
}


#if 0
#ifdef SECURITY_LINUX
/****************************************************************/
/* DecodeUTCTime decodes an ASN1 encoded Universal time type.   */
/* time type. The Time parameter is the time passed into the    */
/* function as a time_t type.  The encoded result is passed back*/
/* in the pbEncoded parameter.  The Writeflag indicates if the  */
/* result is to be written to the pbEncoded parameter.  The     */
/* function returns a -1 if it fails and otherwise returns the  */
/* number of total bytes in the encoded universal time.         */
/****************************************************************/

long
DecodeUTCTime(time_t *pTime, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag)
    {
    long        count;
    struct tm   tmTime;
    DWORD       dwLen;

    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pTime != NULL));


    if(cEncoded < 1) 
    {
        return(SP_LOG_RESULT(-1));
    }

    /* check to make sure this is a universal time type */
    if (pbEncoded[0] != UTCTIME_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* decode the length */
    if ((count = DecodeLength (&dwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
        return -1;
    }

    count++;
    dwLen += count;

    if(cEncoded < dwLen) 
    {
        return(SP_LOG_RESULT(-1));
    }

    if (Writeflag)
    {
        /* extract the year */
        tmTime.tm_year = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* extract the month */
        tmTime.tm_mon = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* extract the day */
        tmTime.tm_mday = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* extract the hour */
        tmTime.tm_hour = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* extract the minutes */
        tmTime.tm_min = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* extract the seconds */
        tmTime.tm_sec = (int)((pbEncoded[count] - 0x30) * 0xA
                                + (pbEncoded[count + 1] - 0x30));
        count += 2;

        /* make sure there is a Z at the end */
        if (pbEncoded[count] != 'Z')
        {
            return(SP_LOG_RESULT(-1));
        }

        *pTime = mktime (&tmTime);
    }

    return (long)dwLen;
}

#else /* SECURITY_LINUX */

long
DecodeFileTime(
    FILETIME *  pTime,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL        WriteFlag)
{
    LONGLONG    ft;
    LONGLONG    delta;
    SYSTEMTIME  st;
    long        count;
    DWORD       dwLen, dwTotalLen;
    BOOL        fUTC;
    int         Offset;

    SP_ASSERT(pTime != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!WriteFlag) || (pTime != NULL));

    if(cEncoded < 1) 
    {
        return(SP_LOG_RESULT(-1));
    }

    /* check to make sure this is a universal time type */
    if (pbEncoded[0] != UTCTIME_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    /* decode the length */
    if ((count = DecodeLength (&dwLen, pbEncoded + 1, cEncoded-1)) == -1)
    {
       return(-1);
    }

    count++;
    dwTotalLen = dwLen + count;

    if(cEncoded < dwLen) 
    {
        return(SP_LOG_RESULT(-1));
    }

    pbEncoded += count;

    if (WriteFlag)
    {
        st.wYear = (WORD) ((pbEncoded[0] - '0') * 10) +
                            (pbEncoded[1] - '0');

        if (st.wYear < 90)
        {
            st.wYear += 2000;
        }
        else
        {
            st.wYear += 1900;
        }

        pbEncoded += 2;
        dwLen -= 2;

        st.wMonth = (WORD) ((pbEncoded[0] - '0') * 10) +
                            (pbEncoded[1] - '0');

        pbEncoded += 2;
        dwLen -= 2;

        st.wDay = (WORD) ((pbEncoded[0] - '0') * 10) +
                            (pbEncoded[1] - '0');

        pbEncoded += 2;
        dwLen -= 2;

        st.wHour = (WORD) ((pbEncoded[0] - '0') * 10) +
                            (pbEncoded[1] - '0');

        pbEncoded += 2;
        dwLen -= 2;

        st.wMinute = (WORD) ((pbEncoded[0] - '0') * 10) +
                            (pbEncoded[1] - '0');

        pbEncoded += 2;
        dwLen -= 2;

        fUTC = FALSE;
        Offset = 0;
        st.wSecond = 0;

        if (dwLen)
        {
            //
            // Ok, still more to go:
            //

            if (*pbEncoded == 'Z')
            {
                DebugLog((DEB_TRACE, "FileTime:  no seconds, Z term\n"));
                //
                // Ok, it is UTC.
                //

                dwLen++;
                pbEncoded++;

            }
            else
            {
                if ((*pbEncoded == '+') ||
                    (*pbEncoded == '-') )
                {
                    DebugLog((DEB_TRACE, "FileTime:  no seconds, offset\n"));
                    //
                    // Yuck!  Offset encoded!
                    //

                    if (dwLen != 5)
                    {
                        return( -1 );
                    }

                    Offset = (int) ((pbEncoded[1] - '0') * 10) +
                                    (pbEncoded[2] - '0');
                    Offset *= 60;

                    Offset += (int) ((pbEncoded[3] - '0') * 10) +
                                    (pbEncoded[4] - '0');

                    if (pbEncoded[0] == '-')
                    {
                        Offset *= -1;
                    }


                }
                else
                {
                    st.wSecond = (WORD) ((pbEncoded[0] - '0') * 10) +
                                        (pbEncoded[1] - '0');

                    if (dwLen == 3)
                    {
                        if (pbEncoded[2] != 'Z')
                        {
                            return( -1 );
                        }

                    }
                    else if (dwLen > 3)
                    {
                        Offset = (int) ((pbEncoded[3] - '0') * 10) +
                                    (pbEncoded[4] - '0');
                        Offset *= 60;

                        Offset += (int) ((pbEncoded[5] - '0') * 10) +
                                        (pbEncoded[6] - '0');

                        if (pbEncoded[2] == '-')
                        {
                            Offset *= -1;
                        }

                    }
                }
            }
        }

        st.wMilliseconds = 0;

        SystemTimeToFileTime(&st, (FILETIME *) &ft);
        if (Offset != 0)
        {
            delta = (LONGLONG) Offset * 10000000;
            ft += delta;
        }

        *pTime = *((FILETIME *) &ft);
    }
    return(dwTotalLen);

}
#endif / * SECURITY_LINUX */
#endif

/****************************************************************/
/* DecodeName decodes an ASN1 encoded Name type. The encoded    */
/* name is passed into the function with the pbEncoded parameter*/
/* The pbName parameter is used to pass the name back to the    */
/* caller and pdwLen is the length of the name in bytes.        */
/* The Writeflag indicates if the result is to be written to    */
/* the pbName parameter.  The function returns a -1 if it       */
/* fails and otherwise returns the number of total bytes in the */
/* encoded name.                                                */
/****************************************************************/

long
DecodeName(
    BYTE *  pbName,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag)
{
    long        index;
    DWORD       dwLen;

    SP_ASSERT(pdwLen != NULL);
    SP_ASSERT(pbEncoded != NULL);

    SP_ASSERT((!Writeflag) || (pbName != NULL));

    /* decode the sequence header */
    if ((index = DecodeHeader (&dwLen, pbEncoded, cEncoded)) == -1)
    {
        return(-1);
    }

    /* decode the set of header */
    if ((index += DecodeSetOfHeader (&dwLen, pbEncoded + index, cEncoded-index)) < index)
    {
        return(-1);
    }

    /* decode the sequence header */
    if ((index += DecodeHeader (&dwLen, pbEncoded + index, cEncoded-index)) < index)
    {
        return(-1);
    }

    /* decode the attribute type, in this implementation it is fake */
    index += 3;  /* 3 because this is the length of the fake OBJECT IDENTIFIER */

    /* decode the string which is the name */
    if ((index += DecodeString (pbName, pdwLen, pbEncoded + index, cEncoded-index, Writeflag)) < index)
    {
        return(-1);
    }

    return index;
}

long
DecodeNull(
    BYTE *  pbEncoded, DWORD cEncoded)
{

    SP_ASSERT(pbEncoded != NULL);

    if(cEncoded < 2) return(SP_LOG_RESULT(-1));
    if (*pbEncoded != NULL_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }
    return(2);
}


long
IisDecodeNameType(
    int *       piPrefix,
    BYTE *      pbEncoded,
    DWORD cEncoded)
{

    DWORD   i;
    DWORD   len;

    SP_ASSERT(piPrefix != NULL);
    SP_ASSERT(pbEncoded != NULL);


    if(cEncoded < 1) 
    {
        return(SP_LOG_RESULT(-1));
    }

    if (*pbEncoded != OBJECT_ID_TAG)
    {
        return(SP_LOG_RESULT(-1));
    }

    pbEncoded++;

    len = *pbEncoded++;
    if(cEncoded < len+2) 
    {
        return(SP_LOG_RESULT(-1));
    }

    for (i = 0; i < sizeof(KnownNameTypes) / sizeof(NameTypes) ; i++ )
    {
        if (KnownNameTypes[i].SequenceLen == len)
        {
            if (memcmp(pbEncoded, KnownNameTypes[i].Sequence, len) == 0)
            {
                *piPrefix = i;
                return(len + 2);
            }
        }
    }

    *piPrefix = -1;
    return len + 2;
}



long
IisDecodeRDN(
    PSTR    *pValue,
    PSTR    pBuf,
    DWORD * pdwComponentLength,
    BYTE *  pbEncoded,
    DWORD   cEncoded
    )
{
    long    index;
    DWORD   dwLen;
    long    CompLen = 0;
    long    Processed;
    long    RdnLen;
    BOOL    fTmpWrite;
    PSTR    pName;
    int     iPrefixType;

    index = DecodeSetHeader(&RdnLen, pbEncoded, cEncoded);
    if (index == -1)
    {
        return(-1);
    }
    Processed = RdnLen + index;
    pbEncoded += index;
    if (0 != RdnLen)
        for (;;)
        {
            index = DecodeHeader(&dwLen, pbEncoded, RdnLen);
            if (index < 0)
                return(-1);
            RdnLen -= index;
            pbEncoded += index;

            index = IisDecodeNameType(&iPrefixType, pbEncoded, RdnLen);
            if (index < 0)
            {
                return(-1);
            }
            RdnLen -= index;
            pbEncoded += index;

            switch ( iPrefixType )
            {
                case 0:                 // CN
                    pValue[3] = pBuf;
                    fTmpWrite = TRUE;
                    break;

                case 1:                 // C
                    pValue[2]  = pBuf;
                    fTmpWrite = TRUE;
                    break;

                case 4:                 // O
                    pValue[0] = pBuf;
                    fTmpWrite = TRUE;
                    break;

                case 5:                 // OU
                    pValue[1] = pBuf;
                    fTmpWrite = TRUE;
                    break;

                default:
                    pName = NULL;
                    fTmpWrite = FALSE;
            }

            index = DecodeString((PUCHAR)pBuf, &dwLen, pbEncoded, RdnLen, fTmpWrite);
            if (index < 0)
            {
                return(-1);
            }

            pBuf[dwLen] = '\0';
            CompLen += dwLen + 1;
            pBuf += dwLen + 1;

            RdnLen -= index;
            pbEncoded += index;
            if (0 < RdnLen)
            {
            }
            else
            {
                break;
            }
        }

    *pdwComponentLength = CompLen;
    return Processed;
}


long
IisDecodeDN(
    PSTR    pValue[],
    PSTR    pBuf,
    BYTE *  pbEncoded,
    DWORD   cEncoded
    )
{
    long    index;
    DWORD   dwLen;
    long    TotalNameLength;
    DWORD   ComponentLength;
    DWORD   NameLength;
    long    EncodedNameLength;

    index = DecodeHeader(&dwLen, pbEncoded, cEncoded);

    if (index == -1)
    {
        return(-1);
    }

    EncodedNameLength = index + dwLen;

    TotalNameLength = dwLen;
    NameLength = 0;

    while (TotalNameLength > 0)
    {
        pbEncoded += index;

        index = IisDecodeRDN( pValue,
                              pBuf + NameLength,
                              &ComponentLength,
                              pbEncoded,
                              cEncoded - index
                            );
        if (index == -1)
            return(-1);

//        if (WriteFlag)
//            pName += ComponentLength;
        TotalNameLength -= index;
        NameLength += ComponentLength;
#if 0
        if ((TotalNameLength > 0) && (0 < ComponentLength))
        {
            if (WriteFlag)
            {
                *pName++ = ',';
                *pName++ = ' ';
            }
            NameLength += 2;
        }
        else if ((TotalNameLength <= 0)
                 && (0 == ComponentLength)
                 && (0 < NameLength))
        {

            //
            // The last RDN didn't produce any output, so we need to
            // roll back that ", " we put on previously.
            //

            if (WriteFlag)
                pName -= 2;
            NameLength -= 2;
        }
#endif
    }

    //*pdwLen = NameLength;

    return(EncodedNameLength);

}
#if 0
long
DecodeSigAlg(
    DWORD *         pAlgId,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag)
{
    long    Result;
    DWORD   dwLen;
    long    index;

    index = DecodeHeader(  &dwLen, pbEncoded, cEncoded);
    if (index == -1)
    {
        return(-1);
    }


    Result = DecodeSigAlgid(   pAlgId,
                            pbEncoded+index,
                            cEncoded - index,
                            WriteFlag );

    if (Result == -1)
    {
        return(-1);
    }
    index += Result;


    Result = DecodeNull(pbEncoded + index, cEncoded - index);
    if (Result == -1)
    {
        return(-1);
    }

    return(index + Result);
}

long
DecodeCryptAlg(
    DWORD *         pAlgId,
    DWORD *         pHashid,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag)
{
    long    Result;
    DWORD   dwLen;
    long    index;

    index = DecodeHeader(  &dwLen, pbEncoded, cEncoded);
    if (index == -1)
    {
        return(-1);
    }


    Result = DecodeCryptAlgid(pAlgId, pHashid,
                            pbEncoded+index,
                            cEncoded - index,
                            WriteFlag );

    if (Result == -1)
    {
        return(-1);
    }
    index += Result;


    Result = DecodeNull(pbEncoded + index, cEncoded - index);
    if (Result == -1)
    {
        return(-1);
    }

    return(index + Result);
}

long
DecodeKeyType(
    DWORD *         pKeyType,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag)
{
    long    Result;
    DWORD   dwLen;
    long    index;

    index = DecodeHeader(  &dwLen, pbEncoded, cEncoded);
    if (index == -1)
    {
        return(-1);
    }


    Result = DecodeKeyExchAlgid(pKeyType,
                            pbEncoded+index,
                            cEncoded - index,
                            WriteFlag );

    if (Result == -1)
    {
        return(-1);
    }
    index += Result;


    Result = DecodeNull(pbEncoded + index, cEncoded - index);
    if (Result == -1)
    {
        return(-1);
    }

    return(index + Result);
}
#endif
#if 0
long
DecryptOctetString(
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    Writeflag,
    PSTR    pszPassword)

{

    long    index, Result;
    CipherSpec CryptId;
    HashSpec  HashId;
    SPBuffer Input, Output;
    PCryptoSystem pCipher;
    PCheckSumFunction pHash;

    if(cEncoded < 1)  
    {
        return(SP_LOG_RESULT(-1));
    }
    /* Figure out what crypto alg and pasword has we are using. */
    index = DecodeCryptAlg( &CryptId, &HashId, pbEncoded, cEncoded, TRUE );
    if (index == -1)
    {
        return(-1);
    }

    pCipher = CipherFromSpec(CryptId);
    if(pCipher == NULL) 
    {
        return(SP_LOG_RESULT(-1));
    }

    pHash = HashFromSpec(HashId);
    if(pHash == NULL) 
    {
        return(SP_LOG_RESULT(-1));
    }

    if (*(pbEncoded + index) != OCTET_STRING_TAG)
    {
        return ( -1 );
    }

    index++;
    /* determine how long the string is */
    if ((Result = DecodeLength (pdwLen, pbEncoded + index, cEncoded-index)) == -1)
    if (Result == -1)
    {
        return(-1);
    }

    index += Result;

    if(cEncoded < (index + *pdwLen)) 
    {
        return(SP_LOG_RESULT(-1));
    }

    if (Writeflag)
    {
        HashBuf SumBuff, Buff;
        PStateBuffer pState;
        PCheckSumBuffer  Sum = (PCheckSumBuffer)SumBuff;
        pHash->Initialize(Sum,0);
        pHash->Sum(Sum, lstrlen(pszPassword), (PUCHAR)pszPassword);
        pHash->Finalize(Sum,  Buff);

        Input.pvBuffer = Output.pvBuffer = pbEncoded+index;
        Input.cbBuffer = Output.cbBuffer = *pdwLen;
        Input.cbData = Output.cbData = *pdwLen;

        pCipher->Initialize(Buff, pHash->cbCheckSum, &pState);
        pCipher->Decrypt(pState, &Input, &Output);
        pCipher->Discard(&pState);
    }

    return (index);
}



long
DecodePrivateKeyFile(
    PctPrivateKey     * *   ppKey,
    PBYTE               pbEncoded,
    DWORD               cEncoded,
    PSTR                Password )
{
    DWORD           dwLen;
    long            Result;
    long            index;
    DWORD           KeyId;
    DWORD           Version;
    KeyExchangeSystem *pSys = NULL;

    index = 0;

    SP_BEGIN("DecodePrivateKeyFile");


    Result = DecodeHeader( &dwLen, pbEncoded , cEncoded);
    if (Result == -1)
    {
        SP_RETURN(-1);
    }
    index += Result;

    Result = DecodeOctetString( NULL, &dwLen, pbEncoded+ index, cEncoded-index, FALSE );
    if (Result == -1)
    {
        SP_RETURN(-1);
    }
    index += Result;

    Result = DecodeHeader( &dwLen, pbEncoded +index, cEncoded-index);
    if (Result == -1)
    {
        SP_RETURN(-1);
    }
    index += Result;



    /* Now, the next item should be an octet string, which is encrypted */
    /* with the password above.  So, we need to skip into it, decrypt it, */
    /* then treat it as a constructed type: */


    Result = DecryptOctetString(&dwLen,
                                pbEncoded+index,
                                cEncoded-index,
                                TRUE,
                                Password);

    if (Result == -1)
    {
        SP_RETURN(-1);
    }




    index += Result;


    /* The moment of truth */


    Result = DecodeHeader( &dwLen, pbEncoded+index, cEncoded-index );
    if (Result == -1)
    {
        SP_RETURN(-1);
    }
    index += Result;

    Version = 0;

    Result = DecodeInteger( (PUCHAR) &Version, sizeof(Version), &dwLen, pbEncoded+index, cEncoded-index, FALSE );

    if ((Result < 0) || ( dwLen > 4 ) )
    {
        SP_RETURN(SP_LOG_RESULT(-1));
    }

    Result = DecodeInteger( (PUCHAR) &Version, sizeof(Version), &dwLen, pbEncoded+index, cEncoded-index, TRUE );
    if (Result == -1 || Version != 0)
    {
        SP_RETURN(SP_LOG_RESULT(-1));
    }

    index += Result;

    Result = DecodeKeyType( &KeyId, pbEncoded+index, cEncoded-index, TRUE );

    if (Result == -1)
    {
        SP_RETURN(-1);
    }

    index += Result;


    /* This is now the serialized rsa key. */


    if (*(pbEncoded+index) != OCTET_STRING_TAG)
    {
        SP_RETURN(SP_LOG_RESULT(-1));
    }

    index ++;

    Result = DecodeLength( &dwLen, pbEncoded+index, cEncoded-index );

    if (Result == -1)
    {
        SP_RETURN(-1);
    }

    if(index + dwLen > cEncoded) 
    {
        SP_RETURN(SP_LOG_RESULT(-1));
    }

    index += Result;

    /* The sequence is the key... */

    pSys = KeyExchangeFromSpec(KeyId);
    if(pSys == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(-1));
    }
    index += pSys->DecodePrivate(pbEncoded+index, cEncoded-index, ppKey);
    SP_RETURN(index); 

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iismap\encode.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 


#ifndef _ENCODE_H_
#define _ENCODE_H_

/* tag definitions for ASN.1 encoding decoding */
#define INTEGER_TAG                     0x02
#define CHAR_STRING_TAG         0x16
#define OCTET_STRING_TAG        0x04
#define BIT_STRING_TAG          0x03
#define UTCTIME_TAG                     0x17
#define SEQUENCE_TAG            0x30
#define SET_OF_TAG                      0x11
#define OBJECT_ID_TAG           0x06
#define NULL_TAG            0x05
#define PRINTABLE_STRING_TAG    0x13
#define TELETEX_STRING_TAG      0x14

/* definitions of maximum lengths needed for the ASN.1 encoded
   form of some of the common fields in a certificate */
#define MAXVALIDITYLEN          0x24
#define MAXKEYINFOLEN           0x50
#define MAXALGIDLEN                     0x0A
#define MAXOBJIDLEN                     0x0A
#define MAXNAMEVALUELEN         0x40
#define UTCTIMELEN                      0x0F
#define MAXPUBKEYDATALEN        0x30
#define VERSIONLEN                      0x03
#define MAXENCODEDSIGLEN        0x30
#define MAXHEADERLEN            0x08
#define MINHEADERLEN            0x03
#define MAXTIMELEN                      0x20

/* definitions for scrubbing memory */
#define ALLBITSOFF                      0x00
#define ALLBITSON                       0xFF

/* prototypes for the functions in encode.c */
long EncodeLength (BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeAlgid (BYTE *pbEncoded, DWORD Algid, BOOL Writeflag);
long EncodeInteger (BYTE *pbEncoded, BYTE *pbInt, DWORD dwLen, BOOL Writeflag);
long EncodeString (BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeOctetString (BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
long EncodeBitString (BYTE *pbEncoded, BYTE *pbStr, DWORD dwLen, BOOL Writeflag);
//long EncodeUTCTime (BYTE *pbEncoded, time_t Time, BOOL Writeflag);
long EncodeHeader (BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeSetOfHeader (BYTE *pbEncoded, DWORD dwLen, BOOL Writeflag);
long EncodeName (BYTE *pbEncoded, BYTE *pbName, DWORD dwLen, BOOL Writeflag);


long DecodeLength (DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeAlgid (DWORD *pAlgid, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeHeader (DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeSetOfHeader (DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded);
long DecodeInteger (BYTE *pbInt, DWORD cbBuff, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeString (BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded,BOOL Writeflag);
long DecodeOctetString (BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeBitString (BYTE *pbStr, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);
long DecodeName (BYTE *pbName, DWORD *pdwLen, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);

long
EncodeAlgorithm(
    BYTE *  pbEncoded,
    DWORD   AlgId,
    BOOL    WriteFlag);

#define ALGTYPE_SIG_RSA_MD5      0x01
#define ALGTYPE_KEYEXCH_RSA_MD5  0x02
#define ALGTYPE_CIPHER_RC4_MD5   0x03

long
EncodeDN(
    BYTE *  pbEncoded,
    PSTR    pszDN,
    BOOL    WriteFlag);

long
IisDecodeDN(
    PSTR    *pValue,
    PSTR    pBuf,
    BYTE *  pbEncoded,
    DWORD   cEncoded
    );


#ifndef SECURITY_LINUX
long
EncodeFileTime(
    BYTE *      pbEncoded,
    FILETIME    Time,
    BOOL        UTC,
    BOOL        WriteFlag);
#else /* SECURITY_LINUX */
long EncodeUTCTime (BYTE *pbEncoded, time_t Time, BOOL Writeflag);
#endif /* SECURITY_LINUX */

#ifndef SECURITY_LINUX
long
DecodeFileTime(
    FILETIME *  pTime,
    BYTE *      pbEncoded,
    DWORD       cEncoded,
    BOOL        WriteFlag);
#else /* SECURITY_LINUX */
long DecodeUTCTime (time_t *pTime, BYTE *pbEncoded, DWORD cEncoded, BOOL Writeflag);

#define DecodeFileTime DecodeUTCTime
#endif /* SECURITY_LINUX */

long
DecodeNull(
    BYTE *  pbEncoded, DWORD cEncoded);

long
DecodeDN(
    PSTR    pName,
    DWORD * pdwLen,
    BYTE *  pbEncoded,
    DWORD   cEncoded,
    BOOL    WriteFlag);

long
DecodeSigAlg(
    DWORD *         pAlgId,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);

long
DecodeCryptAlg(
    DWORD *         pAlgId,
    DWORD *         pHashid,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);

long
DecodeKeyType(
    DWORD *         pKeyType,
    PBYTE           pbEncoded,
    DWORD           cEncoded,
    BOOL            WriteFlag);

//long
//DecodePrivateKeyFile(
//    PctPrivateKey  **   ppKey,
//    PBYTE               pbEncoded,
//    DWORD               cbEncoded,
//    PSTR                Password );


#endif  /* _ENCODE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iisrtl\alloc.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    Alloc.cpp

Abstract:
    Custom heap allocator

   Author:
       George V. Reilly      (GeorgeRe)     Oct-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/11/1999 - Initial

--*/

#include "precomp.hxx"
#include "alloc.h"
#include <irtldbg.h>


// Private heap for IIS

HANDLE g_hHeap = NULL;

BOOL
WINAPI
IisHeapInitialize()
{
    g_hHeap = ::HeapCreate(0, 0, 0);
    return (g_hHeap != NULL);
}

VOID
WINAPI
IisHeapTerminate()
{
    if (g_hHeap)
    {
        IRTLVERIFY(::HeapDestroy(g_hHeap));
        g_hHeap = NULL;
    }
}

// Private IIS heap
HANDLE
WINAPI 
IisHeap()
{
    IRTLASSERT(g_hHeap != NULL);
    return g_hHeap;
}

// Allocate dwBytes
LPVOID
WINAPI
IisMalloc(
    IN SIZE_T dwBytes)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapAlloc( g_hHeap, 0, dwBytes );
}

// Allocate dwBytes. Memory is zeroed
LPVOID
WINAPI
IisCalloc(
    IN SIZE_T dwBytes)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapAlloc( g_hHeap, HEAP_ZERO_MEMORY, dwBytes );
}

// Reallocate lpMem to dwBytes
LPVOID
WINAPI
IisReAlloc(
    IN LPVOID lpMem,
    IN SIZE_T dwBytes)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapReAlloc( g_hHeap, 0, lpMem, dwBytes);
}

// Free lpMem
BOOL
WINAPI
IisFree(
    IN LPVOID lpMem)
{
    IRTLASSERT(g_hHeap != NULL);
    return ::HeapFree( g_hHeap, 0, lpMem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iismap\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved



#include <nt.h>
#define UINT4   ULONG

#include "immd5.h"


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#if CT_COMPILER == CT_MPW

/* MPW doesn't compile the macro correctly, so use a procedure. */
static UINT4 RotateLeft (UINT4, unsigned int);
#define ROTATE_LEFT RotateLeft

#else
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
#endif

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

void MD5Init (mdContext)
MD5_CTX *mdContext;
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

void MD5Update (mdContext, inBuf, inLen)
MD5_CTX *mdContext;
unsigned char *inBuf;
unsigned int inLen;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

void MD5Final (mdContext)
MD5_CTX *mdContext;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (buf, in)
UINT4 *buf;
UINT4 *in;
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}

#if CT_COMPILER == CT_MPW
static UINT4 RotateLeft (x, n)
UINT4 x;
unsigned int n;
{
  return (((x) << (n)) | ((x) >> (32-(n))));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iismap\memalloc.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    memalloc.c

Abstract:

    Memory allocator for the crypto routines.

        IISCryptoAllocMemory
        IISCryptoFreeMemory

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


extern "C" {


#include <iiscrypt.h>



PVOID
WINAPI
IISCryptoAllocMemory(
    IN DWORD Size
    )
{

    return (PVOID)LocalAlloc( LPTR, Size );

}   // IISCryptoAllocateMemory


VOID
WINAPI
IISCryptoFreeMemory(
    IN PVOID Buffer
    )
{

    (VOID)LocalFree( (HLOCAL)Buffer );

}   // IISCryptoFreeMemory


}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iismap\iismaprc.h ===
#define     IDS_IISMAP_FLD0             200
#define     IDS_IISMAP_FLD1             201
#define     IDS_IISMAP_FLD2             202
#define     IDS_IISMAP_FLD3             203
#define     IDS_IISMAP_FLD4             204
#define     IDS_IISMAP_FLD5             205
#define     IDS_IISMAP_FLD6             206
#define     IDS_IISMAP_FLD7             207

#define     IDS_ITAIISMAP_FLD0          300
#define     IDS_ITAIISMAP_FLD1          301
#define     IDS_ITAIISMAP_FLD2          302

#define     IDS_MD5IISMAP_FLD0          400
#define     IDS_MD5IISMAP_FLD1          401
#define     IDS_MD5IISMAP_FLD2          402
#define     IDS_MD5IISMAP_FLD3          403
#define     IDS_MD5IISMAP_FLD4          404
#define     IDS_MD5IISMAP_FLD5          405

#define     IDS_IISMAP11_FLDS           500
#define     IDS_IISMAP11_FLDI           501
#define     IDS_IISMAP11_FLDA           502
#define     IDS_IISMAP11_FLDC           503
#define     IDS_IISMAP11_FLDN           504
#define     IDS_IISMAP11_FLDE           505
#define     IDS_IISMAP11_FLDP           506

#define     IDS_CMR_ASN_C               600
#define     IDS_CMR_ASN_O               601
#define     IDS_CMR_ASN_OU              602
#define     IDS_CMR_ASN_CN              603
#define     IDS_CMR_ASN_L               604
#define     IDS_CMR_ASN_S               605
#define     IDS_CMR_ASN_T               606
#define     IDS_CMR_ASN_GN              607
#define     IDS_CMR_ASN_I               608
#define     IDS_CMR_ASN_Email           609
#define     IDS_CMR_ASN_Addr            610

#define     IDS_CMR_X509FLD_IS          700
#define     IDS_CMR_X509FLD_SU          701
#define     IDS_CMR_X509FLD_SN          702
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iismap\iiscmr.cxx ===
/*++



Copyright (c) 1996  Microsoft Corporation

Module Name:

    iiscmr.cxx

Abstract:

    Classes to handle cert wildcard mapping

Author:

    Philippe Choquier (phillich)    17-oct-1996

--*/

#define _CRYPT32_
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <schnlsp.h>
//#include <crypt32l.h>
#if 1 // DBCS
#include <mbstring.h>
#endif

#include "xbf.hxx"
extern "C" {
#include <immd5.h>
}
#include <iis64.h>
#include <iismap.hxx>
#include "iismaprc.h"
#include "mapmsg.h"
#include <iiscmr.hxx>
#include <icrypt.hxx>
#include <dbgutil.h>

typedef
WINCRYPT32API
PCCERT_CONTEXT
(WINAPI* PFNCertCreateCertificateContext)(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded
    );

typedef
WINCRYPT32API
BOOL
(WINAPI* PFNCertFreeCertificateContext)(
    IN PCCERT_CONTEXT pCertContext
    );

typedef
WINCRYPT32API
BOOL
(WINAPI* PFNCryptDecodeObject)(
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT void        *pvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    );

typedef
WINCRYPT32API
BOOL
(WINAPI* PFNCertGetCertificateContextProperty)(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

//
// GLOBALS
//


//
// definition of ASN.1 <> X.509 name conversion
//

MAP_ASN aMapAsn[] = {
    { szOID_COUNTRY_NAME, "", IDS_CMR_ASN_C },
    { szOID_ORGANIZATION_NAME, "", IDS_CMR_ASN_O },
    { szOID_ORGANIZATIONAL_UNIT_NAME, "", IDS_CMR_ASN_OU },
    { szOID_COMMON_NAME, "", IDS_CMR_ASN_CN },
    { szOID_LOCALITY_NAME, "", IDS_CMR_ASN_L },
    { szOID_STATE_OR_PROVINCE_NAME, "", IDS_CMR_ASN_S },
    { szOID_TITLE, "", IDS_CMR_ASN_T },
    { szOID_GIVEN_NAME, "", IDS_CMR_ASN_GN },
    { szOID_INITIALS, "", IDS_CMR_ASN_I },
    { "1.2.840.113549.1.9.1", "", IDS_CMR_ASN_Email },
    { "1.2.840.113549.1.9.8", "", IDS_CMR_ASN_Addr },   // warning: can include CR/LF
} ;

HINSTANCE hSchannel = NULL;
HINSTANCE hCapi2Lib = NULL;
SSL_GET_ISSUERS_FN  pfnGetDefaultIssuers = NULL;
PFNCertCreateCertificateContext
    pfnCertCreateCertificateContext = NULL;
PFNCertFreeCertificateContext
    pfnCertFreeCertificateContext = NULL;
PFNCryptDecodeObject
    pfnCryptDecodeObject = NULL;
PFNCertGetCertificateContextProperty
    pfnCertGetCertificateContextProperty = NULL;

char HEXTOA[] = "0123456789abcdef";


MAP_FIELD aMapField[] = {
    { CERT_FIELD_ISSUER, IDS_CMR_X509FLD_IS, "" },
    { CERT_FIELD_SUBJECT, IDS_CMR_X509FLD_SU, "" },
    { CERT_FIELD_SERIAL_NUMBER, IDS_CMR_X509FLD_SN, "" },
} ;


DWORD adwFieldFlags[]={
    CERT_FIELD_FLAG_CONTAINS_SUBFIELDS,
    CERT_FIELD_FLAG_CONTAINS_SUBFIELDS,
    0,
};

//
// Global functions
//

BOOL
Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    LPDWORD pU
    )
/*++

Routine Description:

    Unserialize a DWORD
    pU is updated with DWORD from *ppB, ppB & pC are updated

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer
    pU - ptr to DWORD where to unserialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD dwTemp; // added to handle 64 bit alignment problems
    if ( *pC >= sizeof( DWORD ) )
    {
        dwTemp = **ppB;
        *pU = dwTemp;
        *ppB += sizeof(DWORD);
        *pC -= sizeof(DWORD);
        return TRUE;
    }

    return FALSE;
}


BOOL
Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    LPBOOL pU
    )
/*++

Routine Description:

    Unserialize a BOOL
    pU is updated with BOOL from *ppB, ppB & pC are updated

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer
    pU - ptr to BOOL where to unserialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL bTemp; // added to handle 64 bit alignment problems
    if ( *pC >= sizeof( BOOL ) )
    {
        bTemp = **ppB;
        *pU = bTemp;
        *ppB += sizeof(BOOL);
        *pC -= sizeof(BOOL);
        return TRUE;
    }

    return FALSE;
}


//
// Extensible buffer class
//

BOOL
CStoreXBF::Need(
    DWORD dwNeed
    )
/*++

Routine Description:

    Insure that CStoreXBF can store at least dwNeed bytes
    including bytes already stored.

Arguments:

    dwNeed - minimum of bytes available for storage

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( dwNeed > m_cAllocBuff )
    {
        dwNeed = ((dwNeed + m_cGrain)/m_cGrain)*m_cGrain;
        LPBYTE pN = (LPBYTE)LocalAlloc( LMEM_FIXED, dwNeed );
        if ( pN == NULL )
        {
            return FALSE;
        }
        if ( m_cUsedBuff )
        {
            memcpy( pN, m_pBuff, m_cUsedBuff );
        }
        m_cAllocBuff = dwNeed;
        LocalFree( m_pBuff );
        m_pBuff = pN;
    }
    return TRUE;
}

BOOL
CStoreXBF::Save(
    HANDLE hFile
    )
/*++

Routine Description:

    Save to file

Arguments:

    hFile - file handle

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD dwWritten;

    return WriteFile( hFile, GetBuff(), GetUsed(), &dwWritten, NULL ) &&
           dwWritten == GetUsed();
}


BOOL
CStoreXBF::Load(
    HANDLE hFile
    )
/*++

Routine Description:

    Load from file

Arguments:

    hFile - file handle

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD   dwS = GetFileSize( hFile, NULL );
    DWORD   dwRead;

    if ( dwS != 0xffffffff &&
         Need( dwS ) &&
         ReadFile( hFile, GetBuff(), dwS, &dwRead, NULL ) &&
         dwRead == dwS )
    {
        m_cUsedBuff = dwRead;

        return TRUE;
    }

    m_cUsedBuff = 0;

    return FALSE;
}



BOOL
Serialize(
    CStoreXBF* pX,
    DWORD dw
    )
/*++

Routine Description:

    Serialize a DWORD in CStoreXBF

Arguments:

    pX - ptr to CStoreXBF where to add serialized DWORD
    dw - DWORD to serialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return pX->Append( (LPBYTE)&dw, sizeof(dw) );
}


BOOL
Serialize(
    CStoreXBF* pX,
    BOOL f
    )
/*++

Routine Description:

    Serialize a BOOL in CStoreXBF

Arguments:

    pX - ptr to CStoreXBF where to add serialized BOOL
    f - BOOL to serialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return pX->Append( (LPBYTE)&f, sizeof(f) );
}


DWORD
CPtrXBF::AddPtr(
    LPVOID pV
    )
/*++

Routine Description:

    Add a ptr to array

Arguments:

    pV - ptr to be added at end of array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i = GetNbPtr();
    if ( Append( (LPBYTE)&pV, sizeof(pV)) )
    {
        return i;
    }
    return INDEX_ERROR;
}


DWORD
CPtrXBF::InsertPtr(
    DWORD iBefore,
    LPVOID pV
    )
/*++

Routine Description:

    Insert a ptr to array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pV - ptr to be inserted

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    if ( iBefore == INDEX_ERROR || iBefore >= GetNbPtr() )
    {
        return AddPtr( pV );
    }
    if ( AddPtr( NULL ) != INDEX_ERROR )
    {
        memmove( GetBuff()+(iBefore+1)*sizeof(LPVOID),
                 GetBuff()+iBefore*sizeof(LPVOID),
                 GetUsed()-(iBefore+1)*sizeof(LPVOID) );

        SetPtr( iBefore, pV );

        return iBefore;
    }
    return INDEX_ERROR;
}


BOOL
CPtrXBF::DeletePtr(
    DWORD i
    )
/*++

Routine Description:

    Delete a ptr from array

Arguments:

    i - index of ptr to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    memmove( GetBuff()+i*sizeof(LPVOID),
             GetBuff()+(i+1)*sizeof(LPVOID),
             GetUsed()-(i+1)*sizeof(LPVOID) );

    DecreaseUse( sizeof(LPVOID) );

    return TRUE;
}


BOOL
CPtrXBF::Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    DWORD cNbEntry
    )
/*++

Routine Description:

    Unserialize a ptr array

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer
    cNbEntry - # of ptr to unserialize from buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    Reset();
    if ( *pC >= cNbEntry * sizeof(LPVOID) &&
         Append( *ppB, cNbEntry * sizeof(LPVOID) ) )
    {
        *ppB += cNbEntry * sizeof(LPVOID);
        *pC -= cNbEntry * sizeof(LPVOID);

        return TRUE;
    }

    return FALSE;
}


BOOL
CPtrXBF::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a ptr array

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return pX->Append( (LPBYTE)GetBuff(), (DWORD)GetUsed() );
}


DWORD
CPtrDwordXBF::AddPtr(
    DWORD pV
    )
/*++

Routine Description:

    Add a ptr to array

Arguments:

    pV - ptr to be added at end of array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i = GetNbPtr();
    if ( Append( (LPBYTE)&pV, sizeof(pV)) )
    {
        return i;
    }
    return INDEX_ERROR;
}


DWORD
CPtrDwordXBF::InsertPtr(
    DWORD iBefore,
    DWORD pV
    )
/*++

Routine Description:

    Insert a ptr to array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pV - ptr to be inserted

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    if ( iBefore == INDEX_ERROR || iBefore >= GetNbPtr() )
    {
        return AddPtr( pV );
    }
    if ( AddPtr( NULL ) != INDEX_ERROR )
    {
        memmove( GetBuff()+(iBefore+1)*sizeof(DWORD),
                 GetBuff()+iBefore*sizeof(DWORD),
                 GetUsed()-(iBefore+1)*sizeof(DWORD) );

        SetPtr( iBefore, pV );

        return iBefore;
    }
    return INDEX_ERROR;
}


BOOL
CPtrDwordXBF::DeletePtr(
    DWORD i
    )
/*++

Routine Description:

    Delete a ptr from array

Arguments:

    i - index of ptr to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    memmove( GetBuff()+i*sizeof(DWORD),
             GetBuff()+(i+1)*sizeof(DWORD),
             GetUsed()-(i+1)*sizeof(DWORD) );

    DecreaseUse( sizeof(LPVOID) );

    return TRUE;
}


BOOL
CPtrDwordXBF::Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    DWORD cNbEntry
    )
/*++

Routine Description:

    Unserialize a ptr array

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer
    cNbEntry - # of ptr to unserialize from buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    Reset();
    if ( *pC >= cNbEntry * sizeof(DWORD))
    {
        if (Append( *ppB, cNbEntry * sizeof(DWORD) ))
        {
          *ppB += cNbEntry * sizeof(DWORD);
          *pC -= cNbEntry * sizeof(DWORD);
          return TRUE;
         }
    }

    return FALSE;
}


BOOL
CPtrDwordXBF::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a ptr array

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return pX->Append( (LPBYTE)GetBuff(), (DWORD)GetUsed() );
}



BOOL
CAllocString::Set(
    LPSTR pS
    )
/*++

Routine Description:

    Set a string content, freeing prior content if any

Arguments:

    pS - string to copy

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    size_t l;
    Reset();
    if ( m_pStr = (LPSTR)LocalAlloc( LMEM_FIXED, l = strlen(pS)+1 ) )
    {
        memcpy( m_pStr, pS, l );

        return TRUE;
    }
    return FALSE;
}


BOOL
CAllocString::Append(
    LPSTR pS
    )
/*++

Routine Description:

    Append a string content

Arguments:

    pS - string to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    size_t l = m_pStr ? strlen(m_pStr ) : 0;
    size_t nl;
    LPSTR pStr;

    if ( pStr = (LPSTR)LocalAlloc( LMEM_FIXED, l + (nl = strlen(pS)+1 )) )
    {
        memcpy( pStr, m_pStr, l );
        memcpy( pStr+l, pS, nl );

        //
        // Free the old block before we blow it away.
        //

        Reset();

        m_pStr = pStr;

        return TRUE;
    }
    return FALSE;
}


BOOL
CAllocString::Unserialize(
    LPBYTE* ppb,
    LPDWORD pc
    )
/*++

Routine Description:

    Unserialize a string

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD   dwL;

    if ( ::Unserialize( ppb, pc, &dwL ) &&
         (m_pStr = (LPSTR)LocalAlloc( LMEM_FIXED, dwL + 1)) )
    {
        memcpy( m_pStr, *ppb, dwL );
        m_pStr[dwL] = '\0';

        *ppb += dwL;
        *pc -= dwL;

        return TRUE;
    }
    return FALSE;
}


BOOL
CAllocString::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a string

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPSTR pS = m_pStr ? m_pStr : "";

    return ::Serialize( pX, (DWORD)strlen(pS) ) && pX->Append( pS );
}


BOOL
CBlob::Set(
    LPBYTE pStr,
    DWORD cStr
    )
/*++

Routine Description:

    Store a buffer in a blob object
    buffer is copied inside blob
    blob is reset before copy

Arguments:

    pStr - ptr to buffer to copy
    cStr - length of buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    Reset();

    return InitSet( pStr, cStr);
}


BOOL
CBlob::InitSet(
    LPBYTE pStr,
    DWORD cStr
    )
/*++

Routine Description:

    Store a buffer in a blob object
    buffer is copied inside blob
    blob is not reset before copy, initial blob content ignored

Arguments:

    pStr - ptr to buffer to copy
    cStr - length of buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_pStr = (LPBYTE)LocalAlloc( LMEM_FIXED, cStr ) )
    {
        memcpy( m_pStr, pStr, cStr );
        m_cStr = cStr;

        return TRUE;
    }
    return FALSE;
}


BOOL
CBlob::Unserialize(
    LPBYTE* ppB,
    LPDWORD pC
    )
/*++

Routine Description:

    Unserialize a blob

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    Reset();

    if ( ::Unserialize( ppB, pC, &m_cStr ) &&
         *pC >= m_cStr &&
         ( m_pStr = (LPBYTE)LocalAlloc( LMEM_FIXED, m_cStr ) ) )
    {
        memcpy( m_pStr, *ppB, m_cStr );

        *ppB += m_cStr;
        *pC -= m_cStr;
    }
    else
    {
        m_cStr = 0;
        return FALSE;
    }

    return TRUE;
}


BOOL
CBlob::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a blob

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return ::Serialize( pX, m_cStr ) &&
           pX->Append( m_pStr, m_cStr );
}


CStrPtrXBF::~CStrPtrXBF(
    )
/*++

Routine Description:

    CStrPtrXBF destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DWORD iM = GetNbPtr();
    UINT i;
    for ( i = 0 ; i < iM ; ++i )
    {
        ((CAllocString*)GetPtrAddr(i))->Reset();
    }
}


DWORD
CStrPtrXBF::AddEntry(
    LPSTR pS
    )
/*++

Routine Description:

    Add a string to array
    string content is copied in array

Arguments:

    pS - string to be added at end of array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i;

    if ( (i = AddPtr( NULL )) != INDEX_ERROR )
    {
        return ((CAllocString*)GetPtrAddr(i))->Set( pS ) ? i : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


DWORD
CStrPtrXBF::InsertEntry(
    DWORD iBefore,
    LPSTR pS
    )
/*++

Routine Description:

    Insert a string in array
    string content is copied in array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pS - string to be inserted in array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i;

    if ( (i = InsertPtr( iBefore, NULL )) != INDEX_ERROR )
    {
        return ((CAllocString*)GetPtrAddr(i))->Set( pS ) ? i : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


BOOL
CStrPtrXBF::DeleteEntry(
    DWORD i
    )
/*++

Routine Description:

    Delete a string from array

Arguments:

    i - index of string to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( i < GetNbPtr() )
    {
        ((CAllocString*)GetPtrAddr(i))->Reset();
        DeletePtr( i );

        return TRUE;
    }
    return FALSE;
}


BOOL
CStrPtrXBF::Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    DWORD cNbEntry
    )
/*++

Routine Description:

    Unserialize a string array

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer
    cNbEntry - # of entry to unserialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT i;

    Reset();

    CAllocString empty;
    for ( i = 0 ; i < cNbEntry ; ++i )
    {
        if ( !Append( (LPBYTE)&empty, sizeof(empty)) ||
             !((CAllocString*)GetPtrAddr(i))->Unserialize( ppB, pC ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


BOOL
CStrPtrXBF::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a string array

Arguments:

    pX - ptr to CStoreXBF where to add serialized DWORD

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT i;

    for ( i = 0 ; i < GetNbEntry() ; ++i )
    {
        if ( !((CAllocString*)GetPtrAddr(i))->Serialize( pX ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


CBlobXBF::~CBlobXBF(
    )
/*++

Routine Description:

    CBlobXBF destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DWORD iM = GetUsed()/sizeof(CBlob);
    UINT i;
    for ( i = 0 ; i < iM ; ++i )
    {
        GetBlob(i)->Reset();
    }
}


VOID CBlobXBF::Reset(
    )
/*++

Routine Description:

    Reset the blob content to NULL

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DWORD iM = GetUsed()/sizeof(CBlob);
    UINT i;
    for ( i = 0 ; i < iM ; ++i )
    {
        GetBlob(i)->Reset();
    }
    CStoreXBF::Reset();
}


DWORD
CBlobXBF::AddEntry(
    LPBYTE pS,
    DWORD cS
    )
/*++

Routine Description:

    Add a buffer to blob array
    buffer content is copied in array

Arguments:

    pS - buffer to be added at end of array
    cS - length of buffer

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i = GetNbEntry();

    if ( Append( (LPBYTE)&pS, sizeof(CBlob) ) )
    {
        return GetBlob(i)->InitSet( pS, cS ) ? i : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


DWORD
CBlobXBF::InsertEntry(
    DWORD iBefore,
    LPSTR pS,
    DWORD cS )
/*++

Routine Description:

    Insert a buffer in blob array
    buffer content is copied in array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pS - buffer to be inserted in array
    cS - length of buffer

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i;

    if ( iBefore == INDEX_ERROR || iBefore >= GetNbEntry() )
    {
        return AddEntry( (LPBYTE)pS, cS );
    }

    if ( iBefore < GetNbEntry() && Append( (LPBYTE)&pS, sizeof(CBlob) ) )
    {
        memmove( GetBuff()+(iBefore+1)*sizeof(CBlob),
                 GetBuff()+iBefore*sizeof(CBlob),
                 GetUsed()-(iBefore+1)*sizeof(CBlob) );

        return GetBlob(iBefore)->InitSet( (LPBYTE)pS, cS ) ? iBefore : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


BOOL
CBlobXBF::DeleteEntry(
    DWORD i
    )
/*++

Routine Description:

    Delete a entry from blob array

Arguments:

    i - index of string to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( i < GetNbEntry() )
    {
        GetBlob(i)->Reset();

        memmove( GetBuff()+i*sizeof(CBlob),
                 GetBuff()+(i+1)*sizeof(CBlob),
                 GetUsed()-(i+1)*sizeof(CBlob) );

        DecreaseUse( sizeof(CBlob) );

        return TRUE;
    }
    return FALSE;
}


BOOL
CBlobXBF::Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    DWORD cNbEntry )
/*++

Routine Description:

    Unserialize a blob array

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer
    cNbEntry - # of ptr to unserialize from buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT i;

    Reset();

    CBlob empty;
    for ( i = 0 ; i < cNbEntry ; ++i )
    {
        if ( !Append( (LPBYTE)&empty, sizeof(empty) ) ||
             !GetBlob(i)->Unserialize( ppB, pC ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


BOOL
CBlobXBF::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a blob array

Arguments:

    pX - ptr to CStoreXBF where to add serialized blob

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT i;

    for ( i = 0 ; i < GetNbEntry() ; ++i )
    {
        if ( !GetBlob(i)->Serialize( pX ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


CDecodedCert::CDecodedCert(
    PCERT_CONTEXT   pCert
    )
/*++

Routine Description:

    Constructor
    Store a reference to cert ( cert data is NOT copied )

Arguments:

    pCert - cert

Return Value:

    Nothing

--*/
{
    UINT    i;

    for ( i = 0 ; i < CERT_FIELD_LAST ; ++i )
    {
        aniFields[i] = NULL;
    }
    pCertCtx = (PCCERT_CONTEXT)pCert;

}


CDecodedCert::~CDecodedCert(
    )
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    UINT    i;

    for ( i = 0 ; i < CERT_FIELD_LAST ; ++i )
    {
       if ( aniFields[i] != NULL )
       {
           LocalFree( aniFields[i] );
       }
    }
}


BOOL
CDecodedCert::GetIssuer(
    LPVOID* ppCert,
    LPDWORD pcCert
    )
/*++

Routine Description:

    Get the issuer portion of a cert
    Returns a reference : issuer is NOT copied

Arguments:

    ppCert - updated with ptr to issuer
    pcCert - updated with issuer byte count

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( pCertCtx == NULL )
    {
        return FALSE;
    }

    *ppCert = pCertCtx->pCertInfo->Issuer.pbData;
    *pcCert = pCertCtx->pCertInfo->Issuer.cbData;

    return TRUE;
}

PCERT_RDN_ATTR *
CDecodedCert::GetSubField(
    CERT_FIELD_ID fi,
    LPSTR pszAsnName,
    LPDWORD pcElements
    )
/*++

Routine Description:

    Returns a cert sub-field ( e.g. Issuer.O ).  There may be multiple entries
    for a given subfield.  This functions returns an array of attribute values

Arguments:

    fi - cert field where sub-field is located
    pszAsnName - ASN.1 name of sub-field inside fi
    pcElements - Number of elements returned in array

Return Value:

    ptr to array of pointers to attribute blobs if success, otherwise NULL

--*/
{
    CERT_NAME_BLOB* pBlob;
    DWORD           cbNameInfo;
    PCERT_NAME_INFO pNameInfo;
    DWORD           cRDN;
    DWORD           cAttr;
    PCERT_RDN       pRDN;
    PCERT_RDN_ATTR  pAttr;
    PCERT_RDN_ATTR* pAttrValues = NULL;
    DWORD           cRet = 0;
    DWORD           cMaxRet = 0;

    if ( pfnCertCreateCertificateContext == NULL ||
         pfnCryptDecodeObject == NULL )
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return NULL;
    }

    *pcElements = 0;

    switch( fi )
    {
        case CERT_FIELD_ISSUER:
            pBlob = &pCertCtx->pCertInfo->Issuer;
            break;

        case CERT_FIELD_SUBJECT:
            pBlob = &pCertCtx->pCertInfo->Subject;
            break;

        case CERT_FIELD_SERIAL_NUMBER:
            pAttrValues = (PCERT_RDN_ATTR*)
                         LocalAlloc( LPTR, sizeof( PCERT_RDN_ATTR ) );
            if ( pAttrValues == NULL )
            {
                return NULL;
            }
            *pcElements = 1;

            //
            // Setup a CERT_RDN_ATTR so that GetSubField() can always return a 
            // pointer to an array of CERT_RDN_ATTRs
            //
    
            SerialNumber.dwValueType = CERT_RDN_OCTET_STRING;
            SerialNumber.Value = pCertCtx->pCertInfo->SerialNumber;
        
            pAttrValues[ 0 ] = &SerialNumber;
            return pAttrValues;

        default:
            return NULL;
    }

    if ( pszAsnName == NULL )
    {
        return NULL;
    }

    if ( (pNameInfo = aniFields[fi]) == NULL )
    {
        if (!(*pfnCryptDecodeObject)(X509_ASN_ENCODING,
                          (LPCSTR)X509_NAME,
                          pBlob->pbData,
                          pBlob->cbData,
                          0,
                          NULL,
                          &cbNameInfo))
        {
            return NULL;
        }

        if (NULL == (pNameInfo = (PCERT_NAME_INFO)LocalAlloc(LMEM_FIXED,cbNameInfo)))
        {
            return NULL;
        }

        if (!(*pfnCryptDecodeObject)(X509_ASN_ENCODING,
                            (LPCSTR)X509_NAME,
                            pBlob->pbData,
                            pBlob->cbData,
                            0,
                            pNameInfo,
                            &cbNameInfo))
        {
            LocalFree( pNameInfo );

            return NULL;
        }

        aniFields[fi] = pNameInfo;
    }

    for (cRDN = pNameInfo->cRDN, pRDN = pNameInfo->rgRDN; cRDN > 0; cRDN--, pRDN++)
    {
        for ( cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr ; cAttr > 0 ; cAttr--, ++pAttr )
        {
            if ( !strcmp( pAttr->pszObjId, pszAsnName ) )
            {
                if ( ( cRet + 1 ) > cMaxRet )
                {
                    cMaxRet += 10;

                    if ( pAttrValues )
                    {
                        pAttrValues = (PCERT_RDN_ATTR*)
                                        LocalReAlloc( pAttrValues,
                                                      sizeof( PCERT_RDN_ATTR ) * cMaxRet,
                                                      LMEM_MOVEABLE );
                    }
                    else
                    {
                        pAttrValues = (PCERT_RDN_ATTR*)
                                        LocalAlloc( LPTR,
                                                    sizeof( PCERT_RDN_ATTR ) * cMaxRet );
                    }

                    if ( pAttrValues == NULL )
                    {
                        return NULL;
                    }
                }

                pAttrValues[ cRet ] = pAttr;

                cRet++;

            }
        }
    }

    *pcElements = cRet;

    return pAttrValues;
}


CIssuerStore::CIssuerStore(
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );

    m_fValid = TRUE;
}


CIssuerStore::~CIssuerStore(
    )
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DeleteCriticalSection( &m_csLock );
}


BOOL
CIssuerStore::LoadServerAcceptedIssuers(
    )
/*++

Routine Description:

    Load the list of recognized issuers from schannel

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    //
    // IIS 5 : this should not get called any more because the list of
    // trusted issuers isn't specific to cert mapping any more but is done
    // at a virtual server level; also, the IIS 4 UI to set up such a list is
    // being removed
    //
    DBG_ASSERT( TRUE );

    MD5_CTX     md5;
    DWORD       dwLen = 0;
    LPBYTE      pCerts;
    BOOL        fSt = FALSE;
    UINT        i;

    if ( pfnGetDefaultIssuers &&
         (pfnGetDefaultIssuers)( NULL, &dwLen ) )
    {
        if ( !(pCerts = (LPBYTE)LocalAlloc( LMEM_FIXED, dwLen )) )
        {
            m_fValid = FALSE;

            return FALSE;
        }
        if ( (pfnGetDefaultIssuers)( pCerts, &dwLen ) )
        {
            fSt = TRUE;
            while ( dwLen && GETDBLEN(pCerts) <= dwLen )
            {
                CHAR achMd5[sizeof(md5.digest)*2 + 1];
                MD5Init( &md5 );
                MD5Update( &md5, pCerts + DBLEN_SIZE, GETDBLEN(pCerts) );
                MD5Final( &md5 );
                for ( i = 0 ; i < sizeof(md5.digest) ; ++i )
                {
                    achMd5[i*2] = HEXTOA[md5.digest[i]>>4];
                    achMd5[i*2+1] = HEXTOA[md5.digest[i]&0xf];
                }
                achMd5[sizeof(md5.digest)*2] = '\0';

                if ( m_pIssuerNames.AddEntry( achMd5 ) == INDEX_ERROR ||
                     m_IssuerCerts.AddEntry( pCerts + DBLEN_SIZE,
                                             (DWORD)GETDBLEN(pCerts) )
                        == INDEX_ERROR )
                {
                    m_fValid = FALSE;
                    fSt = FALSE;

                    break;
                }

                dwLen -= GETDBLEN(pCerts) + DBLEN_SIZE;
                pCerts += GETDBLEN(pCerts) + DBLEN_SIZE;
            }
        }
        LocalFree( pCerts );
    }

    return fSt;
}


VOID
CIssuerStore::Reset(
    )
/*++

Routine Description:

    Reset issuer list

Arguments:

    None

Return Value:

    None

--*/
{
    m_pIssuerNames.Reset();
    m_IssuerCerts.Reset();

    m_fValid = TRUE;
}


BOOL
CIssuerStore::Unserialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Unserialize issuer list

Arguments:

    pX - CStoreXBF to unserialize from

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE pb = pX->GetBuff();
    DWORD  dw = pX->GetUsed();

    return Unserialize( &pb, &dw );
}


BOOL
CIssuerStore::Unserialize(
    LPBYTE* ppb,
    LPDWORD pc
    )
/*++

Routine Description:

    Unserialize issuer list

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD dwC;

    Reset();

    if ( ::Unserialize( ppb, pc, &dwC ) &&
         m_pIssuerNames.Unserialize( ppb, pc, dwC ) &&
         m_IssuerCerts.Unserialize( ppb, pc, dwC ) )
    {
        return TRUE;
    }

    m_fValid = FALSE;
    return FALSE;
}


BOOL
CIssuerStore::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize issuer list

Arguments:

    pX - CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( !m_fValid )
    {
        return FALSE;
    }

    return ::Serialize( pX, (DWORD)GetNbIssuers() ) &&
           m_pIssuerNames.Serialize( pX ) &&
           m_IssuerCerts.Serialize( pX );
}


BOOL
CIssuerStore::GetIssuer(
    DWORD i,
    LPSTR* ppszIssuerName,
    LPBYTE* ppIssuer,
    LPDWORD pcIssuer
    )
/*++

Routine Description:

    Get issuer from list based on index

Arguments:

    i - index ( 0-based ) of issuer to retrieve
    ppszIssuerName - updated with ptr to issuer ID
    ppIssuer - updated with ptr to DER encoded issuer
    pcIssuer - updated with byte count in issuer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( !m_fValid )
    {
        return FALSE;
    }

    if ( (*ppszIssuerName = m_pIssuerNames.GetEntry( i )) &&
         m_IssuerCerts.GetEntry( i, ppIssuer, pcIssuer ) )
    {
        return TRUE;
    }

    return FALSE;
}


BOOL
CIssuerStore::GetIssuerByName(
    LPSTR pszIssuerName,
    LPBYTE* ppIssuer,
    LPDWORD pcIssuer
    )
/*++

Routine Description:

    Get issuer from list based on ID

Arguments:

    pszIssuerName - issuer ID
    ppIssuer - updated with ptr to DER encoded issuer
    pcIssuer - updated with byte count in issuer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT iI;
    UINT iMax;

    if ( !m_fValid )
    {
        return FALSE;
    }

    iMax = GetNbIssuers();
    for ( iI = 0 ; iI < iMax ; ++iI )
    {
        if ( !strcmp( pszIssuerName, m_pIssuerNames.GetEntry( iI ) ) )
        {
            return m_IssuerCerts.GetEntry( iI, ppIssuer, pcIssuer );
        }
    }
    return FALSE;
}


CCertGlobalRuleInfo::CCertGlobalRuleInfo(
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_fValid    = TRUE;
    m_fEnabled  = TRUE;
}


CCertGlobalRuleInfo::~CCertGlobalRuleInfo(
    )
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


BOOL
CCertGlobalRuleInfo::Reset(
    )
/*++

Routine Description:

    Reset to default values

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_Order.Reset();

    m_fValid    = TRUE;
    m_fEnabled  = TRUE;

    return TRUE;
}

BOOL
CCertGlobalRuleInfo::AddRuleOrder(
    )
/*++

Routine Description:

    Add a rule at end of rule order array

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD i;
    if ( (i = m_Order.AddPtr( NULL )) != INDEX_ERROR )
    {
//          m_Order.SetPtr( i, (LPVOID) i );
        m_Order.SetPtr( i, i );


        return TRUE;
    }
    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertGlobalRuleInfo::DeleteRuleById(
    DWORD dwId,
    BOOL DecrementAbove
    )
/*++

Routine Description:

    Delete a rule based on index in rules array

Arguments:

    dwId - index in rules array
    DecrementAbove - flag indicating if items with a index above dwID need
        to be decremented. This is usually caused by the item being removed
        from the main array.

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT iO;
    UINT iMax = m_Order.GetNbPtr();
    DWORD id;

    for ( iO = 0 ; iO < iMax ; ++iO )
    {
        // if it equals dwID, remove it
        if ( (DWORD_PTR)m_Order.GetPtr( iO ) == dwId )
        {
            m_Order.DeletePtr( iO );

            if ( DecrementAbove )
            {
                // if we have been asked to decrement the remaining items,
                // need to do this in another loop here. Yuck. - Boyd
                iMax = m_Order.GetNbPtr();
                for ( iO = 0 ; iO < iMax ; ++iO )
                {
                    // the id in question
                    id = (DWORD)((DWORD_PTR)m_Order.GetPtr( iO ));

                    // if it is bigger, decrement by one
                    if ( id > dwId )
                    {
                        id--;
                        // put it back in place
//                        m_Order.SetPtr( iO, (LPVOID) id );        //SUNDOWN ALERT
                        m_Order.SetPtr( iO, id );        //SUNDOWN ALERT
                    }
                }
            }


            // return early
            return TRUE;
        }
    }
    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertGlobalRuleInfo::SerializeGlobalRuleInfo(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize mapper global information

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return ::Serialize( pX, GetRuleOrderCount() ) &&
           pX->Append( (LPBYTE)GetRuleOrderArray(),
                sizeof(DWORD)*GetRuleOrderCount() ) &&
           ::Serialize( pX, m_fEnabled );
}


BOOL
CCertGlobalRuleInfo::UnserializeGlobalRuleInfo(
    LPBYTE* ppB,
    LPDWORD pC
    )
/*++

Routine Description:

    Unserialize mapper global info

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD dwO;

    Reset();

    return ::Unserialize( ppB, pC, &dwO ) &&
           m_Order.Unserialize( ppB, pC, dwO ) &&
           ::Unserialize( ppB, pC, &m_fEnabled );
}


CCertMapRule::CCertMapRule(
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_fEnabled          = TRUE;
    m_fDenyAccess       = FALSE;
    m_fMatchAllIssuers  = TRUE;
    m_fValid            = TRUE;
}


CCertMapRule::~CCertMapRule(
    )
/*++

Routine Description:

    Desctructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


VOID
CCertMapRule::Reset(
    )
/*++

Routine Description:

    Reset to default values

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_fEnabled          = TRUE;
    m_fDenyAccess       = FALSE;
    m_fMatchAllIssuers  = TRUE;
    m_fValid            = TRUE;
    m_asRuleName.Reset();
    m_asAccount.Reset();
    m_asPassword.Reset();
    m_ElemsContent.Reset();
    m_ElemsSubfield.Reset();
    m_ElemsField.Reset();
    m_ElemsFlags.Reset();
    m_Issuers.Reset();
    m_IssuersAcceptStatus.Reset();
}


BOOL
CCertMapRule::Unserialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Unserialize a mapping rule

Arguments:

    pX - ptr to CStoreXBF to unserialize from

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    LPBYTE pb = pX->GetBuff();
    DWORD  dw = pX->GetUsed();

    return Unserialize( &pb, &dw );
}




BOOL
CCertMapRule::Unserialize(
    LPBYTE* ppb,
    LPDWORD pc
    )
/*++

Routine Description:

    Unserialize a mapping rule

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD   dwEl;
    DWORD   dwIs;

    Reset();

    if ( m_asRuleName.Unserialize( ppb, pc ) &&
         m_asAccount.Unserialize( ppb, pc ) &&
         m_asPassword.Unserialize( ppb, pc ) &&
         ::Unserialize( ppb, pc, &m_fEnabled ) &&
         ::Unserialize( ppb, pc, &m_fDenyAccess ) &&
         ::Unserialize( ppb, pc, &dwEl ) &&
         m_ElemsContent.Unserialize( ppb, pc, dwEl ) &&
         m_ElemsSubfield.Unserialize( ppb, pc, dwEl ) &&
         m_ElemsField.Unserialize( ppb, pc, dwEl ) &&
         m_ElemsFlags.Unserialize( ppb, pc, dwEl ) &&
        ::Unserialize( ppb, pc, &dwIs ) &&
        m_Issuers.Unserialize( ppb, pc, dwIs ) &&
        m_IssuersAcceptStatus.Unserialize( ppb, pc, dwIs ) &&
        ::Unserialize( ppb, pc, &m_fMatchAllIssuers ) )
    {
        return TRUE;
    }

    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertMapRule::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a rule mapping in CStoreXBF

Arguments:

    pX - ptr to CStoreXBF where to add serialized DWORD

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD   dwEl;
    DWORD   dwIs;

    if ( m_fValid &&
         m_asRuleName.Serialize( pX ) &&
         m_asAccount.Serialize( pX ) &&
         m_asPassword.Serialize( pX ) &&
         ::Serialize( pX, m_fEnabled ) &&
         ::Serialize( pX, m_fDenyAccess ) &&
         ::Serialize( pX, GetRuleElemCount() ) &&
         m_ElemsContent.Serialize( pX ) &&
         m_ElemsSubfield.Serialize( pX ) &&
         m_ElemsField.Serialize( pX ) &&
         m_ElemsFlags.Serialize( pX ) &&
         ::Serialize( pX, m_Issuers.GetNbEntry() ) &&
        m_Issuers.Serialize( pX ) &&
        m_IssuersAcceptStatus.Serialize( pX ) &&
        ::Serialize( pX, m_fMatchAllIssuers ) )
    {
        return TRUE;
    }
    return FALSE;
}


BOOL
CCertMapRule::SetRuleAccount(
    LPSTR pszAcct
    )
/*++

Routine Description:

    Set NT account returned by this rule if match

Arguments:

    pszAcct - NT account to use

Return Value:

    TRUE if successful, FALSE on error
    error ERROR_INVALID_NAME if replacement name ( %subfield% ) invalid

--*/
{
    LPSTR pR;
    LPSTR pD;

    //
    // Check replacement field valid
    //

    if ( pR = strchr( pszAcct, '%' ) )
    {
        ++pR;

        if ( !(pD = strchr( pR, '%' )) )
        {
            SetLastError( ERROR_INVALID_NAME );

            return FALSE;
        }
        *pD = '\0';
        if ( !MapSubFieldToAsn1( pR ) )
        {
            *pD = '%';

            SetLastError( ERROR_INVALID_NAME );

            return FALSE;
        }
        *pD = '%';
    }

    return m_asAccount.Set( pszAcct );
}


// return ERROR_INVALID_NAME if no match
BOOL
CCertMapRule::Match(
    CDecodedCert*   pC,
    CDecodedCert*   pAuth,
    LPSTR           pszAcct,
    LPSTR           pszPwd,
    LPBOOL          pfDenied
    )
/*++

Routine Description:

    Check if rule match certificate

Arguments:

    pC - client certificate
    pAuth - certifying authority
    pszAcct - updated with NT account on success,
        assumed to be at least UNLEN+DNLEN+1 long
    pszPwd - updated with NT password on success,
        assumed to be at least UNLEN long
    pfDenied - updated with deny access status for this match on success
        TRUE if access is denied for this match, otherwise FALSE

Return Value:

    TRUE if successful, FALSE on error
    Errors:
        ERROR_ARENA_TRASHED if rule internal state is invalid
        ERROR_INVALID_NAME if no match

--*/
{
    UINT    i;
    UINT    iMax;
    DWORD   cObjLen;
    DWORD   cMatch = 0;
    BOOL    fSt;
    LPBYTE  pMatch = NULL;
    INT     iRet;
    BOOL    fCaseInsensitive;
    PCERT_RDN_ATTR * pAttrValues;
    DWORD   cAttrValues;
    DWORD   cAttr;
    PBYTE   pContent;
    BOOL    fConverted;
    PBYTE   pConverted;

    if ( !m_fEnabled )
    {
        return FALSE;
    }

    if ( !m_fValid )
    {
        SetLastError( ERROR_ARENA_TRASHED );

        return FALSE;
    }

    iMax = GetRuleElemCount();

    for ( i = 0 ; i < iMax ; ++i )
    {
        m_ElemsContent.GetEntry( i, &pMatch, &cMatch );
        --cMatch;
        
        if( pAttrValues = pC->GetSubField(
                (CERT_FIELD_ID)((UINT_PTR)m_ElemsField.GetPtr(i)),
                m_ElemsSubfield.GetEntry( i ), &cAttrValues ) )
        {
            fCaseInsensitive = (DWORD)((DWORD_PTR)m_ElemsFlags.GetPtr(i) & CMR_FLAGS_CASE_INSENSITIVE);

            for ( cAttr = 0;
                  cAttr < cAttrValues;
                  cAttr++ )
            {
                fConverted = FALSE;
            
                pContent = pAttrValues[ cAttr ]->Value.pbData;
                cObjLen = pAttrValues[ cAttr ]->Value.cbData;

                if ( pAttrValues[ cAttr ]->dwValueType == CERT_RDN_UNICODE_STRING )
                {
                    WCHAR *                     pNewBuffer;
                    
                    cObjLen /= sizeof( WCHAR );
                    
                    //
                    // Convert UNICODE cert value to multibyte
                    //
                    
                    iRet = WideCharToMultiByte( CP_ACP,
                                                0,
                                                (WCHAR*) pContent,
                                                cObjLen,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL );
                    if ( !iRet )
                    {
                        fSt = FALSE;
                        break;
                    }
                    
                    pConverted = (PBYTE) LocalAlloc( LPTR, iRet );
                    if ( pConverted == NULL )
                    {
                        fSt = FALSE;
                        break;
                    }
                    
                    iRet = WideCharToMultiByte( CP_ACP,
                                                0,
                                                (WCHAR*) pContent,
                                                cObjLen,
                                                (CHAR*) pConverted,
                                                iRet,
                                                NULL,
                                                NULL );
                    if ( !iRet )
                    {
                        fSt = FALSE;
                        LocalFree( pConverted );
                        break;
                    }
                    
                    fConverted = TRUE;
                    pContent = (PBYTE) pConverted;
                    cObjLen = iRet;
                }
                    
                switch ( pMatch[0] )
                {
                    case MATCH_ALL:
                        fSt = cObjLen == cMatch &&
                                ( fCaseInsensitive ?
                                    !_memicmp( pMatch+1, pContent, cObjLen ) :
                                    !memcmp( pMatch+1, pContent, cObjLen ) );
                        break;

                    case MATCH_FIRST:
                        fSt = cObjLen >= cMatch &&
                                ( fCaseInsensitive ?
                                    !_memicmp( pMatch+1, pContent, cMatch ) :
                                    !memcmp( pMatch+1, pContent, cMatch ) );
                        break;

                    case MATCH_LAST:
                        fSt = cObjLen >= cMatch &&
                                ( fCaseInsensitive ?
                                    !_memicmp( pMatch+1, pContent+cObjLen-cMatch, cMatch ) :
                                    !memcmp( pMatch+1, pContent+cObjLen-cMatch, cMatch ) );
                        break;

                    case MATCH_IN:
                        fSt = memstr( pContent, cObjLen, pMatch + 1, cMatch, fCaseInsensitive ) != NULL;
                        break;

                    default:
                        fSt = FALSE;
                }
                
                if ( fConverted )
                {
                    LocalFree( pConverted );
                    pConverted = NULL;
                }

                if ( fSt )
                {
                    break;
                }
            }

            LocalFree( pAttrValues );
            pAttrValues = NULL;

            if ( !fSt )
            {
                break;
            }
        }
        else if ( cMatch )
        {
            // non empty rule on n/a subfield : stop looking other matches

            break;
        }
    }


    //
    // if client cert match, check issuers
    //

    if ( i == iMax )
    {
        LPBYTE  pStoreIssuer;
        LPVOID  pCertIssuer;
        DWORD   dwStoreIssuer;
        DWORD   dwCertIssuer;
        DWORD   iI;
        DWORD   iMax;
        LPSTR   pszIssuerName;
        BOOL    fEnabled;
        BOOL    fSt = TRUE;

#if 0      // For IIS 5, there's no list of accepted issuers for mappings
        //
        // Check issuer matches
        //

        if ( !(fSt = GetMatchAllIssuer()) )
        {
            if ( pAuth->GetIssuer( &pCertIssuer, &dwCertIssuer ) )
            {
                pIssuerStore->Lock();
                iMax = GetIssuerCount();
                for ( iI = 0 ; iI < iMax ; ++iI )
                {
                    if ( GetIssuerEntry( iI,
                                         &fEnabled,
                                         &pszIssuerName ) &&
                        fEnabled &&
                        pIssuerStore->GetIssuerByName( pszIssuerName,
                                                       &pStoreIssuer,
                                                       &dwStoreIssuer ) &&
                        dwStoreIssuer == dwCertIssuer &&
                        !memcmp( pStoreIssuer,
                                 pCertIssuer,
                                 dwCertIssuer ) )
                    {
                        fSt = TRUE;

                        break;
                    }
                }
                pIssuerStore->Unlock();
            }
            else
            {
                fSt = FALSE;
            }
        }

#endif //if 0

        if ( fSt )
        {
            *pfDenied = m_fDenyAccess;
            LPSTR pA = GetRuleAccount();
            LPSTR pR;
            LPSTR pD;
            DWORD dwLen;

            if ( pA )
            {
                if ( pR = strchr( pA, '%' ) )
                {
                    ++pR;

                    // copy domain
#if 1 // DBCS enabling for user name
                    if ( pD = (PCHAR)_mbschr( (PUCHAR)pA, '\\' ) )
#else
                    if ( pD = strchr( pA, '\\' ) )
#endif
                    {
                        memcpy( pszAcct, pA, DIFF(pD - pA) + 1 );
                        pszAcct += pD - pA + 1;
                    }

                    // extract field
                    if ( pD = strchr( pR, '%' ) )
                    {
                        memcpy( pszAcct, pR, DIFF(pD - pR) );
                        pszAcct[ pD - pR ] = '\0';

                        pAttrValues = pC->GetSubField( CERT_FIELD_SUBJECT,
                                                       MapSubFieldToAsn1( pszAcct ),
                                                       &cAttrValues );
                        if ( pAttrValues != NULL )
                        {
                            memcpy( pszAcct,
                                    pAttrValues[ 0 ]->Value.pbData,
                                    pAttrValues[ 0 ]->Value.cbData );
                            pszAcct[ pAttrValues[ 0 ]->Value.cbData ] = '\0';
                            strcpy( pszPwd, GetRulePassword() );

                            LocalFree( pAttrValues );
                            pAttrValues = NULL;
                        }
                        else
                        {
                            SetLastError( ERROR_INVALID_NAME );
                            fSt = FALSE;
                        }
                    }
                    else
                    {
                        SetLastError( ERROR_INVALID_NAME );
                        fSt = FALSE;
                    }
                }
                else
                {
                    strcpy( pszAcct, pA );
                    strcpy( pszPwd, GetRulePassword() );
                }
            }
            else
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                fSt = FALSE;
            }
        }

        return fSt;
    }

    SetLastError( ERROR_INVALID_NAME );

    return FALSE;
}


BOOL
CCertMapRule::GetRuleElem(
    DWORD           i,
    CERT_FIELD_ID*  pfiField,
    LPSTR*          ppContent,
    LPDWORD         pcContent,
    LPSTR*          ppSubField,
    LPDWORD         pdwFlags
    )
/*++

Routine Description:

    Access a rule element

Arguments:

    i - index ( 0-based ) of element to access
    pfiField - updated with CERT_FIELD_ID of this element
    ppContent - updated with ptr to match binary form
    pcContent - updated with length of match binary form
    ppSubField - updated with ASN.1 name of cert sub-field for match
    pdwFlags - updated with flags

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( !m_fValid )
    {
        SetLastError( ERROR_ARENA_TRASHED );

        return FALSE;
    }

    if ( (*ppSubField = m_ElemsSubfield.GetEntry( i )) &&
         m_ElemsContent.GetEntry( i, (LPBYTE*)ppContent, pcContent ) )
    {
        *pfiField = (CERT_FIELD_ID)((UINT_PTR)m_ElemsField.GetPtr( i ));
        if ( pdwFlags )
        {
            *pdwFlags = (DWORD)((DWORD_PTR)m_ElemsFlags.GetPtr( i ));
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
CCertMapRule::DeleteRuleElem(
    DWORD i
    )
/*++

Routine Description:

    Delete a rule element

Arguments:

    i - index ( 0-based ) of element to delete

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( !m_fValid )
    {
        SetLastError( ERROR_ARENA_TRASHED );
        return FALSE;
    }

    if ( m_ElemsContent.DeleteEntry( i ) &&
         m_ElemsSubfield.DeleteEntry( i ) &&
         m_ElemsField.DeletePtr( i ) &&
         m_ElemsFlags.DeletePtr( i ) )
    {
        return TRUE;
    }

    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertMapRule::DeleteRuleElemsByField(
    CERT_FIELD_ID fiField
    )
/*++

Routine Description:

    Delete rule elements based on CERT_FIELD_ID

Arguments:

    fiField - CERT_FIELD_ID of elements to delete

Return Value:

    TRUE if successful ( even if no element deleted ), FALSE on error

--*/
{
    UINT    i;
    UINT    iMax;

    if ( !m_fValid )
    {
        SetLastError( ERROR_ARENA_TRASHED );

        return FALSE;
    }

    iMax = GetRuleElemCount();

    for ( i = 0 ; i < iMax ; ++i )
    {
        if ( fiField == (CERT_FIELD_ID)((UINT_PTR)m_ElemsField.GetPtr(i) ))
        {
            if ( !DeleteRuleElem( i ) )
            {
                m_fValid = FALSE;

                return FALSE;
            }
            --i;
        }
    }

    return TRUE;
}


DWORD
CCertMapRule::AddRuleElem(
    DWORD           iBefore,
    CERT_FIELD_ID   fiField,
    LPSTR           pszSubField,
    LPBYTE          pContent,
    DWORD           cContent,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Add a rule element

Arguments:

    iBefore - index ( 0-based ) of where to insert in list,
        0xffffffff to append to list
    fiField - CERT_FIELD_ID of this element
    pSubField - ASN.1 name of cert sub-field for match
    pContent - ptr to match binary form
    cContent - length of match binary form
    dwFlags - flags ( CMR_FLAGS_* )

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( !m_fValid )
    {
        SetLastError( ERROR_ARENA_TRASHED );
        return FALSE;
    }

    if ( m_ElemsContent.InsertEntry( iBefore, (LPSTR)pContent, cContent ) != INDEX_ERROR &&
         m_ElemsSubfield.InsertEntry( iBefore, pszSubField )  != INDEX_ERROR &&
         m_ElemsField.InsertPtr( iBefore, (LPVOID)fiField ) != INDEX_ERROR &&
         m_ElemsFlags.InsertPtr( iBefore, ULongToPtr(dwFlags) ) != INDEX_ERROR )
    {
        return TRUE;
    }

    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertMapRule::GetIssuerEntry(
    DWORD   i,
    LPBOOL  pfS,
    LPSTR*  ppszI
    )
/*++

Routine Description:

    Get issuer entry from issuer list

Arguments:

    i - index ( 0-based ) of element to delete
    pfS - updated with issuer accept status
    ppszI - updated with ptr to issuer ID

Return Value:

    TRUE if successful ( even if no element deleted ), FALSE on error

--*/
{
    if ( i < m_Issuers.GetNbEntry() )
    {
        *ppszI = m_Issuers.GetEntry( i );
        *pfS = (BOOL) ((DWORD_PTR)m_IssuersAcceptStatus.GetPtr( i ));

        return TRUE;
    }

    return FALSE;
}


BOOL
CCertMapRule::GetIssuerEntryByName(
    LPSTR pszName,
    LPBOOL pfS
    )
/*++

Routine Description:

    Get issuer entry from issuer list

Arguments:

    pszName - issuer ID
    pfS - updated with issuer accept status

Return Value:

    TRUE if successful ( even if no element deleted ), FALSE on error

--*/
{
    UINT i;
    UINT iMx = m_Issuers.GetNbEntry();

    for ( i = 0 ; i < iMx ; ++i )
    {
        if ( !strcmp( m_Issuers.GetEntry( i ), pszName ) )
        {
            *pfS = (BOOL) ((DWORD_PTR)m_IssuersAcceptStatus.GetPtr( i ));

            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CCertMapRule::SetIssuerEntryAcceptStatus(
    DWORD i,
    BOOL fAcceptStatus
    )
/*++

Routine Description:

    Set issuer entry accept status

Arguments:

    i - index ( 0-based ) of element to update
    fAcceptStatus - issuer accept status

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return m_IssuersAcceptStatus.SetPtr( i, ULongToPtr(fAcceptStatus) );
}


BOOL
CCertMapRule::AddIssuerEntry(
    LPSTR pszName,
    BOOL fAcceptStatus
    )
/*++

Routine Description:

    Add issuer entry to issuer list

Arguments:

    pszName - issuer ID
    fAcceptStatus - issuer accept status

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_Issuers.AddEntry( pszName ) != INDEX_ERROR &&
         m_IssuersAcceptStatus.AddPtr( ULongToPtr((ULONG)fAcceptStatus) ) != INDEX_ERROR )
    {
        return TRUE;
    }

    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertMapRule::DeleteIssuerEntry(
    DWORD i
    )
/*++

Routine Description:

    Delete an issuer entry

Arguments:

    i - index ( 0-based ) of element to delete

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( m_Issuers.DeleteEntry( i ) &&
         m_IssuersAcceptStatus.DeletePtr( i ) )
    {
        return TRUE;
    }

    return FALSE;
}


CIisRuleMapper::CIisRuleMapper(
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    m_fValid = TRUE;
}


CIisRuleMapper::~CIisRuleMapper(
    )
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    UINT i;
    UINT iMax = GetRuleCount();

    for ( i = 0 ; i < iMax ; ++i )
    {
        delete (CCertMapRule*)GetRule( i );
    }

    DeleteCriticalSection( &m_csLock );
}


BOOL
CIisRuleMapper::Reset(
    )
/*++

Routine Description:

    Reset to default values

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_GlobalRuleInfo.Reset();

    UINT i;
    UINT iMax = GetRuleCount();

    for ( i = 0 ; i < iMax ; ++i )
    {
        delete (CCertMapRule*)GetRule( i );
    }

    m_Rules.Reset();

    m_fValid = TRUE;

    return TRUE;
}


BOOL
CIisRuleMapper::Load(
    LPSTR pszInstanceId
    )
/*++

Routine Description:

    Load a serialized mapper from file

Arguments:

    pszInstanceId - filename

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CStoreXBF       sxSer;
    DWORD           dwMx;
    LPBYTE          pb;
    DWORD           c;
    CCertMapRule *  pR;
    DWORD           ir;
    HANDLE          hFile;
    UINT            i;
    BOOL            fSt = FALSE;

    if ( (hFile = CreateFile( pszInstanceId,
                              GENERIC_READ,
                              FILE_SHARE_READ|FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL )) != INVALID_HANDLE_VALUE &&
         sxSer.Load( hFile ) )
    {
        fSt = Unserialize( &sxSer );
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    }

    return fSt;
}


BOOL
CIisRuleMapper::Save(
    LPSTR pszInstanceId
    )
/*++

Routine Description:

    Save a mapper to file

Arguments:

    pszInstanceId - filename

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    CStoreXBF   sxSer( 1024 );
    HANDLE      hFile;
    BOOL        fSt = FALSE;

    if ( Serialize( &sxSer ) )
    {
        if ( (hFile = CreateFile( pszInstanceId,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ|FILE_SHARE_WRITE,
                                  NULL,
                                  CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL )) != INVALID_HANDLE_VALUE &&
             sxSer.Save( hFile ) )
        {
            fSt = TRUE;
        }

        if ( hFile != INVALID_HANDLE_VALUE )
        {
            CloseHandle( hFile );
        }
    }

    return fSt;
}


BOOL
CIisRuleMapper::Unserialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Unserialize rule mapper

Arguments:

    pX - CStoreXBF to unserialize from

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE pb = pX->GetBuff();
    DWORD  dw = pX->GetUsed();

    return Unserialize( &pb, &dw );
}


#if defined( CRYPT_RULE_MAPPER )

BOOL
CIisRuleMapper::Unserialize(
    LPBYTE*         ppb,
    LPDWORD         pc
    )
/*++

Routine Description:

    Unserialize rule mapper

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD               dwMx;
    CCertMapRule *      pR;
    DWORD               ir;
    HANDLE              hFile;
    UINT                i;
    BOOL                fSt = FALSE;
    IIS_CRYPTO_STORAGE  storage;
    DWORD               dwType;

    if ( (IISCryptoGetBlobLength( (PIIS_CRYPTO_BLOB)*ppb ) > *pc ) ||
         FAILED(storage.Initialize( (PIIS_CRYPTO_BLOB)*ppb)) )
    {
        return FALSE;
    }

    LockRules();
    Reset();

    *pc -= IISCryptoGetBlobLength( (PIIS_CRYPTO_BLOB)*ppb );
    *ppb += IISCryptoGetBlobLength( (PIIS_CRYPTO_BLOB)*ppb );

    if ( SUCCEEDED(storage.DecryptData( (PVOID*)ppb, pc, &dwType,
                (PIIS_CRYPTO_BLOB)*ppb )) &&
         m_GlobalRuleInfo.UnserializeGlobalRuleInfo( ppb, pc ) &&
         ::Unserialize( ppb, pc, &dwMx ) )
    {
        fSt = TRUE;
        for ( i = 0 ; i < dwMx ; ++i )
        {
            if ( !(pR = new CCertMapRule()) ||
                 (ir = m_Rules.AddPtr( (LPVOID)pR )) == INDEX_ERROR ||
                 !pR->Unserialize( ppb, pc ) )
            {
                fSt = FALSE;
                m_fValid = FALSE;
                if ( pR != NULL )
                {
                    delete pR;
                }
                break;
            }
        }
    }
    else
    {
        m_fValid = FALSE;
    }

    UnlockRules();

    return fSt;
}


BOOL
CIisRuleMapper::Serialize(
    CStoreXBF*  psxSer
    )
/*++

Routine Description:

    Serialize all rules

Arguments:

    psxSer - ptr to CStoreXBF where to serialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL                fSt = FALSE;
    UINT                i;
    DWORD               dwMx;
    CStoreXBF           sxSer;
    IIS_CRYPTO_STORAGE  storage;
    PIIS_CRYPTO_BLOB    blob;
    DWORD               dwSesKey;
    LPBYTE              pB;

    LockRules();
    if ( m_fValid )
    {
        dwMx = m_Rules.GetNbPtr();
        if ( m_GlobalRuleInfo.SerializeGlobalRuleInfo( &sxSer ) &&
             ::Serialize( &sxSer, dwMx ) )
        {
            fSt = TRUE;
            for ( i = 0 ; i < dwMx ; ++i )
            {
                if ( !GetRule(i)->Serialize( &sxSer ) )
                {
                    fSt = FALSE;

                    break;
                }
            }
        }
    }
    UnlockRules();

    if ( fSt )
    {
        //
        // Encrypt blob
        //

        fSt = FALSE;
        storage.Initialize();
        if ( SUCCEEDED(storage.GetSessionKeyBlob( &blob )) )
        {
            dwSesKey = IISCryptoGetBlobLength( blob );
            if ( psxSer->Append( (LPBYTE)blob, (DWORD)dwSesKey ) &&
                 SUCCEEDED(storage.EncryptData( (PIIS_CRYPTO_BLOB*)&pB,
                                      sxSer.GetBuff(),
                                      sxSer.GetUsed(), REG_BINARY )) &&
                 psxSer->Append( (LPBYTE)pB,
                                 (DWORD)IISCryptoGetBlobLength( (PIIS_CRYPTO_BLOB)pB )) )
            {
                IISCryptoFreeBlob( (PIIS_CRYPTO_BLOB)pB );
                fSt = TRUE;
            }
        }
    }

    return fSt;
}

#else

BOOL
CIisRuleMapper::Unserialize(
    LPBYTE*         ppb,
    LPDWORD         pc
    )
/*++

Routine Description:

    Unserialize rule mapper

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD           dwMx;
    CCertMapRule *  pR;
    DWORD           ir;
    HANDLE          hFile;
    UINT            i;
    BOOL            fSt = FALSE;

    LockRules();
    Reset();

    if ( m_GlobalRuleInfo.UnserializeGlobalRuleInfo( ppb, pc ) &&
         ::Unserialize( ppb, pc, &dwMx ) )
    {
        fSt = TRUE;
        for ( i = 0 ; i < dwMx ; ++i )
        {
            if ( !(pR = new CCertMapRule()) ||
                 (ir = m_Rules.AddPtr( (LPVOID)pR )) == INDEX_ERROR ||
                 !pR->Unserialize( ppb, pc ) )
            {
                fSt = FALSE;
                m_fValid = FALSE;
                if ( pR != NULL )
                {
                    delete pR;
                }
                break;
            }
        }
    }
    else
    {
        m_fValid = FALSE;
    }

    UnlockRules();

    return fSt;
}

BOOL
CIisRuleMapper::Serialize(
    CStoreXBF*  psxSer
    )
/*++

Routine Description:

    Serialize all rules

Arguments:

    psxSer - ptr to CStoreXBF where to serialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL        fSt = FALSE;
    UINT        i;
    DWORD       dwMx;

    LockRules();
    if ( m_fValid )
    {
        dwMx = m_Rules.GetNbPtr();
        if ( m_GlobalRuleInfo.SerializeGlobalRuleInfo( psxSer ) &&
             ::Serialize( psxSer, dwMx ) )
        {
            fSt = TRUE;
            for ( i = 0 ; i < dwMx ; ++i )
            {
                if ( !GetRule(i)->Serialize( psxSer ) )
                {
                    fSt = FALSE;

                    break;
                }
            }
        }
    }
    UnlockRules();

    return fSt;
}

#endif


BOOL
CIisRuleMapper::DeleteRule(
    DWORD dwI
    )
/*++

Routine Description:

    Delete a rule

Arguments:

    dwI - index ( 0-based ) of rule to delete

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( dwI < GetRuleCount() )
    {
        if ( m_Rules.DeletePtr( dwI ) &&
             m_GlobalRuleInfo.DeleteRuleById( dwI, TRUE ) )
        {
            return TRUE;
        }

        m_fValid = FALSE;
    }

    return FALSE;
}


DWORD
CIisRuleMapper::AddRule(
    )
/*++

Routine Description:

    Add an empty rule

Arguments:

    None

Return Value:

    index of added rule or INDEX_ERROR if error

--*/
{
    CCertMapRule *pR;
    DWORD i;

    if ( pR = new CCertMapRule() )
    {
        if ( (i = m_Rules.AddPtr( (LPVOID)pR )) != INDEX_ERROR )
        {
            if ( m_GlobalRuleInfo.AddRuleOrder() )
            {
                return i;
            }

            m_fValid = FALSE;

            /* INTRINSA suppress = leaks */
            return INDEX_ERROR;
        }

        m_fValid = FALSE;
        delete pR;
    }

    return INDEX_ERROR;
}


DWORD
CIisRuleMapper::AddRule(
    CCertMapRule *pR
    )
/*++

Routine Description:

    Add a rule

Arguments:

    pR - rule to add

Return Value:

    index of added rule or INDEX_ERROR if error

--*/
{
    DWORD i;

    if ( (i = m_Rules.AddPtr( (LPVOID)pR )) != INDEX_ERROR )
    {
        if ( m_GlobalRuleInfo.AddRuleOrder() )
        {
            return i;
        }
    }

    m_fValid = FALSE;

    return INDEX_ERROR;
}


BOOL
CIisRuleMapper::Match(
    PCERT_CONTEXT pCert,
    PCERT_CONTEXT pAuth,
    LPSTR pszAcct,
    LPSTR pszPwd
    )
/*++

Routine Description:

    Check if rule match certificate

    WARNING: must be called inside lock

Arguments:

    pCert - client cert
    pAuth - Certifying Authority or NULL if not recognized
    cbLen - ptr to DER encoded cert
    pszAcct - updated with NT account on success,
        assumed to be at least UNLEN+DNLEN+1 long
    pszPwd - updated with NT password on success,
        assumed to be at least UNLEN+1 long

Return Value:

    TRUE if successful, FALSE on error
    Errors:
        ERROR_ARENA_TRASHED if rule internal state is invalid
        ERROR_INVALID_NAME if no match
        ERROR_ACCESS_DENIED if match and denied access

--*/
{
    UINT            iR;
    UINT            iMax;
    LPDWORD         pdwOrder;
    CDecodedCert    dcCert( pCert );
    CDecodedCert    dcAuth( pAuth );
    BOOL            fSt = FALSE;
    BOOL            fDenied;

    LockRules();

    if ( !IsValid() || !m_GlobalRuleInfo.IsValid() )
    {
        SetLastError( ERROR_ARENA_TRASHED );
        goto ex;
    }

    if ( !m_GlobalRuleInfo.GetRulesEnabled() )
    {
        SetLastError( ERROR_INVALID_NAME );
        goto ex;
    }

    iMax = GetRuleCount();

    if ( iMax == 0 )
    {
        SetLastError( ERROR_INVALID_NAME );
        goto ex;
    }

    pdwOrder = m_GlobalRuleInfo.GetRuleOrderArray();

    for ( iR = 0 ; iR < iMax ; ++iR )
    {
        if ( ((CCertMapRule*)m_Rules.GetPtr(pdwOrder[iR]))->Match(
                &dcCert, &dcAuth, pszAcct, pszPwd, &fDenied ) )
        {
            if ( fDenied )
            {
                SetLastError( ERROR_ACCESS_DENIED );
                fSt = FALSE;
            }
            else
            {
                fSt = TRUE;
            }

            break;
        }
    }
ex:
    UnlockRules();
    return fSt;
}


CERT_FIELD_ID
MapFieldToId(
    LPSTR pField
    )
/*++

Routine Description:

    Map field name ( "Issuer", ... ) to ID

Arguments:

    pField - field name

Return Value:

    CERT_FIELD_ID of field or CERT_FIELD_ERROR if error

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapField)/sizeof(MAP_FIELD) ; ++x )
    {
        if ( !_stricmp( pField, aMapField[x].pTextName ) )
        {
            return aMapField[x].dwId;
        }
    }

    return CERT_FIELD_ERROR;
}


LPSTR
MapIdToField(
    CERT_FIELD_ID   dwId
    )
/*++

Routine Description:

    Map ID to field name ( "Issuer", ... )

Arguments:

    dwId - field ID

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapField)/sizeof(MAP_FIELD) ; ++x )
    {
        if ( dwId == aMapField[x].dwId )
        {
            return aMapField[x].pTextName;
        }
    }

    return NULL;
}


DWORD
GetIdFlags(
    CERT_FIELD_ID   dwId
    )
/*++

Routine Description:

    Get flags for specified ID

Arguments:

    dwId - field ID

Return Value:

    ID flags if success, otherwise 0xffffffff

--*/
{
    if ( dwId < CERT_FIELD_LAST )
    {
        return adwFieldFlags[dwId];
    }

    return 0xffffffff;
}


LPSTR
MapSubFieldToAsn1(
    LPSTR pszSubField
    )
/*++

Routine Description:

    Map field name ( "OU", ... ) to ASN.1 name

Arguments:

    pszSubField - subfield name

Return Value:

    ptr to ASN.1 name or NULL if error

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++x )
    {
        if ( !strcmp( pszSubField, aMapAsn[x].pTextName ) )
        {
            return aMapAsn[x].pAsnName;
        }
    }

    return NULL;
}


LPSTR
MapAsn1ToSubField(
    LPSTR pszAsn1
    )
/*++

Routine Description:

    Map ID to field name ( "OU", ... )

Arguments:

    pszAsn1 - ASN.1 name

Return Value:

    sub field name or ASN.1 name if conversion not found

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++x )
    {
        if ( !strcmp( pszAsn1, aMapAsn[x].pAsnName ) )
        {
            return aMapAsn[x].pTextName;
        }
    }

    return pszAsn1;
}


LPSTR
EnumerateKnownSubFields(
    DWORD dwIndex
    )
/*++

Routine Description:

    Get subfield name from index (0-based )

Arguments:

    dwIndex - enumerator ( 0-based )

Return Value:

    sub field name or NULL if no more subfields

--*/
{
    if ( dwIndex < sizeof(aMapAsn)/sizeof(MAP_ASN) )
    {
        return aMapAsn[dwIndex].pTextName;
    }

    return NULL;
}


VOID
InitializeWildcardMapping(
    HANDLE hModule
    )
/*++

Routine Description:

    Initialize wildcard mapping

Arguments:

    hModule - module handle of this DLL

Return Value:

    Nothing

--*/
{
    // load schannel

    if ( hSchannel = LoadLibrary( "schannel.dll" ) )
    {
        pfnGetDefaultIssuers = (SSL_GET_ISSUERS_FN)GetProcAddress( hSchannel,
                "SslGetDefaultIssuers" );
    }

#if 1
    if ( hCapi2Lib = LoadLibrary("crypt32.dll") )
    {
        pfnCertCreateCertificateContext = (PFNCertCreateCertificateContext)GetProcAddress(hCapi2Lib, "CertCreateCertificateContext");
        pfnCertFreeCertificateContext = (PFNCertFreeCertificateContext)GetProcAddress(hCapi2Lib, "CertFreeCertificateContext");
        pfnCryptDecodeObject = (PFNCryptDecodeObject)GetProcAddress(hCapi2Lib, "CryptDecodeObject");
        pfnCertGetCertificateContextProperty = (PFNCertGetCertificateContextProperty)GetProcAddress(hCapi2Lib, "CertGetCertificateContextProperty");
    }
#else
    hCapi2Lib = NULL;
    pfnCertCreateCertificateContext = CertCreateCertificateContext;
    pfnCertFreeCertificateContext = CertFreeCertificateContext;
    pfnCryptDecodeObject = CryptDecodeObject;
    pfnCertGetCertificateContextProperty = CertGetCertificateContextProperty;
#endif

    LPVOID  p;
    UINT    i;
    UINT    l;
    CHAR    achTmp[128];

    for ( i = 0 ; i < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++ i )
    {
        if ( !(l = LoadString( (HINSTANCE)hModule, aMapAsn[i].dwResId, achTmp, sizeof(achTmp) )) ||
             !(p = LocalAlloc( LMEM_FIXED, l+1 )) )
        {
            p = (LPVOID)"";
        }
        else
        {
            memcpy( p, achTmp, l+1 );
        }

        aMapAsn[i].pTextName = (LPSTR)p;
    }

    for ( i = 0 ; i < sizeof(aMapField)/sizeof(MAP_FIELD) ; ++ i )
    {
        if ( !(l = LoadString( (HINSTANCE)hModule, aMapField[i].dwResId, achTmp, sizeof(achTmp) )) ||
             !(p = LocalAlloc( LMEM_FIXED, l+1 )) )
        {
            p = (LPVOID)"";
        }
        else
        {
            memcpy( p, achTmp, l+1 );
        }

        aMapField[i].pTextName = (LPSTR)p;
    }
}


VOID
TerminateWildcardMapping(
    )
/*++

Routine Description:

    Terminate wildcard mapping

Arguments:

    None

Return Value:

    Nothing

--*/
{
    UINT    i;

    if ( hSchannel != NULL )
    {
        FreeLibrary( hSchannel );
    }

    if ( hCapi2Lib != NULL )
    {
        FreeLibrary( hCapi2Lib );
    }

    for ( i = 0 ; i < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++ i )
    {
        if ( aMapAsn[i].pTextName[0] )
        {
            LocalFree( aMapAsn[i].pTextName );
        }
    }

    for ( i = 0 ; i < sizeof(aMapField)/sizeof(MAP_FIELD) ; ++ i )
    {
        if ( aMapField[i].pTextName[0] )
        {
            LocalFree( aMapField[i].pTextName );
        }
    }
}


BOOL
MatchRequestToBinary(
    LPSTR pszReq,
    LPBYTE* ppbBin,
    LPDWORD pdwBin )
/*++

Routine Description:

    Convert from match request user format ( e.g. "*msft*"
    to internal binary format

Arguments:

    pszReq - match in user format
    ppbBin - updated with ptr to alloced binary format,
        to be freed by calling FreeMatchConversion()
    pdwBin - updated with binary format length

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPSTR       pReq;
    DWORD       cReq;
    LPBYTE      pBin;
    MATCH_TYPES mt;

    if ( !pszReq)
    {
        *ppbBin = NULL;
        *pdwBin = 0;

        return FALSE;
    }

    pReq = pszReq;
    cReq = strlen( pReq );

    if ( !cReq )
    {
        mt = MATCH_ALL;
    }
    else
    {
        if ( pReq[0] == '*' )
        {
            if ( pReq[cReq-1] == '*' && cReq > 1 )
            {
                mt = MATCH_IN;
                cReq -= 2;
            }
            else
            {
                mt = MATCH_LAST;
                cReq -= 1;
            }
            ++pReq;
        }
        else if ( pReq[cReq-1] == '*' )
        {
            mt = MATCH_FIRST;
            cReq -= 1;
        }
        else
        {
            mt = MATCH_ALL;
        }
    }

    if ( !(pBin = (LPBYTE)LocalAlloc( LMEM_FIXED, cReq + 1 )) )
    {
        return FALSE;
    }

    pBin[0] = (UINT)mt;
    memcpy( pBin+1, pReq, cReq );

    *ppbBin = pBin;
    *pdwBin = cReq + 1;

    return TRUE;
}


BOOL
BinaryToMatchRequest(
    LPBYTE pbBin,
    DWORD dwBin,
    LPSTR* ppszReq
    )
/*++

Routine Description:

    Convert from internal binary format to
    match request user format ( e.g. "*msft*"

Arguments:

    pbBin - ptr to binary format,
    dwBin - binary format length
    ppszReq - updated with ptr to alloced match in user format
        to be freed by calling FreeMatchConversion()

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL    fPre;
    BOOL    fPost;
    UINT    cMatch = dwBin + 1;
    LPSTR   pMatch;

    if ( !pbBin || !dwBin )
    {
        *ppszReq = NULL;

        return FALSE;
    }

    switch ( (MATCH_TYPES)(UINT)pbBin[0] )
    {
        case MATCH_ALL:
            fPre = FALSE;
            fPost = FALSE;
            break;

        case MATCH_LAST:
            fPre = TRUE;
            fPost = FALSE;
            ++cMatch;
            break;

        case MATCH_FIRST:
            fPre = FALSE;
            fPost = TRUE;
            ++cMatch;
            break;

        case MATCH_IN:
            fPre = TRUE;
            fPost = TRUE;
            cMatch += 2;
            break;

        default:
            return FALSE;
    }

    if ( !(pMatch = (LPSTR)LocalAlloc( LMEM_FIXED, cMatch )) )
    {
        return FALSE;
    }

    *ppszReq = pMatch;

    if ( fPre )
    {
        *pMatch++ = '*';
    }

    memcpy( pMatch, pbBin + 1, dwBin - 1 );
    pMatch += dwBin - 1;

    if ( fPost )
    {
        *pMatch++ = '*';
    }

    *pMatch = '\0';

    return TRUE;
}


VOID
FreeMatchConversion(
    LPVOID pvFree
    )
/*++

Routine Description:

    Free result of binary to/from user format conversion

Arguments:

    pvFree - buffer to free

Return Value:

    Nothing

--*/
{
    if ( pvFree != NULL )
    {
        LocalFree( pvFree );
    }
}


LPBYTE
memstr(
    LPBYTE  pStr,
    UINT    cStr,
    LPBYTE  pSub,
    UINT    cSub,
    BOOL    fCaseInsensitive
    )
/*++

Routine Description:

    Find 1st occurence of block of memory inside buffer

Arguments:

    pStr - buffer where to search
    cStr - length of pStr
    pSub - buffer to search for in pStr
    cSub - length of pSub
    fCaseInsensitive - TRUE is case insensitive search

Return Value:

    Ptr to 1st occurence of pSub in pStr or NULL if not found

--*/
{
    LPBYTE      p;
    LPBYTE      pN;

    if ( cSub > cStr )
    {
        return NULL;
    }

    UINT    ch = *pSub;

    if ( fCaseInsensitive )
    {
        if ( cStr >= cSub &&
             cSub )
        {
            cStr -= cSub - 1;

            for ( p = pStr ; cStr ; ++p, --cStr )
            {
                if ( !_memicmp( p, pSub, cSub ) )
                {
                    return p;
                }
            }
        }
    }
    else
    {
        for ( p = pStr ; pN = (LPBYTE)memchr( p, ch, cStr ) ; )
        {
            if ( !memcmp( pN, pSub, cSub ) )
            {
                return pN;
            }
            cStr -= (UINT)(pN - p + 1);
            p = pN + 1;
        }
    }

    return NULL;
}


VOID
FreeCIisRuleMapper(
    LPVOID pMapper
    )
/*++

Routine Description:

    Delete a CIisRuleMapper

Arguments:

    pMapper - ptr to mapper

Returns:

    Nothing

--*/
{
    delete (CIisRuleMapper*)pMapper;
}


BOOL
IsCertificateVerified(
    PCCERT_CONTEXT pCertContext
    )
{
    DWORD   fVerified = FALSE;
    DWORD   dwVerified = sizeof(fVerified);


    if ( pfnCertGetCertificateContextProperty == NULL )
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return FALSE;
    }

#ifndef CERT_PROP_VERIFIED
#define CERT_PROP_VERIFIED  (CERT_FIRST_USER_PROP_ID+3)
#endif

    // Check if this is a verified cert chain
    if(!pfnCertGetCertificateContextProperty(pCertContext,
                                          CERT_PROP_VERIFIED,
                                          &fVerified,
                                          &dwVerified))
    {
#if 0
        char achE[80];
        wsprintf( achE, "Error %d\n", GetLastError() );
        OutputDebugString( achE );
#endif
        fVerified = FALSE;
    }

    return fVerified;
}

BOOL
GetDefaultIssuers(
    LPBYTE              pIssuer,
    DWORD *             pdwIssuer
    )
{
    if ( pfnGetDefaultIssuers == NULL )
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return FALSE;
    }

    return pfnGetDefaultIssuers(pIssuer, pdwIssuer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iismap\sources.inc ===
!IF 0

Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Murali R. Krishnan    09-Oct-1995
          This sources.inc file is copied off from original sources file
           to support building two dlls.

Revision History:

!ENDIF

TARGETPATH=obj

MSC_WARNING_LEVEL=/W3 /WX

TARGETTYPE=DYNLINK

USE_MSVCRT=1
DLLENTRY=_DllMainCRTStartup

RAW_TARGETLIBS=\
            $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib    \
            $(SDK_LIB_PATH)\kernel32.lib    \
            $(SDK_LIB_PATH)\advapi32.lib    \
            $(SDK_LIB_PATH)\user32.lib

TARGETLIBS=\
           ..\lib\*\iiscrypt.lib \
           ..\lib\*\icrypt.lib \
		   $(RAW_TARGETLIBS)

SOURCES=\
	iismap.cxx \
	md5c.c \
	iiscmr.cxx \
        memalloc.cxx \
	iismap.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\iismap\iismap.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    iismap.cxx

Abstract:

    Classes to handle mapping

Author:

    Philippe Choquier (phillich)    17-may-1996

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
//#include <crypt32l.h>

#include "xbf.hxx"
extern "C" {
#include "immd5.h"
}
#include <iis64.h>
#include <iismap.hxx>
#include "iismaprc.h"
#include "mapmsg.h"
#include "iiscmr.hxx"
#include <refb.hxx>
#include <icrypt.hxx>
#include "dbgutil.h"

//
// global vars
//

CRITICAL_SECTION g_csIisMap;
DWORD g_dwGuid = 0;
HKEY g_hKey = NULL;
LPSTR g_pszInstallPath = NULL;

DECLARE_DEBUG_PRINTS_OBJECT();

//
//
//

#if defined(DECODE_ASN1)
PRDN_VALUE_BLOB
CertGetNameField(
                 UINT       iEncoding,
                 IN LPCTSTR pszObjId,
                 IN PNAME_INFO pInfo
                 );
UINT DecodeNames(
                 IN PNAME_BLOB pNameBlob,
                 IN LPSTR* pFields,
                 IN LPSTR  pStore
                 );
UINT DecodeCert(
                       IN PBYTE pbEncodedCert,
                       IN DWORD cbEncodedCert,
                       LPSTR*   pFields,
                       LPSTR    pStore
                       );
#endif

//
// global functions
//

extern "C" int __cdecl
QsortIisMappingCmp(
    const void *pA,
    const void *pB )
/*++

Routine Description:

    Compare function for 2 CIisMapping entries
    compare using mask, then all fields as defined in
    the linked CIisAcctMapper hierarchy

Arguments:

    pA -- ptr to 1st element
    pB -- ptr tp 2nd elemet

Returns:

    -1 if *pA < *pB, 0 if *pA == *pB, 1 if *pA > *pB

--*/
{
    return (*(CIisMapping**)pA)->Cmp( *(CIisMapping**)pB, FALSE );
}


extern "C" int __cdecl
MatchIisMappingCmp(
    const void *pA,
    const void *pB )
/*++

Routine Description:

    Compare function for 2 CIisMapping entries
    do not uses mask, uses all fields as defined in
    the linked CIisAcctMapper hierarchy

Arguments:

    pA -- ptr to 1st element
    pB -- ptr tp 2nd elemet

Returns:

    -1 if *pA < *pB, 0 if *pA == *pB, 1 if *pA > *pB

--*/
{
    return ( *(CIisMapping**)pA)->Cmp( *(CIisMapping**)pB, TRUE );
}


HRESULT
GetSecurityDescriptorForMetabaseExtensionFile( 
    PSECURITY_DESCRIPTOR * ppsdStorage 
    )
/*++

Routine Description:

    Build security descriptor that will be set for the extension file
    *.mp (includes Administrators and System )
    
Arguments:

    ppsdStorage - Security Descriptor to be set for extension file

Returns:
    HRESULT
--*/

{
    HRESULT                  hr = ERROR_SUCCESS;
    BOOL                     fRet = FALSE;
    DWORD                    dwDaclSize = 0;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    
    PSID                     psidSystem = NULL;
    PSID                     psidAdmin = NULL;
    PACL                     paclDiscretionary = NULL;
    
    DBG_ASSERT( ppsdStorage != NULL );
    
        *ppsdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if ( *ppsdStorage == NULL ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        //
        // Initialize the security descriptor.
        //

        fRet = InitializeSecurityDescriptor(
                     *ppsdStorage,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        fRet = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &psidSystem
                     );

        if( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }
        
        fRet=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &psidAdmin
                     );

        if( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        dwDaclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(psidAdmin)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(psidSystem)
                       - sizeof(DWORD);

        paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

        if ( paclDiscretionary == NULL ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        fRet = InitializeAcl(
                     paclDiscretionary,
                     dwDaclSize,
                     ACL_REVISION
                     );

        if( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        fRet = AddAccessAllowedAce(
                     paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     psidSystem
                     );

        if ( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        fRet = AddAccessAllowedAce(
                     paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     psidAdmin
                     );

        if ( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        //
        // Set the DACL into the security descriptor.
        //

        fRet = SetSecurityDescriptorDacl(
                     *ppsdStorage,
                     TRUE,
                     paclDiscretionary,
                     FALSE
                     );

        if ( !fRet ) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;

        }

    hr = S_OK;
    
exit:

    if ( psidAdmin != NULL ) 
    {
        FreeSid( psidAdmin );
        psidAdmin = NULL;
    }

    if ( psidSystem != NULL ) 
    {
        FreeSid( psidSystem );
        psidSystem = NULL;
    }

    if ( FAILED( hr ) ) {
        if ( paclDiscretionary != NULL ) 
        {
            LocalFree( paclDiscretionary );
            paclDiscretionary = NULL;
        }

        if ( *ppsdStorage != NULL ) 
        {
            LocalFree( *ppsdStorage );
            *ppsdStorage = NULL;
        }
    }

    return hr;

}

HRESULT
FreeSecurityDescriptorForMetabaseExtensionFile(
    PSECURITY_DESCRIPTOR psdStorage 
    )
/*++

Routine Description:

    Free security descriptor generated by
        GetSecurityDescriptorForMetabaseExtentionFile()
    
Arguments:

    psdStorage - Security Descriptor to be freed

Returns:
    HRESULT
--*/
    
{
    HRESULT     hr = ERROR_SUCCESS;
    BOOL        fRet = FALSE;
    BOOL        fDaclPresent;
    PACL        paclDiscretionary = NULL;
    BOOL        fDaclDefaulted;
        
    //
    // Get the DACL from the security descriptor.
    //

    if ( psdStorage == NULL )
    {
        hr = S_OK;
        goto exit;
    }

    fRet = GetSecurityDescriptorDacl(
                 psdStorage,
                 &fDaclPresent,
                 &paclDiscretionary,
                 &fDaclDefaulted
                 );

    if ( !fRet ) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
        
    if ( fDaclPresent && paclDiscretionary != NULL )
    {
        LocalFree( paclDiscretionary );
        paclDiscretionary = NULL;
    }

    LocalFree( psdStorage );

    hr = S_OK;
    
exit:

    return hr;
}


INT
Iisfputs(
    const char* pBuf,
    FILE* fOut
    )
{
    return (fputs( pBuf, fOut ) == EOF || fputc( '\n', fOut ) == EOF)
        ? EOF
        : 0;
}


LPSTR
Iisfgets(
    LPSTR pBuf,
    INT cMax,
    FILE* fIn
    )
{
    LPSTR pszWas = pBuf;
    INT ch = 0;

    while ( cMax > 1 && (ch=fgetc(fIn))!= EOF && ch != '\n' )
    {
        *pBuf++ = (CHAR)ch;
        --cMax;
    }

    if ( ch != EOF )
    {
        *pBuf = '\0';
        return pszWas;
    }

    return NULL;
}


//
// Fields for the Certificate mapper
//

IISMDB_Fields IisCertMappingFields[] = {
    {IISMDB_TYPE_ISSUER_O, NULL, IDS_IISMAP_FLD0, 40 },
    {IISMDB_TYPE_ISSUER_OU, NULL, IDS_IISMAP_FLD1, 40 },
    {IISMDB_TYPE_ISSUER_C, NULL, IDS_IISMAP_FLD2, 40 },

    {IISMDB_TYPE_SUBJECT_O, NULL, IDS_IISMAP_FLD3, 40 },
    {IISMDB_TYPE_SUBJECT_OU, NULL, IDS_IISMAP_FLD4, 40 },
    {IISMDB_TYPE_SUBJECT_C, NULL, IDS_IISMAP_FLD5, 40 },
    {IISMDB_TYPE_SUBJECT_CN, NULL, IDS_IISMAP_FLD6, 40 },

    {IISMDB_TYPE_NTACCT, NULL, IDS_IISMAP_FLD7, 40 },
} ;

//
// default hierarchy for the Certificate mapper
//

IISMDB_HEntry IisCertMappingHierarchy[] = {
    {IISMDB_INDEX_ISSUER_O, TRUE},
    {IISMDB_INDEX_ISSUER_OU, FALSE},
    {IISMDB_INDEX_ISSUER_C, FALSE},

    {IISMDB_INDEX_SUBJECT_O, TRUE},
    {IISMDB_INDEX_SUBJECT_OU, FALSE},
    {IISMDB_INDEX_SUBJECT_C, FALSE},
    {IISMDB_INDEX_SUBJECT_CN, TRUE},
} ;


//
// Fields for the Certificate 1:1 mapper
//

IISMDB_Fields IisCert11MappingFields[] = {
#if defined(CERT11_FULL_CERT)
    {IISMDB_INDEX_CERT11_CERT, NULL, IDS_IISMAP11_FLDC, 40 },
#else
    {IISMDB_INDEX_CERT11_SUBJECT, NULL, IDS_IISMAP11_FLDS, 40 },
    {IISMDB_INDEX_CERT11_ISSUER, NULL, IDS_IISMAP11_FLDI, 40 },
#endif
    {IISMDB_INDEX_CERT11_NT_ACCT, NULL, IDS_IISMAP11_FLDA, 40 },
#if defined(CERT11_FULL_CERT)
    {IISMDB_INDEX_CERT11_NAME, NULL, IDS_IISMAP11_FLDN, 40 },
    {IISMDB_INDEX_CERT11_ENABLED, NULL, IDS_IISMAP11_FLDE, 40 },
    {IISMDB_INDEX_CERT11_NT_PWD, NULL, IDS_IISMAP11_FLDP, 40 },
#endif
} ;

//
// default hierarchy for the Certificate 1:1 mapper
//

IISMDB_HEntry IisCert11MappingHierarchy[] = {
#if defined(CERT11_FULL_CERT)
    {IISMDB_INDEX_CERT11_CERT, TRUE},
#else
    {IISMDB_INDEX_CERT11_ISSUER, TRUE},
    {IISMDB_INDEX_CERT11_SUBJECT, FALSE},
#endif
} ;


//
// Fields for the Ita mapper
//

IISMDB_Fields IisItaMappingFields[] = {
    {IISMDB_TYPE_ITACCT, NULL, IDS_ITAIISMAP_FLD0, 40 },
    {IISMDB_TYPE_ITPWD, NULL, IDS_ITAIISMAP_FLD1, 40 },

    {IISMDB_TYPE_NTACCT, NULL, IDS_ITAIISMAP_FLD2, 40 },
} ;

//
// default hierarchy for the Ita mapper
//

IISMDB_HEntry IisItaMappingHierarchy[] = {
    {IISIMDB_INDEX_IT_ACCT, TRUE},
    {IISIMDB_INDEX_IT_PWD, TRUE},
} ;


//
// Fields for the Md5 mapper
//

IISMDB_Fields IisMd5MappingFields[] = {
    {IISMDB_TYPE_ITREALM, NULL, IDS_MD5IISMAP_FLD0, 40 },
    {IISMDB_TYPE_ITACCT, NULL, IDS_MD5IISMAP_FLD1, 40 },
    {IISMDB_TYPE_ITMD5PWD, NULL, IDS_MD5IISMAP_FLD2, 40 },

    {IISMDB_TYPE_NTACCT, NULL, IDS_MD5IISMAP_FLD3, 40 },
    {IISMMDB_INDEX_IT_CLRPWD, NULL, IDS_MD5IISMAP_FLD4, 40 },
    {IISMMDB_INDEX_NT_PWD, NULL, IDS_MD5IISMAP_FLD5, 40 },
} ;

//
// default hierarchy for the Md5 mapper
//

IISMDB_HEntry IisMd5MappingHierarchy[] = {
    {IISMMDB_INDEX_IT_REALM, TRUE},
    {IISMMDB_INDEX_IT_ACCT, TRUE},
} ;


HINSTANCE g_hModule = (HINSTANCE)INVALID_HANDLE_VALUE;



// CIisAcctMapper

CIisAcctMapper::CIisAcctMapper(
    )
/*++

Routine Description:

    Constructor for CIisAcctMapper

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_cInit = -1;

    m_pMapping = NULL;
    m_cMapping = 0;

    m_pAltMapping = NULL;
    m_cAltMapping = 0;

    m_pHierarchy = NULL;
    m_cHierarchy = 0;

    m_achFileName[0] = '\0';

    m_pClasses = NULL;
    m_pSesKey = NULL;
    m_dwSesKey = 0;

    m_hNotifyEvent = NULL;
    m_fRequestTerminate = FALSE;

    INITIALIZE_CRITICAL_SECTION( &csLock );
}


CIisAcctMapper::~CIisAcctMapper(
    )
/*++

Routine Description:

    Destructor for CIisAcctMapper

Arguments:

    None

Returns:

    Nothing

--*/
{
    Reset();

    if ( m_pHierarchy != NULL )
    {
        LocalFree( m_pHierarchy );
    }

    if ( m_pSesKey != NULL )
    {
        LocalFree( m_pSesKey );
    }

    DeleteCriticalSection( &csLock );
}


VOID
FreeCIisAcctMapper(
    LPVOID pMapper
    )
/*++

Routine Description:

    Delete a CIisAcctMapper

Arguments:

    pMapper - ptr to mapper

Returns:

    Nothing

--*/
{
    delete (CIisAcctMapper*)pMapper;
}


BOOL
CIisAcctMapper::Create(
    VOID
    )
/*++

Routine Description:

    Create file for CIisAcctMapper with proper SD

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    // create file name, store in m_achFileName
    // from g_dwGuid
    // and g_pszInstallPath

    UINT    cLen;
    UINT    cIter;
    HANDLE  hF;
    HRESULT hr = E_FAIL;
    BOOL    fRet = FALSE;
    PSECURITY_DESCRIPTOR psdForMetabaseExtensionFile = NULL;
    SECURITY_ATTRIBUTES  saStorage;
    PSECURITY_ATTRIBUTES psaStorage = NULL;


    Reset();

    if ( g_pszInstallPath )
    {
        cLen = strlen(g_pszInstallPath);
        memcpy( m_achFileName, g_pszInstallPath, cLen );
        if ( cLen && m_achFileName[cLen-1] != '\\' )
        {
            m_achFileName[cLen++] = '\\';
        }
    }
    else
    {
        cLen = 0;
    }

    wsprintf( m_achFileName+cLen, "%08x.mp", g_dwGuid );

    //
    // build security descriptor (Administrators and SYSTEM)
    // to be set on metabase extension file
    //
    
    hr = GetSecurityDescriptorForMetabaseExtensionFile( 
                    &psdForMetabaseExtensionFile );
    
    if ( SUCCEEDED(hr) && psdForMetabaseExtensionFile != NULL ) 
    {
        saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
        saStorage.lpSecurityDescriptor = psdForMetabaseExtensionFile;
        saStorage.bInheritHandle = FALSE;
    }
    else
    {
        return FALSE;
    }
    //
    // Open file and close it right away
    // If file didn't exist, then empty file with good SD (Security Descriptor)
    // will be created. That will later be opened using C runtime (fopen) 
    // in Save() method and good SD will persist.
    // Ideally Save() should be using Win32 CreateFile()
    // instead fopen and it could set SD itself. But since this is legacy
    // source file and rather unsafe for making too many changes, pragmatic
    // approach was chosen to set SD here in Create() method
    //
    
    if ( (hF = CreateFile( m_achFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ|FILE_SHARE_WRITE,
                           &saStorage,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL ) ) != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hF );
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

    if ( psdForMetabaseExtensionFile != NULL ) 
    {
        FreeSecurityDescriptorForMetabaseExtensionFile( 
                psdForMetabaseExtensionFile );
        psdForMetabaseExtensionFile = NULL;
    }
    return fRet;

}


BOOL
CIisAcctMapper::Delete(
    VOID
    )
/*++

Routine Description:

    Delete external storage used by this mapper ( i.e. file )

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;

    Lock();

    if ( m_achFileName[0] )
    {
        fSt = DeleteFile( m_achFileName );
        m_achFileName[0] = '\0';
    }

    Unlock();

    return fSt;
}


BOOL
CIisAcctMapper::Serialize(
    CStoreXBF* pXbf
    )
/*++

Routine Description:

    Serialize mapper reference ( NOT mapping info ) to buffer
    Save() must be called to save mapping info before calling Serialize()

Arguments:

    pXbf - ptr to extensible buffer to serialize to

Returns:

    TRUE if success, FALSE if error

--*/
{
    return pXbf->Append( (DWORD)strlen(m_achFileName) ) &&
           pXbf->Append( (LPBYTE)m_achFileName, (DWORD)strlen(m_achFileName) ) &&
           pXbf->Append( (LPBYTE)m_md5.digest, (DWORD)sizeof(m_md5.digest) ) &&
           pXbf->Append( (DWORD)m_dwSesKey ) &&
           pXbf->Append( (LPBYTE)m_pSesKey, (DWORD)m_dwSesKey ) ;
}


BOOL
CIisAcctMapper::Unserialize(
    CStoreXBF* pXBF
    )
/*++

Routine Description:

    Unserialize mapper reference ( NOT mapping info ) from extensible buffer
    Load() must be called to load mapping info

Arguments:

    pXBF - ptr to extensible buffer

Returns:

    TRUE if success, FALSE if error

--*/
{
    LPBYTE pb = pXBF->GetBuff();
    DWORD c = pXBF->GetUsed();

    return Unserialize( &pb, &c );
}


BOOL
CIisAcctMapper::Unserialize(
    LPBYTE* ppb,
    LPDWORD pc
    )
/*++

Routine Description:

    Unserialize mapper reference ( NOT mapping info ) from buffer
    Load() must be called to load mapping info

Arguments:

    ppb - ptr to buffer
    pc - ptr to buffer length

Returns:

    TRUE if success, FALSE if error

--*/
{
    DWORD cName;

    if ( ::Unserialize( ppb, pc, &cName ) &&
         cName <= *pc )
    {
        memcpy( m_achFileName, *ppb, cName );
        m_achFileName[ cName ] = '\0';
        *ppb += cName;
        *pc -= cName;
        if ( sizeof(m_md5.digest) <= *pc )
        {
            memcpy( m_md5.digest, *ppb, sizeof(m_md5.digest) );
            *ppb += sizeof(m_md5.digest);
            *pc -= sizeof(m_md5.digest);

            if ( ::Unserialize( ppb, pc, &m_dwSesKey ) &&
                 cName <= *pc )
            {
                if ( m_pSesKey != NULL )
                {
                    LocalFree( m_pSesKey );
                }

                if ( !(m_pSesKey = (LPBYTE)LocalAlloc( LMEM_FIXED, m_dwSesKey )) )
                {
                    m_dwSesKey = 0;
                    return FALSE;
                }
                memcpy( m_pSesKey, *ppb, m_dwSesKey );
                *ppb += m_dwSesKey;
                *pc -= m_dwSesKey;

                return TRUE;
            }
        }
    }

    return FALSE;
}


BOOL
CIisAcctMapper::Serialize(
    VOID
    )
/*++

Routine Description:

    Serialize mapper reference ( NOT mapping info ) to registry
    Save() must be called to save mapping info before calling Serialize()
    Warning : this allow only 1 instance

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL    fSt = TRUE;
    HKEY    hKey;
    LONG    st;

    if ( (st = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
            GetRegKeyName(),
            0,
            KEY_WRITE,
            &hKey )) != ERROR_SUCCESS )
    {
        SetLastError( st );
        return FALSE;
    }

    if ( RegSetValueEx( hKey,
                         FILE_VALIDATOR,
                         NULL,
                         REG_BINARY,
                         (LPBYTE)m_md5.digest,
                         sizeof(m_md5.digest) ) != ERROR_SUCCESS ||
         RegSetValueEx( hKey,
                         FILE_LOCATION,
                         NULL,
                         REG_SZ,
                         (LPBYTE)m_achFileName,
                         strlen(m_achFileName) ) != ERROR_SUCCESS )
    {
        fSt = FALSE;
    }

    RegCloseKey( hKey );

    return fSt;
}


BOOL
CIisAcctMapper::Unserialize(
    VOID
    )
/*++

Routine Description:

    Unserialize mapper reference ( NOT mapping info ) From registry
    Load() must be called to load mapping info
    Warning : this allow only 1 instance

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL    fSt = FALSE;
    HKEY    hKey;
    DWORD   dwLen;
    DWORD   dwType;
    LONG    st;

    // Check registry

    if ( (st = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
            GetRegKeyName(),
            0,
            KEY_READ,
            &hKey )) != ERROR_SUCCESS )
    {
        SetLastError( st );
        return FALSE;
    }

    dwLen = sizeof(m_md5.digest);

    if ( RegQueryValueEx( hKey,
                          FILE_VALIDATOR,
                          NULL,
                          &dwType,
                          (LPBYTE)m_md5.digest,
                          &dwLen ) == ERROR_SUCCESS &&
         dwType == REG_BINARY &&
         (( dwLen = sizeof(m_achFileName) ), TRUE ) &&
         RegQueryValueEx( hKey,
                          FILE_LOCATION,
                          NULL,
                          &dwType,
                          (LPBYTE)m_achFileName,
                          &dwLen ) == ERROR_SUCCESS &&
         dwType == REG_SZ )
    {
        fSt = TRUE;
    }

    RegCloseKey( hKey );

    return fSt;
}


BOOL
CIisAcctMapper::UpdateClasses(
    BOOL fComputeMask
    )
/*++

Routine Description:

    Constructor for CIisAcctMapper

Arguments:

    fComputeMask -- TRUE if mask to be recomputed

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;
    UINT mx = 1 << m_cHierarchy;

    if ( fComputeMask )
    {
        for ( x = 0 ; x < m_cMapping ; ++x )
        {
            m_pMapping[x]->UpdateMask( m_pHierarchy, m_cHierarchy );
        }
    }

    SortMappings();

    if ( m_pClasses == NULL )
    {
        m_pClasses = (MappingClass*)LocalAlloc(
                LMEM_FIXED,
                sizeof(MappingClass)*(mx+1) );
        if ( m_pClasses == NULL )
        {
            return FALSE;
        }
    }

    DWORD dwN = 0;          // current class index in m_pClasses
    DWORD dwLastClass = 0;
    DWORD dwFirst = 0;  // first entry for current dwLastClass
    for ( x = 0 ; x <= m_cMapping ; ++x )
    {
        DWORD dwCur;
        dwCur = (x==m_cMapping) ? dwLastClass+1: m_pMapping[x]->GetMask();
        if ( dwCur > dwLastClass )
        {
            if ( x > dwFirst )
            {
                m_pClasses[dwN].dwClass = dwLastClass;
                m_pClasses[dwN].dwFirst = dwFirst;
                m_pClasses[dwN].dwLast = x - 1;
                ++dwN;
            }
            dwLastClass = dwCur;
            dwFirst = x;
        }
    }

    m_pClasses[dwN].dwClass = 0xffffffff;

    return TRUE;
}


BOOL
CIisAcctMapper::SortMappings(
    )
/*++

Routine Description:

    Sort the mappings. Masks for mapping objects are assumed
    to be already computed.

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    qsort( (LPVOID)m_pMapping,
           m_cMapping,
           sizeof(CIisMapping*),
           QsortIisMappingCmp
           );

    return TRUE;
}


BOOL
CIisAcctMapper::FindMatch(
    CIisMapping* pQuery,
    CIisMapping** pResult,
    LPDWORD piResult
    )
/*++

Routine Description:

    Find a match base on field contents in CIisMapping

Arguments:

    pQuery -- describe fields to consider for mapping
    pResult -- updated with result if found mapping

Returns:

    TRUE if mapping found, else FALSE

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    // iterate through classes, do bsearch on each

    MappingClass *pH = m_pClasses;

    if ( pH == NULL )
    {
        return FALSE;
    }

    while ( pH->dwClass != 0xffffffff )
    {
        CIisMapping **pRes = (CIisMapping **)bsearch( (LPVOID)&pQuery,
                                     (LPVOID)(m_pMapping+pH->dwFirst),
                                     pH->dwLast - pH->dwFirst + 1,
                                     sizeof(CIisMapping*),
                                     MatchIisMappingCmp );
        if ( piResult != NULL )
        {
            *piResult = DIFF(pRes - m_pMapping);
        }

        if ( pRes != NULL )
        {
            *pResult = *pRes;
            return TRUE;
        }

        ++pH;
    }

    return FALSE;
}


#if 0
DWORD
WINAPI IisMappingUpdateIndication(
    LPVOID pV )
/*++

Routine Description:

    Shell for registry update notification

Arguments:

    pV -- ptr to CIisAcctMapper to be notified

Returns:

    NT error code ( 0 if no error )

--*/
{
    return ((CIisAcctMapper*)pV)->UpdateIndication();
}


DWORD
CIisAcctMapper::UpdateIndication(
    VOID )
/*++

Routine Description:

    Thread monitoring authentication methods update in registry

Arguments:

    None

Returns:

    NT error

--*/
{
    for ( ;; )
    {
        if ( RegNotifyChangeKeyValue( m_hKey,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                m_hNotifyEvent,
                TRUE ) != ERROR_SUCCESS )
        {
            break;
        }
        if ( WaitForSingleObject( m_hNotifyEvent, INFINITE)
                != WAIT_OBJECT_0 )
        {
            break;
        }
        if ( m_fRequestTerminate )
        {
            break;
        }

        // re-load mapper

        Lock();
        if ( !Load() && GetLastError() == ERROR_INVALID_ACCESS )
        {
            Reset();
        }
        Unlock();
    }

    return 0;
}
#endif


#if 0
BOOL
CIisAcctMapper::Init(
    BOOL *pfFirst,
    BOOL fMonitorChange
    )
/*++

Routine Description:

    Initialize mappings, optionally load map file

Arguments:

    fLoad -- TRUE to load mappings from file

Returns:

    TRUE if success, FALSE if error

--*/
{
    *pfFirst = FALSE;
    BOOL fSt = TRUE;

    if ( !InterlockedIncrement( &m_cInit ) )
    {
        *pfFirst = TRUE;

        if ( fMonitorChange )
        {
            m_hNotifyEvent = IIS_CREATE_EVENT(
                                 "CIisAcctMapper::m_hNotifyEvent",
                                 this,
                                 FALSE,
                                 FALSE
                                 );
        }
        m_fRequestTerminate = FALSE;

        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                GetRegKeyName(),
                0,
                KEY_READ,
                &m_hKey ) == ERROR_SUCCESS )
        {
            DWORD dwLen = sizeof( m_achFileName );
            DWORD dwType;
            if ( RegQueryValueEx( m_hKey,
                                  FILE_LOCATION,
                                  NULL,
                                  &dwType,
                                  (LPBYTE)m_achFileName,
                                  &dwLen ) != ERROR_SUCCESS
                    || dwType != REG_SZ )
            {
                strcpy( m_achFileName, IIS_CERT_FILENAME );
            }

            if ( fMonitorChange )
            {
                // create registry monitoring thread
                DWORD dwID;
                if ( (m_hThread = CreateThread( NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)::IisMappingUpdateIndication,
                        (LPVOID)this,
                        0,
                        &dwID )) == NULL )
                {
                    fSt = FALSE;
                    goto ex;
                }
            }

            fSt = Reset();
        }
        else
        {
            SetLastError( ERROR_CANTOPEN );
            fSt = FALSE;
        }
    }

    //
    // log event if error
    //

    if ( !fSt )
    {
        char achErr[32];
        LPCTSTR pA[1];
        pA[0] = achErr;
        _itoa( GetLastError(), achErr, 10 );
        ReportIisMapEvent( EVENTLOG_ERROR_TYPE,
                IISMAP_EVENT_INIT_ERROR,
                1,
                pA );
    }

    return fSt;
}


BOOL
CIisAcctMapper::Terminate(
    BOOL fForce
    )
/*++

Routine Description:

    Terminate mapping

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;

    if ( InterlockedDecrement( &m_cInit ) < 0 || fForce )
    {
#if 0
        if ( m_hNotifyEvent && m_hThread )
        {
            m_fRequestTerminate = TRUE;
            SetEvent( m_hNotifyEvent );

            if ( m_hThread != NULL )
            {
                fSt = WaitForSingleObject( m_hThread, 1000 * 3 )
                        == WAIT_OBJECT_0;

                if ( !fSt )
                {
                    TerminateThread( m_hThread, 0 );
                }

                CloseHandle( m_hThread );
                m_hThread = NULL;

                if ( m_hKey != NULL )
                {
                    RegCloseKey( m_hKey );
                    m_hKey = NULL;
                }
                if ( m_hNotifyEvent != NULL )
                {
                    CloseHandle( m_hNotifyEvent );
                    m_hNotifyEvent = NULL;
                }

                return fSt;
            }
        }

        if ( m_hKey != NULL )
        {
            RegCloseKey( m_hKey );
            m_hKey = NULL;
        }
#endif
    }

    return TRUE;
}
#endif


void
CIisAcctMapper::Lock(
    )
/*++

Routine Description:

    Prevent access to mapper from other threads

Arguments:

    None

Returns:

    Nothing

--*/
{
    EnterCriticalSection( &csLock );
}


void
CIisAcctMapper::Unlock(
    )
/*++

Routine Description:

    Re-enabled access to mapper from other threads

Arguments:

    None

Returns:

    Nothing

--*/
{
    LeaveCriticalSection( &csLock );
}


BOOL
CIisAcctMapper::FlushAlternate(
    BOOL    fApply
    )
/*++

Routine Description:

    Flush alternate list, optionaly commiting it to the main list

Arguments:

    fApply -- TRUE to commit changes made in alternate list

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    UINT        i;
    UINT        iM;
    BOOL        fSt = TRUE;

    if ( m_pAltMapping )
    {
        if ( fApply )
        {
            //
            // Transfer non existing objects from regular to alternate list
            //

            iM = min( m_cMapping, m_cAltMapping );

            for ( i = 0 ; i < iM ; ++ i )
            {
                if ( m_pAltMapping[i] == NULL )
                {
                    m_pAltMapping[i] = m_pMapping[i];
                }
                else
                {
                    delete m_pMapping[i];
                }
            }

            //
            // delete extra objects
            //

            if ( m_cMapping > m_cAltMapping )
            {
                for ( i = m_cAltMapping ; i < m_cMapping ; ++i )
                {
                    delete m_pMapping[i];
                }
            }

            if ( m_pMapping )
            {
                LocalFree( m_pMapping );
            }

            m_pMapping = m_pAltMapping;
            m_cMapping = m_cAltMapping;

            fSt = UpdateClasses( TRUE );
        }
        else
        {
            for ( i = 0 ; i < m_cAltMapping ; ++i )
            {
                if ( m_pAltMapping[i] )
                {
                    delete m_pAltMapping;
                }
            }
            LocalFree( m_pAltMapping );
        }
    }

    m_pAltMapping = NULL;
    m_cAltMapping = 0;

    return fSt;
}


BOOL
CIisAcctMapper::GetMapping(
    DWORD           iIndex,
    CIisMapping**   pM,
    BOOL            fGetFromAlternate,
    BOOL            fPutOnAlternate
    )
/*++

Routine Description:

    Get mapping entry based on index

Arguments:

    iIndex -- index in mapping array
    pM -- updated with pointer to mapping. mapping object
          still owned by the mapper object.
    fGetFromAlternate -- TRUE if retrieve from alternate list
    fPutOnAlternate -- TRUE if put returned mapping on alternate list

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( fPutOnAlternate )
    {
        // create alternate list if not exist

        if ( !m_pAltMapping && m_cMapping )
        {
            m_pAltMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*(m_cMapping) );
            if ( m_pAltMapping == NULL )
            {
                return FALSE;
            }

            memset( m_pAltMapping, '\0', sizeof(CIisMapping*) * m_cMapping );

            m_cAltMapping = m_cMapping;
        }

        if ( iIndex < m_cAltMapping )
        {
            if ( m_pAltMapping[iIndex] == NULL &&
                 m_pMapping != NULL )   // work-around for compiler bug
            {
                // duplicate mapping to alternate list if not exist
                if ( m_pMapping[iIndex]->Clone( pM ) )
                {
                    m_pAltMapping[iIndex] = *pM;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                *pM = m_pAltMapping[iIndex];
            }
            return TRUE;
        }

        return FALSE;
    }

    if ( fGetFromAlternate &&
         m_pAltMapping &&
         iIndex < m_cAltMapping )
    {
        if ( m_pAltMapping[iIndex] )
        {
            *pM = m_pAltMapping[iIndex];
        }
        else
        {
            *pM = m_pMapping[iIndex];
        }

        return TRUE;
    }

    if ( iIndex < m_cMapping )
    {
        *pM = m_pMapping[iIndex];

        return TRUE;
    }

    return FALSE;
}


BOOL
CIisAcctMapper::GetMappingForUpdate(
    DWORD iIndex,
    CIisMapping** pM
    )
/*++

Routine Description:

    Get mapping entry based on index
    returns a copy of the mapping so update is cancelable

Arguments:

    iIndex -- index in mapping array
    pM -- updated with pointer to mapping. mapping object
          still owned by the mapper object.

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( iIndex < m_cMapping )
    {
        if ( (*pM = CreateNewMapping()) == NULL )
        {
            return FALSE;
        }

        return (*pM)->Copy( m_pMapping[iIndex] );
    }

    return FALSE;
}


BOOL
CIisAcctMapper::Update(
    DWORD iIndex,
    CIisMapping* pM
    )
/*++

Routine Description:

    Update a mapping

Arguments:

    iIndex -- index in mapping array
    pM -- pointer to mapping.

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( iIndex < m_cMapping )
    {
        pM->UpdateMask( m_pHierarchy, m_cHierarchy);

        return m_pMapping[iIndex]->Copy( pM ) && UpdateClasses( FALSE );
    }

    return FALSE;
}


BOOL
CIisAcctMapper::Update(
    DWORD iIndex
    )
/*++

Routine Description:

    Update a mapping

Arguments:

    iIndex -- index in mapping array

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( iIndex < m_cMapping )
    {
        return m_pMapping[iIndex]->UpdateMask( m_pHierarchy, m_cHierarchy);
    }

    return FALSE;
}


BOOL
CIisAcctMapper::Add(
    CIisMapping*    pM,
    BOOL            fAlternate
    )
/*++

Routine Description:

    Add a mapping entry to mapping array
    Transfer ownership of mapping object to mapper

Arguments:

    pM -- pointer to mapping to be added to mapper
    fAlternate - TRUE if add to alternate list

Returns:

    TRUE if success, FALSE if error

--*/
{
    CIisMapping **pMapping;

    if ( fAlternate )
    {
        DWORD           dwC  = m_pAltMapping ? m_cAltMapping : m_cMapping;
        CIisMapping**   pMap = m_pAltMapping ? m_pAltMapping : m_pMapping;

        pMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*(dwC+1) );
        if ( pMapping == NULL )
        {
            return FALSE;
        }

        if ( m_pAltMapping )
        {
            memcpy( pMapping, pMap, sizeof(CIisMapping*) * dwC );
            LocalFree( m_pAltMapping );
        }
        else
        {
            memset( pMapping, '\0', dwC * sizeof(LPVOID) );
        }
        m_pAltMapping = pMapping;
        m_pAltMapping[dwC] = pM;
        m_cAltMapping = dwC + 1;

        return TRUE;
    }
    else
    {
        pMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*(m_cMapping+1) );
        if ( pMapping == NULL )
        {
            return FALSE;
        }

        if ( m_pMapping )
        {
            memcpy( pMapping, m_pMapping, sizeof(CIisMapping*) * m_cMapping );
            LocalFree( m_pMapping );
        }
        m_pMapping = pMapping;
        pM->UpdateMask( m_pHierarchy, m_cHierarchy );
        m_pMapping[m_cMapping] = pM;
        ++m_cMapping;

        SortMappings();

        return UpdateClasses( FALSE );
    }
}


DWORD
CIisAcctMapper::AddEx(
    CIisMapping* pM
    )
/*++

Routine Description:

    Add a mapping entry to mapping array
    Transfer ownership of mapping object to mapper

Arguments:

    pM -- pointer to mapping to be added to mapper

Returns:

    Index of entry if success, otherwise 0xffffffff

--*/
{
    CIisMapping **pMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*(m_cMapping+1) );
    if ( pMapping == NULL )
    {
        return 0xffffffff;
    }

    if ( m_pMapping )
    {
        memcpy( pMapping, m_pMapping, sizeof(CIisMapping*) * m_cMapping );
        LocalFree( m_pMapping );
    }
    m_pMapping = pMapping;
    pM->UpdateMask( m_pHierarchy, m_cHierarchy );
    m_pMapping[m_cMapping] = pM;
    ++m_cMapping;

    SortMappings();

    if ( UpdateClasses( FALSE ) )
    {
        return m_cMapping-1;
    }

    return 0xffffffff;
}


VOID
CIisAcctMapper::DeleteMappingObject(
    CIisMapping *pM
    )
/*++

Routine Description:

    Delete a mapping object

Arguments:

    pM - ptr to mapping object

Returns:

    Nothing

--*/
{
    delete pM;
}


BOOL
CIisAcctMapper::Delete(
    DWORD   dwIndex,
    BOOL    fUseAlternate
    )
/*++

Routine Description:

    Delete a mapping entry based on index

Arguments:

    iIndex -- index in mapping array
    fUseAlternate -- TRUE if update alternate list

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT        i;
    UINT        iM;

    if ( fUseAlternate )
    {
        //
        // clone all entries from main to alternate list
        //

        if ( !m_pAltMapping )
        {
            m_pAltMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*(m_cMapping) );
            if ( m_pAltMapping == NULL )
            {
                return FALSE;
            }

            memset( m_pAltMapping, '\0', sizeof(CIisMapping*) * m_cMapping );
            m_cAltMapping = m_cMapping;
        }

        iM = min( m_cMapping, m_cAltMapping );

        for ( i = 0 ; i < iM ; ++i )
        {
            if ( m_pAltMapping[i] == NULL )
            {
                if ( !m_pMapping[i]->Clone( &m_pAltMapping[i] ) )
                {
                    return FALSE;
                }
            }
        }

        if ( dwIndex < m_cAltMapping )
        {
            delete m_pAltMapping[dwIndex];

            memmove( m_pAltMapping+dwIndex,
                     m_pAltMapping+dwIndex+1,
                     (m_cAltMapping - dwIndex - 1) * sizeof(CIisMapping*) );

            --m_cAltMapping;

            return TRUE;
        }

        return FALSE;
    }

    if ( dwIndex < m_cMapping )
    {
        delete m_pMapping[dwIndex];

        memmove( m_pMapping+dwIndex,
                 m_pMapping+dwIndex+1,
                 (m_cMapping - dwIndex - 1) * sizeof(CIisMapping*) );

        --m_cMapping;

        return UpdateClasses( FALSE );
    }

    return FALSE;
}


BOOL
CIisAcctMapper::Save(
    )
/*++

Routine Description:

    Save mapper ( mappings, hierarchy, derived class private data )
    to a file, updating registry entry with MD5 signature

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT    x;
    FILE *  fOut = NULL;
    BOOL    fSt = TRUE;
    DWORD   dwVal;
    DWORD   st;
    IIS_CRYPTO_STORAGE  storage;
    PIIS_CRYPTO_BLOB    blob;

    Lock();

    MD5Init( &m_md5 );

    if ( FAILED(storage.Initialize()) )
    {
        fSt = FALSE;
        goto cleanup;
    }

    if ( m_pSesKey != NULL )
    {
        LocalFree( m_pSesKey );
        m_pSesKey = NULL;
        m_dwSesKey = 0;
    }
    if ( FAILED( storage.GetSessionKeyBlob( &blob ) ) )
    {
        fSt = FALSE;
        goto cleanup;
    }
    m_dwSesKey = IISCryptoGetBlobLength( blob );
    if ( (m_pSesKey = (LPBYTE)LocalAlloc( LMEM_FIXED, m_dwSesKey)) == NULL )
    {
        m_dwSesKey = 0;
        fSt = FALSE;
        goto cleanup;
    }
    memcpy( m_pSesKey, (LPBYTE)blob, m_dwSesKey );

    if ( (fOut = fopen( m_achFileName, "wb" )) == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }

    // magic value & version

    dwVal = IISMDB_FILE_MAGIC_VALUE;
    if( fwrite( (LPVOID)&dwVal, sizeof(dwVal), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }
    MD5Update( &m_md5, (LPBYTE)&dwVal, sizeof(dwVal) );

    dwVal = IISMDB_CURRENT_VERSION;
    if( fwrite( (LPVOID)&dwVal, sizeof(dwVal), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }
    MD5Update( &m_md5, (LPBYTE)&dwVal, sizeof(dwVal) );

    // mappings

    if( fwrite( (LPVOID)&m_cMapping, sizeof(m_cMapping), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( &m_md5, (LPBYTE)&m_cMapping, sizeof(m_cMapping) );

    for ( x = 0 ; x < m_cMapping ; ++x )
    {
        if ( !m_pMapping[x]->Serialize( fOut ,(VALID_CTX)&m_md5, (LPVOID)&storage) )
        {
            fSt = FALSE;
            goto cleanup;
        }
    }

    // save hierarchy

    if( fwrite( (LPVOID)&m_cHierarchy, sizeof(m_cHierarchy), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( &m_md5, (LPBYTE)&m_cHierarchy, sizeof(m_cHierarchy) );

    if( fwrite( (LPVOID)m_pHierarchy, sizeof(IISMDB_HEntry), m_cHierarchy, fOut ) != m_cHierarchy )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( &m_md5, (LPBYTE)m_pHierarchy, sizeof(IISMDB_HEntry)*m_cHierarchy );

    // save private data

    fSt = SavePrivate( fOut, (VALID_CTX)&m_md5 );

    MD5Final( &m_md5 );

cleanup:
    if ( fOut != NULL )
    {
        fclose( fOut );
    }

    // update registry

    if ( !fSt )
    {
        memset( m_md5.digest, '\0', sizeof(m_md5.digest) );
    }

    Unlock();

    return fSt;
}


BOOL
CIisAcctMapper::Reset(
    )
/*++

Routine Description:

    Reset mapper to empty state

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;

    // free all mapping
    if ( m_pMapping != NULL )
    {
        for ( x = 0 ; x < m_cMapping ; ++x )
        {
            delete m_pMapping[x];
        }

        LocalFree( m_pMapping );
        m_pMapping = NULL;
    }
    m_cMapping = 0;

    if ( m_pClasses != NULL )
    {
        LocalFree( m_pClasses );
        m_pClasses = NULL;
    }

    // default hierarchy

    if ( m_pHierarchy == NULL )
    {
        IISMDB_HEntry *pH = GetDefaultHierarchy( &m_cHierarchy );
        m_pHierarchy = (IISMDB_HEntry*)LocalAlloc( LMEM_FIXED, sizeof(IISMDB_HEntry)*m_cHierarchy );
        if ( m_pHierarchy == NULL )
        {
            return FALSE;
        }
        memcpy( m_pHierarchy, pH, m_cHierarchy * sizeof(IISMDB_HEntry) );
    }

    return ResetPrivate();
}


BOOL
CIisAcctMapper::Load(
    )
/*++

Routine Description:

    Load mapper ( mappings, hierarchy, derived class private data )
    from a file, checking registry entry for MD5 signature

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT    x;
    MD5_CTX md5Check;
    FILE *  fIn;
    BOOL    fSt = TRUE;
    DWORD dwType;
    DWORD dwLen;
    DWORD dwVal;
    IIS_CRYPTO_STORAGE  storage;

    Reset();

    MD5Init( &md5Check );
    if ( FAILED( storage.Initialize( (PIIS_CRYPTO_BLOB)m_pSesKey) ) )
    {
        return FALSE;
    }

    if ( (fIn = fopen( m_achFileName, "rb" )) == NULL )
    {
        return FALSE;
    }

    // magic value & version

    if( fread( (LPVOID)&dwVal, sizeof(dwVal), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }
    if ( dwVal  != IISMDB_FILE_MAGIC_VALUE )
    {
        SetLastError( ERROR_BAD_FORMAT );
        fSt = FALSE;
        goto cleanup;
    }
    MD5Update( &md5Check, (LPBYTE)&dwVal, sizeof(dwVal) );

    if( fread( (LPVOID)&dwVal, sizeof(dwVal), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }
    MD5Update( &md5Check, (LPBYTE)&dwVal, sizeof(dwVal) );

    // mappings

    if( fread( (LPVOID)&m_cMapping, sizeof(m_cMapping), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( &md5Check, (LPBYTE)&m_cMapping, sizeof(m_cMapping) );

    m_pMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*m_cMapping );
    if ( m_pMapping == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }

    for ( x = 0 ; x < m_cMapping ; ++x )
    {
        if ( !(m_pMapping[x] = CreateNewMapping()) )
        {
            m_cMapping = x;
            fSt = FALSE;
            goto cleanup;
        }
        if ( !m_pMapping[x]->Deserialize( fIn ,(VALID_CTX)&md5Check, (LPVOID)&storage ) )
        {
            m_cMapping = x;
            fSt = FALSE;
            goto cleanup;
        }
    }

    // load hierarchy

    if( fread( (LPVOID)&m_cHierarchy, sizeof(m_cHierarchy), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( &md5Check, (LPBYTE)&m_cHierarchy, sizeof(m_cHierarchy) );

    m_pHierarchy = (IISMDB_HEntry*)LocalAlloc( LMEM_FIXED, sizeof(IISMDB_HEntry)*m_cHierarchy );
    if ( m_pHierarchy == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }

    if( fread( (LPVOID)m_pHierarchy, sizeof(IISMDB_HEntry), m_cHierarchy, fIn ) != m_cHierarchy )
    {
        fSt = FALSE;
        goto cleanup;
    }

    //
    // insure hierarchy correct
    //

    for ( x = 0 ; x < m_cHierarchy; ++x )
    {
        if ( m_pHierarchy[x].m_dwIndex >= m_cFields )
        {
            fSt = FALSE;
            goto cleanup;
        }
    }

    MD5Update( &md5Check, (LPBYTE)m_pHierarchy, sizeof(IISMDB_HEntry)*m_cHierarchy );

    // load private data

    fSt = LoadPrivate( fIn, (VALID_CTX)&md5Check );

    MD5Final( &md5Check );

#if 0
    //
    // Don't use signature for now - a metabase Restore operation
    // may have restored another signature, so metabase and
    // file won't match
    //

    if ( !(fSt = !memcmp( m_md5.digest,
                md5Check.digest,
                sizeof(md5Check.digest) )) )
    {
        SetLastError( ERROR_INVALID_ACCESS );
    }
#endif

cleanup:
    fclose( fIn );

    if ( !fSt && GetLastError() != ERROR_INVALID_ACCESS )
    {
        Reset();
    }
    else
    {
        UpdateClasses();
    }

    if ( !fSt )
    {
        char achErr[32];
        LPCTSTR pA[2];
        pA[0] = m_achFileName;
        pA[1] = achErr;
        _itoa( GetLastError(), achErr, 10 );
        ReportIisMapEvent( EVENTLOG_ERROR_TYPE,
                IISMAP_EVENT_LOAD_ERROR,
                2,
                pA );
    }

    return fSt;
}


// CIisCertMapper

CIisCertMapper::CIisCertMapper(
    )
/*++

Routine Description:

    Constructor for CIisCertMapper

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pIssuers = NULL;
    m_cIssuers = 0;

    m_pFields = IisCertMappingFields;
    m_cFields = sizeof(IisCertMappingFields)/sizeof(IISMDB_Fields);

    m_dwOptions = IISMDB_CERT_OPTIONS;
}


CIisCertMapper::~CIisCertMapper(
    )
/*++

Routine Description:

    Destructor for CIisCertMapper

Arguments:

    None

Returns:

    Nothing

--*/
{
}


IISMDB_HEntry*
CIisCertMapper::GetDefaultHierarchy(
    LPDWORD pdwN
    )
/*++

Routine Description:

    return ptr to default hierarchy for certificates mapping

Arguments:

    pdwN -- updated with hierarchy entries count

Returns:

    ptr to hierarchy entries or NULL if error

--*/
{
    *pdwN = sizeof(IisCertMappingHierarchy) / sizeof(IISMDB_HEntry);

    return IisCertMappingHierarchy;
}


#if defined(DECODE_ASN1)
CIisMapping*
CIisCertMapper::CreateNewMapping(
    Cert_Map *pC
    )
/*++

Routine Description:

    Create a new mapping from a certificate

Arguments:

    pC -- ptr to certificate issuer & subject

Returns:

    ptr to mapping. ownership of this object is transfered to caller.
    NULL if error

--*/
{
    CCertMapping *pCM = new CCertMapping( this );
    if ( pCM == NULL )
    {
        return NULL;
    }

    if ( pCM->Init( pC, m_pHierarchy, m_cHierarchy ) )
    {
        return (CIisMapping*)pCM;
    }
    delete pCM;

    return NULL;
}


CIisMapping*
CIisCertMapper::CreateNewMapping(
    const LPBYTE pC,
    DWORD cC
    )
/*++

Routine Description:

    Create a new mapping from a certificate

Arguments:

    pC -- ptr to certificate issuer & subject
    cC -- size of buffer pointed to by pC

Returns:

    ptr to mapping. ownership of this object is transfered to caller.
    NULL if error

--*/
{
    CCertMapping *pCM = new CCertMapping( this );
    if ( pCM == NULL )
    {
        return NULL;
    }

    if ( pCM->Init( pC, cC, m_pHierarchy, m_cHierarchy ) )
    {
        return (CIisMapping*)pCM;
    }
    delete pCM;

    return NULL;
}
#endif


BOOL
CIisCertMapper::ResetPrivate(
    )
/*++

Routine Description:

    Reset CIisCertMapper issuer list

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    // free issuer list

    if ( m_pIssuers != NULL )
    {
        for ( UINT x = 0 ; x < m_cIssuers ; ++x )
        {
            LocalFree( m_pIssuers[x].pbIssuer );
        }
        LocalFree( m_pIssuers );
        m_pIssuers = NULL;
    }
    m_cIssuers = 0;

    return TRUE;
}


BOOL
CIisCertMapper::LoadPrivate(
    FILE* fIn,
    VALID_CTX pMD5
    )
/*++

Routine Description:

    Load issuer list

Arguments:

    fIn -- file to read from
    pMD5 -- MD5 to update with signature from input byte stream

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    UINT x;

    if( fread( (LPVOID)&m_cIssuers, sizeof(m_cIssuers), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_cIssuers, sizeof(m_cIssuers) );

    m_pIssuers = (IssuerAccepted*)LocalAlloc( LMEM_FIXED, sizeof(IssuerAccepted)*m_cIssuers );
    if ( m_pIssuers == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }

    for ( x = 0 ; x < m_cIssuers ; ++x )
    {
        if ( fread( (LPVOID)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen), 1, fIn ) != 1 )
        {
            m_cIssuers = x;
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen) );

        if ( (m_pIssuers[x].pbIssuer = (LPBYTE)LocalAlloc( LMEM_FIXED, m_pIssuers[x].cbIssuerLen )) == NULL )
        {
            m_cIssuers = x;
            fSt = FALSE;
            goto cleanup;
        }
        if ( fread( m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen, 1, fIn ) != 1 )
        {
            m_cIssuers = x;
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen );
    }

cleanup:
    return fSt;
}


BOOL
CIisCertMapper::SavePrivate(
    FILE* fOut,
    VALID_CTX pMD5
    )
/*++

Routine Description:

    Save issuer list

Arguments:

    fOut -- file to write to
    pMD5 -- MD5 to update with signature of output byte stream

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    UINT x;

    if( fwrite( (LPVOID)&m_cIssuers, sizeof(m_cIssuers), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_cIssuers, sizeof(m_cIssuers) );

    for ( x = 0 ; x < m_cIssuers ; ++x )
    {
        if ( fwrite( (LPVOID)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen), 1, fOut ) != 1 )
        {
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen) );

        if ( fwrite( m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen, 1, fOut ) != 1 )
        {
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen );
    }

cleanup:
    return fSt;
}


BOOL
CIisCertMapper::SetIssuerList(
    IssuerAccepted*pI,
    DWORD dwC
    )
/*++

Routine Description:

    Set the issuer list by copying supplied list

Arguments:

    pI -- list of issuers
    dwC -- count of issuers

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;

    if ( (m_pIssuers = (IssuerAccepted*)LocalAlloc( LMEM_FIXED, sizeof(IssuerAccepted)*dwC )) == NULL )
    {
        return FALSE;
    }

    for ( x = 0 ; x < dwC ; ++x )
    {
        m_pIssuers[x].cbIssuerLen = pI[x].cbIssuerLen;
        if ( (m_pIssuers[x].pbIssuer = (LPBYTE)LocalAlloc( LMEM_FIXED, pI[x].cbIssuerLen )) == NULL )
        {
            m_cIssuers = x;
            return FALSE;
        }
        memcpy( m_pIssuers[x].pbIssuer, pI[x].pbIssuer, pI[x].cbIssuerLen );
    }
    m_cIssuers = dwC;

    return TRUE;
}


BOOL
CIisCertMapper::GetIssuerList(
    IssuerAccepted**pIssuers,
    DWORD*pdwI
    )
/*++

Routine Description:

    Retrieve the issuer list. Ownership of list transferred to caller

Arguments:

    pI -- updated with ptr to array of issuers
    pdwI -- updated with count of issuers

Returns:

    TRUE if success, FALSE if error

--*/
{
    IssuerAccepted *pI;

    Lock();

    pI = (IssuerAccepted*)LocalAlloc( LMEM_FIXED, m_cIssuers * sizeof(IssuerAccepted*) );
    if ( pI == NULL )
    {
        Unlock();
        return FALSE;
    }

    for ( UINT x = 0 ; x < m_cIssuers ; ++x )
    {
        if ( (pI[x].pbIssuer = (LPBYTE)LocalAlloc( LMEM_FIXED,
                m_pIssuers[x].cbIssuerLen ))
             == NULL )
        {
            Unlock();
            DeleteIssuerList( pI, x );
            return FALSE;
        }
        memcpy( pI[x].pbIssuer,
                m_pIssuers[x].pbIssuer,
                m_pIssuers[x].cbIssuerLen );
    }

    *pIssuers = pI;
    *pdwI = m_cIssuers;

    Unlock();

    return TRUE;
}



BOOL
CIisCertMapper::DeleteIssuerList(
    IssuerAccepted* pI,
    DWORD dwI
    )
/*++

Routine Description:

    Delete an issuer list.

Arguments:

    pI -- ptr to array of issuers
    dwI -- count of issuers

Returns:

    TRUE if success, FALSE if error

--*/
{
    for ( DWORD x = 0 ; x < dwI ; ++x )
    {
        LocalFree( pI[x].pbIssuer );
    }
    LocalFree( pI );

    return TRUE;
}


BOOL
CIisCertMapper::GetIssuerBuffer(
    LPBYTE      pB,
    DWORD*      pdwI
    )
/*++

Routine Description:

    Retrieve the issuer list. Ownership of list transferred to caller

Arguments:

    pB -- updated with ptr to issuers buffer
    pdwI -- updated with size of buffer of issuers

Returns:

    TRUE if success, FALSE if error

--*/
{
    LPBYTE  pS;
    DWORD   dwC = 0;

    Lock();

    for ( UINT x = 0 ; x < m_cIssuers ; ++x )
    {
        dwC += m_pIssuers[x].cbIssuerLen + sizeof(USHORT);
    }

    *pdwI = dwC;

    if ( pB != NULL )
    {
        for ( pS = pB, x = 0 ; x < m_cIssuers ; ++x )
        {
            pS[0] = (BYTE)(m_pIssuers[x].cbIssuerLen >> 8);
            pS[1] = (BYTE)(m_pIssuers[x].cbIssuerLen);
            memcpy( pS + sizeof(USHORT),
                    m_pIssuers[x].pbIssuer,
                    m_pIssuers[x].cbIssuerLen );
            pS += m_pIssuers[x].cbIssuerLen + sizeof(USHORT);
        }
    }

    Unlock();

    return TRUE;
}



BOOL
CIisCertMapper::FreeIssuerBuffer(
    LPBYTE pI
    )
/*++

Routine Description:

    Delete an issuer list.

Arguments:

    pI -- ptr to issuers

Returns:

    TRUE if success, FALSE if error

--*/
{
    LocalFree( pI );

    return TRUE;
}


// CIisCert11Mapper

CIisCert11Mapper::CIisCert11Mapper(
    )
/*++

Routine Description:

    Constructor for CIisCert11Mapper

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pIssuers = NULL;
    m_cIssuers = 0;

    m_pFields = IisCert11MappingFields;
    m_cFields = sizeof(IisCert11MappingFields)/sizeof(IISMDB_Fields);

    m_dwOptions = IISMDB_CERT11_OPTIONS;

    m_pSubjectSource = NULL;
    m_pDefaultDomain = NULL;
}


CIisCert11Mapper::~CIisCert11Mapper(
    )
/*++

Routine Description:

    Destructor for CIisCert11Mapper

Arguments:

    None

Returns:

    Nothing

--*/
{
}


BOOL
CIisCert11Mapper::Add(
    CIisMapping* pM
    )
/*++

Routine Description:

    Add a mapping entry to mapping array
    Transfer ownership of mapping object to mapper
    Check is mapping to same NT account does not already exist.

Arguments:

    pM -- pointer to mapping to be added to mapper

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;
    LPSTR pA;
    LPSTR pF;
    DWORD dwA;
    DWORD dwF;

    // check if NT acct not already present.
    // if so, return FALSE, SetLastError( ERROR_INVALID_PARAMETER );

    if ( pM == NULL )
    {
        return FALSE;
    }

#if 0
    if ( !pM->MappingGetField( IISMDB_INDEX_CERT11_NT_ACCT, &pA, &dwA, FALSE )
         || pA == NULL )
    {
        pA = "";
    }

    for ( x = 0 ; x < m_cMapping ; ++x )
    {
        if ( !m_pMapping[x]->MappingGetField( IISMDB_INDEX_CERT11_NT_ACCT, &pF, &dwF, FALSE )
             || pF == NULL )
        {
            pF = "";
        }
        if ( dwA == dwF && !memcmp( pF, pA, dwF ) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }
#endif

#if 1
#if defined(CERT11_FULL_CERT)
    LPSTR pCe;
    DWORD dwCe;
    LPSTR pCeIter;
    DWORD dwCeIter;

    if ( !pM->MappingGetField( IISMDB_INDEX_CERT11_CERT, &pCe, &dwCe, FALSE )
         || pCe == NULL )
    {
        dwCe = 0;
    }

    for ( x = 0 ; x < m_cMapping ; ++x )
    {
        if ( !m_pMapping[x]->MappingGetField( IISMDB_INDEX_CERT11_CERT, &pCeIter, &dwCeIter, FALSE )
             || pCeIter == NULL )
        {
            dwCeIter  = 0;
        }
        if ( dwCe == dwCeIter && !memcmp( pCe, pCeIter, dwCe ) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }
#else
    LPSTR pSu;
    LPSTR pIs;
    DWORD dwSu;
    DWORD dwIs;
    LPSTR pSuIter;
    LPSTR pIsIter;
    DWORD dwSuIter;
    DWORD dwIsIter;

    if ( !pM->MappingGetField( IISMDB_INDEX_CERT11_SUBJECT, &pSu, &dwSu, FALSE )
         || pSu == NULL )
    {
        dwSu = 0;
    }

    if ( !pM->MappingGetField( IISMDB_INDEX_CERT11_ISSUER, &pIs, &dwIs, FALSE )
         || pIs == NULL )
    {
        dwIs = 0;
    }

    for ( x = 0 ; x < m_cMapping ; ++x )
    {
        if ( !m_pMapping[x]->MappingGetField( IISMDB_INDEX_CERT11_SUBJECT, &pSuIter, &dwSuIter, FALSE )
             || pSuIter == NULL )
        {
            dwSuIter  = 0;
        }
        if ( !m_pMapping[x]->MappingGetField( IISMDB_INDEX_CERT11_ISSUER, &pIsIter, &dwIsIter, FALSE )
             || pIsIter == NULL )
        {
            dwIsIter  = 0;
        }
        if ( dwSu == dwSuIter && !memcmp( pSu, pSuIter, dwSu ) &&
             dwIs == dwIsIter && !memcmp( pIs, pIsIter, dwIs ) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }
#endif
#endif

    return CIisAcctMapper::Add( pM );
}


IISMDB_HEntry*
CIisCert11Mapper::GetDefaultHierarchy(
    LPDWORD pdwN
    )
/*++

Routine Description:

    return ptr to default hierarchy for certificates mapping

Arguments:

    pdwN -- updated with hierarchy entries count

Returns:

    ptr to hierarchy entries or NULL if error

--*/
{
    *pdwN = sizeof(IisCert11MappingHierarchy) / sizeof(IISMDB_HEntry);

    return IisCert11MappingHierarchy;
}


#if defined(CERT11_FULL_CERT)

CIisMapping*
CIisCert11Mapper::CreateNewMapping(
    LPBYTE pC,
    DWORD dwC
    )
/*++

Routine Description:

    Create a new mapping from a certificate

Arguments:

    pC -- cert ( ASN.1 format )
    dwC -- length of cert

Returns:

    ptr to mapping. ownership of this object is transfered to caller.
    NULL if error

--*/
{
    CCert11Mapping *pCM = new CCert11Mapping( this );
    if ( pCM == NULL )
    {
        return NULL;
    }

    if ( pCM->Init( pC, dwC, m_pHierarchy, m_cHierarchy ) )
    {
        return (CIisMapping*)pCM;
    }
    delete pCM;

    return NULL;
}

#else

CIisMapping*
CIisCert11Mapper::CreateNewMapping(
    LPBYTE pI,
    DWORD dwI,
    LPBYTE pS,
    DWORD dwS
    )
/*++

Routine Description:

    Create a new mapping from a certificate

Arguments:

    pI -- cert issuer ( ASN.1 format )
    dwI -- length of issuer
    pS -- cert subject ( ASN.1 format )
    dwS -- length of subject

Returns:

    ptr to mapping. ownership of this object is transfered to caller.
    NULL if error

--*/
{
    CCert11Mapping *pCM = new CCert11Mapping( this );
    if ( pCM == NULL )
    {
        return NULL;
    }

    if ( pCM->Init( pI, dwI, pS, dwS, m_pHierarchy, m_cHierarchy ) )
    {
        return (CIisMapping*)pCM;
    }
    delete pCM;

    return NULL;
}

#endif


BOOL
CIisCert11Mapper::ResetPrivate(
    )
/*++

Routine Description:

    Reset CIisCert11Mapper issuer list

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    // free issuer list

    if ( m_pIssuers != NULL )
    {
        for ( UINT x = 0 ; x < m_cIssuers ; ++x )
        {
            LocalFree( m_pIssuers[x].pbIssuer );
        }
        LocalFree( m_pIssuers );
        m_pIssuers = NULL;
    }
    m_cIssuers = 0;

    if ( m_pSubjectSource != NULL )
    {
        LocalFree( m_pSubjectSource );
    }

    if ( m_pDefaultDomain != NULL )
    {
        LocalFree( m_pDefaultDomain );
    }

    return TRUE;
}


BOOL
CIisCert11Mapper::LoadPrivate(
    FILE* fIn,
    VALID_CTX pMD5
    )
/*++

Routine Description:

    Load issuer list

Arguments:

    fIn -- file to read from
    pMD5 -- MD5 to update with signature from input byte stream

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL    fSt = TRUE;
    UINT    x;
    UINT    cLen;
    CHAR    achBuf[64];

    if( fread( (LPVOID)&m_cIssuers, sizeof(m_cIssuers), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_cIssuers, sizeof(m_cIssuers) );

    m_pIssuers = (IssuerAccepted*)LocalAlloc( LMEM_FIXED, sizeof(IssuerAccepted)*m_cIssuers );
    if ( m_pIssuers == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }

    for ( x = 0 ; x < m_cIssuers ; ++x )
    {
        if ( fread( (LPVOID)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen), 1, fIn ) != 1 )
        {
            m_cIssuers = x;
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen) );

        if ( (m_pIssuers[x].pbIssuer = (LPBYTE)LocalAlloc( LMEM_FIXED, m_pIssuers[x].cbIssuerLen )) == NULL )
        {
            m_cIssuers = x;
            fSt = FALSE;
            goto cleanup;
        }
        if ( fread( m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen, 1, fIn ) != 1 )
        {
            m_cIssuers = x;
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen );
    }

    //
    // Read subject source
    //

    if( Iisfgets( achBuf, sizeof(achBuf), fIn ) == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }
    cLen = strlen(achBuf);
    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)achBuf, cLen );
    if ( !(m_pSubjectSource = (LPSTR)LocalAlloc( LMEM_FIXED, cLen+1 )) )
    {
        fSt = FALSE;
        goto cleanup;
    }
    memcpy( m_pSubjectSource, achBuf, cLen+1 );

    //
    // Read default domain
    //

    if( Iisfgets( achBuf, sizeof(achBuf), fIn ) == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }
    cLen = strlen(achBuf);
    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)achBuf, cLen );
    if ( !(m_pDefaultDomain = (LPSTR)LocalAlloc( LMEM_FIXED, cLen+1 )) )
    {
        fSt = FALSE;
        goto cleanup;
    }
    memcpy( m_pDefaultDomain, achBuf, cLen+1 );

cleanup:
    return fSt;
}


BOOL
CIisCert11Mapper::SavePrivate(
    FILE* fOut,
    VALID_CTX pMD5
    )
/*++

Routine Description:

    Save issuer list

Arguments:

    fOut -- file to write to
    pMD5 -- MD5 to update with signature of output byte stream

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    UINT x;

    if( fwrite( (LPVOID)&m_cIssuers, sizeof(m_cIssuers), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_cIssuers, sizeof(m_cIssuers) );

    for ( x = 0 ; x < m_cIssuers ; ++x )
    {
        if ( fwrite( (LPVOID)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen), 1, fOut ) != 1 )
        {
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen) );

        if ( fwrite( m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen, 1, fOut ) != 1 )
        {
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen );
    }

    //
    // Write subject source
    //

    if ( m_pSubjectSource )
    {
        if( Iisfputs( m_pSubjectSource, fOut ) == EOF )
        {
            fSt = FALSE;
            goto cleanup;
        }
        MD5Update( (MD5_CTX*)pMD5, (LPBYTE)m_pSubjectSource, strlen( m_pSubjectSource ) );
    }
    else
    {
        Iisfputs( "", fOut );
    }

    //
    // Write default domain
    //

    if ( m_pDefaultDomain )
    {
        if( Iisfputs( m_pDefaultDomain, fOut ) == EOF )
        {
            fSt = FALSE;
            goto cleanup;
        }
        MD5Update( (MD5_CTX*)pMD5, (LPBYTE)m_pDefaultDomain, strlen( m_pDefaultDomain ) );
    }
    else
    {
        Iisfputs( "", fOut );
    }

cleanup:
    return fSt;
}


BOOL
CIisCert11Mapper::SetSubjectSource(
    LPSTR psz
    )
/*++

Routine Description:

    Set the subject field to use as source for NT acct

Arguments:

    psz - ASN.1 name of field to use

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( m_pSubjectSource != NULL )
    {
        LocalFree( m_pSubjectSource );
    }

    if ( m_pSubjectSource = (LPSTR)LocalAlloc( LMEM_FIXED, strlen(psz)+1) )
    {
        strcpy( m_pSubjectSource, psz );
        return TRUE;
    }

    return FALSE;
}


BOOL
CIisCert11Mapper::SetDefaultDomain(
    LPSTR psz
    )
/*++

Routine Description:

    Set the domain to use for NT acct

Arguments:

    psz - domain name

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( m_pDefaultDomain != NULL )
    {
        LocalFree( m_pDefaultDomain );
    }

    if ( m_pDefaultDomain = (LPSTR)LocalAlloc( LMEM_FIXED, strlen(psz)+1) )
    {
        strcpy( m_pDefaultDomain, psz );
        return TRUE;
    }

    return FALSE;
}


BOOL
CIisCert11Mapper::SetIssuerList(
    IssuerAccepted*pI,
    DWORD dwC
    )
/*++

Routine Description:

    Set the issuer list by copying supplied list

Arguments:

    pI -- list of issuers
    dwC -- count of issuers

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;

    if ( (m_pIssuers = (IssuerAccepted*)LocalAlloc( LMEM_FIXED, sizeof(IssuerAccepted)*dwC )) == NULL )
    {
        return FALSE;
    }

    for ( x = 0 ; x < dwC ; ++x )
    {
        m_pIssuers[x].cbIssuerLen = pI[x].cbIssuerLen;
        if ( (m_pIssuers[x].pbIssuer = (LPBYTE)LocalAlloc( LMEM_FIXED, pI[x].cbIssuerLen )) == NULL )
        {
            m_cIssuers = x;
            return FALSE;
        }
        memcpy( m_pIssuers[x].pbIssuer, pI[x].pbIssuer, pI[x].cbIssuerLen );
    }
    m_cIssuers = dwC;

    return TRUE;
}


BOOL
CIisCert11Mapper::GetIssuerList(
    IssuerAccepted**pIssuers,
    DWORD*pdwI
    )
/*++

Routine Description:

    Retrieve the issuer list. Ownership of list transferred to caller

Arguments:

    pI -- updated with ptr to array of issuers
    pdwI -- updated with count of issuers

Returns:

    TRUE if success, FALSE if error

--*/
{
    IssuerAccepted *pI;

    Lock();

    pI = (IssuerAccepted*)LocalAlloc( LMEM_FIXED, m_cIssuers * sizeof(IssuerAccepted*) );
    if ( pI == NULL )
    {
        Unlock();
        return FALSE;
    }

    for ( UINT x = 0 ; x < m_cIssuers ; ++x )
    {
        if ( (pI[x].pbIssuer = (LPBYTE)LocalAlloc( LMEM_FIXED,
                m_pIssuers[x].cbIssuerLen ))
             == NULL )
        {
            Unlock();
            DeleteIssuerList( pI, x );
            return FALSE;
        }
        memcpy( pI[x].pbIssuer,
                m_pIssuers[x].pbIssuer,
                m_pIssuers[x].cbIssuerLen );
    }

    *pIssuers = pI;
    *pdwI = m_cIssuers;

    Unlock();

    return TRUE;
}



BOOL
CIisCert11Mapper::DeleteIssuerList(
    IssuerAccepted* pI,
    DWORD dwI
    )
/*++

Routine Description:

    Delete an issuer list.

Arguments:

    pI -- ptr to array of issuers
    dwI -- count of issuers

Returns:

    TRUE if success, FALSE if error

--*/
{
    for ( DWORD x = 0 ; x < dwI ; ++x )
    {
        LocalFree( pI[x].pbIssuer );
    }
    LocalFree( pI );

    return TRUE;
}


BOOL
CIisCert11Mapper::GetIssuerBuffer(
    LPBYTE      pB,
    DWORD*      pdwI
    )
/*++

Routine Description:

    Retrieve the issuer list. Ownership of list transferred to caller

Arguments:

    pB -- updated with ptr to issuers buffer
    pdwI -- updated with size of buffer of issuers

Returns:

    TRUE if success, FALSE if error

--*/
{
    LPBYTE  pS;
    DWORD   dwC = 0;

    Lock();

    for ( UINT x = 0 ; x < m_cIssuers ; ++x )
    {
        dwC += m_pIssuers[x].cbIssuerLen + sizeof(USHORT);
    }

    *pdwI = dwC;

    if ( pB != NULL )
    {
        for ( pS = pB, x = 0 ; x < m_cIssuers ; ++x )
        {
            pS[0] = (BYTE)(m_pIssuers[x].cbIssuerLen >> 8);
            pS[1] = (BYTE)(m_pIssuers[x].cbIssuerLen);
            memcpy( pS + sizeof(USHORT),
                    m_pIssuers[x].pbIssuer,
                    m_pIssuers[x].cbIssuerLen );
            pS += m_pIssuers[x].cbIssuerLen + sizeof(USHORT);
        }
    }

    Unlock();

    return TRUE;
}



BOOL
CIisCert11Mapper::FreeIssuerBuffer(
    LPBYTE pI
    )
/*++

Routine Description:

    Delete an issuer list.

Arguments:

    pI -- ptr to issuers

Returns:

    TRUE if success, FALSE if error

--*/
{
    LocalFree( pI );

    return TRUE;
}


// CCertMapping

CCertMapping::CCertMapping(
    CIisAcctMapper* pMap
    )
/*++

Routine Description:

    Constructor for CCertMapping

Arguments:

    pMap -- ptr to mapper object linked to this mapping

Returns:

    Nothing

--*/
{
    m_pMapper = (CIisAcctMapper*)pMap;

    for ( int x = 0 ; x < sizeof(m_pFields)/sizeof(LPSTR) ; ++x )
    {
        m_pFields[x] = NULL;
    }
}


CCertMapping::~CCertMapping(
    )
/*++

Routine Description:

    Destructor for CCertMapping

Arguments:

    None

Returns:

    Nothing

--*/
{
}


#if defined(DECODE_ASN1)
BOOL
DecodeNextField(
    LPBYTE* ppAscii,
    DWORD* pcAscii,
    int* piF,
    LPBYTE* ppN
    )
/*++

Routine Description:

    Decode next field certificate ASCII representation
    field format as
        name=content
        where name is zero or more non comma chars

Arguments:

    ppAscii - ptr to buffer where to scan for next field
              updated with ptr to field content
    pcAscii - ptr to count of char in ppAscii
              updated with count of remaining char after ppAscii update
              piF - updated with field type ( -1: unrecognized, 0:O, 1:OU, 2:C, 3:CN )
    ppN - updated with ptr to field name

Returns:

    TRUE if next field exists, otherwise FALSE

--*/
{
    LPBYTE pAscii = *ppAscii;
    LPBYTE pN;
    int iF;
    LPBYTE p = (LPBYTE)memchr( pAscii, '=', *pcAscii );

    if ( p == NULL )
    {
        return FALSE;
    }

    for ( pN = p ; pN > pAscii && pN[-1] != ' ' ; --pN )
    {
    }

    if ( pN[0] == 'O' && pN[1] == '=' )
    {
        iF = 0;
    }
    else if ( pN[0] == 'O' && pN[1] == 'U' && pN[2] == '=' )
    {
        iF = 1;
    }
    else if ( pN[0] == 'C' && pN[1] == '=' )
    {
        iF = 2;
    }
    else if ( pN[0] == 'C' && pN[1] == 'U' && pN[2] == '='  )
    {
        iF = 3;
    }
    else
    {
        iF = -1;
    }

    *piF = iF;
    *pcAscii -= (p + 1 - pAscii);
    *ppAscii = p + 1;
    *ppN = pN;

    return TRUE;
}


int
IisDecodeAsciiDN(
    LPSTR *pF,
    LPSTR pStore,
    LPBYTE pAscii,
    DWORD cAscii
    )
/*++

Routine Description:

    Decode certificate ASCII representation to an array of well-known fields
    ( 0:O, 1:OU, 2:C, 3:CN )

Arguments:

    pF - ptr to array of fields to be updated with ptr to field content
    pStore - buffer to be used to store fields content, assumed to be big enough
    pAscii - ptr to buffer where to scan for fields
    cAscii - ptr to count of char in pAscii

Returns:

  # of chars stored in pStore

--*/
{
    int iF;
    int iNF;
    LPBYTE pN;
    BOOL f;
    int l = 0;

    //O, OU, C, CN

    f = DecodeNextField( &pAscii, &cAscii, &iF, &pN );

    for ( ; f ; )
    {
        LPBYTE pC = pAscii;
        if ( !(f=DecodeNextField( &pAscii, &cAscii, &iNF, &pN )) )
        {
            pN = pAscii + cAscii;
        }
        else
        {
            while ( pN > pC && *pN != ',' )
            {
                --pN;
            }
        }

        // field content is from pC to pN-1 inclusive

        if ( iF >= 0 )
        {
            pF[iF] = pStore;
            int cL = pN - pC;
            memcpy( pStore, pC, cL );
            pStore[cL++] = '\0';
            l += cL;
            pStore += cL;
        }

        iF = iNF;
    }

    return l;
}


BOOL
CCertMapping::Init(
    Cert_Map *pCert,
    IISMDB_HEntry *pH,
    DWORD dwH
    )
/*++

Routine Description:

    Constructor for CCertMapping

Arguments:

    pCert -- ptr to certificate info to initialize from
    pH -- ptr to hierarchy info
    dwH -- number of hierarchy entries

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    int l;
    int l2;

    if ( m_pBuff )
    {
        LocalFree( m_pBuff );
    }

    m_cUsedBuff = 0;

    if ( !(m_pBuff = (LPBYTE)LocalAlloc( LMEM_FIXED, m_cAllocBuff = 2048 )) )
    {
        return FALSE;
    }

    for ( int x = 0 ; x < sizeof(m_pFields)/sizeof(LPSTR) ; ++x )
    {
        m_pFields[x] = NULL;
    }

    //
    // Check if content ASCII ( if so, 1st byte is a field name, so >= 'A' )
    //

    if ( pCert->cbIssuerLen && pCert->pIssuer[0] >= 'A' )
    {
        if ( (l = IisDecodeAsciiDN( m_pFields,
                    (LPSTR)m_pBuff,
                    pCert->pIssuer,
                    pCert->cbIssuerLen
                    )) == -1
             || (l2 = IisDecodeAsciiDN(
                    m_pFields+3,
                    (LPSTR)m_pBuff+l,
                    pCert->pSubject,
                    pCert->cbSubjectLen
                    )) == -1
            )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }
    //
    // otherwise decode ASN.1 format
    //
    else if ( (l = IisDecodeDN( m_pFields,
                (LPSTR)m_pBuff,
                pCert->pIssuer,
                pCert->cbIssuerLen
                )) == -1
         || (l2 = IisDecodeDN(
                m_pFields+3,
                (LPSTR)m_pBuff+l,
                pCert->pSubject,
                pCert->cbSubjectLen
                )) == -1
        )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    m_cUsedBuff = (UINT)(l + l2);

    UpdateMask( pH, dwH );

    return TRUE;
}


BOOL
CCertMapping::Init(
    const LPBYTE pCert,
    DWORD cCert,
    IISMDB_HEntry *pH,
    DWORD dwH
    )
/*++

Routine Description:

    Constructor for CCertMapping

Arguments:

    pCert -- ptr to certificate info to initialize from
    cCert -- size of buffer pointed to by pCert
    pH -- ptr to hierarchy info
    dwH -- number of hierarchy entries

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    UINT l;

    if ( m_pBuff )
    {
        LocalFree( m_pBuff );
    }

    m_cUsedBuff = 0;

    if ( !(m_pBuff = (LPBYTE)LocalAlloc( LMEM_FIXED, m_cAllocBuff = 2048 )) )
    {
        return FALSE;
    }

    for ( int x = 0 ; x < sizeof(m_pFields)/sizeof(LPSTR) ; ++x )
    {
        m_pFields[x] = NULL;
    }

    //
    // decode ASN.1 format
    //
    // extract issuer, subject from pCert, cCert
    // O, OU, C, CN ( issuer then subject )
    //

    if ( (l = DecodeCert(
                pCert,
                cCert,
                m_pFields,
                (LPSTR)m_pBuff
                )) == 0
       )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    m_cUsedBuff = l;

    UpdateMask( pH, dwH );

    return TRUE;
}
#endif


// CCert11Mapping

CCert11Mapping::CCert11Mapping(
    CIisAcctMapper* pMap
    )
/*++

Routine Description:

    Constructor for CCert11Mapping

Arguments:

    pMap -- ptr to mapper object linked to this mapping

Returns:

    Nothing

--*/
{
    m_pMapper = (CIisAcctMapper*)pMap;

    for ( int x = 0 ; x < sizeof(m_pFields)/sizeof(LPSTR) ; ++x )
    {
        m_pFields[x] = NULL;
    }
    for ( x = 0 ; x < sizeof(m_pFields)/sizeof(LPSTR) ; ++x )
    {
        m_cFields[x] = 0;
    }
}


CCert11Mapping::~CCert11Mapping(
    )
/*++

Routine Description:

    Destructor for CCert11Mapping

Arguments:

    None

Returns:

    Nothing

--*/
{
}


#if defined(CERT11_FULL_CERT)

BOOL
CCert11Mapping::Init(
    LPBYTE pC,
    DWORD dwC,
    IISMDB_HEntry *pH,
    DWORD dwH
)
/*++

Routine Description:

    Constructor for CCert11Mapping

Arguments:

    pC -- cert ( ASN.1 format )
    dwC -- length of cert
    pH -- ptr to hierarchy info
    dwH -- number of hierarchy entries

Returns:

    TRUE if success, FALSE if error

--*/
{
    StoreFieldRef( IISMDB_INDEX_CERT11_CERT, (LPSTR)pC, dwC );

    UpdateMask( pH, dwH );

    return TRUE;
}

#else

BOOL
CCert11Mapping::Init(
    LPBYTE pI,
    DWORD dwI,
    LPBYTE pS,
    DWORD dwS,
    IISMDB_HEntry *pH,
    DWORD dwH
)
/*++

Routine Description:

    Constructor for CCert11Mapping

Arguments:

    pI -- cert issuer ( ASN.1 format )
    dwI -- length of issuer
    pS -- cert subject ( ASN.1 format )
    dwS -- length of subject
    pH -- ptr to hierarchy info
    dwH -- number of hierarchy entries

Returns:

    TRUE if success, FALSE if error

--*/
{
    StoreFieldRef( IISMDB_INDEX_CERT11_SUBJECT, (LPSTR)pS, dwS );
    StoreFieldRef( IISMDB_INDEX_CERT11_ISSUER, (LPSTR)pI, dwI);

    UpdateMask( pH, dwH );

    return TRUE;
}

#endif


// CIisMapping

CIisMapping::CIisMapping(
    )
/*++

Routine Description:

    Constructor for CIisMapping

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pBuff = NULL;
    m_cUsedBuff = m_cAllocBuff = 0;
    m_dwMask = 0;
}


BOOL
CIisMapping::CloneEx(
    CIisMapping**   ppM,
    LPSTR*          ppTargetS,
    LPSTR*          ppS,
    LPDWORD         pTargetC,
    LPDWORD         pC,
    UINT            cF
    )
/*++

Routine Description:

    Clone a mapping entry

Arguments:


Returns:

  TRUE if success, otherwise FALSE

--*/
{
    CIisMapping*    pM = *ppM;
    UINT            i;

    if ( ppTargetS && ppS )
    {
        memcpy( ppTargetS, ppS, sizeof(LPSTR*) * cF );
    }

    if ( pTargetC && pC )
    {
        memcpy( pTargetC, pC, sizeof(DWORD) * cF );
    }

    if ( !(pM->m_pBuff = (LPBYTE)LocalAlloc( LMEM_FIXED, m_cAllocBuff )) )
    {
        delete pM;
        *ppM = NULL;
        return FALSE;
    }

    memcpy( pM->m_pBuff, m_pBuff, m_cUsedBuff );

    pM->m_cUsedBuff = m_cUsedBuff;
    pM->m_cAllocBuff = m_cAllocBuff;
    pM->m_pMapper = m_pMapper;
    pM->m_dwMask = m_dwMask;

    //
    // Adjust ptr to point to new buffer
    //

    for ( i = 0 ; i < cF ; ++i )
    {
        if ( ppTargetS[i] )
        {
            ppTargetS[i] += pM->m_pBuff - m_pBuff;
        }
    }

    return TRUE;
}


BOOL
CIisMapping::UpdateMask(
    IISMDB_HEntry* pH,
    DWORD dwI
    )
/*++

Routine Description:

    Update mask of significant fields for a mapping object
    Field is significant if not containing "*"
    mask if bitmask of n bits where n is # of hierarchy entries
    bit of rank m == 0 means field pointed by hierarchy entry n - 1 - m
    is significant. ( i.e. MSB is hierarchy entry 0, the most significant )

Arguments:

    pH -- ptr to hierarchy info
    dwI -- number of hierarchy entries

Returns:

    TRUE if success, FALSE if error

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    LPSTR pF;
    DWORD dwC;
    int iMax;
    m_dwMask = (1u << dwI)-1;

    iMax = GetNbField( &pFields, &pcFields );

    if ( pcFields )
    {
        for ( UINT x = 0 ; x < dwI ; ++x )
        {
            MappingGetField( pH[x].m_dwIndex, &pF, &dwC, FALSE );
            if ( !pF || dwC != 1 || *pF != '*' )
            {
                m_dwMask &= ~(1u << (dwI - 1 - x) );
            }
        }
    }
    else
    {
        for ( UINT x = 0 ; x < dwI ; ++x )
        {
            MappingGetField( pH[x].m_dwIndex, &pF );
            if ( !pF || strcmp( pF, "*" ) )
            {
                m_dwMask &= ~(1u << (dwI - 1 - x) );
            }
        }
    }

    return TRUE;
}


BOOL
CIisMapping::Copy(
    CIisMapping* pM
    )
/*++

Routine Description:

    Copy the specified mapping in this

Arguments:

    pM - ptr to mapping to duplicate

Returns:

    TRUE if success, FALSE if error

--*/
{
    LPSTR *pFields;
    LPSTR pF;
    UINT iMax = GetNbField( &pFields );

    for ( UINT x = 0 ; x < iMax ; ++x )
    {
        if ( pM->MappingGetField( x, &pF ) && *pF )
        {
            if ( !MappingSetField( x, pF ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}


int
CIisMapping::Cmp(
    CIisMapping* pM,
    BOOL fCmpForMatch
    )
/*++

Routine Description:

    Compare 2 mappings, return -1, 0 or 1 as suitable for qsort or bsearch
    Can compare either for full sort order ( using mask & significant fields )
    or for a match ( not using mask )

Arguments:

    pM -- ptr to mapping to compare to. This is to be used as the 2nd
          entry for purpose of lexicographical order.
    fCmpForMatch -- TRUE if comparing for a match inside a given mask class

Returns:

    -1 if *this < *pM, 0 if *this == *pM, 1 if *this > *pM

--*/
{
    DWORD dwCmpMask = 0xffffffff;

    // if not compare for match, consider mask

    if ( !fCmpForMatch )
    {
        if ( m_dwMask < pM->GetMask() )
        {
            return -1;
        }
        else if ( m_dwMask > pM->GetMask() )
        {
            return 1;
        }

        // mask are identical, have to consider fields
    }

    // compute common significant fields : bit is 1 if significant

    dwCmpMask = (~m_dwMask) & (~pM->GetMask());

    DWORD dwH;
    IISMDB_HEntry* pH = m_pMapper->GetHierarchy( &dwH );
    UINT x;
    LPSTR *pFL;
    LPDWORD pcFL;
    GetNbField( &pFL, &pcFL );

    for ( x = 0 ; x < dwH ; ++x )
    {
        if( ! (dwCmpMask & (1u << (dwH - 1 - x) )) )
        {
            continue;
        }

        LPSTR pA;
        LPSTR pB;
        DWORD dwA;
        DWORD dwB;
        int fC;
        if ( pcFL )     // check if length available
        {
            MappingGetField( pH[x].m_dwIndex, &pA, &dwA, FALSE );
            pM->MappingGetField( pH[x].m_dwIndex, &pB, &dwB, FALSE );
            if ( pA == NULL )
            {
                dwA = 0;
            }
            if ( pB == NULL )
            {
                dwB = 0;
            }
            if ( dwA != dwB )
            {
                return dwA < dwB ? -1 : 1;
            }
            fC = memcmp( pA, pB, dwA );
        }
        else
        {
            MappingGetField( pH[x].m_dwIndex, &pA );
            pM->MappingGetField( pH[x].m_dwIndex, &pB );
            if ( pA == NULL )
            {
                pA = "";
            }
            if ( pB == NULL )
            {
                pB = "";
            }
            fC = strcmp( pA, pB );
        }
        if ( fC )
        {
            return fC;
        }
    }

    return 0;
}


BOOL
CIisMapping::MappingGetField(
    DWORD dwIndex,
    LPSTR *pF
    )
/*++

Routine Description:

    Get ptr to field in mapping entry
    ownership of field remains with mapping entry

Arguments:

    dwIndex -- index of field
    pF -- updated with ptr to field entry. can be NULL if
          field empty.

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    LPSTR *pFields;
    DWORD iMax = GetNbField( &pFields );
    if ( dwIndex >= iMax )
    {
        return FALSE;
    }

    *pF = pFields[dwIndex];

    return TRUE;
}


BOOL
CIisMapping::MappingGetField(
    DWORD dwIndex,
    LPSTR *pF,
    LPDWORD pcF,
    BOOL fUuEncode
    )
/*++

Routine Description:

    Get ptr to field in mapping entry
    ownership of field remains with mapping entry

Arguments:

    dwIndex -- index of field
    pF -- updated with ptr to field entry. can be NULL if
          field empty.
    pcF -- updated with length of fields, 0 if empty
    fUuEncode -- TRUE if result is to be uuencoded.
                 if TRUE, caller must LocalFree( *pF )

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    DWORD iMax = GetNbField( &pFields, &pcFields );
    if ( dwIndex >= iMax )
    {
        return FALSE;
    }

    if ( fUuEncode )
    {
        LPSTR pU = (LPSTR)LocalAlloc( LMEM_FIXED, ((pcFields[dwIndex]+3)*4)/3+1 );
        if ( pU == NULL )
        {
            return FALSE;
        }
        DWORD cO;
        IISuuencode( (LPBYTE)pFields[dwIndex], pcFields[dwIndex], (LPBYTE)pU, FALSE );
        *pF = pU;
        *pcF = strlen(pU);
    }
    else
    {
        *pF = pFields[dwIndex];
        *pcF = pcFields[dwIndex];
    }

    return TRUE;
}


BOOL
CIisMapping::MappingSetField(
    DWORD dwIndex,
    LPSTR pszNew
    )
/*++

Routine Description:

    Set field in mapping entry to specified content
    data pointed by pszNew is copied inside mapping entry

Arguments:

    dwIndex -- index of field
    pszNew -- data to copy inside field

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    LPSTR *pFields;
    DWORD iMax = GetNbField( &pFields );
    if ( dwIndex >= iMax )
    {
        return FALSE;
    }

    return StoreField( pFields, dwIndex, iMax, pszNew );
}


BOOL
CIisMapping::MappingSetField(
    DWORD dwIndex,
    LPSTR pszNew,
    DWORD cNew,
    BOOL fIsUuEncoded
    )
/*++

Routine Description:

    Set field in mapping entry to specified content
    data pointed by pszNew is copied inside mapping entry

Arguments:

    dwIndex -- index of field
    pszNew -- data to copy inside field
    cNew -- length of data
    fIsUuEncoded -- TRUE if pszNew is UUEncoded

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    DWORD iMax = GetNbField( &pFields, &pcFields );
    if ( dwIndex >= iMax )
    {
        return FALSE;
    }

    return StoreField( pFields, pcFields, dwIndex, iMax, pszNew, cNew, fIsUuEncoded );
}


BOOL
CIisMapping::StoreField(
    LPSTR* ppszFields,
    DWORD dwIndex,
    DWORD dwNbIndex,
    LPSTR pszNew
    )
/*++

Routine Description:

    Update field array in mapping entry with new field
    data pointed by pszNew is copied inside mapping entry

Arguments:

    ppszFields -- array of field pointers to be updated
    dwIndex -- index of field
    dwNbIndex -- number of fields in array
    pszNew -- data to copy inside field

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;

    // pszOld is assumed to point inside m_pBuff if non NULL
    // is has to be removed

    LPSTR pszOld = ppszFields[dwIndex];
    if ( pszOld && m_pBuff && (LPBYTE)pszOld > m_pBuff && (LPBYTE)pszOld < m_pBuff+m_cUsedBuff )
    {
        int lO = strlen( pszOld ) + 1;
        int lM = DIFF((m_pBuff + m_cUsedBuff) - (LPBYTE)pszOld) - lO;
        if ( lM )
        {
            memmove( pszOld, pszOld + lO, lM );
            for ( x = 0 ; x < dwNbIndex ; ++x )
            {
                if ( x != dwIndex && ppszFields[x] > pszOld )
                {
                    ppszFields[x] -= lO;
                }
            }
        }
        ppszFields[ dwIndex ] = NULL;
        m_cUsedBuff -= lO;
    }

    // pszNew is to appended to m_pBuff

    int lN = strlen( pszNew ) + 1;

    if ( m_cUsedBuff + lN > m_cAllocBuff )
    {
        UINT cNewBuff = (( m_cUsedBuff + lN + IIS_MAP_BUFF_GRAN ) / IIS_MAP_BUFF_GRAN) * IIS_MAP_BUFF_GRAN;
        LPSTR pNewBuff = (LPSTR)LocalAlloc( LMEM_FIXED, cNewBuff );
        if ( pNewBuff == NULL )
        {
            return FALSE;
        }
        if ( m_pBuff )
        {
            memcpy( pNewBuff, m_pBuff, m_cUsedBuff );
            LocalFree( m_pBuff );
        }
        m_cAllocBuff = cNewBuff;
        // adjust pointers
        for ( UINT x = 0 ; x < dwNbIndex ; ++x )
        {
            if ( x != dwIndex )
            {
                if ( ppszFields[x] != NULL )
                {
                    ppszFields[x] += ((LPBYTE)pNewBuff - m_pBuff);
                }
            }
        }
        m_pBuff = (LPBYTE)pNewBuff;
    }

    memcpy( m_pBuff + m_cUsedBuff, pszNew, lN );

    ppszFields[dwIndex] = (LPSTR)(m_pBuff + m_cUsedBuff);

    m_cUsedBuff += lN;

    return TRUE;
}


BOOL
CIisMapping::StoreField(
    LPSTR* ppszFields,
    LPDWORD ppdwFields,
    DWORD dwIndex,
    DWORD dwNbIndex,
    LPSTR pbNew,
    DWORD cNew,
    BOOL fIsUuEncoded
    )
/*++

Routine Description:

    Update field array in mapping entry with new field
    data pointed by pszNew is copied inside mapping entry

Arguments:

    ppszFields -- array of field pointers to be updated
    ppdwFields -- array of field length to be updated
    dwIndex -- index of field
    dwNbIndex -- number of fields in array
    pbNew -- data to copy inside field
    cNew -- length of data
    fIsUuEncoded -- TRUE if pbNew is UUEncoded

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;

    // pszOld is assumed to point inside m_pBuff if non NULL
    // it has to be removed

    LPSTR pszOld = ppszFields[dwIndex];
    if ( pszOld && m_pBuff && (LPBYTE)pszOld > m_pBuff && (LPBYTE)pszOld < m_pBuff+m_cUsedBuff )
    {
        int lO = ppdwFields[dwIndex];
        int lM = DIFF((m_pBuff + m_cUsedBuff) - (LPBYTE)pszOld) - lO;
        if ( lM )
        {
            memmove( pszOld, pszOld + lO, lM );
            for ( x = 0 ; x < dwNbIndex ; ++x )
            {
                if ( x != dwIndex && ppszFields[x] > pszOld )
                {
                    ppszFields[x] -= lO;
                }
            }
        }
        ppszFields[ dwIndex ] = NULL;
        m_cUsedBuff -= lO;
    }

    // pszNew is to appended to m_pBuff

    int lN = cNew;
    if ( fIsUuEncoded )
    {
        LPSTR pU = (LPSTR)LocalAlloc( LMEM_FIXED, lN + 3);
        if ( pU == NULL )
        {
            return FALSE;
        }
        DWORD cO;
        IISuudecode( pbNew, (LPBYTE)pU, &cO, FALSE );
        pbNew = pU;
        cNew = lN = cO;
    }

    if ( m_cUsedBuff + lN > m_cAllocBuff )
    {
        UINT cNewBuff = (( m_cUsedBuff + lN + IIS_MAP_BUFF_GRAN ) / IIS_MAP_BUFF_GRAN) * IIS_MAP_BUFF_GRAN;
        LPSTR pNewBuff = (LPSTR)LocalAlloc( LMEM_FIXED, cNewBuff );
        if ( pNewBuff == NULL )
        {
            if ( fIsUuEncoded )
            {
                LocalFree( pbNew );
            }
            return FALSE;
        }
        if ( m_pBuff )
        {
            memcpy( pNewBuff, m_pBuff, m_cUsedBuff );
            LocalFree( m_pBuff );
        }
        m_cAllocBuff = cNewBuff;
        // adjust pointers
        for ( UINT x = 0 ; x < dwNbIndex ; ++x )
        {
            if ( x != dwIndex )
            {
                if ( ppszFields[x] != NULL )
                {
                    ppszFields[x] += ((LPBYTE)pNewBuff - m_pBuff);
                }
            }
        }
        m_pBuff = (LPBYTE)pNewBuff;
    }

    memcpy( m_pBuff + m_cUsedBuff, pbNew, lN );

    ppszFields[dwIndex] = (LPSTR)(m_pBuff + m_cUsedBuff);
    if ( ppdwFields )
    {
        ppdwFields[dwIndex] = cNew;
    }

    m_cUsedBuff += lN;

    if ( fIsUuEncoded )
    {
        LocalFree( pbNew );
    }

    return TRUE;
}


BOOL
CIisMapping::Serialize(
    FILE* pFile,
    VALID_CTX pMD5,
    LPVOID pStorage
    )
/*++

Routine Description:

    Serialize a mapping entry

Arguments:

    pFile -- file to write to
    pMD5 -- MD5 to update with signature of written bytes

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked while serializing

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    LPSTR pO = NULL;
    DWORD dwO = 0;
    UINT iMax = GetNbField( &pFields, &pcFields );
    UINT x;
    LPBYTE pB;
    BOOL fMustFree;

    for ( x = 0 ; x < iMax ; ++x )
    {
        LPSTR pF;
        DWORD dwF;

        fMustFree = FALSE;

        if ( pcFields )
        {
            MappingGetField( x, &pF, &dwF, FALSE );
            MD5Update( (MD5_CTX*)pMD5, (LPBYTE)pF, dwF );
store_as_binary:
            if ( IsCrypt( x ) && dwF )
            {
                if ( FAILED(((IIS_CRYPTO_STORAGE*)pStorage)->EncryptData(
                        (PIIS_CRYPTO_BLOB*)&pB,
                        pF,
                        dwF,
                        REG_BINARY )) )
                {
                    return FALSE;
                }
                pF = (LPSTR)pB;
                dwF = IISCryptoGetBlobLength( (PIIS_CRYPTO_BLOB)pB );
                fMustFree = TRUE;
            }

            if ( dwF )
            {
                DWORD dwNeed = ((dwF+2)*4)/3 + 1;
                if ( dwNeed > dwO )
                {
                    if ( pO != NULL )
                    {
                        LocalFree( pO );
                    }
                    dwNeed += 100;  // alloc more than needed
                                    // to minimize # of allocation
                    if ( !(pO = (LPSTR)LocalAlloc( LMEM_FIXED, dwNeed )) )
                    {
                        return FALSE;
                    }
                    dwO = dwNeed;
                }
                /* INTRINSA suppress = null */
                IISuuencode( (LPBYTE)pF, dwF, (LPBYTE)pO, FALSE );
                fputs( pO, pFile );
            }

            if ( fMustFree )
            {
                IISCryptoFreeBlob( (PIIS_CRYPTO_BLOB)pB );
            }
        }
        else
        {
            MappingGetField( x, &pF );
            if ( pF != NULL )
            {
                MD5Update( (MD5_CTX*)pMD5, (LPBYTE)pF, strlen(pF) );
                if ( IsCrypt( x ) )
                {
                    dwF = strlen( pF ) + 1;
                    goto store_as_binary;
                }
                fputs( pF, pFile );
            }
        }
        fputs( "|", pFile );
    }

    fputs( "\r\n", pFile );

    if ( pO != NULL )
    {
        LocalFree( pO );
    }

    return TRUE;
}


BOOL
CIisMapping::Deserialize(
    FILE* pFile,
    VALID_CTX pMD5,
    LPVOID pStorage
    )
/*++

Routine Description:

    Deserialize a mapping entry

Arguments:

    pFile -- file to read from
    pMD5 -- MD5 to update with signature of read bytes

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked while serializing

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    UINT iMax;
    UINT x;
    int c;
    CHAR achBuf[4096];
    DWORD dwType;
    LPBYTE pB;

    iMax = GetNbField( &pFields, &pcFields );

    for ( x = 0 ; x < iMax ; ++x )
    {
        StoreFieldRef( x, NULL );
    }

    for ( x =  0 ; x < sizeof(achBuf) && (c=fgetc(pFile))!= EOF ; )
    {
        achBuf[x++] = (CHAR)c;

        if ( c == '\n' )
        {
            break;
        }
    }
    if ( x == sizeof(achBuf ) )
    {
        return FALSE;
    }

    if ( x > 1 )
    {
        achBuf[x-2] = '\0';

        m_cUsedBuff = m_cAllocBuff = x - 1;
        if ( (m_pBuff = (LPBYTE)LocalAlloc( LMEM_FIXED, m_cAllocBuff )) == NULL )
        {
            m_cAllocBuff = m_cUsedBuff = 0;
            return FALSE;
        }
        memcpy( m_pBuff, achBuf, m_cUsedBuff );

        LPSTR pCur = (LPSTR)m_pBuff;
        LPSTR pNext;
        LPSTR pStore = (LPSTR)m_pBuff;
        DWORD dwDec;
        if ( pcFields )
        {
            for ( x = 0 ; x < iMax ; ++x )
            {
                pNext = strchr( pCur, '|' );
                if ( pNext != NULL )
                {
                    *pNext = '\0';
                    ++pNext;
                }
                else
                {
                    pNext = NULL;
                }
                IISuudecode( pCur, (PBYTE)pStore, &dwDec, FALSE );
                if ( IsCrypt( x ) && dwDec )
                {
                    if ( FAILED(((IIS_CRYPTO_STORAGE*)pStorage)->DecryptData(
                            (PVOID*)&pB,
                            &dwDec,
                            &dwType,
                            (PIIS_CRYPTO_BLOB)pStore )) )
                    {
                        return FALSE;
                    }
                    memmove( pStore, pB, dwDec );
                }
                MD5Update( (MD5_CTX*)pMD5, (LPBYTE)pStore, dwDec );
                StoreFieldRef( x, pStore, dwDec );
                pCur = pNext;
                pStore += dwDec;
            }
        }
        else
        {
            for ( x = 0 ; x < iMax ; ++x )
            {
                pNext = strchr( pCur, '|' );
                if ( pNext != NULL )
                {
                    *pNext = '\0';
                    ++pNext;
                }
                if ( *pCur && IsCrypt( x ) )
                {
                    IISuudecode( pCur, (PBYTE)pCur, &dwDec, FALSE );

                    if ( FAILED(((IIS_CRYPTO_STORAGE*)pStorage)->DecryptData(
                            (PVOID*)&pB,
                            &dwDec,
                            &dwType,
                            (PIIS_CRYPTO_BLOB)pCur )) )
                    {
                        return FALSE;
                    }

                    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)pB, dwDec );
                    StoreFieldRef( x, (LPSTR)pB );
                    pCur = pNext;
                }
                else
                {
                    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)pCur, strlen(pCur) );
                    StoreFieldRef( x, pCur );
                    pCur = pNext;
                }
            }
        }
        return TRUE;
    }

    return FALSE;
}


//


extern "C" BOOL WINAPI
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID pV
    )
/*++

Routine Description:

    DLL init/terminate notification function

Arguments:

    hModule  - DLL handle
    dwReason - notification type
    LPVOID   - not used

Returns:

    TRUE if success, FALSE if failure

--*/
{
    //BOOL f = Crypt32DllMain( (HINSTANCE)hModule, dwReason, pV );

    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
#ifdef _NO_TRACING_
            CREATE_DEBUG_PRINT_OBJECT( "IISMAP" );
#endif
            // record the module handle to access module info later
            g_hModule = (HINSTANCE)hModule;
            INITIALIZE_CRITICAL_SECTION( &g_csIisMap );
            InitializeWildcardMapping( hModule );
            InitializeMapping( hModule );
            if ( IISCryptoInitialize() != NO_ERROR )
            {
                return FALSE;
            }
            return TRUE;

        case DLL_PROCESS_DETACH:
            IISCryptoTerminate();
            TerminateWildcardMapping();
            TerminateMapping();
            DeleteCriticalSection( &g_csIisMap );
#ifdef _NO_TRACING_
            DELETE_DEBUG_PRINT_OBJECT( );
#endif
            break;
    }

    return TRUE;
}


BOOL
InitializeMapping(
    HANDLE hModule
    )
/*++

Routine Description:

    Initialize mapping

Arguments:

    hModule - module handle of this DLL

Return Value:

    Nothing

--*/
{
    // get install path

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMS,
                       0,
                       KEY_READ|KEY_SET_VALUE,
                       &g_hKey ) == ERROR_SUCCESS )
    {
        DWORD dwLen = 0;
        DWORD dwType;

        if ( RegQueryValueEx( g_hKey,
                              INSTALL_PATH,
                              NULL,
                              &dwType,
                              NULL,
                              &dwLen ) != ERROR_SUCCESS ||
             dwType != REG_SZ ||
             !( g_pszInstallPath = (LPSTR)LocalAlloc( LMEM_FIXED, dwLen ) ) ||
             RegQueryValueEx( g_hKey,
                              INSTALL_PATH,
                              NULL,
                              &dwType,
                              (LPBYTE)g_pszInstallPath,
                              &dwLen ) != ERROR_SUCCESS )
        {
            if ( g_pszInstallPath )
            {
                LocalFree( g_pszInstallPath );
                g_pszInstallPath = NULL;
            }
        }

        dwLen = sizeof( g_dwGuid );
        if ( RegQueryValueEx( g_hKey,
                              MAPPER_GUID,
                              NULL,
                              &dwType,
                              (LPBYTE)&g_dwGuid,
                              &dwLen ) != ERROR_SUCCESS ||
             dwType != REG_DWORD )
        {
            g_dwGuid = 0;
        }

        return LoadFieldNames( IisItaMappingFields,
                               sizeof(IisItaMappingFields)/sizeof(IISMDB_Fields) ) &&
               LoadFieldNames( IisCert11MappingFields,
                               sizeof(IisCert11MappingFields)/sizeof(IISMDB_Fields) ) &&
               LoadFieldNames( IisMd5MappingFields,
                               sizeof(IisMd5MappingFields)/sizeof(IISMDB_Fields) );
    }
    else
    {
        g_hKey = NULL;
    }

    return FALSE;
}


BOOL
LoadFieldNames(
    IISMDB_Fields* pFields,
    UINT cFields
    )
/*++

Routine Description:

    Load fields names from resource

Arguments:

    pFields - ptr to array where to store reference to names
    cFields - count of element in array

Return Value:

    TRUE if success, otherwise FALSE

--*/
{

    UINT    x;
    BOOL    fSt = TRUE;

    for ( x = 0 ;
        x < cFields ;
        ++x )
    {
        char achTmp[128];

        if ( LoadString( g_hModule,
                         pFields[x].m_dwResID,
                         achTmp,
                         sizeof( achTmp ) ) != 0 )
        {
            int lN = strlen( achTmp ) + sizeof(CHAR);
            if ( (pFields[x].m_pszDisplayName = (LPSTR)LocalAlloc( LMEM_FIXED, lN )) == NULL )
            {
                fSt = FALSE;
                break;
            }
            memcpy( pFields[x].m_pszDisplayName, achTmp, lN );
        }
        else
        {
            fSt = FALSE;
            break;
        }
    }

    return fSt;
}


VOID
FreeFieldNames(
    IISMDB_Fields* pFields,
    UINT cFields
    )
/*++

Routine Description:

    Free fields names loaded from resource

Arguments:

    pFields - ptr to array where reference to names are stored
    cFields - count of element in array

Return Value:

    Nothing

--*/
{

    UINT    x;
    BOOL    fSt = TRUE;

    for ( x = 0 ;
        x < cFields ;
        ++x )
    {
        if ( pFields[x].m_pszDisplayName )
        {
            LocalFree( pFields[x].m_pszDisplayName );
        }
    }
}


VOID
TerminateMapping(
    )
/*++

Routine Description:

    Terminate mapping

Arguments:

    None

Return Value:

    Nothing

--*/
{
    if ( g_hKey != NULL )
    {
        RegCloseKey( g_hKey );
    }

    if ( g_pszInstallPath )
    {
        LocalFree( g_pszInstallPath );
    }

    FreeFieldNames( IisItaMappingFields,
                    sizeof(IisItaMappingFields)/sizeof(IISMDB_Fields) );
    FreeFieldNames( IisCert11MappingFields,
                    sizeof(IisCert11MappingFields)/sizeof(IISMDB_Fields) );
    FreeFieldNames( IisMd5MappingFields,
                    sizeof(IisMd5MappingFields)/sizeof(IISMDB_Fields) );
}

//


dllexp
BOOL
ReportIisMapEvent(
    WORD wType,
    DWORD dwEventId,
    WORD cNbStr,
    LPCTSTR* pStr
    )
/*++

Routine Description:

    Log an event based on type, ID and insertion strings

Arguments:

    wType -- event type ( error, warning, information )
    dwEventId -- event ID ( as defined by the .mc file )
    cNbStr -- nbr of LPSTR in the pStr array
    pStr -- insertion strings

Returns:

    TRUE if success, FALSE if failure

--*/
{
    BOOL    fSt = TRUE;
    HANDLE  hEventLog = NULL;

    hEventLog = RegisterEventSource(NULL,"IISMAP");

    if ( hEventLog != NULL )
    {
        if (!ReportEvent(hEventLog,             // event log handle
                    wType,                      // event type
                    0,                          // category zero
                    (DWORD) dwEventId,          // event identifier
                    NULL,                       // no user security identifier
                    cNbStr,                     // count of substitution strings (may be no strings)
                                                // less ProgName (argv[0]) and Event ID (argv[1])
                    0,                          // no data
                    (LPCTSTR *) pStr,           // address of string array
                    NULL))                      // address of data
        {
            fSt = FALSE;
        }

        DeregisterEventSource( hEventLog );
    }
    else
    {
        fSt = FALSE;
    }

    return fSt;
}


/////////////////////////////////////////


// CIisItaMapper

CIisItaMapper::CIisItaMapper(
    )
/*++

Routine Description:

    Constructor for CIisItaMapper

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pFields = IisItaMappingFields;
    m_cFields = sizeof(IisItaMappingFields)/sizeof(IISMDB_Fields);

    m_dwOptions = IISMDB_ITA_OPTIONS;
}


CIisItaMapper::~CIisItaMapper(
    )
/*++

Routine Description:

    Destructor for CIisItaMapper

Arguments:

    None

Returns:

    Nothing

--*/
{
}


IISMDB_HEntry*
CIisItaMapper::GetDefaultHierarchy(
    LPDWORD pdwN
    )
/*++

Routine Description:

    return ptr to default hierarchy for ita mapping

Arguments:

    pdwN -- updated with hierarchy entries count

Returns:

    ptr to hierarchy entries or NULL if error

--*/
{
    *pdwN = sizeof(IisItaMappingHierarchy) / sizeof(IISMDB_HEntry);

    return IisItaMappingHierarchy;
}


CIisMapping*
CIisItaMapper::CreateNewMapping(
    LPSTR pszType,
    LPSTR pszUser,
    LPSTR pszPwd
    )
/*++

Routine Description:

    Create a new mapping from internet credentials

Arguments:

    pszType -- login type : basic, user, MD5, SSL/PCT, ...
    pszUser -- user name
    pszPwd -- clear text password

Returns:

    ptr to mapping. ownership of this object is transfered to caller.
    NULL if error

--*/
{
    CItaMapping *pCM = new CItaMapping( this );
    if ( pCM == NULL )
    {
        return NULL;
    }

    if ( pCM->Init( pszType, pszUser, pszPwd, m_pHierarchy, m_cHierarchy ) )
    {
        return (CIisMapping*)pCM;
    }
    delete pCM;

    return NULL;
}


// CItaMapping

CItaMapping::CItaMapping(
    CIisAcctMapper* pMap
    )
/*++

Routine Description:

    Constructor for CItaMapping

Arguments:

    pMap -- ptr to mapper object linked to this mapping

Returns:

    Nothing

--*/
{
    m_pMapper = (CIisAcctMapper*)pMap;

    for ( int x = 0 ; x < sizeof(m_pFields)/sizeof(LPSTR) ; ++x )
    {
        m_pFields[x] = NULL;
    }
}


CItaMapping::~CItaMapping(
    )
/*++

Routine Description:

    Destructor for CItaMapping

Arguments:

    None

Returns:

    Nothing

--*/
{
}


BOOL
CItaMapping::Init(
    LPSTR pszType,
    LPSTR pszUser,
    LPSTR pszPwd,
    IISMDB_HEntry *pH,
    DWORD dwH
    )
/*++

Routine Description:

    Constructor for CItaMapping

Arguments:

    pszType -- login type : basic, user, MD5, SSL/PCT, ...
    pszUser -- user name
    pszPwd -- clear text password
    pH -- ptr to hierarchy info
    dwH -- number of hierarchy entries

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( !MappingSetField( IISIMDB_INDEX_IT_ACCT, pszUser ) )
    {
        return FALSE;
    }

    if ( !MappingSetField( IISIMDB_INDEX_IT_PWD, pszPwd ) )
    {
        return FALSE;
    }

    return UpdateMask( pH, dwH );
}


BOOL
CCert11Mapping::MappingSetField(
    DWORD dwIndex,
    LPSTR pszNew
    )
/*++

Routine Description:

    Set field in mapping entry to specified content
    data pointed by pszNew is copied inside mapping entry

Arguments:

    dwIndex -- index of field
    pszNew -- data to copy inside field

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    DWORD iMax = GetNbField( &pFields, &pcFields );
    if ( dwIndex >= iMax )
    {
        return FALSE;
    }

    return StoreField( pFields, pcFields, dwIndex, iMax, pszNew, strlen(pszNew)+1, FALSE );
}


BOOL
CItaMapping::MappingSetField(
    DWORD dwIndex,
    LPSTR pszNew
    )
/*++

Routine Description:

    Set field in mapping entry to specified content
    data pointed by pszNew is copied inside mapping entry

Arguments:

    dwIndex -- index of field
    pszNew -- data to copy inside field

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    MD5_CTX md5;
    CHAR achDigest[ sizeof(md5.digest)*2 +  1];

#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    // convert clear text pwd to MD5 digest ( as ASCII string )

    if ( dwIndex == IISIMDB_INDEX_IT_PWD )
    {
        MD5Init( &md5 );
        MD5Update( &md5, (LPBYTE)pszNew, strlen(pszNew) );
        MD5Final( &md5 );
        for ( UINT x = 0, y = 0 ; x < sizeof(md5.digest) ; ++x )
        {
            UINT v;
            v = md5.digest[x]>>4;
            achDigest[y++] = TOHEX( v );
            v = md5.digest[x]&0x0f;
            achDigest[y++] = TOHEX( v );
        }
        achDigest[y] = '\0';
        pszNew = achDigest;
    }

    return CIisMapping::MappingSetField( dwIndex, pszNew );
}

// CIisMd5Mapper

CIisMd5Mapper::CIisMd5Mapper(
    )
/*++

Routine Description:

    Constructor for CIisMd5Mapper

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pFields = IisMd5MappingFields;
    m_cFields = sizeof(IisMd5MappingFields)/sizeof(IISMDB_Fields);

    m_dwOptions = IISMDB_MD5_OPTIONS;
}


CIisMd5Mapper::~CIisMd5Mapper(
    )
/*++

Routine Description:

    Destructor for CIisMd5Mapper

Arguments:

    None

Returns:

    Nothing

--*/
{
}


IISMDB_HEntry*
CIisMd5Mapper::GetDefaultHierarchy(
    LPDWORD pdwN
    )
/*++

Routine Description:

    return ptr to default hierarchy for ita mapping

Arguments:

    pdwN -- updated with hierarchy entries count

Returns:

    ptr to hierarchy entries or NULL if error

--*/
{
    *pdwN = sizeof(IisMd5MappingHierarchy) / sizeof(IISMDB_HEntry);

    return IisMd5MappingHierarchy;
}


CIisMapping*
CIisMd5Mapper::CreateNewMapping(
    LPSTR pszRealm,
    LPSTR pszUser
    )
/*++

Routine Description:

    Create a new mapping from internet credentials

Arguments:

    pszRealm -- Realm
    pszUser -- user name

Returns:

    ptr to mapping. ownership of this object is transfered to caller.
    NULL if error

--*/
{
    CMd5Mapping *pCM = new CMd5Mapping( this );
    if ( pCM == NULL )
    {
        return NULL;
    }

    if ( pCM->Init( pszRealm, pszUser, m_pHierarchy, m_cHierarchy ) )
    {
        return (CIisMapping*)pCM;
    }
    delete pCM;

    return NULL;
}


// CMd5Mapping

CMd5Mapping::CMd5Mapping(
    CIisAcctMapper* pMap
    )
/*++

Routine Description:

    Constructor for CMd5Mapping

Arguments:

    pMap -- ptr to mapper object linked to this mapping

Returns:

    Nothing

--*/
{
    m_pMapper = (CIisAcctMapper*)pMap;

    for ( int x = 0 ; x < sizeof(m_pFields)/sizeof(LPSTR) ; ++x )
    {
        m_pFields[x] = NULL;
    }
}


CMd5Mapping::~CMd5Mapping(
    )
/*++

Routine Description:

    Destructor for CItaMapping

Arguments:

    None

Returns:

    Nothing

--*/
{
}


BOOL
CMd5Mapping::Init(
    LPSTR pszRealm,
    LPSTR pszUser,
    IISMDB_HEntry *pH,
    DWORD dwH
    )
/*++

Routine Description:

    Constructor for CItaMapping

Arguments:

    pszRealm -- Realm
    pszUser -- user name
    pH -- ptr to hierarchy info
    dwH -- number of hierarchy entries

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( !MappingSetField( IISMMDB_INDEX_IT_ACCT, pszUser ) )
    {
        return FALSE;
    }

    if ( !MappingSetField( IISMMDB_INDEX_IT_REALM, pszRealm ) )
    {
        return FALSE;
    }

    return UpdateMask( pH, dwH );
}


BOOL
CMd5Mapping::MappingSetField(
    DWORD dwIndex,
    LPSTR pszNew
    )
/*++

Routine Description:

    Set field in mapping entry to specified content
    data pointed by pszNew is copied inside mapping entry

Arguments:

    dwIndex -- index of field
    pszNew -- data to copy inside field

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    MD5_CTX md5;
    CHAR achDigest[ sizeof(md5.digest)*2 +  1];



    // convert clear text pwd to MD5 digest ( as ASCII string )

    if ( dwIndex == IISMMDB_INDEX_IT_MD5PWD )
    {
        if ( !CIisMapping::MappingSetField( IISMMDB_INDEX_IT_CLRPWD, pszNew ) )
        {
            return FALSE;
        }

gen_md5pwd:

        LPSTR pszName = m_pFields[IISMMDB_INDEX_IT_ACCT];
        LPSTR pszRealm = m_pFields[IISMMDB_INDEX_IT_REALM];
        CHAR *pS;

        if ( pszName == NULL )
        {
            pszName = "";
        }
        if ( pszRealm == NULL )
        {
            pszRealm = "";
        }

        pS = new CHAR[strlen(pszName)+1+strlen(pszRealm)+1+strlen(pszNew)+1];
        if ( pS == NULL )
        {
            return FALSE;
        }

        strcpy( pS, pszName );
        strcat( pS, ":" );
        strcat( pS, pszRealm );
        strcat( pS, ":" );
        strcat( pS, pszNew );

        MD5Init( &md5 );
        MD5Update( &md5, (LPBYTE)pS, strlen(pS) );
        MD5Final( &md5 );
        for ( UINT x = 0, y = 0 ; x < sizeof(md5.digest) ; ++x )
        {
            UINT v;
            v = md5.digest[x]>>4;
            achDigest[y++] = TOHEX( v );
            v = md5.digest[x]&0x0f;
            achDigest[y++] = TOHEX( v );
        }
        achDigest[y] = '\0';
        pszNew = achDigest;

        delete [] pS;
    }
    else if ( (dwIndex == IISMMDB_INDEX_IT_REALM ||
              dwIndex == IISMMDB_INDEX_IT_ACCT) &&
              m_pFields[ IISMMDB_INDEX_IT_CLRPWD ] )
    {
        if ( !CIisMapping::MappingSetField( dwIndex, pszNew ) )
        {
            return FALSE;
        }

        dwIndex = IISMMDB_INDEX_IT_MD5PWD;
        pszNew = m_pFields[ IISMMDB_INDEX_IT_CLRPWD ];

        goto gen_md5pwd;
    }

    return CIisMapping::MappingSetField( dwIndex, pszNew );
}

#if 0
PRDN_VALUE_BLOB
CertGetNameField(
                 UINT       iEncoding,
                 IN LPCTSTR pszObjId,
                 IN PNAME_INFO pInfo
                 )
{
    DWORD cRDN, cAttr;
    PRDN pRDN;
    PRDN_ATTR pAttr;

    // Array of RDNs
    for ( cRDN = pInfo->cRDN, pRDN = pInfo->rgRDN ;
          cRDN > 0 ;
          cRDN--, pRDN++ )
    {
        for ( cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr ;
              cAttr > 0 ;
              cAttr--, pAttr++ )
        {
            if ( !strcmp( pAttr->pszObjId, pszObjId ) )
            {
                return &pAttr->Value;
            }
        }
    }

    return NULL;
}


BOOL
StoreField(
    LPSTR*  pFields,
    LPSTR*  pStore,
    UINT*   pLen,
    PRDN_VALUE_BLOB pValue
    )
{
    memc