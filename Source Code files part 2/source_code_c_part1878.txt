);

	if(m_dwStyle & EXBS_THINEDGE) {
		DrawThinEdge(hDC, lpRc,  styleBtn);
	}
	else {
		DrawThickEdge(hDC, lpRc,  styleBtn);
	}
	if(m_dwStyle & EXBS_ICON) {
		DrawIcon(hDC, lpRc, styleBtn);
	}
	else {
		DrawText(hDC, lpRc, styleBtn);
	}
	::SetBkColor(hDC, dwOldBkColor);
	::SetTextColor(hDC, dwOldTextColor);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawThickEdge
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawThickEdge(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	if(style == IS_FLAT) {
		return 0;
	}

	HPEN hPenOrig   = NULL;
	HPEN hPenWhite  = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
	HPEN hPenGlay   = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
	HPEN hPenBlack  = (HPEN)GetStockObject(BLACK_PEN);


	switch(style) {
	case IS_POPED:
		hPenOrig  = (HPEN)::SelectObject(hDC, hPenWhite);
		DrawLine(hDC, lpRc->left, lpRc->top, lpRc->right-1, lpRc->top); 
		DrawLine(hDC, lpRc->left, lpRc->top, lpRc->left, lpRc->bottom - 1);

		SelectObject(hDC, hPenGlay);
		DrawLine(hDC, lpRc->right-2, lpRc->top+1,    lpRc->right-2, lpRc->bottom - 1);
		DrawLine(hDC, lpRc->left+1,  lpRc->bottom-2, lpRc->right-1, lpRc->bottom - 2); 

		SelectObject(hDC, hPenBlack);
		DrawLine(hDC, lpRc->right-1, lpRc->top,  lpRc->right-1, lpRc->bottom); 		
		DrawLine(hDC, lpRc->left,    lpRc->bottom-1, lpRc->right,  lpRc->bottom-1);
		break;
	case IS_PUSHED:
		hPenOrig  = (HPEN)::SelectObject(hDC, hPenBlack);
		DrawLine(hDC, lpRc->left, lpRc->top, lpRc->right-1, lpRc->top); 
		DrawLine(hDC, lpRc->left, lpRc->top, lpRc->left, lpRc->bottom - 1);

		SelectObject(hDC, hPenGlay);
		DrawLine(hDC, lpRc->left+1, lpRc->top+1, lpRc->right-2, lpRc->top+1); 		
		DrawLine(hDC, lpRc->left+1, lpRc->top+1, lpRc->left+1,  lpRc->bottom - 2);

		SelectObject(hDC, hPenWhite);
		DrawLine(hDC, lpRc->right-1, lpRc->top,  lpRc->right-1, lpRc->bottom); 		
		DrawLine(hDC, lpRc->left,    lpRc->bottom-1, lpRc->right-1,  lpRc->bottom - 1);
		break;
	default:
		break;
	}
	if(hPenOrig) {
		SelectObject(hDC, hPenOrig);
	}
	DeleteObject(hPenWhite);
	DeleteObject(hPenGlay);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawThinEdge
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawThinEdge(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	HPEN hPenPrev;
	HPEN hPenTopLeft=0;
	HPEN hPenBottomRight=0;

	switch(style) {
	case IS_PUSHED:
		hPenTopLeft	    = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
		hPenBottomRight = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
		break;
	case IS_POPED:
		hPenTopLeft		= CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
		hPenBottomRight = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
		break;
	case IS_FLAT:	// do not draw 
		return 0;
		break;
	}

	hPenPrev = (HPEN)::SelectObject(hDC, hPenTopLeft);
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
	MoveToEx(hDC, lpRc->left, lpRc->top, NULL);
	LineTo(hDC,   lpRc->right, lpRc->top);
	MoveToEx(hDC, lpRc->left, lpRc->top, NULL);
	LineTo(hDC,   lpRc->left, lpRc->bottom);
#else // UNDER_CE
	{
		POINT pts[] = {{lpRc->left,  lpRc->bottom},
					   {lpRc->left,  lpRc->top},
					   {lpRc->right, lpRc->top}};
		Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
	}
#endif // UNDER_CE

	SelectObject(hDC, hPenBottomRight);
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
	MoveToEx(hDC, lpRc->right -1, lpRc->top - 1, NULL);
	LineTo(hDC,   lpRc->right -1, lpRc->bottom);
	MoveToEx(hDC, lpRc->left + 1, lpRc->bottom -1, NULL);
	LineTo(hDC,   lpRc->right -1, lpRc->bottom -1);
#else // UNDER_CE
	{
		POINT pts[] = {{lpRc->right - 1, lpRc->top    - 1},
					   {lpRc->right - 1, lpRc->bottom - 1},
					   {lpRc->left  + 1, lpRc->bottom - 1}};
		Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
	}
#endif // UNDER_CE

	SelectObject(hDC, hPenPrev);
	DeleteObject(hPenTopLeft);
	DeleteObject(hPenBottomRight);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawLine
// Type     : INT
// Purpose  : Draw Line with current Pen. 
// Args     : 
//          : HDC hDC 
//          : INT x 
//          : INT y 
//          : INT destX 
//          : INT destY 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawLine(HDC hDC, INT x, INT y, INT destX, INT destY)
{
#ifndef UNDER_CE // Windows CE does not support MoveToEx/LineTo. Use Polyline.
	MoveToEx(hDC, x, y, NULL);
	LineTo  (hDC, destX, destY);
#else // UNDER_CE
	POINT pts[] = {{x, y}, {destX, destY}};
	Polyline(hDC, pts, sizeof pts / sizeof pts[0]);
#endif // UNDER_CE
	return 0;
}
//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawIcon
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawIcon(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	if(!m_hIcon) {
		return -1;
	}

	INT sunken, xPos, yPos;
	switch(style) {
	case IS_PUSHED:
		sunken = 1;
		break;
	case IS_POPED:
	case IS_FLAT:
	default:
		sunken = 0;
		break;
	}
	//----------------------------------------------------------------
	//centering Icon
	xPos = lpRc->left + ((lpRc->right  - lpRc->left) - m_cxIcon)/2;
	yPos = lpRc->top  + ((lpRc->bottom - lpRc->top)  - m_cyIcon)/2;
	DrawIconEx(hDC,				//HDC hdc,// handle to device context
			   xPos + sunken,	//int xLeft,// x-coordinate of upper left corner
			   yPos + sunken,	//int yTop,// y-coordinate of upper left corner
			   m_hIcon,			//HICON hIcon,// handle to icon to draw
			   m_cxIcon,		//int cxWidth,// width of the icon
			   m_cyIcon,		//int cyWidth,// height of the icon
			   0,				//UINT istepIfAniCur,// index of frame in animated cursor
			   NULL,			//HBRUSH hbrFlickerFreeDraw,// handle to background brush
			   DI_NORMAL);		//UINT diFlags// icon-drawing flags
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawBitmap
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawBitmap(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
	return 0;
	Unref(hDC);
	Unref(lpRc);
	Unref(style);
}

//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawText
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
inline BOOL MIN(INT a, INT b)
{
	if(a > b) {
		return b;
	}
	else {
		return a;
	}
}
//////////////////////////////////////////////////////////////////
// Function : CEXButton::DrawText
// Type     : INT
// Purpose  : 
// Args     : 
//          : HDC hDC 
//          : LPRECT lpRc 
//          : IMAGESTYLE style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT CEXButton::DrawText(HDC hDC, LPRECT lpRc, IMAGESTYLE style)
{
#if 0
	Dbg(("DrawText START style[%d]\n", style));
	Dbg(("--->Clinet w[%d] h[%d]\n",
		 lpRc->right - lpRc->left,
		 lpRc->bottom - lpRc->top));
#endif
	static POINT pt;
	static RECT	 rc;
	INT sunken, len;
	if(!m_lpwstrText) {
		Dbg(("--->Error m_lpwstrText is NULL\n"));
		return -1;
	}
	len = lstrlenW(m_lpwstrText);
	//DBGW((L"--->len [%d] str[%s]\n", len, m_lpwstrText));
	HFONT hFontPrev;

	if(m_hFont) {
		hFontPrev = (HFONT)::SelectObject(hDC, m_hFont); 
	}
	else {
		hFontPrev = (HFONT)::SelectObject(hDC, GetStockObject(DEFAULT_GUI_FONT));
	}

	ExGetTextExtentPoint32W(hDC, 
							m_lpwstrText, 
							len, 
							&m_tmpSize);
	//Dbg(("--->size.cx [%d] cy[%d]\n", m_tmpSize.cx, m_tmpSize.cy));
	if((lpRc->right - lpRc->left) > m_tmpSize.cx) {
		pt.x = lpRc->left + ((lpRc->right - lpRc->left) - m_tmpSize.cx)/2;
	}
	else {
		pt.x = lpRc->left+2; //2 is edge space
	}
	
	if((lpRc->bottom - lpRc->top) > m_tmpSize.cy) {
		pt.y = lpRc->top + ((lpRc->bottom - lpRc->top) - m_tmpSize.cy)/2;
	}
	else {
		pt.y = lpRc->top+2; //2 is edge space 
	}
	switch(style) {
	case IS_PUSHED:
		sunken = 1;
		break;
	case IS_POPED:
	case IS_FLAT:
	default:
		sunken = 0;
	}

	rc.left   = pt.x;
	rc.right  = lpRc->right - 2;
	rc.top    = pt.y;
	rc.bottom = lpRc->bottom-2;
#if 0
	Dbg(("--->rc l[%d] t[%d] r[%d] b[%d]\n", 
		 rc.left,
		 rc.top,
		 rc.right,
		 rc.bottom));
#endif
	if(m_fEnable) {
		DWORD dwOldBk = ::SetBkMode(hDC, TRANSPARENT);
		ExExtTextOutW(hDC,
					  pt.x + sunken, 
					  pt.y + sunken,
					  ETO_CLIPPED,
					  &rc, 
					  m_lpwstrText,
					  len,
					  NULL);
		::SetBkMode(hDC, dwOldBk);
	}
	else {
		DWORD dwOldTC;
		static RECT rcBk;
		rcBk = rc;
		rcBk.left   +=1 ;
		rcBk.top    +=1 ;
		rcBk.right  +=1;
		rcBk.bottom +=1;
		//Draw white text.
		dwOldTC = ::SetTextColor(hDC, GetSysColor(COLOR_3DHILIGHT));
		ExExtTextOutW(hDC,
					  pt.x + sunken+1,
					  pt.y + sunken+1,
					  ETO_CLIPPED,
					  &rcBk, 
					  m_lpwstrText,
					  len,
					  NULL);
		::SetTextColor(hDC, GetSysColor(COLOR_GRAYTEXT));
		DWORD dwOldBk = ::SetBkMode(hDC, TRANSPARENT);
		ExExtTextOutW(hDC,
					  pt.x + sunken, 
					  pt.y + sunken,
					  ETO_CLIPPED,
					  &rc, 
					  m_lpwstrText,
					  len,
					  NULL);
		::SetBkMode(hDC, dwOldBk);
		::SetTextColor(hDC, dwOldTC);
	}

	SelectObject(hDC, hFontPrev);

	//Dbg(("--->DrawText END\n"));
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\ddbtn\testmain.cpp ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include "resource.h"

#include "dbg.h"
#include "ddbtn.h"
#include "../ptt/ptt.h"

char g_szClass[]="TestMain";
HINSTANCE g_hInst;
BOOL InitApplication(HINSTANCE hInst, LPSTR lpstrClass, WNDPROC lpfnWndProc)
{
	return 0;
}

LPWSTR GetWText(HWND hwnd, INT wID)
{
	CHAR   szBuf[256];
	static WCHAR wchBuf[512];
	Edit_GetText(GetDlgItem(hwnd, wID), szBuf, sizeof(szBuf));
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						szBuf, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}

INT GetINT(HWND hwnd, INT wID)
{
	CHAR szBuf[32];
	Edit_GetText(GetDlgItem(hwnd, wID), szBuf, sizeof(szBuf));
	return atoi(szBuf);
}

typedef struct tagVALLIST {
	INT wID;
	INT lParam;
}VALLIST;

VALLIST slist[] = {
	{ IDC_DDBS_TEXT,				DDBS_TEXT		},
	{ IDC_DDBS_ICON,				DDBS_ICON		},
	{ IDC_DDBS_THINEDGE,			DDBS_THINEDGE	},
	{ IDC_DDBS_FLAT,				DDBS_FLAT		},
	{ IDC_DDBS_NOSEPARATEDBUTTON,	DDBS_NOSEPARATED},
};

typedef struct tagICONLIST {
	INT wID;
	INT lParam;
	INT width;
	INT height;
}ICONLIST;

ICONLIST iconList[]={
	{ IDC_RADIO_ICON1,	IDI_ICON1, 16, 16, },
	{ IDC_RADIO_ICON2,  IDI_ICON1, 32, 32, },
	{ IDC_RADIO_ICON3,	IDI_ICON2, 16, 16, },
	{ IDC_RADIO_ICON4,  IDI_ICON2, 32, 32, },
};

HWND MainCreateWindow(HINSTANCE hInst, HWND hwndOwner, LPSTR lpstrClass, LPVOID lpVoid)
{
	HWND hwnd;
	hwnd = CreateDialogParam(hInst, 
							 g_szClass, 
							 hwndOwner, 
							 NULL, 
							 (LPARAM)lpVoid);
	if(!hwnd) {
		return (HWND)NULL;
	}
	UpdateWindow(hwnd);
	return hwnd;
}

#define ArrayCount(a)	(sizeof(a)/sizeof(a[0]))
#define MAX(a, b)		( a > b ? a : b)
#define IDC_DDBID		4096
#define IDC_SWITCHVIEW	8888

HWND CreateSwitchViewButton(HINSTANCE hInst, HWND hwndParent, INT wID)
{
	HWND hwnd = DDButton_CreateWindow(hInst, 
									  hwndParent, 
									  DDBS_ICON,
									  wID,
									  80,
									  30, 
									  36,
									  24);
	HICON hIcon = LoadImage(hInst,
							MAKEINTRESOURCE(IDI_ICON2),
							IMAGE_ICON, 
							16, 16,
							LR_DEFAULTCOLOR);
	DDButton_SetIcon(hwnd, hIcon);
	DDBITEM ddbItem;
	ZeroMemory(&ddbItem, sizeof(ddbItem));
	ddbItem.cbSize = sizeof(ddbItem);

	ddbItem.lpwstr = L"ڍו\";
	DDButton_AddItem(hwnd, &ddbItem);
	ddbItem.lpwstr = L"g\";
	DDButton_AddItem(hwnd, &ddbItem);
	DDButton_SetCurSel(hwnd, 0);
	return hwnd;
}


LRESULT CALLBACK MainWndProc(HWND	hwnd,
							 UINT	uMsg,
							 WPARAM	wParam,
							 LPARAM	lParam)
{
	PAINTSTRUCT ps;
	HDC hDC;
	RECT rc;
	static INT iIndex;
	switch(uMsg) {
	case WM_CREATE:
		{
			DDButton_CreateWindow(g_hInst, hwnd, DDBS_ICON,
								  IDC_DDBID,
								  20,
								  30, 
								  36,
								  24);
			CreateSwitchViewButton(g_hInst, hwnd, IDC_SWITCHVIEW);
		}
		SetTimer(hwnd, 0x9999, 50, NULL);
		return 1;
	case WM_TIMER:
		{
			KillTimer(hwnd, wParam);
			INT i;
			for(i = 0; i < sizeof(iconList)/sizeof(iconList[0]); i++) {
				HICON hIcon = LoadImage(g_hInst,
										MAKEINTRESOURCE(iconList[i].lParam),
										IMAGE_ICON, 
										iconList[i].width,
										iconList[i].height,
										LR_DEFAULTCOLOR);
				SendMessage(GetDlgItem(hwnd, iconList[i].wID),
							BM_SETIMAGE,
							(WPARAM)IMAGE_ICON,
							(LPARAM)hIcon);
			}
			HWND hwndDDB	 = GetDlgItem(hwnd, IDC_DDBID);
			for(i = 0; i < 23; i++) {
				DDBITEM ddbItem;
				WCHAR wchBuf[256];
				ZeroMemory(&ddbItem, sizeof(ddbItem));
				ddbItem.cbSize = sizeof(ddbItem);
				ddbItem.lpwstr = wchBuf;
				swprintf(wchBuf, L"Item %2d", i);
				DDButton_AddItem(hwndDDB, &ddbItem);
			}
		}
		break;
	case WM_SYSCOMMAND:
		if(wParam == SC_CLOSE) {
			PostQuitMessage(0);
		}
		break;
	case WM_COMMAND:
		{
			WORD wNotifyCode = HIWORD(wParam); // notification code 
			WORD wID		 = LOWORD(wParam);         // item, control, or accelerator identifier 
			HWND hwndCtl	 = (HWND) lParam;      // handle of control 
			HWND hwndDDB	 = GetDlgItem(hwnd, IDC_DDBID);
			switch(wID) {
			case IDC_DDBID:
				{
					switch(wNotifyCode) {
					case DDBN_CLICKED:
						DBG(("DDBN_CLICKED come\n"));
						break;
					case DDBN_SELCHANGE:
						DBG(("DDBN_SELCHANGE come\n"));
						break;
					case DDBN_DROPDOWN:
						DBG(("DDBN_DROPDOWN come\n"));
						break;
					case DDBN_CLOSEUP:
						DBG(("DDBN_CLOSEUP come\n"));
						break;
					default:
						DBG(("ERROR Unknown Notify\n"));
						break;
					}
				}
				break;
			case IDC_ADDITEM:
				{
					DDBITEM ddbItem;
					ZeroMemory(&ddbItem, sizeof(ddbItem));
					ddbItem.cbSize = sizeof(ddbItem);
					ddbItem.lpwstr = GetWText(hwnd, IDC_EDIT_ADDITEM);
					DDButton_AddItem(hwndDDB, &ddbItem);
					iIndex++;
				}
				break;
			case IDC_INSERTITEM:
				{
					DDBITEM ddbItem;
					INT index;
					WCHAR wchItem[256];
					ZeroMemory(&ddbItem, sizeof(ddbItem));
					ddbItem.cbSize = sizeof(ddbItem);
					ddbItem.lpwstr = GetWText(hwnd, IDC_EDIT_INSERTITEM);
					index = GetINT(hwnd, IDC_EDIT_INSERTITEM_INDEX);
					DDButton_InsertItem(hwndDDB, iIndex, &ddbItem);
				}
				break;
			case IDC_GETCURSEL:
				{
					INT i;
					char szBuf[256];
					i = DDButton_GetCurSel(hwndDDB);
					wsprintf(szBuf, "Cur Sel Index %d", i);
					Static_SetText(GetDlgItem(hwnd, IDC_STATIC_GETCURSEL), szBuf);
				}
				break;
			case IDC_SETTEXT:
				{
					DDButton_SetText(hwndDDB, GetWText(hwnd, IDC_EDIT_SETTEXT));
				}
				break;
			case IDC_SETCURSEL:
				{
					DDButton_SetCurSel(hwndDDB, GetINT(hwnd, IDC_EDIT_SETCURSEL));
				}
				break;
			case IDC_SETICON:
				{
					INT i;
					for(i = 0; i < sizeof(iconList)/sizeof(iconList[0]); i++) {
						if(Button_GetCheck(GetDlgItem(hwnd, iconList[i].wID))) {
							HICON hIcon = LoadImage(g_hInst,
													MAKEINTRESOURCE(iconList[i].lParam),
													IMAGE_ICON, 
													iconList[i].width,
													iconList[i].height,
													LR_DEFAULTCOLOR);
							DDButton_SetIcon(hwndDDB, hIcon);
						}
					}
				}
				break;
			case IDC_SETSTYLE:
				{
					INT i;
					DWORD dwStyle = 0;
					for(i = 0; i < sizeof(slist)/sizeof(slist[0]); i++) {
						INT ret = Button_GetCheck(GetDlgItem(hwnd, slist[i].wID));
						if(ret) {
							dwStyle |= slist[i].lParam;
						}
					}
					DDButton_SetStyle(hwndDDB, dwStyle);
				}
				break;
			}
		}
		break;
	case WM_PAINT:
		hDC = BeginPaint(hwnd, &ps);
		GetClientRect(hwnd, &rc);
		FillRect(hDC, &rc, (HBRUSH)(COLOR_3DFACE + 1));
		EndPaint(hwnd, &ps);
		break;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int WINAPI WinMain(HINSTANCE hInstance,
				   HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine,
				   int nCmdShow)
{

	MSG msg;
	HWND hwnd;
	INT ret;
	
	g_hInst = hInstance;
	WNDCLASSEX  wc;
	ZeroMemory(&wc, sizeof(wc));

	wc.cbSize			= sizeof(wc);
	wc.style			= CS_HREDRAW | CS_VREDRAW;	 /* Class style(s). */
	wc.lpfnWndProc		= (WNDPROC)MainWndProc;
	wc.cbClsExtra		= 0;					/* No per-class extra data.*/
	wc.cbWndExtra		= DLGWINDOWEXTRA;		/* No per-window extra data.		  */
	wc.hInstance		= hInstance;			/* Application that owns the class.	  */
	wc.hIcon			= NULL; //LoadIcon(hInstance, MAKEINTRESOURCE(SCROLL32_ICON));
	wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1); //UGetStockObject(LTGRAY_BRUSH); //WHITE_BRUSH); 
	wc.lpszMenuName		= NULL; //g_szClass;    /* Name of menu resource in .RC file. */
	wc.lpszClassName	= g_szClass;	  /* Name used in call to CreateWindow. */
	wc.hIconSm = NULL;
	RegisterClassEx(&wc);

	hwnd = CreateDialog(hInstance, 
						g_szClass, 
						0, 
						NULL);

	UpdateWindow(hwnd); 
	ShowWindow(hwnd, SW_SHOW);
	while (GetMessage(&msg, NULL, 0, 0)){
		TranslateMessage(&msg);
		DispatchMessage(&msg); 
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\exbtn.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "dbg.h"
#include "cexbtn.h"

//////////////////////////////////////////////////////////////////
// Function : EXButton_CreateWindow
// Type     : HWND
// Purpose  : Opened API.
//			: Create Extended Button.
// Args     : 
//          : HINSTANCE		hInst 
//          : HWND			hwndParent 
//          : DWORD			dwStyle		EXBS_XXXXX combination.
//          : INT			wID			Window ID
//          : INT			xPos 
//          : INT			yPos 
//          : INT			width 
//          : INT			height 
// Return   : 
// DATE     : 970905
//////////////////////////////////////////////////////////////////
#ifndef UNDER_CE
#define SZCLASSNAME "MSIME_EXB"
#else // UNDER_CE
#define SZCLASSNAME TEXT("MSIME_EXB")
#endif // UNDER_CE
#ifdef UNDER_CE // In Windows CE, all window classes are process global.
static LPCTSTR MakeClassName(HINSTANCE hInst, LPTSTR lpszBuf)
{
	// make module unique name
	TCHAR szFileName[MAX_PATH];
	GetModuleFileName(hInst, szFileName, MAX_PATH);
	LPTSTR lpszFName = _tcsrchr(szFileName, TEXT('\\'));
	if(lpszFName) *lpszFName = TEXT('_');
	lstrcpy(lpszBuf, SZCLASSNAME);
	lstrcat(lpszBuf, lpszFName);
	return lpszBuf;
}

BOOL EXButton_UnregisterClass(HINSTANCE hInst)
{
	TCHAR szClassName[MAX_PATH];
	return UnregisterClass(MakeClassName(hInst, szClassName), hInst);
}

#endif // UNDER_CE
HWND EXButton_CreateWindow(HINSTANCE	hInst, 
						   HWND			hwndParent, 
						   DWORD		dwStyle,
						   INT			wID, 
						   INT			xPos,
						   INT			yPos,
						   INT			width,
						   INT			height)
{
	DBG_INIT();
	LPCEXButton lpEXB = new CEXButton(hInst, hwndParent, dwStyle, wID);
	HWND hwnd;
	if(!lpEXB) {
		return NULL;
	}
#ifndef UNDER_CE // In Windows CE, all window classes are process global.
	lpEXB->RegisterWinClass(SZCLASSNAME);
	hwnd = CreateWindowEx(0,
						  SZCLASSNAME, 
#else // UNDER_CE
	TCHAR szClassName[MAX_PATH];
	MakeClassName(hInst, szClassName);

	lpEXB->RegisterWinClass(szClassName);
	hwnd = CreateWindowEx(0,
						  szClassName, 
#endif // UNDER_CE
#ifndef UNDER_CE
						  "", 
#else // UNDER_CE
						  TEXT(""),
#endif // UNDER_CE
						  WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, 
						  xPos, yPos,
						  width,
						  height,
						  hwndParent,
#ifdef _WIN64
						  (HMENU)(INT_PTR)wID,
#else
						  (HMENU)wID,
#endif
						  hInst,
						  (LPVOID)lpEXB);
	return hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\cexbtn.h ===
#ifndef _CLASS_EXTENDED_BUTTON_H_
#define _CLASS_EXTENDED_BUTTON_H_
#include <windowsx.h>
#include "dbg.h"
#include "ccom.h" 

#ifdef UNDER_CE // macro
// Under WindowsCE, DrawIcon() is defined as DrawIconEx(), not a real function
#undef DrawIcon
#endif // UNDER_CE

//----------------------------------------------------------------
//Pushed poped, flat image style definition.
//----------------------------------------------------------------
typedef enum tagIMAGESTYLE {
	IS_FLAT = 0,
	IS_POPED,
	IS_PUSHED,
}IMAGESTYLE;

class CEXButton;
typedef CEXButton *LPCEXButton;

class CEXButton : public CCommon
{
public:	
	CEXButton(HINSTANCE hInst, HWND hwndParent, DWORD dwStyle, DWORD wID); 
	~CEXButton();
#ifndef UNDER_CE
	BOOL	RegisterWinClass(LPSTR lpstrClassName);
#else // UNDER_CE
	BOOL	RegisterWinClass(LPTSTR lpstrClassName);
#endif // UNDER_CE
	INT		MsgCreate			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgPaint			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgDestroy			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgTimer			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgMouseMove		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgButtonDown		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT		MsgButtonUp			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT		MsgNcMouseMove		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgNcButtonDown		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT		MsgNcButtonUp		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	INT		MsgEnable			(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgSetFont			(HWND hwnd, WPARAM wParam, LPARAM lParam);	
	INT		MsgCaptureChanged	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgEXB_GetCheck		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgEXB_SetCheck		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgEXB_SetIcon		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgEXB_SetText		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	INT		MsgEXB_SetStyle		(HWND hwnd, WPARAM wParam, LPARAM lParam);
private:
	//----------------------------------------------------------------	
	// Private method
	//----------------------------------------------------------------	
	INT		NotifyToParent	(INT notify);
	INT		NotifyClickToParent(INT notify);
	INT		PressedState();
	INT		CancelPressedState();

	INT		DrawButton		(HDC hDC, LPRECT lpRc);
	INT		DrawThickEdge	(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT     DrawThinEdge	(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT     DrawIcon		(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT     DrawBitmap		(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT     DrawText		(HDC hDC, LPRECT lpRc, IMAGESTYLE imageStyle);
	INT     DrawLine		(HDC hDC, INT x, INT y, INT destX, INT destY);
	//----------------------------------------------------------------	
	//member variable
	//----------------------------------------------------------------	
	HINSTANCE			m_hInst;
	HWND				m_hwndParent;
	HWND				m_hwndFrame;
	DWORD				m_dwStyle;			//combination of DDBS_XXXX
	DWORD				m_wID;				//Window ID;
	BOOL				m_fEnable;			//Enabled or Disabled.		
	HFONT				m_hFont;			//Font handle
	HICON				m_hIcon;			//Icon handle
	INT					m_cxIcon;			//Icon width
	INT					m_cyIcon;			//Icon height
	LPWSTR				m_lpwstrText;		//Button face text.
	BOOL				m_fPushed;			//Toggle button : Pushed or poped state. 
	BOOL				m_fArmed;			//Pushed or poped apparence.
	BOOL				m_fDowned;			//Mouse has clicked.
	BOOL				m_fDblClked;		//Send Double click or not.
	BOOL				m_fWaiting;			// Waiting for double click.
#ifdef NOTUSED // kwada
	INT					m_wNotifyMsg;		// either EXBN_CLICKED or EXBN_DOUBLECLICKED
#endif
	BOOL				m_f16bitOnNT;		//it's on 16bit Application On WinNT. 
	SIZE				m_tmpSize;			//to reduce stack
#ifndef UNDER_CE // not support WNDCLASSEX
	WNDCLASSEX			m_tmpWC;			//to reduce stack
#else // UNDER_CE
	WNDCLASS			m_tmpWC;			//to reduce stack
#endif // UNDER_CE
	RECT				m_tmpBtnRc;			//to reduce stack
	RECT				m_tmpRect;			//to reduce stack
	RECT				m_tmpRect2;			//to reduce stack
	POINT				m_tmpPoint;			//to reduce stack
	PAINTSTRUCT			m_tmpPs;			//to reduce stack
	ICONINFO			m_tmpIconInfo;		//to reduce stack
	BITMAP				m_tmpBitmap;		//to reduce stack
};

#endif //_CLASS_EXTENDED_BUTTON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\dbg.h ===
//////////////////////////////////////////////////////////////////
// File     : dbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef _DBG_H_
#define _DBG_H_
//-------------------------------------------------------
//dbgmgr.h is ../common/dbgmgr.h IME98's common debuging api header.
//In IMEPAD,  only for MemAlloc(), MemFree() function.
//because, we had to send allocate data to ImeIPoint and Freed in 
//it. 
//-------------------------------------------------------

//-------------------------------------------------------
//MACRO function(?) prototype declare
//-------------------------------------------------------
////////////////////////////////////////////////////////
// Function	: DBG
// Type		: VOID
// Purpose	: Printing ANSI debug message with same usage as printf()
//			: 
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//		   : ...	
// CAUTION: Please use DOUBLE Blaket!!!
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

////////////////////////////////////////////////////////
// Function	: DBGMB
// Type		: VOID
// Purpose	: Show Messagebox for ANSI debug message 
//			: Same usage as printf()
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBGMB((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function	: DBGShowWindow
// Type		: VOID
// Purpose	: Invoke debug message window.
//			: DBG(), DBGW()'s message is shown here.
// Args		: HINSTANCE	hInst
//		    : HWND		hwndOwner
/////////////////////////////////////////////////////////
//VOID DBGShowWindow(HINSTANCE hInst, HWND hwndOwner);



#ifdef _DEBUG
extern VOID		_exbtnInit(VOID);
#ifndef UNICODE_ONLY
extern VOID  _exbtnA		 (LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
extern VOID  _exbtnPrintA (LPSTR lpstrMsg, ...);
extern LPSTR _exbtnVaStrA (LPSTR lpstrFmt, ...);
extern LPWSTR _exbtnMulti2Wide(LPSTR lpstr);
extern VOID _exbtnMBA(LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
extern VOID _exbtnMBW(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
#endif

#ifndef ANSI_ONLY
extern VOID   _exbtnW(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _exbtnPrintW(LPWSTR lpstrMsg, ...);
extern LPWSTR _exbtnVaStrW(LPWSTR lpstrFmt, ...);
#endif
#endif


#if defined(_DEBUG) || (defined(_NDEBUG) && defined(_RELDEBUG))
#	define DBG_INIT()			_exbtnInit()
#	define DBGW(a)				_exbtnW( _exbtnMulti2Wide(__FILE__), __LINE__, _exbtnVaStrW a)
#	define DBGA(a)				_exbtnA(__FILE__, __LINE__, _exbtnVaStrA a)
#	define Dbg(a)				_exbtnA(__FILE__, __LINE__, _exbtnVaStrA a)
#	define DBGMB(a)				_exbtnMBA(__FILE__, __LINE__, _exbtnVaStrA a)
#	define DBGMBA(a)			_exbtnMBA(__FILE__, __LINE__, _exbtnVaStrA a)
#	define DBGMBW(a)			_exbtnMBW(_exbtnMulti2Wide(__FILE__), __LINE__, _exbtnVaStrW a)
#else //!_DEBUG	//in Release version, these are disapear...
#	define DBG_INIT()
#	define DBGW(a)	
#	define DBGA(a)		
#	define Dbg(a)
#	define DBGMB(a)
#	define DBGMBA(a)
#	define DBGMBW(a)
#endif //_DEBUG


#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\dbg.cpp ===
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include <stdio.h>
#include <commdlg.h>
#include "dbg.h"

#define PRINT_STRW	//OutputDebugStringW
#define PRINT_STRA	//OutputDebugStringA
static FILE *g_fp;
//-------------------------------------------------------
//Global String buffer
//-------------------------------------------------------
static WCHAR g_wchBuf[1024];
static CHAR  g_chBuf[1024];

static LPSTR GetFileTitleStrA(LPSTR lpstrFile)
{
	static CHAR tchJunk64[64];
	GetFileTitleA(lpstrFile, tchJunk64, sizeof(tchJunk64));	
	return tchJunk64;
}

static LPWSTR GetFileTitleStrW(LPWSTR lpstrFile)
{
	static WCHAR tchJunk64[64];
	GetFileTitleW(lpstrFile, tchJunk64, sizeof(tchJunk64));	
	return tchJunk64;
}


////////////////////////////////////////////////////////
// Function : _exbtnMBA
// Type     : VOID
// Purpose  : Popup Debug MessageBox
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstrMsg 
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
VOID _exbtnMBA(LPSTR	lpstrFile, 
			   INT		lineNo, 
			   LPSTR	lpstrMsg)
{
	wsprintfA(g_chBuf, 
			  "%s(%d)%s", 
			  GetFileTitleStrA(lpstrFile),
			  lineNo,
			  lpstrMsg);
	MessageBoxA(NULL, 
				g_chBuf, 
				"#### IMEPAD ERROR MESSAGE #####",
				MB_ICONERROR | MB_OK | MB_APPLMODAL);
	return;
}

VOID _exbtnMBW(LPWSTR	lpstrFile, 
			   INT		lineNo, 
			   LPWSTR	lpstrMsg)
{
	wsprintfW(g_wchBuf, 
			 L"%s(%d)%s", 
			 GetFileTitleStrW(lpstrFile),			 
			 lineNo,
			 lpstrMsg);
	MessageBoxW(NULL, 
				lpstrFile, 
				L"#### ERROR #####",
				MB_OK | MB_APPLMODAL);
	return;
}


////////////////////////////////////////////////////////
// Function : _exbtnVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _exbtnVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfW(wchBuf, lpstrFmt, ap);
	va_end(ap);
	return wchBuf;
}

LPSTR _exbtnVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(chBuf, lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function: _exbtnPrint
// Type    : VOID
// Purpose : variable args version of OutputDebugString
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _exbtnPrintA(LPSTR lpstrFmt, ...)
{
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(g_chBuf, lpstrFmt, ap);
	va_end(ap);
	if(g_fp) {
		fprintf(g_fp, "%s", g_chBuf);
	}
	PRINT_STRA(g_chBuf);
	return;
}

VOID _exbtnPrintW(LPWSTR lpstrFmt, ...)
{
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfW(g_wchBuf, lpstrFmt, ap);
	va_end(ap);
	if(g_fp) {
		fwprintf(g_fp, L"%s", g_wchBuf);
	}
	PRINT_STRW(g_wchBuf);
	return;
}

////////////////////////////////////////////////////////
// Function: _exbtn
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _exbtnA(LPSTR		lpstrFile, 
		   INT		lineNo, 
		   LPSTR		lpstrMsg
)
{
	_exbtnPrintA("(%s:%d) %s", 
			   GetFileTitleStrA(lpstrFile),
			   lineNo,
			   lpstrMsg);
	return;
}

VOID _exbtnW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg
)
{
	_exbtnPrintW(L"(%s:%d) %s", 
			   GetFileTitleStrW(lpstrFile),
			   lineNo,
			   lpstrMsg);

	return;
}

LPWSTR _exbtnMulti2Wide(LPSTR lpstr)
{
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)g_wchBuf, sizeof(g_wchBuf)/sizeof(WCHAR) );
	return g_wchBuf;
}

VOID _exbtnInit(VOID)
{
#if 0
	if(!g_fp) {
		g_fp = fopen("c:\\temp\\exbtn.log", "w+");
		if(!g_fp) {
			return;
		}
	}
#endif
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\exbtn.h ===
//////////////////////////////////////////////////////////////////
// File     :	exbtn.h ( Extended Button)
// Purpose  :	new control for button
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//	
// History	:970905 Started
//////////////////////////////////////////////////////////////////
#ifndef _EXTENDED_BUTTON_
#define _EXTENDED_BUTTON_

//----------------------------------------------------------------
//Extended Button Style
//----------------------------------------------------------------
#define EXBS_TEXT			0x0000		// Show Text as Button Face.(Default value)
#define EXBS_ICON			0x0001		// Show Icon as Button Face.
#define EXBS_THINEDGE		0x0002		// Draw Thin Edge.
#define EXBS_FLAT			0x0004		// Flat style drop down button.
#define EXBS_TOGGLE			0x0010		// Keep push state.
#define EXBS_DBLCLKS		0x0020		// Send double clicks. kwada 980402

#define EXBM_GETCHECK			(WM_USER + 100)
#define EXBM_SETCHECK			(WM_USER + 101)
#define EXBM_SETICON			(WM_USER + 102)
#define EXBM_SETTEXT			(WM_USER + 103)
#define EXBM_SETSTYLE			(WM_USER + 104)

//----------------------------------------------------------------
//Drop Down Button Notify code.
//It is set to Parent window of Drop Down button as
//WM_COMMAND.
//----------------------------------------------------------------
#define EXBN_CLICKED		0
#define EXBN_ARMED			1		//Button
#define EXBN_DISARMED		2
#define EXBN_DOUBLECLICKED	3

//////////////////////////////////////////////////////////////////
// Function : EXButton_GetCheck
// Type     : INT
// Purpose  : Set button image as icon.
// Args     : HWND		hwndCtrl:		EXButton window handle.
// Remarks	: EXBS_ICON style must be set.
// Return   : 
//////////////////////////////////////////////////////////////////
#define EXButton_GetCheck(hwndCtrl) \
		((int)(DWORD)SendMessage((hwndCtrl), EXBM_GETCHECK, (WPARAM)0, (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : EXButton_SetCheck
// Type     : INT
// Purpose  : Set button image as icon.
// Args     : HWND		hwndCtrl:		EXButton window handle.
//			: BOOL		fCheck:			Check state or Uncheck state.
// Remarks	: EXBS_TOGGLE style must be set.
// Return   : 
//////////////////////////////////////////////////////////////////
#define EXButton_SetCheck(hwndCtrl, fCheck) \
		((int)(DWORD)SendMessage((hwndCtrl), EXBM_SETCHECK, (WPARAM)(BOOL)fCheck, (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : EXButton_SetIcon
// Type     : INT
// Purpose  : Set button image as icon.
// Args     : HWND		hwndCtrl:		EXButton window handle.
//			: HICON		hIcon:			Icon handle.
// Remarks	: EXBS_ICON style must be set.
// Return   : 
//////////////////////////////////////////////////////////////////
#define EXButton_SetIcon(hwndCtrl, hIcon) \
		((int)(DWORD)SendMessage((hwndCtrl), EXBM_SETICON, (WPARAM)hIcon, (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : EXButton_SetText
// Type     : INT
// Purpose  : Set button image as icon.
// Args     : HWND		hwndCtrl:		EXButton window handle.
//			: LPWSTR	lpsz:			Unicode String pointer.
// Remarks	: 
// Return   : 
//////////////////////////////////////////////////////////////////
#define EXButton_SetText(hwndCtrl, lpsz) \
		((int)(DWORD)SendMessage((hwndCtrl), EXBM_SETTEXT, (WPARAM)lpsz, (LPARAM)0))

//////////////////////////////////////////////////////////////////
// Function : EXButton_SetStyle
// Type     : INT
// Purpose  : Set Drop down button's style.
// Args     : HWND		hwndCtrl:		EXButton window handle.
//			: DWORD		dwStyle:		EXBS_XXXXX combination.
// Remarks	: 
// Return   : 
//////////////////////////////////////////////////////////////////
#define EXButton_SetStyle(hwndCtrl, dwStyle) \
		((int)(DWORD)SendMessage((hwndCtrl), EXBM_SETSTYLE, (WPARAM)dwStyle, (LPARAM)0))


//////////////////////////////////////////////////////////////////
// Function : EXButton_CreateWindow
// Type     : HWND
// Purpose  : Opened API.
//			: Create Drop Down Button.
// Args     : 
//          : HINSTANCE		hInst 
//          : HWND			hwndParent 
//          : DWORD			dwStyle		EXBS_XXXXX combination.
//          : INT			wID			Window ID
//          : INT			xPos 
//          : INT			yPos 
//          : INT			width 
//          : INT			height 
// Return   : 
// DATE     : 970905
//////////////////////////////////////////////////////////////////
extern HWND EXButton_CreateWindow(HINSTANCE	hInst, 
								  HWND		hwndParent, 
								  DWORD		dwStyle,
								  INT		wID, 
								  INT		xPos,
								  INT		yPos,
								  INT		width,
								  INT		height);

#ifdef UNDER_CE // In Windows CE, all window classes are process global.
extern BOOL EXButton_UnregisterClass(HINSTANCE hInst);
#endif // UNDER_CE

#endif //_EXTENED_BUTTON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testmain.rc
//
#define IDI_ICON1                       111
#define IDI_ICON2                       112
#define IDD_LISTREPORT                  500
#define IDD_PADLIST                     501
#define IDC_ADDITEM                     1024
#define IDC_INSERTITEM                  1025
#define IDC_GETCURSEL                   1026
#define IDC_SETTEXT                     1027
#define IDC_SETCURSEL                   1033
#define IDC_SETICON                     1034
#define IDC_DDBS_TEXT                   1037
#define IDC_EXBS_TEXT                   1037
#define IDC_SETSTYLE                    1038
#define IDC_DDBS_ICON                   1039
#define IDC_EXBS_ICON                   1039
#define IDC_DDBS_DROPDOWN               1040
#define IDC_EXBS_TOGGLE                 1040
#define IDC_DDBS_THINEDGE               1041
#define IDC_EXBS_THINEDGE               1041
#define IDC_DDBS_FLAT                   1043
#define IDC_EXBS_FLAT                   1043
#define IDC_EDIT_ADDITEM                1044
#define IDC_EDIT_INSERTITEM_INDEX       1045
#define IDC_EDIT_INSERTITEM             1046
#define IDC_EDIT_SETCURSEL              1047
#define IDC_STATIC_GETCURSEL            1048
#define IDC_RADIO_ICON1                 1052
#define IDC_RADIO_ICON2                 1053
#define IDC_EDIT_SETTEXT                1054
#define IDC_RADIO_ICON3                 1055
#define IDC_RADIO_ICON4                 1056
#define IDC_SETCHECK_FALSE              1057
#define IDC_SETCHECK_TRUE               1058
#define IDC_ENABLE_TRUE                 1059
#define IDC_ENABLE_FALSE                1060
#define IDC_BUTTON3                     1061
#define IDB_KEYLIST                     3000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1062
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\exbtn\testmain.cpp ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include "resource.h"

#include "dbg.h"
#include "exbtn.h"

char g_szClass[]="TestMain";
HINSTANCE g_hInst;
BOOL InitApplication(HINSTANCE hInst, LPSTR lpstrClass, WNDPROC lpfnWndProc)
{
	return 0;
}

LPWSTR GetWText(HWND hwnd, INT wID)
{
	CHAR   szBuf[256];
	static WCHAR wchBuf[512];
	Edit_GetText(GetDlgItem(hwnd, wID), szBuf, sizeof(szBuf));
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						szBuf, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}

typedef struct tagVALLIST {
	INT wID;
	INT lParam;
}VALLIST;

VALLIST slist[] = {
	{ IDC_EXBS_TEXT,		EXBS_TEXT		},
	{ IDC_EXBS_ICON,		EXBS_ICON		},
	{ IDC_EXBS_THINEDGE,	EXBS_THINEDGE	},
	{ IDC_EXBS_FLAT,		EXBS_FLAT		},
	{ IDC_EXBS_TOGGLE,		EXBS_TOGGLE		},
};

typedef struct tagICONLIST {
	INT wID;
	INT lParam;
	INT width;
	INT height;
}ICONLIST;

ICONLIST iconList[]={
	{ IDC_RADIO_ICON1,	IDI_ICON1, 16, 16, },
	{ IDC_RADIO_ICON2,  IDI_ICON1, 32, 32, },
	{ IDC_RADIO_ICON3,	IDI_ICON2, 16, 16, },
	{ IDC_RADIO_ICON4,  IDI_ICON2, 32, 32, },
};
HWND MainCreateWindow(HINSTANCE hInst, HWND hwndOwner, LPSTR lpstrClass, LPVOID lpVoid)
{
	HWND hwnd;
	hwnd = CreateDialogParam(hInst, 
							 g_szClass, 
							 hwndOwner, 
							 NULL, 
							 (LPARAM)lpVoid);
	if(!hwnd) {
		return (HWND)NULL;
	}
	UpdateWindow(hwnd);
	return hwnd;
}

#define ArrayCount(a)	(sizeof(a)/sizeof(a[0]))
#define MAX(a, b)		( a > b ? a : b)
#define IDC_EXBID	4096
LRESULT CALLBACK MainWndProc(HWND	hwnd,
							 UINT	uMsg,
							 WPARAM	wParam,
							 LPARAM	lParam)
{
	PAINTSTRUCT ps;
	HDC hDC;
	RECT rc;
	static INT iIndex;
	switch(uMsg) {
	case WM_CREATE:
		{
			HWND hwndEXB = EXButton_CreateWindow(g_hInst, hwnd, EXBS_TEXT,
												 IDC_EXBID,
												 20,
												 30, 
												 35,
												 18);
			EXButton_SetText(hwndEXB, L"J^");
		}
		SetTimer(hwnd, 0x9999, 50, NULL);
		return 1;
	case WM_TIMER:
		{
			KillTimer(hwnd, wParam);
			INT i;
			for(i = 0; i < sizeof(iconList)/sizeof(iconList[0]); i++) {
				HICON hIcon = LoadImage(g_hInst,
										MAKEINTRESOURCE(iconList[i].lParam),
										IMAGE_ICON, 
										iconList[i].width,
										iconList[i].height,
										LR_DEFAULTCOLOR);
				SendMessage(GetDlgItem(hwnd, iconList[i].wID),
							BM_SETIMAGE,
							(WPARAM)IMAGE_ICON,
							(LPARAM)hIcon);
			}
		}
		break;
	case WM_SYSCOMMAND:
		if(wParam == SC_CLOSE) {
			PostQuitMessage(0);
		}
		break;
	case WM_COMMAND:
		{
			WORD wNotifyCode = HIWORD(wParam); // notification code 
			WORD wID		 = LOWORD(wParam);         // item, control, or accelerator identifier 
			HWND hwndCtl	 = (HWND) lParam;      // handle of control 
			HWND hwndEXB	 = (HWND) GetDlgItem(hwnd, IDC_EXBID);
			switch(wID) {
			case IDC_EXBID:
				{
					switch(wNotifyCode) {
					case EXBN_CLICKED:
						DBG(("EXBN_CLICKED come\n"));
						break;
					case EXBN_DOUBLECLICKED:
						DBG(("EXBN_DOUBLECLICKED come\n"));
						break;
					case EXBN_ARMED:
						DBG(("EXBN_ARMED come\n"));
						EXButton_SetText(hwndEXB, L"Ђ");
						break;
					case EXBN_DISARMED: 
						DBG(("EXBN_DISARMED come\n"));
						EXButton_SetText(hwndEXB, L"J^");
						break;
					default:
						DBG(("ERROR Unknown Notify\n"));
						break;
					}
				}
				break;
				break;
			case IDC_SETTEXT:
				{
					EXButton_SetText(hwndEXB, GetWText(hwnd, IDC_EDIT_SETTEXT));
				}
				break;
			case IDC_SETICON:
				{
					INT i;
					for(i = 0; i < sizeof(iconList)/sizeof(iconList[0]); i++) {
						if(Button_GetCheck(GetDlgItem(hwnd, iconList[i].wID))) {
							HICON hIcon = LoadImage(g_hInst,
													MAKEINTRESOURCE(iconList[i].lParam),
													IMAGE_ICON, 
													iconList[i].width,
													iconList[i].height,
													LR_DEFAULTCOLOR);
							EXButton_SetIcon(hwndEXB, hIcon);
						}
					}
				}
				break;
			case IDC_SETCHECK_TRUE:
				EXButton_SetCheck(hwndEXB, TRUE);
				break;
			case IDC_SETCHECK_FALSE:
				EXButton_SetCheck(hwndEXB, FALSE);
				break;
			case IDC_SETSTYLE:
				{
					INT i;
					DWORD dwStyle = 0;
					for(i = 0; i < sizeof(slist)/sizeof(slist[0]); i++) {
						INT ret = Button_GetCheck(GetDlgItem(hwnd, slist[i].wID));
						if(ret) {
							dwStyle |= slist[i].lParam;
						}
					}
					EXButton_SetStyle(hwndEXB, dwStyle);
				}
				break;
			case IDC_ENABLE_TRUE:
				EnableWindow(hwndEXB, TRUE);
				break;
			case IDC_ENABLE_FALSE:
				EnableWindow(hwndEXB, FALSE);
				break;
			}

		}
		break;
	case WM_PAINT:
		hDC = BeginPaint(hwnd, &ps);
		GetClientRect(hwnd, &rc);
		FillRect(hDC, &rc, (HBRUSH)(COLOR_3DFACE + 1));
		EndPaint(hwnd, &ps);
		break;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int WINAPI WinMain(HINSTANCE hInstance,
				   HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine,
				   int nCmdShow)
{

	MSG msg;
	HWND hwnd;
//	INT ret;
	
	g_hInst = hInstance;
	WNDCLASSEX  wc;
	ZeroMemory(&wc, sizeof(wc));

	wc.cbSize			= sizeof(wc);
	wc.style			= CS_HREDRAW | CS_VREDRAW;	 /* Class style(s). */
	wc.lpfnWndProc		= (WNDPROC)MainWndProc;
	wc.cbClsExtra		= 0;					/* No per-class extra data.*/
	wc.cbWndExtra		= DLGWINDOWEXTRA;		/* No per-window extra data.		  */
	wc.hInstance		= hInstance;			/* Application that owns the class.	  */
	wc.hIcon			= NULL; //LoadIcon(hInstance, MAKEINTRESOURCE(SCROLL32_ICON));
	wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1); //UGetStockObject(LTGRAY_BRUSH); //WHITE_BRUSH); 
	wc.lpszMenuName		= NULL; //g_szClass;    /* Name of menu resource in .RC file. */
	wc.lpszClassName	= g_szClass;	  /* Name used in call to CreateWindow. */
	wc.hIconSm = NULL;
	RegisterClassEx(&wc);

	hwnd = CreateDialog(hInstance, 
						g_szClass, 
						0, 
						NULL);

	UpdateWindow(hwnd); 
	ShowWindow(hwnd, SW_SHOW);
	while (GetMessage(&msg, NULL, 0, 0)){
		TranslateMessage(&msg);
		DispatchMessage(&msg); 
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\accplv.cpp ===
//=======================================================================
//		File:	ACCPLV.CPP
//=======================================================================
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "winapi.h"

#include <ole2.h>
//#include <initguid.h>
// 98/07/28 kwada
// Some ids are defined in oleacc.h
// Instances of them are in oleacc.dll. 
// Initguid is needed because oleacc.lib is not linked.
// To avoid conflict of instanciation of those guid,
// initguid appears only once in the application.
//#include "../msaa/inc32/oleacc.h"
//#include "../msaa/inc32/winable.h"
//980112 ToshiaK: VC6 has these include files.
#include <oleacc.h>
#include <winable.h>

#include "accplv.h"
#include "plv.h"
#include "plv_.h"
#include "plvproc.h"
#include "dbg.h"
#include "strutil.h"
//#include "repview.h"
//#include "iconview.h"
#include "rvmisc.h"
#include "ivmisc.h"

CAccPLV::CAccPLV()
{
    m_hWnd = NULL;
    m_pTypeInfo = NULL;
    m_pDefAccessible = NULL;
}

CAccPLV::~CAccPLV( void )
{
    if ( m_pTypeInfo )
    {
        m_pTypeInfo->Release();
        m_pTypeInfo = NULL;
    }

    if ( m_pDefAccessible )
    {
        m_pDefAccessible->Release();
        m_pDefAccessible = NULL;
    }
	
}

void *
CAccPLV::operator new(size_t size){
	return MemAlloc(size);
}

void
CAccPLV::operator delete(void *ptr){
	if(ptr)
		MemFree(ptr);
}

HRESULT CAccPLV::Initialize(HWND hWnd)
{
	HRESULT		hr;
	ITypeLib *	piTypeLib;

	m_hWnd = hWnd;
	m_lpPlv = GetPlvDataFromHWND(hWnd);

	if(!PLV_IsMSAAAvailable(m_lpPlv))
		return E_FAIL;

	hr = PLV_CreateStdAccessibleObject(m_lpPlv,
									   hWnd,
									   OBJID_CLIENT,
									   IID_IAccessible,
									   (void **) &m_pDefAccessible);

	if (FAILED( hr ))
		return hr;

	//-----------------------------------------------------
    //	Obtain an ITypeInfo pointer to our type library.
	//	  The ITypeInfo pointer is used to implement the
	//	  IDispatch interface.
	//-----------------------------------------------------

	//-----------------------------------------------------
	//	First, attempt to load the Accessibility type
	//	  library version 1.0 using the registry.
	//-----------------------------------------------------

    hr = LoadRegTypeLib( LIBID_Accessibility, 1, 0, 0, &piTypeLib );

	//-----------------------------------------------------
	//	If we fail to load the type library from the
	//	  registry information, explicitly try to load
	//	  it from the MSAA system DLL.
	//-----------------------------------------------------

    if ( FAILED( hr ) )
    {
        static OLECHAR szOleAcc[] = L"OLEACC.DLL";
        hr = LoadTypeLib( szOleAcc, &piTypeLib );
    }

	//-----------------------------------------------------
	//	If we successfully load the type library, attempt
	//	  to get the IAccessible type description
	//	  (ITypeInfo pointer) from the type library.
	//-----------------------------------------------------

    if ( SUCCEEDED( hr ) )
    {
        hr = piTypeLib->GetTypeInfoOfGuid( IID_IAccessible, &m_pTypeInfo );
        piTypeLib->Release();
    }

	return hr;
}

//-----------------------------------------------------------------------
//	CAccPLV::QueryInterface()
// ----------------------------------------------------------------------

STDMETHODIMP CAccPLV::QueryInterface( REFIID riid, void** ppv )
{
    *ppv = NULL;
	
	//-----------------------------------------------------
	//	If the IUnknown, IDispatch, or IAccessible
	//	  interface is desired, simply cast the this
	//	  pointer appropriately.
	//-----------------------------------------------------

	if ( riid == IID_IUnknown )
        *ppv = (LPUNKNOWN) this;

	else if ( riid == IID_IDispatch )
        *ppv = (IDispatch *) this;

	else if ( riid == IID_IAccessible )
        *ppv = (IAccessible *)this;

	//-----------------------------------------------------
	//	If the IEnumVARIANT interface is desired, create
	//	  a new VARIANT enumerator which contains all
	//	  the Accessible object's children.
	//-----------------------------------------------------
#ifdef NOTIMPLEMENTED
	else if (riid == IID_IEnumVARIANT)
	{
		return m_pDefAccessible->QueryInterface(riid, ppv);
		//?? AddRef();
	}
#endif
	//-----------------------------------------------------
	//	If the desired interface isn't one we know about,
	//	  return E_NOINTERFACE.
	//-----------------------------------------------------

    else
        return E_NOINTERFACE;


	//-----------------------------------------------------
	//	Increase the reference count of any interface
	//	  returned.
	//-----------------------------------------------------

    ((LPUNKNOWN) *ppv)->AddRef();


    return S_OK;
}


//-----------------------------------------------------------------------
//	CAccPLV::AddRef()
//  CAccPLV::Release()
//	NOTES:
//
//		The lifetime of the Accessible object is governed by the
//		lifetime of the HWND object for which it provides
//		Accessibility.  The object is created in response to the
//		first WM_GETOBJECT message that the server application
//		is ready to process and is destroyed when the server's
//		main window is destroyed.  Since the object's lifetime
//		is not dependent on a reference count, the object has no
//		internal mechanism for tracking reference counting and
//		AddRef() and Release() always return one.
//
//-----------------------------------------------------------------------

STDMETHODIMP_(ULONG) CAccPLV::AddRef( void )
{
	return 1L;
}

STDMETHODIMP_(ULONG) CAccPLV::Release( void )
{
	return 1L;
}

//-----------------------------------------------------------------------
//	CAccPLV::GetTypeInfoCount()
//
//	DESCRIPTION:
//
//		Implements the IDispatch interface method GetTypeInfoCount().
//
//		Retrieves the number of type information interfaces that an
//		object provides (either 0 or 1).
//
//	PARAMETERS:
//
//		pctInfo		[out] Points to location that receives the
//							number of type information interfaces
//							that the object provides. If the object
//							provides type information, this number
//							is set to 1; otherwise it's set to 0.
//
//	RETURNS:
//
//		HRESULT			  S_OK if the function succeeds or 
//							E_INVALIDARG if pctInfo is invalid.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::GetTypeInfoCount( UINT *pctInfo )
{
    if ( !pctInfo )
        return E_INVALIDARG;

    *pctInfo = ( m_pTypeInfo == NULL ? 1 : 0 );

    return S_OK;
}

//-----------------------------------------------------------------------
//	CAccPLV:GetTypeInfo()
//
//	DESCRIPTION:
//
//		Implements the IDispatch interface method GetTypeInfo().
//
//		Retrieves a type information object, which can be used to
//		get the type information for an interface.
//
//	PARAMETERS:
//
//		itinfo		[in]  The type information to return. If this value
//							is 0, the type information for the IDispatch
//							implementation is to be retrieved.
//
//		lcid		[in]  The locale ID for the type information.
//
//		ppITypeInfo	[out] Receives a pointer to the type information
//							object requested.
//
//	RETURNS:
//
//		HRESULT			  S_OK if the function succeeded (the TypeInfo
//							element exists), TYPE_E_ELEMENTNOTFOUND if
//							itinfo is not equal to zero, or 
//							E_INVALIDARG if ppITypeInfo is invalid.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo )
{
    if ( !ppITypeInfo )
        return E_INVALIDARG;

    *ppITypeInfo = NULL;

    if ( itinfo != 0 )
        return TYPE_E_ELEMENTNOTFOUND;
    else if ( m_pTypeInfo == NULL )
        return E_NOTIMPL;

    *ppITypeInfo = m_pTypeInfo;
    m_pTypeInfo->AddRef();

    return S_OK;
	UNREFERENCED_PARAMETER(lcid);
}

//-----------------------------------------------------------------------
//	CAccPLV::GetIDsOfNames()
//
//	DESCRIPTION:
//
//		Implements the IDispatch interface method GetIDsOfNames().
//
//		Maps a single member and an optional set of argument names
//		to a corresponding set of integer DISPIDs, which may be used
//		on subsequent calls to IDispatch::Invoke.
//
//	NOTES:
//
//		This method simply delegates the call to
//		ITypeInfo::GetIDsOfNames().
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::GetIDsOfNames( REFIID riid, OLECHAR ** rgszNames, UINT cNames,
                                        LCID lcid, DISPID * rgdispid )
{
    if ( m_pTypeInfo == NULL )
        return E_NOTIMPL;

    return( m_pTypeInfo->GetIDsOfNames( rgszNames, cNames, rgdispid ) );
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(lcid);
}

//-----------------------------------------------------------------------
//	CAccPLV::Invoke()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::Invoke( DISPID dispid,
                                 REFIID riid,
                                 LCID lcid,
                                 WORD wFlags,
                                 DISPPARAMS * pdispparams,
                                 VARIANT *pvarResult,
                                 EXCEPINFO *pexcepinfo,
                                 UINT *puArgErr )
{
    if ( m_pTypeInfo == NULL )
        return E_NOTIMPL;

    return m_pTypeInfo->Invoke( (IAccessible *)this,
                                dispid,
                                wFlags,
                                pdispparams,
                                pvarResult,
                                pexcepinfo,
                                puArgErr );
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(lcid);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accParent()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accParent( IDispatch ** ppdispParent )
{
	return m_pDefAccessible->get_accParent( ppdispParent );
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accChildCount()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accChildCount( long* pChildCount )
{
	if(!PLV_IsMSAAAvailable(m_lpPlv))
		return E_FAIL;
    if ( !pChildCount )
        return E_INVALIDARG;

	if(m_lpPlv->dwStyle == PLVSTYLE_ICON) // iconview
		*pChildCount = m_lpPlv->iItemCount;
	else
		*pChildCount = (m_lpPlv->iItemCount + 1) * RV_GetColumn(m_lpPlv); // include header

	return S_OK;
}


//-----------------------------------------------------------------------
//	CAccPLV::get_accChild()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accChild( VARIANT varChild, IDispatch ** ppdispChild )
{
    if ( !ppdispChild )
        return E_INVALIDARG;


	*ppdispChild = NULL;
    return S_FALSE;
	UNREFERENCED_PARAMETER(varChild);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accName()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accName().
//
//		Retrieve the name property for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszName			[out] Pointer to the BSTR that will contain
//								the child's name property string.
//-----------------------------------------------------------------------
#define BUFLEN 128
STDMETHODIMP CAccPLV::get_accName( VARIANT varChild, BSTR* pszName )
{
    if (!pszName)
        return E_INVALIDARG;

	*pszName = NULL;

	if ( varChild.lVal == CHILDID_SELF )
		//return m_pDefAccessible->get_accName(varChild,pszName);
		return S_OK;
	
	
	if(m_lpPlv->dwStyle == PLVSTYLE_ICON) {
		PLVITEM plvItem;
		m_lpPlv->lpfnPlvIconItemCallback(m_lpPlv->iconItemCallbacklParam, 
										 varChild.lVal - 1,
										 &plvItem);
		*pszName = SysAllocString(plvItem.lpwstr);
	}
	else {
		static TCHAR	szString[BUFLEN];
		static OLECHAR	wszString[BUFLEN];
   
		static INT nCol,index,colIndex;
		nCol = RV_GetColumn(m_lpPlv);
		if (nCol < 1)
			return E_FAIL;
		index = (varChild.lVal - 1) / nCol;
		colIndex = (varChild.lVal - 1) % nCol;

		if(!index) { // Header
			if(IsWindowUnicode(m_lpPlv->hwndHeader)){
				static HD_ITEMW hdItem;
				hdItem.mask = HDI_TEXT;
				hdItem.fmt  = HDF_STRING;
				hdItem.pszText = wszString;
				hdItem.cchTextMax = BUFLEN;
				SendMessageW(m_lpPlv->hwndHeader, HDM_GETITEMW, (WPARAM)colIndex, (LPARAM)&hdItem);
				*pszName = SysAllocString(hdItem.pszText);
			}
			else{
				static HD_ITEMA hdItem;
				hdItem.mask = HDI_TEXT;
				hdItem.fmt  = HDF_STRING;
				hdItem.pszText = szString;
				hdItem.cchTextMax = BUFLEN;

				SendMessageA(m_lpPlv->hwndHeader, HDM_GETITEMA, (WPARAM)colIndex, (LPARAM)&hdItem);

				MultiByteToWideChar(m_lpPlv->codePage,MB_PRECOMPOSED,hdItem.pszText,-1,
									wszString,hdItem.cchTextMax);
				*pszName = SysAllocString(wszString);
			}
		}
		else { // item
			LPPLVITEM lpPlvItemList = (LPPLVITEM)MemAlloc(sizeof(PLVITEM)*nCol);
			if(!lpPlvItemList)
				return E_FAIL;

			ZeroMemory(lpPlvItemList, sizeof(PLVITEM)*nCol);
			m_lpPlv->lpfnPlvRepItemCallback(m_lpPlv->repItemCallbacklParam, 
											index-1, // line index
											nCol,  //column Count.
											lpPlvItemList);

			*pszName = SysAllocString(lpPlvItemList[colIndex].lpwstr);
			MemFree(lpPlvItemList);
		}
	}

	return S_OK;
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accValue()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accValue().
//
//		Retrieves the value property for the specified child.
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accValue( VARIANT varChild, BSTR* pszValue )
{
    if (!pszValue)
        return E_INVALIDARG;
	
	return m_pDefAccessible->get_accValue(varChild,pszValue);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accDescription()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accDescription().
//
//		Retrieves the description property for the specified child.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accDescription( VARIANT varChild, BSTR* pszDesc )
{
    if (!pszDesc)
		return E_INVALIDARG;

	return m_pDefAccessible->get_accDescription(varChild,pszDesc);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accRole()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accRole().
//
//		Retrieves the role property for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pVarRole		[out] Pointer to the VARIANT structure that
//								will contain the specified child's
//								role property.  This property may
//								either be in the form of a standard
//								role constant or a custom description
//								string.
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accRole( VARIANT varChild, VARIANT * pVarRole )
{
    if (!pVarRole)
		return E_INVALIDARG;

	if ( varChild.lVal == CHILDID_SELF )
		return m_pDefAccessible->get_accRole( varChild, pVarRole );

	pVarRole->vt = VT_I4;

	pVarRole->lVal = ROLE_SYSTEM_CLIENT;
	return S_OK;

}

//-----------------------------------------------------------------------
//	CAccPLV::get_accState()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accState().
//		Retrieves the current state for the specified object or child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pVarState		[out] Pointer to the VARIANT structure that
//								will contain information describing
//								the specified child's current state.
//								This information may either be in the
//								form of one or more object state
//								constants or a custom description
//								string.
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accState( VARIANT varChild, VARIANT * pVarState )
{
	if(!PLV_IsMSAAAvailable(m_lpPlv))
		return E_FAIL;

	if (!pVarState)
		return E_INVALIDARG;

	if ( varChild.lVal == CHILDID_SELF )
		return m_pDefAccessible->get_accState(varChild,pVarState);

	pVarState->vt = VT_I4;

	if(m_lpPlv->dwStyle == PLVSTYLE_ICON) // iconview
		pVarState->lVal = STATE_SYSTEM_SELECTABLE;
	else { // report view
		static INT nCol,index,colIndex;
		nCol = RV_GetColumn(m_lpPlv);
		if (nCol < 1)
			return E_FAIL;
		
		index = (varChild.lVal - 1) / nCol;
		colIndex = (varChild.lVal - 1) % nCol;
		if(index){
			if(colIndex)
				pVarState->lVal = STATE_SYSTEM_READONLY;
			else // item
				pVarState->lVal = STATE_SYSTEM_SELECTABLE;
		}
		else{ // header
			pVarState->lVal = STATE_SYSTEM_READONLY;
		}
	}
		
	return S_OK;
	UNREFERENCED_PARAMETER(varChild);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accHelp()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accHelp().
//
//		Retrieves the help property string for the specified child.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszHelp			[out] Pointer to the BSTR that will contain
//								the child's help property string.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accHelp( VARIANT varChild, BSTR* pszHelp )
{
    if (!pszHelp)
		return E_INVALIDARG;
	return m_pDefAccessible->get_accHelp( varChild, pszHelp );
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accHelpTopic()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accHelpTopic().
//
//		Retrieves the fully qualified path name of the help file
//		associated with the specified object, as well as a pointer
//		to the appropriate topic with in that file.
//
//	PARAMETERS:
//
//		pszHelpFile		[out] Pointer to the BSTR that will contain
//								the fully qualified path name of the
//								help file associated with the child.
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pidTopic		[out] Pointer to the value identifying the
//								help file topic associated with the
//								object.
//
//	RETURNS:
//
//		HRESULT			DISP_E_MEMBERNOTFOUND because the help topic
//						  property is not supported for the Accessible
//						  object or any of its children.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accHelpTopic( BSTR* pszHelpFile, VARIANT varChild, long* pidTopic )
{
	//-----------------------------------------------------
	//	The help topic property is not supported for
	//	  either the Accessible object or any of its
	//	  children.
	//-----------------------------------------------------
	//return m_pDefAccessible->get_accHelpTopic(pszHelpFile,varChild,pidTopic);
	return DISP_E_MEMBERNOTFOUND;
	UNREFERENCED_PARAMETER(pszHelpFile);
	UNREFERENCED_PARAMETER(varChild);
	UNREFERENCED_PARAMETER(pidTopic);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accKeyboardShortcut()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method
//		get_accKeyboardShortcut().
//
//		Retrieves the specified object's keyboard shortcut property.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child to be retrieved.  Since
//								CAccPLV only supports child IDs,
//								the vt member of this structure must
//								equal VT_I4.
//
//		pszShortcut		[out] Pointer to the BSTR that will contain
//								the keyboard shortcut string, or NULL
//								if no keyboard shortcut is associated
//								with this item.
//
//
//	RETURNS:
//
//		HRESULT			DISP_E_MEMBERNOTFOUND because the keyboard
//						  shortcut property is not supported for the
//						  Accessible object or any of its children.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accKeyboardShortcut( VARIANT varChild, BSTR* pszShortcut )
{
	//-----------------------------------------------------
	//	The keyboard shortcut property is not supported
	//	  for either the Accessible object or any of its
	//	  children.  So, set pszShortcut to NULL and
	//	  return DISP_E_MEMBERNOTFOUND.
	//-----------------------------------------------------
	if(!pszShortcut)
		return E_INVALIDARG;
	return m_pDefAccessible->get_accKeyboardShortcut(varChild,pszShortcut);
#ifdef REF				
	pszShortcut = NULL;
    return DISP_E_MEMBERNOTFOUND;
#endif
}




//-----------------------------------------------------------------------
//	CAccPLV::get_accFocus()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accFocus().
//
//		Retrieves the child object that currently has the input focus.
//		Only one object or item within a container can have the current
//		focus at any one time.
//
//	PARAMETERS:
//
//		pVarFocus		[out] Pointer to the VARIANT structure that
//								will contain information describing
//								the specified child's current state.
//								This information may either be in the
//								form of one or more object state
//								constants or a custom description
//								string.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the pVarFocus parameter is
//						  invalid or S_OK.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accFocus( VARIANT * pVarFocus )
{
    if ( !pVarFocus )
        return E_INVALIDARG;

	return m_pDefAccessible->get_accFocus(pVarFocus);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accSelection()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accSelection().
//
//		Retrieves the selected children of this object.
//
//	PARAMETERS:
//
//		pVarSel  		[out] Pointer to the VARIANT structure that
//								will be filled with information about
//								the selected child object or objects.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the pVarSel parameter is
//						  invalid or S_OK.
//
//	NOTES:
//
//		Refer to the MSAA SDK documentation for a full description
//		of this method and the possible settings of pVarSel.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accSelection( VARIANT * pVarSel )
{
    if ( !pVarSel )
        return E_INVALIDARG;
	return m_pDefAccessible->get_accSelection(pVarSel);
}

//-----------------------------------------------------------------------
//	CAccPLV::get_accDefaultAction()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method get_accDefaultAction().
//
//		Retrieves a string containing a localized, human-readable sentence
//		that describes the object's default action.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose default action string is
//								to be retrieved.  Since CAccPLV
//								only supports child IDs, the vt member
//								of this structure must equal VT_I4.
//
//		pszDefAct		[out] Pointer to the BSTR that will contain
//								the child's default action string,
//								or NULL if there is no default action
//								for this object.
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::get_accDefaultAction( VARIANT varChild, BSTR* pszDefAct )
{
	if (!pszDefAct)
        return E_INVALIDARG;
	return m_pDefAccessible->get_accDefaultAction(varChild, pszDefAct);
}

//-----------------------------------------------------------------------
//	CAccPLV::accDoDefaultAction()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accDoDefaultAction().
//
//		Performs the object's default action.
//
//	PARAMETERS:
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose default action will be
//								invoked.  Since CAccPLV only
//								supports child IDs, the vt member of
//								this structure must equal VT_I4.
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::accDoDefaultAction( VARIANT varChild )
{
	//if ( varChild.lVal == CHILDID_SELF )
	return m_pDefAccessible->accDoDefaultAction( varChild );
}

//-----------------------------------------------------------------------
//	CAccPLV::accSelect()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::accSelect( long flagsSel, VARIANT varChild )
{
	return m_pDefAccessible->accSelect(flagsSel, varChild);
}

//-----------------------------------------------------------------------
//	CAccPLV::accLocation()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accLocation().
//
//		Retrieves the specified child's current screen location in
//		screen coordinates.
//
//	PARAMETERS:
//
//		pxLeft			[out] Address of the child's left most
//								boundary.
//
//		pyTop			[out] Address of the child's upper most
//								boundary.
//
//		pcxWid			[out] Address of the child's width.
//
//		pcyHt			[out] Address of the child's height.
//
//		varChild		[in]  VARIANT structure that identifies the
//								child whose screen location is to be
//								retrieved.  Since CAccPLV only
//								supports child IDs, the vt member
//								of this structure must equal VT_I4.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if any of the parameters
//						  are invalid, E_UNEXPECTED if we are for
//						  some reason unable to determine the
//						  window rect of the button or status bar,
//						  S_OK if the screen coordinates of the
//						  child are successfully determined, or
//						  the return value from the standard client
//						  window implementation of accLocation().
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::accLocation( long* pxLeft,
                                      long* pyTop,
                                      long* pcxWid,
                                      long* pcyHt,
                                      VARIANT varChild )
{
    if (!pxLeft || !pyTop || !pcxWid || !pcyHt)
        return E_INVALIDARG;

	if ( varChild.lVal == CHILDID_SELF )
		return m_pDefAccessible->accLocation( pxLeft, pyTop, pcxWid, pcyHt, varChild );
	
	*pxLeft = *pyTop = *pcxWid = *pcyHt = 0;

	static INT index,colIndex,nCol;
	static POINT pt;

	if(m_lpPlv->dwStyle == PLVSTYLE_ICON) {
		*pcxWid  = IV_GetItemWidth(m_hWnd);
		*pcyHt = IV_GetItemHeight(m_hWnd);

		index = varChild.lVal - 1;
		nCol = IV_GetCol(m_hWnd);
		pt.x = IV_GetXMargin(m_hWnd) + *pcxWid  * (index % nCol);
		pt.y = IV_GetYMargin(m_hWnd) + *pcyHt * (index / nCol);
		ClientToScreen(m_hWnd,&pt);
		*pxLeft = pt.x;
		*pyTop = pt.y;
		return S_OK;
	}
	else {
		nCol = RV_GetColumn(m_lpPlv);
		if (nCol < 1)
			return E_FAIL;
			
		index = (varChild.lVal - 1) / nCol;
		colIndex = (varChild.lVal - 1) % nCol;

		if(!index){ //header
			*pcyHt = RV_GetHeaderHeight(m_lpPlv);
			pt.y = RV_GetYMargin(m_hWnd);
		}
		else{
			*pcyHt = RV_GetItemHeight(m_hWnd);
			pt.y = RV_GetYMargin(m_hWnd) + RV_GetHeaderHeight(m_lpPlv)
				   + ((index - 1) - m_lpPlv->iCurTopIndex) * (*pcyHt);
		}
		
		static HD_ITEM hdItem;
		hdItem.mask = HDI_WIDTH;
		hdItem.fmt = 0;
		Header_GetItem(m_lpPlv->hwndHeader,colIndex,&hdItem);
		*pcxWid = hdItem.cxy;

		pt.x = 0;
		for(int i = 0;i<colIndex;i++){
			Header_GetItem(m_lpPlv->hwndHeader,i,&hdItem);
			pt.x += hdItem.cxy;
		}

		ClientToScreen(m_hWnd,&pt);
		*pxLeft = pt.x;
		*pyTop = pt.y;
		return S_OK;
	}
}


//-----------------------------------------------------------------------
//	CAccPLV::accNavigate()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::accNavigate( long navDir, VARIANT varStart, VARIANT* pVarEndUpAt )
{
	return m_pDefAccessible->accNavigate( navDir, varStart, pVarEndUpAt );
}

//-----------------------------------------------------------------------
//	CAccPLV::accHitTest()
//
//	DESCRIPTION:
//
//		Implements the IAccessible interface method accHitTest().
//
//		Retrieves the ID of the a child at a given point on the screen.
//
//	PARAMETERS:
//
//		xLeft and yTop	[in]  The screen coordinates of the point
//								to be hit tested.
//
//		pVarHit			[out] Pointer to the VARIANT structure that
//								will contain information describing
//								the hit child.  If the vt member is
//								VT_I4, then the lVal member is a child
//								ID.  If the vt member is VT_EMPTY,
//								then the navigation failed.
//
//	RETURNS:
//
//		HRESULT			E_INVALIDARG if the pVarHit parameter is
//						  invalid, or S_OK.
//
//	NOTES:
//
//		Since the CAccPLV object has no child objects (only child
//		elements), pVarHit will never be a pointer to a IDispatch
//		interface of a child object.
//
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::accHitTest( long xLeft, long yTop, VARIANT* pVarHit )
{
	if(!PLV_IsMSAAAvailable(m_lpPlv))
		return E_FAIL;

	if ( !pVarHit )
		return E_INVALIDARG;


	static POINT	pt;
	static RECT		rc;
	static INT		index,nCol;
	static PLVINFO	plvInfo;
	static HD_ITEM	hdItem;
	
	pt.x = xLeft;
	pt.y = yTop;
	ScreenToClient(m_hWnd,&pt);
	GetClientRect(m_hWnd, &rc );

	if (PtInRect( &rc, pt )) {
		pVarHit->vt = VT_I4;
		pVarHit->lVal = CHILDID_SELF;
#ifdef OLD
		if(m_lpPlv->dwStyle == PLVSTYLE_ICON) // iconview
			index = IV_GetInfoFromPoint(m_lpPlv, pt, &plvInfo);
		else { // report view
			nCol = RV_GetColumn(m_lpPlv);
			index = RV_GetInfoFromPoint(m_lpPlv, pt, &plvInfo);
			if(index < 0) {
				if(pt.y > RV_GetHeaderHeight(m_lpPlv)) // out of header
					return m_pDefAccessible->accHitTest(xLeft, yTop, pVarHit);

				 // header
				INT wid = 0;
				hdItem.mask = HDI_WIDTH;
				hdItem.fmt = 0;
				for(index = 0;index<nCol;index++){
					Header_GetItem(m_lpPlv->hwndHeader,index,&hdItem);
					wid += hdItem.cxy;
					if(pt.x <= wid)
						break;
				}
			}
			else
				index = (index + 1) * nCol + plvInfo.colIndex;
		}
		pVarHit->lVal = index + 1; // 1 origin
#else // new
		pVarHit->lVal = PLV_ChildIDFromPoint(m_lpPlv,pt);

		if(pVarHit->lVal < 0)
			return m_pDefAccessible->accHitTest(xLeft, yTop, pVarHit);
#endif 
		return S_OK;
	}

	return m_pDefAccessible->accHitTest(xLeft, yTop, pVarHit);
}



//-----------------------------------------------------------------------
//	CAccPLV::put_accName()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::put_accName( VARIANT varChild, BSTR szName )
{
	//-----------------------------------------------------
	//	We don't allow clients to change the name
	//	  property of any child so we simply return
	//	  S_FALSE.
	//-----------------------------------------------------
    return S_FALSE;
	UNREFERENCED_PARAMETER(varChild);
	UNREFERENCED_PARAMETER(szName);
}

//-----------------------------------------------------------------------
//	CAccPLV::put_accValue()
//-----------------------------------------------------------------------

STDMETHODIMP CAccPLV::put_accValue( VARIANT varChild, BSTR szValue )
{
	//-----------------------------------------------------
	//	We don't allow clients to change the value
	//	  property of the status bar (the only child that
	//	  has a value property) so we simply return S_FALSE.
	//-----------------------------------------------------
	return S_FALSE;
	UNREFERENCED_PARAMETER(varChild);
	UNREFERENCED_PARAMETER(szValue);
}

//-----------------------------------------------------------------------
//	CAccPLV::LresultFromObject()
//
//	DESCRIPTION:
//
//		call ::LresultFromObject()
//
//	PARAMETERS:
//
//		wParam			[in]  wParam of WM_GETOBJECT message
//
//-----------------------------------------------------------------------
LRESULT CAccPLV::LresultFromObject(WPARAM wParam)
{
	if(!PLV_IsMSAAAvailable(m_lpPlv))
		return E_FAIL;
	return PLV_LresultFromObject(m_lpPlv,IID_IAccessible,wParam,(IAccessible *)this);
}

//----  End of ACCPLV.CPP  ----
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\accplv.h ===
#ifndef __ACCPLV_H
#define __ACCPLV_H

#include <windows.h>

#include <ole2.h>
//980112 ToshiaK: VC6 has these include files.
//#include "../msaa/inc32/oleacc.h"
//#include "../msaa/inc32/winable.h"
#include <oleacc.h>
#include <winable.h>
//#include "enumvar.h"

#include "plv_.h"

class CAccPLV : public IAccessible
{
public:
	//--------------------------------
	//	IUnknown interface methods
	//--------------------------------

	STDMETHODIMP			QueryInterface( REFIID riid, void** ppv );
	STDMETHODIMP_(ULONG)	AddRef( void );
	STDMETHODIMP_(ULONG)	Release( void );


	//--------------------------------
	//	IDispatch interface methods
	//--------------------------------

	STDMETHODIMP		GetTypeInfoCount( UINT* pctinfo );
	STDMETHODIMP		GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo** pptinfo );
	STDMETHODIMP		GetIDsOfNames( REFIID riid,
						               OLECHAR** rgszNames,
						               UINT cNames,
						               LCID lcid,
						               DISPID* rgdispid );
	STDMETHODIMP		Invoke( DISPID dispidMember,
						        REFIID riid,
						        LCID lcid,
						        WORD wFlags,
						        DISPPARAMS* pdispparams,
						        VARIANT* pvarResult,
						        EXCEPINFO* pexcepinfo,
						        UINT* puArgErr );


	//--------------------------------
	//	IAccessible interface methods
	//--------------------------------

	STDMETHODIMP		get_accParent( IDispatch ** ppdispParent );
	STDMETHODIMP		get_accChildCount( long* pChildCount );
	STDMETHODIMP		get_accChild( VARIANT varChild,
						              IDispatch ** ppdispChild );
	STDMETHODIMP		get_accName( VARIANT varChild, BSTR* pszName );
	STDMETHODIMP		get_accValue( VARIANT varChild, BSTR* pszValue );
	STDMETHODIMP		get_accDescription( VARIANT varChild,
						                    BSTR* pszDescription );
	STDMETHODIMP		get_accRole( VARIANT varChild, VARIANT *pvarRole );
	STDMETHODIMP		get_accState( VARIANT varChild, VARIANT *pvarState );
	STDMETHODIMP		get_accHelp( VARIANT varChild, BSTR* pszHelp );
	STDMETHODIMP		get_accHelpTopic( BSTR* pszHelpFile,
						                  VARIANT varChild,
						                  long* pidTopic );
	STDMETHODIMP		get_accKeyboardShortcut( VARIANT varChild,
						                         BSTR* pszKeyboardShortcut );
	STDMETHODIMP		get_accFocus( VARIANT * pvarFocusChild );
	STDMETHODIMP		get_accSelection( VARIANT * pvarSelectedChildren );
	STDMETHODIMP		get_accDefaultAction( VARIANT varChild,
						                      BSTR* pszDefaultAction );
	STDMETHODIMP		accSelect( long flagsSel, VARIANT varChild );
	STDMETHODIMP		accLocation( long* pxLt,
						             long* pyTp,
									 long* pcxWd,
									 long* pcyHt,
									 VARIANT varChild );
	STDMETHODIMP		accNavigate( long navDir,
						             VARIANT varStart,
									 VARIANT * pVarEndUpAt );
	STDMETHODIMP		accHitTest( long xLeft,
						            long yTop,
									VARIANT * pvarChildAtPoint );
	STDMETHODIMP		accDoDefaultAction( VARIANT varChild );
	STDMETHODIMP		put_accName( VARIANT varChild, BSTR szName );
	STDMETHODIMP		put_accValue( VARIANT varChild, BSTR pszValue );


	//--------------------------------
	//	Constructors and Destructors
	//--------------------------------

	CAccPLV( void );
	~CAccPLV( void );
	
	void *operator new(size_t);
	void operator delete(void*);

	HRESULT				Initialize(HWND hwnd);
	LRESULT				LresultFromObject(WPARAM wParam);
protected:
	IAccessible *	m_pDefAccessible;
	ITypeInfo *		m_pTypeInfo;
	HWND			m_hWnd;
	LPPLVDATA		m_lpPlv;
};

#endif  /* __ACCKYLV_H */



//----  End of ACCKYLV.H  ----
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\dbg.cpp ===
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <stdarg.h>
#include "dbg.h"

static VOID DbgSetWinTextA(LPSTR lpstr);
static VOID DbgSetWinTextW(LPWSTR lpwstr);

#define PRINT_STRW	//OutputDebugStringW
#define PRINT_STRA	//OutputDebugStringA

//-------------------------------------------------------
//Global String buffer
//-------------------------------------------------------
static WCHAR g_wchBuf[1024];
static CHAR  g_chBuf[1024];

static LPSTR GetFileTitleStrA(LPSTR lpstrFile)
{
	static CHAR tchJunk64[64];
	GetFileTitleA(lpstrFile, tchJunk64, sizeof(tchJunk64));	
	return tchJunk64;
}

static LPWSTR GetFileTitleStrW(LPWSTR lpstrFile)
{
	static WCHAR tchJunk64[64];
	GetFileTitleW(lpstrFile, tchJunk64, sizeof(tchJunk64));	
	return tchJunk64;
}


////////////////////////////////////////////////////////
// Function : _plvDbgMBA
// Type     : VOID
// Purpose  : Popup Debug MessageBox
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstrMsg 
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
VOID _plvDbgMBA(LPSTR	lpstrFile, 
			   INT		lineNo, 
			   LPSTR	lpstrMsg)
{
	wsprintfA(g_chBuf, 
			  "%s(%d)%s", 
			  GetFileTitleStrA(lpstrFile),
			  lineNo,
			  lpstrMsg);
	MessageBoxA(NULL, 
				g_chBuf, 
				"#### IMEPAD ERROR MESSAGE #####",
				MB_ICONERROR | MB_OK | MB_APPLMODAL);
	return;
}

VOID _plvDbgMBW(LPWSTR	lpstrFile, 
			   INT		lineNo, 
			   LPWSTR	lpstrMsg)
{
	wsprintfW(g_wchBuf, 
			 L"%s(%d)%s", 
			 GetFileTitleStrW(lpstrFile),			 
			 lineNo,
			 lpstrMsg);
	MessageBoxW(NULL, 
				lpstrFile, 
				L"#### ERROR #####",
				MB_OK | MB_APPLMODAL);
	return;
}


////////////////////////////////////////////////////////
// Function : _plvDbgVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _plvDbgVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfW(wchBuf, lpstrFmt, ap);
	va_end(ap);
	return wchBuf;
}

LPSTR _plvDbgVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(chBuf, lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function: _plvDbgPrint
// Type    : VOID
// Purpose : variable args version of OutputDebugString
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _plvDbgPrintA(LPSTR lpstrFmt, ...)
{
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(g_chBuf, lpstrFmt, ap);
	va_end(ap);
	PRINT_STRA(g_chBuf);
	DbgSetWinTextA(g_chBuf);
	return;
}

VOID _plvDbgPrintW(LPWSTR lpstrFmt, ...)
{
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfW(g_wchBuf, lpstrFmt, ap);
	va_end(ap);
	PRINT_STRW(g_wchBuf);
	DbgSetWinTextW(g_wchBuf);
	return;
}

////////////////////////////////////////////////////////
// Function: _plvDbg
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _plvDbgA(LPSTR		lpstrFile, 
		   INT		lineNo, 
		   LPSTR		lpstrMsg
)
{
	_plvDbgPrintA("(%s:%d) %s", 
			   GetFileTitleStrA(lpstrFile),
			   lineNo,
			   lpstrMsg);
	return;
}

VOID _plvDbgW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg
)
{
	_plvDbgPrintW(L"(%s:%d) %s", 
			   GetFileTitleStrW(lpstrFile),
			   lineNo,
			   lpstrMsg);

	return;
}

LPWSTR _plvDbgMulti2Wide(LPSTR lpstr)
{
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)g_wchBuf, sizeof(g_wchBuf)/sizeof(WCHAR) );
	return g_wchBuf;
}

#define ID_EDITWIN		0x40
#define ID_BTN_CLEAR	0x41
static HWND g_hwndDbg;
static VOID DbgSetWinTextA(LPSTR lpstr)
{
	HWND hwndEdit;
	INT len; 
	if(!g_hwndDbg)  {
		return; 
	}
	if(!lpstr) {
		return;
	}
	hwndEdit = GetDlgItem(g_hwndDbg, ID_EDITWIN);
	if(!hwndEdit) {
		return;
	}
	len = lstrlen(lpstr);
	if(lpstr[len-1] == '\n') {
		lpstr[len-1] = '\r';
		lpstr[len]='\n'; //lpstr is static enough size buffer's pointer.
		lpstr[len+1]=0x00;
	}
	Edit_SetSel(hwndEdit, (WPARAM)-2, (LPARAM)-2);
	Edit_ReplaceSel(hwndEdit, lpstr);
	return; 
}

static VOID DbgSetWinTextW(LPWSTR lpwstr)
{
	static CHAR szStr[512];
	WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK,
						lpwstr, -1, 
						szStr,
						sizeof(szStr),
						NULL, NULL);
	DbgSetWinTextA(szStr);
}

VOID _plvDbgAssert(LPCTSTR		fileName,
					INT			line,
					BOOL		flag,
					LPCTSTR		pszExp)
{
	if(!flag) {
		wsprintf(g_chBuf, "  Assertion Faled %s(%d) %s\n",
				 GetFileTitleStrA((CHAR *)fileName),
				 line,
				 pszExp != (LPCTSTR)NULL ? pszExp : "");
		PRINT_STRA(g_chBuf);
		DebugBreak();
	}
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\dbg.h ===
//////////////////////////////////////////////////////////////////
// File     : dbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef _DBG_H_
#define _DBG_H_

#define	MemAlloc(a)		GlobalAlloc(GMEM_FIXED, (a))
#define MemFree(a)		GlobalFree((a))

//-------------------------------------------------------
//MACRO function(?) prototype declare
//-------------------------------------------------------
////////////////////////////////////////////////////////
// Function	: DBG
// Type		: VOID
// Purpose	: Printing ANSI debug message with same usage as printf()
//			: 
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//		   : ...	
// CAUTION: Please use DOUBLE Blaket!!!
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

////////////////////////////////////////////////////////
// Function	: DBGMB
// Type		: VOID
// Purpose	: Show Messagebox for ANSI debug message 
//			: Same usage as printf()
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBGMB((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function	: DBGShowWindow
// Type		: VOID
// Purpose	: Invoke debug message window.
//			: DBG(), DBGW()'s message is shown here.
// Args		: HINSTANCE	hInst
//		    : HWND		hwndOwner
/////////////////////////////////////////////////////////
//VOID DBGShowWindow(HINSTANCE hInst, HWND hwndOwner);




#ifdef _DEBUG
extern VOID _plvDbgShowWindow(HINSTANCE hInst, HWND hwndOwner);
#ifndef UNICODE_ONLY
extern VOID  _plvDbgA		 (LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
extern VOID  _plvDbgPrintA (LPSTR lpstrMsg, ...);
extern LPSTR _plvDbgVaStrA (LPSTR lpstrFmt, ...);
extern LPWSTR _plvDbgMulti2Wide(LPSTR lpstr);
extern VOID _plvDbgMBA(LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
extern VOID _plvDbgMBW(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID _dbg_Assert(LPCTSTR		fileName,
						INT			line,
						BOOL			flag,
						LPCTSTR		pszExp);

#endif

#ifndef ANSI_ONLY
extern VOID   _plvDbgW(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _plvDbgPrintW(LPWSTR lpstrMsg, ...);
extern LPWSTR _plvDbgVaStrW(LPWSTR lpstrFmt, ...);
#endif
#endif

#if defined(_DEBUG) || (defined(_NDEBUG) && defined(_RELDEBUG))
#	define DBGShowWindow(a,b)	_plvDbgShowWindow(a,b);
#	define DBGW(a)				_plvDbgW( _plvDbgMulti2Wide(__FILE__), __LINE__, _plvDbgVaStrW a)
#	define DBGA(a)				_plvDbgA(__FILE__, __LINE__, _plvDbgVaStrA a)
#	define Dbg(a)				_plvDbgA(__FILE__, __LINE__, _plvDbgVaStrA a)
#	define DBGMB(a)				_plvDbgMBA(__FILE__, __LINE__, _plvDbgVaStrA a)
#	define DBGMBA(a)			_plvDbgMBA(__FILE__, __LINE__, _plvDbgVaStrA a)
#	define DBGMBW(a)			_plvDbgMBW(_plvDbgMulti2Wide(__FILE__), __LINE__, _plvDbgVaStrW a)
#	define DBGASSERT(a)			_plvDbgAssert(__FILE__, __LINE__, a, #a);
#	define DBGASSERTDO(a)		_plvDbgAssert(__FILE__, __LINE__, a, #a);
#else //!_DEBUG	//in Release version, these are disapear...
#	define DBGShowWindow(a,b)
#	define DBGW(a)	
#	define DBGA(a)		
#	define Dbg(a)
#	define DBGMB(a)
#	define DBGMBA(a)
#	define DBGMBW(a)
#	define DBGASSERT(a)
#	define DBGASSERTDO(a)		(a)
#endif //_DEBUG

//extern VOID  _plvDbgA		 (LPSTR lpstrFile, INT lineNo, LPSTR lpstrMsg);
//extern VOID  _plvDbgPrintA (LPSTR lpstrMsg, ...);
//extern LPSTR _plvDbgVaStrA (LPSTR lpstrFmt, ...);
#define DP(a) //_plvDbgA(__FILE__, __LINE__, _plvDbgVaStrA a)
#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\iconview.h ===
#ifndef _ICON_VIEW_H_
#define _ICON_VIEW_H_
/* iconview.cpp */
extern INT IconView_RestoreScrollPos(LPPLVDATA lpPlvData);
extern INT IconView_ResetScrollRange(LPPLVDATA lpPlvData);
extern INT IconView_SetItemCount(LPPLVDATA lpPlvData, INT itemCount, BOOL fDraw);
extern INT IconView_SetTopIndex(LPPLVDATA lpPlvData, INT indexTop);
extern INT IconView_SetCurSel(LPPLVDATA lpPlvData, INT index);
extern INT IconView_Paint(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT IconView_ButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT IconView_ButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT IconView_MouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT IconView_VScroll(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT IconView_GetWidthByColumn(LPPLVDATA lpPlv, INT col);
extern INT IconView_GetHeightByRow(LPPLVDATA lpPlv, INT row);
#endif //_ICON_VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\dispatch.h ===
/* dispatch.c */
#ifndef _DISPATCH_H_
#define _DISPATCH_H_

typedef LRESULT (*PFNMSG)(HWND, UINT, WPARAM, LPARAM);
typedef LRESULT (*PFNCMD)(HWND, WORD, WORD, HWND);

typedef enum{
   edwpNone,            // Do not call any default procedure.
   edwpWindow,          // Call DefWindowProc.
   edwpDialog,          // Call DefDlgProc (This should be used only for
                        // custom dialogs - standard dialog use edwpNone).
   edwpMDIChild,        // Call DefMDIChildProc.
   edwpMDIFrame         // Call DefFrameProc.
} EDWP;                // Enumeration for Default Window Procedures

typedef struct _MSD{
    UINT   uMessage;
    PFNMSG pfnmsg;
} MSD;                 // MeSsage Dispatch structure

typedef struct _MSDI{
    int  cmsd;          // Number of message dispatch structs in rgmsd
    MSD *rgmsd;         // Table of message dispatch structures
    EDWP edwp;          // Type of default window handler needed.
} MSDI, FAR *LPMSDI;   // MeSsage Dipatch Information

typedef struct _CMD{
    WORD   wCommand;
    PFNCMD pfncmd;
} CMD;                 // CoMmand Dispatch structure

typedef struct _CMDI{
    int  ccmd;          // Number of command dispatch structs in rgcmd
    CMD *rgcmd;         // Table of command dispatch structures
    EDWP edwp;          // Type of default window handler needed.
} CMDI, FAR *LPCMDI;   // CoMmand Dispatch Information

LRESULT DispMessage(LPMSDI lpmsdi, HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam);
LRESULT DispCommand(LPCMDI lpcmdi, HWND hwnd, WPARAM wparam, LPARAM lparam);
LRESULT DispDefault(EDWP edwp, HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam);

#endif // _DISPATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\dispatch.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "dispatch.h"


LRESULT DispMessage(LPMSDI lpmsdi, 
                    HWND   hwnd, 
                    UINT   uMessage, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    int  imsd = 0;

    MSD *rgmsd = lpmsdi->rgmsd;
    int  cmsd  = lpmsdi->cmsd;

    for (imsd = 0; imsd < cmsd; imsd++)
    {
        if (rgmsd[imsd].uMessage == uMessage)
            return rgmsd[imsd].pfnmsg(hwnd, uMessage, wparam, lparam);
    }

    return DispDefault(lpmsdi->edwp, hwnd, uMessage, wparam, lparam);
}

////////////////////////////////////////////////////////////////
// Function : DispCommand
// Type     :  LRESULT
// Purpose  : 
//          : 
// Argument : 
//          : LPCMDI lpcmdi 
//          : HWND hwnd 
//          : WPARAM wparam 
//          : LPARAM lparam 
// Return   :
// AUTHOR   : gƗ(ToshiaK)
// START DATE: 
// HISTORY  : 
// 
/////////////////////////////////////////////////////////////////
LRESULT DispCommand(LPCMDI lpcmdi, 
                    HWND   hwnd, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    //LRESULT lRet = 0;
    WORD    wCommand = GET_WM_COMMAND_ID(wparam, lparam);
    int     icmd;

    CMD    *rgcmd = lpcmdi->rgcmd;
    int     ccmd  = lpcmdi->ccmd;

    // Message packing of wparam and lparam have changed for Win32,
    // so use the GET_WM_COMMAND macro to unpack the commnad

    for (icmd = 0; icmd < ccmd; icmd++)
    {
        if (rgcmd[icmd].wCommand == wCommand)
        {
            return rgcmd[icmd].pfncmd(hwnd,
                                      wCommand,
                                      GET_WM_COMMAND_CMD(wparam, lparam),
                                      GET_WM_COMMAND_HWND(wparam, lparam));
        }
    }

    return DispDefault(lpcmdi->edwp, hwnd, WM_COMMAND, wparam, lparam);
}


////////////////////////////////////////////////////////////////
// Function : DispDefault
// Type     :  LRESULT
// Purpose  : 
//          : 
// Argument : 
//          : EDWP edwp 
//          : HWND hwnd 
//          : UINT uMessage 
//          : WPARAM wparam 
//          : LPARAM lparam 
// Return   :
// AUTHOR   : gƗ(ToshiaK)
// START DATE: 
// HISTORY  : 
// 
/////////////////////////////////////////////////////////////////
#define hwndMDIClient NULL
LRESULT DispDefault(EDWP   edwp, 
                    HWND   hwnd, 
                    UINT   uMessage, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    switch (edwp)
    {
        case edwpNone:
            return 0;
        case edwpWindow:
            return DefWindowProc(hwnd, uMessage, wparam, lparam);
        case edwpDialog:
            return DefDlgProc(hwnd, uMessage, wparam, lparam);
#ifndef UNDER_CE // Windows CE does not support MDI func
        case edwpMDIFrame:
            return DefFrameProc(hwnd, hwndMDIClient, uMessage, wparam, lparam);
        case edwpMDIChild:
            return DefMDIChildProc(hwnd, uMessage, wparam, lparam);
#endif // UNDER_CE
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\ivmisc.h ===
#ifndef _IV_MISC_H_
#define _IV_MISC_H_
/* ivmisc.cpp */
extern INT RECT_GetWidth(LPRECT lpRc);
extern INT RECT_GetHeight(LPRECT lpRc);
extern INT IV_GetItemWidth(HWND hwnd);
extern INT IV_GetItemHeight(HWND hwnd);
extern INT IV_GetXMargin(HWND hwnd);
extern INT IV_GetYMargin(HWND hwnd);
extern INT IV_GetDispWidth(HWND hwnd);
extern INT IV_GetDispHeight(HWND hwnd);
extern INT IV_GetWidth(HWND hwnd);
extern INT IV_GetHeight(HWND hwnd);
extern INT IV_GetRow(HWND hwnd);
extern INT IV_GetCol(HWND hwnd);
extern INT IV_GetRowColumn(HWND hwnd, INT *pRow, INT *pCol);
extern INT IV_GetMaxLine(HWND hwnd);
extern INT IV_GetInfoFromPoint(LPPLVDATA lpPlvData, POINT pt, LPPLVINFO lpPlvInfo);
extern INT IV_GetCurScrollPos(HWND hwnd);
extern INT IV_SetCurScrollPos(HWND hwnd, INT nPos);
extern INT IV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos);
extern INT IV_GetScrollTrackPos(HWND hwnd);
#endif //_IV_MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\ivmisc.cpp ===
//////////////////////////////////////////////////////////////////
// File     : ivmisc.cpp
// Purpose  : PadListView control's ICON View function.
//			: Name is ICON View but it does not use ICON
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "plv_.h"
#include "plv.h"
#include "dbg.h"
#include "ivmisc.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

inline INT RECT_GetWidth(LPRECT lpRc)
{
	return lpRc->right - lpRc->left;
}

inline INT RECT_GetHeight(LPRECT lpRc)
{
	return lpRc->bottom - lpRc->top;
}

INT IV_GetItemWidth(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nItemWidth;
}

INT IV_GetItemHeight(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nItemHeight;
}


INT IV_GetXMargin(HWND hwnd)
{
	//return XMARGIN;
	return 0;
	Unref(hwnd);
}

INT IV_GetYMargin(HWND hwnd)
{
	//return YMARGIN;
	return 0;
	Unref(hwnd);
}

INT IV_GetDispWidth(HWND hwnd)
{
	return IV_GetWidth(hwnd) - IV_GetXMargin(hwnd)*2;
}

INT IV_GetDispHeight(HWND hwnd)
{
	return IV_GetHeight(hwnd) - IV_GetYMargin(hwnd)*2;
}

INT IV_GetWidth(HWND hwnd)
{
	RECT rc;
	GetClientRect(hwnd, &rc);
	return RECT_GetWidth(&rc);
}

INT IV_GetHeight(HWND hwnd)
{
	RECT rc;
	GetClientRect(hwnd, &rc);
	return RECT_GetHeight(&rc);
}

INT IV_GetRow(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);

	return IV_GetDispHeight(hwnd)/lpPlv->nItemHeight;
}

INT IV_GetCol(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return IV_GetDispWidth(hwnd) / lpPlv->nItemWidth;
}

INT IV_GetRowColumn(HWND hwnd, INT *pRow, INT *pCol)
{
	*pRow = IV_GetRow(hwnd);
	*pCol = IV_GetCol(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : IV_GetMaxLine
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IV_GetMaxLine(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	INT nCol = IV_GetCol(hwnd);
	if(nCol <= 0) {
		return 0;
	} 
	if(lpPlv->iItemCount > 0) {
		return (lpPlv->iItemCount - 1)/nCol + 1;
	}
	else {
		return 0;
	}
}

//////////////////////////////////////////////////////////////////
// Function : IV_IndexFromPoint
// Type     : INT
// Purpose  : Get item index from PadListView point
// Args     : 
//          : LPPLVDATA lpPlvData 
//          : POINT pt // position of pad listview client.
// Return   : return pt's item index. if -1 error.
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IV_GetInfoFromPoint(LPPLVDATA lpPlvData, POINT pt, LPPLVINFO lpPlvInfo)
{
	INT nRow = IV_GetRow(lpPlvData->hwndSelf);
	INT nCol = IV_GetCol(lpPlvData->hwndSelf);
	if(nCol <= 0) {
		return -1;
	}
	INT nMetricsCount;
	nMetricsCount = (nRow+1) * nCol;
	INT i, j;
	INT x, y;
	RECT rcChar, rc;

	INT nItemWidth  = IV_GetItemWidth(lpPlvData->hwndSelf);
	INT nItemHeight = IV_GetItemHeight(lpPlvData->hwndSelf);

	GetClientRect(lpPlvData->hwndSelf, &rc);
	for(i = 0, j = lpPlvData->iCurIconTopIndex; 
		i < nMetricsCount && j < lpPlvData->iItemCount;
		i++, j++) {
		x = IV_GetXMargin(lpPlvData->hwndSelf) + nItemWidth  * (i % nCol);
		y = IV_GetYMargin(lpPlvData->hwndSelf) + nItemHeight * (i / nCol);
		rcChar.left  = rc.left + x;
		rcChar.top   = rc.top  + y;
		rcChar.right = rcChar.left + nItemWidth;
		rcChar.bottom= rcChar.top  + nItemHeight;
		if(PtInRect(&rcChar, pt)) {
			if(lpPlvInfo) {
				ZeroMemory(lpPlvInfo, sizeof(PLVINFO));
				lpPlvInfo->code  = 0; // don't know at this time.
				lpPlvInfo->index = j;
				lpPlvInfo->pt	 = pt;
				lpPlvInfo->itemRect = rcChar;
			}
			return j;
		}
	}
	return -1;
}

//////////////////////////////////////////////////////////////////
// Function : IV_GetCurScrollPos
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 970707 to use icon original pos (nCurIconScrollPos)
//////////////////////////////////////////////////////////////////
INT IV_GetCurScrollPos(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nCurIconScrollPos;
}

INT IV_SetCurScrollPos(HWND hwnd, INT nPos)
{
	static SCROLLINFO scrInfo;
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);

	INT nRow = IV_GetRow(hwnd);
	INT nCol = IV_GetCol(hwnd);
	INT nMax = IV_GetMaxLine(hwnd);

	Dbg(("nPos[%d] nRow[%d] nCol[%d] nMax[%d]\n", nPos, nRow, nCol, nMax));
	lpPlv->nCurIconScrollPos = nPos;

	//----------------------------------------------------------------
	//important:
	//calc new cur top index
	//----------------------------------------------------------------
	lpPlv->iCurIconTopIndex = nCol * nPos; //changed 970707
	
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= 0;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nRow;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;


	//In normal case,  
	//if (scrInfo.nMax - scrInfo.nMin + 1) <= scrInfo.nPage, 
	// scroll bar is hidden. to prevent it,
	// in this case, set proper page, and DISABLE scrollbar.
	// Now we can show scroll bar always
	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	//970810 toshiak. send scrolled notify.
	static PLVINFO plvInfo;
	ZeroMemory(&plvInfo, sizeof(plvInfo));
	plvInfo.code = PLVN_VSCROLLED;
	SendMessage(GetParent(lpPlv->hwndSelf), 
				lpPlv->uMsg,
				(WPARAM)0,
				(LPARAM)&plvInfo);
	return nPos;
}

INT IV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= nMin;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nPage;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	return 0;
} 

INT IV_GetScrollTrackPos(HWND hwnd)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_ALL;
	GetScrollInfo(hwnd, SB_VERT, &scrInfo);
	return scrInfo.nTrackPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\iconview.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "plv_.h"
#include "plv.h"
#include "dbg.h"
#include "iconview.h"
#include "ivmisc.h"
#include "exgdiw.h"
#include "exres.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

static POSVERSIONINFO ExGetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

static BOOL ExIsWinNT(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
	return fBool;
}

#define IV_EDGET_NONE		0
#define IV_EDGET_RAISED		1
#define IV_EDGET_SUNKEN		2


//////////////////////////////////////////////////////////////////
// Function : RepView_RestoreScrollPos
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IconView_RestoreScrollPos(LPPLVDATA lpPlvData)
{
	return IV_SetCurScrollPos(lpPlvData->hwndSelf, lpPlvData->nCurIconScrollPos);
}

//////////////////////////////////////////////////////////////////
// Function : IconView_ResetScrollRange
// Type     : INT
// Purpose  : Reset scroll bar's range,
//			: if PadListView size was changed.
// Args     : 
//          : LPPLVDATA lpPlvData 
// Return   : 
// DATE     : 970829
//////////////////////////////////////////////////////////////////
INT IconView_ResetScrollRange(LPPLVDATA lpPlvData)
{
	static SCROLLINFO scrInfo;

	HWND hwnd = lpPlvData->hwndSelf;

	INT nRow = IV_GetRow(hwnd);
	INT nCol = IV_GetCol(hwnd);
	INT nMax = IV_GetMaxLine(hwnd);
	INT nPos = lpPlvData->nCurIconScrollPos;

	//----------------------------------------------------------------
	//important:
	//calc new cur top index
	//----------------------------------------------------------------
	lpPlvData->iCurIconTopIndex = nCol * nPos; //changed 970707

	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= 0;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nRow;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	//In normal case,  
	//if (scrInfo.nMax - scrInfo.nMin + 1) <= scrInfo.nPage, 
	// scroll bar is hidden. to prevent it,
	// in this case, set proper page, and DISABLE scrollbar.
	// Now we can show scroll bar always
	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : IconView_SetItemCount
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
//          : INT itemCount 
//          : BOOL fDraw		update scroll bar or not
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IconView_SetItemCount(LPPLVDATA lpPlvData, INT itemCount, BOOL fDraw)
{
	//Dbg(("IconView_SetItemCount [%d]\n", itemCount));
	lpPlvData->iItemCount	     = itemCount;
	lpPlvData->nCurIconScrollPos = 0;	//970707 ToshiaK, same as iCurTopIndex
	lpPlvData->iCurIconTopIndex  = 0;	//970707 ToshiaK, same as iCurTopIndex

	if(fDraw) {
		INT nMaxLine = IV_GetMaxLine(lpPlvData->hwndSelf);
		INT nPage	 = IV_GetRow(lpPlvData->hwndSelf);
		IV_SetScrollInfo(lpPlvData->hwndSelf, 0, nMaxLine, nPage, 0);
	}
	return 0;
}

INT IconView_SetTopIndex(LPPLVDATA lpPlvData, INT indexTop)
{
	INT nCol = IV_GetCol(lpPlvData->hwndSelf); 
	if(nCol <=0) {
		Dbg(("Internal ERROR Colmn 0\n"));
		return 0;
	}
	if(indexTop < lpPlvData->iItemCount) {
		lpPlvData->iCurIconTopIndex = (indexTop/nCol) * nCol;
		
		IV_SetCurScrollPos(lpPlvData->hwndSelf,
						   lpPlvData->iCurIconTopIndex/nCol);
		InvalidateRect(lpPlvData->hwndSelf, NULL, TRUE);
		UpdateWindow(lpPlvData->hwndSelf);
		return indexTop;
	}
	else {
		Dbg(("Internal ERROR\n"));
		return -1;
	}
}

INT IconView_Paint(HWND hwnd, WPARAM wParam, LPARAM lParam)
{

	static PAINTSTRUCT ps;
	static RECT		rc;
	static HBRUSH		hBrush;
	static HDC			hDCMem;
	static HDC			hDC;
	static HBITMAP		hBitmap, hBitmapPrev;
	static DWORD		dwOldTextColor, dwOldBkColor;
	static INT			i, j;

	//Dbg(("IconView_Paint START\n"));
	hDC = BeginPaint(hwnd, &ps);

	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	GetClientRect(hwnd, &rc);

	hDCMem		= CreateCompatibleDC(hDC);
	hBitmap		= CreateCompatibleBitmap(hDC, rc.right - rc.left, rc.bottom-rc.top);
	hBitmapPrev = (HBITMAP)SelectObject(hDCMem, hBitmap);

	//----------------------------------------------------------------
	//971111: #2586
	//----------------------------------------------------------------
	//hBrush         = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
	//dwOldBkColor   = SetBkColor(hDCMem, GetSysColor(COLOR_3DFACE));
	hBrush         = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
	dwOldBkColor   = SetBkColor(hDCMem, GetSysColor(COLOR_WINDOW));
	dwOldTextColor = SetTextColor(hDCMem, GetSysColor(COLOR_WINDOWTEXT));

	FillRect(hDCMem, &rc, hBrush);

	INT nRow = IV_GetRow(hwnd);
	INT nCol = IV_GetCol(hwnd);
	INT nMetricsCount;
	nMetricsCount = (nRow+1) * nCol;
	INT x, y;
	RECT rcChar;

	HFONT hFontOld = NULL;
	if(lpPlvData->hFontIcon) {
		hFontOld = (HFONT)SelectObject(hDCMem, lpPlvData->hFontIcon);
	}


	INT nItemWidth  = IV_GetItemWidth(hwnd);
	INT nItemHeight = IV_GetItemHeight(hwnd);
	INT iCurIconTopIndex;
	//----------------------------------------------------------------
	//error no call back exists
	if(!lpPlvData->lpfnPlvIconItemCallback) {
		Dbg(("Call back does not exists\n"));
		goto LError;
	}
	if(nCol <=0 ){
		Dbg(("Column count is less than zero\n"));
		goto LError;
	}
	//Dbg(("Call back exist\n"));
	static PLVITEM plvItemTmp, plvItem;
	POINT pt;
#ifndef UNDER_CE // Windows CE does not support GetCursorPos.
	GetCursorPos(&pt);
	ScreenToClient(hwnd, &pt);
#else // UNDER_CE
	if(lpPlvData->iCapture != CAPTURE_NONE){
		pt.x = lpPlvData->ptCapture.x;
		pt.y = lpPlvData->ptCapture.y;
	}
	else{
		// set outer client point
		pt.x = -1;
		pt.y = -1;
	}
#endif // UNDER_CE
	//Dbg(("iCurIconTopIndex [%d]\n", lpPlvData->iCurIconTopIndex));
	//Dbg(("iItemCount   [%d]\n", lpPlvData->iItemCount));

	//----------------------------------------------------------------
	//970707 toshiak changed.
	//iCurIconTopIndex shold be a muliple of nCol; 
	//----------------------------------------------------------------
	iCurIconTopIndex = (lpPlvData->iCurIconTopIndex / nCol) * nCol;

	for(i = 0, j = iCurIconTopIndex;
		i < nMetricsCount && j < lpPlvData->iItemCount;
		i++, j++) {
		x = IV_GetXMargin(hwnd) + nItemWidth  * (i % nCol);
		y = IV_GetYMargin(hwnd) + nItemHeight * (i / nCol);
		rcChar.left  = rc.left + x;
		rcChar.top   = rc.top  + y;
		rcChar.right = rcChar.left + nItemWidth;
		rcChar.bottom= rcChar.top  + nItemHeight;
		if(rcChar.top > rc.bottom) {
			break;
		}
		plvItem = plvItemTmp;
		lpPlvData->lpfnPlvIconItemCallback(lpPlvData->iconItemCallbacklParam, 
										   j, 
										   &plvItem);
		if(plvItem.lpwstr) {
			INT edgeFlag;
			if(lpPlvData->iCapture == CAPTURE_LBUTTON) {
				if(PtInRect(&rcChar, lpPlvData->ptCapture) &&
				   PtInRect(&rcChar, pt)) {
					edgeFlag = IV_EDGET_SUNKEN;
				}
				else {
					edgeFlag = IV_EDGET_NONE;
				}
			}
			else {
				if(PtInRect(&rcChar, pt)) {
					edgeFlag = IV_EDGET_RAISED;
				}
				else {
					edgeFlag = IV_EDGET_NONE;
				}
			}
			INT sunken = 0;
			switch(edgeFlag) {
			case IV_EDGET_SUNKEN:
				sunken = 1;
				DrawEdge(hDCMem, &rcChar, EDGE_SUNKEN, BF_SOFT | BF_RECT);
				break;
			case IV_EDGET_RAISED:
				sunken = 0;
				DrawEdge(hDCMem, &rcChar, EDGE_RAISED, BF_SOFT | BF_RECT);
				break;
			case IV_EDGET_NONE:
			default:
				break;
			}
			SIZE size;

			if(ExGetTextExtentPoint32W(hDCMem, plvItem.lpwstr, 1, &size)) {
				ExExtTextOutW(hDCMem, 
							  rcChar.left + (nItemWidth  - size.cx)/2 + sunken,
							  rcChar.top  + (nItemHeight - size.cy)/2 + sunken,
							  ETO_CLIPPED,
							  &rcChar,
							  plvItem.lpwstr,
							  1,
							  NULL);
			}
		}
	}

 LError:
	if(hFontOld){
		SelectObject(hDCMem, hFontOld);
	}
	// LIZHANG: if there is no items, draw the explanation text
	if ( !lpPlvData->iItemCount && (lpPlvData->lpText || lpPlvData->lpwText ))
	{
		HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
		HFONT hOldFont = (HFONT)SelectObject( hDCMem, hFont );
		RECT rcTmp = rc;
		rcTmp.left = 20;
		rcTmp.top = 20;
		rcTmp.right -= 10;
		rcTmp.bottom -= 10;

		//COLORREF colOld = SetTextColor( hDCMem, GetSysColor(COLOR_WINDOW) );
		//COLORREF colBkOld = SetBkColor( hDCMem, GetSysColor(COLOR_3DFACE) );
		COLORREF colOld = SetTextColor( hDCMem, GetSysColor(COLOR_WINDOWTEXT));
		COLORREF colBkOld = SetBkColor( hDCMem, GetSysColor(COLOR_WINDOW) );
#ifndef UNDER_CE // always Unicode
		if(ExIsWinNT()) {
			if(lpPlvData->lpwText) {
				DrawTextW(hDCMem,
						 lpPlvData->lpwText,
						 lstrlenW(lpPlvData->lpwText),
						 &rcTmp,
						 DT_VCENTER|DT_WORDBREAK ); 
			}
		}
		else {
			DrawText( hDCMem,
					 lpPlvData->lpText,
					 lstrlen(lpPlvData->lpText),
					 &rcTmp,
					 DT_VCENTER|DT_WORDBREAK ); 
		}
#else // UNDER_CE
		if(lpPlvData->lpwText) {
			DrawTextW(hDCMem,
					 lpPlvData->lpwText,
					 lstrlenW(lpPlvData->lpwText),
					 &rcTmp,
					 DT_VCENTER|DT_WORDBREAK ); 
		}
#endif // UNDER_CE
		SetTextColor( hDCMem, colOld );
		SetBkColor( hDCMem, colBkOld );
		SelectObject( hDCMem, hOldFont );
	}

	BitBlt(hDC, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
		   hDCMem, 0, 0, SRCCOPY);

	DeleteObject(hBrush);
	SetBkColor(hDCMem, dwOldBkColor);
	SetTextColor(hDCMem, dwOldTextColor);
	SelectObject(hDCMem, hBitmapPrev );

	DeleteObject(hBitmap);
	DeleteDC( hDCMem );

	EndPaint(hwnd, &ps);
	return 0;
	Unref3(hwnd, wParam, lParam);
}

INT IconView_ButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData)  {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	switch(uMsg) {
	case WM_LBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	case WM_MBUTTONDBLCLK:
	case WM_RBUTTONDBLCLK:
		SetCapture(hwnd);
#ifdef UNDER_CE // LBUTTON + ALT key handling
		//Standard way for RBUTTON handling is combination w/ LBUTTON + ALT key
		if(uMsg == WM_LBUTTONDOWN && GetAsyncKeyState(VK_MENU)){
			uMsg = WM_RBUTTONDOWN;
		}
#endif // UNDER_CE
		switch(uMsg) {
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_LBUTTON;
			break;
		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_MBUTTON;
			break;
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_RBUTTON;
			break;
		}
#ifndef UNDER_CE // Windows CE does not support GetCursorPos.
		GetCursorPos(&lpPlvData->ptCapture);
		//remember left button down place
		ScreenToClient(hwnd, &lpPlvData->ptCapture);
#else // UNDER_CE
		lpPlvData->ptCapture.x = (SHORT)LOWORD(lParam);
		lpPlvData->ptCapture.y = (SHORT)HIWORD(lParam);
#endif // UNDER_CE
		switch(uMsg) {
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			InvalidateRect(hwnd, NULL, FALSE);
			break;
		}
#ifdef UNDER_CE // Windows CE used ButtonDown Event for ToolTip
		if(lpPlvData->uMsg != 0) {
			if(uMsg == WM_LBUTTONDOWN) {
				PLVINFO plvInfo;
				INT index = IV_GetInfoFromPoint(lpPlvData,
												lpPlvData->ptCapture,
												&plvInfo);
				plvInfo.code = PLVN_ITEMDOWN;
				SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
			}
		}
#endif // UNDER_CE
		break;
	}
	return 0;
	Unref2(wParam, lParam);
}

INT IconView_ButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	static POINT pt;
	static PLVINFO plvInfo;
	static INT	index, downIndex;
	if(!lpPlvData)  {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	switch(uMsg) {
	case WM_MBUTTONUP:
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
		Dbg(("WM_LBUTTONUP COMES\n"));
#ifdef UNDER_CE // LBUTTON + ALT key handling
		//Standard way for RBUTTON handling is combination w/ LBUTTON + ALT key
		if(uMsg == WM_LBUTTONUP && GetAsyncKeyState(VK_MENU)){
			uMsg = WM_RBUTTONUP;
		}
#endif // UNDER_CE

		InvalidateRect(hwnd, NULL, FALSE);
		pt.x = LOWORD(lParam);
		pt.y = HIWORD(lParam);
#if 0
		Dbg(("x %d, y %d\n", pt.x, pt.y));
		Dbg(("capture x[%d] y[%d] \n",
			 lpPlvData->ptCapture.x,
			 lpPlvData->ptCapture.y));
#endif
		downIndex = IV_GetInfoFromPoint(lpPlvData, lpPlvData->ptCapture, NULL);
		index = IV_GetInfoFromPoint(lpPlvData, pt, &plvInfo);
		ReleaseCapture();
#if 0
		Dbg(("mouse down index [%d]\n", downIndex));
		Dbg(("mouse up   index [%d]\n", index));
#endif
		if(index != -1) {
			Dbg(("code  [%d]\n", plvInfo.code));
			Dbg(("index [%d]\n", plvInfo.index));
			Dbg(("left[%d] top[%d] right[%d] bottom[%d] \n",
				 plvInfo.itemRect.left,
				 plvInfo.itemRect.top,
				 plvInfo.itemRect.right,
				 plvInfo.itemRect.bottom));
			if(index == downIndex) {
				if(lpPlvData->uMsg != 0) {
					if(uMsg == WM_LBUTTONUP) {
						plvInfo.code = PLVN_ITEMCLICKED;
						SendMessage(GetParent(hwnd), lpPlvData->uMsg, index, (LPARAM)&plvInfo);
					}
					else if(uMsg == WM_RBUTTONUP) {
						plvInfo.code = PLVN_R_ITEMCLICKED;
						SendMessage(GetParent(hwnd), lpPlvData->uMsg, index, (LPARAM)&plvInfo);
					}
				}
			}
		}
#ifdef UNDER_CE // Windows CE used ButtonUp Event for ToolTip
		if(lpPlvData->uMsg != 0) {
			if(uMsg == WM_LBUTTONUP) {
				PLVINFO plvInfo;
				INT index = IV_GetInfoFromPoint(lpPlvData,
												lpPlvData->ptCapture,
												&plvInfo);
				plvInfo.code = PLVN_ITEMUP;
				SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
			}
		}
#endif // UNDER_CE
		lpPlvData->iCapture = CAPTURE_NONE;
		lpPlvData->ptCapture.x = 0;
		lpPlvData->ptCapture.y = 0;
		break;
	}
	return 0;
	Unref(wParam);
}

INT IconView_MouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData)  {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	static POINT pt;
	static PLVINFO plvInfo;
	pt.x = LOWORD(lParam);
	pt.y = HIWORD(lParam);
	//Dbg(("x %d, y %d\n", pt.x, pt.y));
	INT index = IV_GetInfoFromPoint(lpPlvData, pt, &plvInfo);
	//Dbg(("mouse up   index [%d]\n", index));
	InvalidateRect(hwnd, NULL, NULL);
	//----------------------------------------------------------------
	//970929:
	//if(index != -1 && !lpPlvData->fCapture) {
	//----------------------------------------------------------------
	if(index != -1 && (lpPlvData->iCapture == CAPTURE_NONE)) {
#if 0
		Dbg(("style [%d]\n", plvInfo.style));
		Dbg(("code  [%d]\n", plvInfo.code));
		Dbg(("index [%d]\n", plvInfo.index));
		Dbg(("left[%d] top[%d] right[%d] bottom[%d] \n",
			 plvInfo.itemRect.left,
			 plvInfo.itemRect.top,
			 plvInfo.itemRect.right,
			 plvInfo.itemRect.bottom));
#endif
		if(lpPlvData->uMsg != 0) {
			plvInfo.code = PLVN_ITEMPOPED;
			SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
#ifdef MSAA
			static oldindex = 0;
			index++; // convert to 1 origin child id

			if((index > 0)&&(index != oldindex)) {
				PLV_NotifyWinEvent(lpPlvData,
								   EVENT_OBJECT_FOCUS,
								   hwnd,
								   OBJID_CLIENT,
								   index); // child id
				oldindex = index;
			}
#endif
		}
	}
	return 0;
	Unref(wParam);
}

//////////////////////////////////////////////////////////////////
// Function : IconView_VScroll
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IconView_VScroll(HWND hwnd, WPARAM wParam,  LPARAM lParam)
{
	//----------------------------------------------------------------
	// get current top index.
	// calc scroll position. 
	// get new top index and set it. 
	// redraw window rectangle.
	//----------------------------------------------------------------
	INT nScrollCode	  = (int) LOWORD(wParam); // scroll bar value 
#ifdef _DEBUG
	INT nArgPos 	  = (short int) HIWORD(wParam);  // scroll box position 
#endif
	//HWND hwndScrollBar = (HWND) lParam;      // handle of scroll bar 
	INT nPos;
	INT nRow, nCol, nMax;

	switch(nScrollCode) {
	case SB_LINEDOWN:	
		Dbg(("SB_LINEDOWN COME nArgPos[%d]\n", nArgPos));
		nRow = IV_GetRow(hwnd);
		nMax = IV_GetMaxLine(hwnd);
		nPos = IV_GetCurScrollPos(hwnd);		
		if(nPos + nRow > nMax - 1) {
			return 0;
		}
		nPos++;
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_LINEUP:
		Dbg(("SB_LINEUP COME nArgPos[%d]\n", nArgPos));
		IV_GetRowColumn(hwnd, &nRow, &nCol);
		nPos = IV_GetCurScrollPos(hwnd);
		if(nPos <= 0) {
			return 0;
		}
		nPos--; 
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_PAGEDOWN:	
		Dbg(("SB_PAGEDOWN COME nArgPos[%d]\n", nArgPos));
		IV_GetRowColumn(hwnd, &nRow, &nCol);
		nMax = IV_GetMaxLine(hwnd);
		nPos = IV_GetCurScrollPos(hwnd);
		Dbg(("nMax [%d] nPos %d nRow[%d] nCol[%d]\n", nMax, nPos, nRow, nCol));
		nPos = min(nPos+nRow, nMax - nRow);
		Dbg(("-->nPos [%d] \n", nPos));
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_PAGEUP:		//Track̏オNbNꂽ
		Dbg(("SB_PAGEUP COME nArgPos[%d]\n", nArgPos));
		IV_GetRowColumn(hwnd, &nRow, &nCol);
		nPos = IV_GetCurScrollPos(hwnd);
		nPos = max(0, nPos - nRow);
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_TOP:
		Dbg(("SB_TOP COME nArgPos[%d]\n", nArgPos));
		break;
	case SB_BOTTOM:
		Dbg(("SB_BOTTOM COME nArgPos[%d]\n", nArgPos));
		break;
	case SB_THUMBTRACK:		//TrackDrag
		Dbg(("SB_THUMBTRACK COME nArgPos[%d]\n", nArgPos));
		nPos = IV_GetScrollTrackPos(hwnd);
		//Dbg(("Current Pos %d\n", nPos));
		IV_GetRowColumn(hwnd, &nRow, &nCol);
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_THUMBPOSITION:	//Scroll BarDragI
		Dbg(("SB_THUMBPOSITION COME nArgPos[%d]\n", nArgPos));
		nPos = IV_GetScrollTrackPos(hwnd);
		Dbg(("Current Pos %d\n", nPos));
		IV_GetRowColumn(hwnd, &nRow, &nCol);
		IV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_ENDSCROLL:
		Dbg(("SB_ENDSCROLL COME nArgPos[%d]\n", nArgPos));
		break;
	}
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	Unref3(hwnd, wParam, lParam);
}

INT IconView_SetCurSel(LPPLVDATA lpPlvData, INT index)
{
	INT		i, j;
	HWND	hwnd;	

	//Dbg(("IconView_SetCurSel Index [%d][0x%08x]START\n", index, index));

	hwnd = lpPlvData->hwndSelf;
	RECT rc;
	GetClientRect(hwnd, &rc);
	INT nRow = IV_GetRow(hwnd);
	INT nCol = IV_GetCol(hwnd);

	if(nCol <= 0) {
		return 0;
	}

	INT nMetricsCount;
	nMetricsCount = (nRow+1) * nCol;
	INT x, y;
	RECT rcChar;

	INT nItemWidth  = IV_GetItemWidth(hwnd);
	INT nItemHeight = IV_GetItemHeight(hwnd);
	INT iCurIconTopIndex;

	static PLVITEM plvItemTmp, plvItem;
	POINT pt;
	iCurIconTopIndex = (lpPlvData->iCurIconTopIndex / nCol) * nCol;
	for(i = 0, j = iCurIconTopIndex;
		i < nMetricsCount && j < lpPlvData->iItemCount;
		i++, j++) {
		if(index == j) {
			x = IV_GetXMargin(hwnd) + nItemWidth  * (i % nCol);
			y = IV_GetYMargin(hwnd) + nItemHeight * (i / nCol);
			rcChar.left  = rc.left + x;
			rcChar.top   = rc.top  + y;
			pt.x = rcChar.left + (nItemWidth  * 3)/4;
			pt.y = rcChar.top  + (nItemHeight * 3)/4;
			ClientToScreen(hwnd, &pt);
			SetCursorPos(pt.x, pt.y);
			break;
		}
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : IconView_GetWidthByColumn
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlv 
//          : INT col 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IconView_GetWidthByColumn(LPPLVDATA lpPlv, INT col)
{
	if(col < 0) {
		col = 0;
	}
	INT nItemWidth = IV_GetItemWidth(lpPlv->hwndSelf);
	INT nVScroll = GetSystemMetrics(SM_CXVSCROLL);
	INT nEdge    = GetSystemMetrics(SM_CXEDGE);
	Dbg(("nItemWidth [%d] nVScroll[%d] nEdge[%d]\n", nItemWidth, nVScroll, nEdge));
	Dbg(("Total Width [%d]\n", col*nItemWidth + nVScroll + nEdge*2));
	return col*nItemWidth + nVScroll + nEdge*2;
}


//////////////////////////////////////////////////////////////////
// Function : IconView_GetHeightByRow
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlv 
//          : INT row 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT IconView_GetHeightByRow(LPPLVDATA lpPlv, INT row)
{
	if(row < 0) {
		row = 0;
	}
	INT nItemHeight = IV_GetItemHeight(lpPlv->hwndSelf);
	INT nEdge       = GetSystemMetrics(SM_CXEDGE);
	Dbg(("nItemHeight [%d] [%d] nEdge[%d]\n", nItemHeight, nEdge));
	Dbg(("Total Height[%d]\n", row*nItemHeight + nEdge*2));
	return row*nItemHeight + nEdge*2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvproc.h ===
#ifndef _PLV_PROC_H_
#define _PLV_PROC_H_
/* plvproc.cpp */
extern LRESULT CALLBACK PlvWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif //_PLV_PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plv.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>

#include "plv.h"
#include "plv_.h"
#include "plvproc.h"
#include "dbg.h"
#include "strutil.h"
#include "repview.h"
#include "iconview.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE
#ifdef MSAA
#pragma message("->plv.cpp:MSAA supported.")
#include "accplv.h"
#include "ivmisc.h"
#include "rvmisc.h"
#endif // MSAA
#ifdef UNDER_CE
	#ifdef FE_JAPANESE
		#define MS_MINCHO_J TEXT("\xff2d\xff33 \x660e\x671d") // lr  
		#define MS_GOTHIC_J TEXT("\xff2d\xff33 \x30b4\x30b7\x30c3\x30af") // lr SVbN 
	#elif FE_KOREAN
		#define GULIM_KO  TEXT("\xad74\xb9bc") // Gulim
		#define BATANG_KO TEXT("\xbc14\xd0d5") // Batang
	#endif	
#else // UNDER_CE
	#ifdef FE_KOREAN
		#define GULIM_KO  "\xb1\xbc\xb8\xb2" // Gulim
		#define BATANG_KO "\xb9\xd9\xc5\xc1" // Batang
	#endif	
#endif

extern LPPLVDATA PLV_Initialize(VOID);
extern VOID PLV_Destroy(LPPLVDATA lpPlv);
extern INT PLV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos);
extern INT PLV_GetScrollTrackPos(HWND hwnd);

#ifdef UNDER_CE // In Windows CE, all window classes are process global.
static LPCTSTR MakeClassName(HINSTANCE hInst, LPTSTR lpszBuf)
{
	// make module unique name
	TCHAR szFileName[MAX_PATH];
	GetModuleFileName(hInst, szFileName, MAX_PATH);
	LPTSTR lpszFName = _tcsrchr(szFileName, TEXT('\\'));
	if(lpszFName) *lpszFName = TEXT('_');
	lstrcpy(lpszBuf, WC_PADLISTVIEW);
	lstrcat(lpszBuf, lpszFName);

	return lpszBuf;
}

BOOL PadListView_UnregisterClass(HINSTANCE hInst)
{
	TCHAR szClassName[MAX_PATH];
	return UnregisterClass(MakeClassName(hInst, szClassName), hInst);
}
#endif // UNDER_CE

//----------------------------------------------------------------
// Public API Declare
//----------------------------------------------------------------
//////////////////////////////////////////////////////////////////
// Function : PadListView_RegisterClass
// Type     : static ATOM
// Purpose  : 
// Args     : 
//          : HINSTANCE hInst 
//          : LPSTR lpstrClass 
//          : WNDPROC lpfnWndProc 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
#ifndef UNDER_CE
static BOOL PadListView_RegisterClass(HINSTANCE hInst, LPSTR lpstrClass, WNDPROC lpfnWndProc)
#else // UNDER_CE
static BOOL PadListView_RegisterClass(HINSTANCE hInst, LPTSTR lpstrClass, WNDPROC lpfnWndProc)
#endif // UNDER_CE
{
	ATOM ret;
#ifndef UNDER_CE // Windows CE does not support EX
	static WNDCLASSEX  wc;
#else // UNDER_CE
	WNDCLASS  wc;
#endif // UNDER_CE

	//----------------------------------------------------------------
	//check specified class is already exist or not
	//----------------------------------------------------------------
#ifndef UNDER_CE // Windows CE does not support EX
	if(GetClassInfoEx(hInst, lpstrClass, &wc)){
#else // UNDER_CE
	if(GetClassInfo(hInst, lpstrClass, &wc)){
#endif // UNDER_CE
		//lpstrClass is already registerd.
		return TRUE;
	}
	ZeroMemory(&wc, sizeof(wc));
#ifndef UNDER_CE // Windows CE does not support EX
	wc.cbSize			= sizeof(wc);
#endif // UNDER_CE
	wc.style			= CS_HREDRAW | CS_VREDRAW;	 /* Class style(s). */
	wc.lpfnWndProc		= (WNDPROC)lpfnWndProc;
	wc.cbClsExtra		= 0;						/* No per-class extra data.*/
	wc.cbWndExtra		= sizeof(LPVOID);			/* No per-window extra data.		  */
	wc.hInstance		= hInst;					/* Application that owns the class.	  */
	wc.hIcon			= NULL; //LoadIcon(hInstance, MAKEINTRESOURCE(SCROLL32_ICON));
	wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
	//wc.hbrBackground	= (HBRUSH)(COLOR_3DFACE+1);
	//wc.hbrBackground	= (HBRUSH)(COLOR_3DFACE+1);
	//wc.hbrBackground	= GetStockObject(WHITE_BRUSH); 
	wc.lpszMenuName		= NULL; //g_szClass;		/* Name of menu resource in .RC file. */
	wc.lpszClassName	= lpstrClass;				/* Name used in call to CreateWindow. */
#ifndef UNDER_CE // Windows CE does not support EX
	wc.hIconSm = NULL;
	ret = RegisterClassEx(&wc);
#else // UNDER_CE
	ret = RegisterClass(&wc);
#endif // UNDER_CE
	return ret ? TRUE: FALSE;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_CreateWindow
// Type     : HWND
// Purpose  : 
// Args     : 
//          : HINSTANCE hInst 
//          : HWND hwndParent 
//          : INT x 
//          : INT y 
//          : INT width 
//          : INT height 
//          : UINT uNotifyMsg 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
HWND WINAPI PadListView_CreateWindow(HINSTANCE	hInst,
							  HWND		hwndParent,
							  INT		wID,
							  INT		x,
							  INT		y,
							  INT		width,
							  INT		height,
							  UINT		uNotifyMsg)
{
	HWND hwnd;	
#ifndef UNDER_CE // In Windows CE, all window classes are process global.
	BOOL ret = PadListView_RegisterClass(hInst, WC_PADLISTVIEW, PlvWndProc);
#else // UNDER_CE
	TCHAR szClassName[MAX_PATH];
	MakeClassName(hInst, szClassName);
	BOOL ret = PadListView_RegisterClass(hInst, szClassName, PlvWndProc);
#endif // UNDER_CE
	if(!ret) {
		Dbg(("Failed to Regiset class[%s]\n", WC_PADLISTVIEW));
		return NULL;
	}

	LPPLVDATA lpPlvData = PLV_Initialize();
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return NULL;
	}
	lpPlvData->hInst = hInst;
	lpPlvData->uMsg  = uNotifyMsg;
	hwnd = CreateWindowEx(WS_EX_CLIENTEDGE,
#ifndef UNDER_CE // All CE window class is process global.
						  WC_PADLISTVIEW,
						  WC_PADLISTVIEW,
#else // UNDER_CE
						  szClassName,
						  szClassName,
#endif // UNDER_CE
						  WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
						  x, y,
						  width,
						  height,
						  hwndParent,
						  (HMENU)(UINT_PTR)wID,
						  hInst,
						  (LPVOID)lpPlvData);
	if(!hwnd) {
		Dbg(("Create Window Failed \n"));
		return NULL;
	}
	return hwnd;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetItemCount
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_GetItemCount(HWND hwnd)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	return lpPlvData->iItemCount;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetItemCount
// Type     : INT
// Purpose  : Set total Item's count to PadListView.
//			: it effect's scroll bar.
// Args     : 
//          : HWND hwnd 
//          : INT itemCount 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetItemCount(HWND hwnd, INT itemCount)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_SetItemCount(lpPlvData, itemCount, TRUE);
		RepView_SetItemCount(lpPlvData, itemCount, FALSE);
	}
	else if(lpPlvData->dwStyle == PLVSTYLE_REPORT) {
		IconView_SetItemCount(lpPlvData, itemCount, FALSE);
		RepView_SetItemCount(lpPlvData, itemCount, TRUE);
	}
	PadListView_Update(hwnd);
	return 0;
	Unref(itemCount);
}


//////////////////////////////////////////////////////////////////
// Function : PadListView_SetExplanationText
// Type     : INT
// Purpose  : set the PadListView's text .
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpText 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetExplanationText(HWND hwnd, LPSTR lpText)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	lpPlvData->lpText = lpText;			// lpText must point to a static data
	PadListView_Update(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetExplanationTextW
// Type     : INT
// Purpose  : set the PadListView's text .
// Args     : 
//          : HWND hwnd 
//          : LPWSTR lpText 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetExplanationTextW(HWND hwnd, LPWSTR lpwText)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	lpPlvData->lpwText = lpwText;			// lpText must point to a static data
	PadListView_Update(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetTopIndex
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : INT indexTop 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetTopIndex(HWND hwnd, INT indexTop)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		return IconView_SetTopIndex(lpPlvData, indexTop);
	}
	else if(lpPlvData->dwStyle == PLVSTYLE_REPORT) {
		return RepView_SetTopIndex(lpPlvData, indexTop);
	}
	else {
		Dbg(("Internal ERROR\n"));
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetTopIndex
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_GetTopIndex(HWND hwnd)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		return lpPlvData->iCurIconTopIndex;
	}
	else {
		return lpPlvData->iCurTopIndex;
	}
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetIconItemCallback
// Type     : INT
// Purpose  : Set user defined Function that gets each Item's string
// Args     : 
//          : HWND hwnd 
//          : LPARAM lParam 
//          : LPFNPLVITEMCALLBACK lpfnPlvItemCallback 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetIconItemCallback(HWND hwnd, LPARAM lParam, LPFNPLVICONITEMCALLBACK lpfnPlvIconItemCallback)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	lpPlvData->iconItemCallbacklParam   = lParam;
	lpPlvData->lpfnPlvIconItemCallback  = lpfnPlvIconItemCallback;
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetReportItemCallback
// Type     : INT
// Purpose  : Set user defined Function that gets each column's string 
//			: in Report view.
// Args     : 
//          : HWND hwnd 
//          : LPFNPLVCOLITEMCALLBACK lpfnColItemCallback 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetReportItemCallback(HWND hwnd, LPARAM lParam, LPFNPLVREPITEMCALLBACK lpfnPlvRepItemCallback)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	lpPlvData->repItemCallbacklParam  = lParam;
	lpPlvData->lpfnPlvRepItemCallback = lpfnPlvRepItemCallback;
	return 0;
}


typedef struct tagFONTINFO {
	LPTSTR		lpstrFontName;
	BOOL		fFound;
	LPLOGFONT	lpLogFont;
}FONTINFO, *LPFONTINFO;

static INT CALLBACK EnumFontFamProc(ENUMLOGFONT		*lpElf,
									NEWTEXTMETRIC	*lpNtm,
									INT				iFontType,
									LPARAM			lParam)
{
	//Dbg(("EnumFontFamProc font[%s]\n", lpElf->elfLogFont.lfFaceName));
#ifndef UNDER_CE // always Unicode
	if(0 == StrcmpA(lpElf->elfLogFont.lfFaceName, ((FONTINFO *)lParam)->lpstrFontName)) {
#else // UNDER_CE
	if(0 == lstrcmp(lpElf->elfLogFont.lfFaceName, ((FONTINFO *)lParam)->lpstrFontName)) {
#endif // UNDER_CE
		*((LPFONTINFO)lParam)->lpLogFont = lpElf->elfLogFont;
		((LPFONTINFO)lParam)->fFound  = TRUE;
		return 0;
	}
	return 1;	
	Unref(lpNtm);
	Unref(iFontType);
}

static INT GetLogFont(HDC hDC, LPTSTR lpstrFaceName, LOGFONT *plf)
{
	static FONTINFO fontInfo;
	if(!lpstrFaceName) {
		Dbg(("GetLogFont Error lpstrFaceName is NULL\n"));
		return -1;
	}
	if(lstrlen(lpstrFaceName) >= LF_FACESIZE) {
		Dbg(("GetLogFont Error length invalid\n"));
		return -1;
	}
	if(!plf) {
		Dbg(("GetLogFont Error plf is NULL\n"));
		return -1;
	}
	ZeroMemory(&fontInfo, sizeof(fontInfo));
	fontInfo.lpstrFontName = lpstrFaceName;
	fontInfo.lpLogFont	   = plf;
	EnumFontFamilies(hDC, NULL, (FONTENUMPROC)EnumFontFamProc, (LPARAM)&fontInfo);
	if(fontInfo.fFound) {
		return 0;
	}
	else {
		return -1;
	}
}

typedef struct tagFONTINFOEX {
	LPTSTR		lpstrFontName;
	INT			charSet;
	BOOL		fFound;
	LPLOGFONT	lpLogFont;
}FONTINFOEX, *LPFONTINFOEX;

static INT CALLBACK EnumFontFamProcEx(ENUMLOGFONT	*lpElf,
									  NEWTEXTMETRIC	*lpNtm,
									  INT				iFontType,
									  LPARAM			lParam)
{
	//Dbg(("EnumFontFamProc font[%s]\n", lpElf->elfLogFont.lfFaceName));
	if(0 == StrcmpA(lpElf->elfLogFont.lfFaceName, ((FONTINFOEX *)lParam)->lpstrFontName)) {
		if((BYTE)((FONTINFOEX *)lParam)->charSet == lpElf->elfLogFont.lfCharSet) {
			*((LPFONTINFOEX)lParam)->lpLogFont = lpElf->elfLogFont;
			((LPFONTINFOEX)lParam)->fFound  = TRUE;
			return 0;
		}
	}
	return 1;	
	Unref(lpNtm);
	Unref(iFontType);
}

static INT GetLogFontEx(HDC		hDC,
						LPTSTR	lpstrFaceName,
						INT		charSet,
						LOGFONT *plf)
{
	Dbg(("!!!!!! GetLogFont charSet[%d]\n", charSet));
	static FONTINFOEX fontInfo;
	if(!lpstrFaceName) {
		Dbg(("GetLogFont Error lpstrFaceName is NULL\n"));
		return -1;
	}
	if(lstrlen(lpstrFaceName) >= LF_FACESIZE) {
		Dbg(("GetLogFont Error length invalid\n"));
		return -1;
	}
	if(!plf) {
		Dbg(("GetLogFont Error plf is NULL\n"));
		return -1;
	}
	ZeroMemory(&fontInfo, sizeof(fontInfo));
	fontInfo.lpstrFontName = lpstrFaceName;
	fontInfo.charSet	   = charSet;
	fontInfo.lpLogFont	   = plf;
	static LOGFONT logFont;
	ZeroMemory(&logFont, sizeof(logFont));
	logFont.lfCharSet = (BYTE)charSet,
#ifndef UNDER_CE
	StrcpyA(logFont.lfFaceName, lpstrFaceName);
#else // UNDER_CE
	lstrcpy(logFont.lfFaceName, lpstrFaceName);
#endif // UNDER_CE
#ifndef UNDER_CE // Windows CE does not support EnumFontFamiliesEx
	EnumFontFamiliesEx(hDC, 
					   &logFont,
					   (FONTENUMPROC)EnumFontFamProcEx,
					   (LPARAM)&fontInfo,
					   0);
#else // UNDER_CE
	EnumFontFamilies(hDC,
					 logFont.lfFaceName,
					 (FONTENUMPROC)EnumFontFamProcEx,
					 (LPARAM)&fontInfo);
#endif // UNDER_CE
	if(fontInfo.fFound) {
		return 0;
	}
	else {
		return -1;
	}
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetIconFont
// Type     : INT
// Purpose  : Set specifed Font for ICON View.
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName 
//          : INT point 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
#define ABS(a)   (a > 0 ? a: -a)
//for do not use stack.
static TEXTMETRIC	g_tm;
static LOGFONT		g_logFont;

INT WINAPI PadListView_SetIconFont(HWND hwnd, LPTSTR lpstrFontName, INT point)
{
	Dbg(("PadListView_SetIconFont  START font[%s] point[%d]\n", lpstrFontName, point));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	if(!lpPlvData) {
		Dbg(("PadListView_SetIconFont ERROR\n"));
		return 0;
	}

	HFONT hFont;
	HDC hDC = GetDC(hwnd);
	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);

	if(-1 == GetLogFont(hDC, lpstrFontName, &g_logFont)) {
		Dbg(("GetLogFont Error [%s]\n", lpstrFontName));
#ifndef UNDER_CE
	#ifdef FE_JAPANESE
		if(0 == lstrcmp(lpstrFontName, "lr ")) {
			GetLogFont(hDC, "MS Mincho", &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, "lr SVbN")) {
			GetLogFont(hDC, "MS Gothic", &g_logFont);
		}
	#elif FE_KOREAN
		if(0 == lstrcmp(lpstrFontName, GULIM_KO)) {
			GetLogFont(hDC, "Gulim", &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, BATANG_KO)) {
			GetLogFont(hDC, "Batang", &g_logFont);
		}
	#else
		return (-1);
	#endif
#else // UNDER_CE
	#ifdef FE_JAPANESE
		if(0 == lstrcmp(lpstrFontName, MS_MINCHO_J)) {
			GetLogFont(hDC, TEXT("MS Mincho"), &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, MS_GOTHIC_J)) {
			GetLogFont(hDC, TEXT("MS Gothic"), &g_logFont);
		}
	#elif FE_KOREAN
		if(0 == lstrcmp(lpstrFontName, GULIM_KO)) {
			GetLogFont(hDC, TEXT("Gulim"), &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, BATANG_KO)) {
			GetLogFont(hDC, TEXT("Batang"), &g_logFont);
		}
	#else
		return (-1);
	#endif
#endif // UNDER_CE
	}
	ReleaseDC(hwnd, hDC);

	//----------------------------------------------------------------
	//Set new size
	//----------------------------------------------------------------
	g_logFont.lfHeight			= - (point * dpi)/72;
	g_logFont.lfWidth			= 0; // Calcurated automatically by lfHeight.

	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontIcon) {
		DeleteObject(lpPlvData->hFontIcon);
	}
	lpPlvData->iFontPointIcon = point;
	lpPlvData->hFontIcon = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nItemWidth  = ABS(g_logFont.lfHeight) + XRECT_MARGIN*2;
	lpPlvData->nItemHeight = ABS(g_logFont.lfHeight) + YRECT_MARGIN*2;
	PadListView_Update(hwnd);
	Dbg(("PadListView_SetFont END\n"));

#if 0
	HFONT hFont;
	//use global data logfont, TextMetrics
	ZeroMemory(&g_logFont,	sizeof(g_logFont));
	ZeroMemory(&g_tm,		sizeof(g_tm));

	HDC hDC = GetDC(hwnd);
	if(!hDC) {
		Dbg(("PadListView_SetIconFont ERROR\n"));
		return -1;
	}
	GetTextMetrics(hDC, &g_tm);

	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);
	ReleaseDC(hwnd, hDC);

	g_logFont.lfHeight		   = - (point * dpi)/72;
	g_logFont.lfCharSet        = DEFAULT_CHARSET; //g_tm.tmCharSet;
	g_logFont.lfPitchAndFamily = g_tm.tmPitchAndFamily;
	Dbg(("g_logFont.lfHeight         = %d\n", g_logFont.lfHeight));
	Dbg(("g_logFont.lfCharSet        = %d\n", g_logFont.lfCharSet));
	Dbg(("g_logFont.lfPitchAndFamily = %d\n", g_logFont.lfPitchAndFamily));

	StrcpyA(g_logFont.lfFaceName, lpstrFontName);
	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontIcon) {
		DeleteObject(lpPlvData->hFontIcon);
	}
	lpPlvData->iFontPointIcon = point;
	lpPlvData->hFontIcon = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nItemWidth  = ABS(g_logFont.lfHeight) + XRECT_MARGIN*2;
	lpPlvData->nItemHeight = ABS(g_logFont.lfHeight) + YRECT_MARGIN*2;
	PadListView_Update(hwnd);
	Dbg(("PadListView_SetFont END\n"));
#endif
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetReportFont
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName 
//          : INT point 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetReportFont(HWND hwnd, LPTSTR lpstrFontName, INT point)
{
	Dbg(("PadListView_SetReportFont  START\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("PadListView_SetReportFont ERROR\n"));
		return 0;
	}

	HFONT hFont;
	ZeroMemory(&g_logFont, sizeof(g_logFont));

	HDC hDC = GetDC(hwnd);
	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);
	if(-1 == GetLogFont(hDC, lpstrFontName, &g_logFont)) {
		Dbg(("GetLogFont Error [%s]\n", lpstrFontName));
#ifndef UNDER_CE
	#ifdef FE_JAPANESE
		if(0 == lstrcmp(lpstrFontName, "lr ")) {
			GetLogFont(hDC, "MS Mincho", &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, "lr SVbN")) {
			GetLogFont(hDC, "MS Gothic", &g_logFont);
		}
	#elif FE_KOREAN
		if(0 == lstrcmp(lpstrFontName, GULIM_KO)) {
			GetLogFont(hDC, "Gulim", &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, BATANG_KO)) {
			GetLogFont(hDC, "Batang", &g_logFont);
		}
	#else
		return (-1);
	#endif
#else // UNDER_CE
	#ifdef FE_JAPANESE
		if(0 == lstrcmp(lpstrFontName, MS_MINCHO_J)) {
			GetLogFont(hDC, TEXT("MS Mincho"), &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, MS_GOTHIC_J)) {
			GetLogFont(hDC, TEXT("MS Gothic"), &g_logFont);
		}
	#elif FE_KOREAN
		if(0 == lstrcmp(lpstrFontName, GULIM_KO)) {
			GetLogFont(hDC, TEXT("Gulim"), &g_logFont);
		}
		else if(0 == lstrcmp(lpstrFontName, BATNANG_KO)) {
			GetLogFont(hDC, TEXT("Batang"), &g_logFont);
		}
	#else
		return (-1);
	#endif
#endif // UNDER_CE
	}
	ReleaseDC(hwnd, hDC);
	g_logFont.lfHeight		   = - (point * dpi)/72;
	g_logFont.lfWidth		   = 0;

	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontRep) {
		DeleteObject(lpPlvData->hFontRep);
	}
	lpPlvData->iFontPointRep = point;
	lpPlvData->hFontRep		 = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nRepItemWidth  = ABS(g_logFont.lfHeight) + PLV_REPRECT_XMARGIN*2;
	lpPlvData->nRepItemHeight = ABS(g_logFont.lfHeight) + PLV_REPRECT_YMARGIN*2;
	PadListView_Update(hwnd);
	return 0;
#if 0
	HFONT hFont;

	HDC hDC = GetDC(hwnd);
	if(!hDC) {
		Dbg(("PadListView_SetReportFont ERROR\n"));
		return -1;
	}
	ZeroMemory(&g_tm,      sizeof(g_tm));
	GetTextMetrics(hDC, &g_tm);
	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);

	ReleaseDC(hwnd, hDC);

	ZeroMemory(&g_logFont, sizeof(g_logFont));
	g_logFont.lfHeight			= - (point * dpi)/72;
	g_logFont.lfCharSet			= DEFAULT_CHARSET; //g_tm.tmCharSet;
	g_logFont.lfPitchAndFamily	= g_tm.tmPitchAndFamily;
	Dbg(("g_logFont.lfHeight         = %d\n", g_logFont.lfHeight));
	Dbg(("g_logFont.lfCharSet        = %d\n", g_logFont.lfCharSet));
	Dbg(("g_logFont.lfPitchAndFamily = %d\n", g_logFont.lfPitchAndFamily));

	StrcpyA(g_logFont.lfFaceName, lpstrFontName);
	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontRep) {
		DeleteObject(lpPlvData->hFontRep);
	}
	lpPlvData->iFontPointRep = point;
	lpPlvData->hFontRep		 = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nRepItemWidth  = ABS(g_logFont.lfHeight) + PLV_REPRECT_XMARGIN*2;
	lpPlvData->nRepItemHeight = ABS(g_logFont.lfHeight) + PLV_REPRECT_YMARGIN*2;
	PadListView_Update(hwnd);
	Dbg(("PadListView_SetFont END\n"));
	return 0;
#endif
}

//
///
//990126:toshiaK
//////////////////////////////////////////////////////////////////
// Function : PadListView_SetIconFontEx
// Type     : INT
// Purpose  : Set specifed Font for ICON View.
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName 
//			: INT charSet
//          : INT point 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetIconFontEx(HWND hwnd,
									 LPTSTR lpstrFontName,
									 INT charSet,
									 INT point)
{
	Dbg(("PadListView_SetIconFontEx  START font[%s] point[%d]\n", lpstrFontName, point));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	if(!lpPlvData) {
		Dbg(("PadListView_SetIconFont ERROR\n"));
		return 0;
	}

	HFONT hFont;
	HDC hDC = GetDC(hwnd);
	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);
	if(-1 == GetLogFontEx(hDC, lpstrFontName, charSet, &g_logFont)) {
		ReleaseDC(hwnd, hDC);
		return -1;
	}
	ReleaseDC(hwnd, hDC);

	//----------------------------------------------------------------
	//Set new size
	//----------------------------------------------------------------
	g_logFont.lfHeight			= - (point * dpi)/72;
	g_logFont.lfWidth			= 0; // Calcurated automatically by lfHeight.

	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontIcon) {
		DeleteObject(lpPlvData->hFontIcon);
	}
	lpPlvData->iFontPointIcon = point;
	lpPlvData->hFontIcon = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nItemWidth  = ABS(g_logFont.lfHeight) + XRECT_MARGIN*2;
	lpPlvData->nItemHeight = ABS(g_logFont.lfHeight) + YRECT_MARGIN*2;
	PadListView_Update(hwnd);
	Dbg(("PadListView_SetFont END\n"));
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetReportFontEx
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName 
//			: INT charSet
//          : INT point 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetReportFontEx(HWND hwnd,
									   LPTSTR lpstrFontName,
									   INT charSet,
									   INT point)
{
	Dbg(("PadListView_SetReportFontEx  START\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("PadListView_SetReportFont ERROR\n"));
		return 0;
	}

	HFONT hFont;
	ZeroMemory(&g_logFont, sizeof(g_logFont));

	HDC hDC = GetDC(hwnd);
	INT dpi = GetDeviceCaps(hDC, LOGPIXELSY);

	if(-1 == GetLogFontEx(hDC, lpstrFontName, charSet, &g_logFont)) {
		ReleaseDC(hwnd, hDC);
		return -1;
	}
	ReleaseDC(hwnd, hDC);
	g_logFont.lfHeight		   = - (point * dpi)/72;
	g_logFont.lfWidth		   = 0;

	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontRep) {
		DeleteObject(lpPlvData->hFontRep);
	}
	lpPlvData->iFontPointRep = point;
	lpPlvData->hFontRep		 = hFont;
	//If font point changed, also changes itemWidth & itemHeight
	lpPlvData->nRepItemWidth  = ABS(g_logFont.lfHeight) + PLV_REPRECT_XMARGIN*2;
	lpPlvData->nRepItemHeight = ABS(g_logFont.lfHeight) + PLV_REPRECT_YMARGIN*2;
	PadListView_Update(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetStyle
// Type     : INT
// Purpose  : set the PadListView's style.
//			  style is PLVSTYLE_LIST or PLVSTYLE_REPORT
// Args     : 
//          : HWND hwnd 
//          : INT style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetStyle(HWND hwnd, INT style)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("PadListView_SetStyle ERROR\n"));
		return -1;
	}
	if(style != PLVSTYLE_ICON && 
	   style != PLVSTYLE_REPORT) {
		Dbg(("Internal ERROR\n"));
		return -1;
	}
	lpPlvData->dwStyle = style;
	if(style == PLVSTYLE_ICON) {
		if(lpPlvData->hwndHeader) {
			//Hide header control
			SetWindowPos(lpPlvData->hwndHeader, NULL, 0, 0, 0, 0,
						 SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
		}
		IconView_RestoreScrollPos(lpPlvData);
	}
	else if(style == PLVSTYLE_REPORT) {
		if(lpPlvData->hwndHeader) {
			RECT rc;
			GetClientRect(lpPlvData->hwndSelf, &rc); // get PadListView's client rect
			HD_LAYOUT hdl;
			WINDOWPOS wp;
			hdl.prc = &rc;
			hdl.pwpos = &wp;
			//Calc header control window size
			if(Header_Layout(lpPlvData->hwndHeader, &hdl) == FALSE) {
				//OutputDebugString("Create Header Layout error\n");
				return NULL;
			}
			SetWindowPos(lpPlvData->hwndHeader, wp.hwndInsertAfter, wp.x, wp.y,
						 wp.cx, wp.cy, wp.flags | SWP_SHOWWINDOW);
		}
		RepView_RestoreScrollPos(lpPlvData);
	}
	PadListView_Update(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetStyle
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_GetStyle(HWND hwnd)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("PadListView_SetFont ERROR\n"));
		return -1;
	}
	return (INT)lpPlvData->dwStyle;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_Update
// Type     : INT
// Purpose  : Repaint PadListView.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_Update(HWND hwnd)
{
	InvalidateRect(hwnd, NULL, TRUE);
	UpdateWindow(hwnd);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetCurSel
// Type     : INT
// Purpose  : set cur selection. Move cursor to specified index.
//			:
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpText 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetCurSel(HWND hwnd, INT index)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return -1;
	}
	switch(lpPlvData->dwStyle) {
	case PLVSTYLE_ICON:
		IconView_SetCurSel(lpPlvData, index);
		break;
	case PLVSTYLE_REPORT:
		RepView_SetCurSel(lpPlvData, index);
		break;
	default:
		break;
	}
	return 0;
}


#if 0

typedef struct _LV_COLUMNA
{
    UINT mask; 	 //LVCF_FMT, LVCF_WIDTH, LVCF_TEXT, LVCF_SUBITEM;
    int fmt;
    int cx;
    LPSTR pszText;
    int cchTextMax;
    int iSubItem;
} LV_COLUMNA;

#define HDI_WIDTH               0x0001
#define HDI_HEIGHT              HDI_WIDTH
#define HDI_TEXT                0x0002
#define HDI_FORMAT              0x0004
#define HDI_LPARAM              0x0008
#define HDI_BITMAP              0x0010

#define HDF_LEFT                0
#define HDF_RIGHT               1
#define HDF_CENTER              2
#define HDF_JUSTIFYMASK         0x0003
#define HDF_RTLREADING          4

#define LVCF_FMT                0x0001
#define LVCF_WIDTH              0x0002
#define LVCF_TEXT               0x0004
#define LVCF_SUBITEM            0x0008

#define LVCFMT_LEFT             0x0000
#define LVCFMT_RIGHT            0x0001
#define LVCFMT_CENTER           0x0002
#define LVCFMT_JUSTIFYMASK      0x0003

#endif

//////////////////////////////////////////////////////////////////
// Function : PadListView_InsertColumn
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : INT index 
//          : PLV_COLUMN * lpPlvCol 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_InsertColumn(HWND hwnd, INT index, PLV_COLUMN *lpPlvCol)
{

	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return -1;
	}

	if(!lpPlvCol) {
		Dbg(("Internal ERROR\n"));
		return -1;
	}
#ifndef UNDER_CE // always Unicode
	if(::IsWindowUnicode(lpPlvData->hwndHeader)) {
#endif // UNDER_CE
		static HD_ITEMW hdi;
#ifndef UNDER_CE // #ifndef UNICODE
		static WCHAR wchBuf[256];
#endif // UNDER_CE
		ZeroMemory(&hdi, sizeof(hdi));
		if(lpPlvCol->mask & LVCF_FMT)	{ hdi.mask |= HDI_FORMAT;	} 
		if(lpPlvCol->mask & LVCF_WIDTH) { hdi.mask |= HDI_WIDTH;	}
		if(lpPlvCol->mask & LVCF_TEXT)	{ hdi.mask |= HDI_TEXT;		}
		if(lpPlvCol->fmt & LVCFMT_LEFT)			{ hdi.fmt |= HDF_LEFT;	}
		if(lpPlvCol->fmt & LVCFMT_RIGHT)		{ hdi.fmt |= HDF_RIGHT; }
		if(lpPlvCol->fmt & LVCFMT_CENTER)		{ hdi.fmt |= HDF_CENTER;}
		if(lpPlvCol->fmt & LVCFMT_JUSTIFYMASK)	{ hdi.fmt |= HDF_JUSTIFYMASK;}
#ifndef UNDER_CE // #ifndef UNICODE
		//----------------------------------------------------------------
		//980728: for ActiveIME support. use lpPlvData->codePage to convert
		//----------------------------------------------------------------
		::MultiByteToWideChar(lpPlvData->codePage,
							  MB_PRECOMPOSED,
							  lpPlvCol->pszText, -1, 
							  (WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
		hdi.pszText    = wchBuf; //lpPlvCol->pszText;
#else // UNDER_CE
		hdi.pszText    = lpPlvCol->pszText;
#endif // UNDER_CE
		hdi.cxy        = lpPlvCol->cx;
		hdi.cchTextMax = lpPlvCol->cchTextMax;
		hdi.fmt |= HDF_OWNERDRAW; //989727: always set ownerdraw
		SendMessageW(lpPlvData->hwndHeader, HDM_INSERTITEMW, (WPARAM)index, (LPARAM)&hdi);
#ifndef UNDER_CE // always Unicode
	}
	else {
		static HD_ITEMA hdi;
		ZeroMemory(&hdi, sizeof(hdi));
		if(lpPlvCol->mask & LVCF_FMT)	{ hdi.mask |= HDI_FORMAT;	} 
		if(lpPlvCol->mask & LVCF_WIDTH) { hdi.mask |= HDI_WIDTH;	}
		if(lpPlvCol->mask & LVCF_TEXT)	{ hdi.mask |= HDI_TEXT;		}

		if(lpPlvCol->fmt & LVCFMT_LEFT)			{ hdi.fmt |= HDF_LEFT;	}
		if(lpPlvCol->fmt & LVCFMT_RIGHT)		{ hdi.fmt |= HDF_RIGHT; }
		if(lpPlvCol->fmt & LVCFMT_CENTER)		{ hdi.fmt |= HDF_CENTER;}
		if(lpPlvCol->fmt & LVCFMT_JUSTIFYMASK)	{ hdi.fmt |= HDF_JUSTIFYMASK;}

		hdi.pszText    = lpPlvCol->pszText;
		hdi.cxy        = lpPlvCol->cx;
		hdi.cchTextMax = lpPlvCol->cchTextMax;
		hdi.fmt |= HDF_OWNERDRAW; //989727: always set ownerdraw
		Header_InsertItem(lpPlvData->hwndHeader, index, &hdi);
	}
#endif // UNDER_CE
	return 0;
}


//----------------------------------------------------------------
// Private API Declaration
//----------------------------------------------------------------
LPPLVDATA PLV_Initialize(VOID)
{
	LPPLVDATA lpPlvData = (LPPLVDATA)MemAlloc(sizeof(PLVDATA));
	if(!lpPlvData) {
		Dbg(("Memory ERROR\n"));
		return (LPPLVDATA)NULL;
	}
	ZeroMemory((LPVOID)lpPlvData, sizeof(PLVDATA));
	//----------------------------------------------------------------
	//IconView, Report view Common data.
	//----------------------------------------------------------------
	lpPlvData->dwSize			= sizeof(PLVDATA);	//this data size;
	lpPlvData->dwStyle			= PLVSTYLE_ICON;	//Pad listview window style (PLVIF_XXXX)
	lpPlvData->hwndSelf			= NULL;				//Pad listview window handle.
	lpPlvData->iItemCount		= 0;				//Virtual total item Count. it effects scroll bar.
	lpPlvData->iCurTopIndex		= 0;				//In report view top line..
	lpPlvData->nCurScrollPos	= 0;				//In report view Current Scroll posision.
	lpPlvData->iCurIconTopIndex	= 0;				//In icon view top line..
	lpPlvData->nCurIconScrollPos= 0;				//In icon view Scroll posision.
	lpPlvData->uMsg				= 0;				// user notify message.
	lpPlvData->iCapture			= CAPTURE_NONE;		//is mouse captured or not.
	lpPlvData->ptCapture.x		= 0;				//LButton Down mouse point.  
	lpPlvData->ptCapture.y		= 0;				//LButton Down mouse point.  

	//----------------------------------------------------------------
	//for Icon view
	//----------------------------------------------------------------
	lpPlvData->nItemWidth		= PLVICON_DEFAULT_WIDTH;			// List(Icon like )view's whole width.
	lpPlvData->nItemHeight		= PLVICON_DEFAULT_HEIGHT;			// List(Icon like )view's whole height.
	lpPlvData->iFontPointIcon	= PLVICON_DEFAULT_FONTPOINT;		// Icon View's font point.
	lpPlvData->hFontIcon		= NULL;								// Icon View's font
	lpPlvData->iconItemCallbacklParam = (LPARAM)0;	// Callback data for LPFNPLVITEMCALLBACK
    lpPlvData->lpfnPlvIconItemCallback = NULL;		//Callback function for getting item by index.

	//----------------------------------------------------------------
	//for report view
	//----------------------------------------------------------------
	lpPlvData->hwndHeader		= NULL;							//Header control's window handle.
    lpPlvData->nRepItemWidth	= PLVREP_DEFAULT_WIDTH;			//Report view's width
    lpPlvData->nRepItemHeight	= PLVREP_DEFAULT_HEIGHT;		//Report view's height
    lpPlvData->iFontPointRep	= PLVREP_DEFAULT_FONTPOINT;		// Report View's font point.
    lpPlvData->hFontRep			= NULL;							// Report View's font
	lpPlvData->repItemCallbacklParam = (LPARAM)0;
	lpPlvData->lpfnPlvRepItemCallback = NULL;				//Callback function for getting colitem by index.
	lpPlvData->lpText = NULL;
	lpPlvData->codePage = CP_ACP;	//980727
#ifdef MSAA
	PLV_InitMSAA(lpPlvData);
#endif
	return lpPlvData;
}

VOID PLV_Destroy(LPPLVDATA lpPlv)
{
	if(lpPlv) {
#ifdef MSAA
		PLV_UninitMSAA(lpPlv);
#endif
		MemFree(lpPlv);
	}
	return;
}

INT PLV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= nMin;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nPage;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	return 0;
} 

INT PLV_GetScrollTrackPos(HWND hwnd)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_ALL;
	GetScrollInfo(hwnd, SB_VERT, &scrInfo);
	return scrInfo.nTrackPos;
}

INT WINAPI PadListView_SetExtendStyle(HWND hwnd, INT style)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		Dbg(("Internal ERROR\n"));
		return 0;
	}
	if(lpPlvData->hwndHeader) {
		INT s = (INT)GetWindowLong(lpPlvData->hwndHeader, GWL_STYLE);
		SetWindowLong(lpPlvData->hwndHeader, GWL_STYLE, (LONG)(s & ~HDS_BUTTONS));
	}
	return 0;
	Unref(style);
}


//////////////////////////////////////////////////////////////////
// Function : PadListView_GetWidthByColumn
// Type     : INT WINAPI
// Purpose  : Calc PLV's window width by specified Column count
//			: This is PLVS_ICONVIEW style only.
// Args     : 
//          : HWND hwnd		PadListView window handle
//          : INT col		column count
// Return   : width by pixel.
// DATE     : 971120
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_GetWidthByColumn(HWND hwnd, INT col)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return IconView_GetWidthByColumn(lpPlv, col);	
}


//////////////////////////////////////////////////////////////////
// Function : PadListView_GetHeightByRow
// Type     : INT WINAPI
// Purpose  : Calc PLV's window height
//			  by specified Row count.
//			  This is PLVS_ICONVIEW style only.
// Args     : 
//          : HWND hwnd		PLV's window handle
//          : INT row		row count
// Return   : height in pixel
// DATE     : 971120
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_GetHeightByRow(HWND hwnd, INT row)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return IconView_GetHeightByRow(lpPlv, row);	
}

//////////////////////////////////////////////////////////////////
// Function	:	PadListView_SetHeaderFont
// Type		:	INT WINAPI 
// Purpose	:	
// Args		:	
//			:	HWND	hwnd	
//			:	LPSTR	lpstrFontName	
// Return	:	
// DATE		:	Tue Jul 28 08:58:06 1998
// Histroy	:	
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetHeaderFont(HWND hwnd, LPTSTR lpstrFontName)
{
	Dbg(("PadListView_SetHeaderFont  START\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	INT point = 9;
	if(!lpPlvData) {
		Dbg(("PadListView_SetHeaderFont ERROR\n"));
		return 0;
	}

	HFONT hFont;
	::ZeroMemory(&g_logFont, sizeof(g_logFont));

	HDC hDC = ::GetDC(hwnd);
	INT dpi = ::GetDeviceCaps(hDC, LOGPIXELSY);
	if(-1 == GetLogFont(hDC, lpstrFontName, &g_logFont)) {
		::ReleaseDC(hwnd, hDC);
		return -1;
	}
	::ReleaseDC(hwnd, hDC);
	g_logFont.lfHeight		   = - (point * dpi)/72;
	g_logFont.lfWidth		   = 0;

	hFont = CreateFontIndirect(&g_logFont);
	if(!hFont) {
		Dbg(("CreatFontIndirect Error\n"));
		return -1;
	}
	if(lpPlvData->hFontHeader) {
		::DeleteObject(lpPlvData->hFontHeader);
	}
	lpPlvData->hFontHeader = hFont;
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function	:	PadListView_SetCodePage
// Type		:	INT WINAPI
// Purpose	:	
// Args		:	
//			:	HWND	hwnd	
//			:	INT	codePage	
// Return	:	
// DATE		:	Tue Jul 28 08:59:35 1998
// Histroy	:	
//////////////////////////////////////////////////////////////////
INT WINAPI PadListView_SetCodePage(HWND hwnd, INT codePage)
{
	Dbg(("PadListView_SetCodePage  START\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(lpPlvData) {
		lpPlvData->codePage = codePage;
	}
	return 0; 
}

#ifdef MSAA
//////////////////////////////////////////////////////////////////
// Functions : MSAA Support Functions
// DATE     : 980724
//////////////////////////////////////////////////////////////////

BOOL PLV_InitMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return FALSE;
	lpPlv->bMSAAAvailable = FALSE;

	lpPlv->bCoInitialized = FALSE;
	lpPlv->hOleAcc = NULL;
	lpPlv->pfnLresultFromObject = NULL;
#ifdef NOTUSED
	lpPlv->pfnObjectFromLresult = NULL;
	lpPlv->pfnAccessibleObjectFromWindow = NULL;
	lpPlv->pfnAccessibleObjectFromPoint = NULL;
#endif
	lpPlv->pfnCreateStdAccessibleObject = NULL;
#ifdef NOTUSED
	lpPlv->pfnAccessibleChildren = NULL;
#endif
	lpPlv->hUser32 = NULL;
	lpPlv->pfnNotifyWinEvent=NULL;
	
	lpPlv->bReadyForWMGetObject=FALSE;
	lpPlv->pAccPLV = NULL;

	if(!PLV_LoadOleAccForMSAA(lpPlv))
		return FALSE;

	if(!PLV_LoadUser32ForMSAA(lpPlv)){
		PLV_UnloadOleAccForMSAA(lpPlv);
		return FALSE;
	}

	if(!PLV_CoInitialize(lpPlv)){
		PLV_UnloadUser32ForMSAA(lpPlv);
		PLV_UnloadOleAccForMSAA(lpPlv);
		return FALSE;
	}
	
	lpPlv->bMSAAAvailable = TRUE;

	return TRUE;
}

void PLV_UninitMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return;

	if(lpPlv->bMSAAAvailable){
		PLV_CoUninitialize(lpPlv);
		PLV_UnloadUser32ForMSAA(lpPlv);
		PLV_UnloadOleAccForMSAA(lpPlv);
		lpPlv->bMSAAAvailable = FALSE;
	}
}

BOOL PLV_CoInitialize(LPPLVDATA lpPlv)
{
	if(lpPlv && !lpPlv->bCoInitialized &&
	   SUCCEEDED(CoInitialize(NULL)))
		lpPlv->bCoInitialized = TRUE;

	return lpPlv->bCoInitialized;
}

void PLV_CoUninitialize(LPPLVDATA lpPlv)
{
	if(lpPlv && lpPlv->bCoInitialized){
		CoUninitialize();
		lpPlv->bCoInitialized = FALSE;
	}
}

BOOL PLV_LoadOleAccForMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return FALSE;

	lpPlv->hOleAcc=::LoadLibrary("oleacc.dll");
	if(!lpPlv->hOleAcc)
		return FALSE;

	if((lpPlv->pfnLresultFromObject
		=(LPFNLRESULTFROMOBJECT)::GetProcAddress(lpPlv->hOleAcc,"LresultFromObject"))
#ifdef NOTUSED
	   && (lpPlv->pfnObjectFromLresult
		   =(LPFNOBJECTFROMLRESULT)::GetProcAddress(lpPlv->hOleAcc,"ObjectFromLresult"))
	   && (lpPlv->pfnAccessibleObjectFromWindow
		   =(LPFNACCESSIBLEOBJECTFROMWINDOW)::GetProcAddress(lpPlv->hOleAcc,"AccessibleObjectFromWindow"))
	   && (lpPlv->pfnAccessibleObjectFromPoint
		   =(LPFNACCESSIBLEOBJECTFROMPOINT)::GetProcAddress(lpPlv->hOleAcc,"AccessibleObjectFromPoint"))
#endif
	   && (lpPlv->pfnCreateStdAccessibleObject
		   =(LPFNCREATESTDACCESSIBLEOBJECT)::GetProcAddress(lpPlv->hOleAcc,"CreateStdAccessibleObject"))
#ifdef NOTUSED
	   && (lpPlv->pfnAccessibleChildren
		   =(LPFNACCESSIBLECHILDREN)::GetProcAddress(lpPlv->hOleAcc,"CreateAccessibleChildren"))
#endif
	  )
			return TRUE;

	PLV_UnloadOleAccForMSAA(lpPlv);
	return FALSE;
}

void PLV_UnloadOleAccForMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return;

	if(lpPlv->hOleAcc){
		::FreeLibrary(lpPlv->hOleAcc);
		lpPlv->hOleAcc = NULL;
	}
	lpPlv->pfnLresultFromObject=NULL;
#ifdef NOTUSED
	lpPlv->pfnObjectFromLresult=NULL;
	lpPlv->pfnAccessibleObjectFromWindow=NULL;
	lpPlv->pfnAccessibleObjectFromPoint=NULL;
#endif
	lpPlv->pfnCreateStdAccessibleObject=NULL;
#ifdef NOTUSED
	lpPlv->pfnAccessibleChildren=NULL;
#endif
}

BOOL PLV_LoadUser32ForMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return FALSE;

	lpPlv->hUser32=::LoadLibrary("user32.dll");
	if(!lpPlv->hUser32)
		return FALSE;

	if((lpPlv->pfnNotifyWinEvent
		=(LPFNNOTIFYWINEVENT)::GetProcAddress(lpPlv->hUser32,"NotifyWinEvent")))
		return TRUE;

	PLV_UnloadUser32ForMSAA(lpPlv);
	return FALSE;
}

void PLV_UnloadUser32ForMSAA(LPPLVDATA lpPlv)
{
	if(!lpPlv)
		return;

	if(lpPlv->hUser32){
		::FreeLibrary(lpPlv->hUser32);
		lpPlv->hUser32 = NULL;
	}
	lpPlv->pfnNotifyWinEvent = NULL;
}

BOOL PLV_IsMSAAAvailable(LPPLVDATA lpPlv)
{
	return (lpPlv && lpPlv->bMSAAAvailable);
}

LRESULT PLV_LresultFromObject(LPPLVDATA lpPlv,REFIID riid, WPARAM wParam, LPUNKNOWN punk)
{
	if(lpPlv && lpPlv->pfnLresultFromObject)
		return lpPlv->pfnLresultFromObject(riid, wParam, punk);

	return (LRESULT)E_FAIL;
}

#ifdef NOTUSED
HRESULT PLV_ObjectFromLresult(LPPLVDATA lpPlv,LRESULT lResult, REFIID riid, WPARAM wParam, void** ppvObject)
{
	if(lpPlv && lpPlv->pfnObjectFromLresult)
		return lpPlv->pfnObjectFromLresult(lResult, riid, wParam, ppvObject);
	return E_FAIL;
}

HRESULT PLV_AccessibleObjectFromWindow(LPPLVDATA lpPlv,HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject)
{
	if(lpPlv && lpPlv->pfnAccessibleObjectFromWindow)
		return lpPlv->pfnAccessibleObjectFromWindow(hwnd, dwId, riid, ppvObject);
	return E_FAIL;
}

HRESULT PLV_AccessibleObjectFromPoint(LPPLVDATA lpPlv,POINT ptScreen, IAccessible ** ppacc, VARIANT* pvarChild)
{
	if(lpPlv && lpPlv->pfnAccessibleObjectFromPoint)
		return lpPlv->pfnAccessibleObjectFromPoint(ptScreen, ppacc, pvarChild);
	return E_FAIL;
}
#endif // NOTUSED

HRESULT PLV_CreateStdAccessibleObject(LPPLVDATA lpPlv,HWND hwnd, LONG idObject, REFIID riid, void** ppvObject)
{
	if(lpPlv && lpPlv->pfnCreateStdAccessibleObject)
		return lpPlv->pfnCreateStdAccessibleObject(hwnd, idObject, riid, ppvObject);
	return E_FAIL;
}

#ifdef NOTUSED
HRESULT PLV_AccessibleChildren (LPPLVDATA lpPlv,IAccessible* paccContainer, LONG iChildStart,				
								LONG cChildren, VARIANT* rgvarChildren,LONG* pcObtained)
{
	if(lpPlv && lpPlv->pfnAccessibleChildren)
		return lpPlv->pfnAccessibleChildren (paccContainer, iChildStart,cChildren,
											 rgvarChildren, pcObtained);
	return E_FAIL;
}
#endif

void PLV_NotifyWinEvent(LPPLVDATA lpPlv,DWORD event,HWND hwnd ,LONG idObject,LONG idChild)
{
	if(lpPlv && lpPlv->pfnNotifyWinEvent)
		lpPlv->pfnNotifyWinEvent(event,hwnd,idObject,idChild);
}

INT PLV_ChildIDFromPoint(LPPLVDATA lpPlv,POINT pt)
{
	if(!lpPlv)
		return -1;

	static INT		index,nCol,nWid;
	static PLVINFO	plvInfo;
	static HD_ITEM	hdItem;
	
	if(lpPlv->dwStyle == PLVSTYLE_ICON) // iconview
		index = IV_GetInfoFromPoint(lpPlv, pt, &plvInfo);
	else { // report view
		nCol = RV_GetColumn(lpPlv);
		index = RV_GetInfoFromPoint(lpPlv, pt, &plvInfo);
		if(index < 0) {
			if(pt.y > RV_GetHeaderHeight(lpPlv)) // out of header
				return -1;

			// header
			nWid = 0;
			hdItem.mask = HDI_WIDTH;
			hdItem.fmt = 0;
			for(index = 0;index<nCol;index++){
				Header_GetItem(lpPlv->hwndHeader,index,&hdItem);
				nWid += hdItem.cxy;
				if(pt.x <= nWid)
					break;
			}
		}
		else
			index = (index + 1) * nCol + plvInfo.colIndex;
	}
	
	return index + 1; // 1 origin
}

#endif // MSAA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvproc_.h ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "dispatch.h"

#ifdef MSAA
#include "plv_.h"
static LRESULT MsgGetObject			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgShowWindow		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif

static LRESULT MsgCreate			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgDestroy			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgPaint				(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgSize				(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgTimer				(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgNcMouseMove		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgMouseMove			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgLMRButtonDblClk	(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgLMRButtonDown		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgLMRButtonUp		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgCaptureChanged	(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgVScroll			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgNotify			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgCommand			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgMeasureItem		(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT MsgDrawItem			(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static LRESULT CmdDefault			(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl);

static MSD rgmsd[] =
{
	{ WM_CREATE,		MsgCreate		},
    { WM_DESTROY,		MsgDestroy		},
	{ WM_PAINT,			MsgPaint		},
	{ WM_NOTIFY,		MsgNotify		},
	{ WM_SIZE,			MsgSize			},
	{ WM_TIMER,			MsgTimer		},
	{ WM_NCMOUSEMOVE,	MsgNcMouseMove	},
	{ WM_MOUSEMOVE,		MsgMouseMove	},

	{ WM_LBUTTONDBLCLK,	MsgLMRButtonDblClk},
	{ WM_MBUTTONDBLCLK,	MsgLMRButtonDblClk},
	{ WM_RBUTTONDBLCLK,	MsgLMRButtonDblClk},

	{ WM_LBUTTONDOWN,	MsgLMRButtonDown},
	{ WM_MBUTTONDOWN,	MsgLMRButtonDown},
	{ WM_RBUTTONDOWN,	MsgLMRButtonDown},

	{ WM_LBUTTONUP,		MsgLMRButtonUp	},
	{ WM_MBUTTONUP,		MsgLMRButtonUp	},
	{ WM_RBUTTONUP,		MsgLMRButtonUp	},

	{ WM_CAPTURECHANGED,MsgCaptureChanged},
	{ WM_VSCROLL,		MsgVScroll		},
    { WM_NOTIFY,		MsgNotify		},
	{ WM_COMMAND,		MsgCommand		},
	{ WM_MEASUREITEM,	MsgMeasureItem	},	//for AcitveIME support
	{ WM_DRAWITEM,		MsgDrawItem		},	//for ActiveIME support	
#ifdef MSAA
	{ WM_GETOBJECT,		MsgGetObject		},
	{ WM_SHOWWINDOW,	MsgShowWindow		},
#endif
};

static MSDI msdiMain =
{
    sizeof(rgmsd) / sizeof(MSD),
    rgmsd,
	edwpWindow,
    //edwpNone, 
};

static CMD rgcmd[] =
{
	{ 0,		CmdDefault	},
};

static CMDI cmdiMain =
{
    sizeof(rgcmd) / sizeof(CMD),
    rgcmd,
    edwpWindow
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvproc.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include "dispatch.h"
#include "plv.h"
#include "plv_.h"
#include "plvproc.h"
#include "plvproc_.h"
#include "dbg.h"
#include "iconview.h"
#include "repview.h"
#include "exgdiw.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

#ifdef MSAA
#include "accplv.h"
#endif

extern LPPLVDATA PLV_Initialize(VOID);
extern VOID PLV_Destroy(LPPLVDATA lpPlv);
extern INT PLV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos);
extern INT PLV_GetScrollTrackPos(HWND hwnd);


LRESULT CALLBACK PlvWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LRESULT hres;
	hres = DispMessage(&msdiMain, hwnd, uMsg, wParam, lParam);
	return hres;
}

////////////////////////////////////////////////////////
// Function : MsgCreate
// Type     : static LRESULT
// Purpose  : Process WM_CREATE message.
//			  Intialize PLVDATA and associate to window handle.
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
static LRESULT MsgCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = (LPPLVDATA)((LPCREATESTRUCT)lParam)->lpCreateParams;
	if(!lpPlvData) {
		return -1;		// create error
	}
	lpPlvData->hwndSelf = hwnd;
	SetPlvDataToHWND(hwnd, lpPlvData);
	//show scroll bar always
	//----------------------------------------------------------------
	// if header window is not created yet, create it.
	//----------------------------------------------------------------
	if(!lpPlvData->hwndHeader)  {
		lpPlvData->hwndHeader = RepView_CreateHeader(lpPlvData);
	}
	PLV_SetScrollInfo(hwnd, 0,0,0,0);
	return TRUE;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgPaint
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgPaint(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	//OutputDebugString("MsgPaint 1 START\n");
	DP(("MsgPaint COME\n"));
	if(!lpPlvData) {
		//OutputDebugString("MsgPaint 1 END\n");
		return 0;
	}
	DP(("MsgPaint lpPlvData->dwStyle [%d]n", lpPlvData->dwStyle));
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		//OutputDebugString("MsgPaint 1 Icon\n");
		IconView_Paint(hwnd, wParam, lParam);
	}
	else {
		//OutputDebugString("MsgPaint 1 Rep\n");
		RepView_Paint(hwnd, wParam, lParam);
	}
	DP(("MsgPaint END\n"));
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgVScroll
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgVScroll(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_VScroll(hwnd, wParam, lParam);
	}
	else {
		RepView_VScroll(hwnd, wParam, lParam);
	}
	return 0;
	UnrefForMsg();
}

////////////////////////////////////////////////////////
// Function : MsgDestroy
// Type     : static LRESULT
// Purpose  : Process WM_DESTORY message
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
static LRESULT MsgDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->hwndHeader) {
		::DestroyWindow(lpPlvData->hwndHeader);
		lpPlvData->hwndHeader = NULL;
	}
	if(lpPlvData->hFontIcon) {
		::DeleteObject(lpPlvData->hFontIcon);
		lpPlvData->hFontIcon = NULL;
	}
	if(lpPlvData->hFontRep) {
		::DeleteObject(lpPlvData->hFontRep);
		lpPlvData->hFontRep = NULL;
	}
	if(lpPlvData->hFontHeader) {
		::DeleteObject(lpPlvData->hFontHeader);
		lpPlvData->hFontHeader = NULL; 
	}
	
#ifdef MSAA
	lpPlvData->bReadyForWMGetObject = FALSE;
	if(lpPlvData->pAccPLV) {
		CoDisconnectObject((LPUNKNOWN) lpPlvData->pAccPLV, 0L);
		delete lpPlvData->pAccPLV;
		lpPlvData->pAccPLV = NULL;
		PLV_NotifyWinEvent(lpPlvData,
						   EVENT_OBJECT_DESTROY,
						   hwnd,
						   OBJID_CLIENT,
						   CHILDID_SELF);
	}
#endif

#if 1 // kwada
	PLV_Destroy(lpPlvData);
#else
	MemFree(lpPlvData);
#endif
	SetPlvDataToHWND(hwnd, (LPPLVDATA)NULL);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgSize
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgSize(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	//INT nWidth	= LOWORD(lParam);
	//INT nHeight = HIWORD(lParam);
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	RECT rc;

	Dbg(("MsgSize COME\n"));
	if(lpPlvData->hwndHeader && lpPlvData->dwStyle == PLVSTYLE_REPORT) {
		GetClientRect(lpPlvData->hwndSelf, &rc); // get PadListView's client rect
		HD_LAYOUT hdl;
		WINDOWPOS wp;
		hdl.prc = &rc;
		hdl.pwpos = &wp;
		//Calc header control window size
		if(Header_Layout(lpPlvData->hwndHeader, &hdl) == FALSE) {
			//OutputDebugString("Create Header Layout error\n");
			return NULL;
		}
		SetWindowPos(lpPlvData->hwndHeader, wp.hwndInsertAfter, wp.x, wp.y,
					 wp.cx, wp.cy, wp.flags | SWP_SHOWWINDOW);
	}
	else {
		Dbg(("Header is NULL\n"));
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_ResetScrollRange(lpPlvData);
	}
	else {
		RepView_ResetScrollRange(lpPlvData);
	}
	UpdateWindow(hwnd);
	return 0;
	UnrefForMsg();
}

static LRESULT MsgTimer(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static RECT  rc; 
	static POINT pt;
	if(wParam == TIMERID_MONITOR) {
		GetCursorPos(&pt);
		GetWindowRect(hwnd, &rc);
		if(!PtInRect(&rc, pt)) {
			KillTimer(hwnd, wParam);
			InvalidateRect(hwnd, NULL, FALSE);
		}
	}
	return 0;
	Unref(uMsg);
	Unref(lParam);
}
//////////////////////////////////////////////////////////////////
// Function : MsgLMRButtonDown
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgLMRButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_ButtonDown(hwnd, uMsg, wParam, lParam);
	}
	else {
		RepView_ButtonDown(hwnd, uMsg, wParam, lParam);
	}
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgLMRButtonDblClk
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgLMRButtonDblClk(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_ButtonDown(hwnd, uMsg, wParam, lParam);
	}
	else {
		RepView_ButtonDown(hwnd, uMsg, wParam, lParam);
	}
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgLMRButtonUp
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgLMRButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_ButtonUp(hwnd, uMsg, wParam, lParam);
	}
	else {
		RepView_ButtonUp(hwnd, uMsg, wParam, lParam);
	}
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgMouseMove
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgMouseMove(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if(lpPlvData->dwStyle == PLVSTYLE_ICON) {
		IconView_MouseMove(hwnd, wParam, lParam);
	}
	else {
		RepView_MouseMove(hwnd, wParam, lParam);
	}
	KillTimer(hwnd, TIMERID_MONITOR);
	SetTimer(hwnd, TIMERID_MONITOR, 100, NULL);
	return 0;
	UnrefForMsg();
}

static LRESULT MsgNcMouseMove(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	InvalidateRect(hwnd, NULL, FALSE);
	return 0;
	UnrefForMsg();
}

//////////////////////////////////////////////////////////////////
// Function : MsgCaptureChanged
// Type     : static LRESULT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static LRESULT MsgCaptureChanged(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
 	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	if((HWND)wParam != hwnd) { // some other window captured mouse.
		lpPlvData->iCapture = CAPTURE_NONE;
	}
	return 0;
	UnrefForMsg();
}

////////////////////////////////////////////////////////
// Function : MsgNotify
// Type     : static LRESULT
// Purpose  : Process WM_NOTIFY message.
//			: currently for Tab Control window.
// Args     : 
//          : HWND hwnd 
//          : UINT uMsg 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
/////////////////////////////
//typedef struct tagNMHDR
//{
//    HWND  hwndFrom;
//    UINT  idFrom;
//    UINT  code;         // NM_ code
//}   NMHDR;
//typedef NMHDR FAR * LPNMHDR;
/////////////////////////////
static LRESULT MsgNotify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	INT     idCtrl = (INT)wParam;

	switch(idCtrl) {
	case HEADER_ID:
		RepView_Notify(hwnd, uMsg, wParam, lParam);
		break;
	}
	return 0; 
	UnrefForMsg();
}

static LRESULT MsgCommand(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DispCommand(&cmdiMain, hwnd, wParam, lParam);
	UnrefForMsg();
}

static LRESULT MsgMeasureItem(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return 0;
	UnrefForMsg();
}

static LRESULT MsgDrawItem(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	Dbg(("MsgDrawItem START\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;
	switch(lpdis->CtlType) {
	case ODT_HEADER:
		{
			static WCHAR wchBuf[256];
#ifndef UNDER_CE // always Unicode
			if(::IsWindowUnicode(lpdis->hwndItem)) {
#endif // UNDER_CE
				HDITEMW hdItem;
				::ZeroMemory(&hdItem, sizeof(hdItem));
				hdItem.mask = HDI_TEXT | HDI_HEIGHT;
				wchBuf[0] = (WCHAR)0x00;
				hdItem.pszText     = wchBuf;
				hdItem.cchTextMax  = sizeof(wchBuf);
				::SendMessageW(lpdis->hwndItem,
							   HDM_GETITEMW,
							   (WPARAM)lpdis->itemID,
							   (LPARAM)&hdItem);
				DBGW((L"%d: %s\n", lpdis->itemID, wchBuf));
#ifndef UNDER_CE // always Unicode
			}
			else {
				HDITEMA hdItem;
				static char szBuf[256];
				::ZeroMemory(&hdItem, sizeof(hdItem));
				hdItem.mask = HDI_TEXT | HDI_HEIGHT;
				szBuf[0] = (CHAR)0x00;
				hdItem.pszText     = szBuf;
				hdItem.cchTextMax  = sizeof(szBuf);
				::SendMessageA(lpdis->hwndItem,
							   HDM_GETITEMA,
							   (WPARAM)lpdis->itemID,
							   (LPARAM)&hdItem);
				//Dbg(("%d: %s\n", lpdis->itemID, szBuf));
				MultiByteToWideChar(lpPlvData->codePage, 
									MB_PRECOMPOSED,
									szBuf, -1,
									(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
			}
#endif // UNDER_CE
			SIZE size;
			INT offsetX, offsetY;
			HFONT hFontPrev = NULL;
			if(lpPlvData->hFontHeader) {
				hFontPrev = (HFONT)::SelectObject(lpdis->hDC, lpPlvData->hFontHeader);
			}
			::ExGetTextExtentPoint32W(lpdis->hDC,
									  wchBuf,
									  lstrlenW(wchBuf),
									  &size);
			offsetX = GetSystemMetrics(SM_CXDLGFRAME);
			offsetY = (lpdis->rcItem.bottom - lpdis->rcItem.top - size.cy)/2;
			::ExExtTextOutW(lpdis->hDC,
						  lpdis->rcItem.left+offsetX,
						  lpdis->rcItem.top+offsetY,
						  ETO_CLIPPED,
						  &lpdis->rcItem,
						  wchBuf,
						  lstrlenW(wchBuf),
						  NULL);
			if(lpPlvData->hFontHeader) {
				::SelectObject(lpdis->hDC, hFontPrev);
			}
		}
		break;
	default:
		break;
	}
	return TRUE; 
	UnrefForMsg();
}

static LRESULT CmdDefault(HWND hwnd, WORD wCommand, WORD wNotify, HWND hwndCtrl)
{
	return 0;
	UnrefForCmd();
}

#ifdef MSAA
static LRESULT MsgGetObject(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	if(!PLV_IsMSAAAvailable(lpPlvData))
		return E_FAIL;

	if(!lpPlvData->bReadyForWMGetObject)
		return E_FAIL;
	
	if(OBJID_CLIENT == lParam) {
		if(!lpPlvData->pAccPLV){
			lpPlvData->pAccPLV = new CAccPLV;
			if(!lpPlvData->pAccPLV)
				return (LRESULT)E_OUTOFMEMORY;

			HRESULT hr;
			hr = lpPlvData->pAccPLV->Initialize(hwnd);
			if(FAILED(hr)){
				delete lpPlvData->pAccPLV;
				lpPlvData->pAccPLV = NULL;
				return (LRESULT)hr;
			}
			PLV_NotifyWinEvent(lpPlvData,
							   EVENT_OBJECT_CREATE,
							   hwnd,
							   OBJID_CLIENT,
							   CHILDID_SELF);
		}
		return lpPlvData->pAccPLV->LresultFromObject(wParam);
	}

	return (HRESULT)0L;
	UnrefForMsg();
}

static LRESULT MsgShowWindow(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);

	if(PLV_IsMSAAAvailable(lpPlvData))
	{
		if(!lpPlvData->bReadyForWMGetObject)
			lpPlvData->bReadyForWMGetObject = TRUE;
		PLV_NotifyWinEvent(lpPlvData ,
						   wParam ? EVENT_OBJECT_SHOW : EVENT_OBJECT_HIDE,
						   hwnd,
						   OBJID_CLIENT,
						   CHILDID_SELF );
	}
	return DispDefault(msdiMain.edwp, hwnd, uMsg, wParam, lParam);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plv_.h ===
#ifndef _PLV__H_
#define _PLV__H_
#include "plv.h"

#ifdef MSAA
#include <ole2.h>
//980112 ToshiaK: VC6 has these include files.
//#include "../msaa/inc32/oleacc.h"
//#include "../msaa/inc32/winable.h"
#include <oleacc.h>
#include <winable.h>

#if(WINVER >= 0x0400)
#define WMOBJ_ID                        0x0000
#define WM_GETOBJECT                    0x003D
#endif /* WINVER >= 0x0400 */


typedef HRESULT (STDAPICALLTYPE * LPFNCOINITIALIZE)(LPVOID pvReserved);
typedef void (STDAPICALLTYPE * LPFNCOUNINITIALIZE)(void);
typedef WINABLEAPI void (WINAPI *LPFNNOTIFYWINEVENT)(DWORD,HWND,LONG,LONG);
class CAccPLV;
#endif // MSAA

#define ArrayCount(a)		(sizeof(a)/sizeof(a[0]))
#define UnrefForMsg()	UNREFERENCED_PARAMETER(hwnd);\
						UNREFERENCED_PARAMETER(uMsg);\
						UNREFERENCED_PARAMETER(wParam);\
						UNREFERENCED_PARAMETER(lParam)

#define UnrefForCmd()	UNREFERENCED_PARAMETER(hwnd);\
						UNREFERENCED_PARAMETER(wCommand);\
						UNREFERENCED_PARAMETER(wNotify);\
						UNREFERENCED_PARAMETER(hwndCtrl)

#define Unref(a)		UNREFERENCED_PARAMETER(a)

#define Unref1(a)		UNREFERENCED_PARAMETER(a)

#define Unref2(a, b)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b)

#define Unref3(a,b,c)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b);\
						UNREFERENCED_PARAMETER(c)

#define Unref4(a,b,c,d)	UNREFERENCED_PARAMETER(a);\
						UNREFERENCED_PARAMETER(b);\
						UNREFERENCED_PARAMETER(c);\
						UNREFERENCED_PARAMETER(d)

//----------------------------------------------------------------
// Default Icon view's width & height
//----------------------------------------------------------------
#define WHOLE_WIDTH		40		//default
#define WHOLE_HEIGHT	40		//default
#define XMARGIN			5	
#define YMARGIN			5
#define XRECT_MARGIN	4
#define YRECT_MARGIN	4
#define PLV_REPRECT_XMARGIN			2
#define PLV_REPRECT_YMARGIN			2

#define PLV_EDGE_NONE				0
#define PLV_EDGE_SUNKEN				1
#define PLV_EDGE_RAISED				2


#define PLVICON_DEFAULT_WIDTH		40
#define PLVICON_DEFAULT_HEIGHT		40
#define PLVICON_DEFAULT_FONTPOINT	16

#define PLVREP_DEFAULT_WIDTH		100
#define PLVREP_DEFAULT_HEIGHT		20
#define PLVREP_DEFAULT_FONTPOINT	9

//----------------------------------------------------------------
//970929: for #1964. do not pop for RButtonDown. 
//LPPLVDATA->iCapture data.
//----------------------------------------------------------------
#define CAPTURE_NONE		0	
#define CAPTURE_LBUTTON		1
#define CAPTURE_MBUTTON		2
#define CAPTURE_RBUTTON		3

#if 0
This sample is Capital Letter "L, N"
                   <-nItemWidth->
                   < >  XRECT_MARGIN
      YMARGIN +  +---------------------------------------------------------------------
              +  | +------------++------------+     +
                 | | +--------+ || +--------+ |     |     
                 | | | *      | || | *    * | |     |     
                 | | | *      | || | * *  * | |nItemHeight
                 | | | *      | || | *  * * | |     |     
                 | | | ****** | || | *    * | |     |     
                 | | +--------+ || +--------+ |     |     
                 | +------------++------------+     +
                >| <--- XMARGIN
                 |
#endif


//----------------------------------------------------------------
//Pad List view internal Data structure.
//----------------------------------------------------------------
typedef struct tagPLVDATA {
	DWORD		dwSize;				//this data size;
	DWORD		dwStyle;			//Pad listview window style (PLVIF_XXXX)
	HINSTANCE	hInst;				//Instance handle.
	HWND		hwndSelf;			//Pad listview window handle.
	INT			iItemCount;			//Virtual total item Count. it effects scroll bar.
	INT			iCurTopIndex;		//In report view top line item index.
	INT			nCurScrollPos;		//In report view Current Scroll posision.
	INT			iCurIconTopIndex;	//In Icon view, top-left corner virtual index.
	INT			nCurIconScrollPos;	//In Icon view, top-left corner virtual index.
	UINT		uMsg;				//Notify message for parent window.
	INT			iCapture;			//Captured with which button(Left, Middle Right).
	POINT		ptCapture;			//LButton Down mouse point.  
	UINT		uMsgDown;			//L,M,R button down message.
	//----------------------------------------------------------------
	//for Icon view
	//----------------------------------------------------------------
	INT			nItemWidth;			// List(Icon like )view's whole width.
	INT			nItemHeight;		// List(Icon like )view's whole height.
	INT			iFontPointIcon;		// Icon View's font point.
	HFONT		hFontIcon;			// Icon View's font
	LPARAM		iconItemCallbacklParam;	// Callback data for LPFNPLVITEMCALLBACK
	LPFNPLVICONITEMCALLBACK		lpfnPlvIconItemCallback;		//Callback function for getting item by index.
	//----------------------------------------------------------------
	//for report view
	//----------------------------------------------------------------
	HWND		hwndHeader;			//Header control's window handle .
	INT			nRepItemWidth;			//Report view's width.
	INT			nRepItemHeight;			//Report view's height.
	INT			iFontPointRep;		// Report View's font point.
	HFONT		hFontRep;			// Report View's font.
	LPARAM		repItemCallbacklParam; //Callback data for LPFNPLVREPITEMCALLBACK.
	LPFNPLVREPITEMCALLBACK		lpfnPlvRepItemCallback;		//Callback function for getting colitem by index.
	//----------------------------------------------------------------
	//for Explanation Text
	//----------------------------------------------------------------
	LPSTR 	lpText;	 // pointer to an explanation text in either ICONVIEW or REPORTVIEW
	LPWSTR 	lpwText; // pointer to an explanation text in either ICONVIEW or REPORTVIEW
	UINT	codePage;			//M2W, W2M's codepage.	//980724
	HFONT	hFontHeader;		//Header control font.	//980724
#ifdef MSAA
	BOOL bMSAAAvailable;
	BOOL bCoInitialized;
	
	HINSTANCE	hOleAcc;
	LPFNLRESULTFROMOBJECT			pfnLresultFromObject;
#ifdef NOTUSED	
	LPFNOBJECTFROMLRESULT			pfnObjectFromLresult;
	LPFNACCESSIBLEOBJECTFROMWINDOW	pfnAccessibleObjectFromWindow;
	LPFNACCESSIBLEOBJECTFROMPOINT	pfnAccessibleObjectFromPoint;
#endif // NOTUSED
	LPFNCREATESTDACCESSIBLEOBJECT	pfnCreateStdAccessibleObject;
#ifdef NOTUSED
	LPFNACCESSIBLECHILDREN			pfnAccessibleChildren;
#endif // NOTUSED

	HINSTANCE	hUser32;
	LPFNNOTIFYWINEVENT	pfnNotifyWinEvent;

	BOOL	bReadyForWMGetObject;
	CAccPLV	*pAccPLV;
#endif
}PLVDATA, *LPPLVDATA;

//----------------------------------------------------------------
//TIMERID for monitoring mouse pos
//----------------------------------------------------------------
#define TIMERID_MONITOR 0x20
//////////////////////////////////////////////////////////////////
// Function : GetPlvDataFromHWND
// Type     : inline LPPLVDATA
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
inline LPPLVDATA GetPlvDataFromHWND(HWND hwnd)
{
#ifdef _WIN64
	return (LPPLVDATA)GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	return (LPPLVDATA)GetWindowLong(hwnd, GWL_USERDATA);
#endif
}

//////////////////////////////////////////////////////////////////
// Function : SetPlvDataToHWND
// Type     : inline LONG
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : LPPLVDATA lpPlvData 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
inline LPVOID SetPlvDataToHWND(HWND hwnd, LPPLVDATA lpPlvData)
{
#ifdef _WIN64
	return (LPVOID)SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpPlvData);
#else
	return (LPVOID)SetWindowLong(hwnd, GWL_USERDATA, (LONG)lpPlvData);
#endif
}

#ifdef MSAA
BOOL PLV_InitMSAA(LPPLVDATA);
void PLV_UninitMSAA(LPPLVDATA);

BOOL PLV_CoInitialize(LPPLVDATA);
void PLV_CoUninitialize(LPPLVDATA);

BOOL PLV_LoadOleAccForMSAA(LPPLVDATA);
void PLV_UnloadOleAccForMSAA(LPPLVDATA);
BOOL PLV_LoadUser32ForMSAA(LPPLVDATA);
void PLV_UnloadUser32ForMSAA(LPPLVDATA);
BOOL PLV_IsMSAAAvailable(LPPLVDATA);
LRESULT PLV_LresultFromObject(LPPLVDATA,REFIID riid, WPARAM wParam, LPUNKNOWN punk);
#ifdef NOTUSED
HRESULT PLV_ObjectFromLresult(LPPLVDATA,LRESULT lResult, REFIID riid, WPARAM wParam, void **ppvObject);
HRESULT PLV_AccessibleObjectFromWindow(LPPLVDATA,HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject);
HRESULT PLV_AccessibleObjectFromPoint(LPPLVDATA,POINT ptScreen, IAccessible ** ppacc, VARIANT* pvarChild);
#endif

HRESULT PLV_CreateStdAccessibleObject(LPPLVDATA,HWND hwnd, LONG idObject, REFIID riid, void** ppvObject);

#ifdef NOTUSED
HRESULT PLV_AccessibleChildren (LPPLVDATA,IAccessible* paccContainer, LONG iChildStart,				
								LONG cChildren, VARIANT* rgvarChildren,LONG* pcObtained);
#endif

void PLV_NotifyWinEvent(LPPLVDATA,DWORD,HWND,LONG,LONG);

INT PLV_ChildIDFromPoint(LPPLVDATA,POINT);
#endif // MSAA

#endif //_PLV__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plv.h ===
#ifndef _PAD_LIST_VIEW_H_
#define _PAD_LIST_VIEW_H_
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <commctrl.h>

#define WC_PADLISTVIEW		TEXT("PadListView")

//----------------------------------------------------------------
//PadListView's style. it is not compatible to WS_XXXX
//----------------------------------------------------------------
#define PLVSTYLE_ICON		0x0001
#define PLVSTYLE_REPORT		0x0002

//----------------------------------------------------------------
// PadListView display data's format
//----------------------------------------------------------------
#define PLVFMT_TEXT		0x0001			// Unicode string(NULL terminate)
#define PLVFMT_BITMAP	0x0002			// Bitmap

typedef struct tagPLVITEM {
	INT		fmt;			// PLVFMT_TEXT or PLVFMT_BITMAP. cannot set combination.
	union  {
		LPWSTR	lpwstr;
		HBITMAP	hBitmap;
	};
}PLVITEM, *LPPLVITEM;

//----------------------------------------------------------------
// commctrl.h's LV_COLUMNA
//----------------------------------------------------------------
#if 0
typedef struct _LV_COLUMNA
{
    UINT mask; 	 //LVCF_FMT, LVCF_WIDTH, LVCF_TEXT, LVCF_SUBITEM;
    int fmt;
    int cx;
    LPSTR pszText;
    int cchTextMax;
    int iSubItem;
} LV_COLUMNA;
#endif

//----------------------------------------------------------------
// PLV_COLUMN is same as LV_COLMUNA
// to insert header control to PadListView.
// PadListView uses Header contorol as child window.
// Interface (PadListView_Insert(Delete)Column uses common control
// (commctrl.h)'s LV_COLUMNA structure.
//----------------------------------------------------------------
#ifndef UNDER_CE // always Unicode
#define PLV_COLUMN				LV_COLUMNA
#else // UNDER_CE
#define PLV_COLUMN				LV_COLUMNW
#endif // UNDER_CE

#define PLVCF_FMT               LVCF_FMT
#define PLVCF_WIDTH             LVCF_WIDTH
#define PLVCF_TEXT              LVCF_TEXT
#define PLVCF_SUBITEM           LVCF_SUBITEM
#define PLVCF_SEPARATER			0x1000			// new define.

#define PLVCFMT_LEFT            LVCFMT_LEFT
#define PLVCFMT_RIGHT           LVCFMT_RIGHT
#define PLVCFMT_CENTER          LVCFMT_CENTER
#define PLVCFMT_JUSTIFYMASK     LVCFMT_JUSTIFYMASK

//----------------------------------------------------------------
//callback function's prototype declaration.

//----------------------------------------------------------------
// this is for PadListView's ICON VIEW callback to retrieve
// display item data by INDEX
//----------------------------------------------------------------
typedef INT (WINAPI *LPFNPLVICONITEMCALLBACK)(LPARAM lParam, INT index, LPPLVITEM lpPlvItem);

//----------------------------------------------------------------
//970705 spec changed, to performance up.
//----------------------------------------------------------------
// This is for PadListView's REPORT VIEW callback to retrieve  
// display item data by INDEX.
// you can specify data with index and column in lpPlvItemList.
// so, lpPlvItemList is PLVITEM's array pointer.
// array count is colCount, that is inserted by user.
#if 0
		+-----------+-----------+-----------+-----------+-----------+-----------+
header	| Column0	| Column1   | Column2   | Column3   | Colmun4   |           |
		+-----------+-----------+-----------+-----------+-----------+-----------+
index-9 |AAAA		  BBBB		  CCCC		 DDDD		 EEEE					|
		|-----------------------------------------------------------------------|
		|																		|
		|-----------------------------------------------------------------------|
		|
in this case to draw top line of report view, PadListView  call report view's call back function 
like this.

LPARAM	lParam	 = user defined data.
INT		index	 = 9;
INT		colCount = 5;
// create 
LPPLVITEM lpPlvItem = (LPPLVITEM)MemAlloc(sizeof(PLVITEM)* colCount); 
ZeroMemory(lpPlvItem, sizeof(PLVITEM)*colCount);

(*lpfnCallback)(lParam,			//user defined data.
				index,			//line index,
				colCount,		//column count,
				lpPlvItem);		//display item data array.

in your call back function, you can specify data like this.

INT WINAPI UserReportViewCallback(LPARAM lParam, INT index, INT colCount, LPPLVITEM lpPlvItemList)
{
	// get line data with index.
	UserGetLineDataWithIndex(index, &someStructure);
	for(i = 0; i < colCount, i++) {
		switch(i) { 
		case 0: // first column data.
			lpPlvItem[i].fmt = PLVFMT_TEXT; // or PLVFMT_BITMAP.
			lpPlvItem[i].lpwst = someStructure.lpwstr[i];
			break;
		case 1: // second column data.
			lpPlvItem[i].fmt = PLVFMT_TEXT;	// or PLVFMT_BITMAP.
			lpPlvItem[i].lpwst = someStructure.lpwstr[i];
			break;
			:
			:
		}
	}
	return 0;
 }
#endif
//----------------------------------------------------------------
typedef INT (WINAPI *LPFNPLVREPITEMCALLBACK)(LPARAM lParam, 
											 INT	index, 
											 INT	colCount, 
											 LPPLVITEM lpPlvItemList);


//----------------------------------------------------------------
// PadListView Notify code, data
// Notify message will be send to PadListView's parent window.
// user can specify their own Message Id when it created.
// see PadListView_CreateWindow(). 
// Notify message data is as follow's
// User Defined message.
// wID			= (INT)Window Id of PadListView.
// lpPlvInfo	= (LPPLVINFO)lParam. notify Info structure data pointer
//----------------------------------------------------------------
#define PLVN_ITEMPOPED				(WORD)1		//item data is poped image.
												//in icon view, all item notify come,
												//in report view, only first column.
#define PLVN_ITEMPUSHED				(WORD)2		//
#define PLVN_ITEMCLICKED			(WORD)3		//item data is clicked.
#define PLVN_ITEMDBLCLICKED			(WORD)4		//item data is double clicked
#define PLVN_ITEMCOLUMNCLICKED		(WORD)5		//not item but column is clicked(only in report view)
#define PLVN_ITEMCOLUMNDBLCLICKED	(WORD)6		//not item is column is clicked(only in report view)

#define PLVN_R_ITEMCLICKED			(WORD)7		//item data is clicked.
#define PLVN_R_ITEMDBLCLICKED		(WORD)8		//item data is double clicked
#define PLVN_R_ITEMCOLUMNCLICKED	(WORD)9		//not item but column is clicked(only in report view)
#define PLVN_R_ITEMCOLUMNDBLCLICKED	(WORD)10	//not item is column is clicked(only in report view)
#define PLVN_HDCOLUMNCLICKED		(WORD)20	//in Report view, header clicked.
												//in this case PLVINFO's colIndex is valid.
#define PLVN_VSCROLLED				(WORD)30	//970810: new.
#ifdef UNDER_CE // Windows CE used ButtonDown/Up Event for ToolTip
#define PLVN_ITEMDOWN				(WORD)41	//item data is downed.
#define PLVN_ITEMUP					(WORD)42	//item data is upped.
#endif // UNDER_CE

typedef struct tagPLVINFO {
	INT		code;		//PLVN_XXXX	
	INT		index;		//selected, or on item's index. it is same as wParam data.
	POINT	pt;			//mouse point in Pad listview client area
	RECT	itemRect;	//item's rectangle, 
	INT		colIndex;	//if style is report view,  column index is specifed.
	RECT	colItemRect;//if style is report view column rectangle is specified.
}PLVINFO, *LPPLVINFO;

//////////////////////////////////////////////////////////////////
// Function : PadListView_CreateWindow
// Type     : HWND
// Purpose  : Create PadListView control window.
// Args     : 
//          : HINSTANCE hInst		//instance handle
//          : HWND hwndParent		//Parent window handle 
//			: INT wID				//ChildWindow's Identifier.
//          : INT x					//horizontal position of window 
//          : INT y					//vertical position of window
//          : INT width				//window width
//          : INT height			//window height
//          : UINT uNotifyMsg		//notify message. it should be Greater than WM_USER
// Return	: PadListView's window handle
//////////////////////////////////////////////////////////////////
extern HWND WINAPI PadListView_CreateWindow(HINSTANCE hInst, 
									 HWND hwndParent, 
									 INT wID, 
									 INT x, 
									 INT y, 
									 INT width, 
									 INT height, 
									 UINT uNotifyMsg);

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetItemCount
// Type     : INT
// Purpose  : Get item count that was specified by user.
// Args     : 
//          : HWND hwnd 
// Return   : item count.(0<=)
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_GetItemCount(HWND hwnd);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetItemCount
// Type     : INT
// Purpose  : Set total Item's count to PadListView.
//			: it effect's scroll bar.
// Args     : 
//          : HWND hwnd 
//          : INT itemCount 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetItemCount(HWND hwnd, INT itemCount);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetTopIndex
// Type     : INT
// Purpose  : Set top index. Top index is left-top corner data(ICON VIEW)
//			: or top line(REPORT VIEW). index is ZERO-BASED. If top index is set as 10, 
//			: PadListView display index 10's item at left-top or top in client area.
//			: It means scroll bar is automatically scrolled.
//			: In ICON VIEW, PadListView re-calc top index. because, 
//			: top index should be Column data count * N.
//			: ICONV VIEW calc Column count from client width and item width.
//			: 100 item is set to PadListView, column count is 10,
//			: if user set top index as 5, it is re-calc to 0.
//			: if user set top index as 47, it is re-calc to 40.
// Args     : 
//          : HWND hwnd 
//          : INT indexTop 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetTopIndex(HWND hwnd, INT indexTop);

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetTopIndex
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
// Return   : Top item index.
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_GetTopIndex(HWND hwnd);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetIconItemCallback
// Type     : INT
// Purpose  : Set user defined Function that gets each Item's data
//			: in ICON VIEW
//			: PadListView call this function, when redraw client area.
//			: User must manage display data with index.
// Args     : 
//          : HWND hwnd 
//          : LPARAM lParam 
//          : LPFNPLVITEMCALLBACK lpfnPlvItemCallback 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetIconItemCallback(HWND hwnd, LPARAM lParam, LPFNPLVICONITEMCALLBACK lpfnIconItemCallback);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetReportItemCallback
// Type     : INT
// Purpose  : Set user defined Function that gets each column's data
//			: in Report view.
//			: User must manage display data with index and column index.
// Args     : 
//          : HWND hwnd 
//          : LPFNPLVCOLITEMCALLBACK lpfnColItemCallback 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetReportItemCallback(HWND hwnd, LPARAM lParam, LPFNPLVREPITEMCALLBACK lpfnRepItemCallback);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetIconFont
// Type     : INT
// Purpose  : Set specifed Font for ICON View.
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName:	NULL terminated font name.
//          : INT point:			font point count. 				 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetIconFont(HWND hwnd, LPTSTR lpstrFontName, INT point);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetReportFont
// Type     : INT
// Purpose  : Set specifed Font for REPORT VIEW.
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpstrFontName 
//          : INT point 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetReportFont(HWND hwnd, LPTSTR lpstrFontName, INT point);

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetStyle
// Type     : INT
// Purpose  : return current PadListView's style
// Args     : 
//          : HWND hwnd 
// Return   : PLVSTYLE_ICON or PLVSTYLE_REPORT
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_GetStyle(HWND hwnd);

//////////////////////////////////////////////////////////////////
// Function : PadListView_SetStyle
// Type     : INT
// Purpose  : set the PadListView's style.
//			  style is PLVSTYLE_LIST or PLVSTYLE_REPORT
// Args     : 
//          : HWND hwnd 
//          : INT style 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetStyle(HWND hwnd, INT style);


//////////////////////////////////////////////////////////////////
// Function : PadListView_Update
// Type     : INT
// Purpose  : Repaint PadListView.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_Update(HWND hwnd);

//////////////////////////////////////////////////////////////////
// Function : PadListView_InsertColumn
// Type     : INT
// Purpose  : Set header control's column data.
//			: most of feature is same as LVM_INSERTCOLUMN message.
// Args     : 
//          : HWND hwnd 
//          : INT index 
//          : PLV_COLUMN * lpPlvCol 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_InsertColumn(HWND hwnd, INT index, PLV_COLUMN *lpPlvCol);
//extern INT  WINAPI PadListView_DeleteColumn(HWND hwnd, INT index);


//////////////////////////////////////////////////////////////////
// Function : PadListView_SetExplanationText
// Type     : INT
// Purpose  : set the PadListView's text .
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpText 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT  WINAPI PadListView_SetExplanationText(HWND hwnd, LPSTR lpText);

extern INT  WINAPI PadListView_SetExplanationTextW(HWND hwnd, LPWSTR lpText);
//////////////////////////////////////////////////////////////////
// Function : PadListView_SetCurSel
// Type     : INT
// Purpose  : set cur selection. Move cursor to specified index.
//			:
// Args     : 
//          : HWND hwnd 
//          : LPSTR lpText 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
extern INT WINAPI PadListView_SetCurSel(HWND hwnd, INT index);

extern INT WINAPI PadListView_SetExtendStyle(HWND hwnd, INT style);

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetWidthByColumn
// Type     : INT WINAPI
// Purpose  : Calc PLV's window width by specified Column count
//			: This is PLVS_ICONVIEW style only.
// Args     : 
//          : HWND hwnd		PadListView window handle
//          : INT col		column count
// Return   : width by pixel.
// DATE     : 971120
//////////////////////////////////////////////////////////////////
extern INT WINAPI PadListView_GetWidthByColumn(HWND hwnd, INT col);

//////////////////////////////////////////////////////////////////
// Function : PadListView_GetHeightByRow
// Type     : INT WINAPI
// Purpose  : Calc PLV's window height
//			  by specified Row count.
//			  This is PLVS_ICONVIEW style only.
// Args     : 
//          : HWND hwnd		PLV's window handle
//          : INT row		row count
// Return   : height in pixel
// DATE     : 971120
//////////////////////////////////////////////////////////////////
extern INT WINAPI PadListView_GetHeightByRow(HWND hwnd, INT row);

//////////////////////////////////////////////////////////////////
// Function	:	PadListView_SetHeaderFont
// Type		:	INT WINAPI 
// Purpose	:	
// Args		:	
//			:	HWND	hwnd	
//			:	LPSTR	lpstrFontName	
// Return	:	
// DATE		:	Tue Jul 28 08:58:06 1998
// Histroy	:	
//////////////////////////////////////////////////////////////////
extern INT WINAPI PadListView_SetHeaderFont(HWND hwnd, LPTSTR lpstrFontName);

//////////////////////////////////////////////////////////////////
// Function	:	PadListView_SetCodePage
// Type		:	INT WINAPI
// Purpose	:	
// Args		:	
//			:	HWND	hwnd	
//			:	INT	codePage	
// Return	:	
// DATE		:	Tue Jul 28 08:59:35 1998
// Histroy	:	
//////////////////////////////////////////////////////////////////
extern INT WINAPI PadListView_SetCodePage(HWND hwnd, INT codePage);


extern INT WINAPI PadListView_SetIconFontEx(HWND  hwnd,
											LPTSTR lpstrFontName,
											INT   charSet,
											INT    point);

extern INT WINAPI PadListView_SetReportFontEx(HWND	 hwnd,
											  LPTSTR lpstrFontName,
											  INT   charSet,
											  INT	 point);

#ifdef UNDER_CE // In Windows CE, all window classes are process global.
extern BOOL PadListView_UnregisterClass(HINSTANCE hInst);
#endif // UNDER_CE

#endif //_PAD_LIST_VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\dispatch.h ===
/* dispatch.c */
#ifndef _DISPATCH_H_
#define _DISPATCH_H_

typedef LRESULT (*PFNMSG)(HWND, UINT, WPARAM, LPARAM);
typedef LRESULT (*PFNCMD)(HWND, WORD, WORD, HWND);

typedef enum{
   edwpNone,            // Do not call any default procedure.
   edwpWindow,          // Call DefWindowProc.
   edwpDialog,          // Call DefDlgProc (This should be used only for
                        // custom dialogs - standard dialog use edwpNone).
   edwpMDIChild,        // Call DefMDIChildProc.
   edwpMDIFrame         // Call DefFrameProc.
} EDWP;                // Enumeration for Default Window Procedures

typedef struct _MSD{
    UINT   uMessage;
    PFNMSG pfnmsg;
} MSD;                 // MeSsage Dispatch structure

typedef struct _MSDI{
    int  cmsd;          // Number of message dispatch structs in rgmsd
    MSD *rgmsd;         // Table of message dispatch structures
    EDWP edwp;          // Type of default window handler needed.
} MSDI, FAR *LPMSDI;   // MeSsage Dipatch Information

typedef struct _CMD{
    WORD   wCommand;
    PFNCMD pfncmd;
} CMD;                 // CoMmand Dispatch structure

typedef struct _CMDI{
    int  ccmd;          // Number of command dispatch structs in rgcmd
    CMD *rgcmd;         // Table of command dispatch structures
    EDWP edwp;          // Type of default window handler needed.
} CMDI, FAR *LPCMDI;   // CoMmand Dispatch Information

LRESULT DispMessage(LPMSDI lpmsdi, HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam);
LRESULT DispCommand(LPCMDI lpcmdi, HWND hwnd, WPARAM wparam, LPARAM lparam);
LRESULT DispDefault(EDWP edwp, HWND hwnd, UINT uMessage, WPARAM wparam, LPARAM lparam);

#endif // _DISPATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\repview.h ===
#ifndef _REP_VIEW_H_
#define _REP_VIEW_H_

#define HEADER_ID		0x20
/* repview.cpp */
extern HWND RepView_CreateHeader(LPPLVDATA lpPlvData);
extern INT RepView_RestoreScrollPos(LPPLVDATA lpPlvData);
extern INT RepView_ResetScrollRange(LPPLVDATA lpPlvData);
extern INT RepView_SetItemCount(LPPLVDATA lpPlvData, INT itemCount, INT fDraw);
extern INT RepView_SetTopIndex(LPPLVDATA lpPlvData, INT indexTop);
extern INT RepView_SetCurSel(LPPLVDATA lpPlvData, INT index);
extern INT RepView_ErrorPaint(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT RepView_Paint(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT RepView_Notify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT RepView_ButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT RepView_ButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern INT RepView_MouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam);
extern INT RepView_VScroll(HWND hwnd, WPARAM wParam, LPARAM lParam);

#endif //_REP_VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\repview.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "plv_.h"
#include "plv.h"
#include "dbg.h"
#include "repview.h"
#include "rvmisc.h"
#include "exgdiw.h"
// temporary
#if 0
#include "resource.h"
#endif
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

static POSVERSIONINFO ExGetOSVersion(VOID)
{
    static BOOL fFirst = TRUE;
    static OSVERSIONINFO os;
    if ( fFirst ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx( &os ) ) {
            fFirst = FALSE;
        }
    }
    return &os;
}

static BOOL ExIsWinNT(VOID)
{
	BOOL fBool;
	fBool = (ExGetOSVersion()->dwPlatformId == VER_PLATFORM_WIN32_NT);
	return fBool;
}

//----------------------------------------------------------------
// Header control window ID 
//----------------------------------------------------------------

HWND RepView_CreateHeader(LPPLVDATA lpPlvData)
{
	if(!lpPlvData) {
		return NULL;
	}
	static RECT rc;
//	HD_ITEM hdItem;
	InitCommonControls();
	HWND hwnd;
#ifndef UNDER_CE // always Unicode
	if(ExIsWinNT()) {
#endif // UNDER_CE
		hwnd = CreateWindowExW(0,
									WC_HEADERW,
									L"",
									WS_CHILD | WS_VISIBLE | HDS_BUTTONS |HDS_HORZ, 
									0, 0, 0, 0, //rc.left, rc.top, rc.right - rc.left, 30,
									lpPlvData->hwndSelf,
									(HMENU)HEADER_ID,
									lpPlvData->hInst,
									NULL);
#ifndef UNDER_CE // always Unicode
	}
	else {
		hwnd = CreateWindowExA(0,
									WC_HEADER,
									"",
									WS_CHILD | WS_VISIBLE | HDS_BUTTONS |HDS_HORZ, 
									0, 0, 0, 0, //rc.left, rc.top, rc.right - rc.left, 30,
									lpPlvData->hwndSelf,
									(HMENU)HEADER_ID,
									lpPlvData->hInst,
									NULL);
	}
#endif // UNDER_CE
	if(hwnd == NULL) {
		//wsprintf(szBuf, "Create Header tError %d\n", GetLastError());
		//OutputDebugString(szBuf);
		//OutputDebugString("Create Header error\n");
		return NULL;
	}
	SendMessage(hwnd, 
				WM_SETFONT,
				(WPARAM)(HFONT)GetStockObject(DEFAULT_GUI_FONT),
				MAKELPARAM(FALSE, 0));

	GetClientRect(lpPlvData->hwndSelf, &rc); // get PadListView's client rect
	static HD_LAYOUT hdl;
	static WINDOWPOS wp;
	hdl.prc = &rc;
	hdl.pwpos = &wp;
	//Calc header control window size
	if(Header_Layout(hwnd, &hdl) == FALSE) {
		//OutputDebugString("Create Header Layout error\n");
		return NULL;
	}
#if 0  // test test
		HD_ITEM hdi;  // Header item.
		hdi.mask = HDI_FORMAT | HDI_WIDTH | HDI_TEXT;
		hdi.fmt  = HDF_LEFT | HDF_STRING;
		hdi.pszText = "poipoi"; //:zItemHead[i];     // The text for the item.
		hdi.cxy = 75;			         // The initial width.
		hdi.cchTextMax = lstrlen(hdi.pszText);  // The length of the string.
		Header_InsertItem(hwnd, 0, &hdi);
#endif

	SetWindowPos(hwnd, wp.hwndInsertAfter, wp.x, wp.y,
				 wp.cx, wp.cy, wp.flags | SWP_SHOWWINDOW);
				 //wp.cx, wp.cy, wp.flags | SWP_HIDEWINDOW);
	return hwnd;
}

//////////////////////////////////////////////////////////////////
// Function : RepView_RestoreScrollPos
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_RestoreScrollPos(LPPLVDATA lpPlvData)
{
	return RV_SetCurScrollPos(lpPlvData->hwndSelf, lpPlvData->nCurScrollPos);
}

//////////////////////////////////////////////////////////////////
// Function : RepView_ResetScrollPos
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_ResetScrollRange(LPPLVDATA lpPlvData)
{
	static SCROLLINFO scrInfo;
	if(!lpPlvData) {
		return 0;
	}
	HWND hwnd = lpPlvData->hwndSelf;
	INT nRow = RV_GetRow(hwnd);
	//INT nCol = RV_GetCol(hwnd);
	INT nMax = RV_GetMaxLine(hwnd);


	INT nPos = lpPlvData->nCurScrollPos;
	//lpPlv->iCurTopIndex = nPos;

	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= 0;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nRow;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	//In normal case,  
	//if (scrInfo.nMax - scrInfo.nMin + 1) <= scrInfo.nPage, 
	// scroll bar is hidden. to prevent it,
	// in this case, set proper page, and DISABLE scrollbar.
	// Now we can show scroll bar always
	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : RepView_SetItemCount
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
//          : INT itemCount 
//          : BOOL fDraw		update scroll bar or not
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_SetItemCount(LPPLVDATA lpPlvData, INT itemCount, BOOL fDraw)
{
	lpPlvData->iItemCount = itemCount;
	lpPlvData->iCurTopIndex  = 0;	//970707 ToshiaK, change curTopindex to 0
	lpPlvData->nCurScrollPos = 0;	//970707 ToshiaK, same as iCurTopIndex
	
	if(fDraw) {
		INT nMaxLine = lpPlvData->iItemCount; //RV_GetMaxLine(lpPlvData->hwndSelf);
		INT nPage	 = RV_GetRow(lpPlvData->hwndSelf);
		RV_SetScrollInfo(lpPlvData->hwndSelf, 0, nMaxLine, nPage, 0);
	}
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : RepView_SetTopIndex
// Type     : INT
// Purpose  : 
// Args     : 
//          : LPPLVDATA lpPlvData 
//          : INT indexTop 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_SetTopIndex(LPPLVDATA lpPlvData, INT indexTop)
{
	INT nCol = RV_GetCol(lpPlvData->hwndSelf); 
	if(nCol <=0) {
		return 0;
	}
	if(indexTop < lpPlvData->iItemCount) {
		lpPlvData->iCurTopIndex = indexTop;
		RV_SetCurScrollPos(lpPlvData->hwndSelf, lpPlvData->iCurTopIndex);
		RECT rc;
		GetClientRect(lpPlvData->hwndSelf, &rc);
		rc.top += RV_GetHeaderHeight(lpPlvData);
		InvalidateRect(lpPlvData->hwndSelf, &rc, TRUE);
		UpdateWindow(lpPlvData->hwndSelf);
		return indexTop;
	}
	else {
		return -1;
	}
}

//////////////////////////////////////////////////////////////////
// Function : RepView_Paint
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_Paint(HWND hwnd, WPARAM wParam, LPARAM lParam)
{

	//OutputDebugString("RepViewPaint start\n");
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	DP(("RepView_Paint START lpPlvData[0x%08x]\n", lpPlvData));
	DP(("RepView_Paint START lpPlvData->lpfnPlvRepItemCallback[0x%08x]\n", lpPlvData));
	if(!lpPlvData && !lpPlvData->lpfnPlvRepItemCallback) {
		Dbg((" Error Callback\n"));
		//OutputDebugString("RepViewPaint end 1\n");
		return 0;
	}

	INT nCol		= RV_GetColumn(lpPlvData);
	INT *pColWidth;  
	if(nCol < 1) {
		return 0;
	}

	LPPLVITEM lpPlvItemList = (LPPLVITEM)MemAlloc(sizeof(PLVITEM)*nCol);
	if(!lpPlvItemList) {
		return 0;
	}

	pColWidth = (INT *)MemAlloc(sizeof(INT)*nCol);

	if(!pColWidth) {
		DP(("RepView_Paint END\n"));
		//OutputDebugString("RepViewPaint end 2\n");
		MemFree(lpPlvItemList);
		return 0;
	}
	ZeroMemory(lpPlvItemList, sizeof(PLVITEM)*nCol);

	static PAINTSTRUCT ps;
	HDC hDC = BeginPaint(hwnd, &ps);

	static RECT rc;
	GetClientRect(hwnd, &rc);

	HDC hDCMem = CreateCompatibleDC(hDC);
	HBITMAP hBitmap = CreateCompatibleBitmap(hDC,
											 rc.right - rc.left,
											 rc.bottom - rc.top);
	HBITMAP hBitmapPrev    = (HBITMAP)SelectObject(hDCMem, hBitmap);

	//----------------------------------------------------------------
	//971111: #2586: Back color is COLOR_WINDOW
	//----------------------------------------------------------------
	//HBRUSH  hBrush         = CreateSolidBrush(GetSysColor(COLOR_3DFACE));
	//DWORD   dwOldBkColor   = SetBkColor(hDCMem, GetSysColor(COLOR_3DFACE));

	HBRUSH  hBrush         = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
	DWORD   dwOldBkColor   = SetBkColor(hDCMem, GetSysColor(COLOR_WINDOW));
	DWORD   dwOldTextColor = SetTextColor(hDCMem, GetSysColor(COLOR_WINDOWTEXT));

	HDC hDCForBmp  = CreateCompatibleDC(hDCMem); // for item columne bitmap;

	FillRect(hDCMem, &rc, hBrush);

	INT nRow = RV_GetRow(hwnd);
	INT y;
	static RECT rcItem;

	static PLVITEM plvItemTmp, plvItem;
	HFONT hFontOld = NULL;

	if(lpPlvData->hFontRep) {
		hFontOld = (HFONT)SelectObject(hDCMem, lpPlvData->hFontRep);
	}

	static POINT pt;
#ifndef UNDER_CE // Windows CE does not support GetCursorPos.
	GetCursorPos(&pt);
	ScreenToClient(hwnd, &pt);
#else // UNDER_CE
	if(lpPlvData->iCapture != CAPTURE_NONE){
		pt.x = lpPlvData->ptCapture.x;
		pt.y = lpPlvData->ptCapture.y;
	}
	else{
		// set outer client point
		pt.x = -1;
		pt.y = -1;
	}
#endif // UNDER_CE

	static RECT rcHead;
	GetClientRect(lpPlvData->hwndHeader, &rcHead);

	INT nItemHeight = RV_GetItemHeight(hwnd);
	INT yOffsetHead = rcHead.bottom - rcHead.top;
	INT	i, j, k;		


	for(k = 0; k < nCol; k++) {
		HD_ITEM hdItem;
		hdItem.mask = HDI_WIDTH;
		hdItem.fmt  = 0;
		Header_GetItem(lpPlvData->hwndHeader, k, &hdItem);
		pColWidth[k] = hdItem.cxy;
	}

	//	DP(("lpPlvData->iCurTopIndex [%d]\n", lpPlvData->iCurTopIndex));
	//	DP(("nRow %d\n", nRow));
	//	DP(("lpPlvData->iItemCount [%d]\n", lpPlvData->iItemCount));

	//----------------------------------------------------------------
	// for each index item( each line that will be displayed )
	//----------------------------------------------------------------
	//Dbg(("iCurTopIndex = %d\n", lpPlvData->iCurTopIndex));
	//Dbg(("iItemCount   = %d\n", lpPlvData->iItemCount));
	for(i = 0, j = lpPlvData->iCurTopIndex;
		i < nRow && j < lpPlvData->iItemCount;
		i++, j++) {

		//----------------------------------------------------------------
		// get line's vertical offset.
		//----------------------------------------------------------------
		y = RV_GetYMargin(hwnd) + nItemHeight * i;

		ZeroMemory(lpPlvItemList, sizeof(PLVITEM)*nCol);
		//----------------------------------------------------------------
		//changed data query call back spec in 970705: by toshiak
		// get line's all column data with one function call.
		//----------------------------------------------------------------
		lpPlvData->lpfnPlvRepItemCallback(lpPlvData->repItemCallbacklParam, 
										  j,		//line index. 
										  nCol,		//column Count.
										  lpPlvItemList);
		INT xOffset = 0;
		//Dbg(("j = %d\n", j));
		for(k = 0; k < nCol; k++) {
			//Dbg(("k = %d\n", k));
			rcItem.left  = xOffset;
			rcItem.right = rcItem.left + pColWidth[k];
			rcItem.top   = rc.top      + yOffsetHead + y;
			rcItem.bottom= rcItem.top  + nItemHeight;
			if(rcItem.top > rc.bottom) {
				break;
			}
			if(rcItem.left > rc.right) {
				break;
			}
			RV_DrawItem(lpPlvData, hDCMem, hDCForBmp, pt, k, &rcItem, &lpPlvItemList[k]);
			xOffset += pColWidth[k];
		}
		//----------------------------------------------------------------
		//000531:Satori #1641
		//Call DeleteObject() here.
		//----------------------------------------------------------------
		for(k = 0; k < nCol; k++) {
			if(lpPlvItemList[k].fmt == PLVFMT_BITMAP && lpPlvItemList[k].hBitmap != NULL) {
				DeleteObject(lpPlvItemList[k].hBitmap);
			}
		}
	}
	if(hFontOld){
		SelectObject(hDCMem, hFontOld);
	}

	if(pColWidth) {
		MemFree(pColWidth);
	}

	if(lpPlvItemList) {
		MemFree(lpPlvItemList);
	}
	// LIZHANG: if there is no items, draw the explanation text
	if ( !lpPlvData->iItemCount && (lpPlvData->lpText || lpPlvData->lpwText))
	{
		HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
		HFONT hOldFont = (HFONT)SelectObject( hDCMem, hFont );
		RECT rcTmp = rc;
		rcTmp.left = 20;
		rcTmp.top = 20;
		rcTmp.right -= 10;
		rcTmp.bottom -= 10;

		//----------------------------------------------------------------
		//971111: #2586
		//COLORREF colOld = SetTextColor( hDCMem, GetSysColor(COLOR_WINDOW) );
		//COLORREF colBkOld = SetBkColor( hDCMem, GetSysColor(COLOR_3DFACE) );
		//----------------------------------------------------------------
		COLORREF colOld = SetTextColor( hDCMem, GetSysColor(COLOR_WINDOWTEXT));
		COLORREF colBkOld = SetBkColor( hDCMem, GetSysColor(COLOR_WINDOW) );
#ifndef UNDER_CE // always Unicode
		if(ExIsWinNT()) {
#endif // UNDER_CE
			if(lpPlvData->lpwText) {
				DrawTextW( hDCMem,
						  lpPlvData->lpwText,
						  lstrlenW(lpPlvData->lpwText),
						  &rcTmp,
						  DT_VCENTER|DT_WORDBREAK ); 
			}
#ifndef UNDER_CE // always Unicode
		}
		else {
			if(lpPlvData->lpText) {
				DrawText( hDCMem,
						 lpPlvData->lpText,
						 lstrlen(lpPlvData->lpText),
						 &rcTmp,DT_VCENTER|DT_WORDBREAK ); 
			}
		}
#endif // UNDER_CE
		SetTextColor( hDCMem, colOld );
		SetBkColor( hDCMem, colBkOld );
		SelectObject( hDCMem, hOldFont );
	}

	BitBlt(hDC,
		   rc.left,
		   rc.top, 
		   rc.right - rc.left,
		   rc.bottom - rc.top,
		   hDCMem, 0, 0, SRCCOPY);

	// LIZHANG 7/6/97 added this line to repaint header control
	InvalidateRect(lpPlvData->hwndHeader,NULL,FALSE);

	DeleteObject(hBrush);
	SetBkColor(hDCMem, dwOldBkColor);
	SetTextColor(hDCMem, dwOldTextColor);
	SelectObject(hDCMem, hBitmapPrev );
	DeleteObject(hBitmap);
	DeleteDC(hDCForBmp);
	DeleteDC( hDCMem );


	EndPaint(hwnd, &ps);
	//OutputDebugString("RepViewPaint end 3\n");
	return 0;
	Unref3(hwnd, wParam, lParam);
}

INT RepView_Notify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	//Dbg(("Header Notify come\n"));
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData) {
		return 0;
	}
	HD_NOTIFY *lpNtfy = (HD_NOTIFY *)lParam;
	switch(lpNtfy->hdr.code) {
	case HDN_ITEMCLICKW:
	case HDN_ITEMCLICKA:
		{
			//Dbg(("lpNtfy->iItem   [%d]\n", lpNtfy->iItem));
			//Dbg(("lpNtfy->iButton [%d]\n", lpNtfy->iButton));
			static PLVINFO plvInfo;
			ZeroMemory(&plvInfo, sizeof(plvInfo));
			plvInfo.code = PLVN_HDCOLUMNCLICKED;
			plvInfo.colIndex = lpNtfy->iItem;
			SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
		}
		break;
	case HDN_ITEMDBLCLICK:
	case HDN_DIVIDERDBLCLICK:
	case HDN_BEGINTRACK:
		break;
	case HDN_ENDTRACKA:
	case HDN_ENDTRACKW:
		{
			RECT	rc, rcHead;
			GetClientRect(hwnd, &rc);
			GetClientRect(lpNtfy->hdr.hwndFrom, &rcHead);
			rc.top += rcHead.bottom - rcHead.top;
			InvalidateRect(hwnd, &rc, FALSE);
		}
		break;
	case HDN_TRACK:
		break;
	}
	return 0;
	Unref(uMsg);
	Unref(wParam);
}

INT RepView_ButtonDown(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData)  {
		return 0;
	}
	switch(uMsg) {
	case WM_LBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	case WM_MBUTTONDBLCLK:
	case WM_RBUTTONDBLCLK:
		//Dbg(("WM_LBUTTONDOWN COME\n"));
		SetCapture(hwnd);
#ifdef UNDER_CE // LBUTTON + ALT key handling
		//Standard way for RBUTTON handling is combination w/ LBUTTON + ALT key
		if(uMsg == WM_LBUTTONDOWN && GetAsyncKeyState(VK_MENU)){
			uMsg = WM_RBUTTONDOWN;
		}
#endif // UNDER_CE
		switch(uMsg) {
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_LBUTTON;
			break;
		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_MBUTTON;
			break;
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
			lpPlvData->iCapture = CAPTURE_RBUTTON;
			break;
		}
#ifndef UNDER_CE // Windows CE does not support GetCursorPos.
		GetCursorPos(&lpPlvData->ptCapture);
		//remember left button down place
		ScreenToClient(hwnd, &lpPlvData->ptCapture);
#else // UNDER_CE
		lpPlvData->ptCapture.x = (SHORT)LOWORD(lParam);
		lpPlvData->ptCapture.y = (SHORT)HIWORD(lParam);
#endif // UNDER_CE
		RECT rc;
		GetClientRect(hwnd, &rc);
		rc.top += RV_GetHeaderHeight(lpPlvData);
		InvalidateRect(hwnd, &rc, FALSE);
		//UpdateWindow(lpPlvData->hwndSelf);
		break;
	}
	return 0;
	Unref2(wParam, lParam);
}

INT RepView_ButtonUp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	static POINT pt;
	static PLVINFO plvInfo;
	static INT	index, downIndex;
	if(!lpPlvData)  {
		return 0;
	}
	switch(uMsg) {
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
		//Dbg(("WM_LBUTTONUP COMES\n"));
#ifdef UNDER_CE // LBUTTON + ALT key handling
		//Standard way for RBUTTON handling is combination w/ LBUTTON + ALT key
		if(uMsg == WM_LBUTTONUP && GetAsyncKeyState(VK_MENU)){
			uMsg = WM_RBUTTONUP;
		}
#endif // UNDER_CE
		RECT rc;
		lpPlvData->iCapture = CAPTURE_NONE;
		ReleaseCapture();
		GetClientRect(lpPlvData->hwndSelf, &rc);
		rc.top += RV_GetHeaderHeight(lpPlvData);
		InvalidateRect(lpPlvData->hwndSelf, &rc, TRUE);
		pt.x = LOWORD(lParam);
		pt.y = HIWORD(lParam);
		//Dbg(("x %d, y %d\n", pt.x, pt.y));
		//Dbg(("capture x[%d] y[%d] \n",lpPlvData->ptCapture.x,lpPlvData->ptCapture.y));
		downIndex = RV_GetInfoFromPoint(lpPlvData, lpPlvData->ptCapture, NULL);
		index = RV_GetInfoFromPoint(lpPlvData, pt, &plvInfo);
		//Dbg(("mouse down index [%d]\n", downIndex));
		//Dbg(("mouse up   index [%d]\n", index));
		if(index != -1) {
			Dbg(("code  [%d]\n", plvInfo.code));
			Dbg(("index [%d]\n", plvInfo.index));
			Dbg(("left[%d] top[%d] right[%d] bottom[%d] \n",
				 plvInfo.itemRect.left,
				 plvInfo.itemRect.top,
				 plvInfo.itemRect.right,
				 plvInfo.itemRect.bottom));
			if(index == downIndex) {
				if(lpPlvData->uMsg != 0) {
					if(uMsg == WM_LBUTTONUP) {
						plvInfo.code = PLVN_ITEMCLICKED;
						SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
					}
					else if(uMsg == WM_RBUTTONUP) {
						plvInfo.code = PLVN_R_ITEMCLICKED;
						SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
					}
				}
			}
		}
		lpPlvData->ptCapture.x = 0;
		lpPlvData->ptCapture.y = 0;
		break;
	}
	return 0;
	Unref(wParam);
}

//////////////////////////////////////////////////////////////////
// Function : RepView_MouseMove
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_MouseMove(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData)  {
		return 0;
	}
	static RECT rc;
	static POINT pt;
	static PLVINFO plvInfo;
	pt.x = LOWORD(lParam);
	pt.y = HIWORD(lParam);
	//Dbg(("x %d, y %d\n", pt.x, pt.y));
	INT index = RV_GetInfoFromPoint(lpPlvData, pt, &plvInfo);
	//Dbg(("mouse up   index [%d]\n", index));
	GetClientRect(lpPlvData->hwndSelf, &rc);
	rc.top += RV_GetHeaderHeight(lpPlvData);
	InvalidateRect(hwnd, &rc, FALSE);
	if(index != -1 && (lpPlvData->iCapture == CAPTURE_NONE)) {
		if(lpPlvData->uMsg != 0) {
			if(plvInfo.colIndex == 0) { //poped image is only when column index == 0.
				plvInfo.code = PLVN_ITEMPOPED;
				SendMessage(GetParent(hwnd), lpPlvData->uMsg, 0, (LPARAM)&plvInfo);
			}
#ifdef MSAA
			static oldindex = 0;

			index = PLV_ChildIDFromPoint(lpPlvData,pt);
			if((index > 0)&&(index != oldindex)){
				PLV_NotifyWinEvent(lpPlvData,
								   EVENT_OBJECT_FOCUS,
								   hwnd,
								   OBJID_CLIENT,
								   index); // child id
				oldindex = index;
			}
#endif
		}
	}
	return 0;
	Unref(wParam);
}

//////////////////////////////////////////////////////////////////
// Function : RepView_VScroll
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : WPARAM wParam 
//          : LPARAM lParam 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RepView_VScroll(HWND hwnd, WPARAM wParam,  LPARAM lParam)
{
	//----------------------------------------------------------------
	// get current top index.
	// calc scroll position. 
	// get new top index and set it. 
	// redraw window rectangle.
	//----------------------------------------------------------------
	LPPLVDATA lpPlvData = GetPlvDataFromHWND(hwnd);
	if(!lpPlvData)  {
		return 0;
	}

	INT nScrollCode	  = (int) LOWORD(wParam); // scroll bar value 
#ifdef _DEBUG
	INT nArgPos 	  = (short int) HIWORD(wParam);  // scroll box position 
#endif
	//HWND hwndScrollBar = (HWND) lParam;      // handle of scroll bar 
	INT nPos;
	INT nRow, nCol, nMax;

	switch(nScrollCode) {
	case SB_LINEDOWN:	
		Dbg(("SB_LINEDOWN COME nArgPos[%d]\n", nArgPos));
		nRow = RV_GetRow(hwnd);
		nMax = RV_GetMaxLine(hwnd);
		nPos = RV_GetCurScrollPos(hwnd);		
		if(nPos + nRow > nMax - 1) {
			return 0;
		}
		nPos++;
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_LINEUP:
		Dbg(("SB_LINEUP COME nArgPos[%d]\n", nArgPos));
		RV_GetRowColumn(hwnd, &nRow, &nCol);
		nPos = RV_GetCurScrollPos(hwnd);
		if(nPos <= 0) {
			return 0;
		}
		nPos--; 
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_PAGEDOWN:	
		Dbg(("SB_PAGEDOWN COME nArgPos[%d]\n", nArgPos));
		RV_GetRowColumn(hwnd, &nRow, &nCol);
		nMax = RV_GetMaxLine(hwnd);
		nPos = RV_GetCurScrollPos(hwnd);
		nPos = min(nPos+nRow, nMax - nRow);
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_PAGEUP:		//Track̏オNbNꂽ
		Dbg(("SB_PAGEUP COME nArgPos[%d]\n", nArgPos));
		RV_GetRowColumn(hwnd, &nRow, &nCol);
		nPos = RV_GetCurScrollPos(hwnd);
		nPos = max(0, nPos - nRow);
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_TOP:
		Dbg(("SB_TOP COME nArgPos[%d]\n", nArgPos));
		break;
	case SB_BOTTOM:
		Dbg(("SB_BOTTOM COME nArgPos[%d]\n", nArgPos));
		break;
	case SB_THUMBTRACK:		//TrackDrag
		Dbg(("SB_THUMBTRACK COME nArgPos[%d]\n", nArgPos));
		nPos = RV_GetScrollTrackPos(hwnd);
		Dbg(("Current Pos %d\n", nPos));
		RV_GetRowColumn(hwnd, &nRow, &nCol);
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_THUMBPOSITION:	//Scroll BarDragI
		Dbg(("SB_THUMBPOSITION COME nArgPos[%d]\n", nArgPos));
		nPos = RV_GetScrollTrackPos(hwnd);
		Dbg(("Current Pos %d\n", nPos));
		RV_GetRowColumn(hwnd, &nRow, &nCol);
		RV_SetCurScrollPos(hwnd, nPos);
		break;
	case SB_ENDSCROLL:
		Dbg(("SB_ENDSCROLL COME nArgPos[%d]\n", nArgPos));
		break;
	}
	RECT rc;
	GetClientRect(lpPlvData->hwndSelf, &rc);
	rc.top += RV_GetHeaderHeight(lpPlvData);
	InvalidateRect(lpPlvData->hwndSelf, &rc, TRUE);
	return 0;
	Unref3(hwnd, wParam, lParam);
}

INT RepView_SetCurSel(LPPLVDATA lpPlvData, INT index)
{
	DP(("RepView_Paint START lpPlvData[0x%08x]\n", lpPlvData));
	INT nCol		= RV_GetColumn(lpPlvData);
	if(!lpPlvData) {
		return 0;
	}
	if(nCol < 1) {
		return 0;
	}
	HWND hwnd = lpPlvData->hwndSelf; 
	static RECT rc;
	GetClientRect(hwnd, &rc);
	INT nRow = RV_GetRow(hwnd);
	INT y;
	static RECT rcItem;
	static POINT pt;
	static RECT rcHead;
	GetClientRect(lpPlvData->hwndHeader, &rcHead);

	INT nItemHeight = RV_GetItemHeight(hwnd);
	INT yOffsetHead = rcHead.bottom - rcHead.top;
	INT	i, j;
	Dbg(("yOffsetHead [%d] nItemHeight[%d]\n", yOffsetHead, nItemHeight));
	//----------------------------------------------------------------
	// for each index item( each line that will be displayed )
	//----------------------------------------------------------------
	for(i = 0, j = lpPlvData->iCurTopIndex; 
		i < nRow && j < lpPlvData->iItemCount;
		i++, j++) {

		//----------------------------------------------------------------
		// get line's vertical offset.
		//----------------------------------------------------------------
		if(j == index) {
			y = RV_GetYMargin(hwnd) + nItemHeight * i;
			Dbg(("y %d\n", y));
			INT xOffset = 0;
			rcItem.left  = xOffset;
			rcItem.top   = rc.top      + yOffsetHead + y;
			pt.x = rcItem.left + (nItemHeight * 3)/4;
			pt.y = rcItem.top  + (nItemHeight * 3)/4;
			Dbg(("pt.x[%d] pt.y[%d]\n", pt.x, pt.y));
			ClientToScreen(hwnd, &pt);
			SetCursorPos(pt.x, pt.y);
			break;			
		}
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\rvmisc.h ===
#ifndef _RV_MISC_H_
#define _RV_MISC_H_
/* rvmisc.cpp */
extern INT RV_GetItemWidth(HWND hwnd);
extern INT RV_GetItemHeight(HWND hwnd);
extern INT RV_GetXMargin(HWND hwnd);
extern INT RV_GetYMargin(HWND hwnd);
extern INT RV_GetHeaderHeight(LPPLVDATA lpPlvData);
extern INT RV_GetDispWidth(HWND hwnd);
extern INT RV_GetDispHeight(HWND hwnd);
extern INT RV_GetWidth(HWND hwnd);
extern INT RV_GetHeight(HWND hwnd);
extern INT RV_GetRow(HWND hwnd);
extern INT RV_GetColumn(LPPLVDATA lpPlvData);
extern INT RV_GetCol(HWND hwnd);
extern INT RV_GetRowColumn(HWND hwnd, INT *pRow, INT *pCol);
extern INT RV_GetMaxLine(HWND hwnd);
extern INT RV_GetInfoFromPoint(LPPLVDATA lpPlvData, POINT pt, LPPLVINFO lpPlvInfo);
extern INT RV_DrawItem(LPPLVDATA lpPlvData, HDC hDC, HDC hDCForBmp, POINT pt, INT colIndex, LPRECT lpRect, LPPLVITEM lpPlvItem);
extern INT RV_GetCurScrollPos(HWND hwnd);
extern INT RV_SetCurScrollPos(HWND hwnd, INT nPos);
extern INT RV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos);
extern INT RV_GetScrollTrackPos(HWND hwnd);
#endif //_RV_MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\rvmisc.cpp ===
//////////////////////////////////////////////////////////////////
// File     : ivmisc.cpp
// Purpose  : PadListView control's ICON View function.
//			: Name is ICON View but it does not use ICON
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include "plv_.h"
#include "plv.h"
#include "dbg.h"
#include "rvmisc.h"
#include "strutil.h"
#include "exgdiw.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

inline INT RECT_GetWidth(LPRECT lpRc)
{
	return lpRc->right - lpRc->left;
}

inline INT RECT_GetHeight(LPRECT lpRc)
{
	return lpRc->bottom - lpRc->top;
}

INT RV_GetItemWidth(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nRepItemWidth;
}

INT RV_GetItemHeight(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nRepItemHeight;
}


INT RV_GetXMargin(HWND hwnd)
{
	return XMARGIN;
	Unref(hwnd);
}

INT RV_GetYMargin(HWND hwnd)
{
	//return YMARGIN;
	return 0;
	Unref(hwnd);
}
INT RV_GetHeaderHeight(LPPLVDATA lpPlvData)
{
	static RECT rc;
	if(!lpPlvData->hwndHeader) {
		return 0;
	}
	GetClientRect(lpPlvData->hwndHeader, &rc);
	return rc.bottom - rc.top;
}

INT RV_GetDispWidth(HWND hwnd)
{
	return RV_GetWidth(hwnd) - RV_GetXMargin(hwnd)*2;
}

INT RV_GetDispHeight(HWND hwnd)
{
	return RV_GetHeight(hwnd) - RV_GetYMargin(hwnd)*2;
}

INT RV_GetWidth(HWND hwnd)
{
	static RECT rc;
	GetClientRect(hwnd, &rc);
	return RECT_GetWidth(&rc);
}

INT RV_GetHeight(HWND hwnd)
{
	static RECT rc;
	GetClientRect(hwnd, &rc);
	return RECT_GetHeight(&rc);
}

INT RV_GetRow(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return (RV_GetDispHeight(hwnd) - RV_GetHeaderHeight(lpPlv))/lpPlv->nRepItemHeight;
}

INT RV_GetColumn(LPPLVDATA lpPlvData)
{
	if(!lpPlvData) {
		//OutputDebugString("RV_GetColumn: lpPlvData NULL\n");
		return 0;
	}
	if(!lpPlvData->hwndHeader) {
		//OutputDebugString("RV_GetColumn: hwndHeader NULL\n");
		return 0;
	}
	return Header_GetItemCount(lpPlvData->hwndHeader);
}

INT RV_GetCol(HWND hwnd)
{
	//LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return 1;
	UNREFERENCED_PARAMETER(hwnd);
}

INT RV_GetRowColumn(HWND hwnd, INT *pRow, INT *pCol)
{
	*pRow = RV_GetRow(hwnd);
	*pCol = RV_GetCol(hwnd);
	return 0;
}

INT RV_GetMaxLine(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->iItemCount;
}

//////////////////////////////////////////////////////////////////
// Function : RV_IndexFromPoint
// Type     : INT
// Purpose  : Get item index from PadListView point
// Args     : 
//          : LPPLVDATA lpPlvData 
//          : POINT pt // position of pad listview client.
// Return   : return pt's item index. if -1 error.
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RV_GetInfoFromPoint(LPPLVDATA lpPlvData, POINT pt, LPPLVINFO lpPlvInfo)
{
	INT nRow = RV_GetRow(lpPlvData->hwndSelf);
	// get header control item count;
	INT nCol = RV_GetColumn(lpPlvData);

	if(nCol <=0 ) {
		return 0;
	}

	INT i, j, k;
	INT x, y;
	static RECT rc, rcHead;
	//INT nItemWidth  = RV_GetItemWidth(lpPlvData->hwndSelf);
	INT nItemHeight = RV_GetItemHeight(lpPlvData->hwndSelf);

	GetClientRect(lpPlvData->hwndHeader, &rcHead);
	GetClientRect(lpPlvData->hwndSelf,   &rc);

	INT yOffsetHead = rcHead.bottom - rcHead.top;
	static RECT rcItem;

	for(i = 0, j = lpPlvData->iCurTopIndex; 
		i < nRow  && j < lpPlvData->iItemCount;
		i++, j++) {
		x = RV_GetXMargin(lpPlvData->hwndSelf);
		y = RV_GetYMargin(lpPlvData->hwndSelf) + nItemHeight*i;
		INT xOffset = 0;
		HD_ITEM hdItem;
		for(k = 0; k < nCol; k++) {
			hdItem.mask = HDI_WIDTH;
			hdItem.fmt  = 0;
			Header_GetItem(lpPlvData->hwndHeader, k, &hdItem);
			rcItem.left  = xOffset;
			rcItem.right = rcItem.left + hdItem.cxy;
			rcItem.top   = rc.top  + yOffsetHead + y;
			rcItem.bottom= rcItem.top  + nItemHeight;
			if(PtInRect(&rcItem, pt)) {
				if(lpPlvInfo) {
					ZeroMemory(lpPlvInfo, sizeof(PLVINFO));
					lpPlvInfo->code        = 0; // don't know at this time.
					lpPlvInfo->index       = j;
					lpPlvInfo->pt	       = pt;
					lpPlvInfo->itemRect    = rcItem;
					lpPlvInfo->colIndex    = k;
					lpPlvInfo->colItemRect = rcItem;
				}
				return j;
			}
			xOffset += hdItem.cxy;
		}
	}
	return -1;
}

INT RV_DrawItem(LPPLVDATA	lpPlvData, 
				HDC			hDC, 
				HDC			hDCForBmp, 
				POINT		pt,
				INT			colIndex, 
				LPRECT		lpRect, 
				LPPLVITEM	lpPlvItem)
{

	if(!lpPlvItem->lpwstr) {
		return 0;
	}
	//INT edgeFlag = PLV_EDGE_NONE;
	INT sunken = 0;


	if(lpPlvItem->fmt == PLVFMT_TEXT) {
		SIZE size;
		//Dbg(("Call GetTextExtentPoint32W()\n"));
		//Dbg(("Length %d\n", StrlenW(lpPlvItem->lpwstr)));
		if(!ExGetTextExtentPoint32W(hDC, 
									lpPlvItem->lpwstr, 
									StrlenW(lpPlvItem->lpwstr), 
									&size)) {
			return 0;
		}
		if(colIndex == 0) {
			RECT rcItem = *lpRect;
			rcItem.left += 2;
			rcItem.right = rcItem.left + size.cx+4;
			if(lpPlvData->iCapture == CAPTURE_LBUTTON) {
#if 0
				Dbg(("RV_Draw Captureing\n"));
				Dbg(("pt [%d][%d] cap pt[%d][%d]drawrect l[%d] t[%d] r[%d] b[%d]\n",
					 pt.x,
					 pt.y,
					 lpPlvData->ptCapture.x,
					 lpPlvData->ptCapture.y,
					 rcItem.left, 
					 rcItem.top, 
					 rcItem.right, 
					 rcItem.bottom));
#endif
				if(PtInRect(&rcItem, lpPlvData->ptCapture) && PtInRect(&rcItem, pt)) {
					sunken = 1;
					DrawEdge(hDC, &rcItem, EDGE_SUNKEN, BF_SOFT | BF_RECT);
				}
			}
			else {
				if(PtInRect(&rcItem, pt)) {
					sunken = 0; //-1;
					DrawEdge(hDC, &rcItem, EDGE_RAISED, BF_SOFT | BF_RECT);
				}
			}
		}
		//Dbg(("Call ExtTextOut()\n"));
		ExExtTextOutW(hDC, 
					  lpRect->left + sunken + (colIndex == 0 ? 4 : 0),
					  lpRect->top  + (lpRect->bottom - lpRect->top - size.cy)/2 + sunken,
					  ETO_CLIPPED,
					  lpRect,
					  lpPlvItem->lpwstr,
					  StrlenW(lpPlvItem->lpwstr), 
					  NULL);
	}
	else if(lpPlvItem->fmt == PLVFMT_BITMAP) {
		//Dbg(("Draw Bitmap\n"));
		if(lpPlvItem->hBitmap) {
			BITMAP bitMap;
			HBITMAP hBitmapOld;
			GetObject(lpPlvItem->hBitmap, sizeof(bitMap), &bitMap);
			hBitmapOld = (HBITMAP)SelectObject(hDCForBmp, lpPlvItem->hBitmap);
			INT yOffset = 0;
			if(bitMap.bmHeight < (lpRect->bottom - lpRect->top)) {
				yOffset = ((lpRect->bottom - lpRect->top) - bitMap.bmHeight)/ 2;
			}
			BitBlt(hDC, 
				   lpRect->left, 
				   lpRect->top+yOffset, 
				   lpRect->right - lpRect->left, lpRect->bottom - lpRect->top,
#ifndef UNDER_CE // CE Specific ??
				   hDCForBmp, 0, 0, SRCAND);
#else // UNDER_CE
				   hDCForBmp, 0, 0, SRCINVERT);
#endif // UNDER_CE
			SelectObject(hDCForBmp, hBitmapOld);
			//----------------------------------------------------------------
			//000531:Satori #1461
			//Don't call DeleteObject() here, call it from RV_DrawItem()'s caller.
			//repview.cpp:RepView_Paint();
			//----------------------------------------------------------------
			//DeleteObject(lpPlvItem->hBitmap);
		}
	}
	return 0;
}


INT RV_GetCurScrollPos(HWND hwnd)
{
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);
	return lpPlv->nCurScrollPos;
}

INT RV_SetCurScrollPos(HWND hwnd, INT nPos)
{
	static SCROLLINFO scrInfo;
	LPPLVDATA lpPlv = GetPlvDataFromHWND(hwnd);

	INT nRow = RV_GetRow(hwnd);
	//INT nCol = RV_GetCol(hwnd);
	INT nMax = RV_GetMaxLine(hwnd);

	lpPlv->nCurScrollPos = nPos;
	lpPlv->iCurTopIndex = nPos;

	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= 0;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nRow;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	//In normal case,  
	//if (scrInfo.nMax - scrInfo.nMin + 1) <= scrInfo.nPage, 
	// scroll bar is hidden. to prevent it,
	// in this case, set proper page, and DISABLE scrollbar.
	// Now we can show scroll bar always
	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}

	//970810 toshiak. send scrolled notify.
	static PLVINFO plvInfo;
	ZeroMemory(&plvInfo, sizeof(plvInfo));
	plvInfo.code = PLVN_VSCROLLED;
	SendMessage(GetParent(lpPlv->hwndSelf), 
				lpPlv->uMsg,
				(WPARAM)0,
				(LPARAM)&plvInfo);
	return nPos;
}

//////////////////////////////////////////////////////////////////
// Function : RV_SetScrollInfo
// Type     : INT
// Purpose  : 
// Args     : 
//          : HWND hwnd 
//          : INT nMin 
//          : INT nMax 
//          : INT nPage 
//          : INT nPos 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT RV_SetScrollInfo(HWND hwnd, INT nMin, INT nMax, INT nPage, INT nPos)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_PAGE | SIF_POS | SIF_RANGE;
	scrInfo.nMin		= nMin;
	scrInfo.nMax		= nMax-1;
	scrInfo.nPage		= nPage;
	scrInfo.nPos		= nPos;
	scrInfo.nTrackPos	= 0;

	if((scrInfo.nMax - scrInfo.nMin +1) <= (INT)scrInfo.nPage) {
		scrInfo.nMin  = 0;
		scrInfo.nMax  = 1;
		scrInfo.nPage = 1;
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);		
		EnableScrollBar(hwnd, SB_VERT, ESB_DISABLE_BOTH);
#else // UNDER_CE
		scrInfo.fMask |= SIF_DISABLENOSCROLL;
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
#endif // UNDER_CE
	}
	else {
#ifndef UNDER_CE // Windows CE does not support EnableScrollBar
		EnableScrollBar(hwnd, SB_VERT, ESB_ENABLE_BOTH);
#endif // UNDER_CE
		SetScrollInfo(hwnd, SB_VERT, &scrInfo, TRUE);
	}
	return 0;
} 

INT RV_GetScrollTrackPos(HWND hwnd)
{
	static SCROLLINFO scrInfo;
	scrInfo.cbSize		= sizeof(scrInfo);
	scrInfo.fMask		= SIF_ALL;
	GetScrollInfo(hwnd, SB_VERT, &scrInfo);
	return scrInfo.nTrackPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\strutil.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#pragma warning(disable :4706) //4706    "̔rl͑̌ʂɂȂĂ܂"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\dispatch.cpp ===
#include "imewarn.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "dispatch.h"


LRESULT DispMessage(LPMSDI lpmsdi, 
                    HWND   hwnd, 
                    UINT   uMessage, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    int  imsd = 0;

    MSD *rgmsd = lpmsdi->rgmsd;
    int  cmsd  = lpmsdi->cmsd;

    for (imsd = 0; imsd < cmsd; imsd++)
    {
        if (rgmsd[imsd].uMessage == uMessage)
            return rgmsd[imsd].pfnmsg(hwnd, uMessage, wparam, lparam);
    }

    return DispDefault(lpmsdi->edwp, hwnd, uMessage, wparam, lparam);
}

////////////////////////////////////////////////////////////////
// Function : DispCommand
// Type     :  LRESULT
// Purpose  : 
//          : 
// Argument : 
//          : LPCMDI lpcmdi 
//          : HWND hwnd 
//          : WPARAM wparam 
//          : LPARAM lparam 
// Return   :
// AUTHOR   : gƗ(ToshiaK)
// START DATE: 
// HISTORY  : 
// 
/////////////////////////////////////////////////////////////////
LRESULT DispCommand(LPCMDI lpcmdi, 
                    HWND   hwnd, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    LRESULT lRet = 0;
    WORD    wCommand = GET_WM_COMMAND_ID(wparam, lparam);
    int     icmd;

    CMD    *rgcmd = lpcmdi->rgcmd;
    int     ccmd  = lpcmdi->ccmd;

    // Message packing of wparam and lparam have changed for Win32,
    // so use the GET_WM_COMMAND macro to unpack the commnad

    for (icmd = 0; icmd < ccmd; icmd++)
    {
        if (rgcmd[icmd].wCommand == wCommand)
        {
            return rgcmd[icmd].pfncmd(hwnd,
                                      wCommand,
                                      GET_WM_COMMAND_CMD(wparam, lparam),
                                      GET_WM_COMMAND_HWND(wparam, lparam));
        }
    }

    return DispDefault(lpcmdi->edwp, hwnd, WM_COMMAND, wparam, lparam);
}


////////////////////////////////////////////////////////////////
// Function : DispDefault
// Type     :  LRESULT
// Purpose  : 
//          : 
// Argument : 
//          : EDWP edwp 
//          : HWND hwnd 
//          : UINT uMessage 
//          : WPARAM wparam 
//          : LPARAM lparam 
// Return   :
// AUTHOR   : gƗ(ToshiaK)
// START DATE: 
// HISTORY  : 
// 
/////////////////////////////////////////////////////////////////
#define hwndMDIClient NULL
LRESULT DispDefault(EDWP   edwp, 
                    HWND   hwnd, 
                    UINT   uMessage, 
                    WPARAM wparam, 
                    LPARAM lparam)
{
    switch (edwp)
    {
        case edwpNone:
            return 0;
        case edwpWindow:
            return DefWindowProc(hwnd, uMessage, wparam, lparam);
        case edwpDialog:
            return DefDlgProc(hwnd, uMessage, wparam, lparam);
        case edwpMDIFrame:
            return DefFrameProc(hwnd, hwndMDIClient, uMessage, wparam, lparam);
        case edwpMDIChild:
            return DefMDIChildProc(hwnd, uMessage, wparam, lparam);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by plvtest.rc
//
#define IDS_JSS_HANKAKU_ALPHA           1
#define IDS_JSS_SYMBOL_ALNUM            2
#define IDS_JSS_HIRA_KATA               3
#define IDS_JSS_GREEK                   4
#define IDS_JSS_RUSSIAN                 5
#define IDS_JSS_SPECIAL                 6
#define IDS_JSS_KANJI_1                 7
#define IDS_JSS_KANJI_2                 8
#define IDS_JSS_KANJI_3                 9
#define IDS_JSS_GAIJI                   10
#define IDS_USS_BASIC_LATIN             11
#define IDS_USS_LATIN_1_SUPPLEMENT      12
#define IDS_USS_LATIN_EXTENDED_A        13
#define IDS_USS_LATIN_EXTENDED_B        14
#define IDS_USS_IPA_EXTENSIONS          15
#define IDS_USS_SPACING_MODIFIER_LETTERS 16
#define IDS_USS_COMBINING_DIACRITICAL_MARKS 17
#define IDS_USS_GREEK                   18
#define IDS_USS_CYRILLIC                19
#define IDS_USS_ARMENIAN                20
#define IDS_USS_HEBREW                  21
#define IDS_USS_ARABIC                  22
#define IDS_USS_DEVANAGARI              23
#define IDS_USS_BENGALI                 24
#define IDS_USS_GURMUKHI                25
#define IDS_USS_GUJARATI                26
#define IDS_USS_ORIYA                   27
#define IDS_USS_TAMIL                   28
#define IDS_USS_TELUGU                  29
#define IDS_USS_KANNADA                 30
#define IDS_USS_MALAYALAM               31
#define IDS_USS_THAI                    32
#define IDS_USS_LAO                     33
#define IDS_USS_TIBETAN                 34
#define IDS_USS_GEORGIAN                35
#define IDS_USS_HANGUL_JAMO             36
#define IDS_USS_LATIN_EXTENDED_ADDITIONAL 37
#define IDS_USS_GREEK_EXTENDED          38
#define IDS_USS_GENERAL_PUNCTUATION     39
#define IDS_USS_SUPERSCRIPTS_AND_SUBSCRIPTS 40
#define IDS_USS_CURRENCY_SYMBOLS        41
#define IDS_USS_COMBINING_MARKS_FOR_SYMBOLS 42
#define IDS_USS_LETTERLIKE_SYMBOLS      43
#define IDS_USS_NUMBER_FORMS            44
#define IDS_USS_ARROWS                  45
#define IDS_USS_MATHEMATICAL_OPERATORS  46
#define IDS_USS_MISCELLANEOUS_TECHNICAL 47
#define IDS_USS_CONTROL_PICTURES        48
#define IDS_USS_OPTICAL_CHARACTER_RECOGNITION 49
#define IDS_USS_ENCLOSED_ALPHANUMERICS  50
#define IDS_USS_BOX_DRAWING             51
#define IDS_USS_BLOCK_ELEMENTS          52
#define IDS_USS_GEOMETRIC_SHAPES        53
#define IDS_USS_MISCELLANEOUS_SYMBOLS   54
#define IDS_USS_DINGBATS                55
#define IDS_USS_CJK_SYMBOLS_AND_PUNCTUATION 56
#define IDS_USS_HIRAGANA                57
#define IDS_USS_KATAKANA                58
#define IDS_USS_BOPOMOFO                59
#define IDS_USS_HANGUL_COMPATIBILITY_JAMO 60
#define IDS_USS_KANBUN                  61
#define IDS_USS_ENCLOSED_CJK_LETTERS_AND_MONTHS 62
#define IDS_USS_CJK_COMPATIBILITY       63
#define IDS_USS_CJK_UNIFIED_IDEOGRAPHS  64
#define IDS_USS_HANGUL_SYLLABLES        65
#define IDS_USS_HIGH_SURROGATES         66
#define IDS_USS_HIGH_PRIVATE_USE_SURROGATES 67
#define IDS_USS_LOW_SURROGATES          68
#define IDS_USS_PRIVATE_USE             69
#define IDS_USS_CJK_COMPATIBILITY_IDEOGRAPHS 70
#define IDS_USS_ALPHABETIC_PRESENTATION_FORMS 71
#define IDS_USS_ARABIC_PRESENTATION_FORMS_A 72
#define IDS_USS_COMBINING_HALF_MARKS    73
#define IDS_USS_CJK_COMPATIBILITY_FORMS 74
#define IDS_USS_SMALL_FORM_VARIANTS     75
#define IDS_USS_ARABIC_PRESENTATION_FORMS_B 76
#define IDS_USS_HALFWIDTH_AND_FULLWIDTH_FORMS 77
#define IDS_USS_SPECIALS                78
#define IDS_SUBSET                      79
#define IDS_FONT                        80
#define IDS_CODE_UNICODE                81
#define IDS_CODE_SJIS                   82
#define IDI_ICON1                       100
#define IDD_PADLIST                     106
#define IDD_PLVLIST                     106
#define IDD_LISTREPORT                  109
#define IDD_PLVREPORT                   109
#define IDD_PARENT                      110
#define IDB_BITMAP1                     111
#define IDC_BUTTON1                     1024
#define IDC_LIST1                       1027
#define IDC_CHECK1                      1028
#define IDC_BUTTON2                     1032
#define IDC_BUTTON3                     1033
#define IDC_BTN_2                       1034
#define IDC_CHARTYPE                    1035
#define IDC_FONT                        1036
#define IDC_CODE                        1037
#define IDC_COMBO1                      1038
#define IDC_BTN_SWITCH                  1039

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1040
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\testlist.h ===
#ifndef _TEST_LIST_H_ 
#define _TEST_LIST_H_ 
HWND TestList_Create(HINSTANCE hInst, HWND hwndParent);
#endif //_TEST_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\testlist.cpp ===
#include "imewarn.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include "resource.h"
#include "testlist.h"
#include <stdio.h>
#include "plv.h"
#include "dbg.h"

extern HINSTANCE g_hInst;
LRESULT CALLBACK ListWndProc(HWND  hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HWND TestList_Create(HINSTANCE hInst, HWND hwndParent)
{
	return CreateDialog(hInst, MAKEINTRESOURCE(IDD_PLVLIST), hwndParent, (DLGPROC)ListWndProc);
}


INT WINAPI GetItemForIcon(LPARAM lParam, INT index, LPPLVITEM lpPlvItem)
{
	static WCHAR wchCode[2];
	wchCode[0] = (WCHAR)(index + (WCHAR)lParam);
	lpPlvItem->lpwstr = wchCode;
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : GetItemForReport
// Type     : INT WINAPI
// Purpose  : Get report view's line data.
// Args     : 
//          : LPARAM lParam 
//          : INT index 
//          : INT colCount 
//          : LPPLVITEM lpPlvItem 
// Return   : 
// DATE     : 970705, spec changed. see plv.h
//////////////////////////////////////////////////////////////////
INT WINAPI GetItemForReport(LPARAM lParam, INT index, INT colCount, LPPLVITEM lpPlvItemList)
{
	static WCHAR wchChar[5][64];
	int i;
	for(i = 0; i < colCount; i++) {
		switch(i) { 
		case 0:
			lpPlvItemList[i].fmt = PLVFMT_TEXT;
			wchChar[i][0] = (WCHAR)(index + (WCHAR)lParam);
			wchChar[i][1] = (WCHAR)0x0000;
			lpPlvItemList[i].lpwstr = wchChar[0];
			break;
		case 1:
			lpPlvItemList[i].fmt = PLVFMT_BITMAP;
			lpPlvItemList[i].hBitmap = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP1));
			break;
		case 2:
		case 3:
		case 4:
			lpPlvItemList[i].fmt = PLVFMT_TEXT;
			swprintf(wchChar[i], L" Line %d - Colmun %d", index, i);
			lpPlvItemList[i].lpwstr = wchChar[i];
			break;
		default:
			break;
		}
	}
	return 0;
}

#define IDC_LISTVIEW   10
LRESULT CALLBACK ListWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg) {
	case WM_INITDIALOG:
		{
			HWND hwndLv = PadListView_CreateWindow(g_hInst,			//Instance handle
												   hwnd,			//parent window handle
												   IDC_LISTVIEW,	// Window ID.	
												   10,				// x position
												   10,				// y position
												   400,				// width
												   200,				// height	
												   WM_USER+1);		// notify msg.
			PadListView_SetItemCount(hwndLv, 6000);
			PadListView_SetIconItemCallback(hwndLv, (LPARAM)0x4e00, GetItemForIcon);
			PadListView_SetReportItemCallback(hwndLv, (LPARAM)0x4e00, GetItemForReport);
			PadListView_SetIconFont(hwndLv, "MS UI Gothic", 18);
			PadListView_SetReportFont(hwndLv, "MS UI Gothic", 12);
			PadListView_SetStyle(hwndLv, PLVSTYLE_ICON);
			INT i;
			for(i = 0; i < 5; i++) {
				PLV_COLUMN plvCol;
				char szBuf[30];
				wsprintf(szBuf, "column %d", i+1);
				plvCol.mask = PLVCF_FMT | PLVCF_WIDTH | PLVCF_TEXT;
				plvCol.fmt  = PLVCFMT_LEFT;
				plvCol.pszText = szBuf;
				plvCol.cx	   = 70;	
				plvCol.cchTextMax = lstrlen(szBuf);
				PadListView_InsertColumn(hwndLv, i, &plvCol);
			}
		}
		return 1;
	case WM_USER+1:
		{
			LPPLVINFO lpPlvInfo = (LPPLVINFO)lParam;
			OutputDebugStringA("----------------start---------------------------\n");
			DBG(("idCtrl    [%d]\n", (INT)wParam));
			DBG(("code      [%d][%s]\n", lpPlvInfo->code,
				 lpPlvInfo->code == PLVN_ITEMPOPED				? "PLVN_ITEMPOPED"				:
				 lpPlvInfo->code == PLVN_ITEMCLICKED			? "PLVN_ITEMCLICKED"			:
				 lpPlvInfo->code == PLVN_ITEMCOLUMNCLICKED		? "PLVN_ITEMCOLUMNCLICKED"		:
				 lpPlvInfo->code == PLVN_ITEMDBLCLICKED			? "PLVN_ITEMDBLCLICKED"			:
				 lpPlvInfo->code == PLVN_ITEMCOLUMNDBLCLICKED	? "PLVN_ITEMCOLUMNDBLCLICKED"	:
				 lpPlvInfo->code == PLVN_R_ITEMCLICKED			? "PLVN_R_ITEMCLICKED"			:
				 lpPlvInfo->code == PLVN_R_ITEMCOLUMNCLICKED	? "PLVN_R_ITEMCOLUMNCLICKED"	:
				 lpPlvInfo->code == PLVN_R_ITEMDBLCLICKED		? "PLVN_R_ITEMDBLCLICKED"		:
				 lpPlvInfo->code == PLVN_R_ITEMCOLUMNDBLCLICKED ? "PLVN_R_ITEMCOLUMNDBLCLICKED" :
				 lpPlvInfo->code == PLVN_HDCOLUMNCLICKED		? "PLVN_HDCOLUMNCLICKED"		: "UNKNOWN"));
			DBG(("index     [%d]\n", lpPlvInfo->index));
			DBG(("pt        x[%d] y[%d]\n",
				 lpPlvInfo->pt.x,
				 lpPlvInfo->pt.y));
			DBG(("colIndex  [%d]\n", lpPlvInfo->colIndex));
			DBG(("itemRect    L[%3d] T[%3d] R[%3d] B[%3d]\n", 
				 lpPlvInfo->itemRect.left,
				 lpPlvInfo->itemRect.top,
				 lpPlvInfo->itemRect.right,
				 lpPlvInfo->itemRect.bottom));
			DBG(("colItenRect L[%3d] T[%3d] R[%3d] B[%3d]\n",
				 lpPlvInfo->colItemRect.left,    
				 lpPlvInfo->colItemRect.top,     
				 lpPlvInfo->colItemRect.right,   
				 lpPlvInfo->colItemRect.bottom));
			OutputDebugStringA("----------------end---------------------------\n");
		}
		break;
	case WM_COMMAND:
		switch(LOWORD(wParam)) {
		case IDOK:
		case IDCANCEL:
			DestroyWindow(hwnd);
			break;
		case IDC_BTN_SWITCH:
			DBG(("IDC_BTN_SWITCH COME\n"));
			if(PLVSTYLE_ICON == PadListView_GetStyle(GetDlgItem(hwnd, IDC_LISTVIEW))) {
				PadListView_SetStyle(GetDlgItem(hwnd, IDC_LISTVIEW), PLVSTYLE_REPORT);
			}
			else {
				PadListView_SetStyle(GetDlgItem(hwnd, IDC_LISTVIEW), PLVSTYLE_ICON);
			}
			break;
		}
		break;
	default:
		break;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\strutil.h ===
#ifndef _STR_UTIL_H_
#define _STR_UTIL_H_

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(disable :4706) //4706    "̔rl͑̌ʂɂȂĂ܂"
//----------------------------------------------------------------
//ANSI version string utility
//----------------------------------------------------------------
#define	StrlenW		lstrlenW
#define StrlenA		lstrlenA
#define StrcpyA		lstrcpyA
#define StrcatA		lstrcatA
#define StrcmpA		lstrcmp

inline int __cdecl StrncmpA(const char * first,
							const char * last,
							unsigned int count)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last) {
		first++;
		last++;
	}
	return *(unsigned char *)first - *(unsigned char *)last;
}

inline char * __cdecl StrncpyA(char * dest,	const char * source, unsigned int count)
{
	char *start = dest;

	while (count && (*dest++ = *source++))	/* copy string */
		count--;

	if (count)								/* pad out with zeroes */
		while (--count)
			*dest++ = '\0';

	return(start);
}

inline char * __cdecl StrchrA(const char * string, int ch)
{
	while (*string && *string != (char)ch)
		string++;

	if (*string == (char)ch)
		return((char *)string);
	return NULL;
}

//----------------------------------------------------------------
//Unicode version string utility
//----------------------------------------------------------------
inline WCHAR * __cdecl StrchrW(const WCHAR * string, int ch)
{
	while (*string && *string != (WCHAR)ch)
		string++;

	if (*string == (WCHAR)ch)
		return((WCHAR *)string);
	return NULL;
}

inline int __cdecl StrncmpW(const WCHAR * first,
							const WCHAR * last,
							unsigned int count)
{
	if (!count)
		return(0);

	while (--count && *first && *first == *last) {
		first++;
		last++;
	}
	return *first - *last;
}

inline int __cdecl StrcmpW(const WCHAR * first, const WCHAR * last)
{
	for (; *first && *last && (*first == *last); first++, last++);
	return (*first - *last);
}

inline WCHAR * __cdecl StrcpyW(WCHAR * dest, const WCHAR * source)
{
	WCHAR *start = dest;

	while (*dest++ = *source++);

	return(start);
}

inline WCHAR * __cdecl StrncpyW(WCHAR * dest,
								const WCHAR * source,
								unsigned int count)

{
	WCHAR *start = dest;

	while (count && (*dest++ = *source++))	/* copy string */
		count--;

	if (count)								/* pad out with zeroes */
		while (--count)
			*dest++ = 0;

	return(start);
}

inline WCHAR * __cdecl StrcatW(WCHAR * dest, const WCHAR * source)
{
	WCHAR *start = dest;
	WCHAR *pwch;

	for (pwch = dest; *pwch; pwch++);
	while (*pwch++ = *source++);

	return(start);
}


#ifdef __cplusplus
}
#endif
#endif //_STR_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\plv\plvtest\testmain.cpp ===
#include "imewarn.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "resource.h"
#include "testlist.h"

/* testmain.cpp */
extern BOOL InitApplication(HINSTANCE hInst, LPSTR lpstrClass, WNDPROC lpfnWndProc);
extern HWND MainCreateWindow(HINSTANCE hInst, HWND hwndOwner, LPSTR lpstrClass, LPVOID lpVoid);
extern LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
extern int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);

char g_szClass[]="TestMain";
HINSTANCE g_hInst;
BOOL InitApplication(HINSTANCE hInst, LPSTR lpstrClass, WNDPROC lpfnWndProc)
{
	return 0;
}

HWND MainCreateWindow(HINSTANCE hInst, HWND hwndOwner, LPSTR lpstrClass, LPVOID lpVoid)
{
	HWND hwnd;
	hwnd = CreateDialogParam(hInst, 
							 g_szClass, 
							 hwndOwner, 
							 NULL, 
							 (LPARAM)lpVoid);
	if(!hwnd) {
		return (HWND)NULL;
	}
	UpdateWindow(hwnd);
	return hwnd;
}

LRESULT CALLBACK MainWndProc(HWND	hwnd,
							 UINT	uMsg,
							 WPARAM	wParam,
							 LPARAM	lParam)
{
	LRESULT hres;
	HWND hwndDlg;
	LPDRAWITEMSTRUCT lpdi;
		LPMEASUREITEMSTRUCT lpmi = (LPMEASUREITEMSTRUCT)lParam;
	BOOL bDraw;
	switch(uMsg) {
	case WM_CREATE:
		break;
	//case WM_HITTESET:
	//	break;
	case WM_NCHITTEST:
		break;
	case WM_MOUSEACTIVATE:
		//return MA_NOACTIVATEANDEAT;
		break;
	case WM_SYSCOMMAND:
		{
			UINT uCmdType = wParam;        // type of system command requested
			switch(uCmdType) {
			case SC_CLOSE:
				PostQuitMessage(0);
				break;
			}
		}
		break;
	case WM_COMMAND:
		switch(LOWORD(wParam)) {
		case IDC_BUTTON1:
			hwndDlg = TestList_Create(g_hInst, hwnd);
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
	return DefWindowProc(hwnd, uMsg, wParam, lParam);


	//hres = DispMessage(&msdiMain, hwnd, uMsg, wParam, lParam);
	//return hres;
}

int WINAPI WinMain(HINSTANCE hInstance,
				   HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine,
				   int nCmdShow)
{

	MSG msg;
	HWND hwnd;
	INT ret;
	
	g_hInst = hInstance;
	WNDCLASSEX  wc;
	ZeroMemory(&wc, sizeof(wc));

	wc.cbSize			= sizeof(wc);
	wc.style			= CS_HREDRAW | CS_VREDRAW;	 /* Class style(s). */
	wc.lpfnWndProc		= (WNDPROC)MainWndProc;
	wc.cbClsExtra		= 0;					/* No per-class extra data.*/
	wc.cbWndExtra		= DLGWINDOWEXTRA;		/* No per-window extra data.		  */
	wc.hInstance		= hInstance;			/* Application that owns the class.	  */
	wc.hIcon			= NULL; //LoadIcon(hInstance, MAKEINTRESOURCE(SCROLL32_ICON));
	wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground	= GetStockObject(LTGRAY_BRUSH); //WHITE_BRUSH); 
	wc.lpszMenuName		= NULL; //g_szClass;    /* Name of menu resource in .RC file. */
	wc.lpszClassName	= g_szClass;	  /* Name used in call to CreateWindow. */
	wc.hIconSm = NULL;
	RegisterClassEx(&wc);

	hwnd = CreateDialog(hInstance, 
						g_szClass, 
						0, 
						NULL);

	UpdateWindow(hwnd); 
	ShowWindow(hwnd, SW_SHOW);
	while (GetMessage(&msg, NULL, 0, 0)){
		TranslateMessage(&msg);
		DispatchMessage(&msg); 
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\cdwtt.h ===
#ifndef __C_DWTT_H__
#define __C_DWTT_H__
#include "ptt.h"

inline LPVOID GetHWNDPtr(HWND hwnd)
{
#ifdef _WIN64
	return (LPVOID)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	return (LPVOID)::GetWindowLong(hwnd, GWL_USERDATA);
#endif
}

inline LPVOID SetHWNDPtr(HWND hwnd, LPVOID lpVoid)
{
#ifdef _WIN64
	return (LPVOID)::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpVoid);
#else
	return (LPVOID)::SetWindowLong(hwnd, GWL_USERDATA, (LONG)lpVoid);
#endif
}

//----------------------------------------------------------------
//Disabled Window ToolTip class
//----------------------------------------------------------------
// For Disabled Window Tool Tip data
//----------------------------------------------------------------
typedef struct tagXINFO {
	struct tagXINFO		*next;
	INT					whichEvent;			//TTM_RELAYEVNET or TTM_RELAYEVENT_WITHUSERINFO
	TOOLTIPUSERINFO		userInfo;
	TOOLINFOW			toolInfoW;
}XINFO, *LPXINFO;

class CDWToolTip;
typedef CDWToolTip *LPCDWToolTip;

class CDWToolTip
{
public:
	CDWToolTip(HWND hwnd);
	~CDWToolTip();
	BOOL Enable(HWND hwndToolTip, BOOL fEnable);	
	void *operator new(size_t size);
	void operator  delete(void *p);
	static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
private:
	LRESULT RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT MsgCreate		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT MsgPrintClient	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT MsgPaint		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT	MsgTimer		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT	MsgDestroy		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT	MsgSetFont		(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_SetDelayTime(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_AddToolW	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT	TTM_DelToolW	(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_NewToolRectW(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_RelayEventWithUserInfo(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_RelayEvent(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_GetSetToolInfoW(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT TTM_GetToolCount(HWND hwnd, WPARAM wParam, LPARAM lParam);
	BOOL	SetWindowAnimate(HWND hwnd);
	LPWSTR	GetTipTextW(VOID);
	INT		GetTipSize	(LPSIZE lpSize);	
	INT		DrawTipText	(HDC hDC, LPRECT lpRc, LPWSTR lpwstr);
	BOOL	IsMousePointerIn(VOID);
	BOOL	IsSameInfo(LPXINFO lpXInfo1, LPXINFO lpXInfo2);
	static POSVERSIONINFO GetVersionInfo();
	static BOOL	IsWinNT4(VOID);
	static BOOL	IsWinNT5(VOID);
	static BOOL	IsWinNT(VOID);
	static BOOL	IsWin98(VOID);
	static BOOL	IsWin95(VOID);
private:
	HWND	m_hwndSelf;
	HFONT	m_hFont;
	BOOL	m_fShow;			//Already show or not;
	DWORD	m_dwDelayFlag;
	DWORD   m_dwDelayTime;
	DWORD	m_dwDurationTime;
	LPXINFO	m_lpXInfoHead;
	LPXINFO	m_lpXInfoCur;
	XINFO	m_xInfoPrev;		//New 971104
	MSG		m_curRelayMsg;
	BOOL	m_fEnable;		//if FALSE never show tooltip;
};
#endif // __C_DWTT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\dbg.cpp ===
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#pragma warning(disable:4057)
#pragma warning(disable:4115)
#pragma warning(disable:4200)
#pragma warning(disable:4201)
#pragma warning(disable:4209)
#pragma warning(disable:4214)
#pragma warning(disable:4218)
#pragma warning(disable:4310)
#pragma warning(disable:4514)
#pragma warning(disable:4699)
#pragma warning(disable:4710)

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <stdarg.h>
#include "dbg.h"
#include <stdio.h>

static IsWinNT()
{
	static OSVERSIONINFO os;
	if(os.dwOSVersionInfoSize == 0) { 
		os.dwOSVersionInfoSize = sizeof(os);
		::GetVersionEx(&os);
	}
	return (os.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

//----------------------------------------------------------------
//internal function prototype declare
//----------------------------------------------------------------
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath);
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath);
VOID   _pttDbgPrintfA			(LPSTR  lpstrFmt, ...);
VOID   _pttDbgPrintfW			(LPWSTR lpstrFmt, ...);

//----------------------------------------------------------------
// Global Data
//----------------------------------------------------------------
static LPFNDBGCALLBACKA g_lpfnDbgCBA;
static LPFNDBGCALLBACKW g_lpfnDbgCBW;
static BOOL g_fEnable=FALSE;
inline VOID ODStrW(LPWSTR lpwstr)
{
	if(g_fEnable) OutputDebugStringW(lpwstr);
}
inline VOID ODStrA(LPSTR lpstr)
{
	if(g_fEnable) OutputDebugStringA(lpstr);
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgSetCallback
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPFNDBGCALLBACK lpfnDbgCallback 
// Return   : 
// DATE     : Tue Jan 06 12:42:36 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgSetCallback(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW)
{
	g_lpfnDbgCBA = lpfnCBA;
	g_lpfnDbgCBW = lpfnCBW;
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgSwitchOutput
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:35:55 1998
// Author   : 
//////////////////////////////////////////////////////////////////
VOID _pttDbgEnableOutput(BOOL fEnable)
{
	g_fEnable = fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgIsOutputEnable
// Type     : VOID
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 18:00:52 1998
// Author   : 
//////////////////////////////////////////////////////////////////
BOOL _pttDbgIsOutputEnable(VOID)
{
	return g_fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgOutStrA
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Tue Jan 06 12:29:39 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgOutStrA(LPSTR lpstr)
{
	static BOOL fIn;
	ODStrA(lpstr);
#ifdef _CONSOLE
	printf(lpstr);
#endif

	if(g_lpfnDbgCBA) {
		if(fIn) { return; }
		fIn = TRUE;
		(*g_lpfnDbgCBA)(lpstr);
		fIn = FALSE;
	}
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgOutStrW
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpwstr 
// Return   : 
// DATE     : Tue Jan 06 12:30:07 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgOutStrW(LPWSTR lpwstr)
{
	static BOOL fIn;

	if(IsWinNT()) {
		ODStrW(lpwstr);
	}
	else {
		static CHAR szBuf[1024];
		::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
		ODStrA(szBuf);
	}

#ifdef _CONSOLE
	static CHAR szBuf[1024];
	::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
	printf(szBuf);
#endif
	if(g_lpfnDbgCBW) { 
		if(fIn) { return; } 		
		fIn = TRUE;
		(*g_lpfnDbgCBW)(lpwstr);
		fIn = FALSE;
	}
	return;
}

////////////////////////////////////////////////////////
// Function: _pttDbgA
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _pttDbgA(LPSTR		lpstrFile, 
			 INT		lineNo, 
			 LPSTR		lpstrMsg)
{
	_pttDbgPrintfA("(%12s:%4d) %s", 
				 GetFileTitleStrA(lpstrFile),
				 lineNo,
				 lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFile 
//          : INT lineNo 
//          : LPWSTR lpstrMsg 
// Return   : 
// DATE     : Mon Jan 05 15:10:41 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg)
{
	_pttDbgPrintfW(L"(%12s:%4d) %s", 
			   GetFileTitleStrW(lpstrFile),
			   lineNo,
			   lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgVaStrA
// Type     : LPSTR
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:09:53 1998
//////////////////////////////////////////////////////////////////
LPSTR _pttDbgVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(chBuf, lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function : _pttDbgVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _pttDbgVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap);	//Use C-RunTime Library for Win95
	va_end(ap);
	return wchBuf;
}


////////////////////////////////////////////////////////
// Function: _pttDbgPrintfA
// Type    : VOID
// Purpose : variable args version of OutputDebugStringA
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _pttDbgPrintfA(LPSTR lpstrFmt, ...)
{
	static CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	_pttDbgOutStrA(szBuf);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgPrintfW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:11:24 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgPrintfW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap); //Use C-RunTime Library for Win95
	va_end(ap);
	_pttDbgOutStrW(wchBuf);
	return;
}


//////////////////////////////////////////////////////////////////
// Function : _pttDbgMulti2Wide
// Type     : LPWSTR
// Purpose  : return Unicode string from MBCS string
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Mon Jan 05 15:10:48 1998
//////////////////////////////////////////////////////////////////
LPWSTR _pttDbgMulti2Wide(LPSTR lpstr)
{
	static WCHAR wchBuf[512];
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}


//////////////////////////////////////////////////////////////////
// Function : _pttDbgGetWinClass
// Type     : LPSTR
// Purpose  : Get Windows class name string
//			  ANSI version only.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:08:43 1998
//////////////////////////////////////////////////////////////////
LPSTR _pttDbgGetWinClass(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetClassNameA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;

}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgGetWinText
// Type     : LPSTR
// Purpose  : Get Windows text(title) string
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:09:08 1998
//////////////////////////////////////////////////////////////////
LPSTR _pttDbgGetWinText(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetWindowTextA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgMsgBoxA
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Thu Jan 08 12:31:03 1998
//////////////////////////////////////////////////////////////////
VOID _pttDbgMsgBoxA(LPSTR lpstrFile,  INT lineNo, LPSTR lpstrMsg)
{
#ifdef _CONSOLE
	return;
#endif
	char szTmp[512];
	wsprintf(szTmp, "Debug Message Box (File: %s, Line: %4d)", 
			   GetFileTitleStrA(lpstrFile), 
			   lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
}

VOID _pttDbgAssert(LPSTR  lpstrFile,  INT lineNo, BOOL fOk, LPSTR lpstrMsg)
{
	if(fOk) {
		return; 
	}
	char szTmp[512];
	wsprintf(szTmp, "ASSERT (File: %s, Line: %4d)", 
			 GetFileTitleStrA(lpstrFile), 
			 lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
	DebugBreak();
}

//////////////////////////////////////////////////////////////////
// Function : _pttDbgGetErrorString
// Type     : LPSTR
// Purpose  : Convert Error(Got from GetLastError()) value to ERROR Message String
// Args     : 
//          : INT errorCode 
// Return   : 
// DATE     : Mon Jan 05 16:43:34 1998
//////////////////////////////////////////////////////////////////
LPSTR _pttDbgGetErrorString(INT errorCode)
{
	static CHAR szBuf[512];
	INT count;
	szBuf[0] = (CHAR)0x00;
	count = wsprintf(szBuf, "[0x%08x]:", errorCode);
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   errorCode, 
				   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				   szBuf+count,
				   sizeof(szBuf)-1-count,
				   NULL );
	if(*(szBuf + count) != (CHAR)0x00) {
		int nLen = lstrlenA(szBuf);
		if((nLen - count) > 1) {
			szBuf[nLen - 1] = (CHAR)0x00;
		}
	}
	return szBuf;
}


//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrA
// Type     : static LPSTR
// Purpose  : Return File name string(remove folder)
// Args     : 
//          : LPSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:34:22 1998
//////////////////////////////////////////////////////////////////
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath)
{
	static CHAR szBuf[2];
	CHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenA(lpstrFilePath) - 1);
	for(pTemp = CharPrevA(lpstrFilePath, pLast); 
		(pTemp  != lpstrFilePath) && 
		(*pTemp != '\\')	 &&
		(*pTemp != (CHAR)0x00); 
		pTemp = CharPrevA(lpstrFilePath, pTemp)) {
		;
	}
	if(*pTemp == '\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}

//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrW
// Type     : static LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:38:19 1998
//////////////////////////////////////////////////////////////////
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath)
{
	static WCHAR szBuf[2];
	WCHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenW(lpstrFilePath) - 1);
	for(pTemp = pLast-1;
		(pTemp != lpstrFilePath) &&
		(*pTemp != L'\\')		 &&
		(*pTemp != (WCHAR)0x0000);
		pTemp--) {
		;
	}

	if(*pTemp == L'\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\cdwtt.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "ptt.h"
#include "cdwtt.h"
#include "dbg.h"
#include "exgdiw.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

//----------------------------------------------------------------
//Animate window const value
//----------------------------------------------------------------
#define AW_HOR_POSITIVE             0x00000001
#define AW_HOR_NEGATIVE             0x00000002
#define AW_VER_POSITIVE             0x00000004
#define AW_VER_NEGATIVE             0x00000008
#define AW_CENTER                   0x00000010
#define AW_HIDE                     0x00010000
#define AW_ACTIVATE                 0x00020000
#define AW_SLIDE                    0x00040000
#define AW_BLEND                    0x00080000

//----------------------------------------------------------------
//local Timer id
//----------------------------------------------------------------
#define TID_SHOW		3
#define TID_MONITOR		4
#define TID_DURATION	5

#ifdef MemAlloc
#undef MemAlloc
#endif
#ifdef MemFree
#undef MemFree
#endif

#define MemAlloc(a)		GlobalAllocPtr(GHND, a)
#define MemFree(a)		GlobalFreePtr(a);
#define MAX(a, b)	((a) > (b) ? (a) : (b))
#define UnrefMsg()		UNREFERENCED_PARAMETER(hwnd); \
						UNREFERENCED_PARAMETER(wParam); \
						UNREFERENCED_PARAMETER(lParam)

#if 0
typedef struct {  // ti  
    UINT      cbSize; 
    UINT      uFlags; 
    HWND      hwnd; 
    UINT      uId; 
    RECT      rect; 
    HINSTANCE hinst; 
    LPTSTR     lpszText; 
} TOOLINFO, NEAR *PTOOLINFO, FAR *LPTOOLINFO; 

typedef struct tagTOOLINFOW {
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT uId;
    RECT rect;
    HINSTANCE hinst;
    LPWSTR lpszText;
} TOOLINFOW, NEAR *PTOOLINFOW, FAR *LPTOOLINFOW;
#endif

LPXINFO XInfo_New(VOID)
{
	LPXINFO lpXif = (LPXINFO)MemAlloc(sizeof(XINFO));
	if(lpXif) {
		ZeroMemory(lpXif, sizeof(XINFO));
	}
	return lpXif;
}

LRESULT CALLBACK CDWToolTip::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPCDWToolTip lpCDWTT;
	switch(uMsg) {
#ifndef UNDER_CE // Windows CE does not support WM_NCCREATE/WM_NCDESTROY
	case WM_NCCREATE:
		lpCDWTT = new CDWToolTip(hwnd);
		SetHWNDPtr(hwnd, lpCDWTT);
		break;
	case WM_NCDESTROY:
		lpCDWTT = (LPCDWToolTip)::GetHWNDPtr(hwnd);
		SetHWNDPtr(hwnd, NULL);
		if(lpCDWTT) {
			delete lpCDWTT;
		}
		break;
#else // UNDER_CE
	case WM_CREATE:
		lpCDWTT = new CDWToolTip(hwnd);
		SetHWNDPtr(hwnd, lpCDWTT);
		if(lpCDWTT) {
			return lpCDWTT->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	case WM_DESTROY:
		lpCDWTT = (LPCDWToolTip)GetHWNDPtr(hwnd);
		if(lpCDWTT) {
			lpCDWTT->RealWndProc(hwnd, uMsg, wParam, lParam);
			SetHWNDPtr(hwnd, NULL);
			delete lpCDWTT;
		}
		break;
#endif // UNDER_CE
	default:
		lpCDWTT = (LPCDWToolTip)GetHWNDPtr(hwnd);
		if(lpCDWTT) {
			return lpCDWTT->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void *CDWToolTip::operator new(size_t size)
{
	BYTE *p = (BYTE *)MemAlloc(size);
	if(p) {
		ZeroMemory(p, size);
	}
	return (void *)p;
}

void  CDWToolTip::operator delete(void *pv)
{
	if(pv) {
		MemFree(pv);
	}
}

CDWToolTip::CDWToolTip(HWND hwnd)
{
	m_hwndSelf = hwnd;
	m_hFont	   = NULL;	
}

CDWToolTip::~CDWToolTip()
{
	//do nothing
}

LRESULT CDWToolTip::RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg) {
	case WM_CREATE:
		return MsgCreate(hwnd, wParam, lParam);
	case WM_PAINT:
		return MsgPaint	(hwnd, wParam, lParam);
#ifndef UNDER_CE // Not support
	case WM_PRINTCLIENT:
		return MsgPrintClient(hwnd, wParam, lParam);
#endif // UNDER_CE
	case WM_TIMER:
		return MsgTimer(hwnd, wParam, lParam);
	case WM_DESTROY:
		return MsgDestroy(hwnd, wParam, lParam);
	case WM_SETFONT:
		return MsgSetFont(hwnd, wParam, lParam);
	case TTM_SETDELAYTIME:
		return TTM_SetDelayTime(hwnd, wParam, lParam);
	case TTM_ADDTOOLW:
		return TTM_AddToolW(hwnd, wParam, lParam);
	case TTM_DELTOOLW:
		return TTM_DelToolW(hwnd, wParam, lParam);
	case TTM_NEWTOOLRECTW:
		return TTM_NewToolRectW(hwnd, wParam, lParam);
	case TTM_RELAYEVENT_WITHUSERINFO:
		return TTM_RelayEventWithUserInfo(hwnd, wParam, lParam);
	case TTM_RELAYEVENT:
		return TTM_RelayEvent(hwnd, wParam, lParam);
	case TTM_GETTOOLINFOW:
	case TTM_SETTOOLINFOW:
		return TTM_GetSetToolInfoW(hwnd, uMsg, wParam, lParam);
	case TTM_GETTOOLCOUNT:
		return TTM_GetToolCount(hwnd, wParam, lParam);
	default:
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}


LRESULT CDWToolTip::MsgCreate(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	m_hwndSelf = hwnd;
	m_fEnable  = TRUE; //970812: new to show or hide tooltip explicitly 
	return 1;
	UnrefMsg();
}

LRESULT CDWToolTip::MsgPrintClient(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
#ifndef UNDER_CE // Not support
	Dbg(("WM_PRINTCLIENT COME lParam[0x%08x]\n", lParam));
	RECT rc;
	POINT		pt;
	GetCursorPos(&pt);
	GetClientRect(hwnd, &rc);
	HDC hDC = (HDC)wParam;
	HFONT hFontOld = NULL;
	if(m_hFont) {
		hFontOld = (HFONT)::SelectObject(hDC, m_hFont);
	}
	else {
		hFontOld = (HFONT)::SelectObject(hDC, GetStockObject(DEFAULT_GUI_FONT));
	}
	LPWSTR lpwstr = GetTipTextW();
	if(lpwstr) {
		DrawTipText(hDC, &rc, lpwstr);
	}
	::SelectObject(hDC, hFontOld);
#endif // UNDER_CE
	return 0;
	UNREFERENCED_PARAMETER(lParam);
}

LRESULT CDWToolTip::MsgSetFont(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	HFONT hFont = (HFONT)wParam;
	BOOL  fRedraw = LOWORD(lParam);

	if(!hFont) {
		return 0;
	}

#ifndef UNDER_CE
	LOGFONTA logFont;
#else // UNDER_CE
	LOGFONT logFont;
#endif // UNDER_CE
	HFONT hFontNew;
	::GetObject(hFont, sizeof(logFont), &logFont);
	hFontNew = ::CreateFontIndirect(&logFont);

	if(!hFontNew) {
		return 0;
	}
	if(m_hFont) {
		::DeleteObject(m_hFont);
	}
	m_hFont = hFontNew;
	if(fRedraw) {
		::InvalidateRect(hwnd, NULL, TRUE);
	}
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::MsgPaint(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	PAINTSTRUCT ps;
	RECT		rc;
#ifndef UNDER_CE // Windows CE does not support GetCursorPos
	POINT		pt;
	::GetCursorPos(&pt);
#endif // UNDER_CE
	::GetClientRect(hwnd, &rc);

	HDC hDC = ::BeginPaint(hwnd, &ps);
	HFONT hFontOld = NULL;
	if(m_hFont) {
		hFontOld = (HFONT)::SelectObject(hDC, m_hFont);
	}
	else {
		hFontOld = (HFONT)::SelectObject(hDC, GetStockObject(DEFAULT_GUI_FONT));
	}
	LPWSTR lpwstr = GetTipTextW();
	if(lpwstr) {
		DrawTipText(hDC, &rc, lpwstr);
	}
	::SelectObject(hDC, hFontOld);
	::EndPaint(hwnd, &ps);
	//Dbg(("--->WM_PAINT END\n"));
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::MsgTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	static POINT	pt;
	static SIZE		size;
	static RECT		rect;
	static BOOL fAnimate;

#ifndef UNDER_CE // Windows CE does not support GetCursorPos
	::GetCursorPos(&pt);
#else // UNDER_CE
	if(m_lpXInfoCur){
		pt = m_lpXInfoCur->userInfo.pt;
		ClientToScreen(m_lpXInfoCur->userInfo.hwnd, &pt);
	}
#endif // UNDER_CE
	switch(wParam) {
	case TID_SHOW:
		//Dbg(("TID_SHOW COME\n"));
		KillTimer(hwnd, TID_SHOW);
		SetTimer(hwnd, TID_MONITOR, 20, NULL);
		SetTimer(hwnd, TID_DURATION, 6000, NULL);
		//get cur mouse pos
		//show tool tip window
		//call invalidate rect
		//set monitoring timer
		if(0 == GetTipSize(&size)) {
			if(m_fEnable) {
				//Dbg(("-->GetTipSize ret 0\n"));
				if(IsMousePointerIn()) {
					//Dbg(("-->Call SetWindowPos\n"));
					//990530: KOTAE #433
					INT cxScr = ::GetSystemMetrics(SM_CXSCREEN);
					INT cyScr = ::GetSystemMetrics(SM_CYSCREEN);
					
					if(cxScr < (pt.x + size.cx)) {
						pt.x = cxScr - size.cx;
					}

					if(cyScr < pt.y + 20 + size.cy) {
						pt.y = cyScr - (20*2 + size.cy);
					}

					SetWindowPos(hwnd, 
								 HWND_TOP, 
								 pt.x, pt.y+20,
								 size.cx, size.cy, 
								 SWP_NOACTIVATE | SWP_HIDEWINDOW |SWP_NOOWNERZORDER);

					fAnimate = SetWindowAnimate(hwnd);
					if(!fAnimate)
						SetWindowPos(hwnd, 
									 HWND_TOP, 
									 pt.x, pt.y+20, 
									 size.cx, size.cy, 
									 SWP_NOACTIVATE | SWP_SHOWWINDOW | SWP_NOOWNERZORDER);

					//Dbg(("-->SetWindowPos End\n"));

					m_fShow = TRUE;

					if(!fAnimate)
						InvalidateRect(hwnd, NULL, NULL);

					//Dbg(("-->Invalidate Rect End\n"));
				}
			}
		}
		//Dbg(("TID_SHOW END\n"));
		break;
	case TID_MONITOR:
		{
			//Dbg(("TID_MONITOR COME\n"));
			HWND hwndOwner = (HWND)GetWindow(hwnd, GW_OWNER);
			if(!IsMousePointerIn() || NULL == GetTipTextW() || !IsWindowVisible(hwndOwner) ) {
				//Dbg(("---> Hide Window\n"));
				::SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
							   SWP_HIDEWINDOW |
							   SWP_NOACTIVATE |
							   SWP_NOZORDER   | 
							   SWP_NOSIZE		| 
							   SWP_NOMOVE);
				//Dbg(("Set curInfo NULL\n"));
				m_lpXInfoCur = NULL;
				m_fShow = FALSE;
				::KillTimer(hwnd, TID_MONITOR);
				::KillTimer(hwnd, TID_DURATION);
			}
		}
		break;
	case TID_DURATION:
		//Dbg(("TID_DURATION START\n"));
		SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
					 SWP_NOZORDER   |
					 SWP_NOSIZE     |
					 SWP_HIDEWINDOW |
					 SWP_NOACTIVATE);
		//Dbg(("Set curInfo NULL\n"));
		//lptt->lpXInfoCur = NULL;
		m_fShow = FALSE;
		::KillTimer(hwnd, TID_MONITOR);
		::KillTimer(hwnd, TID_DURATION);
		break;
	default:
		break;
	}
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::MsgDestroy(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	Dbg(("WM_DESTORY START\n"));
	::KillTimer(hwnd, TID_SHOW);
	::KillTimer(hwnd, TID_MONITOR);
	::KillTimer(hwnd, TID_DURATION);
	LPXINFO lpXInfo, lpXInfoNext;
	m_lpXInfoCur = NULL;
	INT i;
	for(lpXInfo = m_lpXInfoHead, i = 0;
		lpXInfo;
		lpXInfo = lpXInfoNext, i++){
		lpXInfoNext = lpXInfo->next;
		//Dbg(("-->%d: Free XInfo\n", i));
		MemFree(lpXInfo);
	}
	if(m_hFont) {
		::DeleteObject(m_hFont); 
		m_hFont = NULL;
	}
	Dbg(("--->WM_DESTORY END\n"));
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_SetDelayTime(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	switch(wParam) {
	case TTDT_AUTOMATIC:
		break;
	case TTDT_RESHOW:
		break;
	case TTDT_AUTOPOP:
		break;
	case TTDT_INITIAL:
		break;
	}
	m_dwDelayFlag = (DWORD)wParam;
	m_dwDelayTime = (DWORD)lParam;
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_AddToolW(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	TOOLINFOW *lpTi = (LPTOOLINFOW)lParam;
	if(!lpTi) {
		Dbg(("################### lParam is NULLL\n"));
		return 0;
	}
	if(lpTi->cbSize !=  sizeof(TOOLINFOW)) {
		Dbg(("##### TTM_ADDTOOLW size ERROR\n"));
		return 0;
	}
	LPXINFO *ppXInfo, lpXInfoNew;
	lpXInfoNew = XInfo_New();
	if(!lpXInfoNew) {
		return 0;
	}
	lpXInfoNew->toolInfoW = *lpTi;
	for(ppXInfo = &m_lpXInfoHead; 
		*ppXInfo; 
		ppXInfo = &(*ppXInfo)->next){
	}
	*ppXInfo = lpXInfoNew;
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_DelToolW(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	TOOLINFOW *lpTi = (LPTOOLINFOW)lParam;
	if(!lpTi) {
		Dbg(("################### lParam is NULLL\n"));
		return 0;
	}
	if(lpTi->cbSize !=  sizeof(TOOLINFOW)) {
		return 0;
	}
	LPXINFO *ppXInfo, lpXInfoTmp;
	for(ppXInfo = &m_lpXInfoHead; *ppXInfo; ppXInfo = &(*ppXInfo)->next){
		if((*ppXInfo)->toolInfoW.hwnd == lpTi->hwnd &&
		   (*ppXInfo)->toolInfoW.uId  == lpTi->uId) {
			lpXInfoTmp = *ppXInfo;
			*ppXInfo = (*ppXInfo)->next;
			if(lpXInfoTmp == m_lpXInfoCur) {
				//Dbg(("Set curInfo NULL\n"));
				m_lpXInfoCur = NULL;
			}
			MemFree(lpXInfoTmp);
			Dbg(("TTM_DELTOOLW SUCCEEDED\n"));
			return 0;
			break;
		}
	}
	Dbg(("TTM_DELTOOLW Error END\n"));
	return -1;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_NewToolRectW(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	TOOLINFOW *lpTi = (LPTOOLINFOW)lParam;
	if(lpTi->cbSize !=  sizeof(TOOLINFOW)) {
		return 0;
	}
	LPXINFO *ppXInfo;
	for(ppXInfo = &m_lpXInfoHead; *ppXInfo; ppXInfo = &(*ppXInfo)->next) {
		if((*ppXInfo)->toolInfoW.hwnd == lpTi->hwnd &&
		   (*ppXInfo)->toolInfoW.uId  == lpTi->uId) {
			if(m_lpXInfoCur == *ppXInfo) {
				m_xInfoPrev = *(m_lpXInfoCur);
			}
			(*ppXInfo)->toolInfoW = *lpTi;
			break;
		}
	}
	return 0;
	UnrefMsg();
}

// SendMessage(hwnd, TTM_RELAYEVENT_WITHUESRINFO, 0, LPTOOLTIPUSERINFO lpInfo);
LRESULT CDWToolTip::TTM_RelayEventWithUserInfo(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	INT i;
	LPXINFO *ppXInfo;
	LPTOOLTIPUSERINFO lpUserInfo = (LPTOOLTIPUSERINFO)lParam;
	//Dbg(("TTM_RELAYEVENT_WITHUSERINFO START\n"));
	if(!lpUserInfo) {
		//Dbg(("--->TTM_RELAYEVENT_WITHUSERINFO ERROR END\n"));
		return 0;
	}
	for(i = 0, ppXInfo = &m_lpXInfoHead; 
		*ppXInfo;
		i++, ppXInfo = &(*ppXInfo)->next) {
		UINT uFlags = (*ppXInfo)->toolInfoW.uFlags;
		if(uFlags & TTF_IDISHWND) {
			if((HWND)(*ppXInfo)->toolInfoW.uId == lpUserInfo->hwnd) {
				//Dbg(("[%d]Find info with hwnd index\n", i));
				break;
			}
		}
		else {
#ifdef _DEBUG //970915:
			if(!IsWindow(lpUserInfo->hwnd)) {
				Dbg(("############## hwnd corrupted [0x%08x]\n", 
					 lpUserInfo->hwnd));
				DebugBreak();
			}
			if(!IsWindow((*ppXInfo)->toolInfoW.hwnd)) {
				Dbg(("############## hwnd corrupted [0x%08x]\n", 
					 (*ppXInfo)->toolInfoW.hwnd));
				DebugBreak();
			}
#endif
			if(lpUserInfo->hwnd == GetDlgItem((*ppXInfo)->toolInfoW.hwnd, 
											  (INT)(*ppXInfo)->toolInfoW.uId)) {
				break;
			}
			else if(lpUserInfo->hwnd == (*ppXInfo)->toolInfoW.hwnd) {
				if(PtInRect(&(*ppXInfo)->toolInfoW.rect, lpUserInfo->pt)) {
					break;
				}
			}
#if 0
			if(PtInRect(&(*ppXInfo)->toolInfoW.rect, lpUserInfo->pt)) {
				Dbg(("[%d]Find INFO with id [%d]\n", i, (*ppXInfo)->toolInfoW.uId));
				break;
			}
#endif
		}
	} 
	if(*ppXInfo) {
		//m_curRelayMsg = *lpmsg;
		if(m_lpXInfoCur == *ppXInfo) {  // Same info is used.
			//check specified rect is same or not
			// it is very dirty code.....
			// if rectangle is same. 
			if((lpUserInfo->rect.left   == (*ppXInfo)->userInfo.rect.left ) &&
			   (lpUserInfo->rect.top    == (*ppXInfo)->userInfo.rect.top  ) &&
			   (lpUserInfo->rect.right  == (*ppXInfo)->userInfo.rect.right) &&
			   (lpUserInfo->rect.bottom == (*ppXInfo)->userInfo.rect.bottom)) { 
				//Dbg(("Set Timer 500\n"));
				//SetTimer(hwnd, TID_SHOW, 500, NULL);
			}
			else {
				//if rectangl is NOT same, it should be displayed now
				//Dbg(("Set Timer 10\n"));
				SetTimer(hwnd, TID_SHOW, 100, NULL);
			}
		}
		else {  
			SetTimer(hwnd, TID_SHOW, 500, NULL);
		}
		(*ppXInfo)->whichEvent = TTM_RELAYEVENT_WITHUSERINFO;
		(*ppXInfo)->userInfo   = *lpUserInfo;
		m_lpXInfoCur = *ppXInfo;
		//Dbg(("--->TTM_REUSER END\n"));
	}
	else {
		//Dbg(("Set curInfo NULL\n"));
		m_lpXInfoCur = NULL;
		//Dbg(("--->TTM_REUSER CUR NULL END\n"));
	}
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_RelayEvent(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	LPMSG lpmsg = (LPMSG)lParam;
	INT	i;
	LPXINFO *ppXInfo; //lpXInfo; //, lpXInfoCur;
	if(!lpmsg) {
		return 0;
	}
	switch(lpmsg->message) {
	case WM_LBUTTONDOWN:
	case WM_MOUSEMOVE:
	case WM_LBUTTONUP:
	case WM_RBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
		for(i = 0, ppXInfo = &m_lpXInfoHead; 
			*ppXInfo;
			i++, ppXInfo = &(*ppXInfo)->next) {
			UINT uFlags = (*ppXInfo)->toolInfoW.uFlags;
			if(uFlags & TTF_IDISHWND) {
				if((HWND)(*ppXInfo)->toolInfoW.uId == lpmsg->hwnd) {
					//Dbg(("[%d]Find info with hwnd index\n", i));
					break;
				}
			}
			else {
				POINT pt;
				pt.x = LOWORD(lpmsg->lParam);
				pt.y = HIWORD(lpmsg->lParam);
				if(PtInRect(&(*ppXInfo)->toolInfoW.rect, pt)) {
					//Dbg(("[%d]Find INFO with id [%d]\n", i, (*ppXInfo)->toolInfoW.uId));
					break;
				}
			}
		} 
		if(*ppXInfo) {
			m_curRelayMsg = *lpmsg;
			(*ppXInfo)->whichEvent = TTM_RELAYEVENT;
			if(m_lpXInfoCur) { 
				if(m_lpXInfoCur != *ppXInfo) {
					//Dbg(("-->SetTimer TID_SHOW with 100msec\n"));
					SetTimer(hwnd, TID_SHOW, 100, NULL);
					m_xInfoPrev = *m_lpXInfoCur;
				}
				else {  
					//----------------------------------------------------------------
					//m_lpXInfoCur is not changed.
					//check rectangle, other information is same or not
					//----------------------------------------------------------------
					if(!IsSameInfo(&m_xInfoPrev, *ppXInfo)) { 
						SetTimer(hwnd, TID_SHOW, 100, NULL);
						m_xInfoPrev = **ppXInfo;
					}
				}
				//else {
				//	SetTimer(hwnd, TID_SHOW, 500, NULL);
				//}
				
			}
			else {  
				//Dbg(("-->SetTimer TID_SHOW with 500msec\n"));
				SetTimer(hwnd, TID_SHOW, 500, NULL);
			}
			m_lpXInfoCur = *ppXInfo;
		}
		else {
			//Dbg(("Set curInfo NULL\n"));
			m_lpXInfoCur = NULL;
		}
		break;
	default:
		break;
	}
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_GetSetToolInfoW(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPTOOLINFOW lpTi = (LPTOOLINFOW)lParam;
	if(lpTi->cbSize != sizeof(TOOLINFOW)) {
		return 0;
	}
	LPXINFO *ppXInfo;
	for(ppXInfo = &m_lpXInfoHead; *ppXInfo; ppXInfo = &(*ppXInfo)->next) {
		if((*ppXInfo)->toolInfoW.hwnd == lpTi->hwnd && 
		   (*ppXInfo)->toolInfoW.uId  == lpTi->uId) {
			if(uMsg == TTM_GETTOOLINFOW) {
				(*lpTi) = (*ppXInfo)->toolInfoW;
			}
			else {
				(*ppXInfo)->toolInfoW = *lpTi;
			}
			break;
		}
	}
	return 0;
	UnrefMsg();
}

LRESULT CDWToolTip::TTM_GetToolCount(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	INT i;
	LPXINFO *ppXInfo;
	for(i = 0, ppXInfo = &m_lpXInfoHead;
		*ppXInfo;
		ppXInfo = &(*ppXInfo)->next, i++) {
	}
	return i;
	UnrefMsg();
}

BOOL CDWToolTip::Enable(HWND hwndToolTip, BOOL fEnable)
{
	if(m_hwndSelf != hwndToolTip) {
		//Dbg(("ToolTip Enable Invalid Window Handle\n"));
		return 0;
	}
	m_fEnable = fEnable;
	m_fShow   = fEnable;
	if(!fEnable) { //if fEnable FALSE
		::SetWindowPos(hwndToolTip, NULL, 0, 0, 0, 0, 
					   SWP_HIDEWINDOW |
					   SWP_NOACTIVATE |
					   SWP_NOZORDER   | 
					   SWP_NOSIZE	  | 
					   SWP_NOMOVE);
		::KillTimer(hwndToolTip, TID_SHOW);
		::KillTimer(hwndToolTip, TID_MONITOR);
		::KillTimer(hwndToolTip, TID_DURATION);
	}
	return 0;
}

LPWSTR CDWToolTip::GetTipTextW(VOID)
{
	static TOOLTIPTEXTW			toolTipTextW;
	static TOOLTIPTEXTUSERINFO	ttTextUserInfo;
	INT idCtrl;
	if(!m_lpXInfoCur) {
		//Dbg(("GetTipTextW m_lpXInfoCur is NULL\n"));
		return NULL;
	}
	if(m_lpXInfoCur->toolInfoW.uFlags & TTF_IDISHWND) {
		idCtrl = GetDlgCtrlID((HWND)m_lpXInfoCur->toolInfoW.uId);
	}
	else {
		idCtrl = (INT)m_lpXInfoCur->toolInfoW.uId;
	}
	switch(m_lpXInfoCur->whichEvent) {
	case TTM_RELAYEVENT_WITHUSERINFO:
		ZeroMemory((LPVOID)&ttTextUserInfo, sizeof(ttTextUserInfo));
		ttTextUserInfo.hdr.hwndFrom = m_hwndSelf;
		ttTextUserInfo.hdr.idFrom   = idCtrl;
		ttTextUserInfo.hdr.code     = TTN_NEEDTEXT_WITHUSERINFO;
		ttTextUserInfo.userInfo   = m_lpXInfoCur->userInfo;
		::SendMessage(m_lpXInfoCur->toolInfoW.hwnd, 
					  WM_NOTIFY, 
					  (WPARAM)0, 
					  (LPARAM)&ttTextUserInfo);
#if _DEBUG
		if(!toolTipTextW.lpszText) {
			//Dbg(("###### Text is NULL\n"));
		}
#endif
		return (LPWSTR)ttTextUserInfo.lpszText;
		break;
	case TTM_RELAYEVENT:
	default:
		ZeroMemory((LPVOID)&toolTipTextW, sizeof(toolTipTextW));
		toolTipTextW.hdr.hwndFrom = m_hwndSelf;
		toolTipTextW.hdr.idFrom   = idCtrl;
		toolTipTextW.hdr.code     = TTN_NEEDTEXTW;
		toolTipTextW.hinst			= m_lpXInfoCur->toolInfoW.hinst;
		toolTipTextW.uFlags			= m_lpXInfoCur->toolInfoW.uFlags;
		if(m_lpXInfoCur->toolInfoW.lpszText == LPSTR_TEXTCALLBACKW) {
			if(!m_lpXInfoCur->toolInfoW.hwnd) {
				//Dbg(("###### hwnd is NULL\n"));
				return NULL;
			}
			if(!IsWindow(m_lpXInfoCur->toolInfoW.hwnd)) {
				//Dbg(("###### hwnd is Corrupted?\n"));
				return NULL;
			}
			SendMessage(m_lpXInfoCur->toolInfoW.hwnd, 
						WM_NOTIFY, 
						(WPARAM)0, 
						(LPARAM)&toolTipTextW);
#ifdef _DEBUG 
			if(!toolTipTextW.lpszText) {
				//Dbg(("###### Text is NULL\n"));
			}
#endif
			return (LPWSTR)toolTipTextW.lpszText;
		}
		break;
	}
	return NULL;
}

INT CDWToolTip::GetTipSize(LPSIZE lpSize)
{
	LPWSTR lpwstr = GetTipTextW();
	HDC hDC;
	SIZE size;
	INT	 i;
	LPWSTR lp, lpTop;
	//Dbg(("GetTipSize START \n"));

	if(!lpSize) {
		//Dbg(("-->GetTipSize ERROR END\n"));
		return -1;
	}
	if(!lpwstr) {
		//Dbg(("--->GetTipSize lpwstr is NULL\n"));
		return -1;
	}
	//DBGW((L"lpwst [%s]\n", lpwstr));
#ifdef _DEBUG 
	if(!IsWindow(m_hwndSelf)) {
		//Dbg(("######### hwnd is Corrupted [0x%08x]\n", m_hwndSelf));
		DebugBreak();
	}
#endif
	hDC = ::GetDC(m_hwndSelf);
	HFONT hFontOld = NULL;
	if(m_hFont) {
		hFontOld = (HFONT)::SelectObject(hDC, m_hFont);
	}
	else { 
		hFontOld = (HFONT)::SelectObject(hDC, GetStockObject(DEFAULT_GUI_FONT));
	}
	lpSize->cx = lpSize->cy = 0;
	for(i=0, lpTop = lp = lpwstr;;lp++) {
		if(*lp == (WCHAR)L'\n') {
			//Dbg(("Find return i[%d]\n", i));
			ExGetTextExtentPoint32W(hDC, lpTop, i, &size);
			//Dbg(("cx[%d] cy[%d]\n", size.cx, size.cy));
			lpSize->cx = MAX(lpSize->cx, size.cx);
			lpSize->cy += size.cy;
			lpTop = lp+1;
			i = 0;
		}
		else if (*lp == (WCHAR)0x0000) {
			ExGetTextExtentPoint32W(hDC, lpTop, i, &size);
			lpSize->cx = MAX(lpSize->cx, size.cx);
			lpSize->cy += size.cy;
			break;
		}
		else {
			i++;
		}
	}
	lpSize->cx += 4;
	lpSize->cy += 4;
	::SelectObject(hDC, hFontOld);
	::ReleaseDC(m_hwndSelf, hDC);
	//Dbg(("TIP SIZE cx[%d] cy[%d]\n", lpSize->cx, lpSize->cy));
	//Dbg(("-->GetTipSize NORMAL END\n"));
	return 0;
}

INT CDWToolTip::DrawTipText(HDC hDC, LPRECT lpRc, LPWSTR lpwstr)
{
	SIZE size;
	INT	 i, j;
	LPWSTR lp, lpTop;
	if(!lpwstr) {
		return 0;
	}
	if(!lpRc) {
		return 0;
	}
	INT yOffset = 0;
#ifndef UNDER_CE
	::FillRect(hDC, lpRc, (HBRUSH)(COLOR_INFOBK + 1));
#else // UNDER_CE
	::FillRect(hDC, lpRc, GetSysColorBrush(COLOR_INFOBK));
#endif // UNDER_CE
	COLORREF dwOldTC = ::SetTextColor(hDC, GetSysColor(COLOR_INFOTEXT));
	DWORD oldMode = ::SetBkMode(hDC, TRANSPARENT);
	// Init size
	size.cx = size.cy = 0;
	
	for(i=j=0, lpTop = lp = lpwstr;;lp++) {
		if(*lp == L'\n' || *lp == (WCHAR)0x0000) {
			ExGetTextExtentPoint32W(hDC, lpTop, i, &size);
			//Dbg(("Length %d\n", i));
			ExExtTextOutW(hDC,
						  lpRc->left + 1,
						  lpRc->top  + 1 + yOffset,
						  ETO_CLIPPED, lpRc,
						  lpTop, 
						  i,
						  NULL);
			if(*lp == (WCHAR)0x0000) {
				break;
			}
			lpTop = lp+1;
			i = 0;
			j++;
			yOffset += size.cy;
		}
		else {
			i++;
		}
	}
	::SetTextColor(hDC, dwOldTC);
	::SetBkMode(hDC, oldMode);
	return 0;
}

BOOL CDWToolTip::IsMousePointerIn(VOID)
{
	POINT	pt;
	RECT	rect;
	HWND hwndTarget;

	//Dbg(("IsMousePointerIn START\n"));
#ifndef UNDER_CE // Windows CE does not support GetCursorPos
	::GetCursorPos(&pt);
#else // UNDER_CE
	if(m_lpXInfoCur){
		pt = m_lpXInfoCur->userInfo.pt;
		ClientToScreen(m_lpXInfoCur->userInfo.hwnd, &pt);
	}
#endif // UNDER_CE
	if(!m_lpXInfoCur) {
		//Dbg(("--->IsMousePointer in ERROR END\n"));
		return FALSE;
	}
	if(m_lpXInfoCur->toolInfoW.uFlags & TTF_IDISHWND) {
		hwndTarget = (HWND)m_lpXInfoCur->toolInfoW.uId;
		//Dbg(("---> TYPE TTF_IDISHWND hwnd[0x%08x]\n", hwndTarget ));
		if(IsWindow(hwndTarget)) {
			//Dbg(("--->IsWindow OK\n"));
			GetWindowRect(hwndTarget, &rect);
			//Dbg(("--->GetWindowRect OK\n"));
			if(PtInRect(&rect, pt)) {
				return TRUE;
			}
			return FALSE;
		}
		else {
			//Dbg(("################ hwndTarget[0x%08x] IS CORRUPTED\n", hwndTarget));
		}
	}
	else {
		switch(m_lpXInfoCur->whichEvent) {
		case TTM_RELAYEVENT:
			//OLD_970808
			::ScreenToClient(m_lpXInfoCur->toolInfoW.hwnd, &pt);
			if(::PtInRect(&m_lpXInfoCur->toolInfoW.rect, pt)) {
				return TRUE;
			}
			break;
		case TTM_RELAYEVENT_WITHUSERINFO:
			if(IsWindow(m_lpXInfoCur->toolInfoW.hwnd)) {
				HWND hwndCmd = GetDlgItem(m_lpXInfoCur->toolInfoW.hwnd, 
										  (INT)m_lpXInfoCur->toolInfoW.uId);
				RECT rc;
				::GetClientRect(hwndCmd, &rc);
				//LPRECT lpRc = &rc;
#if 0
				Dbg(("--->t[%d]l[%d]r[%d]b[%d]\n",
					 lpRc->top,
					 lpRc->left,
					 lpRc->right,
					 lpRc->bottom));			
#endif
				::ScreenToClient(hwndCmd, &pt);
				Dbg(("--->pt.x[%d] pt.y[%d]\n", pt.x, pt.y));
				if(PtInRect(&rc, pt)) {
					if(PtInRect(&m_lpXInfoCur->userInfo.rect, pt)) {
						return TRUE;
					}
				}
				else {
					//Dbg(("--->Is Mouse PtInRect Error END\n"));
				}
			}
			else {
				Dbg(("################ hwndTarget[0x%08x] IS CORRUPTED\n", 
					 m_lpXInfoCur->toolInfoW.hwnd));
			}
			break;
		}
	}
	//Dbg(("--->Is Mouse PtInRect Error END\n"));
	return FALSE;
}

BOOL CDWToolTip::IsSameInfo(LPXINFO lpXInfo1, LPXINFO lpXInfo2)
{
	if(!lpXInfo1 || !lpXInfo2) {
		return FALSE;
	}
	switch(lpXInfo1->whichEvent) {
	case TTM_RELAYEVENT:
		if(lpXInfo2->whichEvent != TTM_RELAYEVENT) {
			return FALSE;
		}
		if((lpXInfo1->toolInfoW.uFlags != lpXInfo2->toolInfoW.uFlags) || 
		   (lpXInfo1->toolInfoW.hwnd   != lpXInfo2->toolInfoW.hwnd)   ||
		   (lpXInfo1->toolInfoW.uId    != lpXInfo2->toolInfoW.uId)    ||
		   (lpXInfo1->toolInfoW.rect.top   != lpXInfo2->toolInfoW.rect.top)   ||
		   (lpXInfo1->toolInfoW.rect.left  != lpXInfo2->toolInfoW.rect.left)  ||
		   (lpXInfo1->toolInfoW.rect.right != lpXInfo2->toolInfoW.rect.right) ||
		   (lpXInfo1->toolInfoW.rect.bottom!= lpXInfo2->toolInfoW.rect.bottom)) {
			return FALSE;
		}
		break;
	case TTM_RELAYEVENT_WITHUSERINFO:
		if(lpXInfo2->whichEvent != TTM_RELAYEVENT_WITHUSERINFO) {
			return FALSE;
		}
		if((lpXInfo1->userInfo.hwnd != lpXInfo2->userInfo.hwnd) ||
		   (lpXInfo1->userInfo.pt.x != lpXInfo2->userInfo.pt.x) ||
		   (lpXInfo1->userInfo.pt.y != lpXInfo2->userInfo.pt.y) ||
		   (lpXInfo1->userInfo.rect.top    != lpXInfo2->userInfo.rect.top)    ||
		   (lpXInfo1->userInfo.rect.left   != lpXInfo2->userInfo.rect.left)   ||
		   (lpXInfo1->userInfo.rect.right  != lpXInfo2->userInfo.rect.right)  ||
		   (lpXInfo1->userInfo.rect.bottom != lpXInfo2->userInfo.rect.bottom)) {
			return FALSE;
		}
		break;
	} 
	return TRUE;
}

//----------------------------------------------------------------
POSVERSIONINFO CDWToolTip::GetVersionInfo()
{
    static BOOL fFirstCall = TRUE;
    static OSVERSIONINFO os;

    if ( fFirstCall ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &os ) ) {
            fFirstCall = FALSE;
        }
    }
    return &os;
}

BOOL CDWToolTip::IsWinNT4() 
{ 
	BOOL fNT4;
	fNT4 = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
		(GetVersionInfo()->dwMajorVersion >= 4);

	return fNT4;
}

BOOL CDWToolTip::IsWinNT5() 
{ 
	BOOL fNT5;
	fNT5 = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
		(GetVersionInfo()->dwMajorVersion == 5);

	return fNT5;
}

BOOL CDWToolTip::IsWinNT()
{
	return (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT);
}

BOOL CDWToolTip::IsWin95(VOID)
{
	if(GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
		return TRUE;
	}
	return FALSE;
}

BOOL CDWToolTip::IsWin98() 
{ 
	BOOL fMemphis;
	fMemphis = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
		(GetVersionInfo()->dwMajorVersion >= 4) &&
		(GetVersionInfo()->dwMinorVersion  >= 10);

	return fMemphis;
}

//----------------------------------------------------------------
//----------------------------------------------------------------
//VC6 does NOT defined 
//#define SPI_GETMENUANIMATION                0x1002
//#define SPI_GETTOOLTIPANIMATION             0x1016
//----------------------------------------------------------------
#define MY_SPI_GETMENUANIMATION                0x1002
#define MY_SPI_GETTOOLTIPANIMATION             0x1016
typedef BOOL (WINAPI *LPFNANIMATEWINDOW)(HWND hwnd, DWORD dwTime, DWORD dwFlag);
BOOL CDWToolTip::SetWindowAnimate(HWND hwnd)
{
	//----------------------------------------------------------------
	//08/16/00
	//Satori #2239. Animate window show HourGlass cursor,
	//when owner window is Disabled and very weird.
	//We should stop animate tool tip in Office10
	//----------------------------------------------------------------
	return FALSE;
	UNREFERENCED_PARAMETER(hwnd);
#if 0

#ifndef UNDER_CE // No support
	HMODULE hLib;
	LPFNANIMATEWINDOW lpfnProc;
	BOOL fRet, fAnimate;
	//----------------------------------------------------------------
	//00/08/01 for Satori #2239
	//for Win98: can use SPI_GETMENUANIMATION for Tooltip.
	//for Win2K: can use SPI_GETTOOLTIPANIMATION for Tooltip.
	//----------------------------------------------------------------
	if(IsWin98() || IsWinNT5()) {
		if(IsWin98()) {
			fRet = SystemParametersInfo(MY_SPI_GETMENUANIMATION,
										0,
										&fAnimate,
										FALSE);
			if(!fRet || !fAnimate) {
				return 0;
			}
		}
		else { //Win2K()
			fRet = SystemParametersInfo(MY_SPI_GETTOOLTIPANIMATION,
										0,
										&fAnimate,
										FALSE);
			if(!fRet || !fAnimate) {
				return 0;
			}
		}

		hLib = GetModuleHandle("user32");
		if(!hLib) {
			return 0;
		}
		lpfnProc = (LPFNANIMATEWINDOW)GetProcAddress(hLib, "AnimateWindow");
		if(lpfnProc) {
			INT ret = (*lpfnProc)(hwnd, 200, AW_VER_POSITIVE|AW_SLIDE);
			Dbg(("ret [%d] lasterror[%d]\n", ret, GetLastError()));
			return ret;
		}
	}
#endif // UNDER_CE
	return 0;
#endif //if 0
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\dbg.h ===
//////////////////////////////////////////////////////////////////
// File     : dbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef _DBG_H_
#define _DBG_H_

#ifdef __cplusplus
#	define InlineFunc  inline
#else 
#	define InlineFunc  __inline
#endif

//----------------------------------------------------------------
// Callback function prototype
//----------------------------------------------------------------
typedef VOID (WINAPI *LPFNDBGCALLBACKA)(LPSTR  lpstr);
typedef VOID (WINAPI *LPFNDBGCALLBACKW)(LPWSTR lpwstr);

//-------------------------------------------------------
//MACRO function  prototype declare.
//It is valid only if compliled with _DEBUG definition.
//-------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function : DBGSetCallback
// Type     : VOID
// Purpose  : Set debug callback function.
//			  callback function has set, when DBG() has called,
//			  call this callback function with formatted message string.
// Args     : 
//          : LPFNDBGCALLBACKA lpfnDbgCallbackA 
//          : LPFNDBGCALLBACKW lpfnDbgCallbackW 
// Return   : VOID
// DATE     : Tue Jan 06 12:21:05 1998
//////////////////////////////////////////////////////////////////
//VOID DBGSetCallback(LPFNDBGCALLBACKA lpfnDbgCallbackA, LPFNDBGCALLBACKW lpfnDbgCallbackW);

//////////////////////////////////////////////////////////////////
// Function : DBGEnableOutput
// Type     : VOID
// Purpose  : On off OutputDebugString to COM.
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:33:21 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//VOID DBGEnableOutput(BOOL fEnable)

//////////////////////////////////////////////////////////////////
// Function : DBGIsOutputEnable
// Type     : BOOL
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 17:58:28 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//BOOL DBGIsOutputEnable(VOID)


////////////////////////////////////////////////////////
// Function	: DBG
// Type		: VOID
// Purpose	: Printing ANSI debug message with same usage as printf()
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// Example	: DBGW(("Error occured data[%d]", i));
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//		   : ...	
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example	: DBGW(("Error occured data[%d]", i));
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

//////////////////////////////////////////////////////////////////
// Function : DBGMsgBox
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example	: DBGMsgBox(("Error occured data[%d]", i));
//////////////////////////////////////////////////////////////////
//VOID DBGMsgBox((LPSTR lpstrFmt, ...))

//////////////////////////////////////////////////////////////////
// Function : DBGAssert
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fError
// Return   : 
// DATE     : Fri Jan 09 17:17:31 1998
//////////////////////////////////////////////////////////////////
//VOID DBGAssert(BOOL fError)


//////////////////////////////////////////////////////////////////
// Function : DBGSTR
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr
//////////////////////////////////////////////////////////////////
//VOID DBGSTR(LPSTR lpstr);


//////////////////////////////////////////////////////////////////
// Function : DBGGetErrorString
// Type     : VOID
// Purpose  : Get error message from WIN32 Error code.
// Args     : 
//          : INT errorCode 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetErrorString(INT errorCode)


//////////////////////////////////////////////////////////////////
// Function : DBGGetWinClass
// Type     : LPSTR
// Purpose  : Get class name string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinClass(HWND hwnd)

//////////////////////////////////////////////////////////////////
// Function : DBGGetWinText
// Type     : LPSTR
// Purpose  : Get title text string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinText(HWND hwnd)



#ifdef _DEBUG
//----------------------------------------------------------------
//Function prototype declare
//----------------------------------------------------------------
extern VOID   _pttDbgEnableOutput	(BOOL fEnable);
extern BOOL   _pttDbgIsOutputEnable	(VOID);
extern VOID	  _pttDbgSetCallback		(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW);
extern VOID   _pttDbgA				(LPSTR  lpstrFile, INT lineNo, LPSTR  lpstrMsg);
extern VOID   _pttDbgW				(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _pttDbgMsgBoxA			(LPSTR  lpstrFile,  INT lineNo, LPSTR lpstrMsg);
extern VOID   _pttDbgAssert			(LPSTR  lpstrFile,  INT lineNo, BOOL fError, LPSTR lpstrMsg);
extern VOID   _pttDbgPrintfA			(LPSTR  lpstrFmt, ...);
extern VOID   _pttDbgPrintfW			(LPWSTR lpstrFmt, ...);
extern VOID   _pttDbgOutStrA			(LPSTR  lpstr);
extern VOID	  _pttDbgOutStrW			(LPWSTR lpwstr);
extern LPSTR  _pttDbgVaStrA			(LPSTR  lpstrFmt, ...);
extern LPWSTR _pttDbgVaStrW			(LPWSTR lpstrFmt, ...);
extern LPWSTR _pttDbgMulti2Wide		(LPSTR  lpstr);
extern LPSTR  _pttDbgGetWinClass		(HWND   hwnd);
extern LPSTR  _pttDbgGetWinText		(HWND   hwnd);
extern LPSTR  _pttDbgGetErrorString	(INT    errorCode);
extern LPSTR  _pttDbgGetVkStr		(INT	virtKey);
//----------------------------------------------------------------
// Macro definition
//----------------------------------------------------------------
#	define DBGSetCallback(a,b)	_pttDbgSetCallback(a, b)
#	define DBGEnableOutput(a)	_pttDbgEnableOutput(a)
#	define DBGIsOutputEnable()	_pttDbgIsOutputEnable()
#	define Dbg(a)				_pttDbgA(__FILE__, __LINE__, _pttDbgVaStrA a)
#	define DBGA(a)				_pttDbgA(__FILE__, __LINE__, _pttDbgVaStrA a)
#	define DBGW(a)				_pttDbgW( _pttDbgMulti2Wide(__FILE__), __LINE__, _pttDbgVaStrW a)
#	define DBGMsgBox(a)			_pttDbgMsgBoxA(__FILE__, __LINE__, _pttDbgVaStrA a)
#	define DBGAssert(a)			_pttDbgAssert(__FILE__, __LINE__, a, #a)
#	define DBGAssertSz(a,b)		_pttDbgAssert(__FILE__, __LINE__, a, b)
#	define DBGOutStr(a)			_pttDbgOutStrA(a)
#	define DBGOutStrA(a)		_pttDbgOutStrA(a)
#	define DBGOutStrW(a)		_pttDbgOutStrW(a)
#	define DBGP(a)				_pttDbgOutStrA(_pttDbgVaStrA a)
#	define DBGPA(a)				_pttDbgOutStrA(_pttDbgVaStrA a)
#	define DBGPW(a)				_pttDbgOutStrW(_pttDbgVaStrW a)
#	define DBGGetErrorString(a)	_pttDbgGetErrorString(a)
#	define DBGGetWinClass(a)	_pttDbgGetWinClass(a)
#	define DBGGetWinText(a)		_pttDbgGetWinText(a)
#else //!_DEBUG	//in Release version, these will disapear...
#	define DBGSetCallback(a,b)
#	define DBGEnableOutput(a)
#	define DBGIsOutputEnable()
#	define Dbg(a)
#	define DBGW(a)
#	define DBGA(a)
#	define DBGP(a)
#	define DBGPA(a)
#	define DBGPW(a)
#	define DBGAssert(a)
#	define DBGAssertSz(a,b)
#	define DBGMsgBox(a)
#	define DBGOutStr(a)
#	define DBGOutStrA(a)
#	define DBGOutStrW(a)
#	define DBGGetErrorString(a)
#	define DBGGetWinClass(a)
#	define DBGGetWinText(a)
#endif //_DEBUG


//----------------------------------------------------------------
//These function use variable argument, so we cannot define 
//"Normal" MACRO for them.
//so, Use inline function that do nothing if _DEBUG is NOT set.
//----------------------------------------------------------------
InlineFunc VOID DBGDoNothingA(LPSTR  lpstrFmt, ...) { lpstrFmt;}
InlineFunc VOID DBGDoNothingW(LPWSTR lpstrFmt, ...) { lpstrFmt;}
#ifdef _DEBUG 
#define DBGPrintf		_debugPrintfA
#define DBGPrintfA		_debugPrintfA
#define DBGPrintfW		_debugPrintfW
#else 
#define DBGPrintf		DBGDoNothingA
#define DBGPrintfA		DBGDoNothingA
#define DBGPrintfW		DBGDoNothingW
#endif


//----------------------------------------------------------------
//This is helper inline function for outputs debug string in 
//Retail version. if FORCE_DEBUG is defined this function works.
//Some time, we met bugs than occurs only retail version, 
//and would like to out debug message. 
//----------------------------------------------------------------
#ifdef FORCE_DEBUG
#include <stdarg.h>
//////////////////////////////////////////////////////////////////
// Function : FDbg
// Type     : InlineFunc VOID
// Purpose  : 
// Args     : 
//          : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Tue Jan 06 19:06:19 1998
//////////////////////////////////////////////////////////////////
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...)
{
	CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	OutputDebugStringA(szBuf);	
	return;
}
#else //FORCE_DEBUG
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...) { lpstrFmt;}
#endif

#endif //_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\padrs\cmddef.h ===
#ifndef __CMD_DEF_H__
#define __CMD_DEF_H__
//----------------------------------------------------------------
//Please check these are different with res/main/resource.h's IDC_XXX
//----------------------------------------------------------------
#define IDC_KBTN_FIRST					6000
#define IDC_KBTN_BACKSPACE              (IDC_KBTN_FIRST+1)
#define IDC_KBTN_DELETE                 (IDC_KBTN_FIRST+2) 
#define IDC_KBTN_ENTER                  (IDC_KBTN_FIRST+3) 
#define IDC_KBTN_ESCAPE                 (IDC_KBTN_FIRST+4) 
#define IDC_KBTN_SPACE                  (IDC_KBTN_FIRST+5) 
#define IDC_KBTN_FAREAST                (IDC_KBTN_FIRST+6) 
#define IDC_KBTN_ARROWS				    (IDC_KBTN_FIRST+7) 
#define IDC_KBTN_ARROW_LEFT			    (IDC_KBTN_FIRST+8)
#define IDC_KBTN_ARROW_RIGHT		    (IDC_KBTN_FIRST+9)
#define IDC_KBTN_ARROW_UP			    (IDC_KBTN_FIRST+10)
#define IDC_KBTN_ARROW_DOWN			    (IDC_KBTN_FIRST+11)
#define IDC_KBTN_HOME                   (IDC_KBTN_FIRST+12)
#define IDC_KBTN_PAGEUP                	(IDC_KBTN_FIRST+13)
#define IDC_KBTN_TAB                    (IDC_KBTN_FIRST+14)
#define IDC_KBTN_LWIN              		(IDC_KBTN_FIRST+15)
#define IDC_KBTN_END                    (IDC_KBTN_FIRST+16)
#define IDC_KBTN_PAGEDOWN				(IDC_KBTN_FIRST+17)
#define IDC_KBTN_INSERT					(IDC_KBTN_FIRST+18)
#define IDC_KBTN_APPKEY                 (IDC_KBTN_FIRST+19)

#endif // __CMD_DEF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\padrs\padhelp.h ===
//////////////////////////////////////////////////////////////////
// File     :	padhelp.h
// Purpose  :	Each FarEast's help module header. 
// 
// 
// Date     :	Thu May 20 20:43:25 1999
// Author   :	toshiak
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __PAD_HELP_H__
#define __PAD_HELP_H__

#define PADHELPINDEX_MAIN				1	
#define PADHELPINDEX_PROPERTY			2
#define PADHELPINDEX_APPLETMENUCHANGE	3
#define PADHELPINDEX_RESERVED1			4
#define PADHELPINDEX_RESERVED2			5

#define SZPADHELP_HANDLEHELP			TEXT("PadHelp_HandleHelp")
#define SZPADHELP_HANDLECONTEXTPOPUP	TEXT("PadHelp_HandleContextPopup")

//----------------------------------------------------------------
//Add imepadUiLangID
//----------------------------------------------------------------
typedef INT (WINAPI *LPFN_PADHELP_HANDLEHELP)(HWND hwnd, INT padHelpIndex, LANGID imepadUiLangID);
typedef INT (WINAPI *LPFN_PADHELP_HANDLECONTEXTPOPUP)(HWND hwndCtrl, INT idCtrl, LANGID imepadUiLangID);
INT WINAPI PadHelp_HandleHelp(HWND hwnd, INT padHelpIndex, LANGID imepadUiLangID);
INT WINAPI PadHelp_HandleContextPopup(HWND hwndCtrl, INT idCtrl, LANGID imepadUiLangID);

#endif //__PAD_HELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\ptt.cpp ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "cdwtt.h"
#ifdef UNDER_CE // Windows CE specific
#include "stub_ce.h" // Windows CE stub for unsupported APIs
#endif // UNDER_CE

#ifndef UNDER_CE
static char g_szClass[]="fdwtooltip";
#else // UNDER_CE
static TCHAR g_szClass[]=TEXT("fdwtooltip");
#endif // UNDER_CE

#ifdef UNDER_CE // In Windows CE, all window classes are process global.
static LPCTSTR MakeClassName(HINSTANCE hInst, LPTSTR lpszBuf)
{
	// make module unique name
	TCHAR szFileName[MAX_PATH];
	GetModuleFileName(hInst, szFileName, MAX_PATH);
	LPTSTR lpszFName = _tcsrchr(szFileName, TEXT('\\'));
	if(lpszFName) *lpszFName = TEXT('_');
	lstrcpy(lpszBuf, g_szClass);
	lstrcat(lpszBuf, lpszFName);

	return lpszBuf;
}

BOOL ToolTip_UnregisterClass(HINSTANCE hInst)
{
	TCHAR szClassName[MAX_PATH];
	return UnregisterClass(MakeClassName(hInst, szClassName), hInst);
}
#endif // UNDER_CE

HWND WINAPI ToolTip_CreateWindow(HINSTANCE hInst, DWORD dwStyle, HWND hwndOwner)
{
#ifndef UNDER_CE // Windows CE does not support EX
	WNDCLASSEX  wc;
	if(!::GetClassInfoEx(hInst, g_szClass, &wc)) {
#else // UNDER_CE
	TCHAR szClassName[MAX_PATH];
	WNDCLASS  wc;
	if(!::GetClassInfo(hInst, MakeClassName(hInst, szClassName), &wc)) {
#endif // UNDER_CE
		::ZeroMemory(&wc, sizeof(wc));
#ifndef UNDER_CE // Windows CE does not support EX
		wc.cbSize			= sizeof(wc);
#endif // UNDER_CE
		wc.style			= CS_HREDRAW | CS_VREDRAW;
		wc.lpfnWndProc		= (WNDPROC)CDWToolTip::WndProc;
		wc.cbClsExtra		= 0;
		wc.cbWndExtra		= 0;
		wc.hInstance		= hInst;
		wc.hIcon			= NULL; 
		wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
		wc.hbrBackground	= (HBRUSH)NULL;
		wc.lpszMenuName		= NULL; 
#ifndef UNDER_CE // In Windows CE, all window classes are process global.
		wc.lpszClassName	= g_szClass;
#else // UNDER_CE
		wc.lpszClassName	= szClassName;
#endif // UNDER_CE
#ifndef UNDER_CE // Windows CE does not support EX
		wc.hIconSm = NULL;
		::RegisterClassEx(&wc);
#else // UNDER_CE
		::RegisterClass(&wc);
#endif // UNDER_CE
	}
	HWND hwnd;
	//----------------------------------------------------------------
	//for Satori #2239.
	//If create window with WS_DISABLED, AnimateWindow change cursor as hourglass.
	//So, removed WS_DISABLED.
	//----------------------------------------------------------------
	//00/08/08: This fix is NOT enough...
	//Tooltip gets focus...
	//----------------------------------------------------------------
	hwnd =  ::CreateWindowEx(0,
#ifndef UNDER_CE // In Windows CE, all window classes are process global.
							 g_szClass,
#else // UNDER_CE
							 szClassName,
#endif // UNDER_CE
							 NULL,
							 //dwStyle | WS_POPUP | WS_BORDER | WS_VISIBLE, //WS_DISABLED,
							 dwStyle | WS_POPUP | WS_BORDER | WS_DISABLED,
							 0, 0, 0, 0, 
							 hwndOwner,
							 NULL,
							 hInst,
							 NULL);
	return hwnd;
}

INT WINAPI ToolTip_Enable(HWND hwndToolTip, BOOL fEnable)
{
	LPCDWToolTip lpCDWTT = (LPCDWToolTip)GetHWNDPtr(hwndToolTip);
	if(lpCDWTT) {
		lpCDWTT->Enable(hwndToolTip, fEnable);
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\lib\ptt\ptt.h ===
//////////////////////////////////////////////////////////////////
// File     : ptt.h
// Purpose  : Own Tooltop for disabled window
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef _PAD_TOOL_TIP_H_
#define _PAD_TOOL_TIP_H_
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <commctrl.h>
extern HWND WINAPI ToolTip_CreateWindow(HINSTANCE hInst, DWORD dwStyle, HWND hwndOwner);
extern INT  WINAPI ToolTip_Enable(HWND hwndToolTip, BOOL fEnable);
#ifdef UNDER_CE // In Windows CE, all window classes are process global.
extern BOOL ToolTip_UnregisterClass(HINSTANCE hInst);
#endif // UNDER_CE
#define TTM_RELAYEVENT_WITHUSERINFO		(WM_USER+101)
#define TTN_NEEDTEXT_WITHUSERINFO		(TTN_FIRST - 20)

typedef struct tagTOOLTIPUSERINFO {
	HWND	hwnd;
	POINT	pt;
	RECT	rect;
	LPARAM	lParam; 
}TOOLTIPUSERINFO, *LPTOOLTIPUSERINFO;

typedef struct tagTOOLTIPTEXTUSERINFO
{
	NMHDR			hdr;
	TOOLTIPUSERINFO	userInfo;
	LPWSTR			lpszText;
}TOOLTIPTEXTUSERINFO, *LPTOOLTIPTEXTUSERINFO;
#endif // _DW_TOOL_TIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\padrs\resmain.h ===
//////////////////////////////////////////////////////////////////
// File     :	resmain.h
// Purpose  :	
// 
// 
// Date     :	Thu May 20 21:28:50 1999
// Author   :	toshiak
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __RES_MAIN_H__
#define __RES_MAIN_H__
//=======================================================
//IMEPad Popup menu help id.(For Korean WinHelp)
//=======================================================
//
#define IDH_TOC_IMEPAD			3099		//Main Help

//-------------------------------------------------------
//Not used.
//-------------------------------------------------------
#define IDH_PAD_BASE_MENU			3000			//Menu.
#define IDH_PAD_BASE_APPLET			3001			//applet menu.
#define	IDH_PAD_BASE_BACK			3002			//back.

//-------------------------------------------------------
//Basic Buttons.
//-------------------------------------------------------
#define IDH_PAD_BASE_BASIC_BS		3010			//[BS]
#define IDH_PAD_BASE_BASIC_DEL		3011			//[Del]
#define IDH_PAD_BASE_BASIC_CONV		3012			//[Conv]
#define IDH_PAD_BASE_BASIC_ENTER	3013			//[Enter]
#define IDH_PAD_BASE_BASIC_SPACE	3014			//[space]
#define IDH_PAD_BASE_BASIC_ESC		3015			//[ESC]
#define IDH_PAD_BASE_BASIC_LEFT		3016			//[<-]
#define IDH_PAD_BASE_BASIC_RIGHT	3017			//[->]
#define IDH_PAD_BASE_BASIC_UP		3018			//[Up arrow]
#define IDH_PAD_BASE_BASIC_DOWN		3019			//[Down arrow]

//-------------------------------------------------------
//Extended Buttons.
//-------------------------------------------------------
#define IDH_PAD_BASE_EX_HOME		3020			//[HOME]
#define IDH_PAD_BASE_EX_END			3021			//[End]
#define IDH_PAD_BASE_EX_PGUP		3022			//[PgUp]
#define IDH_PAD_BASE_EX_PGDN		3023			//[PgDw]
#define IDH_PAD_BASE_EX_TAB			3024			//[Tab]
#define IDH_PAD_BASE_EX_INS			3025			//[Ins]
#define IDH_PAD_BASE_EX_WINDOWS		3026			//[Windows]
#define IDH_PAD_BASE_EX_APP			3027			//[App]
#define IDH_PAD_BASE_DELETE			3030			

//-------------------------------------------------------
//IMEPad's property dialog.
//-------------------------------------------------------
#define IDH_PAD_PROPERTY_OK			3600		//OK
#define IDH_PAD_PROPERTY_CANCEL		3601		//Cancel
#define IDH_PAD_PROPERTY_HELP		3602		//Help
#define IDH_PAD_PROPERTY_BASIC      3607    	//Basic button.
#define IDH_PAD_PROPERTY_EX			3608    	//Extended button.
#define IDH_PAD_PROPERTY_POS        3609    	//Position.
#define IDH_PAD_PROPERTY_LANG       3611    	//Language.

//----------------------------------------------------------------
//IMEPad's user configuration(IMEPad change menu order)
//
#define IDH_PAD_USER_ADD	        3702        
#define IDH_PAD_USER_REMOVE		    3703        
#define IDH_PAD_USER_CLOSE		    3704        
#define IDH_PAD_USER_RESET		    3705        
#define IDH_PAD_USER_UP		        3706        
#define IDH_PAD_USER_DOWN			3707        

#endif //__RES_MAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadcb.h ===
#ifndef __C_IME_PAD_CALLBACK_H__
#define __C_IME_PAD_CALLBACK_H__
#include "cpadsvr.h"

//----------------------------------------------------------------
//990630:ToshiaK for #1327
//----------------------------------------------------------------
#define WM_USER_UPDATECONTEXT	(WM_USER+400)

class CImePadCallback;
typedef CImePadCallback *LPCImePadCallback;

class CImePadCallback :public IImePadCallback
{
public:
	HRESULT __stdcall QueryInterface(REFIID riid, void**ppv);
	ULONG   __stdcall AddRef	(void);
	ULONG   __stdcall Release	(void);
	virtual HRESULT STDMETHODCALLTYPE OnStart( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE OnClose( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE OnPing( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE PassData( 
		/* [in] */ long nSize,
		/* [size_is][in] */ byte __RPC_FAR *pByte,
		/* [out][in] */ DWORD __RPC_FAR *pdwCharID);
	virtual HRESULT STDMETHODCALLTYPE ReceiveData( 
		/* [in] */ DWORD dwCmdID,
		/* [in] */ DWORD dwDataID,
		/* [out] */ long __RPC_FAR *pSize,
		/* [size_is][size_is][out] */ byte __RPC_FAR *__RPC_FAR *ppByte);
public:
	CImePadCallback(HWND hwndIF, LPCImePadSvr lpCImePadSvr);
	~CImePadCallback();
	VOID* operator new( size_t size );
	VOID  operator delete( VOID *lp );
private:
	LPCImePadSvr	m_lpCImePadSvr;
	DWORD			m_dwReg;
	HWND			m_hwndIF;
	LONG			m_cRef;			
};

#ifndef		__DEFINE_IMEPAD_IUNKNOWN_DUMMY__
#define		__DEFINE_IMEPAD_IUNKNOWN_DUMMY__
#pragma pack(8)
typedef struct IUnkDummyVtbl
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
		IUnknown __RPC_FAR * This,
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
		IUnknown __RPC_FAR * This);
	
	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
		IUnknown __RPC_FAR * This);
}IUnkDummyVtbl;

interface IUnkDummy
{
       CONST_VTBL struct IUnkDummyVtbl __RPC_FAR *lpVtbl;
};
#pragma pack()
#endif //__DEFINE_IMEPAD_IUNKNOWN_DUMMY__

extern BOOL IsBadVtbl(IUnkDummy *lpIUnk);


#endif //__C_IME_PAD_CALLBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\padrs\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by F:\satori\fecommon\imepadsv\res\cht\res.rc
//
#define IDC_STATIC                      -1

#define IDS_TITLE_IMEPAD                1
#define IDS_TITLE_PADMENU               2
#define IDS_TITLE_APPLETMENU            3
#define IDS_TITLE_TURNBACK              4
#define IDS_TITLE_VERSION               5
#define IDS_TITLE_HELP                  6
#define IDS_TITLE_IMEPAD_HELP           7
#define IDS_TITLE_CLOSE                 8
#define IDS_TITLE_PROPERTY              9
#define IDS_TITLE_ADD_APPLETS           10
#define IDS_TITLE_LEFT                  11
#define IDS_TITLE_RIGHT                 12
#define IDS_TITLE_APPLET                13
#define IDS_TITLE_FILENAME              14
#define IDS_TITLE_CHANGE_APPLET_ORDER   15
#define IDS_TITLE_RES2                  16
#define IDS_TITLE_RES3                  17
#define IDS_TITLE_RES4                  18
#define IDS_SUFFIX_PROPERTY             19
#define IDS_SUFFIX_HELP                 20
#define IDS_BUTTON_BACK                 21
#define IDS_BUTTON_NEXT                 22
#define IDS_BUTTON_FINISH               23
#define IDS_BUTTON_RES1                 24
#define IDS_BUTTON_RES2                 25
#define IDS_BUTTON_RES3                 26
#define IDS_LANG_AUTO                   27
#define IDS_LANG_ENGLISH                28
#define IDS_LANG_CHINESE_SIMPLIFIED     29
#define IDS_LANG_CHINESE_TRADITIONAL    30
#define IDS_LANG_JAPANESE               31
#define IDS_LANG_KOREAN                 32
#define IDS_KBTN_BACKSPACE              33
#define IDS_KBTN_ENTER                  34
#define IDS_KBTN_SPACE                  35
#define IDS_KBTN_DELETE                 36
#define IDS_KBTN_ESCAPE                 37
#define IDS_KBTN_HOME                   38
#define IDS_KBTN_PAGEUP                 39
#define IDS_KBTN_TAB                    40
#define IDS_KBTN_LWIN                   41
#define IDS_KBTN_END                    42
#define IDS_KBTN_PAGEDOWN               43
#define IDS_KBTN_INSERT                 44
#define IDS_KBTN_APPKEY                 45
#define IDS_KBTN_FE_ENG                 46
#define IDS_KBTN_FE_CHS                 47
#define IDS_KBTN_FE_CHT                 48
#define IDS_KBTN_FE_JPN                 49
#define IDS_KBTN_FE_KOR                 50
#define IDS_FE_KEY_ENG                  51
#define IDS_FE_KEY_CHS                  52
#define IDS_FE_KEY_CHT                  53
#define IDS_FE_KEY_JPN                  54
#define IDS_FE_KEY_KOR                  55
#define IDS_ACC_BACKSPACE               56
#define IDS_ACC_ENTER                   57
#define IDS_ACC_SPACE                   58
#define IDS_ACC_DELETE                  59
#define IDS_ACC_ESCAPE                  60
#define IDS_ACC_HOME                    61
#define IDS_ACC_PAGEUP                  62
#define IDS_ACC_TAB                     63
#define IDS_ACC_LWIN                    64
#define IDS_ACC_END                     65
#define IDS_ACC_PAGEDOWN                66
#define IDS_ACC_INSERT                  67
#define IDS_ACC_APPKEY                  68
#define IDS_ACC_ARROW_LEFT              69
#define IDS_ACC_ARROW_RIGHT             70
#define IDS_ACC_ARROW_UP                71
#define IDS_ACC_ARROW_DOWN              72
#define IDS_ACC_FE_ENG                  73
#define IDS_ACC_FE_CHS                  74
#define IDS_ACC_FE_CHT                  75
#define IDS_ACC_FE_JPN                  76
#define IDS_ACC_RES1                    77
#define IDS_ACC_RES2                    78
#define IDS_ACC_RES3                    79
#define IDS_ACC_RES4                    80
#define IDS_ACC_RES5                    81
#define IDS_MSG_INVALID_FOLDER          82
#define IDS_MSG_NOFOLDER_CREATE         83
#define IDS_MSG_FAILEDTOCREATEFOLDER    84
#define IDS_MSG_NOAPPLETINFOLDER        85
#define IDS_MSG_NOENOUGHMEMORY          86
#define IDS_MSG_NOSPECIFIEDAPPLET       87
#define IDS_MSG_DOADMIN                 88
#define IDS_MSG_RES1                    89
#define IDS_MSG_RES2                    90
#define IDS_MSG_RES3                    91
#define IDS_MSG_RES4                    92
#define IDS_MSG_RES5                    93
#define IDS_MSG_RES6                    94
#define IDS_FONTNAME_NATIVE_0           95
#define IDS_FONTNAME_NATIVE_1           96
#define IDS_FONTNAME_NATIVE_2           97
#define IDS_FONTNAME_NATIVE_3           98
#define IDS_FONTNAME_ENG_0              99
#define IDS_FONTNAME_ENG_1              100
#define IDS_FONTNAME_ENG_2              101
#define IDS_FONTNAME_ENG_3              102
#define IDI_WINDOW                      200
#define IDI_APPKEY                      201
#define IDI_INSTALL                     202
#define IDI_IMEPAD                      206
#define IDD_PROPERTY                    208
#define IDD_CHGAPPLETORDER              212
#define IDD_BTNPANE                     213
#define IDD_INST_SETAPPLETFOLDER        214
#define IDR_MENUCONTEXTHELP             215
#define IDD_INST_SETINSTALLFOLDER       216
#define IDD_INST_BROWSEAPPLET           217
#define IDD_VERSION                     218
#define IDD_INST_DOING                  219
#define IDD_INST_ADD_DELETE             220
#define IDD_INST_DELETE                 221
#define IDC_BROWSE                      1027
#define IDC_APPLETLIST                  1027
#define IDC_STATIC_MSG                  1028
#define IDC_CHECK1                      1028
#define IDC_STATIC_COPYFROM             1030
#define IDC_STATIC_ERRORMSG             1031
#define IDC_STATIC_ERROR_TITLE          1032
#define IDC_PROGRESS                    1033
#define IDC_STATIC_FOLDERNAME           1036
#define IDC_OTHERLIST                   1036
#define IDC_FOLDER_PATH                 1037
#define IDC_STATIC_FILENAME             1038
#define IDC_SRCFOLDER                   1039
#define IDC_FOLDERNAME                  1040
#define IDC_DESTFOLDER                  1041
#define IDC_TITLE_DESTFOLDER            1042
#define IDC_ADDAPPLET                   1042
#define IDC_DELETEAPPLET                1043
#define IDC_LISTAPPLET                  1046
#define IDC_NOTIFY                      1047
#define IDC_TEXT_VERSION                1048
#define IDC_CFG_GEN_APPLETBAR           1068
#define IDC_CFG_GEN_APPLETBAR_POSITION  1069
#define IDC_CFG_GEN_BASIC_BUTTONS       1070
#define IDC_CFG_GEN_EXTEND_BUTTONS      1071
#define IDC_CFG_GEN_BUTTON_LANGUAGE     1072
#define IDC_CFG_GEN_BUTTON_POSITION     1073
#define IDC_CFG_GEN_MENU_LANGUAGE       1074
#define IDC_CFG_GEN_BUTTON_OK           1075
#define IDC_CFG_GEN_BUTTON_CANCEL       1076
#define IDC_CFG_GEN_BUTTON_HELP         1077
#define IDC_CFG_CHGMENU_APPLETS         1078
#define IDC_CFG_GEN_BUTTON_POSITION2    1078
#define IDC_CFG_CHGMENU_CURAPPLETS      1079
#define IDC_CFG_CHGMENU_CLOSE           1080
#define IDC_CFG_CHGMENU_RESET           1081
#define IDC_CFG_CHGMENU_ADD             1082
#define IDC_CFG_CHGMENU_DELETE          1083
#define IDC_CFG_CHGMENU_UP              1084
#define IDC_CFG_CHGMENU_DOWN            1095
#define IDC_INST_APPLETLIST             1096
#define IDC_INST_INSTALL_FROM_FILE      1097

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         40012
#define _APS_NEXT_CONTROL_VALUE         1093
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\padrs\resmain.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	resmain.cpp
// Purpose  :	IMEPad's neutral resource &
//            	Help API.
// 
// 
// Date     :	Thu May 20 20:58:06 1999
// Author   :	toshiak
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#include <windows.h>
#include <windowsx.h>
#include "resource.h"
#include "cmddef.h"
#include "padhelp.h"
//#include "../common/cutil.h"
#include "resmain.h"

//----------------------------------------------------------------
//Helpfile name
//----------------------------------------------------------------
#define TSZ_HTMLHELP_FILE_KOR	TEXT("impdko61.chm")    //Helpfile for Htmlhelp
#define TSZ_HTMLHELP_FILE_ENG	TEXT("korpaden.chm")    //Helpfile for Htmlhelp
#define TSZ_WMHELP_FILE	    	TEXT("imkr61.hlp")      // IME Pad Context Help. Kor only.

//----------------------------------------------------------------
//HelpId table
//----------------------------------------------------------------
static INT g_helpIdList[]={
    IDC_KBTN_BACKSPACE,  IDH_PAD_BASE_BASIC_BS,
    IDC_KBTN_DELETE,     IDH_PAD_BASE_BASIC_DEL,
    IDC_KBTN_FAREAST,    IDH_PAD_BASE_BASIC_CONV,
    IDC_KBTN_ENTER,      IDH_PAD_BASE_BASIC_ENTER,
    IDC_KBTN_SPACE,      IDH_PAD_BASE_BASIC_SPACE,
    IDC_KBTN_ESCAPE,     IDH_PAD_BASE_BASIC_ESC,
    IDC_KBTN_ARROWS,     IDH_PAD_BASE_BASIC_LEFT,
    IDC_KBTN_ARROW_LEFT, IDH_PAD_BASE_BASIC_LEFT,
    IDC_KBTN_ARROW_RIGHT,IDH_PAD_BASE_BASIC_RIGHT,
    IDC_KBTN_ARROW_UP,   IDH_PAD_BASE_BASIC_UP,
    IDC_KBTN_ARROW_DOWN, IDH_PAD_BASE_BASIC_DOWN,
    IDC_KBTN_HOME,       IDH_PAD_BASE_EX_HOME,
    IDC_KBTN_END,        IDH_PAD_BASE_EX_END,
    IDC_KBTN_PAGEUP,     IDH_PAD_BASE_EX_PGUP,
    IDC_KBTN_PAGEDOWN,   IDH_PAD_BASE_EX_PGDN,
    IDC_KBTN_TAB,        IDH_PAD_BASE_EX_TAB,
    IDC_KBTN_INSERT,     IDH_PAD_BASE_EX_INS,
    IDC_KBTN_LWIN,       IDH_PAD_BASE_EX_WINDOWS,
    IDC_KBTN_APPKEY,     IDH_PAD_BASE_EX_APP,

    //IMEPad's property dialog's Popup-help.
	IDC_CFG_GEN_BASIC_BUTTONS,    	IDH_PAD_PROPERTY_BASIC,
	IDC_CFG_GEN_EXTEND_BUTTONS,    	IDH_PAD_PROPERTY_EX,
	IDC_CFG_GEN_BUTTON_POSITION,	IDH_PAD_PROPERTY_POS,
	IDC_CFG_GEN_MENU_LANGUAGE,    	IDH_PAD_PROPERTY_LANG,
	IDC_CFG_GEN_BUTTON_OK,        	IDH_PAD_PROPERTY_OK,
	IDC_CFG_GEN_BUTTON_CANCEL,    	IDH_PAD_PROPERTY_CANCEL,
	IDC_CFG_GEN_BUTTON_HELP,    	IDH_PAD_PROPERTY_HELP,

    //IMEPad's user configu dialog's Popup-help.
	IDC_CFG_CHGMENU_APPLETS,    	0,
	IDC_CFG_CHGMENU_CURAPPLETS,    	0,
	IDC_CFG_CHGMENU_CLOSE,        	IDH_PAD_USER_CLOSE,
	IDC_CFG_CHGMENU_RESET,        	IDH_PAD_USER_RESET,
	IDC_CFG_CHGMENU_ADD,        	IDH_PAD_USER_ADD,
	IDC_CFG_CHGMENU_DELETE,        	IDH_PAD_USER_REMOVE,
	IDC_CFG_CHGMENU_UP,            	IDH_PAD_USER_UP,
	IDC_CFG_CHGMENU_DOWN,        	IDH_PAD_USER_DOWN,
	0,            	0,
}; 

//////////////////////////////////////////////////////////////////
// Function	:	PadHelp_HandleHelp
// Type	    :	INT WINAPI
// Purpose	:    
// Args	    :    
//            :	HWND	hwnd	
//            :	INT		padHelpIndex	
//            :	LANGID	imepadUiLangID
// Return	:    
// DATE	    :	Fri Aug 04 08:59:21 2000
// Histroy	:	Fri Aug 04 09:03:17 2000
//                # Add imepadUiLangID. 
//////////////////////////////////////////////////////////////////
INT WINAPI
PadHelp_HandleHelp(HWND hwnd, INT padHelpIndex, LANGID imepadUiLangID)
{
	TCHAR tszPath[MAX_PATH];
	TCHAR tszFile[MAX_PATH];
	BOOL  fKoreanEnv = (imepadUiLangID == MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT)) ? TRUE : FALSE;

	tszPath[0] = (TCHAR)0x00;
	tszFile[0] = (TCHAR)0x00;
    // There is No Korean TS NT4.0
#if 0
    //----------------------------------------------------------------
    //In WinNT4.0 TerminalServer, htmlhlp has bug.
    //have to set absolute HTML helpfile path to it
    //----------------------------------------------------------------
	if(CUtil::IsHydra() && CUtil::IsWinNT4()) {
    	INT size = CUtil::GetWINDIR(tszFile, sizeof(tszFile)/sizeof(tszFile[0]));
    	tszFile[size] = (TCHAR)0x00;
    	lstrcat(tszFile, TEXT("\\help\\"));
    	lstrcat(tszFile, fKoreanEnv ? TSZ_HTMLHELP_FILE_KOR : TSZ_HTMLHELP_FILE_ENG);
    }
	else {
    	lstrcpy(tszFile, fKoreanEnv ? TSZ_HTMLHELP_FILE_KOR : TSZ_HTMLHELP_FILE_ENG);
    }
#endif
	lstrcpy(tszFile, fKoreanEnv ? TSZ_HTMLHELP_FILE_KOR : TSZ_HTMLHELP_FILE_ENG);

	switch(padHelpIndex) {
	case PADHELPINDEX_MAIN:
	case PADHELPINDEX_APPLETMENUCHANGE:
    	wsprintf(tszPath, TEXT("hh.exe %s"), tszFile);
    	break;
	case PADHELPINDEX_PROPERTY:
    	wsprintf(tszPath, TEXT("hh.exe %s::/howIMETopic166_ChangetheIMEPadOperatingEnvironment.htm"), tszFile);
    	break;

#if 0
	case PADHELPINDEX_RESERVED1:
    	wsprintf(tszPath, TEXT("hh.exe %s::/IDH_TOC_IMEPAD_fake.htm"), tszFile);
    	break;
	case PADHELPINDEX_RESERVED2:
    	wsprintf(tszPath, TEXT("hh.exe %s::/IDH_TOC_IMEPAD_fake.htm"), tszFile);
    	break;
#endif
	default:
    	return -1;
    }
#ifndef UNDER_CE
    ::WinExec(tszPath, SW_SHOWNORMAL);
#else
#pragma message("Not Implemented yet!!")
#endif
	return 0;
	UNREFERENCED_PARAMETER(hwnd);
	UNREFERENCED_PARAMETER(imepadUiLangID);
}

//////////////////////////////////////////////////////////////////
// Function	:	PadHelp_HandleContextPopup
// Type	    :	INT WINAPI
// Purpose	:	Invoke Popup Help.
//                ::WinHelp(HWND   hwndCtrl,                //set passed parameter.
//                          LPTSTR TSZ_WMHELP_FILE,        //set your WinHelp file name.
//                          DWORD	 HELP_CONTEXTPOPUP,        //uCommand.
//                          DWORD	 realHelpIndex);        //Context Identifier for a topic.
//            	This code only popups context help.
// Args	    :    
//            :	HWND	hwndCtrl:	Control window handle for popup.
//            :	INT		idCtrl:    	Logical Control ID	        
// Return	:    
// DATE	    :	Tue Jun 22 15:49:37 1999
//            :	LANGID	imepadUiLangID:	IMEPad's Ui langID.
// Return	:    
// DATE	    :	Tue Jun 22 15:49:37 1999
// Histroy	:	Fri Aug 04 09:02:12 2000
//                # Add imepadUiLangID. but you don't need to check it now.
//////////////////////////////////////////////////////////////////
INT WINAPI
PadHelp_HandleContextPopup(HWND hwndCtrl, INT idCtrl, LANGID imepadUiLangID)
{
#ifdef _DEBUG
	TCHAR tszBuf[256];
	TCHAR tszClass[256];
	GetClassName(hwndCtrl, tszClass, sizeof(tszClass)/sizeof(tszClass[0]));
	wsprintf(tszBuf,
             "PadHelp_HandleContextPopup: hwndCtrl[0x%08x][%s] idCtrl[%d][0x%08x]\n",
             hwndCtrl,
             tszClass,
             idCtrl,
             idCtrl);
	OutputDebugString(tszBuf);
#endif
	int i;
	for(i = 0; i < sizeof(g_helpIdList)/sizeof(g_helpIdList[0]); i+=2) {
    	if(idCtrl == g_helpIdList[i]) {
#ifdef _DEBUG
        	wsprintf(tszBuf,
                     "Find idCtrl[%d][0x%08x] helpId[%d][0x%08x]\n",
                     idCtrl, idCtrl,
                     g_helpIdList[i+1], g_helpIdList[i+1]);
        	OutputDebugString(tszBuf);
#endif
        	return ::WinHelp(hwndCtrl,
                             TSZ_WMHELP_FILE,
                             HELP_CONTEXTPOPUP,
                             g_helpIdList[i+1]);
        }
    }
	return 0;
	UNREFERENCED_PARAMETER(hwndCtrl);
	UNREFERENCED_PARAMETER(imepadUiLangID);
}

//----------------------------------------------------------------
//DllMain
//----------------------------------------------------------------
BOOL WINAPI DllMain(HANDLE hInst, DWORD dwF, LPVOID lpNotUsed)
{
	return TRUE;
	UNREFERENCED_PARAMETER(hInst);
	UNREFERENCED_PARAMETER(dwF);
	UNREFERENCED_PARAMETER(lpNotUsed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadcb.cpp ===
#include <windows.h>
#include <windowsx.h>
#ifdef UNDER_CE // stub for CE
#include "stub_ce.h"
#endif // UNDER_CE
#include "imepadsv.h"
#include "cpadcb.h"
#include "cpaddbg.h"
#include "ipoint1.h"
#include "iimecb.h"
#include "imepad.h"

#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)

BOOL IsBadVtbl(IUnkDummy *lpIUnk)
{
#ifdef _DEBUG
	BOOL fBad = ::IsBadReadPtr(lpIUnk, sizeof(VOID*)) ||
		::IsBadReadPtr(lpIUnk->lpVtbl, sizeof(VOID*)) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->QueryInterface) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->AddRef) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->Release);
	if(fBad) {
		DBG(("--> IsBadVtbl HIT HIT HIT\n"));
	}
	return fBad;
#else
	return ::IsBadReadPtr(lpIUnk, sizeof(VOID*)) ||
		   ::IsBadReadPtr(lpIUnk->lpVtbl, sizeof(VOID*)) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->QueryInterface) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->AddRef) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->Release);
#endif
}

HRESULT __stdcall CImePadCallback::QueryInterface(REFIID riid, void**ppv)
{
	if(riid == IID_IUnknown) {
		*ppv = static_cast<IImePadCallback *>(this);
	}
	else if (riid == IID_IImePadCallback) {
		*ppv = static_cast<IImePadCallback *>(this);
	}
	else {
		return (*ppv = 0), E_NOINTERFACE;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

ULONG __stdcall
CImePadCallback::AddRef(void)
{
	//DBG(("CImePadCallback::AddRef Always return 2\n"));
	DBG(("CImePadCallback::AddRef m_cRef[%d] -> [%d]\n", m_cRef, m_cRef+1));
	return ::InterlockedIncrement(&m_cRef);
}

ULONG __stdcall
CImePadCallback::Release(void)
{
	//Never call delete in it.
	DBG(("CImePadCallback::Release (Never Delete) m_cRef[%d] -> [%d]\n", m_cRef, m_cRef-1));
	::InterlockedDecrement(&m_cRef);
	return m_cRef;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadCallback::OnStart
// Type		:	HRESULT __stdcall
// Purpose	:	
// Args		:	
//			:	DWORD	dwParam	
// Return	:	
// DATE		:	Tue Aug 31 16:49:37 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
HRESULT __stdcall
CImePadCallback::OnStart(DWORD dwParam)
{
	DBG(("OnClose come dwParam[%d]\n", dwParam));
	IUnknown *lpUnk;
	IImeCallback *lp = NULL;
	if(!m_lpCImePadSvr) {
		DBG(("-->m_lpCImePadSvr is NULL ?\n"));
		return -1;
	}

	lpUnk = m_lpCImePadSvr->GetIUnkIImeCallback();
	if(!lpUnk) {
		DBG(("-->IImeCallback does not set\n"));
		return -1;
	}

	if(IsBadVtbl((IUnkDummy*)lpUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}

	lpUnk->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
	if(!lp) {
		DBG(("-->QuertyInterface Failed\n"));
	}
	lp->Notify(IMECBNOTIFY_IMEPADOPENED, 0, 0);
	lp->Release();
	return S_OK;
	Unref(dwParam);
}

HRESULT __stdcall CImePadCallback::OnClose(DWORD dwParam)
{
	DBG(("OnClose come dwParam[%d]\n", dwParam));
	IUnknown *lpUnk;
	IImeCallback *lp = NULL;
	if(!m_lpCImePadSvr) {
		DBG(("-->m_lpCImePadSvr is NULL ?\n"));
		return -1;
	}
	m_lpCImePadSvr->OnIMEPadClose();

	lpUnk = m_lpCImePadSvr->GetIUnkIImeCallback();
	if(!lpUnk) {
		DBG(("-->IImeCallback does not set\n"));
		return -1;
	}

	if(IsBadVtbl((IUnkDummy*)lpUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}

	lpUnk->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
	if(!lp) {
		DBG(("-->QuertyInterface Failed\n"));
	}
	lp->Notify(IMECBNOTIFY_IMEPADCLOSED, 0, 0);
	lp->Release();
	return S_OK;
	Unref(dwParam);
}

HRESULT __stdcall
CImePadCallback::OnPing(DWORD dwParam)
{
	return S_OK;
	Unref(dwParam);
}

typedef struct tagPADCTRL2IPCTRL {
	DWORD dwImePadCtrl;
	DWORD dwIPointCtrl;
}PADCTL2IPCTRL;

static PADCTL2IPCTRL padCtrl2Ip[]= {
	{ IMEPADCTRL_CONVERTALL,           IPCTRL_CONVERTALL,		      },
	{ IMEPADCTRL_DETERMINALL,          IPCTRL_DETERMINALL,		      },
	{ IMEPADCTRL_DETERMINCHAR,         IPCTRL_DETERMINCHAR,		      },
	{ IMEPADCTRL_CLEARALL,             IPCTRL_CLEARALL,			      },
	{ IMEPADCTRL_CARETSET,             IPCTRL_CARETSET,			      },
	{ IMEPADCTRL_CARETLEFT,            IPCTRL_CARETLEFT,			  },
	{ IMEPADCTRL_CARETRIGHT,           IPCTRL_CARETRIGHT,		      },
	{ IMEPADCTRL_CARETTOP,             IPCTRL_CARETTOP,			      },
	{ IMEPADCTRL_CARETBOTTOM,          IPCTRL_CARETBOTTOM,		      },
	{ IMEPADCTRL_CARETBACKSPACE,       IPCTRL_CARETBACKSPACE,	      },
	{ IMEPADCTRL_CARETDELETE,          IPCTRL_CARETDELETE,		      },
	{ IMEPADCTRL_PHRASEDELETE,         IPCTRL_PHRASEDELETE,		      },
	{ IMEPADCTRL_INSERTSPACE,          IPCTRL_INSERTSPACE,		      },
	{ IMEPADCTRL_INSERTFULLSPACE,      IPCTRL_INSERTFULLSPACE,	      },
	{ IMEPADCTRL_INSERTHALFSPACE,      IPCTRL_INSERTHALFSPACE,	      },
	{ IMEPADCTRL_ONIME,                IPCTRL_ONIME,				  },
	{ IMEPADCTRL_OFFIME,               IPCTRL_OFFIME,			      },
	{ IMEPADCTRL_ONPRECONVERSION,      IPCTRL_PRECONVERSION,		  },
	{ IMEPADCTRL_PHONETICCANDIDATE,    IPCTRL_PHONETICCANDIDATE,	  },
};

HRESULT __stdcall
CImePadCallback::PassData(long nSize, byte *pByte, DWORD *pdwCharID)
{
	DBG(("CImePadCallback::PassData START\n"));
	LPIMEDATAHEADER lpImeDataHeader = (LPIMEDATAHEADER)pByte;

	HRESULT hr = S_OK;
	IUnknown *lpIUnk = NULL;
	IImeIPoint1 *lpIImeIPoint = NULL;
	DWORD dwCharID = 0;

	if(!m_lpCImePadSvr) {
		DBG(("m_lpCImePadSvr is NULL Error\n"));
		return E_FAIL;
	}
	lpIUnk = m_lpCImePadSvr->GetIUnkIImeIPoint();
	if(!lpIUnk) {
		DBG(("lpIUnk is NULL\n"));
		return E_FAIL;
	}

	if(IsBadVtbl((IUnkDummy*)lpIUnk)) {
		return E_FAIL;
	}

	hr = lpIUnk->QueryInterface(IID_IImeIPoint1, (VOID **)&lpIImeIPoint);
	if(hr != S_OK) {
		DBG(("QuertyInterface Failed\n"));
		return E_FAIL;
	}
	if(!lpIImeIPoint) {
		DBG(("QuertyInterface failed\n"));
		return E_FAIL;
	}
	DBG(("m_hwndIF [0x%08x]\n", m_hwndIF));


	switch(lpImeDataHeader->dwDataID) {
	case IMEDATAID_CONTROL:
		{
			LPIMEDATACONTROL lpImeDataCtrl = (LPIMEDATACONTROL)lpImeDataHeader;
			for(int i = 0; i < sizeof(padCtrl2Ip)/sizeof(padCtrl2Ip[0]); i++) {
				if(lpImeDataCtrl->dwControl == padCtrl2Ip[i].dwImePadCtrl) {
					hr = lpIImeIPoint->ControlIME((WORD)padCtrl2Ip[i].dwIPointCtrl,
												   IPCTRLPARAM_DEFAULT);
					//hr = lpIImeIPoint->UpdateContext(TRUE);
					break;
				}
			}
		}
		break;
	case IMEDATAID_STRING:
		{
			DBG(("--> IMEDATAID_STRING\n"));
			LPIMEDATASTRING lpImeDataStr = (LPIMEDATASTRING)lpImeDataHeader;
			switch(lpImeDataHeader->dwCmdID) {
			case IMECMDID_INSERTSTRING:
				{
					DBG(("--> IMECMDID_INSERTSTRING START\n"));
					LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
					INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
					DBGW((L"lpwstr [%s] len[%d]\n", lpwstr, len));
					BOOL fPreConv = lpImeDataStr->fPreConv;
					//990818:ToshiaK for KOTAE #1775.
					dwCharID = lpImeDataStr->dwCharID;					
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
												  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
					hr = lpIImeIPoint->InsertStringEx(lpwstr,
													  len,
													  &dwCharID);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					if(pdwCharID) {
						*pdwCharID = dwCharID;
					}
					fPreConv = 0;
					DBG(("--> IMECMDID_INSERTSTRING END\n"));
				}
				break;
			case IMECMDID_CHANGESTRING:
				{
					DBG(("--> IMECMDID_CHANGESTRING\n"));
					LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
					INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
					dwCharID	  = ((LPIMEDATASTRING)lpImeDataHeader)->dwCharID;
					BOOL fPreConv = lpImeDataStr->fPreConv;
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
												  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
					hr = lpIImeIPoint->ReplaceCompString(lpImeDataStr->dwStartPos,
														 lpImeDataStr->dwDeleteLength,
														 lpwstr,
														 len,
														 &dwCharID);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					//hr = lpIImeIPoint->UpdateContext(TRUE);
					if(pdwCharID) {
						*pdwCharID = dwCharID;
					}
					hr = (HRESULT)dwCharID;
				}
				break;
			case IMECMDID_DELETESTRING:
				{
					DBG(("--> IMECMDID_DELETESTRING\n"));
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME, IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					hr = lpIImeIPoint->DeleteCompString((DWORD)lpImeDataStr->dwStartPos,
														(DWORD)lpImeDataStr->dwDeleteLength);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					//hr = lpIImeIPoint->UpdateContext(TRUE);
				}
				break;
			case IMECMDID_INSERTSTRINGINFO:
			case IMECMDID_CHANGESTRINGINFO:
				{
					DBG(("--> IMECMDID_INSERT(Change)STRINGINFO\n"));
					LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
					INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
					dwCharID	  = ((LPIMEDATASTRING)lpImeDataHeader)->dwCharID;
					BOOL fPreConv = lpImeDataStr->fPreConv;
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
												  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
					hr = lpIImeIPoint->ReplaceCompString(lpImeDataStr->dwStartPos,
														 lpImeDataStr->dwDeleteLength,
														 lpwstr,
														 len,
														 &dwCharID);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					if(pdwCharID) {
						*pdwCharID = dwCharID;
					}
					hr = (HRESULT)dwCharID;
				}
				break;
			default:
				break;
				}
		}
		break;
	case IMEDATAID_STRINGCAND:
		{
			DBG(("Data ID is IMEDATAID_STRINGCAND\n"));
			HRESULT hr;
			LPIMEDATASTRINGCAND lpStrCand = (LPIMEDATASTRINGCAND)lpImeDataHeader;
			PIPCANDIDATE lpIpCand;
			INT	textCount, byteCount, i, nSize;
			PBYTE p;
			textCount =  byteCount = 0;
			DBG(("--> dwStringCount %d\n", lpStrCand->dwStringCount));
			for(i = 0; i < (INT)lpStrCand->dwStringCount; i++) {
				DBG(("--> %d offset [%d]\n", i, lpStrCand->dwOffsetString[i]));
				textCount++; 
				LPWSTR lpwstr = (LPWSTR)(((LPBYTE)lpStrCand) +  lpStrCand->dwOffsetString[i]);
				DBGW((L"--> %d %s\n", i, lpwstr));
				byteCount += (lstrlenW(lpwstr)+1) * sizeof(WCHAR);
			}
			if(textCount == 0) {
				return S_OK;
			}
			dwCharID = lpStrCand->dwCharID;
			DWORD dwExInfo = lpStrCand->dwExtraInfoSize;
			nSize = sizeof(IPCANDIDATE) + (textCount-1) * sizeof(DWORD) + byteCount + dwExInfo;
			lpIpCand = (IPCANDIDATE *)MemAlloc(nSize);
			if (lpIpCand == NULL)
				return E_OUTOFMEMORY;
			lpIpCand->dwSize		= nSize;
			lpIpCand->dwFlags		= lpStrCand->dwInfoMask;
			lpIpCand->iSelIndex		= lpStrCand->dwSelIndex;
			lpIpCand->nCandidate	= textCount;
			lpIpCand->dwPrivateDataOffset = 0;
			lpIpCand->dwPrivateDataSize	  = 0;
			DBG(("lpIpCand[0x%08x] \n", lpIpCand));
			DBG(("sizeof(IPCANDIDATE) [%d]\n", sizeof(IPCANDIDATE)));
			DBG(("size add [%d]\n", sizeof(DWORD) * (textCount -1)));
			DWORD dwOffset = sizeof(IPCANDIDATE)+sizeof(DWORD)*(textCount-1);
			p = ((PBYTE)lpIpCand) + dwOffset;
			for(i = 0; i < (INT)lpStrCand->dwStringCount; i++) {
				LPWSTR lpwstr = (LPWSTR)(((LPBYTE)lpStrCand) +  lpStrCand->dwOffsetString[i]);
				DWORD dwStrSize = (lstrlenW(lpwstr) + 1) * sizeof(WCHAR);
				CopyMemory((LPWSTR)p, 
						   (WCHAR *)lpwstr,
						   dwStrSize);
				lpIpCand->dwOffset[i] = dwOffset;
				dwOffset += dwStrSize;
				p += dwStrSize;
			}
			if(dwExInfo > 0) {
				lpIpCand->dwPrivateDataSize   = dwExInfo;
#ifdef _WIN64
				lpIpCand->dwPrivateDataOffset = (DWORD)((DWORD_PTR)p - (DWORD_PTR)lpIpCand);
#else
				lpIpCand->dwPrivateDataOffset = (DWORD)p - (DWORD)lpIpCand;
#endif
				CopyMemory(p,
						   (LPBYTE)((LPBYTE)lpStrCand + lpStrCand->dwExtraInfoOffset),
						   lpStrCand->dwExtraInfoSize);
			}
			BOOL fPreConv = lpStrCand->fPreConv;
			hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME, IPCTRLPARAM_DEFAULT);
			hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION,
										  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
			//----------------------------------------------------------------

			//990713: need to set Start position for IPoint.
			//----------------------------------------------------------------
			DWORD dwInsertPos; // = IPINS_CURRENT;	//Default.
			DWORD dwLen;		 
			//990823:Toshiak for KOTAE #1779.
			//000825:Satori #2123
			if(lpStrCand->dwStartPos == IMECMDVALUE_DEFAULT_INSERT_POS) {
				dwInsertPos = IPINS_CURRENT; //Set IPoint's value
			}
			else {
				dwInsertPos = lpStrCand->dwStartPos;
			}
				
			dwLen		= lpStrCand->dwDeleteLength;
			switch(lpStrCand->header.dwCmdID) {
			case IMECMDID_INSERTSTRINGCANDINFO:
				hr = lpIImeIPoint->InsertImeItem(lpIpCand,
												 dwInsertPos,
												 &dwCharID);
				break;
			case IMECMDID_CHANGESTRINGCANDINFO:
				hr = lpIImeIPoint->ReplaceImeItem(dwInsertPos,
												  dwLen,
												  lpIpCand,
												  &dwCharID);
				break;
			default:
				break;
			}
			hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
			//hr = lpIImeIPoint->UpdateContext(TRUE);
			MemFree(lpIpCand);
			if(pdwCharID) {
				*pdwCharID = dwCharID;
			}
		}
		break;
	default:
		break;
	}
	//990630:ToshiaK for #1327.
	//In WinWord, if call UpdateContext(TRUE) here,
	//Word does NOT repaint composition string.
	//once return the SendMessageTimeout() procedure,
	//and update context asynchronously.
	//in WM_USER_UPDATECONTEXT's lParam, set IImeIPoint interface pointer.
	//and message procedure, check it with current iimeipoint.
	::PostMessage(m_hwndIF, WM_USER_UPDATECONTEXT, (WPARAM)0, (LPARAM)lpIImeIPoint);
	lpIImeIPoint->Release();
	return hr;
	Unref(nSize);
}


HRESULT STDMETHODCALLTYPE 
CImePadCallback::ReceiveData( 
	/* [in] */ DWORD dwCmdID,
	/* [in] */ DWORD dwDataID,
	/* [out] */ long __RPC_FAR *pSize,
	/* [size_is][size_is][out] */ byte __RPC_FAR *__RPC_FAR *ppByte)
{
	DBG(("CImePadCallback::ReceiveData START\n"));
	DBG(("-->dwCmdID  [0x%08x]\n", dwCmdID));
	DBG(("-->dwDataID [0x%08x]\n", dwDataID));
	DBG(("-->pSize    [0x%08x]\n", pSize));
	DBG(("-->ppByte   [0x%08x]\n", ppByte));

	HRESULT hr = S_OK;
	IUnknown *lpIUnk = NULL;
	IImeIPoint1 *lpIImeIPoint = NULL;

	DBG(("-->Check m_lpCImePadSvr\n"));
	if(!m_lpCImePadSvr) {
		DBG(("m_lpCImePadSvr is NULL Error\n"));
		return E_FAIL;
	}
	DBG(("-->Check m_fnCoTaskMemAlloc\n"));	
	if(!m_lpCImePadSvr->m_fnCoTaskMemAlloc ||
	   !m_lpCImePadSvr->m_fnCoTaskMemFree) {
		DBG(("--> OLE32.DLL does NOT EXIST ? Error\n"));
		return E_FAIL;
	}

	lpIUnk = m_lpCImePadSvr->GetIUnkIImeIPoint();
	DBG(("-->Check lpIUnk [0x%08x]\n", lpIUnk));	
	if(!lpIUnk) {
		DBG(("lpIUnk is NULL\n"));
		return E_FAIL;
	}

	DBG(("-->Check lpIUnk IsBadVtbl[0x%08x]\n", lpIUnk));
	if(IsBadVtbl((IUnkDummy*)lpIUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}
	
	DBG(("-->Call QuertyInterface\n"));
	hr = lpIUnk->QueryInterface(IID_IImeIPoint1, (VOID **)&lpIImeIPoint);
	if(hr != S_OK) {
		DBG(("QuertyInterface Failed\n"));
		return E_FAIL;
	}

	DBG(("--> QueryInterface Success \n"));	
	if(!lpIImeIPoint) {
		DBG(("QuertyInterface failed\n"));
		return E_FAIL;
	}

	LPIMEDATACOMPOSITION lpCompoInfo;
	LPIMEDATACOMPOSITION lpCompoTmp;
	LPWSTR lpwstrCompo, lpwstr;
	DWORD  *pdwCharID, *pdw;	
	DWORD  dwSize;
	switch(dwDataID) {
	case IMEDATAID_COMPOSITION:
		switch(dwCmdID) {
		case IMECMDID_GETCOMPOSITIONINFO:
			DBG(("--> IMECMDID_GETCOMPOSITIONINFO\n"));
			dwSize = sizeof(IMEDATACOMPOSITION);
			lpCompoInfo = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvr->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpCompoInfo) {
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			hr = lpIImeIPoint->GetAllCompositionInfo(NULL,
													 NULL,
													 (INT *)&lpCompoInfo->dwStringCount,
													 (INT *)&lpCompoInfo->dwCaretPos,
													 (INT *)&lpCompoInfo->dwUndeterminedStartPos,
													 (INT *)&lpCompoInfo->dwUndeterminedLength,
													 (INT *)&lpCompoInfo->dwEditStartPos,
													 (INT *)&lpCompoInfo->dwEditLength);
			lpCompoInfo->header.dwSize  = dwSize;
			lpCompoInfo->header.dwCmdID = dwCmdID;
			lpCompoInfo->header.dwDataID= dwDataID;
			lpCompoInfo->dwOffsetString = 0;
			lpCompoInfo->dwOffsetCharID = 0;
			*pSize = lpCompoInfo->header.dwSize;
			*ppByte = (PBYTE)lpCompoInfo;
			DBG(("--> IMECMDID_GETCOMPOSITIONINFO END\n"));
			break;
		case IMECMDID_GETCOMPOSITIONSTRING:
			DBG(("--> IMECMDID_GETCOMPOSITIONSTRING START\n"));
			lpCompoInfo = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvr->m_fnCoTaskMemAlloc)(sizeof(IMEDATACOMPOSITION));
			if(!lpCompoInfo) {
				DBG(("-->OutofMemory\n"));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			lpwstrCompo = NULL;
			pdwCharID   = NULL;
			ZeroMemory(lpCompoInfo, sizeof(IMEDATACOMPOSITION));
			
			hr = lpIImeIPoint->GetAllCompositionInfo(&lpwstrCompo,
													 &pdwCharID,
													 (INT *)&lpCompoInfo->dwStringCount,
													 (INT *)&lpCompoInfo->dwCaretPos,
													 (INT *)&lpCompoInfo->dwUndeterminedStartPos,
													 (INT *)&lpCompoInfo->dwUndeterminedLength,
													 (INT *)&lpCompoInfo->dwEditStartPos,
													 (INT *)&lpCompoInfo->dwEditLength);
			DBG(("-->hr [0x%08x]\n", hr));
			DBGW((L"-->lpwstrCompo[%s]\n", lpwstrCompo));
			dwSize = sizeof(IMEDATACOMPOSITION) +
					 (lpCompoInfo->dwStringCount+1)*sizeof(WCHAR) +
					 (lpCompoInfo->dwStringCount) * sizeof(DWORD);
			DBG(("-->dwSize [%d]\n", dwSize));
			lpCompoTmp = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvr->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpCompoTmp) {
				DBG(("-->OutofMemory\n"));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			lpCompoTmp->header.dwSize  = dwSize;
			lpCompoTmp->header.dwCmdID = dwCmdID;
			lpCompoTmp->header.dwDataID= dwDataID;
			lpCompoTmp->dwStringCount           = lpCompoInfo->dwStringCount;
			lpCompoTmp->dwCaretPos              = lpCompoInfo->dwCaretPos;
			lpCompoTmp->dwUndeterminedStartPos  = lpCompoInfo->dwUndeterminedStartPos;
			lpCompoTmp->dwUndeterminedLength    = lpCompoInfo->dwUndeterminedLength;
			lpCompoTmp->dwEditStartPos          = lpCompoInfo->dwEditStartPos;
			lpCompoTmp->dwEditLength            = lpCompoInfo->dwEditLength;
			lpCompoTmp->dwOffsetString = (DWORD)sizeof(IMEDATACOMPOSITION);

			lpwstr = (LPWSTR)((PBYTE)lpCompoTmp + lpCompoTmp->dwOffsetString);
			//990928:toshiaK for KOTAE #2273
			//Need to check lpwstrCompo is NULL or not.
			if(lpwstrCompo && lpCompoTmp->dwStringCount > 0) {
				CopyMemory(lpwstr, 
					   (WCHAR *)lpwstrCompo,
					   lpCompoTmp->dwStringCount * sizeof(WCHAR));
			}
			lpwstr[lpCompoTmp->dwStringCount] = (WCHAR)0x0000;
			
			lpCompoTmp->dwOffsetCharID = (DWORD)(sizeof(IMEDATACOMPOSITION) +
												 (lpCompoTmp->dwStringCount+1)*sizeof(WCHAR));

			//990928:toshiaK for KOTAE #2273
			//Need to check pdwCharID is NULL or not.
			if(pdwCharID && lpCompoTmp->dwStringCount > 0) {
				pdw = (DWORD *)((PBYTE)lpCompoTmp + lpCompoTmp->dwOffsetCharID);
				CopyMemory(pdw, pdwCharID, sizeof(DWORD)*lpCompoTmp->dwStringCount);
			}
			
			*pSize = lpCompoTmp->header.dwSize;
			*ppByte = (PBYTE)lpCompoTmp;
			(*m_lpCImePadSvr->m_fnCoTaskMemFree)(lpCompoInfo);
			//990928:toshiaK for KOTAE #2273
			if(lpwstrCompo) {
				(*m_lpCImePadSvr->m_fnCoTaskMemFree)(lpwstrCompo);
			}
			//990928:toshiaK for KOTAE #2273
			if(pdwCharID) {
				(*m_lpCImePadSvr->m_fnCoTaskMemFree)(pdwCharID);
			}
			DBG(("--> IMECMDID_GETCOMPOSITIONSTRING END\n"));
			break;
		default:
			break;
		}
		break;
	case IMEDATAID_CONVSTATUS:
		{
			if(dwCmdID != IMECMDID_GETCONVERSIONSTATUS) {
				DBG((" --> INVALID CMDID\n"));
			}
			DBG(("--> IMECMDID_GETCONVERSIONSTATUS\n"));
			dwSize = sizeof(IMEDATACONVSTATUS);
			LPIMEDATACONVSTATUS lpConvStat;
			lpConvStat = (LPIMEDATACONVSTATUS)(*m_lpCImePadSvr->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpConvStat) {
				DBG(("E_OUTOFMEMORY dwSize [%d]\n", dwSize));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			LPARAM lConv = 0;
			LPARAM lSent = 0;
			hr = lpIImeIPoint->ControlIME((WORD)IPCTRL_GETCONVERSIONMODE,
										  (LPARAM)&lConv);
			
			hr = lpIImeIPoint->ControlIME((WORD)IPCTRL_GETSENTENCENMODE,
										  (LPARAM)&lSent);
			lpConvStat->header.dwSize  = dwSize;
			lpConvStat->header.dwCmdID = IMECMDID_GETCONVERSIONSTATUS;
			lpConvStat->header.dwDataID= IMEDATAID_CONVSTATUS;
			lpConvStat->dwConversionMode = (DWORD)lConv;
			lpConvStat->dwSentenceMode   = (DWORD)lSent;
			DBG((" --> dwConversionMode[0x%8x]\n", lpConvStat->dwConversionMode));
			DBG((" --> dwSentenceMode  [0x%8x]\n", lpConvStat->dwSentenceMode));
			*pSize  = dwSize;
			*ppByte = (PBYTE)lpConvStat;
		}
		break;
	case IMEDATAID_APPINFO:
		//990816:ToshiaK KOTAE Raid #1757
		if(dwCmdID != IMECMDID_GETAPPLHWND) {
			DBG((" --> INVALID CMDID\n"));
			hr = S_FALSE;
		}
		else {
			IImeCallback *lp = NULL;
			IUnknown *lpUnkCB;
			lpUnkCB = m_lpCImePadSvr->GetIUnkIImeCallback();
			if(!lpUnkCB) {
				DBG(("-->IImeCallback does not set\n"));
				lpIImeIPoint->Release();
				return E_FAIL;
			}
			if(IsBadVtbl((IUnkDummy*)lpUnkCB)) {
				DBG(("lpIUnk is BAD Pointer \n"));
				lpIImeIPoint->Release();
				return E_FAIL;
			}
			lpUnkCB->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
			if(!lp) {
				DBG(("-->QuertyInterface Failed\n"));
				lpIImeIPoint->Release();
				return E_FAIL;
			}

			dwSize = sizeof(IMEDATAAPPLINFO);
			LPIMEDATAAPPLINFO lpApplInfo;
			lpApplInfo = (LPIMEDATAAPPLINFO)(*m_lpCImePadSvr->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpApplInfo) {
				DBG(("E_OUTOFMEMORY dwSize [%d]\n", dwSize));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			lpApplInfo->header.dwSize  = dwSize;
			lpApplInfo->header.dwCmdID = IMECMDID_GETAPPLHWND;
			lpApplInfo->header.dwDataID= IMEDATAID_APPINFO;
			lpApplInfo->hwndApp = NULL;
			lp->GetApplicationHWND(&lpApplInfo->hwndApp);

			if(pSize && ppByte) {
				*pSize  = dwSize;
				*ppByte = (PBYTE)lpApplInfo;
			}
			else {
				(*m_lpCImePadSvr->m_fnCoTaskMemFree)(lpApplInfo);
				hr = E_FAIL;
			}
			lp->Release();
		}
		break;
	default:
		DBG(("UNKOWN DATAID [0x%08x]\n",  dwDataID));
		hr = S_FALSE;
		break;
	}

	lpIImeIPoint->Release();
	DBG(("CImePadCallback::ReceiveData END hr[0x%08x]\n", hr));
	return hr;
}


//----------------------------------------------------------------

CImePadCallback::CImePadCallback(HWND hwndIF, LPCImePadSvr lpCImePadSvr)
{
	DBG(("######## CImePadCallback::CImePadCallback constructor START ##########\n"));
	m_hwndIF       = hwndIF;
	m_lpCImePadSvr = lpCImePadSvr;
	m_cRef		   = 0;
	DBG(("######## CImePadCallback::CImePadCallback constructor END   ##########\n"));
}

CImePadCallback::~CImePadCallback()
{
	DBG(("######## CImePadCallback::~CImePadCallback destructor START ##########\n"));
	m_hwndIF	   = NULL;
	m_lpCImePadSvr = NULL;
	DBG(("######## CImePadCallback::~CImePadCallback destructor END   ##########\n"));	
	m_cRef		   = 0;
}

VOID*
CImePadCallback::operator new( size_t size )
{
	LPVOID lp = (LPVOID)MemAlloc(size);
	return lp;
}

VOID
CImePadCallback::operator delete( VOID *lp )
{
	if(lp) {
		MemFree(lp);
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpaddbg.cpp ===
//////////////////////////////////////////////////////////////////
// File     : cpaddbg.cpp
// Purpose  :
// 
// 
// Date     : Fri Feb 19 22:03:56 1999
// Author   : 
//
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifdef _DEBUG
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdarg.h>
#include "cpaddbg.h"
#include <stdio.h>

static IsWinNT()
{
	static OSVERSIONINFO os;
	if(os.dwOSVersionInfoSize == 0) { 
		os.dwOSVersionInfoSize = sizeof(os);
		::GetVersionEx(&os);
	}
	return (os.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

//----------------------------------------------------------------
//internal function prototype declare
//----------------------------------------------------------------
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath);
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath);
VOID   _padDbgPrintfA			(LPSTR  lpstrFmt, ...);
VOID   _padDbgPrintfW			(LPWSTR lpstrFmt, ...);

#define SZPREFIX	"IME:cpad:"
#define WSZPREFIX	L"IME:cpad:"
//----------------------------------------------------------------
// Global Data
//----------------------------------------------------------------
static LPFNDBGCALLBACKA g_lpfnDbgCBA=NULL;
static LPFNDBGCALLBACKW g_lpfnDbgCBW=NULL;
//static BOOL g_fEnable=FALSE;
static BOOL g_fEnable=TRUE;
inline VOID ODStrW(LPWSTR lpwstr)
{
	if(g_fEnable) OutputDebugStringW(lpwstr);
}
inline VOID ODStrA(LPSTR lpstr)
{
	if(g_fEnable) OutputDebugStringA(lpstr);
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgSetCallback
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPFNDBGCALLBACK lpfnDbgCallback 
// Return   : 
// DATE     : Tue Jan 06 12:42:36 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgSetCallback(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW)
{
	g_lpfnDbgCBA = lpfnCBA;
	g_lpfnDbgCBW = lpfnCBW;
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgSwitchOutput
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:35:55 1998
// Author   : 
//////////////////////////////////////////////////////////////////
VOID _padDbgEnableOutput(BOOL fEnable)
{
	g_fEnable = fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgIsOutputEnable
// Type     : VOID
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 18:00:52 1998
// Author   : 
//////////////////////////////////////////////////////////////////
BOOL _padDbgIsOutputEnable(VOID)
{
	return g_fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgOutStrA
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Tue Jan 06 12:29:39 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgOutStrA(LPSTR lpstr)
{
	static BOOL fIn;
	ODStrA(lpstr);
#ifdef _CONSOLE
	printf(lpstr);
#endif

	if(g_lpfnDbgCBA) {
		if(fIn) { return; }
		fIn = TRUE;
		(*g_lpfnDbgCBA)(lpstr);
		fIn = FALSE;
	}
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgOutStrW
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpwstr 
// Return   : 
// DATE     : Tue Jan 06 12:30:07 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgOutStrW(LPWSTR lpwstr)
{
	static BOOL fIn;
	if(IsWinNT()) {
		ODStrW(lpwstr);
	}
	else {
		static CHAR szBuf[1024];
		::WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0);
		ODStrA(szBuf);
	}

#ifdef _CONSOLE
	static CHAR szBuf[1024];
	::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
	printf(szBuf);
#endif
	if(g_lpfnDbgCBW) { 
		if(fIn) { return; } 		
		fIn = TRUE;
		(*g_lpfnDbgCBW)(lpwstr);
		fIn = FALSE;
	}
	return;
}

////////////////////////////////////////////////////////
// Function: _padDbgA
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _padDbgA(LPSTR		lpstrFile, 
			 INT		lineNo, 
			 LPSTR		lpstrMsg)
{
	_padDbgPrintfA("%s(%12s:%4d) %s", 
				  SZPREFIX,
				  GetFileTitleStrA(lpstrFile),
				  lineNo,
				  lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFile 
//          : INT lineNo 
//          : LPWSTR lpstrMsg 
// Return   : 
// DATE     : Mon Jan 05 15:10:41 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg)
{
	_padDbgPrintfW(L"%s(%10s:%4d) %s", 
				  WSZPREFIX,
				  GetFileTitleStrW(lpstrFile),
				  lineNo,
				  lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgVaStrA
// Type     : LPSTR
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:09:53 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(chBuf, lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function : _padDbgVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _padDbgVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap);	//Use C-RunTime Library for Win95
	va_end(ap);
	return wchBuf;
}


////////////////////////////////////////////////////////
// Function: _padDbgPrintfA
// Type    : VOID
// Purpose : variable args version of OutputDebugStringA
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _padDbgPrintfA(LPSTR lpstrFmt, ...)
{
	static CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	_padDbgOutStrA(szBuf);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgPrintfW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:11:24 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgPrintfW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap); //Use C-RunTime Library for Win95
	va_end(ap);
	_padDbgOutStrW(wchBuf);
	return;
}


//////////////////////////////////////////////////////////////////
// Function : _padDbgMulti2Wide
// Type     : LPWSTR
// Purpose  : return Unicode string from MBCS string
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Mon Jan 05 15:10:48 1998
//////////////////////////////////////////////////////////////////
LPWSTR _padDbgMulti2Wide(LPSTR lpstr)
{
	static WCHAR wchBuf[512];
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}


//////////////////////////////////////////////////////////////////
// Function : _padDbgGetWinClass
// Type     : LPSTR
// Purpose  : Get Windows class name string
//			  ANSI version only.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:08:43 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetWinClass(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetClassNameA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;

}

//////////////////////////////////////////////////////////////////
// Function : _padDbgGetWinText
// Type     : LPSTR
// Purpose  : Get Windows text(title) string
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:09:08 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetWinText(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetWindowTextA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgMsgBoxA
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Thu Jan 08 12:31:03 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgMsgBoxA(LPSTR lpstrFile,  INT lineNo, LPSTR lpstrMsg)
{
#ifdef _CONSOLE
	return;
#endif
	char szTmp[512];
	wsprintfA(szTmp, "Debug Message Box (File: %s, Line: %4d)", 
			   GetFileTitleStrA(lpstrFile), 
			   lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
}

VOID _padDbgAssert(LPSTR  lpstrFile,  INT lineNo, BOOL fOk, LPSTR lpstrMsg)
{
	if(fOk) {
		return; 
	}
	char szTmp[512];
	wsprintfA(szTmp, "ASSERT (File: %s, Line: %4d)", 
			 GetFileTitleStrA(lpstrFile), 
			 lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
	DebugBreak();
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgGetErrorString
// Type     : LPSTR
// Purpose  : Convert Error(Got from GetLastError()) value to ERROR Message String
// Args     : 
//          : INT errorCode 
// Return   : 
// DATE     : Mon Jan 05 16:43:34 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetErrorString(INT errorCode)
{
	static CHAR szBuf[512];
	INT count;
	szBuf[0] = (CHAR)0x00;
	count = wsprintfA(szBuf, "[0x%08x]:", errorCode);
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   errorCode, 
				   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				   szBuf+count,
				   sizeof(szBuf)-1-count,
				   NULL );
	if(*(szBuf + count) != (CHAR)0x00) {
		int nLen = lstrlenA(szBuf);
		if((nLen - count) > 1) {
			szBuf[nLen - 1] = (CHAR)0x00;
		}
	}
	return szBuf;
}


//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrA
// Type     : static LPSTR
// Purpose  : Return File name string(remove folder)
// Args     : 
//          : LPSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:34:22 1998
//////////////////////////////////////////////////////////////////
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath)
{
	static CHAR szBuf[2];
	CHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenA(lpstrFilePath) - 1);
	for(pTemp = CharPrevA(lpstrFilePath, pLast); 
		(pTemp  != lpstrFilePath) && 
		(*pTemp != '\\')	 &&
		(*pTemp != (CHAR)0x00); 
		pTemp = CharPrevA(lpstrFilePath, pTemp)) {
		;
	}
	if(*pTemp == '\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}

//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrW
// Type     : static LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:38:19 1998
//////////////////////////////////////////////////////////////////
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath)
{
	static WCHAR szBuf[2];
	WCHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenW(lpstrFilePath) - 1);
	for(pTemp = pLast-1;
		(pTemp != lpstrFilePath) &&
		(*pTemp != L'\\')		 &&
		(*pTemp != (WCHAR)0x0000);
		pTemp--) {
		;
	}

	if(*pTemp == L'\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}


#define DEFID(a)	{a, #a}
typedef struct idStr {
	INT code;
	LPSTR lpstr;
}IDSTR; 

IDSTR rpcError[]={
	DEFID(RPC_S_INVALID_STRING_BINDING),
	DEFID(RPC_S_WRONG_KIND_OF_BINDING),
	DEFID(RPC_S_INVALID_BINDING),
	DEFID(RPC_S_PROTSEQ_NOT_SUPPORTED),
	DEFID(RPC_S_INVALID_RPC_PROTSEQ),
	DEFID(RPC_S_INVALID_STRING_UUID),
	DEFID(RPC_S_INVALID_ENDPOINT_FORMAT),
	DEFID(RPC_S_INVALID_NET_ADDR),
	DEFID(RPC_S_NO_ENDPOINT_FOUND),
	DEFID(RPC_S_INVALID_TIMEOUT),
	DEFID(RPC_S_OBJECT_NOT_FOUND),
	DEFID(RPC_S_ALREADY_REGISTERED),
	DEFID(RPC_S_TYPE_ALREADY_REGISTERED),
	DEFID(RPC_S_ALREADY_LISTENING),
	DEFID(RPC_S_NO_PROTSEQS_REGISTERED),
	DEFID(RPC_S_NOT_LISTENING),
	DEFID(RPC_S_UNKNOWN_MGR_TYPE),
	DEFID(RPC_S_UNKNOWN_IF),
	DEFID(RPC_S_NO_BINDINGS),
	DEFID(RPC_S_NO_PROTSEQS),
	DEFID(RPC_S_CANT_CREATE_ENDPOINT),
	DEFID(RPC_S_OUT_OF_RESOURCES),
	DEFID(RPC_S_SERVER_UNAVAILABLE),
	DEFID(RPC_S_SERVER_TOO_BUSY),
	DEFID(RPC_S_INVALID_NETWORK_OPTIONS),
	DEFID(RPC_S_NO_CALL_ACTIVE),
	DEFID(RPC_S_CALL_FAILED),
	DEFID(RPC_S_CALL_FAILED_DNE),
	DEFID(RPC_S_PROTOCOL_ERROR),
	DEFID(RPC_S_UNSUPPORTED_TRANS_SYN),
	DEFID(RPC_S_UNSUPPORTED_TYPE),
	DEFID(RPC_S_INVALID_TAG),
	DEFID(RPC_S_INVALID_BOUND),
	DEFID(RPC_S_NO_ENTRY_NAME),
	DEFID(RPC_S_INVALID_NAME_SYNTAX),
	DEFID(RPC_S_UNSUPPORTED_NAME_SYNTAX),
	DEFID(RPC_S_UUID_NO_ADDRESS),
	DEFID(RPC_S_DUPLICATE_ENDPOINT),
	DEFID(RPC_S_UNKNOWN_AUTHN_TYPE),
	DEFID(RPC_S_MAX_CALLS_TOO_SMALL),
	DEFID(RPC_S_STRING_TOO_LONG),
	DEFID(RPC_S_PROTSEQ_NOT_FOUND),
	DEFID(RPC_S_PROCNUM_OUT_OF_RANGE),
	DEFID(RPC_S_BINDING_HAS_NO_AUTH),
	DEFID(RPC_S_UNKNOWN_AUTHN_SERVICE),
	DEFID(RPC_S_UNKNOWN_AUTHN_LEVEL),
	DEFID(RPC_S_INVALID_AUTH_IDENTITY),
	DEFID(RPC_S_UNKNOWN_AUTHZ_SERVICE),
	DEFID(EPT_S_INVALID_ENTRY),
	DEFID(EPT_S_CANT_PERFORM_OP),
	DEFID(EPT_S_NOT_REGISTERED),
	DEFID(RPC_S_NOTHING_TO_EXPORT),
	DEFID(RPC_S_INCOMPLETE_NAME),
	DEFID(RPC_S_INVALID_VERS_OPTION),
	DEFID(RPC_S_NO_MORE_MEMBERS),
	DEFID(RPC_S_NOT_ALL_OBJS_UNEXPORTED),
	DEFID(RPC_S_INTERFACE_NOT_FOUND),
	DEFID(RPC_S_ENTRY_ALREADY_EXISTS),
	DEFID(RPC_S_ENTRY_NOT_FOUND),
	DEFID(RPC_S_NAME_SERVICE_UNAVAILABLE),
	DEFID(RPC_S_INVALID_NAF_ID),
	DEFID(RPC_S_CANNOT_SUPPORT),
	DEFID(RPC_S_NO_CONTEXT_AVAILABLE),
	DEFID(RPC_S_INTERNAL_ERROR),
	DEFID(RPC_S_ZERO_DIVIDE),
	DEFID(RPC_S_ADDRESS_ERROR),
	DEFID(RPC_S_FP_DIV_ZERO),
	DEFID(RPC_S_FP_UNDERFLOW),
	DEFID(RPC_S_FP_OVERFLOW),
	DEFID(RPC_X_NO_MORE_ENTRIES),
	DEFID(RPC_X_SS_CHAR_TRANS_OPEN_FAIL),
	DEFID(RPC_X_SS_CHAR_TRANS_SHORT_FILE),
	DEFID(RPC_X_SS_IN_NULL_CONTEXT),
	DEFID(RPC_X_SS_CONTEXT_DAMAGED),
	DEFID(RPC_X_SS_HANDLES_MISMATCH),
	DEFID(RPC_X_SS_CANNOT_GET_CALL_HANDLE),
	DEFID(RPC_X_NULL_REF_POINTER),
	DEFID(RPC_X_ENUM_VALUE_OUT_OF_RANGE),
	DEFID(RPC_X_BYTE_COUNT_TOO_SMALL),
	DEFID(RPC_X_BAD_STUB_DATA),
	DEFID(ERROR_INVALID_USER_BUFFER),
	DEFID(ERROR_UNRECOGNIZED_MEDIA),
	DEFID(ERROR_NO_TRUST_LSA_SECRET),
	DEFID(ERROR_NO_TRUST_SAM_ACCOUNT),
	DEFID(ERROR_TRUSTED_DOMAIN_FAILURE),
	DEFID(ERROR_TRUSTED_RELATIONSHIP_FAILURE),
	DEFID(ERROR_TRUST_FAILURE),
	DEFID(RPC_S_CALL_IN_PROGRESS),
};

LPSTR _padDbgGetRPCError(INT code)
{
	INT i;
	for(i = 0; i < sizeof(rpcError)/sizeof(rpcError[0]); i++) {
		if(rpcError[i].code == code) {
			return rpcError[i].lpstr;
		}
	}
	static char szBuf[]="";
	return szBuf;
}

INT _padDbgShowError(HRESULT hr, LPSTR lpstrFunc)
{
	char szBuf[256];
	char szMsg[1024];
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				  NULL,
				  hr,
				  0,
				  szBuf,
				  256,
				  NULL);
	szBuf[lstrlenA(szBuf)-1] = (char)0x00;
	wsprintfA(szMsg, "!!%s: hr[0x%08x] code[%d][%x][%s][%s]",
			 lpstrFunc ? lpstrFunc : "UnknownFunc",
			 hr,
			 HRESULT_CODE(hr),
			 HRESULT_CODE(hr),
			 _padDbgGetErrorString(HRESULT_CODE(hr)), 
			 szBuf);
	DBG(("%s\n", szMsg));
	return 0;
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpaddbg.h ===
//////////////////////////////////////////////////////////////////
// File     : cpaddbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef __C_PAD_DBG_H_
#define __C_PAD_DBG_H_

#ifdef __cplusplus
#	define InlineFunc  inline
#else 
#	define InlineFunc  __inline
#endif

//----------------------------------------------------------------
// Callback function prototype
//----------------------------------------------------------------
typedef VOID (WINAPI *LPFNDBGCALLBACKA)(LPSTR  lpstr);
typedef VOID (WINAPI *LPFNDBGCALLBACKW)(LPWSTR lpwstr);

//-------------------------------------------------------
//MACRO function  prototype declare.
//It is valid only if compliled with _DEBUG definition.
//-------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function : DBGSetCallback
// Type     : VOID
// Purpose  : Set debug callback function.
//			  callback function has set, when DBG() has called,
//			  call this callback function with formatted message string.
// Args     : 
//          : LPFNDBGCALLBACKA lpfnDbgCallbackA 
//          : LPFNDBGCALLBACKW lpfnDbgCallbackW 
// Return   : VOID
// DATE     : Tue Jan 06 12:21:05 1998
//////////////////////////////////////////////////////////////////
//VOID DBGSetCallback(LPFNDBGCALLBACKA lpfnDbgCallbackA, LPFNDBGCALLBACKW lpfnDbgCallbackW);

//////////////////////////////////////////////////////////////////
// Function : DBGEnableOutput
// Type     : VOID
// Purpose  : On off OutputDebugString to COM.
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:33:21 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//VOID DBGEnableOutput(BOOL fEnable)

//////////////////////////////////////////////////////////////////
// Function : DBGIsOutputEnable
// Type     : BOOL
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 17:58:28 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//BOOL DBGIsOutputEnable(VOID)


////////////////////////////////////////////////////////
// Function	: DBG
// Type		: VOID
// Purpose	: Printing ANSI debug message with same usage as printf()
// Args		: 
//			: LPSTR lpstrFuncName 
//			: ...	
// Example	: DBGW(("Error occured data[%d]", i));
// CAUTION	: Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//		   : ...	
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example	: DBGW(("Error occured data[%d]", i));
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

//////////////////////////////////////////////////////////////////
// Function : DBGMsgBox
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example	: DBGMsgBox(("Error occured data[%d]", i));
//////////////////////////////////////////////////////////////////
//VOID DBGMsgBox((LPSTR lpstrFmt, ...))

//////////////////////////////////////////////////////////////////
// Function : DBGAssert
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fError
// Return   : 
// DATE     : Fri Jan 09 17:17:31 1998
//////////////////////////////////////////////////////////////////
//VOID DBGAssert(BOOL fError)


//////////////////////////////////////////////////////////////////
// Function : DBGSTR
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr
//////////////////////////////////////////////////////////////////
//VOID DBGSTR(LPSTR lpstr);


//////////////////////////////////////////////////////////////////
// Function : DBGGetErrorString
// Type     : VOID
// Purpose  : Get error message from WIN32 Error code.
// Args     : 
//          : INT errorCode 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetErrorString(INT errorCode)


//////////////////////////////////////////////////////////////////
// Function : DBGGetWinClass
// Type     : LPSTR
// Purpose  : Get class name string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinClass(HWND hwnd)

//////////////////////////////////////////////////////////////////
// Function : DBGGetWinText
// Type     : LPSTR
// Purpose  : Get title text string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinText(HWND hwnd)



#ifdef _DEBUG
//----------------------------------------------------------------
//Function prototype declare
//----------------------------------------------------------------
extern VOID   _padDbgEnableOutput	(BOOL fEnable);
extern BOOL   _padDbgIsOutputEnable	(VOID);
extern VOID	  _padDbgSetCallback		(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW);
extern VOID   _padDbgA				(LPSTR  lpstrFile, INT lineNo, LPSTR  lpstrMsg);
extern VOID   _padDbgW				(LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _padDbgMsgBoxA			(LPSTR  lpstrFile,  INT lineNo, LPSTR lpstrMsg);
extern VOID   _padDbgAssert			(LPSTR  lpstrFile,  INT lineNo, BOOL fError, LPSTR lpstrMsg);
extern VOID   _padDbgPrintfA			(LPSTR  lpstrFmt, ...);
extern VOID   _padDbgPrintfW			(LPWSTR lpstrFmt, ...);
extern VOID   _padDbgOutStrA			(LPSTR  lpstr);
extern VOID	  _padDbgOutStrW			(LPWSTR lpwstr);
extern LPSTR  _padDbgVaStrA			(LPSTR  lpstrFmt, ...);
extern LPWSTR _padDbgVaStrW			(LPWSTR lpstrFmt, ...);
extern LPWSTR _padDbgMulti2Wide		(LPSTR  lpstr);
extern LPSTR  _padDbgGetWinClass		(HWND   hwnd);
extern LPSTR  _padDbgGetWinText		(HWND   hwnd);
extern LPSTR  _padDbgGetErrorString	(INT    errorCode);
extern LPSTR  _padDbgGetVkStr		(INT	virtKey);
extern INT	  _padDbgShowError		(HRESULT hr, LPSTR lpstrFunc);
//----------------------------------------------------------------
// Macro definition
//----------------------------------------------------------------
#	define DBGSetCallback(a,b)	_padDbgSetCallback(a, b)
#	define DBGEnableOutput(a)	_padDbgEnableOutput(a)
#	define DBGIsOutputEnable()	_padDbgIsOutputEnable()
#   undef DBG
#	define DBG(a)				_padDbgA(__FILE__, __LINE__, _padDbgVaStrA a)
#	define DBGA(a)				_padDbgA(__FILE__, __LINE__, _padDbgVaStrA a)
#	define DBGW(a)				_padDbgW( _padDbgMulti2Wide(__FILE__), __LINE__, _padDbgVaStrW a)
#	define DBGMsgBox(a)			_padDbgMsgBoxA(__FILE__, __LINE__, _padDbgVaStrA a)
#	define DBGAssert(a)			_padDbgAssert(__FILE__, __LINE__, a, #a)
#	define DBGAssertSz(a,b)		_padDbgAssert(__FILE__, __LINE__, a, b)
#	define DBGOutStr(a)			_padDbgOutStrA(a)
#	define DBGOutStrA(a)		_padDbgOutStrA(a)
#	define DBGOutStrW(a)		_padDbgOutStrW(a)
#	define DBGP(a)				_padDbgOutStrA(_padDbgVaStrA a)
#	define DBGPA(a)				_padDbgOutStrA(_padDbgVaStrA a)
#	define DBGPW(a)				_padDbgOutStrW(_padDbgVaStrW a)
#	define DBGGetErrorString(a)	_padDbgGetErrorString(a)
#	define DBGGetWinClass(a)	_padDbgGetWinClass(a)
#	define DBGGetWinText(a)		_padDbgGetWinText(a)
#	define DBGShowError(a,b)	_padDbgShowError(a,b)
#else //!_DEBUG	//in Release version, these will disapear...
#	define DBGSetCallback(a,b)
#	define DBGEnableOutput(a)
#	define DBGIsOutputEnable()
#   undef DBG
#	define DBG(a)
#	define DBGW(a)
#	define DBGA(a)
#	define DBGP(a)
#	define DBGPA(a)
#	define DBGPW(a)
#	define DBGAssert(a)
#	define DBGAssertSz(a,b)
#	define DBGMsgBox(a)
#	define DBGOutStr(a)
#	define DBGOutStrA(a)
#	define DBGOutStrW(a)
#	define DBGGetErrorString(a)
#	define DBGGetWinClass(a)
#	define DBGGetWinText(a)
#	define DBGShowError(a,b)
#endif //_DEBUG


//----------------------------------------------------------------
//These function use variable argument, so we cannot define 
//"Normal" MACRO for them.
//so, Use inline function that do nothing if _DEBUG is NOT set.
//----------------------------------------------------------------
InlineFunc VOID DBGDoNothingA(LPSTR  lpstrFmt, ...) {lpstrFmt;}
InlineFunc VOID DBGDoNothingW(LPWSTR lpstrFmt, ...) {lpstrFmt;}
#ifdef _DEBUG 
#define DBGPrintf		_padDbgPrintfA
#define DBGPrintfA		_padDbgPrintfA
#define DBGPrintfW		_padDbgPrintfW
#else 
#define DBGPrintf		DBGDoNothingA
#define DBGPrintfA		DBGDoNothingA
#define DBGPrintfW		DBGDoNothingW
#endif


//----------------------------------------------------------------
//This is helper inline function for outputs debug string in 
//Retail version. if FORCE_DEBUG is defined this function works.
//Some time, we met bugs than occurs only retail version, 
//and would like to out debug message. 
//----------------------------------------------------------------
#ifdef FORCE_DEBUG
#include <stdarg.h>
//////////////////////////////////////////////////////////////////
// Function : FDbg
// Type     : InlineFunc VOID
// Purpose  : 
// Args     : 
//          : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Tue Jan 06 19:06:19 1998
//////////////////////////////////////////////////////////////////
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...)
{
	CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	OutputDebugStringA(szBuf);	
	return;
}
#else //FORCE_DEBUG
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...) {lpstrFmt;}
#endif

#endif //_C_PAD_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadsvr.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvr.cpp
// Purpose  :	Client source code for IMEPad executable.
// 
// 
// Date     :	Fri Apr 16 15:39:33 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
//----------------------------------------------------------------
//	Public static methods
//
//	static BOOL OnProcessAttach(HINSTANCE hInst);
//	static BOOL OnProcessDetach(VOID);
//	static BOOL OnThreadAttach(VOID);
//	static BOOL OnThreadDetach(VOID);
//	static LPCImePadSvr GetCImePadSvr(VOID);
//	static LPCImePadSvr LoadCImePadSvr(VOID);
//	static LPCImePadSvr FecthCImePadSvr(VOID);
//	static VOID         DestroyCImePadSvr(VOID);
//
//----------------------------------------------------------------
#include <windows.h>
#ifdef UNDER_CE // stub for CE
#include "stub_ce.h"
#endif // UNDER_CE
#include "cpadsvr.h"
#include "cpaddbg.h"
#include "cpadsvrs.h"	//Use Shared Memory for IPC. 

//----------------------------------------------------------------
//misc definition
//----------------------------------------------------------------
#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)
//----------------------------------------------------------------
//Static member initialize
//----------------------------------------------------------------
#define UNDEF_TLSINDEX	0xFFFFFFFF					
INT		CImePadSvr::m_gdwTLSIndex = UNDEF_TLSINDEX;	//Thread Local Strage initial value.
HMODULE	CImePadSvr::m_ghModClient = NULL;			//Client Module handle.

//----------------------------------------------------------------
//OLE function is dynamically loaded/called
//----------------------------------------------------------------
#define SZMOD_OLE32DLL			TEXT("OLE32.DLL")
#ifdef UNDER_CE // For GetModuleHandleW
#define WSZMOD_OLE32DLL			L"OLE32.DLL"
#endif // UNDER_CE
#define SZFN_COINITIALIZE		"CoInitialize"
#define SZFN_COCREATEINSTANCE	"CoCreateInstance"
#define SZFN_COUNINITIALIZE		"CoUninitialize"
#define SZFN_CODISCONNECTOBJECT	"CoDisconnectObject"
#define SZFN_COTASKMEMALLOC		"CoTaskMemAlloc"
#define SZFN_COTASKMEMREALLOC	"CoTaskMemRealloc"
#define SZFN_COTASKMEMFREE		"CoTaskMemFree"

#ifdef UNICODE
#pragma message("UNICODE Unicode")
#endif
//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::OnProcessAttach
// Type		:	BOOL
// Purpose	:	Get thread local strage index.
//				Initialize static value.	
// Args		:	
//			:	HINSTANCE	hInst	Caller's moudle handle.
// Return	:	
// DATE		:	Fri Apr 16 15:41:32 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvr::OnProcessAttach(HINSTANCE hInst)
{
	DBG(("CImePadSvr::OnProcessAttach START\n"));
#ifdef _DEBUG
	DWORD dwPID = ::GetCurrentProcessId();
	DWORD dwTID = ::GetCurrentThreadId();
	DBG(("-->PID [0x%08x][%d] TID [0x%08x][%d]\n", dwPID, dwPID, dwTID, dwTID));
#endif

#ifdef _DEBUG
	if(m_ghModClient) {
		::DebugBreak();
	}
	if(m_gdwTLSIndex != UNDEF_TLSINDEX) {
		::DebugBreak();
	}
#endif
	m_ghModClient  = (HMODULE)hInst;
	m_gdwTLSIndex  = ::TlsAlloc();	//Get new TLS index.
	if(m_gdwTLSIndex == UNDEF_TLSINDEX) {
		DBG(("-->OnPorcessAttach ::TlsAlloc Error ret [%d]\n", GetLastError()));
	}

	DBG(("-->OnProcessAttach() m_gdwTLSIndex[0x%08x][%d]\n",  m_gdwTLSIndex, m_gdwTLSIndex));
	DBG(("CImePadSvr::OnProcessAttach END\n"));
	return TRUE;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::OnProcessDetach
// Type		:	BOOL
// Purpose	:	Delete all client instance.
//				We cannot call COM API in DLL_PROCESS_DETACH.
//				See DCOM mailing list article, 
//				http://discuss.microsoft.com/SCRIPTS/WA-MSD.EXE?A2=ind9712a&L=dcom&F=&S=&P=20706
// Args		:	None
// Return	:	
// DATE		:	Tue Apr 13 17:49:55 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvr::OnProcessDetach(VOID)
{
	DBG(("CImePadSvr::OnProcessDetach\n"));
	CImePadSvr::OnThreadDetach();

	if(!::TlsFree(m_gdwTLSIndex)) {
		DBG(("-->::TlsFree Error [%d]\n", GetLastError()));
	}
	m_gdwTLSIndex = UNDEF_TLSINDEX;
	DBG(("CImePadSvr::OnProcessDetach END\n"));
	return TRUE;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::OnThreadAttach
// Type		:	BOOL
// Purpose	:	Do Nothing.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 21:37:16 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvr::OnThreadAttach(VOID)
{
	return TRUE;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::OnThreadDetach
// Type		:	BOOL
// Purpose	:	
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 21:38:06 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvr::OnThreadDetach(VOID)
{
	DBG(("CImePadSvr::OnThreadDetach\n"));
#ifdef _DEBUG
	DWORD dwPID = ::GetCurrentProcessId();
	DWORD dwTID = ::GetCurrentThreadId();
	DBG(("-->PID [0x%08x][%d] TID [0x%08x][%d]\n", dwPID, dwPID, dwTID, dwTID));
#endif
	LPCImePadSvr lpCImePadSvr = (LPCImePadSvr)::TlsGetValue(m_gdwTLSIndex);
	if(lpCImePadSvr) {
		DBG(("-->First Set TlsSetValue as NULL\n"));
		if(!::TlsSetValue(m_gdwTLSIndex, NULL)) {
			DBG(("TlsSetValue Failed\n"));
		}
		DBG(("-->Call ForceDisConnect() START\n"));
		lpCImePadSvr->ForceDisConnect();
		DBG(("-->Call ForceDisConnect() END\n"));
		delete lpCImePadSvr;
	}
	DBG(("CImePadSvr::OnThreadDetach END\n"));
	return TRUE;
}


//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::GetCImePadSvr
// Type		:	LPCImePadSvr
// Purpose	:	Get LPCImePadSvr pointer in current Thread.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 21:41:46 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
LPCImePadSvr
CImePadSvr::GetCImePadSvr(VOID)
{
	LPCImePadSvr lpCImePadSvr;
	if(m_gdwTLSIndex == UNDEF_TLSINDEX) {
		DBG(("-->CImePadSvr::GetCImePadSvr() Error, need TLS index\n"));  
#ifdef _DEBUG
		//DebugBreak();
#endif
		return NULL;
	}
	lpCImePadSvr = (LPCImePadSvr)::TlsGetValue(m_gdwTLSIndex); 
	return lpCImePadSvr;
}


//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::LoadCImePadSvr
// Type		:	LPCImePadSvr
// Purpose	:	Load LPCImePadSvr pointer in current thread.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 21:42:17 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
LPCImePadSvr
CImePadSvr::LoadCImePadSvr(INT protocol)
{
	LPCImePadSvr lpCImePadSvr;

	lpCImePadSvr = CImePadSvr::GetCImePadSvr();
	
	if(lpCImePadSvr) {	//Already created in current thread. 
		return lpCImePadSvr;
	}

	lpCImePadSvr = NULL;
	switch(protocol) {
	case CIMEPADSVR_COM:
		//lpCImePadSvr = new CImePadSvrCOM(); 
		break;
	case CIMEPADSVR_SHAREDMEM:
		lpCImePadSvr = new CImePadSvrSharemem();
		if(lpCImePadSvr) {
			if(!lpCImePadSvr->IsAvailable()) {
				delete lpCImePadSvr;
				lpCImePadSvr = NULL;
			}
		}
		break;
	default:
		break;
	}
	if(!lpCImePadSvr) {
		DBG(("-->LoadCImePadSvr() Error Out of Memory?\n"));
		return NULL;
	}
	//Set new value to TLS.
	if(!::TlsSetValue(m_gdwTLSIndex, lpCImePadSvr)) {
		DBG(("-->LoadCImePadSvr() TlsSetValue Failed [%d]\n", GetLastError()));
		delete lpCImePadSvr;
		::TlsSetValue(m_gdwTLSIndex, NULL);
		return NULL;
	}
	return lpCImePadSvr;
}

LPCImePadSvr
CImePadSvr::FecthCImePadSvr(VOID)
{
	return NULL;
}

VOID
CImePadSvr::DestroyCImePadSvr(VOID)
{
	DBG(("CImePadSvr::DestroyCImePadSvr START\n"));
	LPCImePadSvr lpCImePadSvr = GetCImePadSvr();
	if(!lpCImePadSvr) {
		DBG(("-->CImePadSvr::DestroyCImePadSvr() Already Destroyed or not instance\n"));
		DBG(("CImePadSvr::DestroyCImePadSvr END\n"));
		return;
	}
	lpCImePadSvr->Terminate(NULL);
	delete lpCImePadSvr;
	if(!::TlsSetValue(m_gdwTLSIndex, NULL)) {
		DBG(("-->TlsSetValue() error [%d]\n", GetLastError()));
	}
	DBG(("CImePadSvr::DestroyCImePadSvr END\n"));
	return;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvr::CImePadSvr
// Type		:	
// Purpose	:	Constructor of CImePadSvr
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:37:18 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvr::CImePadSvr()
{
	DBG(("CImePadSvr::CImePadSvr START\n"));
	m_fCoInitSuccess		= FALSE;	//Flag for CoInitialize() successed or not. 
	m_fOLELoaded			= FALSE;	//OLE32.DLL is loaded by Application or explicitly loaded.
	m_hModOLE				= FALSE;	//OLE32.DLL module handle.
	m_fnCoInitialize		= NULL;		//CoInitialize()		function pointer.
	m_fnCoCreateInstance	= NULL;		//CoCreateInstance()	function pointer.
	m_fnCoUninitialize		= NULL;		//CoUninitialize()		function pointer.
	m_fnCoDisconnectObject	= NULL;		//CoDisconnectObject()	function pointer.
	m_fnCoTaskMemAlloc		= NULL;		//CoTaskMemAlloc()		function pointer.
	m_fnCoTaskMemRealloc	= NULL;		//CoTaskMemRealloc()	function pointer.
	m_fnCoTaskMemFree		= NULL;		//CoTaskMemFree()		function pointer.
	DBG(("CImePadSvr::CImePadSvr END\n"));
}

CImePadSvr::~CImePadSvr()
{
	DBG(("CImePadSvr::~CImePadSvr START\n"));
	m_fCoInitSuccess		= FALSE;	//Flag for CoInitialize() successed or not. 
	m_fOLELoaded			= FALSE;	//OLE32.DLL is loaded by Application or explicitly loaded.
	m_hModOLE				= FALSE;	//OLE32.DLL module handle.
	m_fnCoInitialize		= NULL;		//CoInitialize()		function pointer.
	m_fnCoCreateInstance	= NULL;		//CoCreateInstance()	function pointer.
	m_fnCoUninitialize		= NULL;		//CoUninitialize()		function pointer.
	m_fnCoDisconnectObject	= NULL;		//CoDisconnectObject()	function pointer.
	m_fnCoTaskMemAlloc		= NULL;		//CoTaskMemAlloc()		function pointer.
	m_fnCoTaskMemRealloc	= NULL;		//CoTaskMemRealloc()	function pointer.
	m_fnCoTaskMemFree		= NULL;		//CoTaskMemFree()		function pointer.
	DBG(("CImePadSvr::~CImePadSvr END\n"));
}

BOOL
CImePadSvr::InitOleAPI(VOID)
{
	DBG(("CImePadSvr::InitOleAPI START\n"));
	if(!m_hModOLE) {
#ifndef UNDER_CE // For GetModuleHandleW
		m_hModOLE = ::GetModuleHandle(SZMOD_OLE32DLL);
#else // UNDER_CE
		m_hModOLE = ::GetModuleHandleW(WSZMOD_OLE32DLL);
#endif // UNDER_CE
		if(m_hModOLE) {
			DBG(("-->%s is Loaded by Application\n", SZMOD_OLE32DLL));
			m_fOLELoaded = FALSE;
		}
		else {
			m_hModOLE = ::LoadLibrary(SZMOD_OLE32DLL);
			if(m_hModOLE) {
				DBG(("--> %s has Loaded Explicitly", SZMOD_OLE32DLL)); 
				m_fOLELoaded = TRUE;
			}
			else {
				return FALSE;
			}
		}
	}

	m_fnCoInitialize	  = (FN_COINITIALIZE)		GetProcAddress(m_hModOLE, SZFN_COINITIALIZE);
	m_fnCoCreateInstance  = (FN_COCREATEINSTANCE)	::GetProcAddress(m_hModOLE, SZFN_COCREATEINSTANCE);
	m_fnCoUninitialize	  = (FN_COUNINITIALIZE)		::GetProcAddress(m_hModOLE, SZFN_COUNINITIALIZE);
	m_fnCoDisconnectObject= (FN_CODISCONNECTOBJECT)	::GetProcAddress(m_hModOLE, SZFN_CODISCONNECTOBJECT);
	m_fnCoTaskMemAlloc	  = (FN_COTASKMEMALLOC)		::GetProcAddress(m_hModOLE, SZFN_COTASKMEMALLOC);
	m_fnCoTaskMemRealloc  = (FN_COTASKMEMREALLOC)	::GetProcAddress(m_hModOLE, SZFN_COTASKMEMREALLOC);
	m_fnCoTaskMemFree	  = (FN_COTASKMEMFREE)		::GetProcAddress(m_hModOLE, SZFN_COTASKMEMFREE);

	if(!m_fnCoInitialize		||
	   !m_fnCoCreateInstance	||
	   !m_fnCoUninitialize		||
	   !m_fnCoDisconnectObject	||
	   !m_fnCoTaskMemAlloc		||
	   !m_fnCoTaskMemRealloc	||	
	   !m_fnCoTaskMemFree) {
	   
		DBG(("InitOleAPI Failed: GetProcAddress Error\n"));
		return FALSE;
	}
	DBG(("CImePadSvr::InitOleAPI END\n"));
	return TRUE;
}

BOOL
CImePadSvr::TermOleAPI(VOID)
{
	DBG(("CImePadSvr::TermOleAPI START\n"));
	m_fnCoInitialize		= NULL;
	m_fnCoCreateInstance	= NULL;
	m_fnCoUninitialize		= NULL;
	m_fnCoDisconnectObject	= NULL;
	m_fnCoTaskMemAlloc		= NULL;
	m_fnCoTaskMemRealloc	= NULL; 
	m_fnCoTaskMemFree		= NULL;

	if(!m_hModOLE) {
		DBG(("-->TermOleAPI already Terminated?\n"));
		return TRUE;
	}

	if(m_hModOLE && m_fOLELoaded) {
		DBG(("--> FreeLibrary\n"));
		::FreeLibrary(m_hModOLE);
	}
	m_hModOLE    = NULL;
	m_fOLELoaded = FALSE;
	DBG(("CImePadSvr::TermOleAPI END\n"));
	return TRUE;
}

VOID*
CImePadSvr::operator new( size_t size )
{
	LPVOID lp = (LPVOID)MemAlloc(size);
	return lp;
}

VOID
CImePadSvr::operator delete( VOID *lp )
{
	if(lp) {
		MemFree(lp);
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadcbu.h ===
#ifndef __C_IME_PAD_CALLBACK_FOR_UIM_H__
#define __C_IME_PAD_CALLBACK_FOR_UIM_H__
#include "cpadsvu.h"

//----------------------------------------------------------------
//990630:ToshiaK for #1327
//----------------------------------------------------------------
#define WM_USER_UPDATECONTEXT	(WM_USER+400)

class CImePadCallbackUIM;
typedef CImePadCallbackUIM *LPCImePadCallbackUIM;

class CImePadCallbackUIM :public IImePadCallback
{
public:
	HRESULT __stdcall QueryInterface(REFIID riid, void**ppv);
	ULONG   __stdcall AddRef	(void);
	ULONG   __stdcall Release	(void);
	virtual HRESULT STDMETHODCALLTYPE OnStart( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE OnClose( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE OnPing( 
		/* [in] */ DWORD dwParam);
	virtual HRESULT STDMETHODCALLTYPE PassData( 
		/* [in] */ long nSize,
		/* [size_is][in] */ byte __RPC_FAR *pByte,
		/* [out][in] */ DWORD __RPC_FAR *pdwCharID);
	virtual HRESULT STDMETHODCALLTYPE ReceiveData( 
		/* [in] */ DWORD dwCmdID,
		/* [in] */ DWORD dwDataID,
		/* [out] */ long __RPC_FAR *pSize,
		/* [size_is][size_is][out] */ byte __RPC_FAR *__RPC_FAR *ppByte);
public:
	CImePadCallbackUIM(HWND hwndIF, LPCImePadSvrUIM lpCImePadSvrUIM);
	~CImePadCallbackUIM();
	VOID* operator new( size_t size );
	VOID  operator delete( VOID *lp );
private:
	LPCImePadSvrUIM	m_lpCImePadSvrUIM;
	DWORD			m_dwReg;
	HWND			m_hwndIF;
	LONG			m_cRef;			
};

#ifndef		__DEFINE_IMEPAD_IUNKNOWN_DUMMY__
#define		__DEFINE_IMEPAD_IUNKNOWN_DUMMY__
#pragma pack(8)
typedef struct IUnkDummyVtbl
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
		IUnknown __RPC_FAR * This,
		/* [in] */ REFIID riid,
		/* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
		IUnknown __RPC_FAR * This);
	
	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
		IUnknown __RPC_FAR * This);
}IUnkDummyVtbl;

interface IUnkDummy
{
       CONST_VTBL struct IUnkDummyVtbl __RPC_FAR *lpVtbl;
};
#pragma pack()
#endif //__DEFINE_IMEPAD_IUNKNOWN_DUMMY__

extern BOOL IsBadVtblUIM(IUnkDummy *lpIUnk);




#endif //__C_IME_PAD_CALLBACK_FOR_UIM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadcbu.cpp ===
#include <windows.h>
#include <windowsx.h>
#ifdef UNDER_CE // stub for CE
#include "stub_ce.h"
#endif // UNDER_CE
#include "imepadsv.h"
#include "cpadcbu.h"
#include "cpaddbg.h"
#include "ipoint1.h"
#include "iimecb.h"
#include "imepad.h"

#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)

BOOL IsBadVtblUIM(IUnkDummy *lpIUnk)
{
#ifdef _DEBUG
	BOOL fBad = ::IsBadReadPtr(lpIUnk, sizeof(VOID*)) ||
		::IsBadReadPtr(lpIUnk->lpVtbl, sizeof(VOID*)) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->QueryInterface) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->AddRef) ||
		::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->Release);
	if(fBad) {
		DBG(("--> IsBadVtbl HIT HIT HIT\n"));
	}
	return fBad;
#else
	return ::IsBadReadPtr(lpIUnk, sizeof(VOID*)) ||
		   ::IsBadReadPtr(lpIUnk->lpVtbl, sizeof(VOID*)) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->QueryInterface) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->AddRef) ||
		   ::IsBadCodePtr((FARPROC)lpIUnk->lpVtbl->Release);
#endif
}

HRESULT __stdcall
CImePadCallbackUIM::QueryInterface(REFIID riid, void**ppv)
{
	if(riid == IID_IUnknown) {
		*ppv = static_cast<IImePadCallback *>(this);
	}
	else if (riid == IID_IImePadCallback) {
		*ppv = static_cast<IImePadCallback *>(this);
	}
	else {
		return (*ppv = 0), E_NOINTERFACE;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef();
	return S_OK;
}

ULONG __stdcall
CImePadCallbackUIM::AddRef(void)
{
	//DBG(("CImePadCallbackUIM::AddRef Always return 2\n"));
	DBG(("CImePadCallbackUIM::AddRef m_cRef[%d] -> [%d]\n", m_cRef, m_cRef+1));
	return ::InterlockedIncrement(&m_cRef);
}

ULONG __stdcall
CImePadCallbackUIM::Release(void)
{
	//Never call delete in it.
	DBG(("CImePadCallbackUIM::Release (Never Delete) m_cRef[%d] -> [%d]\n", m_cRef, m_cRef-1));
	::InterlockedDecrement(&m_cRef);
	return m_cRef;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadCallbackUIM::OnStart
// Type		:	HRESULT __stdcall
// Purpose	:	
// Args		:	
//			:	DWORD	dwParam	
// Return	:	
// DATE		:	Tue Aug 31 16:49:37 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
HRESULT __stdcall
CImePadCallbackUIM::OnStart(DWORD dwParam)
{
	DBG(("OnClose come dwParam[%d]\n", dwParam));
	IUnknown *lpUnk;
	IImeCallback *lp = NULL;
	if(!m_lpCImePadSvrUIM) {
		DBG(("-->m_lpCImePadSvrUIM is NULL ?\n"));
		return -1;
	}

	lpUnk = m_lpCImePadSvrUIM->GetIUnkIImeCallback();
	if(!lpUnk) {
		DBG(("-->IImeCallback does not set\n"));
		return -1;
	}

	if(IsBadVtblUIM((IUnkDummy*)lpUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}

	lpUnk->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
	if(!lp) {
		DBG(("-->QuertyInterface Failed\n"));
	}
	lp->Notify(IMECBNOTIFY_IMEPADOPENED, 0, 0);
	lp->Release();
	return S_OK;
	Unref(dwParam);
}

HRESULT __stdcall CImePadCallbackUIM::OnClose(DWORD dwParam)
{
	DBG(("OnClose come dwParam[%d]\n", dwParam));
	IUnknown *lpUnk;
	IImeCallback *lp = NULL;
	if(!m_lpCImePadSvrUIM) {
		DBG(("-->m_lpCImePadSvrUIM is NULL ?\n"));
		return -1;
	}
	m_lpCImePadSvrUIM->OnIMEPadClose();

	lpUnk = m_lpCImePadSvrUIM->GetIUnkIImeCallback();
	if(!lpUnk) {
		DBG(("-->IImeCallback does not set\n"));
		return -1;
	}

	if(IsBadVtblUIM((IUnkDummy*)lpUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}

	lpUnk->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
	if(!lp) {
		DBG(("-->QuertyInterface Failed\n"));
	}
	lp->Notify(IMECBNOTIFY_IMEPADCLOSED, 0, 0);
	lp->Release();
	return S_OK;
	Unref(dwParam);
}

HRESULT __stdcall
CImePadCallbackUIM::OnPing(DWORD dwParam)
{
	return S_OK;
	Unref(dwParam);
}

typedef struct tagPADCTRL2IPCTRL {
	DWORD dwImePadCtrl;
	DWORD dwIPointCtrl;
}PADCTL2IPCTRL;

static PADCTL2IPCTRL padCtrl2Ip[]= {
	{ IMEPADCTRL_CONVERTALL,           IPCTRL_CONVERTALL,		      },
	{ IMEPADCTRL_DETERMINALL,          IPCTRL_DETERMINALL,		      },
	{ IMEPADCTRL_DETERMINCHAR,         IPCTRL_DETERMINCHAR,		      },
	{ IMEPADCTRL_CLEARALL,             IPCTRL_CLEARALL,			      },
	{ IMEPADCTRL_CARETSET,             IPCTRL_CARETSET,			      },
	{ IMEPADCTRL_CARETLEFT,            IPCTRL_CARETLEFT,			  },
	{ IMEPADCTRL_CARETRIGHT,           IPCTRL_CARETRIGHT,		      },
	{ IMEPADCTRL_CARETTOP,             IPCTRL_CARETTOP,			      },
	{ IMEPADCTRL_CARETBOTTOM,          IPCTRL_CARETBOTTOM,		      },
	{ IMEPADCTRL_CARETBACKSPACE,       IPCTRL_CARETBACKSPACE,	      },
	{ IMEPADCTRL_CARETDELETE,          IPCTRL_CARETDELETE,		      },
	{ IMEPADCTRL_PHRASEDELETE,         IPCTRL_PHRASEDELETE,		      },
	{ IMEPADCTRL_INSERTSPACE,          IPCTRL_INSERTSPACE,		      },
	{ IMEPADCTRL_INSERTFULLSPACE,      IPCTRL_INSERTFULLSPACE,	      },
	{ IMEPADCTRL_INSERTHALFSPACE,      IPCTRL_INSERTHALFSPACE,	      },
	{ IMEPADCTRL_ONIME,                IPCTRL_ONIME,				  },
	{ IMEPADCTRL_OFFIME,               IPCTRL_OFFIME,			      },
	{ IMEPADCTRL_ONPRECONVERSION,      IPCTRL_PRECONVERSION,		  },
	{ IMEPADCTRL_PHONETICCANDIDATE,    IPCTRL_PHONETICCANDIDATE,	  },
};

HRESULT __stdcall
CImePadCallbackUIM::PassData(long nSize, byte *pByte, DWORD *pdwCharID)
{
	DBG(("CImePadCallbackUIM::PassData START\n"));
	LPIMEDATAHEADER lpImeDataHeader = (LPIMEDATAHEADER)pByte;

	HRESULT hr = S_OK;
	IUnknown *lpIUnk = NULL;
	IImeIPoint1 *lpIImeIPoint = NULL;
	DWORD dwCharID = 0;

	if(!m_lpCImePadSvrUIM) {
		DBG(("m_lpCImePadSvrUIM is NULL Error\n"));
		return E_FAIL;
	}
	lpIUnk = m_lpCImePadSvrUIM->GetIUnkIImeIPoint();
	if(!lpIUnk) {
		DBG(("lpIUnk is NULL\n"));
		return E_FAIL;
	}

	if(IsBadVtblUIM((IUnkDummy*)lpIUnk)) {
		return E_FAIL;
	}

	hr = lpIUnk->QueryInterface(IID_IImeIPoint1, (VOID **)&lpIImeIPoint);
	if(hr != S_OK) {
		DBG(("QuertyInterface Failed\n"));
		return E_FAIL;
	}
	if(!lpIImeIPoint) {
		DBG(("QuertyInterface failed\n"));
		return E_FAIL;
	}
	DBG(("m_hwndIF [0x%08x]\n", m_hwndIF));


	switch(lpImeDataHeader->dwDataID) {
	case IMEDATAID_CONTROL:
		{
			LPIMEDATACONTROL lpImeDataCtrl = (LPIMEDATACONTROL)lpImeDataHeader;
			for(int i = 0; i < sizeof(padCtrl2Ip)/sizeof(padCtrl2Ip[0]); i++) {
				if(lpImeDataCtrl->dwControl == padCtrl2Ip[i].dwImePadCtrl) {
					hr = lpIImeIPoint->ControlIME((WORD)padCtrl2Ip[i].dwIPointCtrl,
												   IPCTRLPARAM_DEFAULT);
					//hr = lpIImeIPoint->UpdateContext(TRUE);
					break;
				}
			}
		}
		break;
	case IMEDATAID_STRING:
		{
			DBG(("--> IMEDATAID_STRING\n"));
			LPIMEDATASTRING lpImeDataStr = (LPIMEDATASTRING)lpImeDataHeader;
			switch(lpImeDataHeader->dwCmdID) {
			case IMECMDID_INSERTSTRING:
				{
					DBG(("--> IMECMDID_INSERTSTRING START\n"));
					LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
					INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
					DBGW((L"lpwstr [%s] len[%d]\n", lpwstr, len));
					BOOL fPreConv = lpImeDataStr->fPreConv;
					//990818:ToshiaK for KOTAE #1775.
					dwCharID = lpImeDataStr->dwCharID;
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
												  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
					hr = lpIImeIPoint->InsertStringEx(lpwstr,
													  len,
													  &dwCharID);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					if(pdwCharID) {
						*pdwCharID = dwCharID;
					}
					fPreConv = 0;
					DBG(("--> IMECMDID_INSERTSTRING END\n"));
				}
				break;
			case IMECMDID_CHANGESTRING:
				{
					DBG(("--> IMECMDID_CHANGESTRING\n"));
					LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
					INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
					dwCharID	  = ((LPIMEDATASTRING)lpImeDataHeader)->dwCharID;
					BOOL fPreConv = lpImeDataStr->fPreConv;
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
												  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
					hr = lpIImeIPoint->ReplaceCompString(lpImeDataStr->dwStartPos,
														 lpImeDataStr->dwDeleteLength,
														 lpwstr,
														 len,
														 &dwCharID);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					//hr = lpIImeIPoint->UpdateContext(TRUE);
					if(pdwCharID) {
						*pdwCharID = dwCharID;
					}
					hr = (HRESULT)dwCharID;
				}
				break;
			case IMECMDID_DELETESTRING:
				{
					DBG(("--> IMECMDID_DELETESTRING\n"));
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME, IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					hr = lpIImeIPoint->DeleteCompString((DWORD)lpImeDataStr->dwStartPos,
														(DWORD)lpImeDataStr->dwDeleteLength);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					//hr = lpIImeIPoint->UpdateContext(TRUE);
				}
				break;
			case IMECMDID_INSERTSTRINGINFO:
			case IMECMDID_CHANGESTRINGINFO:
				{
					DBG(("--> IMECMDID_INSERT(Change)STRINGINFO\n"));
					LPWSTR lpwstr = (LPWSTR)((LPIMEDATASTRING)lpImeDataHeader)->wChar;
					INT len		  = lpwstr ? lstrlenW(lpwstr) : 0;
					dwCharID	  = ((LPIMEDATASTRING)lpImeDataHeader)->dwCharID;
					BOOL fPreConv = lpImeDataStr->fPreConv;
					hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME,	IPCTRLPARAM_DEFAULT);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, 
												  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
					hr = lpIImeIPoint->ReplaceCompString(lpImeDataStr->dwStartPos,
														 lpImeDataStr->dwDeleteLength,
														 lpwstr,
														 len,
														 &dwCharID);
					hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
					if(pdwCharID) {
						*pdwCharID = dwCharID;
					}
					hr = (HRESULT)dwCharID;
				}
				break;
			default:
				break;
				}
		}
		break;
	case IMEDATAID_STRINGCAND:
		{
			DBG(("Data ID is IMEDATAID_STRINGCAND\n"));
			HRESULT hr;
			LPIMEDATASTRINGCAND lpStrCand = (LPIMEDATASTRINGCAND)lpImeDataHeader;
			PIPCANDIDATE lpIpCand;
			INT	textCount, byteCount, i, nSize;
			PBYTE p;
			textCount =  byteCount = 0;
			DBG(("--> dwStringCount %d\n", lpStrCand->dwStringCount));
			for(i = 0; i < (INT)lpStrCand->dwStringCount; i++) {
				DBG(("--> %d offset [%d]\n", i, lpStrCand->dwOffsetString[i]));
				textCount++; 
				LPWSTR lpwstr = (LPWSTR)(((LPBYTE)lpStrCand) +  lpStrCand->dwOffsetString[i]);
				DBGW((L"--> %d %s\n", i, lpwstr));
				byteCount += (lstrlenW(lpwstr)+1) * sizeof(WCHAR);
			}
			if(textCount == 0) {
				return S_OK;
			}
			dwCharID = lpStrCand->dwCharID;
			DWORD dwExInfo = lpStrCand->dwExtraInfoSize;
			nSize = sizeof(IPCANDIDATE) + (textCount-1) * sizeof(DWORD) + byteCount + dwExInfo;
			lpIpCand = (IPCANDIDATE *)MemAlloc(nSize);
			lpIpCand->dwSize		= nSize;
			lpIpCand->dwFlags		= lpStrCand->dwInfoMask;
			lpIpCand->iSelIndex		= lpStrCand->dwSelIndex;
			lpIpCand->nCandidate	= textCount;
			lpIpCand->dwPrivateDataOffset = 0;
			lpIpCand->dwPrivateDataSize	  = 0;
			DBG(("lpIpCand[0x%08x] \n", lpIpCand));
			DBG(("sizeof(IPCANDIDATE) [%d]\n", sizeof(IPCANDIDATE)));
			DBG(("size add [%d]\n", sizeof(DWORD) * (textCount -1)));
			DWORD dwOffset = sizeof(IPCANDIDATE)+sizeof(DWORD)*(textCount-1);
			p = ((PBYTE)lpIpCand) + dwOffset;
			for(i = 0; i < (INT)lpStrCand->dwStringCount; i++) {
				LPWSTR lpwstr = (LPWSTR)(((LPBYTE)lpStrCand) +  lpStrCand->dwOffsetString[i]);
				DWORD dwStrSize = (lstrlenW(lpwstr) + 1) * sizeof(WCHAR);
				CopyMemory((LPWSTR)p, 
						   (WCHAR *)lpwstr,
						   dwStrSize);
				lpIpCand->dwOffset[i] = dwOffset;
				dwOffset += dwStrSize;
				p += dwStrSize;
			}
			if(dwExInfo > 0) {
				lpIpCand->dwPrivateDataSize   = dwExInfo;
#ifdef _WIN64
				lpIpCand->dwPrivateDataOffset = (DWORD)((DWORD_PTR)p - (DWORD_PTR)lpIpCand);
#else
				lpIpCand->dwPrivateDataOffset = (DWORD)p - (DWORD)lpIpCand;
#endif
				CopyMemory(p,
						   (LPBYTE)((LPBYTE)lpStrCand + lpStrCand->dwExtraInfoOffset),
						   lpStrCand->dwExtraInfoSize);
			}
			BOOL fPreConv = lpStrCand->fPreConv;
			hr = lpIImeIPoint->ControlIME(IPCTRL_ONIME, IPCTRLPARAM_DEFAULT);
			hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION,
										  fPreConv ? IPCTRLPARAM_ON : IPCTRLPARAM_OFF);
			//----------------------------------------------------------------

			//990713: need to set Start position for IPoint.
			//----------------------------------------------------------------
			DWORD dwInsertPos; // = IPINS_CURRENT;	//Default.
			DWORD dwLen;		 
			//990823:Toshiak for KOTAE #1779.
			//000825:Satori #2123
			if(lpStrCand->dwStartPos == IMECMDVALUE_DEFAULT_INSERT_POS) {
				dwInsertPos = IPINS_CURRENT; //Set IPoint's value
			}
			else {
				dwInsertPos = lpStrCand->dwStartPos;
			}

			dwLen	= (DWORD)lpStrCand->dwDeleteLength;
			switch(lpStrCand->header.dwCmdID) {
			case IMECMDID_INSERTSTRINGCANDINFO:
				hr = lpIImeIPoint->InsertImeItem(lpIpCand,
												 dwInsertPos,
												 &dwCharID);
				break;
			case IMECMDID_CHANGESTRINGCANDINFO:
				hr = lpIImeIPoint->ReplaceImeItem(dwInsertPos,
												  dwLen,
												  lpIpCand,
												  &dwCharID);
				break;
			default:
				break;
			}
			hr = lpIImeIPoint->ControlIME(IPCTRL_PRECONVERSION, IPCTRLPARAM_ON);
			//hr = lpIImeIPoint->UpdateContext(TRUE);
			MemFree(lpIpCand);
			if(pdwCharID) {
				*pdwCharID = dwCharID;
			}
		}
		break;
	default:
		break;
	}
	//990630:ToshiaK for #1327.
	//In WinWord, if call UpdateContext(TRUE) here,
	//Word does NOT repaint composition string.
	//once return the SendMessageTimeout() procedure,
	//and update context asynchronously.
	//in WM_USER_UPDATECONTEXT's lParam, set IImeIPoint interface pointer.
	//and message procedure, check it with current iimeipoint.
	::PostMessage(m_hwndIF, WM_USER_UPDATECONTEXT, (WPARAM)0, (LPARAM)lpIImeIPoint);
	lpIImeIPoint->Release();
	return hr;
	Unref(nSize);
}


HRESULT STDMETHODCALLTYPE 
CImePadCallbackUIM::ReceiveData( 
	/* [in] */ DWORD dwCmdID,
	/* [in] */ DWORD dwDataID,
	/* [out] */ long __RPC_FAR *pSize,
	/* [size_is][size_is][out] */ byte __RPC_FAR *__RPC_FAR *ppByte)
{
	DBG(("CImePadCallbackUIM::ReceiveData START\n"));
	DBG(("-->dwCmdID  [0x%08x]\n", dwCmdID));
	DBG(("-->dwDataID [0x%08x]\n", dwDataID));
	DBG(("-->pSize    [0x%08x]\n", pSize));
	DBG(("-->ppByte   [0x%08x]\n", ppByte));

	HRESULT hr = S_OK;
	IUnknown *lpIUnk = NULL;
	IImeIPoint1 *lpIImeIPoint = NULL;

	DBG(("-->Check m_lpCImePadSvrUIM\n"));
	if(!m_lpCImePadSvrUIM) {
		DBG(("m_lpCImePadSvrUIM is NULL Error\n"));
		return E_FAIL;
	}
	DBG(("-->Check m_fnCoTaskMemAlloc\n"));
	if(!m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc ||
	   !m_lpCImePadSvrUIM->m_fnCoTaskMemFree) {
		DBG(("--> OLE32.DLL does NOT EXIST ? Error\n"));
		return E_FAIL;
	}
	

	lpIUnk = m_lpCImePadSvrUIM->GetIUnkIImeIPoint();
	DBG(("-->Check lpIUnk [0x%08x]\n", lpIUnk));
	if(!lpIUnk) {
		DBG(("lpIUnk is NULL\n"));
		return E_FAIL;
	}

	DBG(("-->Check lpIUnk IsBadVtblUIM[0x%08x]\n", lpIUnk));
	if(IsBadVtblUIM((IUnkDummy*)lpIUnk)) {
		DBG(("lpIUnk is BAD Pointer \n"));
		return E_FAIL;
	}

	DBG(("-->Call QuertyInterface\n"));
	hr = lpIUnk->QueryInterface(IID_IImeIPoint1, (VOID **)&lpIImeIPoint);
	if(hr != S_OK) {
		DBG(("QuertyInterface Failed\n"));
		return E_FAIL;
	}
	DBG(("--> QueryInterface Success \n"));
	if(!lpIImeIPoint) {
		DBG(("QuertyInterface failed\n"));
		return E_FAIL;
	}

	LPIMEDATACOMPOSITION lpCompoInfo;
	LPIMEDATACOMPOSITION lpCompoTmp;
	LPWSTR lpwstrCompo, lpwstr;
	DWORD  *pdwCharID, *pdw;	
	DWORD  dwSize;
	switch(dwDataID) {
	case IMEDATAID_COMPOSITION:
		switch(dwCmdID) {
		case IMECMDID_GETCOMPOSITIONINFO:
			DBG(("--> IMECMDID_GETCOMPOSITIONINFO\n"));
			dwSize = sizeof(IMEDATACOMPOSITION);
			lpCompoInfo = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpCompoInfo) {
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			hr = lpIImeIPoint->GetAllCompositionInfo(NULL,
													 NULL,
													 (INT *)&lpCompoInfo->dwStringCount,
													 (INT *)&lpCompoInfo->dwCaretPos,
													 (INT *)&lpCompoInfo->dwUndeterminedStartPos,
													 (INT *)&lpCompoInfo->dwUndeterminedLength,
													 (INT *)&lpCompoInfo->dwEditStartPos,
													 (INT *)&lpCompoInfo->dwEditLength);
			lpCompoInfo->header.dwSize  = dwSize;
			lpCompoInfo->header.dwCmdID = dwCmdID;
			lpCompoInfo->header.dwDataID= dwDataID;
			lpCompoInfo->dwOffsetString = 0;
			lpCompoInfo->dwOffsetCharID = 0;
			*pSize = lpCompoInfo->header.dwSize;
			*ppByte = (PBYTE)lpCompoInfo;
			DBG(("--> IMECMDID_GETCOMPOSITIONINFO END\n"));
			break;
		case IMECMDID_GETCOMPOSITIONSTRING:
			DBG(("--> IMECMDID_GETCOMPOSITIONSTRING START\n"));
			lpCompoInfo = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc)(sizeof(IMEDATACOMPOSITION));
			if(!lpCompoInfo) {
				DBG(("-->OutofMemory\n"));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			lpwstrCompo = NULL;
			pdwCharID   = NULL;
			ZeroMemory(lpCompoInfo, sizeof(IMEDATACOMPOSITION));

			hr = lpIImeIPoint->GetAllCompositionInfo(&lpwstrCompo,
													 &pdwCharID,
													 (INT *)&lpCompoInfo->dwStringCount,
													 (INT *)&lpCompoInfo->dwCaretPos,
													 (INT *)&lpCompoInfo->dwUndeterminedStartPos,
													 (INT *)&lpCompoInfo->dwUndeterminedLength,
													 (INT *)&lpCompoInfo->dwEditStartPos,
													 (INT *)&lpCompoInfo->dwEditLength);
			DBG(("-->hr [0x%08x]\n", hr));
			DBGW((L"-->lpwstrCompo[%s]\n", lpwstrCompo));
			dwSize = sizeof(IMEDATACOMPOSITION) +
					 (lpCompoInfo->dwStringCount+1)*sizeof(WCHAR) +
					 (lpCompoInfo->dwStringCount) * sizeof(DWORD);
			DBG(("-->dwSize [%d]\n", dwSize));
			lpCompoTmp = (LPIMEDATACOMPOSITION)(*m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpCompoTmp) {
				DBG(("-->OutofMemory\n"));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			lpCompoTmp->header.dwSize  = dwSize;
			lpCompoTmp->header.dwCmdID = dwCmdID;
			lpCompoTmp->header.dwDataID= dwDataID;
			lpCompoTmp->dwStringCount           = lpCompoInfo->dwStringCount;
			lpCompoTmp->dwCaretPos              = lpCompoInfo->dwCaretPos;
			lpCompoTmp->dwUndeterminedStartPos  = lpCompoInfo->dwUndeterminedStartPos;
			lpCompoTmp->dwUndeterminedLength    = lpCompoInfo->dwUndeterminedLength;
			lpCompoTmp->dwEditStartPos          = lpCompoInfo->dwEditStartPos;
			lpCompoTmp->dwEditLength            = lpCompoInfo->dwEditLength;
			lpCompoTmp->dwOffsetString = (DWORD)sizeof(IMEDATACOMPOSITION);

			lpwstr = (LPWSTR)((PBYTE)lpCompoTmp + lpCompoTmp->dwOffsetString);
			//990928:toshiaK for KOTAE #2273
			//Need to check lpwstrCompo is NULL or not.
			if(lpwstrCompo && lpCompoTmp->dwStringCount > 0) {
				CopyMemory(lpwstr, 
						   (WCHAR *)lpwstrCompo,
						   lpCompoTmp->dwStringCount * sizeof(WCHAR));
			}
			lpwstr[lpCompoTmp->dwStringCount] = (WCHAR)0x0000;

			lpCompoTmp->dwOffsetCharID = (DWORD)(sizeof(IMEDATACOMPOSITION) +
												 (lpCompoTmp->dwStringCount+1)*sizeof(WCHAR));
			//990928:toshiaK for KOTAE #2273
			//Need to check pdwCharID is NULL or not.
			if(pdwCharID && lpCompoTmp->dwStringCount > 0) {
				pdw = (DWORD *)((PBYTE)lpCompoTmp + lpCompoTmp->dwOffsetCharID);
				CopyMemory(pdw, pdwCharID, sizeof(DWORD)*lpCompoTmp->dwStringCount);
			}

			*pSize = lpCompoTmp->header.dwSize;
			*ppByte = (PBYTE)lpCompoTmp;
			(*m_lpCImePadSvrUIM->m_fnCoTaskMemFree)(lpCompoInfo);

			//990928:toshiaK for KOTAE #2273
			if(lpwstrCompo) {
				(*m_lpCImePadSvrUIM->m_fnCoTaskMemFree)(lpwstrCompo);
			}
			//990928:toshiaK for KOTAE #2273
			if(pdwCharID) {
				(*m_lpCImePadSvrUIM->m_fnCoTaskMemFree)(pdwCharID);
			}
			DBG(("--> IMECMDID_GETCOMPOSITIONSTRING END\n"));
			break;
		default:
			break;
		}
		break;
	case IMEDATAID_CONVSTATUS:
		{
			if(dwCmdID != IMECMDID_GETCONVERSIONSTATUS) {
				DBG((" --> INVALID CMDID\n"));
			}
			DBG(("--> IMECMDID_GETCONVERSIONSTATUS\n"));
			dwSize = sizeof(IMEDATACONVSTATUS);
			LPIMEDATACONVSTATUS lpConvStat;
			lpConvStat = (LPIMEDATACONVSTATUS)(*m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpConvStat) {
				DBG(("E_OUTOFMEMORY dwSize [%d]\n", dwSize));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			LPARAM lConv = 0;
			LPARAM lSent = 0;
			hr = lpIImeIPoint->ControlIME((WORD)IPCTRL_GETCONVERSIONMODE,
										  (LPARAM)&lConv);
			
			hr = lpIImeIPoint->ControlIME((WORD)IPCTRL_GETSENTENCENMODE,
										  (LPARAM)&lSent);
			lpConvStat->header.dwSize  = dwSize;
			lpConvStat->header.dwCmdID = IMECMDID_GETCONVERSIONSTATUS;
			lpConvStat->header.dwDataID= IMEDATAID_CONVSTATUS;
			lpConvStat->dwConversionMode = (DWORD)lConv;
			lpConvStat->dwSentenceMode   = (DWORD)lSent;
			DBG((" --> dwConversionMode[0x%8x]\n", lpConvStat->dwConversionMode));
			DBG((" --> dwSentenceMode  [0x%8x]\n", lpConvStat->dwSentenceMode));
			*pSize  = dwSize;
			*ppByte = (PBYTE)lpConvStat;
		}
		break;
	case IMEDATAID_APPINFO:
		//990816:ToshiaK KOTAE Raid #1757
		if(dwCmdID != IMECMDID_GETAPPLHWND) {
			DBG((" --> INVALID CMDID\n"));
			hr = S_FALSE;
		}
		else {
			IImeCallback *lp = NULL;
			IUnknown *lpUnkCB;
			lpUnkCB = m_lpCImePadSvrUIM->GetIUnkIImeCallback();
			if(!lpUnkCB) {
				DBG(("-->IImeCallback does not set\n"));
				lpIImeIPoint->Release();
				return E_FAIL;
			}
			if(IsBadVtblUIM((IUnkDummy*)lpUnkCB)) {
				DBG(("lpIUnk is BAD Pointer \n"));
				lpIImeIPoint->Release();
				return E_FAIL;
			}
			lpUnkCB->QueryInterface(IID_IImeCallback, (LPVOID *)&lp);
			if(!lp) {
				DBG(("-->QuertyInterface Failed\n"));
				lpIImeIPoint->Release();
				return E_FAIL;
			}

			dwSize = sizeof(IMEDATAAPPLINFO);
			LPIMEDATAAPPLINFO lpApplInfo;
			lpApplInfo = (LPIMEDATAAPPLINFO)(*m_lpCImePadSvrUIM->m_fnCoTaskMemAlloc)(dwSize);
			if(!lpApplInfo) {
				DBG(("E_OUTOFMEMORY dwSize [%d]\n", dwSize));
				lpIImeIPoint->Release();
				return E_OUTOFMEMORY;
			}
			lpApplInfo->header.dwSize  = dwSize;
			lpApplInfo->header.dwCmdID = IMECMDID_GETAPPLHWND;
			lpApplInfo->header.dwDataID= IMEDATAID_APPINFO;
			lpApplInfo->hwndApp = NULL;
			lp->GetApplicationHWND(&lpApplInfo->hwndApp);

			if(pSize && ppByte) {
				*pSize  = dwSize;
				*ppByte = (PBYTE)lpApplInfo;
			}
			else {
				(*m_lpCImePadSvrUIM->m_fnCoTaskMemFree)(lpApplInfo);
				hr = E_FAIL;
			}
			lp->Release();
		}
		break;
	default:
		DBG(("UNKOWN DATAID [0x%08x]\n",  dwDataID));
		hr = S_FALSE;
		break;
	}

	lpIImeIPoint->Release();
	DBG(("CImePadCallbackUIM::ReceiveData END hr[0x%08x]\n", hr));
	return hr;
}


//----------------------------------------------------------------

CImePadCallbackUIM::CImePadCallbackUIM(HWND hwndIF, LPCImePadSvrUIM lpCImePadSvrUIM)
{
	DBG(("######## CImePadCallbackUIM::CImePadCallbackUIM constructor START ##########\n"));
	m_hwndIF			= hwndIF;
	m_lpCImePadSvrUIM	= lpCImePadSvrUIM;
	m_cRef				= 0;
	DBG(("######## CImePadCallbackUIM::CImePadCallbackUIM constructor END   ##########\n"));
}

CImePadCallbackUIM::~CImePadCallbackUIM()
{
	DBG(("######## CImePadCallbackUIM::~CImePadCallbackUIM destructor START ##########\n"));
	m_hwndIF			= NULL;
	m_lpCImePadSvrUIM	= NULL;
	DBG(("######## CImePadCallbackUIM::~CImePadCallbackUIM destructor END   ##########\n"));
	m_cRef				= 0;
}

VOID*
CImePadCallbackUIM::operator new( size_t size )
{
	LPVOID lp = (LPVOID)MemAlloc(size);
	return lp;
}

VOID
CImePadCallbackUIM::operator delete( VOID *lp )
{
	if(lp) {
		MemFree(lp);
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadsvrs.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvrs.cpp
// Purpose  :	CImePadServer for Shared Memory version.
// 
// 
// Date     :	Fri Apr 16 15:39:33 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#ifdef UNDER_CE // stub for CE
#include "stub_ce.h"
#endif // UNDER_CE
#include "imepadsv.h"
#include "cpadsvrs.h"
#include "cpadcb.h"
#include "cpaddbg.h"
#include "iimecb.h"
#include "ipoint1.h"

//----------------------------------------------------------------
//misc definition
//----------------------------------------------------------------
#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)

inline LPVOID
WinSetUserPtr(HWND hwnd, LPVOID lpVoid)
{
#ifdef _WIN64	
	return (LPVOID)SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpVoid);
#else
	return (LPVOID)SetWindowLong(hwnd, GWL_USERDATA, (LONG)lpVoid);
#endif
}

inline LPVOID
WinGetUserPtr(HWND hwnd)
{
#ifdef _WIN64	
	return (LPVOID)GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	return (LPVOID)GetWindowLong(hwnd, GWL_USERDATA);
#endif
}

static LPWSTR
StrdupW(LPWSTR lpwstr)
{
	LPWSTR lpwstrRet;
	if(!lpwstr) {
		return NULL;
	}
	INT len = lstrlenW(lpwstr);
	if(len == 0) {
		return NULL;
	}
	lpwstrRet = (LPWSTR)MemAlloc((len+1) * sizeof(WCHAR));
	if(!lpwstrRet) {
		return NULL;
	}
	CopyMemory(lpwstrRet, lpwstr, sizeof(WCHAR)*len);
	lpwstrRet[len] = (WCHAR)0x0000;
	return lpwstrRet;
} 

//----------------------------------------------------------------
//
//public method decalre
//
//----------------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrSharemem::CImePadSvrSharemem
// Type		:	None
// Purpose	:	Constructor of CImePadSvrSharemem class
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:04:01 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvrSharemem::CImePadSvrSharemem(VOID)
{
	DBG(("CImePadSvrSharemem::CImePadSvrSharemem() constructor START\n"));
	m_imeLangID				= 0;		//Save Initialized data.
	m_dwImeInputID			= 0;		//Save Initialized data.
	m_fShowReqStatus		= FALSE;	//Save ShowUI()'s bool value.
	m_fLastActiveCtx		= FALSE;	//Save IMEPADNOTIFY_ACTIVATECONTEXT
	m_hwndIF				= NULL;		//Internal I/F Window handle.
	m_lpIUnkIImeIPoint		= NULL;		//IImeIPoint I/F pointer as IUnknown.
	m_lpIUnkIImeCallback	= NULL;		//IImeCallback I/F pointer as IUnknown.
	m_lpCImePadCallback		= NULL;		//CImePadCallback instance pointer.
	m_lpIImePadServer		= NULL;		//IImePadServer I/F pointer.
	m_dwRegAdvise			= 0;
	m_hModuleProxyStub		= NULL;

	//Initialize Candidate data
	ZeroMemory(&m_ntfyDataApplyCand,	sizeof(m_ntfyDataApplyCand));
	ZeroMemory(&m_ntfyDataQueryCand,	sizeof(m_ntfyDataQueryCand));
	ZeroMemory(&m_ntfyDataApplyCandEx,	sizeof(m_ntfyDataApplyCandEx));

	DBG(("CImePadSvrSharemem::CImePadSvrSharemem() constructor END\n"));
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrSharemem::~CImePadSvrSharemem
// Type		:	INT
// Purpose	:	Destructor of CImePadSvrSharemem Class.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:04:29 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvrSharemem::~CImePadSvrSharemem(VOID)
{
	DBG(("CImePadSvrSharemem::CImePadSvrSharemem() Destructor START\n"));
	this->DestroyIFHWND(TRUE);
	m_imeLangID				= 0;		//Save Initialized data.
	m_dwImeInputID			= 0;		//Save Initialized data.
	m_fShowReqStatus		= FALSE;	//Save ShowUI()'s bool value.
	m_fLastActiveCtx		= FALSE;	//Save IMEPADNOTIFY_ACTIVATECONTEXT
	m_hwndIF				= NULL;		//Internal I/F Window handle.
	m_lpIUnkIImeIPoint		= NULL;		//IImeIPoint I/F pointer as IUnknown.
	m_lpIUnkIImeCallback	= NULL;		//IImeCallback I/F pointer as IUnknown.
	m_lpIImePadServer		= NULL;		//IImePadServer I/F pointer.

	//990813:ToshiaK. Memory leak.
	if(m_lpCImePadCallback) {
		delete m_lpCImePadCallback;
		m_lpCImePadCallback = NULL;
	}	

	if(m_hModuleProxyStub) {
		::FreeLibrary(m_hModuleProxyStub);
		m_hModuleProxyStub = 0;
	}
	DBG(("CImePadSvrSharemem::CImePadSvrSharemem() Destructor END\n"));
}

BOOL
CImePadSvrSharemem::IsAvailable(VOID)
{
	LPTSTR lpPath = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
	if(!lpPath) {
		DBG(("-->Outof Memory ??\n"));
		return FALSE;
	}

	if(0 ==  this->CLSID2ModuleName(IID_IImePadServerSHM,
									FALSE,
									lpPath,
									sizeof(TCHAR)*MAX_PATH)) {
		MemFree(lpPath);
		return TRUE;
	}
	MemFree(lpPath);
	return FALSE;

}

BOOL
CImePadSvrSharemem::OnIMEPadClose(VOID)
{
	m_fShowReqStatus = FALSE;
	return 0;
}

INT
CImePadSvrSharemem::Initialize(LANGID	imeLangID,
							   DWORD	dwImeInputID,
							   LPVOID	lpVoid)
{
	DBG(("CImePadSvrSharemem::Initialize() START\n"));
	DBG(("--> imeLangID   [0x%08x]\n", imeLangID));
	DBG(("--> dwImeInputID[0x%08x]\n", dwImeInputID));
	if(m_lpIImePadServer) {
		DBG(("-->Already Initialized\n"));
		return 0;
	}

	HRESULT hr;
	
	this->CreateIFHWND();	//Create internal Interface Window.
	m_imeLangID		= imeLangID;
	m_dwImeInputID	= dwImeInputID;
	if(!m_lpCImePadCallback) {
		m_lpCImePadCallback = new CImePadCallback(m_hwndIF, this);
	}
	this->InitOleAPI();
	m_lpIImePadServer = (IImePadServer *)this->CreateObject();
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->Initialize(::GetCurrentProcessId(),
								  ::GetCurrentThreadId(),
								  (DWORD)imeLangID,
								  (DWORD)dwImeInputID,
								  FALSE,					//fUIM;
								  m_lpCImePadCallback,
								  NULL,
								  0,
								  0);
	DBG(("CImePadSvrSharemem::Initialize() END\n"));
	return 0;
	Unref(lpVoid);
	Unref(hr);
}

INT
CImePadSvrSharemem::Terminate(LPVOID lpVoid)
{
	DBG(("CImePadSvrSharemem::::Terminate() START \n"));
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->Terminate(0, 0);
	m_lpIImePadServer = NULL;
	//990813:ToshiaK memory leak;
	if(m_lpCImePadCallback) {
		delete m_lpCImePadCallback;
		m_lpCImePadCallback = NULL;
	}
	DBG(("CImePadSvrSharemem::Terminate() End\n"));
	return 0;
	Unref(lpVoid);
}

INT
CImePadSvrSharemem::ForceDisConnect(VOID)
{
	DBG(("CImePadSvrSharemem::ForceDisConnect START\n"));
	if(m_lpIImePadServer) {
		m_lpIImePadServer = NULL;
	}
	DBG(("CImePadSvrSharemem::ForceDisConnect END\n"));
	return 0;
}


INT
CImePadSvrSharemem::ShowUI(BOOL fShow)
{
	DBG(("CImePadSvrSharemem::ShowUI() START fShow [%d]\n"));
	m_fShowReqStatus = fShow;
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->ShowUI(fShow);
	DBG(("CImePadSvrSharemem::ShowUI() END\n"));
	return 0;
}

INT
CImePadSvrSharemem::IsVisible(BOOL *pfVisible)
{
	if(pfVisible) {
		*pfVisible = m_fShowReqStatus;
	}
	return 0;
}

INT
CImePadSvrSharemem::ActivateApplet(UINT activateID,
								   DWORD_PTR dwActivateParam,
								   LPWSTR lpwstr1,
								   LPWSTR lpwstr2)
{
	DBG(("CImePadSvrSharemem::ActivateApplet START\n"));
	DBG(("-->activateID      [0x%08x][%s]\n",
		 activateID,
		 activateID == IMEPADACTID_ACTIVATEBYCATID ? "IMEPADACTID_ACTIVATEBYCATID" :
		 activateID == IMEPADACTID_ACTIVATEBYIID   ? "IMEPADACTID_ACTIVATEBYIID" :
		 activateID == IMEPADACTID_ACTIVATEBYNAME  ? "IMEPADACTID_ACTIVATEBYNAME" : 
		 "Unknown"));
	DBG(("-->dwActivateParam [0x%08x]\n", dwActivateParam));
	DBG(("-->lpwstr1         [0x%08x]\n", lpwstr1));
	DBG(("-->lpwstr2         [0x%08x]\n", lpwstr2));

	if(!m_lpIImePadServer) {
		DBG(("-->m_lpIImePadServer is NULL\n"));
		DBG(("CImePadSvrSharemem::ActivateApplet END\n"));
		return -1;
	}
	m_lpIImePadServer->ActivateApplet(activateID,
									  dwActivateParam,
									  lpwstr1,
									  lpwstr2);
	DBG(("CImePadSvrSharemem::ActivateApplet END\n"));
	return 0;
	Unref(activateID);
	Unref(dwActivateParam);
	Unref(lpwstr1);
	Unref(lpwstr2);
}

INT
CImePadSvrSharemem::Notify(INT id, WPARAM wParam, LPARAM lParam)
{
	HRESULT hr;
	switch(id) {
	case IMEPADNOTIFY_ACTIVATECONTEXT:
		DBG(("CImePadSvrSharemem::Notify: ActivateContext\n"));
		//990608:KOTAE #1121. if ImePad is not shown in this application,
		//Do not send IMEPADNOTIFY_ACTIVATECONTEXT
		if(!m_fShowReqStatus) {
			return 0;
		}
		m_fLastActiveCtx = (BOOL)wParam;
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_ACTIVATECONTEXT);
		if(m_fLastActiveCtx) {
			::SetTimer(m_hwndIF,
					   TIMERID_NOTIFY_ACTIVATECONTEXT,
					   TIMERELAPS_ACTIVATE,
					   NULL);
		}
		else {
			::SetTimer(m_hwndIF,
					   TIMERID_NOTIFY_ACTIVATECONTEXT,
					   TIMERELAPS_INACTIVATE,
					   NULL);
		}
		break;
	case IMEPADNOTIFY_APPLYCANDIDATE:
		//----------------------------------------------------------------
		// Notify for Candidate Applied
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: iSelIndex = (INT)lParam;
		//----------------------------------------------------------------
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATE);
		m_ntfyDataApplyCand.dwCharID   = (DWORD)wParam;
		m_ntfyDataApplyCand.dwSelIndex = (DWORD)lParam;
		::SetTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATE, TIMERELAPS_NOTIFY, NULL);

		break;
	case IMEPADNOTIFY_QUERYCANDIDATE:
		//----------------------------------------------------------------
		// Notify for Querying Candidate
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: 0. not used.
		//----------------------------------------------------------------
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_QUERYCANDIDATE);
		m_ntfyDataQueryCand.dwCharID = (DWORD)wParam;
		::SetTimer(m_hwndIF, TIMERID_NOTIFY_QUERYCANDIDATE, TIMERELAPS_NOTIFY, NULL);
		break;
	case IMEPADNOTIFY_APPLYCANDIDATE_EX:
		//----------------------------------------------------------------
		// Notify for Candidate Applied
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: lpApplyCandEx = (LPIMEPADAPPLYCANDEX)lParam;
		//----------------------------------------------------------------
		{
			::KillTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATEEX);
			m_ntfyDataApplyCandEx.dwCharID = (DWORD)wParam;
			LPIMEPADAPPLYCANDINFO lpApplyCandInfo = (LPIMEPADAPPLYCANDINFO)lParam;

			if(m_ntfyDataApplyCandEx.lpwstrCreated1) {
				MemFree(m_ntfyDataApplyCandEx.lpwstrCreated1);
			}
			if(m_ntfyDataApplyCandEx.lpwstrCreated2) {
				MemFree(m_ntfyDataApplyCandEx.lpwstrCreated2);
			}
			m_ntfyDataApplyCandEx.lpwstrCreated1 = NULL;
			m_ntfyDataApplyCandEx.lpwstrCreated2 = NULL;
			
			if(lpApplyCandInfo) {
				if(lpApplyCandInfo->lpwstrDisplay) {
					m_ntfyDataApplyCandEx.lpwstrCreated1 = StrdupW(lpApplyCandInfo->lpwstrDisplay);
				}
				if(lpApplyCandInfo->lpwstrReading) {
					m_ntfyDataApplyCandEx.lpwstrCreated2 = StrdupW(lpApplyCandInfo->lpwstrReading);
				}
			}
			::SetTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATEEX, TIMERELAPS_NOTIFY, NULL);
		}
		break;
	case IMEPADNOTIFY_MODECHANGED:
		break;
	case IMEPADNOTIFY_STARTCOMPOSITION:
		break;
	case IMEPADNOTIFY_COMPOSITION:
		break;
	case IMEPADNOTIFY_ENDCOMPOSITION:
		break;
	case IMEPADNOTIFY_OPENCANDIDATE:
		break;
	case IMEPADNOTIFY_CLOSECANDIDATE:
		break;
	default:
		break;
	}
	return 0;
	Unref(hr);
	Unref(wParam);
	Unref(lParam);
}

INT
CImePadSvrSharemem::GetAppletConfigList(DWORD dwMask,
										INT *pCountApplet,
										IMEPADAPPLETCONFIG **ppList)
{
	DBG(("CImePadSvrSharemem::GetAppletConfigList START\n"));
	if(!m_lpIImePadServer) {
		DBG(("-->m_lpIImePadServer is NULL\n"));
		return -1;
	}
	HRESULT hr;
	hr = m_lpIImePadServer->GetAppletConfigList(dwMask,
												(UINT *)pCountApplet,
												ppList);
	DBG(("CImePadSvrSharemem::GetAppletConfigList END\n"));
	return hr;
}

IUnknown *
CImePadSvrSharemem::SetIUnkIImeIPoint(IUnknown *pIUnkIImeIPoint)
{
	return m_lpIUnkIImeIPoint = pIUnkIImeIPoint;
}

IUnknown *
CImePadSvrSharemem::SetIUnkIImeCallback(IUnknown *pIUnkIImeCallback)
{
	return m_lpIUnkIImeCallback = pIUnkIImeCallback;
}

IUnknown*
CImePadSvrSharemem::GetIUnkIImeIPoint(VOID)
{
	return m_lpIUnkIImeIPoint;
}

IUnknown*
CImePadSvrSharemem::GetIUnkIImeCallback(VOID)
{
	return m_lpIUnkIImeCallback;
}


//----------------------------------------------------------------
//
//private static method
//
//----------------------------------------------------------------

IImePadServer*
CImePadSvrSharemem::CreateObject(VOID)
{
	DBG(("CImePadSvrSharemem::CreateObject START\n"));
	typedef LPVOID (WINAPI * LPFN_CREATEOBJECT)(DWORD dwIntanceID);
	if(m_hModuleProxyStub) {
		DBG(("-->Already Created\n"));
		return m_lpIImePadServer;
	}

	LPTSTR lpPath = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
	if(!lpPath) {
		DBG(("-->Outof Memory ??\n"));
		return NULL;
	}

	if(0 !=  this->CLSID2ModuleName(IID_IImePadServerSHM,
									FALSE,
									lpPath,
									sizeof(TCHAR)*MAX_PATH)) {
		DBG(("-->Cannot found proxy\n"));
		goto LError;
	}
	m_hModuleProxyStub= ::LoadLibrary(lpPath);
	DBG(("-->lpPath [%s]\n", lpPath));
#if 0
#ifdef _DEBUG		
	m_hModuleProxyStub = ::LoadLibrary(TEXT("dbgpadsm.dll"));
#else
	m_hModuleProxyStub = ::LoadLibrary(TEXT("imepadsm.dll"));
#endif
#endif
	if(!m_hModuleProxyStub) {
		goto LError;
	}

	LPFN_CREATEOBJECT lpfn;
	lpfn = (LPFN_CREATEOBJECT)::GetProcAddress(m_hModuleProxyStub, "CreateObject");
	if(!lpfn) {
		DBG(("-->GetProcAddress Error \n"));
		goto LError;
	}
	m_lpIImePadServer = (IImePadServer *)(*lpfn)(0);
	return m_lpIImePadServer;

 LError:
	if(lpPath) {
		MemFree(lpPath);
	}
	return NULL;
} 

LRESULT CALLBACK
CImePadSvrSharemem::ClientWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPCImePadSvrSharemem lpCImePadSvr = NULL;
	switch(uMsg) {
#ifdef UNDER_CE
	case WM_CREATE:
		lpCImePadSvr = (LPCImePadSvrSharemem)((LPCREATESTRUCT)lParam)->lpCreateParams;
		WinSetUserPtr(hwnd, (LPVOID)lpCImePadSvr);
		if(lpCImePadSvr) {
			return lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	case WM_DESTROY:
		lpCImePadSvr = (LPCImePadSvrSharemem)WinGetUserPtr(hwnd);
		if(lpCImePadSvr) {
			lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		WinSetUserPtr(hwnd, (LPVOID)NULL);
		break;
#else //!UNDER_CE
	case WM_NCCREATE:
		lpCImePadSvr = (LPCImePadSvrSharemem)((LPCREATESTRUCT)lParam)->lpCreateParams;
		WinSetUserPtr(hwnd, (LPVOID)lpCImePadSvr);
		break;
	case WM_NCDESTROY:
		WinSetUserPtr(hwnd, (LPVOID)NULL);
		break;
#endif //UNDER_CE
	default:
		lpCImePadSvr = (LPCImePadSvrSharemem)WinGetUserPtr(hwnd);
		if(lpCImePadSvr) {
			return lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT
CImePadSvrSharemem::RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg) {
	case WM_CREATE:
		DBG(("CImePadSvrSharemem::WM_CREATE\n"));
		return 1;
	case WM_TIMER:
		return MsgTimer(hwnd, wParam, lParam);
	case WM_USER_UPDATECONTEXT:
		{
			IImeIPoint1 *lpIImeIPoint = NULL;
			if(!m_lpIUnkIImeIPoint) {
				DBG(("--> m_lpIUnkIImeIPoint is NULL\n"));
				return E_FAIL;
			}
			if(IsBadVtbl((IUnkDummy *)m_lpIUnkIImeIPoint)) {
				return E_FAIL;
			}

			HRESULT hr = m_lpIUnkIImeIPoint->QueryInterface(IID_IImeIPoint1,
															(VOID **)&lpIImeIPoint);
			if(hr != S_OK) {
				DBG(("QuertyInterface Failed\n"));
				return E_FAIL;
			}
			if(!lpIImeIPoint) {
				DBG(("lpIImeIPoint is NULL\n"));
				return 0;
			}
			//Check current IImeIPoint is same with lParam's IImeIPoint.
			//990715:Fixed KOTAE #1563. 
			//In 16bit application wParam's HIWORD is always 0x0000 !!!!!
			//So, Use LParam.
			if((IImeIPoint1 *)lParam == lpIImeIPoint) {
				DBG(("Call UpdateContext\n"));
				lpIImeIPoint->UpdateContext(TRUE);
			}
			else {
				DBG(("lpIImeIPoint is different lParam[0x%08x]\n", lParam));
			}
			lpIImeIPoint->Release();
		}
		break;
	default:
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT
CImePadSvrSharemem::MsgTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	HRESULT hr;
	switch(wParam) {
	case TIMERID_NOTIFY_ACTIVATECONTEXT:
		::KillTimer(hwnd, wParam);
		if(!m_lpIImePadServer) {
			return -1;
		}
		m_lpIImePadServer->Notify(IMEPADNOTIFY_ACTIVATECONTEXT,
								  (WPARAM)m_fLastActiveCtx,
								  (LPARAM)0);
		break;
	case TIMERID_NOTIFY_APPLYCANDIDATE:
		::KillTimer(hwnd, wParam);
		if(!m_lpIImePadServer) {
			return -1;
		}
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_APPLYCANDIDATE,
										  m_ntfyDataApplyCand.dwCharID,
										  0,
										  0,
										  0);
		m_ntfyDataApplyCand.dwCharID = 0;
		break;
	case TIMERID_NOTIFY_QUERYCANDIDATE:
		::KillTimer(hwnd, wParam);
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_QUERYCANDIDATE,
										  m_ntfyDataQueryCand.dwCharID,
										  m_ntfyDataQueryCand.dwSelIndex,
										  0,
										  0);
		m_ntfyDataQueryCand.dwCharID   = 0;
		m_ntfyDataQueryCand.dwSelIndex = 0;
		break;
	case TIMERID_NOTIFY_APPLYCANDIDATEEX:
		::KillTimer(hwnd, wParam);
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_APPLYCANDIDATE_EX,
										  m_ntfyDataApplyCandEx.dwCharID,
										  0,
										  m_ntfyDataApplyCandEx.lpwstrCreated1,
										  m_ntfyDataApplyCandEx.lpwstrCreated2);
		if(m_ntfyDataApplyCandEx.lpwstrCreated1) {
			MemFree(m_ntfyDataApplyCandEx.lpwstrCreated1);
		}
		if(m_ntfyDataApplyCandEx.lpwstrCreated2) {
			MemFree(m_ntfyDataApplyCandEx.lpwstrCreated2);
		}
		m_ntfyDataApplyCandEx.lpwstrCreated1 = NULL;
		m_ntfyDataApplyCandEx.lpwstrCreated2 = NULL;

		break;
	default:
		::KillTimer(hwnd, wParam);
		break;
	}
	return 0;
	Unref(hr);
	Unref(hwnd);
	Unref(wParam);
	Unref(lParam);
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrSharemem::CreateIFHWND
// Type		:	HWND
// Purpose	:	Create interface size 0 window.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:01:19 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
HWND
CImePadSvrSharemem::CreateIFHWND(VOID)
{
	DBG(("CImePadSvrSharemem::CreateIFHWND START\n"));
	if(m_hwndIF && ::IsWindow(m_hwndIF)) {
		return m_hwndIF;
	}
	ATOM atom;
	HWND hwnd;

#ifndef UNDER_CE // No Ex
	WNDCLASSEX wc;
#else // UNDER_CE
	WNDCLASS wc;
#endif // UNDER_CE

#ifndef UNDER_CE // No Ex
	wc.cbSize = sizeof(wc);
#endif // UNDER_CE
	wc.style			= 0;
	wc.lpfnWndProc		= (WNDPROC)CImePadSvrSharemem::ClientWndProc;
	wc.cbClsExtra		= 0;
	wc.cbWndExtra		= 0; 
	wc.hInstance		= m_ghModClient;
	wc.hIcon			= (HICON)NULL;
	wc.hCursor			= (HCURSOR)NULL; 
	wc.hbrBackground	= (HBRUSH)NULL;
	wc.lpszMenuName		= NULL;
	wc.lpszClassName	= SZ_IMEPADIFCLASS;
#ifndef UNDER_CE // No Ex
	wc.hIconSm			= NULL;

	atom = ::RegisterClassEx(&wc);
#else // UNDER_CE
	atom = ::RegisterClass(&wc);
#endif // UNDER_CE
	hwnd = ::CreateWindowEx(0,
							SZ_IMEPADIFCLASS,
							NULL,
							WS_POPUP | WS_DISABLED,
							0,0,0,0,
							NULL,
							NULL,
							m_ghModClient,
							(LPVOID)this);
	if(!hwnd) {
		DBG(("CreateWindowEx Error %d\n", GetLastError()));
	}
	m_hwndIF = hwnd;
	DBG(("CImePadSvrSharemem::CreateIFHWND END\n"));
	return hwnd;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrSharemem::DestroyIFHWND
// Type		:	BOOL
// Purpose	:	Destroy interface window.
// Args		:	
//			:	BOOL	fReserved	
// Return	:	
// DATE		:	Mon May 17 23:02:43 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvrSharemem::DestroyIFHWND(BOOL fReserved)
{
	DBG(("CImePadSvrSharemem::DestroyIFHWND() START\n"));
	if(m_hwndIF && ::IsWindow(m_hwndIF)) {
		::DestroyWindow(m_hwndIF);
		m_hwndIF = NULL;
	}
	//Must Unregister class. 
	BOOL fRet = ::UnregisterClass(SZ_IMEPADIFCLASS, m_ghModClient);
	if(!fRet) {
		if(::GetLastError() != ERROR_CLASS_DOES_NOT_EXIST) {
			DBG(("UnregisterClass Unknown error [%d]\n", GetLastError()));
		}
	}
	DBG(("CImePadSvrSharemem::DestroyIFHWND() END\n"));
	return TRUE;
	Unref(fReserved);
}

INT
CImePadSvrSharemem::CLSID2Str(REFCLSID refclsid, TCHAR *szBuf)
{
	wsprintf(szBuf, TEXT("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), 
			 refclsid.Data1,
			 refclsid.Data2,
			 refclsid.Data3,
			 refclsid.Data4[0],
			 refclsid.Data4[1],
			 refclsid.Data4[2],
			 refclsid.Data4[3],
			 refclsid.Data4[4],
			 refclsid.Data4[5],
			 refclsid.Data4[6],
			 refclsid.Data4[7]);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CLSID2ModuleName
// Type     : INT
// Purpose  : Get module path from CLSID. only gets InprocServer32
//			: Path.
// Args     : 
//          : REFCLSID refclsid 
//			: BOOL fLocalSvr;
//          : TCHAR szPath 
//          : INT cbSize 
// Return   : 
// DATE     : Thu Apr 16 02:48:05 1998
// Author   : 
//////////////////////////////////////////////////////////////////
#define MAX_CLSIDNAME 64
INT
CImePadSvrSharemem::CLSID2ModuleName(REFCLSID refclsid, BOOL fLocalSvr, TCHAR *szPath, INT cbSize)
{
	//DBG(("CImePadSvrSharemem::CLSID2ModuleName START\n"));
	static TCHAR szCLSID[MAX_CLSIDNAME];
	static TCHAR szServerKey[256];

	CLSID2Str(refclsid, szCLSID);
	DBG(("-->szCLSID [%s]\n", szCLSID));

	if(fLocalSvr) {
		wsprintf(szServerKey, TEXT("CLSID\\%s\\LocalServer32"), szCLSID);
	}
	else {
		wsprintf(szServerKey, TEXT("CLSID\\%s\\InprocServer32"), szCLSID);
	}

	DBG(("-->szServerKey[%s]\n", szServerKey));
	INT ret;
	HKEY hKey;
	ret = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
						 szServerKey,
						 0, 
						 KEY_READ, //ALL_ACCESS,
						 &hKey);
	if(ret != ERROR_SUCCESS) {
		DBG(("-->RegOpenKeyEx Failed ret=[0x%08x], GLE [0x%08x]\n", ret, GetLastError()));
		return ret;
	}
	ULONG size = cbSize;
	ret = ::RegQueryValueEx(hKey,
							NULL,
							NULL,
							NULL,
							(LPBYTE)szPath, &size);
	if(ret != ERROR_SUCCESS) {
		DBG(("-->RegQueryValueEx Failed\n", ret));
		::RegCloseKey(hKey);
		return ret;
	}
	::RegCloseKey(hKey);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadsvrs.h ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvrs.h
// Purpose  :	
// 
// Date     :	Fri Apr 16 14:34:49 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_IMEPAD_SERVER_SHARE_MEM_H__
#define __C_IMEPAD_SERVER_SHARE_MEM_H__
#include "cpadsvr.h"

class CImePadSvrSharemem;
typedef CImePadSvrSharemem *LPCImePadSvrSharemem;

//----------------------------------------------------------------
//Async notify data.
//----------------------------------------------------------------
typedef struct tagIMEPADNOTIFYDATA {
	DWORD	dwCharID;
	DWORD	dwSelIndex;
	LPWSTR	lpwstrCreated1;
	LPWSTR	lpwstrCreated2;
}IMEPADNOTIFYDATA, LPIMEPADNOTIFYDATA;

interface IImePadServer;
class CImePadSvrSharemem:public CImePadSvr
{
public:
	CImePadSvrSharemem(VOID);
	~CImePadSvrSharemem(VOID);
	virtual BOOL		IsAvailable			(VOID);
	virtual BOOL		OnIMEPadClose		(VOID);
	virtual INT			Initialize			(LANGID	imeLangID, DWORD dwImeInputID, LPVOID lpVoid);
	virtual	INT			Terminate			(LPVOID lpVoid);
	virtual INT			ForceDisConnect		(VOID);
	virtual	INT			ShowUI				(BOOL fShow);
	virtual	INT			IsVisible			(BOOL *pfVisible);
	virtual	INT			ActivateApplet		(UINT activateID,
											 DWORD_PTR	dwActParam,
											 LPWSTR lpwstr1,
											 LPWSTR lpwstr2);
	virtual	INT			Notify				(INT id, WPARAM wParam, LPARAM lParam);
	virtual INT			GetAppletConfigList	(DWORD	dwMask,
											 INT*	pCountApplet,
											 IMEPADAPPLETCONFIG **ppList);
	virtual IUnknown*	SetIUnkIImeIPoint	(IUnknown *pIUnk);
	virtual IUnknown*	SetIUnkIImeCallback	(IUnknown *pIUnk);
	virtual IUnknown*	GetIUnkIImeIPoint	(VOID);
	virtual IUnknown*	GetIUnkIImeCallback	(VOID);
private:
	//----------------------------------------------------------------
	//private methods.
	//----------------------------------------------------------------
	IImePadServer *			CreateObject(VOID);
	static LRESULT CALLBACK ClientWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT MsgTimer   (HWND hwnd, WPARAM wParam, LPARAM lParam);
	HWND	CreateIFHWND	(VOID);
	BOOL	DestroyIFHWND	(BOOL fReserved);
	INT		CLSID2Str		(REFCLSID refclsid, TCHAR *szBuf);
	INT		CLSID2ModuleName(REFCLSID refclsid,
							 BOOL fLocalSvr,
							 TCHAR *szPath,
							 INT cbSize);

	//----------------------------------------------------------------
	//private member
	//----------------------------------------------------------------
	LANGID					m_imeLangID;			//Save Initialized data.
	DWORD					m_dwImeInputID;			//Save Initialized data.
	BOOL					m_fShowReqStatus;		//Save ShowUI()'s bool value.
	BOOL					m_fLastActiveCtx;		//Save IMEPADNOTIFY_ACTIVATECONTEXT
	HWND					m_hwndIF;				//Internal I/F Window handle.
	IUnknown*				m_lpIUnkIImeIPoint;		//IImeIPoint I/F pointer as IUnknown.
	IUnknown*				m_lpIUnkIImeCallback;	//IImeCallback I/F pointer as IUnknown.
	IImePadServer*			m_lpIImePadServer;		//IImePadServer I/F pointer.
	LPCImePadCallback		m_lpCImePadCallback;	//CImePadCallback instance pointer.
	DWORD					m_dwRegAdvise;			//Callbacck interface connect cookie.
	HMODULE					m_hModuleProxyStub;		//ProxyStub dll instance handle.
	DWORD					m_dwTLSIndexForProxyStub;
	IMEPADNOTIFYDATA		m_ntfyDataApplyCand;	//for IMEPADNOTIFY_APPLYCAND	
	IMEPADNOTIFYDATA		m_ntfyDataQueryCand;	//for IMEPADNOTIFY_QUERYCAND
	IMEPADNOTIFYDATA		m_ntfyDataApplyCandEx;	//for IMEPADNOTIFY_APPLYCANDEX
};
#endif //__C_IMEPAD_SERVER_SHARE_MEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpaddbg.h ===
//////////////////////////////////////////////////////////////////
// File     : cpaddbg.h
// Purpose  : MACRO definition for showing debug message
// 
// 
// Copyright(c) 1991-1997, Microsoft Corp. All rights reserved
//
//////////////////////////////////////////////////////////////////
#ifndef __C_PAD_DBG_H_
#define __C_PAD_DBG_H_

#ifdef __cplusplus
#   define InlineFunc  inline
#else 
#   define InlineFunc  __inline
#endif

//----------------------------------------------------------------
// Callback function prototype
//----------------------------------------------------------------
typedef VOID (WINAPI *LPFNDBGCALLBACKA)(LPSTR  lpstr);
typedef VOID (WINAPI *LPFNDBGCALLBACKW)(LPWSTR lpwstr);

//-------------------------------------------------------
//MACRO function  prototype declare.
//It is valid only if compliled with _DEBUG definition.
//-------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function : DBGSetCallback
// Type     : VOID
// Purpose  : Set debug callback function.
//            callback function has set, when DBG() has called,
//            call this callback function with formatted message string.
// Args     : 
//          : LPFNDBGCALLBACKA lpfnDbgCallbackA 
//          : LPFNDBGCALLBACKW lpfnDbgCallbackW 
// Return   : VOID
// DATE     : Tue Jan 06 12:21:05 1998
//////////////////////////////////////////////////////////////////
//VOID DBGSetCallback(LPFNDBGCALLBACKA lpfnDbgCallbackA, LPFNDBGCALLBACKW lpfnDbgCallbackW);

//////////////////////////////////////////////////////////////////
// Function : DBGEnableOutput
// Type     : VOID
// Purpose  : On off OutputDebugString to COM.
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:33:21 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//VOID DBGEnableOutput(BOOL fEnable)

//////////////////////////////////////////////////////////////////
// Function : DBGIsOutputEnable
// Type     : BOOL
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 17:58:28 1998
// Author   : 
//////////////////////////////////////////////////////////////////
//BOOL DBGIsOutputEnable(VOID)


////////////////////////////////////////////////////////
// Function : DBG
// Type     : VOID
// Purpose  : Printing ANSI debug message with same usage as printf()
// Args     : 
//          : LPSTR lpstrFuncName 
//          : ...   
// Example  : DBGW(("Error occured data[%d]", i));
// CAUTION  : Must use DOUBLE Blaket to remove in Release version!!!
/////////////////////////////////////////////////////////
//VOID DBG((LPSTR lpstrFuncName, ...));


////////////////////////////////////////////////////////
// Function: DBGW
// Type    : VOID
// Purpose : Printing Unicode debug message with same usage as printf()
// Args    : 
//         : LPWSTR lpstrFuncName 
//         : ...    
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example  : DBGW(("Error occured data[%d]", i));
/////////////////////////////////////////////////////////
//VOID DBGW((LPWSTR lpstrFuncName, ...));

//////////////////////////////////////////////////////////////////
// Function : DBGMsgBox
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// CAUTION  : Shold use DOUBLE Blaket!!!
// Example  : DBGMsgBox(("Error occured data[%d]", i));
//////////////////////////////////////////////////////////////////
//VOID DBGMsgBox((LPSTR lpstrFmt, ...))

//////////////////////////////////////////////////////////////////
// Function : DBGAssert
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fError
// Return   : 
// DATE     : Fri Jan 09 17:17:31 1998
//////////////////////////////////////////////////////////////////
//VOID DBGAssert(BOOL fError)


//////////////////////////////////////////////////////////////////
// Function : DBGSTR
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr
//////////////////////////////////////////////////////////////////
//VOID DBGSTR(LPSTR lpstr);


//////////////////////////////////////////////////////////////////
// Function : DBGGetErrorString
// Type     : VOID
// Purpose  : Get error message from WIN32 Error code.
// Args     : 
//          : INT errorCode 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetErrorString(INT errorCode)


//////////////////////////////////////////////////////////////////
// Function : DBGGetWinClass
// Type     : LPSTR
// Purpose  : Get class name string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinClass(HWND hwnd)

//////////////////////////////////////////////////////////////////
// Function : DBGGetWinText
// Type     : LPSTR
// Purpose  : Get title text string from specified window.
// Args     : 
//          : HWND hwnd 
//////////////////////////////////////////////////////////////////
//LPSTR DBGGetWinText(HWND hwnd)



#ifdef _DEBUG
//----------------------------------------------------------------
//Function prototype declare
//----------------------------------------------------------------
extern VOID   _padDbgEnableOutput   (BOOL fEnable);
extern BOOL   _padDbgIsOutputEnable (VOID);
extern VOID   _padDbgSetCallback        (LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW);
extern VOID   _padDbgA              (LPSTR  lpstrFile, INT lineNo, LPSTR  lpstrMsg);
extern VOID   _padDbgW              (LPWSTR lpstrFile, INT lineNo, LPWSTR lpstrMsg);
extern VOID   _padDbgMsgBoxA            (LPSTR  lpstrFile,  INT lineNo, LPSTR lpstrMsg);
extern VOID   _padDbgAssert         (LPSTR  lpstrFile,  INT lineNo, BOOL fError, LPSTR lpstrMsg);
extern VOID   _padDbgPrintfA            (LPSTR  lpstrFmt, ...);
extern VOID   _padDbgPrintfW            (LPWSTR lpstrFmt, ...);
extern VOID   _padDbgOutStrA            (LPSTR  lpstr);
extern VOID   _padDbgOutStrW            (LPWSTR lpwstr);
extern LPSTR  _padDbgVaStrA         (LPSTR  lpstrFmt, ...);
extern LPWSTR _padDbgVaStrW         (LPWSTR lpstrFmt, ...);
extern LPWSTR _padDbgMulti2Wide     (LPSTR  lpstr);
extern LPSTR  _padDbgGetWinClass        (HWND   hwnd);
extern LPSTR  _padDbgGetWinText     (HWND   hwnd);
extern LPSTR  _padDbgGetErrorString (INT    errorCode);
extern LPSTR  _padDbgGetVkStr       (INT    virtKey);
extern INT    _padDbgShowError      (HRESULT hr, LPSTR lpstrFunc);
//----------------------------------------------------------------
// Macro definition
//----------------------------------------------------------------
#   define DBGSetCallback(a,b)  _padDbgSetCallback(a, b)
#   define DBGEnableOutput(a)   _padDbgEnableOutput(a)
#   define DBGIsOutputEnable()  _padDbgIsOutputEnable()
#   undef DBG
#   define DBG(a)               _padDbgA(__FILE__, __LINE__, _padDbgVaStrA a)
#   define DBGA(a)              _padDbgA(__FILE__, __LINE__, _padDbgVaStrA a)
#   define DBGW(a)              _padDbgW( _padDbgMulti2Wide(__FILE__), __LINE__, _padDbgVaStrW a)
#   define DBGMsgBox(a)         _padDbgMsgBoxA(__FILE__, __LINE__, _padDbgVaStrA a)
#   define DBGAssert(a)         _padDbgAssert(__FILE__, __LINE__, a, #a)
#   define DBGAssertSz(a,b)     _padDbgAssert(__FILE__, __LINE__, a, b)
#   define DBGOutStr(a)         _padDbgOutStrA(a)
#   define DBGOutStrA(a)        _padDbgOutStrA(a)
#   define DBGOutStrW(a)        _padDbgOutStrW(a)
#   define DBGP(a)              _padDbgOutStrA(_padDbgVaStrA a)
#   define DBGPA(a)             _padDbgOutStrA(_padDbgVaStrA a)
#   define DBGPW(a)             _padDbgOutStrW(_padDbgVaStrW a)
#   define DBGGetErrorString(a) _padDbgGetErrorString(a)
#   define DBGGetWinClass(a)    _padDbgGetWinClass(a)
#   define DBGGetWinText(a)     _padDbgGetWinText(a)
#   define DBGShowError(a,b)    _padDbgShowError(a,b)
#else //!_DEBUG //in Release version, these will disapear...
#   define DBGSetCallback(a,b)
#   define DBGEnableOutput(a)
#   define DBGIsOutputEnable()
#   undef DBG
#   define DBG(a)
#   define DBGW(a)
#   define DBGA(a)
#   define DBGP(a)
#   define DBGPA(a)
#   define DBGPW(a)
#   define DBGAssert(a)
#   define DBGAssertSz(a,b)
#   define DBGMsgBox(a)
#   define DBGOutStr(a)
#   define DBGOutStrA(a)
#   define DBGOutStrW(a)
#   define DBGGetErrorString(a)
#   define DBGGetWinClass(a)
#   define DBGGetWinText(a)
#   define DBGShowError(a,b)
#endif //_DEBUG


//----------------------------------------------------------------
//These function use variable argument, so we cannot define 
//"Normal" MACRO for them.
//so, Use inline function that do nothing if _DEBUG is NOT set.
//----------------------------------------------------------------
InlineFunc VOID DBGDoNothingA(LPSTR  lpstrFmt, ...) {lpstrFmt;}
InlineFunc VOID DBGDoNothingW(LPWSTR lpstrFmt, ...) {lpstrFmt;}
#ifdef _DEBUG 
#define DBGPrintf       _padDbgPrintfA
#define DBGPrintfA      _padDbgPrintfA
#define DBGPrintfW      _padDbgPrintfW
#else 
#define DBGPrintf       DBGDoNothingA
#define DBGPrintfA      DBGDoNothingA
#define DBGPrintfW      DBGDoNothingW
#endif


//----------------------------------------------------------------
//This is helper inline function for outputs debug string in 
//Retail version. if FORCE_DEBUG is defined this function works.
//Some time, we met bugs than occurs only retail version, 
//and would like to out debug message. 
//----------------------------------------------------------------
#ifdef FORCE_DEBUG
#include <stdarg.h>
//////////////////////////////////////////////////////////////////
// Function : FDbg
// Type     : InlineFunc VOID
// Purpose  : 
// Args     : 
//          : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Tue Jan 06 19:06:19 1998
//////////////////////////////////////////////////////////////////
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...)
{
    CHAR szBuf[512];
    va_list ap;
    va_start(ap, lpstrFmt);
    wvsprintfA(szBuf, lpstrFmt, ap);
    va_end(ap);
    OutputDebugStringA(szBuf);  
    return;
}
#else //FORCE_DEBUG
InlineFunc VOID FDbg(LPSTR lpstrFmt, ...) {lpstrFmt;}
#endif

#endif //_C_PAD_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcimm\cpadsvr.h ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvr.h
// Purpose  :	Class for Client that uses IMEPad.
//				This is Super(Abstract) class.
//				
// 
// Date     :	Fri Apr 16 14:34:49 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_IMEPAD_SERVER_H__
#define __C_IMEPAD_SERVER_H__
#include "imepadsv.h"

//----------------------------------------------------------------
//Select protocol in LoadCImePadSvr();
//----------------------------------------------------------------
#define CIMEPADSVR_COM				0x0010
#define CIMEPADSVR_SHAREDMEM		0x0020
#define SZ_IMEPADIFCLASS			TEXT("msimepad9IFClass")
//----------------------------------------------------------------
//TIMER id definition
//----------------------------------------------------------------
#define TIMERID_NOTIFY_ACTIVATECONTEXT	0x0010
#define TIMERID_NOTIFY_APPLYCANDIDATE	0x0011
#define TIMERID_NOTIFY_QUERYCANDIDATE	0x0012
#define TIMERID_NOTIFY_APPLYCANDIDATEEX	0x0013
#define TIMERELAPS_ACTIVATE				200		//milisec
#define TIMERELAPS_INACTIVATE			100
#define TIMERELAPS_NOTIFY				200

//----------------------------------------------------------------
//Forward declare
//----------------------------------------------------------------
class CImePadCallback;
typedef CImePadCallback *LPCImePadCallback;
class CImePadSvr;
typedef CImePadSvr*	LPCImePadSvr;

//----------------------------------------------------------------
//OLE API func's pointer declare
//----------------------------------------------------------------
typedef HRESULT (WINAPI* FN_COINITIALIZE)(LPVOID pvReserved);
typedef HRESULT (WINAPI* FN_COCREATEINSTANCE)(REFCLSID rclsid,
											  LPUNKNOWN pUnkOuter,
											  DWORD dwClsContext,
											  REFIID riid,
											  LPVOID FAR* ppv);
typedef void    (WINAPI* FN_COUNINITIALIZE)(void);
typedef HRESULT (WINAPI* FN_CODISCONNECTOBJECT)(LPUNKNOWN pUnk, DWORD dwReserved);
typedef LPVOID  (WINAPI* FN_COTASKMEMALLOC)(ULONG cb);
typedef LPVOID  (WINAPI* FN_COTASKMEMREALLOC)(LPVOID pv, ULONG cb);
typedef VOID    (WINAPI* FN_COTASKMEMFREE)(LPVOID pv);


class CImePadSvr
{
public:
	//----------------------------------------------------------------
	//Static method declare
	//----------------------------------------------------------------
	static BOOL OnProcessAttach(HINSTANCE hInst);
	static BOOL OnProcessDetach(VOID);
	static BOOL OnThreadAttach(VOID);
	static BOOL OnThreadDetach(VOID);
	static LPCImePadSvr GetCImePadSvr(VOID);
	static LPCImePadSvr LoadCImePadSvr(INT flag);
	static LPCImePadSvr FecthCImePadSvr(VOID);
	static VOID         DestroyCImePadSvr(VOID);
	friend class CImePadCallback;
	VOID* operator new( size_t size );
	VOID  operator delete( VOID *lp );
private:
	static INT		m_gdwTLSIndex;
protected:
	static HMODULE	m_ghModClient;
	INT InitOleAPI(VOID);
	INT TermOleAPI(VOID);
	BOOL					m_fCoInitSuccess;		//Flag for CoInitialize() successed or not. 
	BOOL					m_fOLELoaded;			//OLE32.DLL is loaded by Application or explicitly loaded.
	HMODULE					m_hModOLE;				//OLE32.DLL module handle.
	FN_COINITIALIZE			m_fnCoInitialize;		//CoInitialize()		function pointer.
	FN_COCREATEINSTANCE		m_fnCoCreateInstance;	//CoCreateInstance()	function pointer.
	FN_COUNINITIALIZE		m_fnCoUninitialize;		//CoUninitialize()		function pointer.
	FN_CODISCONNECTOBJECT	m_fnCoDisconnectObject;	//CoDisconnectObject()	function pointer.
	FN_COTASKMEMALLOC		m_fnCoTaskMemAlloc;		//CoTaskMemAlloc()		function pointer.
	FN_COTASKMEMREALLOC		m_fnCoTaskMemRealloc;	//CoTaskMemRealloc()	function pointer.
	FN_COTASKMEMFREE		m_fnCoTaskMemFree;		//CoTaskMemFree()		function pointer.
public:
	CImePadSvr();
	virtual ~CImePadSvr();
	virtual BOOL		IsAvailable			(VOID)=0;
	virtual BOOL		OnIMEPadClose		(VOID)=0;
	//----------------------------------------------------------------
	//IImePadSvr interface
	//----------------------------------------------------------------
	virtual INT			Initialize			(LANGID	imeLangID, DWORD dwImeInputID, LPVOID lpVoid)=0;
	virtual	INT			Terminate			(LPVOID lpVoid)=0;
	virtual INT			ForceDisConnect		(VOID)=0;
	virtual	INT			ShowUI				(BOOL fShow)=0;
	virtual	INT			IsVisible			(BOOL *pfVisible)=0;
	virtual	INT			ActivateApplet		(UINT   activateID,
											 DWORD_PTR	dwActParam,
											 LPWSTR lpwstr1,
											 LPWSTR lpwstr2)=0; 
	virtual	INT			Notify				(INT	id,
											 WPARAM wParam,
											 LPARAM lParam)=0;
	virtual INT			GetAppletConfigList(DWORD	dwMask,
											 INT*	pCountApplet,
											 IMEPADAPPLETCONFIG **ppCfgList)=0;
	//----------------------------------------------------------------
	//Set/Get IImeIPoint, IImeCallback interface
	//----------------------------------------------------------------
	virtual IUnknown*	SetIUnkIImeIPoint	(IUnknown *pIUnk)=0;
	virtual IUnknown*	SetIUnkIImeCallback	(IUnknown *pIUnk)=0;
	virtual IUnknown*	GetIUnkIImeIPoint	(VOID)=0;
	virtual IUnknown*	GetIUnkIImeCallback	(VOID)=0;
};
#endif //__C_IMEPAD_SERVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadsvu.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvr.cpp
// Purpose  :	Client source code for IMEPad executable.
// 
// 
// Date     :	Fri Apr 16 15:39:33 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#include <windows.h>
#include "cpadsvu.h"
#include "cpaddbg.h"
#include "cpadsvus.h"	//Use Shared Memory for IPC. 

//----------------------------------------------------------------
//misc definition
//----------------------------------------------------------------
#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)

//----------------------------------------------------------------
//OLE function is dynamically loaded/called
//----------------------------------------------------------------
#define SZMOD_OLE32DLL			TEXT("OLE32.DLL")
#ifdef UNDER_CE // For GetModuleHandleW
#define WSZMOD_OLE32DLL			L"OLE32.DLL"
#endif // UNDER_CE
#define SZFN_COINITIALIZE		"CoInitialize"
#define SZFN_COCREATEINSTANCE	"CoCreateInstance"
#define SZFN_COUNINITIALIZE		"CoUninitialize"
#define SZFN_CODISCONNECTOBJECT	"CoDisconnectObject"
#define SZFN_COTASKMEMALLOC		"CoTaskMemAlloc"
#define SZFN_COTASKMEMREALLOC	"CoTaskMemRealloc"
#define SZFN_COTASKMEMFREE		"CoTaskMemFree"


//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrUIM::CreateInstance
// Type		:	HRESULT
// Purpose	:	Create New CImePadSvrUIM instance.
// Args		:	
//			:	LPCImePadSvrUIM *	pp	
//			:	LPARAM	lReserved1	//not used. must be ZERO.
//			:	LPARAM	lReserved2	//not used. must be ZERO.
// Return	:	
// DATE		:	Tue Mar 28 00:31:26 2000
// Histroy	:	
//////////////////////////////////////////////////////////////////
HRESULT
CImePadSvrUIM::CreateInstance(HINSTANCE			hInst,
							  LPCImePadSvrUIM	*pp,
							  LPARAM			lReserved1,
							  LPARAM			lReserved2)
{
	if(!pp) {
		return S_FALSE;
	}
	LPCImePadSvrUIM lpCImePadSvrUIM;
	lpCImePadSvrUIM = NULL;
	lpCImePadSvrUIM = new CImePadSvrUIM_Sharemem(hInst);
	if(lpCImePadSvrUIM) {
		if(!lpCImePadSvrUIM->IsAvailable()) {
			delete lpCImePadSvrUIM;
			lpCImePadSvrUIM = NULL;
			*pp = NULL;
			return S_FALSE;
		}
		*pp = lpCImePadSvrUIM;
		return S_OK;
	}
	return S_FALSE;

	UNREFERENCED_PARAMETER(lReserved1);
	UNREFERENCED_PARAMETER(lReserved2);
}

HRESULT
CImePadSvrUIM::DeleteInstance(LPCImePadSvrUIM	lpCImePadSvrUIM,
							  LPARAM			lReserved)
{
	lReserved; // no ref
	DBG(("CImePadSvrUIM::DestroyCImePadSvrUIM START\n"));
	if(!lpCImePadSvrUIM) {
		return S_FALSE;
	}

	lpCImePadSvrUIM->Terminate(NULL);
	delete lpCImePadSvrUIM;

	DBG(("CImePadSvrUIM::DestroyCImePadSvrUIM END\n"));
	return S_OK;
}


//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrUIM::CImePadSvrUIM
// Type		:	
// Purpose	:	Constructor of CImePadSvrUIM
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:37:18 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvrUIM::CImePadSvrUIM(HINSTANCE hInst)
{
	DBG(("CImePadSvrUIM::CImePadSvrUIM START\n"));
	m_fCoInitSuccess		= FALSE;	//Flag for CoInitialize() successed or not. 
	m_fOLELoaded			= FALSE;	//OLE32.DLL is loaded by Application or explicitly loaded.
	m_hModOLE				= FALSE;	//OLE32.DLL module handle.
	m_fnCoInitialize		= NULL;		//CoInitialize()		function pointer.
	m_fnCoCreateInstance	= NULL;		//CoCreateInstance()	function pointer.
	m_fnCoUninitialize		= NULL;		//CoUninitialize()		function pointer.
	m_fnCoDisconnectObject	= NULL;		//CoDisconnectObject()	function pointer.
	m_fnCoTaskMemAlloc		= NULL;		//CoTaskMemAlloc()		function pointer.
	m_fnCoTaskMemRealloc	= NULL;		//CoTaskMemRealloc()	function pointer.
	m_fnCoTaskMemFree		= NULL;		//CoTaskMemFree()		function pointer.
	m_hModClient			= (HMODULE)hInst;	
	DBG(("CImePadSvrUIM::CImePadSvrUIM END\n"));
}

CImePadSvrUIM::~CImePadSvrUIM()
{
	DBG(("CImePadSvrUIM::~CImePadSvrUIM START\n"));
	m_fCoInitSuccess		= FALSE;	//Flag for CoInitialize() successed or not. 
	m_fOLELoaded			= FALSE;	//OLE32.DLL is loaded by Application or explicitly loaded.
	m_hModOLE				= FALSE;	//OLE32.DLL module handle.
	m_fnCoInitialize		= NULL;		//CoInitialize()		function pointer.
	m_fnCoCreateInstance	= NULL;		//CoCreateInstance()	function pointer.
	m_fnCoUninitialize		= NULL;		//CoUninitialize()		function pointer.
	m_fnCoDisconnectObject	= NULL;		//CoDisconnectObject()	function pointer.
	m_fnCoTaskMemAlloc		= NULL;		//CoTaskMemAlloc()		function pointer.
	m_fnCoTaskMemRealloc	= NULL;		//CoTaskMemRealloc()	function pointer.
	m_fnCoTaskMemFree		= NULL;		//CoTaskMemFree()		function pointer.
	m_hModClient			= NULL;
	DBG(("CImePadSvrUIM::~CImePadSvrUIM END\n"));
}

BOOL
CImePadSvrUIM::InitOleAPI(VOID)
{
	DBG(("CImePadSvrUIM::InitOleAPI START\n"));
	if(!m_hModOLE) {
#ifndef UNDER_CE // For GetModuleHandleW
		m_hModOLE = ::GetModuleHandle(SZMOD_OLE32DLL);
#else // UNDER_CE
		m_hModOLE = ::GetModuleHandleW(WSZMOD_OLE32DLL);
#endif // UNDER_CE
		if(m_hModOLE) {
			DBG(("-->%s is Loaded by Application\n", SZMOD_OLE32DLL));
			m_fOLELoaded = FALSE;
		}
		else {
			m_hModOLE = ::LoadLibrary(SZMOD_OLE32DLL);
			if(m_hModOLE) {
				DBG(("--> %s has Loaded Explicitly", SZMOD_OLE32DLL)); 
				m_fOLELoaded = TRUE;
			}
			else {
				return FALSE;
			}
		}
	}

	m_fnCoInitialize	  = (FN_COINITIALIZE)		GetProcAddress(m_hModOLE, SZFN_COINITIALIZE);
	m_fnCoCreateInstance  = (FN_COCREATEINSTANCE)	::GetProcAddress(m_hModOLE, SZFN_COCREATEINSTANCE);
	m_fnCoUninitialize	  = (FN_COUNINITIALIZE)		::GetProcAddress(m_hModOLE, SZFN_COUNINITIALIZE);
	m_fnCoDisconnectObject= (FN_CODISCONNECTOBJECT)	::GetProcAddress(m_hModOLE, SZFN_CODISCONNECTOBJECT);
	m_fnCoTaskMemAlloc	  = (FN_COTASKMEMALLOC)		::GetProcAddress(m_hModOLE, SZFN_COTASKMEMALLOC);
	m_fnCoTaskMemRealloc  = (FN_COTASKMEMREALLOC)	::GetProcAddress(m_hModOLE, SZFN_COTASKMEMREALLOC);
	m_fnCoTaskMemFree	  = (FN_COTASKMEMFREE)		::GetProcAddress(m_hModOLE, SZFN_COTASKMEMFREE);

	if(!m_fnCoInitialize		||
	   !m_fnCoCreateInstance	||
	   !m_fnCoUninitialize		||
	   !m_fnCoDisconnectObject	||
	   !m_fnCoTaskMemAlloc		||
	   !m_fnCoTaskMemRealloc	||	
	   !m_fnCoTaskMemFree) {
	   
		DBG(("InitOleAPI Failed: GetProcAddress Error\n"));
		return FALSE;
	}
	DBG(("CImePadSvrUIM::InitOleAPI END\n"));
	return TRUE;
}

BOOL
CImePadSvrUIM::TermOleAPI(VOID)
{
	DBG(("CImePadSvrUIM::TermOleAPI START\n"));
	m_fnCoInitialize		= NULL;
	m_fnCoCreateInstance	= NULL;
	m_fnCoUninitialize		= NULL;
	m_fnCoDisconnectObject	= NULL;
	m_fnCoTaskMemAlloc		= NULL;
	m_fnCoTaskMemRealloc	= NULL; 
	m_fnCoTaskMemFree		= NULL;

	if(!m_hModOLE) {
		DBG(("-->TermOleAPI already Terminated?\n"));
		return TRUE;
	}

	if(m_hModOLE && m_fOLELoaded) {
		DBG(("--> FreeLibrary\n"));
		::FreeLibrary(m_hModOLE);
	}
	m_hModOLE    = NULL;
	m_fOLELoaded = FALSE;
	DBG(("CImePadSvrUIM::TermOleAPI END\n"));
	return TRUE;
}

#if 0
VOID*
CImePadSvrUIM::operator new( size_t size )
{
	LPVOID lp = (LPVOID)MemAlloc(size);
	return lp;
}

VOID
CImePadSvrUIM::operator delete( VOID *lp )
{
	if(lp) {
		MemFree(lp);
	}
	return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpaddbg.cpp ===
//////////////////////////////////////////////////////////////////
// File     : cpaddbg.cpp
// Purpose  :
// 
// 
// Date     : Fri Feb 19 22:03:56 1999
// Author   : 
//
// Copyright(c) 1995-1998, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifdef _DEBUG

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <stdarg.h>
#include "cpaddbg.h"
#include <stdio.h>

static IsWinNT()
{
	static OSVERSIONINFO os;
	if(os.dwOSVersionInfoSize == 0) { 
		os.dwOSVersionInfoSize = sizeof(os);
		::GetVersionEx(&os);
	}
	return (os.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

//----------------------------------------------------------------
//internal function prototype declare
//----------------------------------------------------------------
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath);
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath);
VOID   _padDbgPrintfA			(LPSTR  lpstrFmt, ...);
VOID   _padDbgPrintfW			(LPWSTR lpstrFmt, ...);

#define SZPREFIX	"IME:cpad:"
#define WSZPREFIX	L"IME:cpad:"
//----------------------------------------------------------------
// Global Data
//----------------------------------------------------------------
static LPFNDBGCALLBACKA g_lpfnDbgCBA=NULL;
static LPFNDBGCALLBACKW g_lpfnDbgCBW=NULL;
//static BOOL g_fEnable=FALSE;
static BOOL g_fEnable=TRUE;
inline VOID ODStrW(LPWSTR lpwstr)
{
	if(g_fEnable) OutputDebugStringW(lpwstr);
}
inline VOID ODStrA(LPSTR lpstr)
{
	if(g_fEnable) OutputDebugStringA(lpstr);
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgSetCallback
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPFNDBGCALLBACK lpfnDbgCallback 
// Return   : 
// DATE     : Tue Jan 06 12:42:36 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgSetCallback(LPFNDBGCALLBACKA lpfnCBA, LPFNDBGCALLBACKW lpfnCBW)
{
	g_lpfnDbgCBA = lpfnCBA;
	g_lpfnDbgCBW = lpfnCBW;
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgSwitchOutput
// Type     : VOID
// Purpose  : 
// Args     : 
//          : BOOL fOn 
// Return   : 
// DATE     : Fri Apr 03 17:35:55 1998
// Author   : 
//////////////////////////////////////////////////////////////////
VOID _padDbgEnableOutput(BOOL fEnable)
{
	g_fEnable = fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgIsOutputEnable
// Type     : VOID
// Purpose  : 
// Args     : None
// Return   : 
// DATE     : Fri Apr 03 18:00:52 1998
// Author   : 
//////////////////////////////////////////////////////////////////
BOOL _padDbgIsOutputEnable(VOID)
{
	return g_fEnable;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgOutStrA
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Tue Jan 06 12:29:39 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgOutStrA(LPSTR lpstr)
{
	static BOOL fIn;
	ODStrA(lpstr);
#ifdef _CONSOLE
	printf(lpstr);
#endif

	if(g_lpfnDbgCBA) {
		if(fIn) { return; }
		fIn = TRUE;
		(*g_lpfnDbgCBA)(lpstr);
		fIn = FALSE;
	}
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgOutStrW
// Type     : static VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpwstr 
// Return   : 
// DATE     : Tue Jan 06 12:30:07 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgOutStrW(LPWSTR lpwstr)
{
	static BOOL fIn;
	if(IsWinNT()) {
		ODStrW(lpwstr);
	}
	else {
		static CHAR szBuf[1024];
		::WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0);
		ODStrA(szBuf);
	}

#ifdef _CONSOLE
	static CHAR szBuf[1024];
	::WideCharToMultiByte(932, WC_COMPOSITECHECK, lpwstr, -1, szBuf, sizeof(szBuf), 0, 0); 
	printf(szBuf);
#endif
	if(g_lpfnDbgCBW) { 
		if(fIn) { return; } 		
		fIn = TRUE;
		(*g_lpfnDbgCBW)(lpwstr);
		fIn = FALSE;
	}
	return;
}

////////////////////////////////////////////////////////
// Function: _padDbgA
// Type    : VOID
// Purpose : 
// Args    : 
//         : LPSTR lpstrFile 
//         : INT lineNo 
//         : LPTSR lpstrMsg 
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _padDbgA(LPSTR		lpstrFile, 
			 INT		lineNo, 
			 LPSTR		lpstrMsg)
{
	_padDbgPrintfA("%s(%12s:%4d) %s", 
				  SZPREFIX,
				  GetFileTitleStrA(lpstrFile),
				  lineNo,
				  lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFile 
//          : INT lineNo 
//          : LPWSTR lpstrMsg 
// Return   : 
// DATE     : Mon Jan 05 15:10:41 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgW(LPWSTR		lpstrFile, 
		   INT			lineNo, 
		   LPWSTR		lpstrMsg)
{
	_padDbgPrintfW(L"%s(%10s:%4d) %s", 
				  WSZPREFIX,
				  GetFileTitleStrW(lpstrFile),
				  lineNo,
				  lpstrMsg);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgVaStrA
// Type     : LPSTR
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:09:53 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgVaStrA(LPSTR lpstrFmt, ...)
{
	static CHAR chBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(chBuf, lpstrFmt, ap);
	va_end(ap);
	return chBuf;
}


////////////////////////////////////////////////////////
// Function : _padDbgVaStrW
// Type     : LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt
// Return   : 
// DATE     : 
/////////////////////////////////////////////////////////
LPWSTR _padDbgVaStrW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap);	//Use C-RunTime Library for Win95
	va_end(ap);
	return wchBuf;
}


////////////////////////////////////////////////////////
// Function: _padDbgPrintfA
// Type    : VOID
// Purpose : variable args version of OutputDebugStringA
// Args    : 
//         : LPSTR lpstrFmt 
//         : ...
// Return  : 
// DATE    : 
/////////////////////////////////////////////////////////
VOID _padDbgPrintfA(LPSTR lpstrFmt, ...)
{
	static CHAR szBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	wvsprintfA(szBuf, lpstrFmt, ap);
	va_end(ap);
	_padDbgOutStrA(szBuf);
	return;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgPrintfW
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFmt 
//          : ...
// Return   : 
// DATE     : Mon Jan 05 15:11:24 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgPrintfW(LPWSTR lpstrFmt, ...)
{
	static WCHAR wchBuf[512];
	va_list ap;
	va_start(ap, lpstrFmt);
	vswprintf(wchBuf, lpstrFmt, ap); //Use C-RunTime Library for Win95
	va_end(ap);
	_padDbgOutStrW(wchBuf);
	return;
}


//////////////////////////////////////////////////////////////////
// Function : _padDbgMulti2Wide
// Type     : LPWSTR
// Purpose  : return Unicode string from MBCS string
// Args     : 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Mon Jan 05 15:10:48 1998
//////////////////////////////////////////////////////////////////
LPWSTR _padDbgMulti2Wide(LPSTR lpstr)
{
	static WCHAR wchBuf[512];
	MultiByteToWideChar(CP_ACP, 
						MB_PRECOMPOSED,
						lpstr, -1,
						(WCHAR*)wchBuf, sizeof(wchBuf)/sizeof(WCHAR) );
	return wchBuf;
}


//////////////////////////////////////////////////////////////////
// Function : _padDbgGetWinClass
// Type     : LPSTR
// Purpose  : Get Windows class name string
//			  ANSI version only.
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:08:43 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetWinClass(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetClassNameA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;

}

//////////////////////////////////////////////////////////////////
// Function : _padDbgGetWinText
// Type     : LPSTR
// Purpose  : Get Windows text(title) string
// Args     : 
//          : HWND hwnd 
// Return   : 
// DATE     : Mon Jan 05 15:09:08 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetWinText(HWND hwnd)
{
#ifdef _CONSOLE
	return NULL;
#endif
	static CHAR szBuf[256];
	szBuf[0]=(char)0x00;
	GetWindowTextA(hwnd, szBuf, sizeof(szBuf));
	return szBuf;
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgMsgBoxA
// Type     : VOID
// Purpose  : 
// Args     : 
//          : LPSTR lpstrFile 
//          : INT lineNo 
//          : LPSTR lpstr 
// Return   : 
// DATE     : Thu Jan 08 12:31:03 1998
//////////////////////////////////////////////////////////////////
VOID _padDbgMsgBoxA(LPSTR lpstrFile,  INT lineNo, LPSTR lpstrMsg)
{
#ifdef _CONSOLE
	return;
#endif
	char szTmp[512];
	wsprintfA(szTmp, "Debug Message Box (File: %s, Line: %4d)", 
			  GetFileTitleStrA(lpstrFile), 
			  lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
}

VOID _padDbgAssert(LPSTR  lpstrFile,  INT lineNo, BOOL fOk, LPSTR lpstrMsg)
{
	if(fOk) {
		return; 
	}
	char szTmp[512];
	wsprintfA(szTmp, "ASSERT (File: %s, Line: %4d)", 
			  GetFileTitleStrA(lpstrFile), 
			  lineNo);
	MessageBoxA(GetActiveWindow(), lpstrMsg, szTmp, MB_OK);
	DebugBreak();
}

//////////////////////////////////////////////////////////////////
// Function : _padDbgGetErrorString
// Type     : LPSTR
// Purpose  : Convert Error(Got from GetLastError()) value to ERROR Message String
// Args     : 
//          : INT errorCode 
// Return   : 
// DATE     : Mon Jan 05 16:43:34 1998
//////////////////////////////////////////////////////////////////
LPSTR _padDbgGetErrorString(INT errorCode)
{
	static CHAR szBuf[512];
	INT count;
	szBuf[0] = (CHAR)0x00;
	count = wsprintfA(szBuf, "[0x%08x]:", errorCode);
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   errorCode, 
				   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				   szBuf+count,
				   sizeof(szBuf)-1-count,
				   NULL );
	if(*(szBuf + count) != (CHAR)0x00) {
		int nLen = lstrlenA(szBuf);
		if((nLen - count) > 1) {
			szBuf[nLen - 1] = (CHAR)0x00;
		}
	}
	return szBuf;
}


//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrA
// Type     : static LPSTR
// Purpose  : Return File name string(remove folder)
// Args     : 
//          : LPSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:34:22 1998
//////////////////////////////////////////////////////////////////
static LPSTR GetFileTitleStrA(LPSTR lpstrFilePath)
{
	static CHAR szBuf[2];
	CHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenA(lpstrFilePath) - 1);
	for(pTemp = CharPrevA(lpstrFilePath, pLast); 
		(pTemp  != lpstrFilePath) && 
		(*pTemp != '\\')	 &&
		(*pTemp != (CHAR)0x00); 
		pTemp = CharPrevA(lpstrFilePath, pTemp)) {
		;
	}
	if(*pTemp == '\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}

//////////////////////////////////////////////////////////////////
// Function : GetFileTitleStrW
// Type     : static LPWSTR
// Purpose  : 
// Args     : 
//          : LPWSTR lpstrFilePath 
// Return   : 
// DATE     : Mon Jan 05 13:38:19 1998
//////////////////////////////////////////////////////////////////
static LPWSTR GetFileTitleStrW(LPWSTR lpstrFilePath)
{
	static WCHAR szBuf[2];
	WCHAR *pLast, *pTemp;
	if(!lpstrFilePath) {
		szBuf[0] = (CHAR)0x00;
		return szBuf;
	}
	pLast = lpstrFilePath + (lstrlenW(lpstrFilePath) - 1);
	for(pTemp = pLast-1;
		(pTemp != lpstrFilePath) &&
		(*pTemp != L'\\')		 &&
		(*pTemp != (WCHAR)0x0000);
		pTemp--) {
		;
	}

	if(*pTemp == L'\\') {
		return pTemp+1;
	}
	return lpstrFilePath;
}


#define DEFID(a)	{a, #a}
typedef struct idStr {
	INT code;
	LPSTR lpstr;
}IDSTR; 

IDSTR rpcError[]={
	DEFID(RPC_S_INVALID_STRING_BINDING),
	DEFID(RPC_S_WRONG_KIND_OF_BINDING),
	DEFID(RPC_S_INVALID_BINDING),
	DEFID(RPC_S_PROTSEQ_NOT_SUPPORTED),
	DEFID(RPC_S_INVALID_RPC_PROTSEQ),
	DEFID(RPC_S_INVALID_STRING_UUID),
	DEFID(RPC_S_INVALID_ENDPOINT_FORMAT),
	DEFID(RPC_S_INVALID_NET_ADDR),
	DEFID(RPC_S_NO_ENDPOINT_FOUND),
	DEFID(RPC_S_INVALID_TIMEOUT),
	DEFID(RPC_S_OBJECT_NOT_FOUND),
	DEFID(RPC_S_ALREADY_REGISTERED),
	DEFID(RPC_S_TYPE_ALREADY_REGISTERED),
	DEFID(RPC_S_ALREADY_LISTENING),
	DEFID(RPC_S_NO_PROTSEQS_REGISTERED),
	DEFID(RPC_S_NOT_LISTENING),
	DEFID(RPC_S_UNKNOWN_MGR_TYPE),
	DEFID(RPC_S_UNKNOWN_IF),
	DEFID(RPC_S_NO_BINDINGS),
	DEFID(RPC_S_NO_PROTSEQS),
	DEFID(RPC_S_CANT_CREATE_ENDPOINT),
	DEFID(RPC_S_OUT_OF_RESOURCES),
	DEFID(RPC_S_SERVER_UNAVAILABLE),
	DEFID(RPC_S_SERVER_TOO_BUSY),
	DEFID(RPC_S_INVALID_NETWORK_OPTIONS),
	DEFID(RPC_S_NO_CALL_ACTIVE),
	DEFID(RPC_S_CALL_FAILED),
	DEFID(RPC_S_CALL_FAILED_DNE),
	DEFID(RPC_S_PROTOCOL_ERROR),
	DEFID(RPC_S_UNSUPPORTED_TRANS_SYN),
	DEFID(RPC_S_UNSUPPORTED_TYPE),
	DEFID(RPC_S_INVALID_TAG),
	DEFID(RPC_S_INVALID_BOUND),
	DEFID(RPC_S_NO_ENTRY_NAME),
	DEFID(RPC_S_INVALID_NAME_SYNTAX),
	DEFID(RPC_S_UNSUPPORTED_NAME_SYNTAX),
	DEFID(RPC_S_UUID_NO_ADDRESS),
	DEFID(RPC_S_DUPLICATE_ENDPOINT),
	DEFID(RPC_S_UNKNOWN_AUTHN_TYPE),
	DEFID(RPC_S_MAX_CALLS_TOO_SMALL),
	DEFID(RPC_S_STRING_TOO_LONG),
	DEFID(RPC_S_PROTSEQ_NOT_FOUND),
	DEFID(RPC_S_PROCNUM_OUT_OF_RANGE),
	DEFID(RPC_S_BINDING_HAS_NO_AUTH),
	DEFID(RPC_S_UNKNOWN_AUTHN_SERVICE),
	DEFID(RPC_S_UNKNOWN_AUTHN_LEVEL),
	DEFID(RPC_S_INVALID_AUTH_IDENTITY),
	DEFID(RPC_S_UNKNOWN_AUTHZ_SERVICE),
	DEFID(EPT_S_INVALID_ENTRY),
	DEFID(EPT_S_CANT_PERFORM_OP),
	DEFID(EPT_S_NOT_REGISTERED),
	DEFID(RPC_S_NOTHING_TO_EXPORT),
	DEFID(RPC_S_INCOMPLETE_NAME),
	DEFID(RPC_S_INVALID_VERS_OPTION),
	DEFID(RPC_S_NO_MORE_MEMBERS),
	DEFID(RPC_S_NOT_ALL_OBJS_UNEXPORTED),
	DEFID(RPC_S_INTERFACE_NOT_FOUND),
	DEFID(RPC_S_ENTRY_ALREADY_EXISTS),
	DEFID(RPC_S_ENTRY_NOT_FOUND),
	DEFID(RPC_S_NAME_SERVICE_UNAVAILABLE),
	DEFID(RPC_S_INVALID_NAF_ID),
	DEFID(RPC_S_CANNOT_SUPPORT),
	DEFID(RPC_S_NO_CONTEXT_AVAILABLE),
	DEFID(RPC_S_INTERNAL_ERROR),
	DEFID(RPC_S_ZERO_DIVIDE),
	DEFID(RPC_S_ADDRESS_ERROR),
	DEFID(RPC_S_FP_DIV_ZERO),
	DEFID(RPC_S_FP_UNDERFLOW),
	DEFID(RPC_S_FP_OVERFLOW),
	DEFID(RPC_X_NO_MORE_ENTRIES),
	DEFID(RPC_X_SS_CHAR_TRANS_OPEN_FAIL),
	DEFID(RPC_X_SS_CHAR_TRANS_SHORT_FILE),
	DEFID(RPC_X_SS_IN_NULL_CONTEXT),
	DEFID(RPC_X_SS_CONTEXT_DAMAGED),
	DEFID(RPC_X_SS_HANDLES_MISMATCH),
	DEFID(RPC_X_SS_CANNOT_GET_CALL_HANDLE),
	DEFID(RPC_X_NULL_REF_POINTER),
	DEFID(RPC_X_ENUM_VALUE_OUT_OF_RANGE),
	DEFID(RPC_X_BYTE_COUNT_TOO_SMALL),
	DEFID(RPC_X_BAD_STUB_DATA),
	DEFID(ERROR_INVALID_USER_BUFFER),
	DEFID(ERROR_UNRECOGNIZED_MEDIA),
	DEFID(ERROR_NO_TRUST_LSA_SECRET),
	DEFID(ERROR_NO_TRUST_SAM_ACCOUNT),
	DEFID(ERROR_TRUSTED_DOMAIN_FAILURE),
	DEFID(ERROR_TRUSTED_RELATIONSHIP_FAILURE),
	DEFID(ERROR_TRUST_FAILURE),
	DEFID(RPC_S_CALL_IN_PROGRESS),
};

LPSTR _padDbgGetRPCError(INT code)
{
	INT i;
	for(i = 0; i < sizeof(rpcError)/sizeof(rpcError[0]); i++) {
		if(rpcError[i].code == code) {
			return rpcError[i].lpstr;
		}
	}
	static char szBuf[]="";
	return szBuf;
}

INT _padDbgShowError(HRESULT hr, LPSTR lpstrFunc)
{
	char szBuf[256];
	char szMsg[1024];
	FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   hr,
				   0,
				   szBuf,
				   256,
				   NULL);
	szBuf[lstrlenA(szBuf)-1] = (char)0x00;
	wsprintfA(szMsg, "!!%s: hr[0x%08x] code[%d][%x][%s][%s]",
			  lpstrFunc ? lpstrFunc : "UnknownFunc",
			  hr,
			  HRESULT_CODE(hr),
			  HRESULT_CODE(hr),
			  _padDbgGetErrorString(HRESULT_CODE(hr)), 
			  szBuf);
	DBG(("%s\n", szMsg));
	return 0;
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( HjDict )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( HjDict ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\enum.h ===
/****************************************************************************
   Enum.h : declaration of Busu/Stroke Enumeration functions

   Copyright 2000 Microsoft Corp.

   History:
	  07-FEB-2000 bhshin  created
****************************************************************************/

#ifndef _ENUM_HEADER
#define _ENUM_HEADER

#include "Lex.h"

short GetMaxBusu(MAPFILE *pLexMap);
short GetMaxStroke(MAPFILE *pLexMap);

BOOL GetFirstBusuHanja(MAPFILE *pLexMap, short nBusuID, WCHAR *pwchFirst);
BOOL GetNextBusuHanja(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *pwchNext);

BOOL GetFirstStrokeHanja(MAPFILE *pLexMap, short nStroke, WCHAR *pwchFirst);
BOOL GetNextStrokeHanja(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *pwchNext);

#endif // #ifndef _ENUM_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadsvu.h ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvr.h
// Purpose  :	Class for Client that uses IMEPad.
//				This is Super(Abstract) class.
//				
// 
// Date     :	Fri Apr 16 14:34:49 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_IMEPAD_SERVER_FOR_UIM_H__
#define __C_IMEPAD_SERVER_FOR_UIM_H__
#include "imepadsv.h"


//----------------------------------------------------------------
//Forward declare
//----------------------------------------------------------------
class CImePadCallbackUIM;
typedef CImePadCallbackUIM *LPCImePadCallbackUIM;
class CImePadSvrUIM;
typedef CImePadSvrUIM*	LPCImePadSvrUIM;

//----------------------------------------------------------------
//OLE API func's pointer declare
//----------------------------------------------------------------
typedef HRESULT (WINAPI* FN_COINITIALIZE)(LPVOID pvReserved);
typedef HRESULT (WINAPI* FN_COCREATEINSTANCE)(REFCLSID rclsid,
											  LPUNKNOWN pUnkOuter,
											  DWORD dwClsContext,
											  REFIID riid,
											  LPVOID FAR* ppv);
typedef void    (WINAPI* FN_COUNINITIALIZE)(void);
typedef HRESULT (WINAPI* FN_CODISCONNECTOBJECT)(LPUNKNOWN pUnk, DWORD dwReserved);
typedef LPVOID  (WINAPI* FN_COTASKMEMALLOC)(ULONG cb);
typedef LPVOID  (WINAPI* FN_COTASKMEMREALLOC)(LPVOID pv, ULONG cb);
typedef VOID    (WINAPI* FN_COTASKMEMFREE)(LPVOID pv);

class CImePadSvrUIM
{
public:
	//----------------------------------------------------------------
	//Static method declare
	//----------------------------------------------------------------
	static HRESULT		CreateInstance(HINSTANCE		hInst,
									   LPCImePadSvrUIM	*pp,
									   LPARAM			lReserved1,
									   LPARAM			lReserved2);
	static HRESULT		DeleteInstance(LPCImePadSvrUIM	lpCImePadSvrUIM,
									   LPARAM			lReserved);
public:
	friend class CImePadCallbackUIM;
	//VOID* operator new( size_t size );
	//VOID  operator delete( VOID *lp );
public:
	CImePadSvrUIM(HINSTANCE hInst);
	virtual ~CImePadSvrUIM();
	virtual BOOL		IsAvailable			(VOID)=0;
	virtual BOOL		OnIMEPadClose		(VOID)=0;
	//----------------------------------------------------------------
	//IImePadSvr interface
	//----------------------------------------------------------------
	virtual INT			Initialize			(LANGID		imeLangID,
											 DWORD		dwImeInputID,
											 LPVOID		lpVoid)=0;
	virtual	INT			Terminate			(LPVOID lpVoid)=0;
	virtual INT			ForceDisConnect		(VOID)=0;
	virtual	INT			ShowUI				(BOOL fShow)=0;
	virtual	INT			IsVisible			(BOOL *pfVisible)=0;
	virtual	INT			ActivateApplet		(UINT   activateID,
											 LPARAM	dwActParam,
											 LPWSTR lpwstr1,
											 LPWSTR lpwstr2)=0; 
	virtual	INT			Notify				(INT	id,
											 WPARAM wParam,
											 LPARAM lParam)=0;
	virtual INT			GetAppletConfigList(DWORD	dwMask,
											INT*	pCountApplet,
											IMEPADAPPLETCONFIG **ppCfgList)=0;
	//----------------------------------------------------------------
	//Set/Get IImeIPoint, IImeCallback interface
	//----------------------------------------------------------------
	virtual IUnknown*	SetIUnkIImeIPoint	(IUnknown *pIUnk)=0;
	virtual IUnknown*	SetIUnkIImeCallback	(IUnknown *pIUnk)=0;
	virtual IUnknown*	GetIUnkIImeIPoint	(VOID)=0;
	virtual IUnknown*	GetIUnkIImeCallback	(VOID)=0;
protected:
	HMODULE	m_hModClient;
	INT		InitOleAPI(VOID);
	INT		TermOleAPI(VOID);
	BOOL					m_fCoInitSuccess;		//Flag for CoInitialize() successed or not. 
	BOOL					m_fOLELoaded;			//OLE32.DLL is loaded by Application or explicitly loaded.
	HMODULE					m_hModOLE;				//OLE32.DLL module handle.
	FN_COINITIALIZE			m_fnCoInitialize;		//CoInitialize()		function pointer.
	FN_COCREATEINSTANCE		m_fnCoCreateInstance;	//CoCreateInstance()	function pointer.
	FN_COUNINITIALIZE		m_fnCoUninitialize;		//CoUninitialize()		function pointer.
	FN_CODISCONNECTOBJECT	m_fnCoDisconnectObject;	//CoDisconnectObject()	function pointer.
	FN_COTASKMEMALLOC		m_fnCoTaskMemAlloc;		//CoTaskMemAlloc()		function pointer.
	FN_COTASKMEMREALLOC		m_fnCoTaskMemRealloc;	//CoTaskMemRealloc()	function pointer.
	FN_COTASKMEMFREE		m_fnCoTaskMemFree;		//CoTaskMemFree()		function pointer.
};
#endif //__C_IMEPAD_SERVER_FOR_UIM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadsvus.cpp ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvrs.cpp
// Purpose  :	CImePadServerUIM for Shared Memory version.
// 
// 
// Date     :	Fri Apr 16 15:39:33 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#include <windows.h>
#include "imepadsv.h"
#include "cpadsvus.h"
#include "cpadcbu.h"
#include "cpaddbg.h"
#include "iimecb.h"
#include "ipoint1.h"

//----------------------------------------------------------------
//misc definition
//----------------------------------------------------------------
#define Unref(a)	UNREFERENCED_PARAMETER(a)
//990812:ToshiaK For Win64. Use Global Alloc/Free Ptr.
#include <windowsx.h>
#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)


#define SZ_IMEPADIFCLASS			TEXT("msimepad8UIMIFClass")
//----------------------------------------------------------------
//TIMER id definition
//----------------------------------------------------------------
#define TIMERID_NOTIFY_ACTIVATECONTEXT	0x0010
#define TIMERID_NOTIFY_APPLYCANDIDATE	0x0011
#define TIMERID_NOTIFY_QUERYCANDIDATE	0x0012
#define TIMERID_NOTIFY_APPLYCANDIDATEEX	0x0013
#define TIMERELAPS_ACTIVATE				200		//milisec
#define TIMERELAPS_INACTIVATE			100
#define TIMERELAPS_NOTIFY				200

inline LPVOID
WinSetUserPtr(HWND hwnd, LPVOID lpVoid)
{
#ifdef _WIN64	
	return (LPVOID)SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpVoid);
#else
	return (LPVOID)SetWindowLong(hwnd, GWL_USERDATA, (LONG)lpVoid);
#endif
}

inline LPVOID
WinGetUserPtr(HWND hwnd)
{
#ifdef _WIN64	
	return (LPVOID)GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	return (LPVOID)GetWindowLong(hwnd, GWL_USERDATA);
#endif
}

static LPWSTR
StrdupW(LPWSTR lpwstr)
{
	LPWSTR lpwstrRet;
	if(!lpwstr) {
		return NULL;
	}
	INT len = lstrlenW(lpwstr);
	if(len == 0) {
		return NULL;
	}
	lpwstrRet = (LPWSTR)MemAlloc((len+1) * sizeof(WCHAR));
	if(!lpwstrRet) {
		return NULL;
	}
	CopyMemory(lpwstrRet, lpwstr, sizeof(WCHAR)*len);
	lpwstrRet[len] = (WCHAR)0x0000;
	return lpwstrRet;
} 

//----------------------------------------------------------------
//
//public method decalre
//
//----------------------------------------------------------------

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrSharemem::CImePadSvrSharemem
// Type		:	None
// Purpose	:	Constructor of CImePadSvrSharemem class
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:04:01 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvrUIM_Sharemem::CImePadSvrUIM_Sharemem(HINSTANCE hInst):CImePadSvrUIM(hInst)
{
	DBG(("CImePadSvrUIM_Sharemem::CImePadSvrUIM_Sharemem() constructor START\n"));
	m_imeLangID				= 0;		//Save Initialized data.
	m_dwImeInputID			= 0;		//Save Initialized data.
	m_fShowReqStatus		= FALSE;	//Save ShowUI()'s bool value.
	m_fLastActiveCtx		= FALSE;	//Save IMEPADNOTIFY_ACTIVATECONTEXT
	m_hwndIF				= NULL;		//Internal I/F Window handle.
	m_lpIUnkIImeIPoint		= NULL;		//IImeIPoint I/F pointer as IUnknown.
	m_lpIUnkIImeCallback	= NULL;		//IImeCallback I/F pointer as IUnknown.
	m_lpCImePadCallbackUIM	= NULL;		//CImePadCallbackUIM instance pointer.
	m_lpIImePadServer		= NULL;		//IImePadServer I/F pointer.
	m_dwRegAdvise			= 0;
	m_hModuleProxyStub		= NULL;

	//Initialize Candidate data
	ZeroMemory(&m_ntfyDataApplyCand,	sizeof(m_ntfyDataApplyCand));
	ZeroMemory(&m_ntfyDataQueryCand,	sizeof(m_ntfyDataQueryCand));
	ZeroMemory(&m_ntfyDataApplyCandEx,	sizeof(m_ntfyDataApplyCandEx));

	DBG(("CImePadSvrUIM_Sharemem::CImePadSvrUIM_Sharemem() constructor END\n"));
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrUIM_Sharemem::~CImePadSvrUIM_Sharemem
// Type		:	INT
// Purpose	:	Destructor of CImePadSvrUIM_Sharemem Class.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:04:29 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
CImePadSvrUIM_Sharemem::~CImePadSvrUIM_Sharemem(VOID)
{
	DBG(("CImePadSvrUIM_Sharemem::CImePadSvrUIM_Sharemem() Destructor START\n"));
	this->DestroyIFHWND(TRUE);
	m_imeLangID				= 0;		//Save Initialized data.
	m_dwImeInputID			= 0;		//Save Initialized data.
	m_fShowReqStatus		= FALSE;	//Save ShowUI()'s bool value.
	m_fLastActiveCtx		= FALSE;	//Save IMEPADNOTIFY_ACTIVATECONTEXT
	m_hwndIF				= NULL;		//Internal I/F Window handle.
	m_lpIUnkIImeIPoint		= NULL;		//IImeIPoint I/F pointer as IUnknown.
	m_lpIUnkIImeCallback	= NULL;		//IImeCallback I/F pointer as IUnknown.
	m_lpIImePadServer		= NULL;		//IImePadServer I/F pointer.

	//990813:ToshiaK. Memory leak.
	if(m_lpCImePadCallbackUIM) {
		delete m_lpCImePadCallbackUIM;
		m_lpCImePadCallbackUIM = NULL;
	}

	if(m_hModuleProxyStub) {
		::FreeLibrary(m_hModuleProxyStub);
		m_hModuleProxyStub = 0;
	}
	DBG(("CImePadSvrUIM_Sharemem::CImePadSvrUIM_Sharemem() Destructor END\n"));
}

BOOL
CImePadSvrUIM_Sharemem::IsAvailable(VOID)
{
	LPTSTR lpPath = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
	if(!lpPath) {
		DBG(("-->Outof Memory ??\n"));
		return FALSE;
	}

	if(0 ==  this->CLSID2ModuleName(IID_IImePadServerSHM,
									FALSE,
									lpPath,
									sizeof(TCHAR)*MAX_PATH)) {
		MemFree(lpPath);
		return TRUE;
	}
	MemFree(lpPath);
	return FALSE;

}

BOOL
CImePadSvrUIM_Sharemem::OnIMEPadClose(VOID)
{
	m_fShowReqStatus = FALSE;
	return 0;
}

INT
CImePadSvrUIM_Sharemem::Initialize(LANGID	imeLangID,
							   DWORD	dwImeInputID,
							   LPVOID	lpVoid)
{
	DBG(("CImePadSvrUIM_Sharemem::Initialize() START\n"));
	DBG(("--> imeLangID   [0x%08x]\n", imeLangID));
	DBG(("--> dwImeInputID[0x%08x]\n", dwImeInputID));
	if(m_lpIImePadServer) {
		DBG(("-->Already Initialized\n"));
		return 0;
	}

	HRESULT hr;
	
	this->CreateIFHWND();	//Create internal Interface Window.
	m_imeLangID		= imeLangID;
	m_dwImeInputID	= dwImeInputID;
	if(!m_lpCImePadCallbackUIM) {
		m_lpCImePadCallbackUIM = new CImePadCallbackUIM(m_hwndIF, this);
	}
	this->InitOleAPI();

	m_lpIImePadServer = (IImePadServer *)this->CreateObject();
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->Initialize(::GetCurrentProcessId(),
								  ::GetCurrentThreadId(),
								  (DWORD)imeLangID,
								  (DWORD)dwImeInputID,
								  TRUE,					//fUIM,
								  m_lpCImePadCallbackUIM,
								  NULL,
								  0,
								  0);
	DBG(("CImePadSvrUIM_Sharemem::Initialize() END\n"));
	return 0;
	Unref(lpVoid);
	Unref(hr);
}

INT
CImePadSvrUIM_Sharemem::Terminate(LPVOID lpVoid)
{
	DBG(("CImePadSvrUIM_Sharemem::::Terminate() START \n"));
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->Terminate(0, 0);
	m_lpIImePadServer = NULL;
	//990813:ToshiaK memory leak;
	if(m_lpCImePadCallbackUIM) {
		delete m_lpCImePadCallbackUIM;
		m_lpCImePadCallbackUIM = NULL;
	}
	DBG(("CImePadSvrUIM_Sharemem::Terminate() End\n"));
	return 0;
	Unref(lpVoid);
}

INT
CImePadSvrUIM_Sharemem::ForceDisConnect(VOID)
{
	DBG(("CImePadSvrUIM_Sharemem::ForceDisConnect START\n"));
	if(m_lpIImePadServer) {
		m_lpIImePadServer = NULL;
	}
	DBG(("CImePadSvrUIM_Sharemem::ForceDisConnect END\n"));
	return 0;
}


INT
CImePadSvrUIM_Sharemem::ShowUI(BOOL fShow)
{
	DBG(("CImePadSvrUIM_Sharemem::ShowUI() START fShow [%d]\n"));
	m_fShowReqStatus = fShow;
	if(!m_lpIImePadServer) {
		return -1;
	}
	m_lpIImePadServer->ShowUI(fShow);
	DBG(("CImePadSvrUIM_Sharemem::ShowUI() END\n"));
	return 0;
}

INT
CImePadSvrUIM_Sharemem::IsVisible(BOOL *pfVisible)
{
	if(pfVisible) {
		*pfVisible = m_fShowReqStatus;
	}
	return 0;
}

INT
CImePadSvrUIM_Sharemem::ActivateApplet(UINT activateID,
									   LPARAM dwActivateParam,
									   LPWSTR lpwstr1,
									   LPWSTR lpwstr2)
{
	DBG(("CImePadSvrUIM_Sharemem::ActivateApplet START\n"));
	DBG(("-->activateID      [0x%08x][%s]\n",
		 activateID,
		 activateID == IMEPADACTID_ACTIVATEBYCATID ? "IMEPADACTID_ACTIVATEBYCATID" :
		 activateID == IMEPADACTID_ACTIVATEBYIID   ? "IMEPADACTID_ACTIVATEBYIID" :
		 activateID == IMEPADACTID_ACTIVATEBYNAME  ? "IMEPADACTID_ACTIVATEBYNAME" : 
		 "Unknown"));
	DBG(("-->dwActivateParam [0x%08x]\n", dwActivateParam));
	DBG(("-->lpwstr1         [0x%08x]\n", lpwstr1));
	DBG(("-->lpwstr2         [0x%08x]\n", lpwstr2));

	if(!m_lpIImePadServer) {
		DBG(("-->m_lpIImePadServer is NULL\n"));
		DBG(("CImePadSvrUIM_Sharemem::ActivateApplet END\n"));
		return -1;
	}
	m_lpIImePadServer->ActivateApplet(activateID,
									  dwActivateParam,
									  lpwstr1,
									  lpwstr2);
	DBG(("CImePadSvrUIM_Sharemem::ActivateApplet END\n"));
	return 0;
	Unref(activateID);
	Unref(dwActivateParam);
	Unref(lpwstr1);
	Unref(lpwstr2);
}

INT
CImePadSvrUIM_Sharemem::Notify(INT id, WPARAM wParam, LPARAM lParam)
{
	HRESULT hr;
	switch(id) {
	case IMEPADNOTIFY_ACTIVATECONTEXT:
		DBG(("CImePadSvrUIM_Sharemem::Notify: ActivateContext\n"));
		//990608:KOTAE #1121. if ImePad is not shown in this application,
		//Do not send IMEPADNOTIFY_ACTIVATECONTEXT
		if(!m_fShowReqStatus) {
			return 0;
		}
		m_fLastActiveCtx = (BOOL)wParam;
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_ACTIVATECONTEXT);
		if(m_fLastActiveCtx) {
			::SetTimer(m_hwndIF,
					   TIMERID_NOTIFY_ACTIVATECONTEXT,
					   TIMERELAPS_ACTIVATE,
					   NULL);
		}
		else {
			::SetTimer(m_hwndIF,
					   TIMERID_NOTIFY_ACTIVATECONTEXT,
					   TIMERELAPS_INACTIVATE,
					   NULL);
		}
		break;
	case IMEPADNOTIFY_APPLYCANDIDATE:
		//----------------------------------------------------------------
		// Notify for Candidate Applied
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: iSelIndex = (INT)lParam;
		//----------------------------------------------------------------
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATE);
		m_ntfyDataApplyCand.dwCharID   = (DWORD)wParam;
		m_ntfyDataApplyCand.dwSelIndex = (DWORD)lParam;
		::SetTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATE, TIMERELAPS_NOTIFY, NULL);

		break;
	case IMEPADNOTIFY_QUERYCANDIDATE:
		//----------------------------------------------------------------
		// Notify for Querying Candidate
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: 0. not used.
		//----------------------------------------------------------------
		::KillTimer(m_hwndIF, TIMERID_NOTIFY_QUERYCANDIDATE);
		m_ntfyDataQueryCand.dwCharID = (DWORD)wParam;
		::SetTimer(m_hwndIF, TIMERID_NOTIFY_QUERYCANDIDATE, TIMERELAPS_NOTIFY, NULL);
		break;
	case IMEPADNOTIFY_APPLYCANDIDATE_EX:
		//----------------------------------------------------------------
		// Notify for Candidate Applied
		// WPARAM wParam: dwCharId = (DWORD)wParam;
		// LPARAM lParam: lpApplyCandEx = (LPIMEPADAPPLYCANDEX)lParam;
		//----------------------------------------------------------------
		{
			::KillTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATEEX);
			m_ntfyDataApplyCandEx.dwCharID = (DWORD)wParam;
			LPIMEPADAPPLYCANDINFO lpApplyCandInfo = (LPIMEPADAPPLYCANDINFO)lParam;

			if(m_ntfyDataApplyCandEx.lpwstrCreated1) {
				MemFree(m_ntfyDataApplyCandEx.lpwstrCreated1);
			}
			if(m_ntfyDataApplyCandEx.lpwstrCreated2) {
				MemFree(m_ntfyDataApplyCandEx.lpwstrCreated2);
			}
			m_ntfyDataApplyCandEx.lpwstrCreated1 = NULL;
			m_ntfyDataApplyCandEx.lpwstrCreated2 = NULL;
			
			if(lpApplyCandInfo) {
				if(lpApplyCandInfo->lpwstrDisplay) {
					m_ntfyDataApplyCandEx.lpwstrCreated1 = StrdupW(lpApplyCandInfo->lpwstrDisplay);
				}
				if(lpApplyCandInfo->lpwstrReading) {
					m_ntfyDataApplyCandEx.lpwstrCreated2 = StrdupW(lpApplyCandInfo->lpwstrReading);
				}
			}
			::SetTimer(m_hwndIF, TIMERID_NOTIFY_APPLYCANDIDATEEX, TIMERELAPS_NOTIFY, NULL);
		}
		break;
	case IMEPADNOTIFY_MODECHANGED:
		break;
	case IMEPADNOTIFY_STARTCOMPOSITION:
		break;
	case IMEPADNOTIFY_COMPOSITION:
		break;
	case IMEPADNOTIFY_ENDCOMPOSITION:
		break;
	case IMEPADNOTIFY_OPENCANDIDATE:
		break;
	case IMEPADNOTIFY_CLOSECANDIDATE:
		break;
	default:
		break;
	}
	return 0;
	Unref(hr);
	Unref(wParam);
	Unref(lParam);
}

INT
CImePadSvrUIM_Sharemem::GetAppletConfigList(DWORD dwMask,
										INT *pCountApplet,
										IMEPADAPPLETCONFIG **ppList)
{
	DBG(("CImePadSvrUIM_Sharemem::GetAppletConfigList START\n"));
	if(!m_lpIImePadServer) {
		DBG(("-->m_lpIImePadServer is NULL\n"));
		return -1;
	}
	HRESULT hr;
	hr = m_lpIImePadServer->GetAppletConfigList(dwMask,
												(UINT *)pCountApplet,
												ppList);
	DBG(("CImePadSvrUIM_Sharemem::GetAppletConfigList END\n"));
	return hr;
}

IUnknown *
CImePadSvrUIM_Sharemem::SetIUnkIImeIPoint(IUnknown *pIUnkIImeIPoint)
{
	return m_lpIUnkIImeIPoint = pIUnkIImeIPoint;
}

IUnknown *
CImePadSvrUIM_Sharemem::SetIUnkIImeCallback(IUnknown *pIUnkIImeCallback)
{
	return m_lpIUnkIImeCallback = pIUnkIImeCallback;
}

IUnknown*
CImePadSvrUIM_Sharemem::GetIUnkIImeIPoint(VOID)
{
	return m_lpIUnkIImeIPoint;
}

IUnknown*
CImePadSvrUIM_Sharemem::GetIUnkIImeCallback(VOID)
{
	return m_lpIUnkIImeCallback;
}


//----------------------------------------------------------------
//
//private static method
//
//----------------------------------------------------------------

IImePadServer*
CImePadSvrUIM_Sharemem::CreateObject(VOID)
{
	DBG(("CImePadSvrUIM_Sharemem::CreateObject START\n"));
	typedef LPVOID (WINAPI * LPFN_CREATEOBJECT2)(DWORD dwIntanceID, DWORD *pdwTLS);

	LPTSTR lpPath = (LPTSTR)MemAlloc(sizeof(TCHAR)*MAX_PATH);
	if(!lpPath) {
		DBG(("-->Outof Memory ??\n"));
		return NULL;
	}

	if(0 !=  this->CLSID2ModuleName(IID_IImePadServerSHM,
									FALSE,
									lpPath,
									sizeof(TCHAR)*MAX_PATH)) {
		DBG(("-->Cannot found proxy\n"));
		goto LError;
	}
	if(!m_hModuleProxyStub) {
		m_hModuleProxyStub= ::LoadLibrary(lpPath);
	}
	DBG(("-->lpPath [%s]\n", lpPath));

	if(!m_hModuleProxyStub) {
		DBG(("CImePadSvrUIM_Sharemem::CreateObject START\n"));
		goto LError;
	}

	LPFN_CREATEOBJECT2 lpfn;
	lpfn = (LPFN_CREATEOBJECT2)::GetProcAddress(m_hModuleProxyStub, "CreateObject2");
	if(!lpfn) {
		DBG(("-->GetProcAddress Error \n"));
		goto LError;
	}
	m_lpIImePadServer = (IImePadServer *)(*lpfn)(0, NULL);
	DBG(("CImePadSvrUIM_Sharemem::CreateObject m_lpIImePadServer[0x%08x]\n", m_lpIImePadServer));
	return m_lpIImePadServer;

 LError:
	if(lpPath) {
		MemFree(lpPath);
	}
	DBG(("CImePadSvrUIM_Sharemem::CreateObject Error END\n"));
	return NULL;
} 

LRESULT CALLBACK
CImePadSvrUIM_Sharemem::ClientWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPCImePadSvrUIM_Sharemem lpCImePadSvr = NULL;
	switch(uMsg) {
#ifdef UNDER_CE
	case WM_CREATE:
		lpCImePadSvr = (LPCImePadSvrUIM_Sharemem)((LPCREATESTRUCT)lParam)->lpCreateParams;
		WinSetUserPtr(hwnd, (LPVOID)lpCImePadSvr);
		if(lpCImePadSvr) {
			return lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	case WM_DESTROY:
		lpCImePadSvr = (LPCImePadSvrUIM_Sharemem)WinGetUserPtr(hwnd);
		if(lpCImePadSvr) {
			lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		WinSetUserPtr(hwnd, (LPVOID)NULL);
		break;
#else //!UNDER_CE
	case WM_NCCREATE:
		lpCImePadSvr = (LPCImePadSvrUIM_Sharemem)((LPCREATESTRUCT)lParam)->lpCreateParams;
		WinSetUserPtr(hwnd, (LPVOID)lpCImePadSvr);
		break;
	case WM_NCDESTROY:
		WinSetUserPtr(hwnd, (LPVOID)NULL);
		break;
#endif //UNDER_CE
	default:
		lpCImePadSvr = (LPCImePadSvrUIM_Sharemem)WinGetUserPtr(hwnd);
		if(lpCImePadSvr) {
			return lpCImePadSvr->RealWndProc(hwnd, uMsg, wParam, lParam);
		}
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT
CImePadSvrUIM_Sharemem::RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg) {
	case WM_CREATE:
		DBG(("CImePadSvrUIM_Sharemem::WM_CREATE\n"));
		return 1;
	case WM_TIMER:
		return MsgTimer(hwnd, wParam, lParam);
	case WM_USER_UPDATECONTEXT:
		{
			IImeIPoint1 *lpIImeIPoint = NULL;
			if(!m_lpIUnkIImeIPoint) {
				DBG(("--> m_lpIUnkIImeIPoint is NULL\n"));
				return E_FAIL;
			}
			if(IsBadVtblUIM((IUnkDummy *)m_lpIUnkIImeIPoint)) {
				return E_FAIL;
			}

			HRESULT hr = m_lpIUnkIImeIPoint->QueryInterface(IID_IImeIPoint1,
															(VOID **)&lpIImeIPoint);
			if(hr != S_OK) {
				DBG(("QuertyInterface Failed\n"));
				return E_FAIL;
			}
			if(!lpIImeIPoint) {
				DBG(("lpIImeIPoint is NULL\n"));
				return 0;
			}
			//Check current IImeIPoint is same with lParam's IImeIPoint.
			//990715:Fixed KOTAE #1563. 
			//In 16bit application wParam's HIWORD is always 0x0000 !!!!!
			//So, Use LParam.
			if((IImeIPoint1 *)lParam == lpIImeIPoint) {
				DBG(("Call UpdateContext\n"));
				lpIImeIPoint->UpdateContext(TRUE);
			}
			else {
				DBG(("lpIImeIPoint is different lParam[0x%08x]\n", lParam));
			}
			lpIImeIPoint->Release();
		}
		break;
	default:
		break;
	}
	return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT
CImePadSvrUIM_Sharemem::MsgTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	HRESULT hr;
	switch(wParam) {
	case TIMERID_NOTIFY_ACTIVATECONTEXT:
		::KillTimer(hwnd, wParam);
		if(!m_lpIImePadServer) {
			return -1;
		}
		m_lpIImePadServer->Notify(IMEPADNOTIFY_ACTIVATECONTEXT,
								  (WPARAM)m_fLastActiveCtx,
								  (LPARAM)0);
		break;
	case TIMERID_NOTIFY_APPLYCANDIDATE:
		::KillTimer(hwnd, wParam);
		if(!m_lpIImePadServer) {
			return -1;
		}
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_APPLYCANDIDATE,
										  m_ntfyDataApplyCand.dwCharID,
										  0,
										  0,
										  0);
		m_ntfyDataApplyCand.dwCharID = 0;
		break;
	case TIMERID_NOTIFY_QUERYCANDIDATE:
		::KillTimer(hwnd, wParam);
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_QUERYCANDIDATE,
										  m_ntfyDataQueryCand.dwCharID,
										  m_ntfyDataQueryCand.dwSelIndex,
										  0,
										  0);
		m_ntfyDataQueryCand.dwCharID   = 0;
		m_ntfyDataQueryCand.dwSelIndex = 0;
		break;
	case TIMERID_NOTIFY_APPLYCANDIDATEEX:
		::KillTimer(hwnd, wParam);
		m_lpIImePadServer->NotifyWithData(IMEPADNOTIFY_APPLYCANDIDATE_EX,
										  m_ntfyDataApplyCandEx.dwCharID,
										  0,
										  m_ntfyDataApplyCandEx.lpwstrCreated1,
										  m_ntfyDataApplyCandEx.lpwstrCreated2);
		if(m_ntfyDataApplyCandEx.lpwstrCreated1) {
			MemFree(m_ntfyDataApplyCandEx.lpwstrCreated1);
		}
		if(m_ntfyDataApplyCandEx.lpwstrCreated2) {
			MemFree(m_ntfyDataApplyCandEx.lpwstrCreated2);
		}
		m_ntfyDataApplyCandEx.lpwstrCreated1 = NULL;
		m_ntfyDataApplyCandEx.lpwstrCreated2 = NULL;

		break;
	default:
		::KillTimer(hwnd, wParam);
		break;
	}
	return 0;
	Unref(hr);
	Unref(hwnd);
	Unref(wParam);
	Unref(lParam);
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrUIM_Sharemem::CreateIFHWND
// Type		:	HWND
// Purpose	:	Create interface size 0 window.
// Args		:	None
// Return	:	
// DATE		:	Mon May 17 23:01:19 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
HWND
CImePadSvrUIM_Sharemem::CreateIFHWND(VOID)
{
	DBG(("CImePadSvrUIM_Sharemem::CreateIFHWND START\n"));
	if(m_hwndIF && ::IsWindow(m_hwndIF)) {
		return m_hwndIF;
	}
	ATOM atom;
	HWND hwnd;

#ifndef UNDER_CE // No Ex
	WNDCLASSEX wc;
#else // UNDER_CE
	WNDCLASS wc;
#endif // UNDER_CE

#ifndef UNDER_CE // No Ex
	wc.cbSize = sizeof(wc);
#endif // UNDER_CE
	wc.style			= 0;
	wc.lpfnWndProc		= (WNDPROC)CImePadSvrUIM_Sharemem::ClientWndProc;
	wc.cbClsExtra		= 0;
	wc.cbWndExtra		= 0; 
	wc.hInstance		= m_hModClient;
	wc.hIcon			= (HICON)NULL;
	wc.hCursor			= (HCURSOR)NULL; 
	wc.hbrBackground	= (HBRUSH)NULL;
	wc.lpszMenuName		= NULL;
	wc.lpszClassName	= SZ_IMEPADIFCLASS;
#ifndef UNDER_CE // No Ex
	wc.hIconSm			= NULL;

	atom = ::RegisterClassEx(&wc);
#else // UNDER_CE
	atom = ::RegisterClass(&wc);
#endif // UNDER_CE
	hwnd = ::CreateWindowEx(0,
							SZ_IMEPADIFCLASS,
							NULL,
							WS_POPUP | WS_DISABLED,
							0,0,0,0,
							NULL,
							NULL,
							m_hModClient,
							(LPVOID)this);
	if(!hwnd) {
		DBG(("CreateWindowEx Error %d\n", GetLastError()));
	}
	m_hwndIF = hwnd;
	DBG(("CImePadSvrUIM_Sharemem::CreateIFHWND END\n"));
	return hwnd;
}

//////////////////////////////////////////////////////////////////
// Function	:	CImePadSvrUIM_Sharemem::DestroyIFHWND
// Type		:	BOOL
// Purpose	:	Destroy interface window.
// Args		:	
//			:	BOOL	fReserved	
// Return	:	
// DATE		:	Mon May 17 23:02:43 1999
// Histroy	:	
//////////////////////////////////////////////////////////////////
BOOL
CImePadSvrUIM_Sharemem::DestroyIFHWND(BOOL fReserved)
{
	//DBG(("CImePadSvrUIM_Sharemem::DestroyIFHWND() START\n"));
	if(m_hwndIF && ::IsWindow(m_hwndIF)) {
		::DestroyWindow(m_hwndIF);
		m_hwndIF = NULL;
	}
	//Must Unregister class. 
	BOOL fRet = ::UnregisterClass(SZ_IMEPADIFCLASS, m_hModClient);
	if(!fRet) {
		if(::GetLastError() != ERROR_CLASS_DOES_NOT_EXIST) {
			DBG(("UnregisterClass Unknown error [%d]\n", GetLastError()));
		}
	}
	//DBG(("CImePadSvrUIM_Sharemem::DestroyIFHWND() END\n"));
	return TRUE;
	Unref(fReserved);
}

INT
CImePadSvrUIM_Sharemem::CLSID2Str(REFCLSID refclsid, TCHAR *szBuf)
{
	wsprintf(szBuf, TEXT("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), 
			 refclsid.Data1,
			 refclsid.Data2,
			 refclsid.Data3,
			 refclsid.Data4[0],
			 refclsid.Data4[1],
			 refclsid.Data4[2],
			 refclsid.Data4[3],
			 refclsid.Data4[4],
			 refclsid.Data4[5],
			 refclsid.Data4[6],
			 refclsid.Data4[7]);
	return 0;
}

//////////////////////////////////////////////////////////////////
// Function : CLSID2ModuleName
// Type     : INT
// Purpose  : Get module path from CLSID. only gets InprocServer32
//			: Path.
// Args     : 
//          : REFCLSID refclsid 
//			: BOOL fLocalSvr;
//          : TCHAR szPath 
//          : INT cbSize 
// Return   : 
// DATE     : Thu Apr 16 02:48:05 1998
// Author   : 
//////////////////////////////////////////////////////////////////
#define MAX_CLSIDNAME 64
INT
CImePadSvrUIM_Sharemem::CLSID2ModuleName(REFCLSID refclsid, BOOL fLocalSvr, TCHAR *szPath, INT cbSize)
{
	//DBG(("CImePadSvrUIM_Sharemem::CLSID2ModuleName START\n"));
	static TCHAR szCLSID[MAX_CLSIDNAME];
	static TCHAR szServerKey[256];

	CLSID2Str(refclsid, szCLSID);
	DBG(("-->szCLSID [%s]\n", szCLSID));

	if(fLocalSvr) {
		wsprintf(szServerKey, TEXT("CLSID\\%s\\LocalServer32"), szCLSID);
	}
	else {
		wsprintf(szServerKey, TEXT("CLSID\\%s\\InprocServer32"), szCLSID);
	}

	INT ret;
	HKEY hKey;
	ret = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
						 szServerKey,
						 0, 
						 KEY_READ, //ALL_ACCESS,
						 &hKey);
	if(ret != ERROR_SUCCESS) {
		DBG(("-->RegOpenKeyEx Failed\n", ret));
		return ret;
	}
	ULONG size = cbSize;
	ret = ::RegQueryValueEx(hKey,
							NULL,
							NULL,
							NULL,
							(LPBYTE)szPath, &size);
	if(ret != ERROR_SUCCESS) {
		DBG(("-->RegQueryValueEx Failed\n", ret));
		::RegCloseKey(hKey);
		return ret;
	}
	::RegCloseKey(hKey);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\enum.cpp ===
/****************************************************************************
   Enum.cpp : implementation of Busu/Stroke Enumeration functions

   Copyright 2000 Microsoft Corp.

   History:
	  07-FEB-2000 bhshin  created
****************************************************************************/
#include "private.h"
#include "Enum.h"
#include "Lookup.h"
#include "Hanja.h"
#include "..\common\trie.h"

// GetMaxBusu
// 
// get the maximum busu sequence number
//
// Parameters:
//  pLexMap -> (MAPFILE*) ptr to lexicon map struct
//
// Result:
//  (number of busu, -1 if error occurs)
//
// 08FEB2000  bhshin  began
short GetMaxBusu(MAPFILE *pLexMap)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	short cBusu;
		
	// parameter validation
	if (pLexMap == NULL)
		return -1;

	if (pLexMap->pvData == NULL)
		return -1;

	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	// lookup BusuInfo table
	cBusu = *(pLex + pLexHeader->rgnBusuInfo);

	return cBusu;
}

// GetMaxStroke
// 
// get the maximum stroke number
//
// Parameters:
//  pLexMap -> (MAPFILE*) ptr to lexicon map struct
//
// Result:
//  (max stroke number, -1 if error occurs)
//
// 08FEB2000  bhshin  began
short GetMaxStroke(MAPFILE *pLexMap)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	short cStroke, nMaxStroke;
	
	// parameter validation
	if (pLexMap == NULL)
		return -1;

	if (pLexMap->pvData == NULL)
		return -1;

	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	// lookup StrokeHead table
	cStroke = *(pLex + pLexHeader->rgnStrokeHead);

	_STROKE_HEAD *pStrokeHead = (_STROKE_HEAD*)(pLex + pLexHeader->rgnStrokeHead + 1);

	// get the max stroke
	nMaxStroke = pStrokeHead[cStroke-1].bStroke;

	return nMaxStroke;
}

// GetFirstBusuHanja
// 
// get the first hanja of input busu
//
// Parameters:
//  pLexMap -> (MAPFILE*) ptr to lexicon map struct
//  nBusuID -> (short) busu id
//  pwchFirst -> (WCHAR*) output first hanja with input busu ID
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 07FEB2000  bhshin  began
BOOL GetFirstBusuHanja(MAPFILE *pLexMap, short nBusuID, WCHAR *pwchFirst)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	short cBusuID;

	*pwchFirst = NULL;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;

	if (nBusuID <= 0)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	// lookup BusuHead table to get the Busu Code ID
	cBusuID = *(pLex + pLexHeader->rgnBusuHead);
	if (nBusuID >= cBusuID)
		return FALSE;

	_BUSU_HEAD *pBusuHead = (_BUSU_HEAD*)(pLex + pLexHeader->rgnBusuHead + 1);

	*pwchFirst = pBusuHead[nBusuID-1].wchHead;

	return TRUE;
}

// GetNextBusuHanja
// 
// get the next same busu hanja
//
// Parameters:
//  pLexMap  -> (MAPFILE*) ptr to lexicon map struct
//  wchHanja -> (int) current hanja 
//  pwchNext -> (WCHAR*) output next hanja with same busu
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 07FEB2000  bhshin  began
BOOL GetNextBusuHanja(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *pwchNext)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	DWORD dwOffset;
	DWORD dwIndex;

	*pwchNext = NULL;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	dwOffset = pLexHeader->rgnHanja;

	if (fIsExtAHanja(wchHanja))
	{
		dwIndex = (wchHanja - HANJA_EXTA_START);
	}
	else if (fIsCJKHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += (wchHanja - HANJA_CJK_START);
	}
	else if (fIsCompHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += HANJA_CJK_END - HANJA_CJK_START + 1;
		dwIndex += (wchHanja - HANJA_COMP_START);
	}
	else
	{
		// unknown input
		return FALSE;
	}

	_HANJA_INFO *pHanjaInfo = (_HANJA_INFO*)(pLex + dwOffset);

	*pwchNext = pHanjaInfo[dwIndex].wchNextBusu;

	return TRUE;
}

// GetFirstStrokeHanja
// 
// get the first hanja of input stroke
//
// Parameters:
//  pLexMap   -> (MAPFILE*) ptr to lexicon map struct
//  nStroke   -> (int) stroke number
//  pwchFirst -> (WCHAR*) output first hanja with input stroke
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 07FEB2000  bhshin  began
BOOL GetFirstStrokeHanja(MAPFILE *pLexMap, short nStroke, WCHAR *pwchFirst)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	short cStroke, nMaxStroke;
	
	*pwchFirst = NULL;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;

	if (nStroke < 0)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	// lookup StrokeHead table
	cStroke = *(pLex + pLexHeader->rgnStrokeHead);

	_STROKE_HEAD *pStrokeHead = (_STROKE_HEAD*)(pLex + pLexHeader->rgnStrokeHead + 1);

	// check max stroke
	nMaxStroke = pStrokeHead[cStroke-1].bStroke;
	if (nStroke > nMaxStroke)
		return FALSE;

	for (int i = 0; i < cStroke; i++)
	{
		if (pStrokeHead[i].bStroke == nStroke)
			break;
	}

	if (i == cStroke)
	{
		// not found
		*pwchFirst = NULL; 
		return FALSE;
	}

	*pwchFirst = pStrokeHead[i].wchHead;

	return TRUE;
}

// GetNextStrokeHanja
// 
// get the next same stroke hanja
//
// Parameters:
//  pLexMap -> (MAPFILE*) ptr to lexicon map struct
//  wchHanja -> (int) current hanja 
//  pwchNext -> (WCHAR*) output next hanja with same stroke
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 07FEB2000  bhshin  began
BOOL GetNextStrokeHanja(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *pwchNext)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	DWORD dwOffset;
	DWORD dwIndex;

	*pwchNext = NULL;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	dwOffset = pLexHeader->rgnHanja;

	if (fIsExtAHanja(wchHanja))
	{
		dwIndex = (wchHanja - HANJA_EXTA_START);
	}
	else if (fIsCJKHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += (wchHanja - HANJA_CJK_START);
	}
	else if (fIsCompHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += HANJA_CJK_END - HANJA_CJK_START + 1;
		dwIndex += (wchHanja - HANJA_COMP_START);
	}
	else
	{
		// unknown input
		return FALSE;
	}

	_HANJA_INFO *pHanjaInfo = (_HANJA_INFO*)(pLex + dwOffset);

	*pwchNext = pHanjaInfo[dwIndex].wchNextStroke;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\fecommon\srcuim\cpadsvus.h ===
//////////////////////////////////////////////////////////////////
// File     :	cpadsvus.h
// Purpose  :	
// 
// Date     :	Fri Apr 16 14:34:49 1999
// Author   :	ToshiaK
//
// Copyright(c) 1995-1999, Microsoft Corp. All rights reserved
//////////////////////////////////////////////////////////////////
#ifndef __C_IMEPAD_SERVER_SHARE_MEM_FOR_UIM_H__
#define __C_IMEPAD_SERVER_SHARE_MEM_FOR_UIM_H__
#include "cpadsvu.h"

class CImePadSvrUIM_Sharemem;
typedef CImePadSvrUIM_Sharemem *LPCImePadSvrUIM_Sharemem;

//----------------------------------------------------------------
//Async notify data.
//----------------------------------------------------------------
typedef struct tagIMEPADNOTIFYDATA {
	DWORD	dwCharID;
	DWORD	dwSelIndex;
	LPWSTR	lpwstrCreated1;
	LPWSTR	lpwstrCreated2;
}IMEPADNOTIFYDATA, LPIMEPADNOTIFYDATA;

interface IImePadServer;
class CImePadSvrUIM_Sharemem:public CImePadSvrUIM
{
public:
	CImePadSvrUIM_Sharemem(HINSTANCE hInst);
	~CImePadSvrUIM_Sharemem(VOID);
	virtual BOOL		IsAvailable			(VOID);
	virtual BOOL		OnIMEPadClose		(VOID);
	virtual INT			Initialize			(LANGID	imeLangID, DWORD dwImeInputID, LPVOID lpVoid);
	virtual	INT			Terminate			(LPVOID lpVoid);
	virtual INT			ForceDisConnect		(VOID);
	virtual	INT			ShowUI				(BOOL fShow);
	virtual	INT			IsVisible			(BOOL *pfVisible);
	virtual	INT			ActivateApplet		(UINT	activateID,
											 LPARAM	dwActParam,
											 LPWSTR lpwstr1,
											 LPWSTR lpwstr2);
	virtual	INT			Notify				(INT id, WPARAM wParam, LPARAM lParam);
	virtual INT			GetAppletConfigList	(DWORD	dwMask,
											 INT*	pCountApplet,
											 IMEPADAPPLETCONFIG **ppList);
	virtual IUnknown*	SetIUnkIImeIPoint	(IUnknown *pIUnk);
	virtual IUnknown*	SetIUnkIImeCallback	(IUnknown *pIUnk);
	virtual IUnknown*	GetIUnkIImeIPoint	(VOID);
	virtual IUnknown*	GetIUnkIImeCallback	(VOID);
private:
	//----------------------------------------------------------------
	//private methods.
	//----------------------------------------------------------------
	IImePadServer *			CreateObject(VOID);
	static LRESULT CALLBACK ClientWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT RealWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT MsgTimer   (HWND hwnd, WPARAM wParam, LPARAM lParam);
	HWND	CreateIFHWND	(VOID);
	BOOL	DestroyIFHWND	(BOOL fReserved);
	INT		CLSID2Str		(REFCLSID refclsid, TCHAR *szBuf);
	INT		CLSID2ModuleName(REFCLSID refclsid,
							 BOOL fLocalSvr,
							 TCHAR *szPath,
							 INT cbSize);

	//----------------------------------------------------------------
	//private member
	//----------------------------------------------------------------
	LANGID					m_imeLangID;			//Save Initialized data.
	DWORD					m_dwImeInputID;			//Save Initialized data.
	BOOL					m_fShowReqStatus;		//Save ShowUI()'s bool value.
	BOOL					m_fLastActiveCtx;		//Save IMEPADNOTIFY_ACTIVATECONTEXT
	HWND					m_hwndIF;				//Internal I/F Window handle.
	IUnknown*				m_lpIUnkIImeIPoint;		//IImeIPoint I/F pointer as IUnknown.
	IUnknown*				m_lpIUnkIImeCallback;	//IImeCallback I/F pointer as IUnknown.
	IImePadServer*			m_lpIImePadServer;		//IImePadServer I/F pointer.
	LPCImePadCallbackUIM	m_lpCImePadCallbackUIM;	//CImePadCallback instance pointer.
	LPARAM					m_dwRegAdvise;			//Callbacck interface connect cookie.
	HMODULE					m_hModuleProxyStub;		//ProxyStub dll instance handle.
	DWORD					m_dwTLSIndexForProxyStub;
	IMEPADNOTIFYDATA		m_ntfyDataApplyCand;	//for IMEPADNOTIFY_APPLYCAND	
	IMEPADNOTIFYDATA		m_ntfyDataQueryCand;	//for IMEPADNOTIFY_QUERYCAND
	IMEPADNOTIFYDATA		m_ntfyDataApplyCandEx;	//for IMEPADNOTIFY_APPLYCANDEX
};
#endif //__C_IMEPAD_SERVER_SHARE_MEM_FOR_UIM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\hjdict.cpp ===
// HjDict.cpp : Implementation of DLL Exports.
//
// History:
//		17-MAY-2000	  bhshin    removed unused method/interface for CICERO
//		02-FEB-2000   bhshin	created


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f HjDictps.mk in the project directory.

#include "private.h"
#include "resource.h"
#include <initguid.h>
#include "HjDict.h"

#include "HjDict_i.c"
#include "IHJDict.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_HJDict, CHJDict)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_HJDICTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\ibusuinfo.cpp ===
// IBusuInfo.cpp : Implementation of CBusuInfo
#include "stdafx.h"
#include "HjDict.h"
#include "IBusuInfo.h"

/////////////////////////////////////////////////////////////////////////////
// CBusuInfo

STDMETHODIMP CBusuInfo::get_Busu(long *pVal)
{
	*pVal = (long)m_wchBusu;

	return S_OK;
}

STDMETHODIMP CBusuInfo::get_BusuDesc(BSTR *pVal)
{
	*pVal = m_bstrDesc.Copy();

	return S_OK;
}

STDMETHODIMP CBusuInfo::get_Stroke(short *pVal)
{
	*pVal = m_nStroke;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\ihanjainfo.cpp ===
// IHanjaInfo.cpp : Implementation of CHanjaInfo
#include "stdafx.h"
#include "HjDict.h"
#include "IHanjaInfo.h"

/////////////////////////////////////////////////////////////////////////////
// CHanjaInfo


STDMETHODIMP CHanjaInfo::get_BusuID(short *pVal)
{
	*pVal = m_nBusuID;

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_Stroke(short *pVal)
{
	*pVal = m_nStroke;

	return S_OK;
}


STDMETHODIMP CHanjaInfo::get_StrokeExcludeBusu(short *pVal)
{
	*pVal = m_nStrokeExcludeBusu;

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_Type(HANJA_TYPE *pVal)
{
	*pVal = m_nType;

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_Meaning(BSTR *pVal)
{
	*pVal = m_bstrMeaning.Copy();

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_Explain(BSTR *pVal)
{
	*pVal = m_bstrExplain.Copy();

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_NextBusu(long *pVal)
{
	*pVal = m_wchNextBusu;

	return S_OK;
}

STDMETHODIMP CHanjaInfo::get_NextStroke(long *pVal)
{
	*pVal = m_wchNextStroke;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\ibusuinfo.h ===
// IBusuInfo.h : Declaration of the CBusuInfo

#ifndef __BUSUINFO_H_
#define __BUSUINFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CBusuInfo
class ATL_NO_VTABLE CBusuInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CBusuInfo, &CLSID_BusuInfo>,
	public IDispatchImpl<IBusuInfo, &IID_IBusuInfo, &LIBID_HJDICTLib>
{
public:
	CBusuInfo()
	{
		m_wchBusu = NULL;
		m_nStroke = 0;
		m_bstrDesc.Empty();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_BUSUINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CBusuInfo)
	COM_INTERFACE_ENTRY(IBusuInfo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Operator
public:
	void Initialize(WCHAR wchBusu, short nStroke, LPCWSTR lpcwszDesc)
	{
		m_wchBusu = wchBusu;
		m_nStroke = nStroke;
		m_bstrDesc = lpcwszDesc;
	}

// IBusuInfo
public:
	STDMETHOD(get_Stroke)(/*[out, retval]*/ short *pVal);
	STDMETHOD(get_BusuDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Busu)(/*[out, retval]*/ long *pVal);

// Data members
protected:
	WCHAR m_wchBusu;
	short m_nStroke;
	CComBSTR m_bstrDesc; 
};

#endif //__BUSUINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\hanja.h ===
/****************************************************************************
   Hanja.cpp : declaration of Hanja definition and utility functions

   Copyright 2000 Microsoft Corp.

   History:
	  02-FEB-2000 bhshin  created
****************************************************************************/

#ifndef _HANJA_HEADER
#define _HANJA_HEADER

// CJK Unified Ideograph
#define  HANJA_CJK_START	0x4E00
#define  HANJA_CJK_END		0x9FA5

// CJK Compatibility Ideograph
#define  HANJA_COMP_START	0xF900
#define  HANJA_COMP_END		0xFA2D

// CJK Unified Ideograph Extension A
#define  HANJA_EXTA_START   0x3400
#define  HANJA_EXTA_END		0x4DB5

// Pre-composed HANGUL
#define  HANGUL_PRECOMP_BASE 0xAC00
#define  HANGUL_PRECOMP_MAX  0xD7A3

__inline
BOOL fIsHangulSyllable(WCHAR wch)
{
    return (wch >= HANGUL_PRECOMP_BASE && wch <= HANGUL_PRECOMP_MAX) ? TRUE : FALSE;
}

__inline
BOOL fIsCJKHanja(WCHAR wch)
{
	return (wch >= HANJA_CJK_START && wch <= HANJA_CJK_END) ? TRUE : FALSE;
}

__inline
BOOL fIsCompHanja(WCHAR wch)
{
	return (wch >= HANJA_COMP_START && wch <= HANJA_COMP_END) ? TRUE : FALSE;
}

__inline
BOOL fIsExtAHanja(WCHAR wch)
{
	return (wch >= HANJA_EXTA_START && wch <= HANJA_EXTA_END) ? TRUE : FALSE;
}

__inline
BOOL fIsHanja(WCHAR wch)
{
	return (fIsCJKHanja(wch) || fIsCompHanja(wch) || fIsExtAHanja(wch)) ? TRUE : FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\ihjdict.h ===
/****************************************************************************
   IHJDict.h : Declaration of the CHJDict

   Copyright 2000 Microsoft Corp.

   History:
      02-AUG-2000 bhshin  remove unused method for Hand Writing team
	  17-MAY-2000 bhshin  remove unused method for CICERO
	  02-FEB-2000 bhshin  created
****************************************************************************/

#ifndef __HJDICT_H_
#define __HJDICT_H_

#include "resource.h"       // main symbols
#include "Lex.h"

/////////////////////////////////////////////////////////////////////////////
// CHJDict
class ATL_NO_VTABLE CHJDict : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CHJDict, &CLSID_HJDict>,
	public IHJDict
{
public:
	CHJDict()
	{
		m_fLexOpen = FALSE;
	}

	~CHJDict();

DECLARE_REGISTRY_RESOURCEID(IDR_HJDICT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHJDict)
	COM_INTERFACE_ENTRY(IHJDict)
END_COM_MAP()

// IHJDict
public:
	STDMETHOD(Init)();
	STDMETHOD(LookupMeaning)(/*[in]*/ WCHAR wchHanja, /*[out]*/ LPWSTR pwszMeaning, /*[in]*/ int cchMeaning);
	STDMETHOD(LookupHangulOfHanja)(/*[in]*/ LPCWSTR pwszHanja, /*[out]*/ LPWSTR pwszHangul, /*[in]*/ int cchHangul);

// Member Data
protected:
	BOOL m_fLexOpen;  // main dict open flag
	MAPFILE m_LexMap; // lexicon handle
};

#endif //__HJDICT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\ihjdict.cpp ===
/****************************************************************************
   IHJDict.cpp : Implementation of CHJDict

   Copyright 2000 Microsoft Corp.

   History:
      02-AUG-2000 bhshin  remove unused method for Hand Writing team
	  17-MAY-2000 bhshin  remove unused method for CICERO
	  02-FEB-2000 bhshin  created
****************************************************************************/
#include "private.h"
#include "HjDict.h"
#include "IHJDict.h"
#include "Lookup.h"
#include "..\inc\common.h"

// maximum output buffer size
#define	MAX_OUT_BUFFER		512
#define SZLEX_FILENAME		"hanja.lex"

/////////////////////////////////////////////////////////////////////////////
// CHJDict

// CHJDict::~CHjDict
// 
// load main lexicon
//
// Parameters:
//  lpcszPath -> (LPCSTR) lexicon path
//
// Result:
//  (HRESULT)
//
// 02AUG2000  bhshin  began
CHJDict::~CHJDict()
{
	if (m_fLexOpen)
		CloseLexicon(&m_LexMap);
}


// CHJDict::Init
// 
// load main lexicon
//
// Parameters:
//  lpcszPath -> (LPCSTR) lexicon path
//
// Result:
//  (HRESULT)
//
// 02FEB2000  bhshin  began
STDMETHODIMP CHJDict::Init()
{
	CHAR  szLexPath[256], szLexPathExpanded[256]		;
	HKEY  hKey;
	DWORD dwCb, dwType;

	if (m_fLexOpen)
	{
		CloseLexicon(&m_LexMap);
		m_fLexOpen = FALSE;
	}

	// default value
	lstrcpy(szLexPath, "%WINDIR%\\IME\\IMKR6_1\\Dicts\\");

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szIMEDirectoriesKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		dwCb = sizeof(szLexPath);
		dwType = REG_EXPAND_SZ;

		RegQueryValueEx(hKey, g_szDicPath, NULL, &dwType, (LPBYTE)szLexPath, &dwCb);
		RegCloseKey(hKey);
	}

	ExpandEnvironmentStrings(szLexPath, szLexPathExpanded, sizeof(szLexPathExpanded));
    if (szLexPathExpanded[lstrlen(szLexPathExpanded)-1] != '\\')
    	lstrcat(szLexPathExpanded, "\\");
	lstrcat(szLexPathExpanded, SZLEX_FILENAME);

	if (!OpenLexicon(szLexPathExpanded, &m_LexMap))
		return E_FAIL;

	m_fLexOpen = TRUE;

	return S_OK;
}

// CHJDict::LookupHangulOfHanja
// 
// lookup hangul of input hanja string 
//
// Parameters:
//  pwszHanja    -> (LPCWSTR) input hanja string
//  pwszHangul  -> (WCHAR *) output hangul string
//  cchHangul    -> (int) output buffer size
//
// Result:
//  (HRESULT)
//
// 02FEB2000  bhshin  began
STDMETHODIMP CHJDict::LookupHangulOfHanja(LPCWSTR pwszHanja, 
										  WCHAR *pwszHangul,
										  int cchHangul)
{
	int cchHanja;
	BOOL fLookup;
	
	cchHanja = wcslen(pwszHanja);
	if (cchHanja == 0)
		return E_FAIL;

	// output buffer insufficient
	if (cchHangul < cchHanja)
		return E_FAIL;

	fLookup = ::LookupHangulOfHanja(&m_LexMap, pwszHanja, cchHanja, pwszHangul, cchHangul);
	if (!fLookup)
		return E_FAIL; // it shoud be found

	return S_OK;
}

// CHJDict::LookupMeaning
// 
// lookup hanja meaning
//
// Parameters:
//  wchHanja    -> (WCHAR) input hanja unicode
//  pwszMeaning -> (LPWSTR) output meaning
//  cchMeaning  -> (int) output buffer size
//
// Result:
//  (HRESULT)
//
// 09FEB2000  bhshin  began
STDMETHODIMP CHJDict::LookupMeaning(WCHAR wchHanja, LPWSTR pwszMeaning, int cchMeaning)
{
	BOOL fLookup;

	fLookup = ::LookupMeaning(&m_LexMap, (WCHAR)wchHanja, pwszMeaning, cchMeaning);
	if (!fLookup)
		return E_FAIL;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\ihanjainfo.h ===
// IHanjaInfo.h : Declaration of the CHanjaInfo

#ifndef __HANJAINFO_H_
#define __HANJAINFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CHanjaInfo
class ATL_NO_VTABLE CHanjaInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CHanjaInfo, &CLSID_HanjaInfo>,
	public IDispatchImpl<IHanjaInfo, &IID_IHanjaInfo, &LIBID_HJDICTLib>
{
public:
	CHanjaInfo()
	{
		m_nBusuID = -1;
		m_nStroke = -1;
		m_nStrokeExcludeBusu = -1;
		m_nType = HANJA_UNKNOWN;
		m_bstrMeaning.Empty();
		m_bstrExplain.Empty();
		m_wchNextBusu = NULL;
		m_wchNextStroke = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_HANJAINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHanjaInfo)
	COM_INTERFACE_ENTRY(IHanjaInfo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// Operator
public:
	void Initialize(short BusuID, short Stroke, short StrokeExcludeBusu, short Type,
		            LPCWSTR lpcwszMean, LPCWSTR lpcwszExplain, 
					WCHAR wchNextBusu, WCHAR wchNextStroke)
	{
		m_nBusuID = BusuID;
		m_nStroke = Stroke;
		m_nStrokeExcludeBusu = StrokeExcludeBusu;
		m_nType = (HANJA_TYPE)Type;
		m_bstrMeaning = lpcwszMean;
		m_bstrExplain = lpcwszExplain;
		m_wchNextBusu = wchNextBusu;
		m_wchNextStroke = wchNextStroke;
	}

// IHanjaInfo
public:
	STDMETHOD(get_NextStroke)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_NextBusu)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_Explain)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Meaning)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Type)(/*[out, retval]*/ HANJA_TYPE *pVal);
	STDMETHOD(get_StrokeExcludeBusu)(/*[out, retval]*/ short *pVal);
	STDMETHOD(get_Stroke)(/*[out, retval]*/ short *pVal);
	STDMETHOD(get_BusuID)(/*[out, retval]*/ short *pVal);

// Data members
protected:
	short m_nBusuID;
	short m_nStroke;
	short m_nStrokeExcludeBusu;
	HANJA_TYPE m_nType;
	CComBSTR m_bstrMeaning;
	CComBSTR m_bstrExplain;
	WCHAR m_wchNextBusu;
	WCHAR m_wchNextStroke;
};

#endif //__HANJAINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\lex.cpp ===
/****************************************************************************
   Lex.cpp : lexicon management functions

   Copyright 2000 Microsoft Corp.

   History:
      17-MAY-2000 bhshin  changed signature for CICERO
	  02-FEB-2000 bhshin  created
****************************************************************************/

#include "private.h"
#include "Lex.h"

// OpenLexicon
// 
// map the lexicon file into memory
//
// Parameters:
//  lpcszLexPath -> (LPCSTR) lexicon path
//  pLexMap      -> (MAPFILE*) ptr to lexicon map struct
//
// Result:
//  (TRUE if success, FALSE if failure)
//
// 02FEB2000  bhshin  began
BOOL OpenLexicon(LPCSTR lpcszLexPath, MAPFILE *pLexMap)
{
    char *pData;
    unsigned short nVersion;

    pLexMap->hFile = NULL;
    pLexMap->hFileMapping = NULL;
    pLexMap->pvData = NULL;

    // open the file for reading
    pLexMap->hFile = CreateFile(lpcszLexPath, GENERIC_READ, FILE_SHARE_READ, NULL,
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (pLexMap->hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    // create a file mapping
    pLexMap->hFileMapping = CreateFileMappingA(pLexMap->hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (pLexMap->hFileMapping == NULL)
        return FALSE;

    // map the entire file for reading
    pLexMap->pvData = MapViewOfFileEx(pLexMap->hFileMapping, FILE_MAP_READ, 0, 0, 0, 0);
    if (pLexMap->pvData == NULL)
        return FALSE;

    // check the version # in the first 2 bytes (swap bytes)
    pData = (char*)pLexMap->pvData;
    nVersion = pData[0];
    nVersion |= (pData[1] << 8);
    if (nVersion < LEX_VERSION)
    {
        return FALSE;
    }

	// check the magic signature
	if (strcmp(pData+2, "HJKO") != 0)
	{
		return FALSE;
	}

    return TRUE;
}

// CloseLexicon
// 
// unmap the lexicon file into memory
//
// Parameters:
//  pLexMap  -> (MAPFILE*) ptr to lexicon map struct
//
// Result:
//  (void)
//
// 02FEB2000  bhshin  began
void CloseLexicon(MAPFILE *pLexMap)
{
    if (pLexMap->pvData != NULL)
        UnmapViewOfFile(pLexMap->pvData);

    if (pLexMap->hFileMapping != NULL)
        CloseHandle(pLexMap->hFileMapping);
    
	if (pLexMap->hFile != NULL)
        CloseHandle(pLexMap->hFile);

    pLexMap->hFile = NULL;
    pLexMap->hFileMapping = NULL;
    pLexMap->pvData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\lex.h ===
/****************************************************************************
   Lex.h : lexicon structure and declaration of lexicon management functions

   Copyright 2000 Microsoft Corp.

   History:
      02-AUG-2000 bhshin  remove unused dict for Hand Writing team
	  17-MAY-2000 bhshin  remove unused dict for CICERO
	  02-FEB-2000 bhshin  created
****************************************************************************/

#ifndef _LEX_HEADER
#define _LEX_HEADER

// current lexicon version
#define LEX_VERSION 0x0040

// Lexicon Header Structure
// ========================
typedef struct {
	unsigned short nVersion;
	char szMagic[4];
	unsigned short nPadding;
	unsigned long rgnHanjaIdx;			// offset to hanja index (needed for just K1 lex)
    unsigned long rgnReading;			// offset to Hanja Reading
    unsigned long rgnMeanIdx;			// offset to meaning index
	unsigned long rgnMeaning;			// offset to meaning trie
} LEXICON_HEADER;

// MapFile structure
// =================
typedef struct {
    HANDLE hFile;
    HANDLE hFileMapping;
    void *pvData;
} MAPFILE, *pMAPFILE;

// Lexicon Open/Close functions
// ============================
BOOL OpenLexicon(LPCSTR lpcszLexPath, MAPFILE *pLexMap);
void CloseLexicon(MAPFILE *pLexMap);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\lookup.cpp ===
/****************************************************************************
   Lookup.cpp : implementation of various lookup functions

   Copyright 2000 Microsoft Corp.

   History:
   		02-AUG-2000 bhshin  remove unused method for Hand Writing team
		17-MAY-2000 bhshin  remove unused method for CICERO
		02-FEB-2000 bhshin  created
****************************************************************************/
#include "private.h"
#include "Lookup.h"
#include "Hanja.h"
#include "trie.h"


// LookupHanjaIndex
// 
// get the hanja index with code value
// it's needed for just K0/K1 lex
//
// Parameters:
//  pLexMap      -> (MAPFILE*) ptr to lexicon map struct
//  wchHanja     -> (WCHAR) hanja unicode
//
// Result:
//  (-1 if not found, otherwise return index value)
//
// 02FEB2000  bhshin  began
int LookupHanjaIndex(MAPFILE *pLexMap, WCHAR wchHanja)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	DWORD dwOffset;
	DWORD dwIndex;
	unsigned short *pIndex;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	dwOffset = pLexHeader->rgnHanjaIdx;

	if (fIsExtAHanja(wchHanja))
	{
		dwIndex = (wchHanja - HANJA_EXTA_START);
	}
	else if (fIsCJKHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += (wchHanja - HANJA_CJK_START);
	}
	else if (fIsCompHanja(wchHanja))
	{
		dwIndex = HANJA_EXTA_END - HANJA_EXTA_START + 1;
		dwIndex += HANJA_CJK_END - HANJA_CJK_START + 1;
		dwIndex += (wchHanja - HANJA_COMP_START);
	}
	else
	{
		// unknown input
		return -1;
	}

	pIndex = (WCHAR*)(pLex + dwOffset);

	return pIndex[dwIndex];
}

// HanjaToHangul
// 
// lookup Hanja reading
//
// Parameters:
//  pLexMap      -> (MAPFILE*) ptr to lexicon map struct
//
// Result:
//  (NULL if error, otherwise matched Hangul)
//
// 02FEB2000  bhshin  began
WCHAR HanjaToHangul(MAPFILE *pLexMap, WCHAR wchHanja)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	DWORD dwOffset;
	int nIndex;
	WCHAR *pwchReading;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	dwOffset = pLexHeader->rgnReading;

	nIndex = LookupHanjaIndex(pLexMap, wchHanja);
	if (nIndex == -1)
	{
		return NULL; // not found;
	}

	pwchReading = (WCHAR*)(pLex + dwOffset);

	return pwchReading[nIndex];
}

// LookupHangulOfHanja
// 
// lookup hangul of input hanja string 
//
// Parameters:
//  pLexMap      -> (MAPFILE*) ptr to lexicon map struct
//  lpcwszHanja  -> (LPCWSTR) input hanja string
//  cchHanja     -> (int) length of input hanja
//  wzHangul     -> (LPWSTR) output hangul string
//  cchHangul    -> (int) output buffer size
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 02FEB2000  bhshin  began
BOOL LookupHangulOfHanja(MAPFILE *pLexMap, LPCWSTR lpcwszHanja, int cchHanja,
						 LPWSTR wzHangul, int cchHangul)
{
	WCHAR wchHangul;
	
	if (cchHangul < cchHanja)
		return FALSE; // output buffer is too small

	for (int i = 0; i < cchHanja; i++)
	{
		wchHangul = HanjaToHangul(pLexMap, lpcwszHanja[i]);

		if (wchHangul == NULL)
			return FALSE; // unknown hanja included

		wzHangul[i] = wchHangul;
	}
	wzHangul[i] = L'\0';
	
	return TRUE;
}

// LookupMeaning
// 
// lookup hanja meaning
//
// Parameters:
//  pLexMap        -> (MAPFILE*) ptr to lexicon map struct
//  wchHanja       -> (WCHAR) input hanja
//  wzMean         -> (WCHAR*) output meaning buffer
//  cchMean        -> (int) output meaning buffer size
//
// Result:
//  (FALSE if error occurs, otherwise return TRUE)
//
// 09FEB2000  bhshin  began
BOOL LookupMeaning(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *wzMean, int cchMean)
{
	unsigned char *pLex;
	LEXICON_HEADER *pLexHeader;
	int nIndex;
	TRIECTRL *lpTrieCtrl;
	BOOL fFound;
	unsigned short *pidxMean;
	int idxMean;

	// parameter validation
	if (pLexMap == NULL)
		return FALSE;

	if (pLexMap->pvData == NULL)
		return FALSE;
	
	pLex = (unsigned char*)pLexMap->pvData;
	pLexHeader = (LEXICON_HEADER*)pLexMap->pvData;

	nIndex = LookupHanjaIndex(pLexMap, wchHanja);
	if (nIndex == -1)
	{
		return FALSE; // not found;
	}

	// meaning
	pidxMean = (unsigned short*)(pLex + pLexHeader->rgnMeanIdx);
	idxMean = pidxMean[nIndex];

	lpTrieCtrl = TrieInit(pLex + pLexHeader->rgnMeaning);
	if (lpTrieCtrl == NULL)
		return FALSE;

	fFound = TrieIndexToWord(lpTrieCtrl, idxMean, wzMean, cchMean);
	if (!fFound)
	{
		wzMean[0] = L'\0';
	}

	TrieFree(lpTrieCtrl);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\lookup.h ===
/****************************************************************************
   Lookup.h : declarations of various lookup functions

   Copyright 2000 Microsoft Corp.

   History:
   		02-AUG-2000 bhshin  remove unused method for Hand Writing team
   		17-MAY-2000 bhshin  remove unused method for CICERO
		02-FEB-2000 bhshin  created
****************************************************************************/

#ifndef _LOOKUP_H
#define _LOOKUP_H

#include "Lex.h" // MAPFILE

//----------------------------------------------------------------------------
// structures for lookup lexicon
//----------------------------------------------------------------------------

int LookupHanjaIndex(MAPFILE *pLexMap, WCHAR wchHanja);

BOOL LookupHangulOfHanja(MAPFILE *pLexMap, LPCWSTR lpcwszHanja, int cchHanja,
						 LPWSTR wzHangul, int cchHangul);

BOOL LookupMeaning(MAPFILE *pLexMap, WCHAR wchHanja, WCHAR *wzMean, int cchMean);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HjDict.rc
//
#define IDS_PROJNAME                    100
#define IDR_HJDICT                      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\memmgr.cpp ===
// memmgr.c
//
// This file contains definitions for the memory management.
// Implementation details may change so beware of relying on internal details.
//

#include "private.h"
#include "memmgr.h"

#ifdef DEBUG
int cAllocMem = 0;     // Amount of memory alloced
int cAlloc = 0;        // Count of allocs outstanding
int cAllocMaxMem = 0;  // Max amount of memory ever alloced.
#endif

#ifdef  DEBUG
int	gFailure = 0;
#endif

/******************************Public*Routine******************************\
* ExternAlloc
*
* This guy keeps the size in the first long so we can fake a realloc.  Lot's
* of debug checking for heap overwrites.
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void *ExternAlloc(DWORD cb)
{
    long   *pl;
	DWORD	cbAlloc;

#ifdef  DEBUG
#ifndef WINCE
    //
    // If gFailure is 0 nothing happens, if it's non-zero we
    // fail 1 in gFailure allocations.
    //

    if (gFailure)
    {
        if (((rand() * gFailure) / (RAND_MAX + 1)) == 0)
        {
            return (void *) NULL;
        }
    }
#endif
#endif

// Since we can't use realloc on WINCE, we need to save the original size for memcpy
// in our own realloc function.

	cbAlloc = cb + 4;

#ifdef DEBUG
    cbAlloc +=  3;	// round it up to DWORD boundary
    cbAlloc &= ~3;
    cbAlloc +=  8;	// write size at begining and overwrite detector at begining and end
#endif

	pl = (long *) malloc(cbAlloc);
	if (pl == (long *) NULL)
		return pl;

// Stamp this baby full of invalid bytes so code that relies on 0's in it are sniffed out.

#ifdef DEBUG
	memset(pl,0xff,cbAlloc);
#endif

// OK, tuck the object size away at the begining

  *(pl++) = cb;

#ifdef DEBUG
  *(pl++) = 0xDEADBEEF;
    pl[(cbAlloc / 4) - 3] = 0xDEADBEEF;
    cAlloc++;
    cAllocMem += cb;

    if (cAllocMem > cAllocMaxMem)
    {
        TCHAR szDebug[128];
        cAllocMaxMem = cAllocMem;
        wsprintf(szDebug, TEXT("cAllocMaxMem = %d \r\n"), cAllocMaxMem);
        OutputDebugString(szDebug);
    }
#endif

    return pl;
}

/******************************Public*Routine******************************\
* ExternRealloc
*
* Well this not good but we want the same exact code on NT and WINCE and
* we can't find a way to use the flags and have Realloc work the same on
* both.  Realloc is a very infrequent event so this work for us.
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void *ExternRealloc(void *pv, DWORD cbNew)
{
    void   *pvNew = ExternAlloc(cbNew);

    if (pv && pvNew)
    {
        long   *pl;
        DWORD	cb;

        pl = (long *) pv;

#ifdef	DEBUG
		pl--;
#endif

        cb = (DWORD) *(--pl);
		memcpy(pvNew, pv, min(cbNew, cb));
        ExternFree(pv);
    }

	return pvNew;
}

/******************************Public*Routine******************************\
* ExternFree
*
* Free up the memory, in debug mode check for heap corruption !
*
* History:
*  19-Nov-1996 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void ExternFree(void *pv)
{
    long   *pl;

// We now allow freeing of null pointers

	if (pv == (void *) NULL)
		return;

    pl = (long *) pv;
    pl--;

#ifdef DEBUG
{
    int		cbAlloc;

// Check nothing has been stepped on.

    pl--;
    cbAlloc = *pl;
    cAllocMem -= cbAlloc;
    cbAlloc = (cbAlloc + 11) & ~3;
    cAlloc--;
}
#endif

	free(pl);
}

char *Externstrdup( const char *strSource )
{
	int		nLen = 0;
	char*	pszOut = NULL;

	// fail immediately on a null pointer
	if (NULL == strSource)
		return NULL;

	// get the length of the ansi string 
	nLen = strlen(strSource) * sizeof(char);

	// fail on a 0 length string 
	//  @todo(petewil) - is this right, or return 0 length string instead?
	if (0 == nLen)
		return NULL;

	// allow room for a trailing null
	nLen += sizeof(char);

	// allocate space for the string
	pszOut = (char*)ExternAlloc(nLen);

	if (NULL == pszOut)
		return NULL;

	// copy the string into the buffer provided
	strcpy(pszOut, strSource);

    return pszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\memmgr.h ===
// memmgr.h
//
// This file contains declarations and macros for memory management.  
// Implementation details may change so beware of relying on internal details.


#ifndef __INCLUDE_MEMMGR
#define __INCLUDE_MEMMGR

#ifdef __cplusplus
extern "C" 
{
#endif

void *ExternAlloc(DWORD cb);
void *ExternRealloc(void *pv, DWORD cb);
void  ExternFree(void *pv);

char *Externstrdup( const char *strSource );

#ifdef DEBUG
extern int cAllocMem;     // Amount of memory alloced
extern int cAlloc;        // Count of allocs outstanding
extern int cAllocMaxMem;  // Max amount of memory ever alloced.
#endif

#ifdef __cplusplus
};
#endif

#endif //__INCLUDE_MEMMGR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\private.h ===
//+---------------------------------------------------------------------------
//
//  File:       private.h
//
//  Contents:   Private header for simx project.
//
//----------------------------------------------------------------------------


#ifndef _PRIVATE_H_
#define _PRIVATE_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _OLEAUT32_

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#endif  // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C92D3440_7CB2_4583_9617_587FFBBBA100__INCLUDED_)
#define AFX_STDAFX_H__C92D3440_7CB2_4583_9617_587FFBBBA100__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C92D3440_7CB2_4583_9617_587FFBBBA100__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imkrinst\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "IMKRINST"
#define SZ_MODULE       "IMKRINST"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\trie.h ===
#ifndef TRIE_H
#define TRIE_H

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; lpbNode points to the first byte of the next node in this state, and
lpbDown points to the first byte referenced by the down pointer, if any */

typedef struct tagTAGDATA
{
	DWORD	cTag;			// Count of tagged nodes below this node in the subtree
	DWORD	dwData;			// Stored tagged data for this node
} TAGDATA;

#define MAXTAGS 8
#if MAXTAGS > 8
#error No more than 8 tags are allowed
#endif

typedef struct tagTRIESCAN
{
	WCHAR	wch;			// Unicode character
	WORD	wFlags;			// see below
	WORD	wMask;			// which tags are valid
	WORD	__pad0;			// 
	DWORD	cWords;			// Words in subtree (only valid if TRIE_NODE_COUNT is set)
	DWORD	cSkipWords;		// Words in subtrees ignored when following a skip pointer
	LPBYTE	lpbNode;		// Address of next byte within the compressed trie
	LPBYTE	lpbDown;		// Address referenced by down pointer, if any
	LPBYTE	lpbRight;		// Address referenced by right pointer, if any
	LPBYTE	lpbSRDown;		// Last single-ref address referenced
	TAGDATA	aTags[MAXTAGS];	// The list of tag counts/data
} TRIESCAN, *PTRIESCAN, *LPTRIESCAN;

// Trie node flags, only the lower 16 bits of the flags are saved in the trie

#define TRIE_NODE_VALID         0x00000001      // wch is the last letter of a valid word
#define TRIE_NODE_END           0x00000002      // Last node in the state (no more alternatives to wch)
#define TRIE_NODE_COUNT         0x00000004		// The count of words in the subtree is stored in the node
#define TRIE_NODE_TAGGED        0x00000008      // The node has tagged data
#define TRIE_NODE_DOWN          0x00000010      // iDown is valid (word so far is a valid prefix)
#define TRIE_NODE_RIGHT         0x00000020      // iRight is valid (word connects to a substate)
#define TRIE_DOWN_INLINE        0x00000040      // iDown omitted, since it points to next node in memory
#define TRIE_DOWN_MULTI         0x00000080      // iDown is a second reference or worse
#define TRIE_DOWN_ABS           0x00000100		// iDown is an absolute immediate offset into the trie
#define	TRIE_NODE_SKIP			0x00000200		// Either iRight is a skip pointer or EOS is a 'soft' EOS
#define	TRIE_NODE_SKIP_COUNT	0x00000400		// cSkipWords is valid

/* Macro to access the data in the node, works for dawgs and tries */

#define DAWGDATA(pdawg)       ((pdawg)->wch)
#define DAWGDOWNFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_DOWN)
#define DAWGENDFLAG(pdawg)    ((pdawg)->wFlags & TRIE_NODE_END)
#define DAWGWORDFLAG(pdawg)   ((pdawg)->wFlags & TRIE_NODE_VALID)

/* Fixed-length part of the compressed trie header */

typedef struct tagTRIESTATS
{
	WORD	version;						// Version of this particular compressed trie
	WORD	__pad0;							//
	BYTE	wTagsMask;						// Which tags are in use
	BYTE	wEnumMask;						// Which tags have enumeration
	BYTE	wDataMask;						// Which tags have stored data
	BYTE	cTagFields;						// Total tags in use
	WORD	cMaxWord;						// Number of characters in longest word
	WORD	cMaxState;						// Number of nodes in longest state (max alternatives)
	WORD	cCharFlagsCodesMax;             // Bytes in longest char/flags code
	WORD	cTagsCodesMax;                  // Bytes in longest tagged data code
	WORD	cMRPointersCodesMax;			// Bytes in longest MR pointer code
	WORD	cSROffsetsCodesMax;             // Bytes in longest Single-ref code
	DWORD	cWords;							// Number of words in dictionary
	DWORD	cUniqueSROffsets;               // Unique offsets in Single-ref segment
	DWORD	cUniqueCharFlags;               // Unique char/flags pairs
	DWORD	cUniqueTags;                    // Unique tagged data values
	DWORD	cUniqueMRPointers;              // Unique multi-ref pointers
	DWORD	cbHeader;						// Bytes in header & tables
	DWORD	cbTrie;							// Bytes in trie
} TRIESTATS, *PTRIESTATS, *LPTRIESTATS;

/* Primary unit of a node.  Nodes usually contain a pointer too */

typedef struct tagCHARFLAGS {
        wchar_t wch;
        short wFlags;
} CHARFLAGS, *PCHARFLAGS, *LPCHARFLAGS;

/* Control structure used to decompress the trie */

typedef struct tagTRIECTRL
{
	TRIESTATS  *lpTrieStats;				// Pointer to base of header segment
	WORD       *lpwCharFlagsCodes;			// decoding table for Char/flags
	WORD       *lpwTagsCodes;				// decoding table for tagged data
	WORD       *lpwMRPointersCodes;			// decoding table for multiref pointers
	WORD       *lpwSROffsetsCodes;			// decoding table for singleref offsets
	CHARFLAGS  *lpCharFlags;				// table to convert codes to char/flags
	DWORD      *lpwTags;					// table to convert codes to tagged data
	DWORD      *lpwMRPointers;				// table to convert codes to multiref pointers
	DWORD      *lpwSROffsets;				// table to convert codes to Singleref offsets
	BYTE       *lpbTrie;					// Pointer to the trie.
} TRIECTRL, *PTRIECTRL, *LPTRIECTRL;

/* Useful Constants */

#define TRIE_MAX_DEPTH          128     // We'll fail on any words longer than this

// The prototypes below are plain C     (this is required for use with C++)

/* Given a pointer to a mapped file or resource containing a compressed trie,
read the trie into memory, making all the allocations required */

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte);

/* Free all the allocations associated with a trie */

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl);

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI
TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

BOOL WINAPI
TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch);

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI
TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguisha valid word from a valid prefix, caller must test
wFlags for fTrieNodeValid. */

BOOL WINAPI
TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t * lpwszWord);

int WINAPI
TrieWordToIndex(
        TRIECTRL   *ptc,                // Trie in which to find word index
        wchar_t    *pwszWord            // Word for which we're looking
);

BOOL WINAPI
TrieIndexToWord(
        TRIECTRL   *ptc,                // Trie in which to find indexed word
        DWORD       nIndex,             // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int         cwc                 // Max characters in buffer (including NULL)
);

int WINAPI
TrieWordToTagIndex(
        TRIECTRL   *ptc,                // Trie in which to find word index
        wchar_t    *pwszWord,           // Word for which we're looking
        int         tag                 // Which tag to enumerate
);

BOOL WINAPI
TrieTagIndexToWord(
        TRIECTRL   *ptc,                // Trie in which to find indexed word
        DWORD       nIndex,             // Index for which we're looking
        wchar_t    *pwszWord,           // Returned word
        int         cwc,                // Max characters in buffer (including NULL)
        int         tag                 // Which tag to enumerate
);

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                // Returned values
        BYTE       *pbValid             // Mask for valid return values
);

int WINAPI
TriePrefixToRange(
        TRIECTRL   *ptc,                // Trie in which to find prefix range
        wchar_t    *pwszWord,           // Prefix for which we're looking
        int                *piStart     // Start of range with this prefix
);

/**** Subroutines for traversing Directed Acyclic Word Graphs ****/

/* Abstract trie node structure.  wch is a character to transition on; flags describe various things
about the compressed trie; iDown indexes the first node in the state wch transitions to. DAWG is a special
kind of trie: a "Directed Acyclic Word Graph," essentially an ending-compressed trie. */

typedef struct tagDAWGNODE
{
    DWORD   wch;            // Unicode character
    DWORD   wFlags;         // see below
    DWORD   cWords;         // Words below this node in the subtree
	DWORD	cSkipWords;		// Words below skipped nodes
    DWORD   iDown;          // Offset of first node in next state
    DWORD   iRight;         // Offset to first node in next substate
    DWORD   cTags[8];       // Count of tagged nodes below this node in the subtree
    DWORD   dwData[8];      // Stored tagged data for this node
} DAWGNODE, *PDAWGNODE, *LPDAWGNODE;

/* Given a trie and a pointer to a node in it, find the next node in that state.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. Returns a pointer to the new node, NULL if there is
no next node (i.e. if this is the end of a state).*/

DAWGNODE * WINAPI DawgGetNextNode(void *pTrie, DAWGNODE *pTrieNode);

/* From this node, find the first node in the state it points to.  This is equivalent
to traversing a down pointer or extending the word one letter and finding the first
alternative.  Returns a pointer to the first node in the new state, NULL if there is
no down pointer. To find the first state in the trie, use pTrieNode == NULL */

DAWGNODE * WINAPI DawgGetNextState(void *pTrie, DAWGNODE *pTrieNode);

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns a pointer to the terminal node in pTrie Returns
NULL if there is no path through the trie that corresponds to pwszWord. To distinguish
a valid word from a valid prefix, caller must test wFlags for fTrieNodeValid. */

DAWGNODE * WINAPI DawgCheckWord(void *pTrie, wchar_t *pwszWord);

/* Walk the trie from pTrieNode, calling pfnTrieWord on every valid word.  pvParam is passed through
to pfnTrieWord.  If pfnTrieWord returns non-zero, the enumeration stops.  pwszWord must point to a
space of cwchTrieWordMax+1 wchar_t's.  To walk the entire trie, pass NULL for pTrieNode. Returns
the number of words traversed. pfnTrieWord may be null if all you want is the count of words. */

int WINAPI
DawgEnumerate(
        void *pTrie,                    // Trie to enumerate
        DAWGNODE *pTrieNodeStart,       // point to enumerate from, NULL if all
        wchar_t *pwszWord,              // buffer to hold words being enumerated
        void *pvParam,                  // parameter to pass to pfnTrieWord
        int (*pfnTrieWord)(wchar_t *pwszWord, void *pvParam)
);

// end plain C Prototypes

#ifdef __cplusplus
}
#endif

#endif // TRIE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\hanjadic\trie.cpp ===
#include "private.h"
#include "trie.h"
#include "memmgr.h"

#define fNLGNewMemory(pp,cb) ((*pp) = (TRIECTRL*)ExternAlloc(cb))       
#define NLGFreeMemory ExternFree

/******************************Public*Routine******************************\
* TrieInit
*
* Given a pointer to a resource or mapped file of a mapped file this
* function allocates and initializes the trie structure.
*
* Returns NULL for failure, trie control structure pointer for success.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

TRIECTRL * WINAPI TrieInit(LPBYTE lpByte)
{
    LPWORD lpwTables;
    TRIECTRL *lpTrieCtrl;
    LPTRIESTATS lpTrieStats;

    lpTrieStats = (LPTRIESTATS) lpByte;

	if (lpTrieStats == NULL)
		return(NULL);

	// Check the version number.  This code currently only supports version 1 tries  

	if (lpTrieStats->version > 1)
		return NULL;

    //
    // Allocate space for the control structure and the table of SR offsets
    //

    if (!fNLGNewMemory(&lpTrieCtrl, sizeof(TRIECTRL)))
        return NULL;

    //
    // Allocate space for the complete header, copy the fixed part and read in the rest
    //

    lpByte += lpTrieStats->cbHeader;
    lpTrieCtrl->lpTrieStats = lpTrieStats;

    //
    // Set up the table pointers (all these tables are inside the TRIECTRL allocation)
    //

    lpwTables = (LPWORD)(lpTrieStats+1);

    lpTrieCtrl->lpwCharFlagsCodes = lpwTables;
    lpwTables += lpTrieStats->cCharFlagsCodesMax;

    if (lpTrieStats->cCharFlagsCodesMax & 1)               // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwTagsCodes = lpwTables;
    lpwTables += lpTrieStats->cTagsCodesMax;

    if (lpTrieStats->cTagsCodesMax & 1)                     // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwMRPointersCodes = lpwTables;
    lpwTables += lpTrieStats->cMRPointersCodesMax;

    if (lpTrieStats->cMRPointersCodesMax & 1)               // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpwSROffsetsCodes = lpwTables;
    lpwTables += lpTrieStats->cSROffsetsCodesMax;

    if (lpTrieStats->cSROffsetsCodesMax & 1)                           // Deal with possible data mis-alignment
        lpwTables++;

    lpTrieCtrl->lpCharFlags = (LPCHARFLAGS)lpwTables;
    lpwTables = (LPWORD)(lpTrieCtrl->lpCharFlags + lpTrieStats->cUniqueCharFlags);

    lpTrieCtrl->lpwTags = (DWORD *)lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueTags);

    lpTrieCtrl->lpwMRPointers = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueMRPointers);

    lpTrieCtrl->lpwSROffsets = (DWORD *) lpwTables;
    lpwTables += (2 * lpTrieStats->cUniqueSROffsets);

    //
    // These tables should exactly fill the allocation
    //

    if ((LPBYTE)lpwTables - (LPBYTE)lpTrieStats != (int)lpTrieStats->cbHeader)
    	{
    	TrieFree(lpTrieCtrl);
		return NULL;
    	}

    //
    // Init trie pointers
    //

    lpTrieCtrl->lpbTrie = (LPBYTE)lpByte;

    return lpTrieCtrl;
}

/******************************Public*Routine******************************\
* TrieFree
*
* Free the resources allocated for the control structure.
*
* History:
*  16-Jun-1997 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void WINAPI TrieFree(LPTRIECTRL lpTrieCtrl)
{
    //
    // Finally free the control structure and all the tables.  STILL MUST FREE THIS FOR ROM
    //

    NLGFreeMemory(lpTrieCtrl);
}

/* Deompress a single symbol using base-256 huffman from a compressed data structure. piSymbol
points to a space to hold the decompressed value, which is an index to a frequency-ordered
table of symbols (0 is most frequent).  pcCodes is a table of code lengths returned from
HuffmanComputeTable.  pbData is a pointer to memory that contains the encoded data.  The
return value is the number of bytes decoded. */

int DecompressSymbol(WORD *piSymbol, WORD *pcCodes, unsigned char *pbData)
{
    int cBytes = 0;
    WORD wCode = 0, wiSymbol = 0;

    /* At each stage in this loop, we're trying to see if we've got a length-n code.
    dwCode is which length-n code it would have to be.  If there aren't that many length-n codes,
    we have to try n+1.  To do that, we subtract the number of length-n codes and shift in
    the next byte. dwiSymbol is the symbol number of the first length-n code. */

    while (1)
    {
        wCode += *pbData++;
        ++cBytes;

        if (wCode < *pcCodes)
        {
			break;
        }
        wiSymbol += *pcCodes;
        wCode -= *pcCodes++;
        wCode <<= 8;
    }

    /* Now that dwCode is a valid number of a length-cBytes code, we can just add it to
    dwiSymbol, because we've already added the counts of the shorter codes to it. */

    wiSymbol += wCode;

    *piSymbol = wiSymbol;

    return cBytes;
}

DWORD Get3ByteAddress(BYTE *pb)
{
    return ((((pb[0] << 8) | pb[1]) << 8) | pb[2]) & 0x00ffffff;
}

void WINAPI TrieDecompressNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    TRIESTATS  *lpTrieStats;
    DWORD       wOffset;
    DWORD       wOffset2;
    WORD        wCode;
    DWORD       dwCode;
    BYTE        wMask;
    BYTE        bMask;
    int         iTag;

    lpTrieStats = lpTrieCtrl->lpTrieStats;

    /* If this is an initial call, use the first byte in the trie */

    if (lpTrieScan->wFlags == 0)
    {
        lpTrieScan->lpbSRDown = 0;
        lpTrieScan->lpbNode = lpTrieCtrl->lpbTrie;
    }

    /* Decompress the char/flags */

    lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwCharFlagsCodes, lpTrieScan->lpbNode);
    lpTrieScan->wch      = lpTrieCtrl->lpCharFlags[wCode].wch;
    lpTrieScan->wFlags   = lpTrieCtrl->lpCharFlags[wCode].wFlags;

    // Decompress skip enumeration

    if (lpTrieScan->wFlags & TRIE_NODE_SKIP_COUNT)
    {
		// Values greater than 127 are really 15 or 21 bit values.

        dwCode = (DWORD) *lpTrieScan->lpbNode++;

        if (dwCode >= 0x00c0)
        {
            dwCode  = ((dwCode & 0x003f) << 15);
            dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
            dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
        }
        else if (dwCode >= 0x0080)
            dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

        lpTrieScan->cSkipWords = dwCode;
    }

    /* Code to decompress enumeration goes here */

    if (lpTrieScan->wFlags & TRIE_NODE_COUNT)
    {
		// Values greater than 127 are really 15 or 21 bit values.

        dwCode = (DWORD) *lpTrieScan->lpbNode++;

        if (dwCode >= 0x00c0)
        {
            dwCode  = ((dwCode & 0x003f) << 15);
            dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
            dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
        }
        else if (dwCode >= 0x0080)
            dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

        lpTrieScan->cWords = dwCode;

		// Decompress the tagged enumeration counts

        wMask = 1;
        for (iTag = 0; iTag < MAXTAGS; iTag++)
        {
            if (lpTrieCtrl->lpTrieStats->wEnumMask & wMask)
            {
				// Values greater than 127 are really 15 or 21 bit values.

                dwCode = (DWORD) *lpTrieScan->lpbNode++;

                if (dwCode >= 0x00c0)
                {
                    dwCode  = ((dwCode & 0x003f) << 15);
                    dwCode |= ((((DWORD) *lpTrieScan->lpbNode++) & 0x007f) << 8);
                    dwCode |= (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);
                }
                else if (dwCode >= 0x0080)
                    dwCode = ((dwCode & 0x007f) <<  8) | (((DWORD) *lpTrieScan->lpbNode++) & 0x00ff);

                lpTrieScan->aTags[iTag].cTag = dwCode;
            }
            else
                lpTrieScan->aTags[iTag].cTag = 0;

            wMask <<= 1;
        }
    }
    else
		lpTrieScan->cWords = 0;

    // Any tagged data for this node follows the counts

    lpTrieScan->wMask = 0;

    if (lpTrieScan->wFlags & TRIE_NODE_TAGGED)
    {
		// If there is only one tagged field, the mask byte won't be stored

        if (lpTrieCtrl->lpTrieStats->cTagFields == 1)
                bMask = lpTrieCtrl->lpTrieStats->wDataMask;
        else
                bMask = *lpTrieScan->lpbNode++;

		// Now that we know which elements are stored here, pull them in their proper place

        wMask = 1;
        for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
        {
                if (lpTrieCtrl->lpTrieStats->wDataMask & bMask & wMask)
                {
                    lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwTagsCodes, lpTrieScan->lpbNode);
                    lpTrieScan->aTags[iTag].dwData = lpTrieCtrl->lpwTags[wCode];
                    lpTrieScan->wMask |= wMask;
                }

                bMask  &= ~wMask;
                wMask <<= 1;
        }
    }

    // There are two flavors of right pointers: Multiref and Skip.

    if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
    {
        if (lpTrieScan->wFlags & TRIE_NODE_SKIP)
        {
            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,lpTrieScan->lpbNode);
            wOffset2 = lpTrieCtrl->lpwSROffsets[wCode];     // Only add this after entire node is decompressed
        }
        else
        {
            /* Multiref: The down pointer is encoded directly */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode, lpTrieCtrl->lpwMRPointersCodes, lpTrieScan->lpbNode);
            lpTrieScan->lpbRight = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
        }
    }
    else
            lpTrieScan->lpbRight = NULL;

    // There are 4 kinds of down pointer: Absolute, Inline, Multiref, and Singleref Offset.
    // Each requires different decompression

    if (lpTrieScan->wFlags & TRIE_DOWN_ABS)
    {
            // Immediate.  The next 3 bytes are the absolute offset from the base of the trie.

            lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + Get3ByteAddress(lpTrieScan->lpbNode);
            lpTrieScan->lpbNode += 3;
    }
    else if (lpTrieScan->wFlags & TRIE_DOWN_INLINE)
    {
            /* Inline: The down pointer points to the next sequential byte (so it isn't stored) */

            lpTrieScan->lpbSRDown = lpTrieScan->lpbDown = lpTrieScan->lpbNode;
    }
    else if (lpTrieScan->wFlags & TRIE_DOWN_MULTI)
    {
            /* Multiref: The down pointer is encoded directly */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwMRPointersCodes,
                    lpTrieScan->lpbNode);

            lpTrieScan->lpbDown = lpTrieCtrl->lpbTrie + lpTrieCtrl->lpwMRPointers[wCode];
    }
    else if (lpTrieScan->wFlags & TRIE_NODE_DOWN)
    {
            /* SR Offset.  The down pointer is encoded as an offset from the LAST downpointer
            into this singleref segment.  So we have to keep the old one around so we can add to it */

            lpTrieScan->lpbNode += DecompressSymbol(&wCode,lpTrieCtrl->lpwSROffsetsCodes,
                    lpTrieScan->lpbNode);

            if (lpTrieScan->lpbSRDown == 0)
            {
                    lpTrieScan->lpbSRDown = lpTrieScan->lpbNode;  // We offset from the end of the first node when going into a new state.
            }

            wOffset = lpTrieCtrl->lpwSROffsets[wCode];
            lpTrieScan->lpbSRDown += wOffset;
            lpTrieScan->lpbDown = lpTrieScan->lpbSRDown;
    }
    else
            lpTrieScan->lpbDown = NULL;

	// We couldn't deal with this until now, since skip pointers are always delta encoded from the end of node

    if ((lpTrieScan->wFlags & (TRIE_NODE_RIGHT | TRIE_NODE_SKIP)) == (TRIE_NODE_RIGHT | TRIE_NODE_SKIP))
        lpTrieScan->lpbRight = lpTrieScan->lpbNode + wOffset2;

} // TrieDecompressNode

/* Given a compressed trie and a pointer to a decompresed node from it, find and decompress
the next node in the same state. lpTrieScan is a user-allocated structure that holds the
decompressed node and into which the new node is copied.
This is equivalent to traversing a right pointer or finding the next alternative
letter at the same position. If there is no next node (i.e.this is the end of the state)
then TrieGetNextNode returns FALSE. To scan from the beginning of the trie, set the lpTrieScan
structure to zero */

BOOL WINAPI TrieGetNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
	// Are we at EOS?

    if (lpTrieScan->wFlags & TRIE_NODE_END)
    {
		// Is this is a hard EOS?

        if (!(lpTrieScan->wFlags & TRIE_NODE_SKIP))
        {
			// If we can follow a right pointer, do so, else fail
        
            if (lpTrieScan->wFlags & TRIE_NODE_RIGHT)
                lpTrieScan->lpbNode = lpTrieScan->lpbRight;
            else
                return FALSE;
        }

		// Either we're at a soft EOS or we've followed a right pointer.
		// Both these require us to reset the SRDown for proper decompression

        lpTrieScan->lpbSRDown = 0;
    }

	// Decompress the node at return success

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

BOOL WINAPI TrieSkipNextNode(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, WCHAR wch)
{
	// If this is the last node in the normal or skip state, quit here

    if (lpTrieScan->wFlags & TRIE_NODE_END)
        return FALSE;

	// If there isn't a right pointer or if the target letter is alphabetically less then
	// the current letter scan right normally.  Otherwise, follow the skip pointer.

    if (!(lpTrieScan->wFlags & TRIE_NODE_RIGHT) || (wch < lpTrieScan->wch))
        return TrieGetNextNode(lpTrieCtrl, lpTrieScan);

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode   = lpTrieScan->lpbRight;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;
}

/* Follow the down pointer to the next state.  This is equivalent to accepting the character
in this node and advancing to the next character position.  Returns FALSE if there is no
down pointer.  This also decompresses the first node in the state, so all the values in
lpTrieScan will be good. */

BOOL WINAPI TrieGetNextState(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan)
{
    /* Flags can't normally be zero; that always means "top node" */

    if (lpTrieScan->wFlags == 0)
    {
        TrieDecompressNode(lpTrieCtrl, lpTrieScan);
        return TRUE;
    }

    if (!(lpTrieScan->wFlags & TRIE_NODE_DOWN))
        return FALSE;

    lpTrieScan->lpbSRDown = 0;
    lpTrieScan->lpbNode = lpTrieScan->lpbDown;

    TrieDecompressNode(lpTrieCtrl, lpTrieScan);

    return TRUE;

} // TrieGetNextState

/* Check the validity of a word or prefix. Starts from the root of pTrie looking for
pwszWord.  If it finds it, it returns TRUE and the user-provided lpTrieScan structure
contains the final node in the word.  If there is no path, TrieCheckWord returns FALSE
To distinguish a valid word from a valid prefix, caller must test
wFlags for TRIE_NODE_VALID. */

BOOL WINAPI TrieCheckWord(LPTRIECTRL lpTrieCtrl, LPTRIESCAN lpTrieScan, wchar_t far* lpwszWord)
{
    /* Start at the root of the trie and loop through all the letters in the word */

    memset(lpTrieScan,0,sizeof(*lpTrieScan));

    while (*lpwszWord)
    {
        /* Each new letter means we need to go to a new state.  If there is none,
                the word is not in this trie */

        if (!TrieGetNextState(lpTrieCtrl, lpTrieScan))
            return FALSE;

        /* Now we walk across the state looking for this character.  If we don't find
        it, this word is not in this trie */

        while (lpTrieScan->wch != *lpwszWord)
        {
            if (!TrieSkipNextNode(lpTrieCtrl, lpTrieScan, *lpwszWord))
                return FALSE;
        }

        ++lpwszWord;
    }

    return TRUE;

} // TrieCheckWord

// Find the index to the word in the trie.

DWORD CountWords(TRIECTRL *ptc, TRIESCAN *pts)
{
    TRIESCAN        ts     = *pts;
    DWORD           cWords = 0;

    if (!TrieGetNextState(ptc, &ts))
            return cWords;

    do
    {
        if (ts.wFlags & TRIE_NODE_VALID)
            cWords++;

        cWords += CountWords(ptc, &ts);
    } while (TrieGetNextNode(ptc, &ts));

    return cWords;
}

int WINAPI TrieWordToIndex(TRIECTRL *ptc, wchar_t *pwszWord)
{
    TRIESCAN    ts;
    int         ich = 0;
    int         index = 0;
    BOOL        bValid;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
            return FALSE;

    do
    {
        bValid = ts.wFlags & TRIE_NODE_VALID;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

			// If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & TRIE_NODE_VALID)
                return index;

			// Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
			// Now, follow the skip pointer if exist and the alphabetic character is greater then
			// the pivot point. Otherwise, goto the next node.  Add the sub tree count.  If it's cached
			// use it, otherwise compute it recursively.

            if ((ts.wFlags & TRIE_NODE_SKIP_COUNT) && (pwszWord[ich] > ts.wch))
            {
                index += ts.cSkipWords;

				// This can't fail if TRIE_NODE_SKIP_COUNT is set

                TrieSkipNextNode(ptc, &ts, pwszWord[ich]);
            }
            else
            {
                index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

                if (!TrieGetNextNode(ptc, &ts))
                    return -1;
            }
        }

		// If the node we just visited was valid, increment the index

        if (bValid)
            index++;

    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cWords;
    DWORD           cSkips;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
		// If we're at the end of the buffer, fail

        if (ich + 1 >= cwc)
            return FALSE;

		// Remember this node's character

        pwszWord[ich] = ts.wch;

		// If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & TRIE_NODE_VALID)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

		// Get the count of words in this subtree.

        cWords = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);
        cSkips = (ts.wFlags & TRIE_NODE_SKIP_COUNT) ? ts.cSkipWords : 0x7fffffff;

		// Scan to the right until the word count of the subtree would be greater than or equal to the index
		// we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.
		// If we can use a skip count, do so.

        if (nIndex < cWords)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

            ich++;                                  // Advance the character position
        }
        else
        {
            if (nIndex >= cSkips)
            {
                nIndex -= cSkips;

                ts.lpbSRDown = 0;
                ts.lpbNode = ts.lpbRight;
                
                TrieDecompressNode(ptc, &ts);
            }
            else
            {
                nIndex -= cWords;

                if (!TrieGetNextNode(ptc, &ts))
                    return FALSE;
            }
        }

    } while (TRUE);

    pwszWord[++ich] = L'\0';                        // Null terminate the string
    return ts.wFlags & TRIE_NODE_VALID;             // Return validity
}

int WINAPI TriePrefixToRange(TRIECTRL *ptc, wchar_t *pwszWord, int *piStart)
{
    TRIESCAN        ts;
    int                     ich = 0;
    int                     cnt;
    BOOL            bValid;

    memset(&ts, 0, sizeof(TRIESCAN));
	*piStart = 0;

    if (!TrieGetNextState(ptc, &ts))
            return 0;

    // Deal with special case of empty string

    if (pwszWord && !*pwszWord)
            return ptc->lpTrieStats->cWords;

    do
    {
		// Get the count of words below this prefix

        cnt = (ts.wFlags & TRIE_NODE_COUNT) ? ts.cWords : CountWords(ptc, &ts);

		// If the node we just arrived at is valid, increment the count

        bValid = ts.wFlags & TRIE_NODE_VALID;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
			ich++;

            // If we reached the end of prefix, return the count remaining below

            if (pwszWord[ich] == L'\0')
            {
                if (bValid)
					cnt++;

                return cnt;
            }

            // Try going down a level

            if (!TrieGetNextState(ptc, &ts))
				return 0;
        }
        else
        {
			// Add the sub tree count.

           *piStart += cnt;

			// Try the next letter in this state

            if (!TrieGetNextNode(ptc, &ts))
				return 0;
        }

        if (bValid)
			(*piStart)++;

    } while (TRUE);
}

// TAGS

// Find the index to the word in the trie.

DWORD CountTags(TRIECTRL *ptc, TRIESCAN *pts, DWORD wMask, int iTag)
{
    TRIESCAN	ts = *pts;
    DWORD       cTags = 0;

    if (!TrieGetNextState(ptc, &ts))
		return cTags;

    do
    {
        if (ts.wFlags & wMask)
			cTags++;

        cTags += CountTags(ptc, &ts, wMask, iTag);
    } while (TrieGetNextNode(ptc, &ts));

    return cTags;
}

int WINAPI TrieWordToTagIndex(TRIECTRL *ptc, wchar_t *pwszWord, int iTag)
{
    TRIESCAN	ts;
    int         ich = 0;
    int         index = 0;
    BOOL        bValid;
    DWORD       wMask = 1 << iTag;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
        return FALSE;

    do
    {
        bValid = ts.wFlags & wMask;

		// Scan to the right until we find a matching character.  !!!WARNING!!! The state may not be alphabetized.
		// If the character doesn't match, add the subtree count to the enumeration total and slide to the right.

        if (ts.wch == pwszWord[ich])
        {
            ich++;

			// If we reached the end of word at a valid state, return the index

            if ((pwszWord[ich] == L'\0') && ts.wFlags & wMask)
                return index;

			// Try going down a level

            if (!TrieGetNextState(ptc, &ts))
                return -1;
        }
        else
        {
			// Add the sub tree count.  If it's cached use it, otherwise compute it recursively.

            index += (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

            if (!TrieGetNextNode(ptc, &ts))
                return -1;
        }

		// If the node we just visited was valid, increment the index

        if (bValid)
			index++;
    } while (TRUE);
}

// Given an index into the trie, return the word.

BOOL WINAPI TrieTagIndexToWord(TRIECTRL *ptc, DWORD nIndex, wchar_t *pwszWord, int cwc, int iTag)
{
    TRIESCAN        ts;
    int             ich = 0;
    DWORD           cTags;
    DWORD           wMask = 1 << iTag;

    memset(&ts, 0, sizeof(TRIESCAN));

    if (!TrieGetNextState(ptc, &ts))
		return FALSE;

    do
    {
		// If we're at the end of the buffer, fail

        if (ich + 1 >= cwc)
            return FALSE;

		// Remember this node's character

        pwszWord[ich] = ts.wch;

		// If we're on a valid word AND we've reached the index we're looking for, exit the loop

        if (ts.wFlags & wMask)
        {
            if (!nIndex)
                break;

            nIndex--;
        }

		// Get the count of words in this subtree.

        cTags = (ts.wFlags & TRIE_NODE_COUNT) ? ts.aTags[iTag].cTag : CountTags(ptc, &ts, wMask, iTag);

		// Scan to the right until the word count of the subtree would be greater than or equal to the index
		// we're looking for.  Descend that trie and repeat.  !!!WARNING!!! The state may not be alphabetized.

        if (nIndex < cTags)
        {
            if (!TrieGetNextState(ptc, &ts))
                return FALSE;

                ich++; // Advance the character position
        }
        else
        {
            nIndex -= cTags;

            if (!TrieGetNextNode(ptc, &ts))
                return FALSE;
        }
    } while (TRUE);

    pwszWord[++ich] = L'\0';            // Null terminate the string
    return ts.wFlags & wMask;           // Return validity
}

BOOL WINAPI
TrieGetTagsFromWord(
        TRIECTRL   *ptc,                // Trie in which to find word
        wchar_t    *pwszWord,           // Word for which we're looking
        DWORD      *pdw,                // Returned values
        BYTE       *pbValid             // Mask for valid return values
)
{
    TRIESCAN        ts;
    int             iTag;
    WORD            wMask;
    BYTE            bMask = ptc->lpTrieStats->wTagsMask;

    if (!TrieCheckWord(ptc, &ts, pwszWord))
        return FALSE;

    if (ts.wFlags & TRIE_NODE_TAGGED)
    {
        wMask = 1;
        for (iTag = 0; bMask && (iTag < MAXTAGS); iTag++)
        {
            if (ts.wMask & wMask)
            {
                pdw[iTag] = ts.aTags[iTag].dwData;
                bMask |= wMask;
            }

            wMask <<= 1;
        }
    }

   *pbValid = (BYTE) wMask;

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imkrinst\private.h ===
//
//  Private.h
//
//  Contents:   Private header for korimx project.
//

#if !defined (__PRIVATE_H__INCLUDED_)
#define __PRIVATE_H__INCLUDED_

#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include "initguid.h"
#include "common.h"
#include "debug.h"
#include "msctf.h"
#include "regsvr.h"

#define fTrue   1
#define fFalse  0

#endif  // __PRIVATE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imkrinst\imkrinst.h ===
/****************************** Module Header ******************************\
* Module Name: imkrinst.h
*
* Copyright (c) 2000, Microsoft Corporation
*
* IMKRINST, main header file
*
\***************************************************************************/
#if !defined (_IMKRINST_H__INCLUDED_)
#define _IMKRINST_H__INCLUDED_

/////////////////////////////////////////////////////////////////////////////
// Global constants
/////////////////////////////////////////////////////////////////////////////

// Line buffer length for script file.
const int _cchBuffer = 1024;

// Error code returned from ProcessScriptFile.
enum 
{                                 
	errNoError,
    errNoFile,
    errFileList,
    errSetDefaultParameters,
    errSetVersion,
    errPreSetupCheck,
    errRenameFile,
    errRegisterIME,
    errRegisterIMEandTIP,
    errRegisterInterface,
    errRegisterInterfaceWow64,
    errAddToPreload,
    errPrepareMigration,
    errRegisterPackageVersion,
    errRegisterPadOrder,
    errCmdCreateDirectory,
    errCmdRegisterHelpDirs
};

/////////////////////////////////////////////////////////////////////////////
// Utility classes
/////////////////////////////////////////////////////////////////////////////
//
// FileListElement. Constructs FileListSet.
//
class FLE
{                                              // I use short incomprehensible name such as "FLE"
public:                                                 // since we'll meet many C4786 warnings when I use
    BOOL fRemoved;                                      // longer name.
    TCHAR szFileName[MAX_PATH];    
};

// binary operator required to construct a set of this class.
bool operator < (const FLE &fle1, const FLE &fle2)
{
	return(0 > lstrcmpi(fle1.szFileName, fle2.szFileName));
};

//
// VersionComparison. Used to compare two version info. Used for IsNewer.
//
class VersionComparison2
{
public:
    VersionComparison2(const DWORD arg_dwMajorVersion, const DWORD arg_dwMinorVersion) 
        : dwMajorVersion(arg_dwMajorVersion), dwMinorVersion(arg_dwMinorVersion){};

    virtual bool operator <(const VersionComparison2 &vc2)
    	{
        if((dwMajorVersion < vc2.dwMajorVersion) || 
           ((dwMajorVersion == vc2.dwMajorVersion) && (dwMinorVersion < vc2.dwMinorVersion)))
            return(true);
        else
            return(false);
    	}

    virtual bool operator ==(const VersionComparison2 &vc2)
    {
        return((dwMajorVersion == vc2.dwMajorVersion) && (dwMinorVersion == vc2.dwMinorVersion));
    }

private:
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
};

class VersionComparison4
{
public:
    VersionComparison4(const DWORD arg_dwMajorVersion, const DWORD arg_dwMiddleVersion, const DWORD arg_dwMinorVersion, const DWORD arg_dwBuildNumber) 
        : dwMajorVersion(arg_dwMajorVersion), dwMiddleVersion(arg_dwMiddleVersion), dwMinorVersion(arg_dwMinorVersion), dwBuildNumber(arg_dwBuildNumber){};

    virtual bool operator <(const VersionComparison4 &vc4)
    {
        if((dwMajorVersion < vc4.dwMajorVersion) || 
           ((dwMajorVersion == vc4.dwMajorVersion) && (dwMiddleVersion < vc4.dwMiddleVersion)) ||
           ((dwMajorVersion == vc4.dwMajorVersion) && (dwMiddleVersion == vc4.dwMiddleVersion) && (dwMinorVersion < vc4.dwMinorVersion)) ||
           ((dwMajorVersion == vc4.dwMajorVersion) && (dwMiddleVersion == vc4.dwMiddleVersion) && (dwMinorVersion == vc4.dwMinorVersion) && (dwBuildNumber < vc4.dwBuildNumber)))
            return(true);
        else
            return(false);
    }

    virtual bool operator ==(const VersionComparison4 &vc4)
    {
        return((dwMajorVersion == vc4.dwMajorVersion) && (dwMiddleVersion == vc4.dwMiddleVersion) &&
               (dwMinorVersion == vc4.dwMinorVersion) && (dwBuildNumber == vc4.dwBuildNumber));
    }
    
private:
    DWORD dwMajorVersion;
    DWORD dwMiddleVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
};

#endif // !defined (_IMKRINST_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imkrinst\regtip.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       regtip.cpp
//
//  Contents:   Reister/Unregister TIP functionality.
//
//----------------------------------------------------------------------------

#include "private.h"
#include "regtip.h"

//
// misc def in Cicero
//

const TCHAR c_szCTFTIPKey[]          = TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\");
const TCHAR c_szCTFTIPKeyWow6432[]   = TEXT("Software\\Wow6432Node\\Microsoft\\CTF\\TIP");
const TCHAR c_szEnable[]             = TEXT("Enable");
const WCHAR c_szEnableW[]            = L"Enable";
const TCHAR c_szLanguageProfileKey[] = TEXT("LanguageProfile\\");
const WCHAR c_szDescriptionW[]       = L"Description";
const WCHAR c_szIconFileW[]          = L"IconFile";
const TCHAR c_szIconIndex[]          = TEXT("IconIndex");
const TCHAR c_szItem[]               = TEXT("Item\\");         // Item to category mapping
const TCHAR c_szCategoryKey[]        = TEXT("Category\\");
const WCHAR c_wszDescription[]       = L"Description";
const TCHAR c_szCategory[]           = TEXT("Category\\"); // Category to item mapping
const WCHAR c_szMUIDescriptionW[]    =  L"Display Description";

typedef enum 
{ 
	CAT_FORWARD  = 0x0,
	CAT_BACKWARD = 0x1
} OURCATDIRECTION;


//
// registry access functions
//

/*   S E T  R E G  V A L U E   */
/*-----------------------------------------------------------------------------



-----------------------------------------------------------------------------*/
static BOOL SetRegValue(HKEY hKey, const WCHAR *szName, WCHAR *szValue)
{
	LONG ec;

	ec = RegSetValueExW(hKey, szName, 0, REG_SZ, (BYTE *)szValue, (lstrlenW(szValue)+1) * sizeof(WCHAR));

	return (ec == ERROR_SUCCESS);
}


/*   S E T  R E G  V A L U E   */
/*-----------------------------------------------------------------------------



-----------------------------------------------------------------------------*/
static BOOL SetRegValue(HKEY hKey, const CHAR *szName, DWORD dwValue)
{
	LONG ec;

	ec = RegSetValueExA( hKey, szName, 0, REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD) );

	return (ec == ERROR_SUCCESS);
}


/*   D E L E T E  R E G  K E Y   */
/*-----------------------------------------------------------------------------



-----------------------------------------------------------------------------*/
static LONG DeleteRegKey( HKEY hKey, const CHAR *szKey )
{
	HKEY hKeySub;
	LONG ec = RegOpenKeyEx( hKey, szKey, 0, KEY_READ | KEY_WRITE, &hKeySub );

	if (ec != ERROR_SUCCESS) {
		return ec;
	}

	FILETIME time;
	DWORD dwSize = 256;
	TCHAR szBuffer[256];
	while (RegEnumKeyEx( hKeySub, 0, szBuffer, &dwSize, NULL, NULL, NULL, &time) == ERROR_SUCCESS) {
		ec = DeleteRegKey( hKeySub, szBuffer );
		if (ec != ERROR_SUCCESS) {
			return ec;
		}
		dwSize = 256;
	}

	RegCloseKey( hKeySub );

	return RegDeleteKey( hKey, szKey );
}


/*   D E L E T E  R E G  V A L U E   */
/*-----------------------------------------------------------------------------



-----------------------------------------------------------------------------*/
static LONG DeleteRegValue( HKEY hKey, const WCHAR *szName )
{
	LONG ec;

	ec = RegDeleteValueW( hKey, szName );

	return (ec == ERROR_SUCCESS);
}


//
// Input processor profile functions
//

/*   O U R  R E G I S T E R   */
/*-----------------------------------------------------------------------------

	private version of CInputProcessorProfiles::Register()
	(Cicero interface function)

-----------------------------------------------------------------------------*/
static HRESULT OurRegister(REFCLSID rclsid)
{
// --- CInputProcessorProfiles::Register() ---
//    CMyRegKey key;
//    TCHAR szKey[256];
//
//    lstrcpy(szKey, c_szCTFTIPKey);
//    CLSIDToStringA(rclsid, szKey + lstrlen(szKey));
//
//    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
//        return E_FAIL;
//
//    key.SetValueW(L"1", c_szEnableW);
//
//    return S_OK;

	HKEY hKey;
	CHAR szKey[ 256 ];
	LONG ec;

	lstrcpy(szKey, c_szCTFTIPKey);
	CLSIDToStringA(rclsid, szKey + lstrlen(szKey));

	ec = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

	SetRegValue(hKey, c_szEnableW, L"1");

	RegCloseKey(hKey);
	return S_OK;
}


/*   O U R  A D D  L A N G U A G E  P R O F I L E   */
/*-----------------------------------------------------------------------------

	private version of CInputProcessorProfiles::AddLanguageProfile()
	(Cicero interface function)

-----------------------------------------------------------------------------*/
static HRESULT OurAddLanguageProfile( REFCLSID rclsid,
                               LANGID langid,
                               REFGUID guidProfile,
                               const WCHAR *pchProfile,
                               ULONG cch,
                               const WCHAR *pchFile,
                               ULONG cchFile,
                               ULONG uIconIndex)
{
// --- CInputProcessorProfiles::AddLanguageProfile() ---
//    CMyRegKey keyTmp;
//    CMyRegKey key;
//    char szTmp[256];
//
//    if (!pchProfile)
//       return E_INVALIDARG;
//
//    lstrcpy(szTmp, c_szCTFTIPKey);
//    CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
//    lstrcat(szTmp, "\\");
//    lstrcat(szTmp, c_szLanguageProfileKey);
//    wsprintf(szTmp + lstrlen(szTmp), "0x%08x", langid);
//
//    if (keyTmp.Create(HKEY_LOCAL_MACHINE, szTmp) != S_OK)
//        return E_FAIL;
//
//    CLSIDToStringA(guidProfile, szTmp);
//    if (key.Create(keyTmp, szTmp) != S_OK)
//        return E_FAIL;
//
//    key.SetValueW(WCHtoWSZ(pchProfile, cch), c_szDescriptionW);
//
//    if (pchFile)
//    {
//        key.SetValueW(WCHtoWSZ(pchFile, cchFile), c_szIconFileW);
//        key.SetValue(uIconIndex, c_szIconIndex);
//    }
//
//    CAssemblyList::InvalidCache();
//    return S_OK;

	HKEY hKey;
	HKEY hKeyTmp;
	LONG ec;
	CHAR szTmp[256];
	WCHAR szProfile[256];
	
	if (!pchProfile)
		return E_INVALIDARG;

	lstrcpy(szTmp, c_szCTFTIPKey);
	CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
	lstrcat(szTmp, "\\" );
	lstrcat(szTmp, c_szLanguageProfileKey);
	wsprintf(szTmp + lstrlen(szTmp), "0x%08x", langid);

	ec = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyTmp, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

	CLSIDToStringA(guidProfile, szTmp);
	ec = RegCreateKeyEx(hKeyTmp, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	RegCloseKey(hKeyTmp);
	
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

	lstrcpynW(szProfile, pchProfile, cch+1);
	szProfile[cch] = L'\0';
	SetRegValue(hKey, c_szDescriptionW, szProfile);

	if (pchFile) 
		{
		WCHAR szFile[ MAX_PATH ];
		lstrcpynW(szFile, pchFile, cchFile+1);
		szFile[cchFile] = L'\0';
		SetRegValue(hKey, c_szIconFileW, szFile);
		SetRegValue(hKey, c_szIconIndex, uIconIndex);
		}

	RegCloseKey( hKey );
	return S_OK;
}



//+---------------------------------------------------------------------------
//
// NumToWDec
//
//----------------------------------------------------------------------------

static void NumToWDec(DWORD dw, WCHAR *psz)
{
    DWORD dwIndex = 1000000000;
    BOOL fNum = FALSE;

    while (dwIndex)
    {
        BYTE b = (BYTE)(dw / dwIndex);
        
        if (b)
            fNum = TRUE;

        if (fNum)
        {
            *psz = (WCHAR)(L'0' + b);
            psz++;
        }

        dw %= dwIndex;
        dwIndex /= 10;
    }

    if (!fNum)
    {
        *psz = L'0';
        psz++;
    }
    *psz = L'\0';

    return;
}

//+---------------------------------------------------------------------------
//
// OurSetLanguageProfileDisplayName
//
//----------------------------------------------------------------------------

static HRESULT OurSetLanguageProfileDisplayName(REFCLSID rclsid,
                                               LANGID langid,
                                               REFGUID guidProfile,
                                               const WCHAR *pchFile,
                                               ULONG cchFile,
                                               ULONG uResId)
{
    HKEY hKeyTmp;
    HKEY hKey;
   	LONG ec;
    CHAR szTmp[MAX_PATH];
    WCHAR wszTmp[MAX_PATH];
    WCHAR wszResId[MAX_PATH];
	WCHAR szFile[MAX_PATH];
	
    if (!pchFile)
       return E_INVALIDARG;

    lstrcpy(szTmp, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, szTmp + lstrlen(szTmp));
    lstrcat(szTmp, "\\");
    lstrcat(szTmp, c_szLanguageProfileKey);
    wsprintf(szTmp + lstrlen(szTmp), "0x%08x", langid);

	ec = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyTmp, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

    CLSIDToStringA(guidProfile, szTmp);
    ec = RegCreateKeyEx(hKeyTmp, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	RegCloseKey(hKeyTmp);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

    //
    // make "@[filename],-ResId" string 
    //
    lstrcpyW(wszTmp, L"@");

	// WCHtoWSZ(pchFile, cchFile)
    lstrcpynW(szFile, pchFile, cchFile+1);
	szFile[cchFile] = L'\0';

    lstrcatW(wszTmp, szFile);
    lstrcatW(wszTmp, L",-");
    NumToWDec(uResId, wszResId);
    lstrcatW(wszTmp, wszResId);

	SetRegValue(hKey, c_szMUIDescriptionW, wszTmp);
	RegCloseKey(hKey);
    return S_OK;
}

//
// Category manager functions
//

/*   O U R  G E T  C A T  K E Y   */
/*-----------------------------------------------------------------------------

	private version of GetCatKey()
	(Cicero internal function)

-----------------------------------------------------------------------------*/
static inline void OurGetCatKey( REFCLSID rclsid, REFGUID rcatid, LPSTR pszKey, LPCSTR pszItem )
{
// --- GetCatKey() ---
//    lstrcpy(pszKey, c_szCTFTIPKey);
//    CLSIDToStringA(rclsid, pszKey + lstrlen(pszKey));
//    lstrcat(pszKey, "\\");
//    lstrcat(pszKey, c_szCategoryKey);
//    lstrcat(pszKey, pszItem);
//    CLSIDToStringA(rcatid, pszKey + lstrlen(pszKey));

	lstrcpy(pszKey, c_szCTFTIPKey);
	CLSIDToStringA(rclsid, pszKey + lstrlen(pszKey));
	lstrcat(pszKey, "\\");
	lstrcat(pszKey, c_szCategoryKey);
	lstrcat(pszKey, pszItem);
	CLSIDToStringA(rcatid, pszKey + lstrlen(pszKey));
}


/*   O U R  R E G I S T E R  G  U  I  D  D E S C R I P T I O N   */
/*-----------------------------------------------------------------------------

	private version of RegisterGUIDDescription()
	(Cicero library function & interface function)

-----------------------------------------------------------------------------*/
static HRESULT OurRegisterGUIDDescription( REFCLSID rclsid, REFGUID rcatid, WCHAR *pszDesc )
{
// --- RegisterGUIDDescription() ---
//    ITfCategoryMgr *pcat;
//    HRESULT hr;
//
//    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
//                                   NULL, 
//                                   CLSCTX_INPROC_SERVER, 
//                                   IID_ITfCategoryMgr, 
//                                   (void**)&pcat)))
//    {
//        hr = pcat->RegisterGUIDDescription(rclsid, rcatid, pszDesc, wcslen(pszDesc));
//        pcat->Release();
//    }
//
//    return hr;

// --- CCategoryMgr::RegisterGUIDDescription() ---
//    return s_RegisterGUIDDescription(rclsid, rguid, WCHtoWSZ(pchDesc, cch));

// --- CCategoryMgr::s_RegisterGUIDDescription() ---
//    TCHAR szKey[256];
//    CMyRegKey key;
//    
//    GetCatKey(rclsid, rguid, szKey, c_szItem);
//
//    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
//        return E_FAIL;
//
//    key.SetValueW(pszDesc, c_wszDescription);
//
//    return S_OK;

	CHAR szKey[ 256 ];
	HKEY hKey;
	LONG ec;

	OurGetCatKey( rclsid, rcatid, szKey, c_szItem );

	ec = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

	SetRegValue(hKey, c_wszDescription, pszDesc);

	RegCloseKey(hKey);
	return S_OK;
}


/*   O U R  I N T E R N A L  R E G I S T E R  C A T E G O R Y   */
/*-----------------------------------------------------------------------------

	private version of CCategoryMgr::_InternalRegisterCategory()
	(Cicero interface function)

-----------------------------------------------------------------------------*/
static HRESULT OurInternalRegisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, OURCATDIRECTION catdir )
{
// --- CCategoryMgr::_InternalRegisterCategory() ---
//    TCHAR szKey[256];
//    CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
//    CMyRegKey key;
//    CMyRegKey keySub;
//    
//    GetCatKey(rclsid, rcatid, szKey, pszForward);
//
//    if (key.Create(HKEY_LOCAL_MACHINE, szKey) != S_OK)
//        return E_FAIL;
//
//    //
//    // we add this guid and save it.
//    //
//    char szValue[CLSID_STRLEN + 1];
//    CLSIDToStringA(rguid, szValue);
//    keySub.Create(key, szValue);
//    _FlushGuidArrayCache(rguid, catdir);
//
//    return S_OK;

	TCHAR szKey[256];
	CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
	HKEY hKey;
	HKEY hKeySub;
	LONG ec;
    
	OurGetCatKey(rclsid, rcatid, szKey, pszForward);
	ec = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;

	char szValue[CLSID_STRLEN + 1];

	CLSIDToStringA(rguid, szValue);
	RegCreateKeyEx( hKey, szValue, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeySub, NULL);

	RegCloseKey( hKey );
	RegCloseKey( hKeySub );
	return S_OK;
}


/*   O U R  I N T E R N A L  U N R E G I S T E R  C A T E G O R Y   */
/*-----------------------------------------------------------------------------

	private version of CCategoryMgr::_InternalUnregisterCategory()
	(Cicero interface function)

-----------------------------------------------------------------------------*/
static HRESULT OurInternalUnregisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid, OURCATDIRECTION catdir )
{
// --- CCategoryMgr::_InternalUnregisterCategory ---
//    TCHAR szKey[256];
//    CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
//    CMyRegKey key;
//    
//    GetCatKey(rclsid, rcatid, szKey, pszForward);
//
//    if (key.Open(HKEY_LOCAL_MACHINE, szKey) != S_OK)
//        return E_FAIL;
//
//    DWORD dwIndex = 0;
//    DWORD dwCnt;
//    char szValue[CLSID_STRLEN + 1];
//    dwCnt = sizeof(szValue);
//
//    CLSIDToStringA(rguid, szValue);
//    key.RecurseDeleteKey(szValue);
//    _FlushGuidArrayCache(rguid, catdir);
//
//    return S_OK;

	CHAR szKey[256];
	CONST TCHAR *pszForward = (catdir == CAT_FORWARD) ? c_szCategory : c_szItem;
	HKEY hKey;
	LONG ec;
    
	OurGetCatKey(rclsid, rcatid, szKey, pszForward);
	ec = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, KEY_ALL_ACCESS, &hKey );
	if (ec != ERROR_SUCCESS) {
		return E_FAIL;
	}

	DWORD dwCnt;
	char szValue[CLSID_STRLEN + 1];
	dwCnt = sizeof(szValue);

	CLSIDToStringA( rguid, szValue );
	DeleteRegKey( hKey, szValue );

//    _FlushGuidArrayCache(rguid, catdir);
//	^ NOTE: KOJIW: We cannot clear Cicero internal cache from TIP side...

	RegCloseKey( hKey );
	return S_OK;
}


/*   O U R  R E G I S T E R  T  I  P   */
/*-----------------------------------------------------------------------------

	private version of RegisterTIP()
	(Cicero library function)

-----------------------------------------------------------------------------*/
BOOL OurRegisterTIP(LPSTR szFilePath, REFCLSID rclsid, WCHAR *pwszDesc, const REGTIPLANGPROFILE *plp)
{
// --- RegisterTIP() ---
//    ITfInputProcessorProfiles *pReg = NULL;
//    HRESULT hr;
//    
//    // register ourselves with the ActiveIMM
//    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, 
//                          CLSCTX_INPROC_SERVER,
//                          IID_ITfInputProcessorProfiles, (void**)&pReg);
//    if (FAILED(hr))
//        goto Exit;
//
//    hr = pReg->Register(rclsid);
//
//    if (FAILED(hr))
//        goto Exit;
//
//    while (plp->langid)
//    {
//        WCHAR wszFilePath[MAX_PATH];
//        WCHAR *pv = &wszFilePath[0];
//
//        wszFilePath[0] = L'\0';
//
//        if (wcslen(plp->szIconFile))
//        {
//            char szFilePath[MAX_PATH];
//            WCHAR *pvCur;
//
//            GetModuleFileName(hInst, szFilePath, ARRAYSIZE(szFilePath));
//            wcscpy(wszFilePath, AtoW(szFilePath));
//
//            pv = pvCur = &wszFilePath[0];
//            while (*pvCur)
//            { 
//                if (*pvCur == L'\\')
//                    pv = pvCur + 1;
//                pvCur++;
//            }
//            *pv = L'\0';
//           
//        }
//        wcscpy(pv, plp->szIconFile);
//        
//        pReg->AddLanguageProfile(rclsid, 
//                                 plp->langid, 
//                                 *plp->pguidProfile, 
//                                 plp->szProfile, 
//                                 wcslen(plp->szProfile),
//                                 wszFilePath,
//                                 wcslen(wszFilePath),
//                                 plp->uIconIndex);
//        plp++;
//    }
//
//    RegisterGUIDDescription(rclsid, rclsid, pwszDesc);
//Exit:
//    SafeRelease(pReg);
//    return SUCCEEDED(hr);

	HRESULT hr;

	hr = OurRegister(rclsid);
	if (FAILED(hr))
		goto Exit;

	while (plp->langid) 
		{
		WCHAR wszFilePath[MAX_PATH];
		WCHAR *pv = &wszFilePath[0];

		wszFilePath[0] = L'\0';

		if (wcslen(plp->szIconFile))
			{
			WCHAR *pvCur;

			MultiByteToWideChar(CP_ACP, 0, szFilePath, -1, wszFilePath, MAX_PATH);

			pv = pvCur = &wszFilePath[0];
			while (*pvCur) 
				{
				if (*pvCur == L'\\')
					pv = pvCur + 1;
				pvCur++;
				}
			*pv = L'\0';
 
			}
		lstrcpyW(pv, plp->szIconFile);

		OurAddLanguageProfile(rclsid, 
								plp->langid, 
								*plp->pguidProfile, 
								plp->szProfile, 
								lstrlenW(plp->szProfile),
								wszFilePath,
								lstrlenW(wszFilePath),
								plp->uIconIndex);

		if (plp->uDisplayDescResIndex)
        	{
            OurSetLanguageProfileDisplayName(rclsid, 
                                         plp->langid, 
                                         *plp->pguidProfile, 
                                         wszFilePath,
                                         wcslen(wszFilePath),
                                         plp->uDisplayDescResIndex);
        	}

		plp++;
		}

	OurRegisterGUIDDescription( rclsid, rclsid, pwszDesc );

Exit:
	return SUCCEEDED(hr);
}


/*   O U R  R E G I S T E R  C A T E G O R Y   */
/*-----------------------------------------------------------------------------

	private versio of RegisterCategory()
	(Cicero library function)

-----------------------------------------------------------------------------*/
HRESULT OurRegisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid )
{
// --- RegisterCategory() ---
//    ITfCategoryMgr *pcat;
//    HRESULT hr;
//
//    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
//                                   NULL, 
//                                   CLSCTX_INPROC_SERVER, 
//                                   IID_ITfCategoryMgr, 
//                                   (void**)&pcat)))
//    {
//        hr = pcat->RegisterCategory(rclsid, rcatid, rguid);
//        pcat->Release();
//    }
//
//    return hr;

// --- CCategoryMgr::RegisterCategory() ---
//    return s_RegisterCategory(rclsid, rcatid, rguid);

// --- CCategoryMgr::s_RegisterGUIDDescription() ---
//    HRESULT hr;
//
//    //
//    // create forward link from category to guids.
//    //
//    if (FAILED(hr = _InternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD)))
//        return hr;
//
//    //
//    // create backward link from guid to categories.
//    //
//    if (FAILED(hr = _InternalRegisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD)))
//    {
//        _InternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
//        return hr;
//    }
//
//    return S_OK;

	HRESULT hr;

	if (FAILED(hr = OurInternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD))) {
		return hr;
	}

	if (FAILED(hr = OurInternalRegisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD))) {
		OurInternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
		return hr;
	}

	return S_OK;
}


/*   O U R  U N R E G I S T E R  C A T E G O R Y   */
/*-----------------------------------------------------------------------------

	private version of UnregisterCategory()
	(Cicero library function)

-----------------------------------------------------------------------------*/
HRESULT OurUnregisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid )
{
// --- UnregisterCategory() ---
//    ITfCategoryMgr *pcat;
//    HRESULT hr;
//
//    if (SUCCEEDED(hr = g_pfnCoCreate(CLSID_TF_CategoryMgr,
//                                   NULL, 
//                                   CLSCTX_INPROC_SERVER, 
//                                   IID_ITfCategoryMgr, 
//                                   (void**)&pcat)))
//    {
//        hr = pcat->UnregisterCategory(rclsid, rcatid, rguid);
//        pcat->Release();
//    }
//
//    return hr;

// --- CCategoryMgr::UnregisterCategory() ---
//    return s_UnregisterCategory(rclsid, rcatid, rguid);

// --- CCategoryMgr::s_UnregisterCategory() ---
//    HRESULT hr;
//
//    //
//    // remove forward link from category to guids.
//    //
//    if (FAILED(hr = _InternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD)))
//        return hr;
//
//    //
//    // remove backward link from guid to categories.
//    //
//    if (FAILED(hr = _InternalUnregisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD)))
//    {
//        _InternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
//        return hr;
//    }
//
//    return S_OK;

	HRESULT hr;

	if (FAILED(hr = OurInternalUnregisterCategory(rclsid, rcatid, rguid, CAT_FORWARD))) {
		return hr;
	}

	if (FAILED(hr = OurInternalUnregisterCategory(rclsid, rguid, rcatid, CAT_BACKWARD))) {
		OurInternalRegisterCategory(rclsid, rcatid, rguid, CAT_FORWARD);
		return hr;
	}

	return S_OK;
}


/*   O U R  R E G I S T E R  C A T E G O R I E S   */
/*-----------------------------------------------------------------------------

	private version of RegisterCategories()
	(Cicero library function)

-----------------------------------------------------------------------------*/
HRESULT OurRegisterCategories( REFCLSID rclsid, const REGISTERCAT *pregcat )
{
// --- RegisterCategories() ---
//    while (pregcat->pcatid)
//    {
//        if (FAILED(RegisterCategory(rclsid, *pregcat->pcatid, *pregcat->pguid)))
//            return E_FAIL;
//        pregcat++;
//    }
//    return S_OK;

	while (pregcat->pcatid) {
		if (FAILED(OurRegisterCategory(rclsid, *pregcat->pcatid, *pregcat->pguid))) {
			return E_FAIL;
		}
		pregcat++;
	}
	return S_OK;
}

//+---------------------------------------------------------------------------
//
// InitProfileRegKeyStr
//
//----------------------------------------------------------------------------

static BOOL InitProfileRegKeyStr(char *psz, REFCLSID rclsid, LANGID langid, REFGUID guidProfile)
{
    lstrcpy(psz, c_szCTFTIPKey);
    CLSIDToStringA(rclsid, psz + lstrlen(psz));
    lstrcat(psz, "\\");
    lstrcat(psz, c_szLanguageProfileKey);
    wsprintf(psz + lstrlen(psz), "0x%08x", langid);
    lstrcat(psz, "\\");
    CLSIDToStringA(guidProfile, psz + lstrlen(psz));

    return TRUE;
}


HRESULT OurEnableLanguageProfileByDefault(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable)
{
    HKEY hKey;
    char szTmp[256];
	LONG ec;
	
    if (!InitProfileRegKeyStr(szTmp, rclsid, langid, guidProfile))
        return E_FAIL;

	ec = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szTmp, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);
	if (ec != ERROR_SUCCESS)
		return E_FAIL;
	
	SetRegValue(hKey, c_szEnable, (DWORD)(fEnable ? 1 : 0));
	
	RegCloseKey(hKey);
	
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imkrinst\regtip.h ===
/****************************** Module Header ******************************\
* Module Name: regtip.h
*
* Copyright (c) 2000, Microsoft Corporation
*
* TIP Register/Unregister TIP functionality.
*
\***************************************************************************/
#if !defined (_REGTIP_H__INCLUDED_)
#define _REGTIP_H__INCLUDED_

#include "regimx.h"
#include "catutil.h"

extern BOOL OurRegisterTIP( LPSTR szFilePath, REFCLSID rclsid, WCHAR *pwszDesc, const REGTIPLANGPROFILE *plp);
extern HRESULT OurRegisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid );
extern HRESULT OurRegisterCategories( REFCLSID rclsid, const REGISTERCAT *pregcat );
extern HRESULT OurUnregisterCategory( REFCLSID rclsid, REFGUID rcatid, REFGUID rguid );
extern HRESULT OurEnableLanguageProfileByDefault(REFCLSID rclsid, LANGID langid, REFGUID guidProfile, BOOL fEnable);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imkrinst\imkrinst.cpp ===
/**************************************************************************\
* Module Name: Winmain.cpp
*
* Copyright (C) 2000, Microsoft Corporation
*
* Korean IME 6.1 install utility
*
* History:
* 11-Dec-2000 CSLim Ported from Satori 8.1 code
\**************************************************************************/

#include "private.h"
#include <set>
#include "imkrinst.h"
#include "regtip.h"
#include "insert.h"
#include "..\tip\resource.h"
#include "..\version\verres.h"

// Profile reg key
#define SZTIPREG_LANGPROFILE_TEMPLATE TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\%s\\LanguageProfile\\0x00000412")
#if defined(_M_IA64)
#define SZTIPREG_LANGPROFILE_TEMPLATE_WOW64 TEXT("SOFTWARE\\Wow6432Node\\Microsoft\\CTF\\TIP\\%s\\LanguageProfile\\0x00000412")
#endif

#ifdef DEBUG
CRITICAL_SECTION g_cs;
#endif

// IA64 IME does not support IME Pad. So we just need to take care Wow64 IME in IA64.
#if !defined(_M_IA64)
// Pad Applet Registry location
#define SZPADSHARE        TEXT("SOFTWARE\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042")
#define SZAPPLETCLSID    TEXT("SOFTWARE\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042\\AppletCLSIDList")
#define SZAPPLETIID        TEXT("SOFTWARE\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042\\AppletIIDList")
#else
#define SZPADSHARE        TEXT("SOFTWARE\\Wow6432Node\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042")
#define SZAPPLETCLSID    TEXT("SOFTWARE\\Wow6432Node\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042\\AppletCLSIDList")
#define SZAPPLETIID        TEXT("SOFTWARE\\Wow6432Node\\Microsoft\\TIP Shared\\1.1\\IMEPad\\1042\\AppletIIDList")
#endif
/////////////////////////////////////////////////////////////////////////////
// Script run routines
BOOL CmdSetupDefaultParameters();
BOOL CmdSetVersion(LPCTSTR szParam);
BOOL CmdFileList(LPCTSTR szFormat);
BOOL CmdPreSetupCheck(LPCTSTR szParam);
BOOL CmdRenamePEFile(LPCTSTR szParam);
BOOL CmdRenameFile(LPCTSTR szParam);
BOOL CmdRegisterInterface(LPCTSTR szParam);
BOOL CmdRegisterInterfaceWow64(LPCTSTR szParam);
BOOL CmdRegisterIMEandTIP(LPCTSTR szParam);
BOOL CmdRegisterPackageVersion(void);
BOOL CmdRegisterPadOrder(void);
BOOL CmdAddToPreload(LPCTSTR szParam);
BOOL CmdPrepareMigration(LPCTSTR szParam);
BOOL CmdCreateDirectory(LPCTSTR szParam);
BOOL CmdRegisterHelpDirs();

/////////////////////////////////////////////////////////////////////////////
// Private Functions
// Utility functions
static DWORD WINAPI ProcessScriptFile();
static void RegisterIMEWithFixedHKL(LPCTSTR szHKL, LPCTSTR szIMEFileName, LPCTSTR szIMEName);
static void cdecl LogOutDCPrintf(LPCTSTR lpFmt, va_list va);
static void DebugLog(LPCTSTR szFormat, ...);
static void ErrorLog(LPCTSTR szFormat, ...);
static INT ParseEnvVar(LPTSTR szBuffer, const UINT arg_nLength);
static void TrimString(LPTSTR szString);
static BOOL fExistFile(LPCTSTR szFilePath);
static BOOL fOldIMEsExist();
static BOOL WINAPI ReplaceFileOnReboot (LPCTSTR pszExisting, LPCTSTR pszNew);
static void GetPEFileVersion(LPTSTR szFilePath, DWORD *pdwMajorVersion, DWORD *pdwMiddleVersion, DWORD *pdwMinorVersion, DWORD *pdwBuildNumber);
static BOOL ActRenameFile(LPCTSTR szSrcPath, LPCTSTR tszDstPath, DWORD dwFileAttributes);
static void RegisterTIP(LPCTSTR szTIPName);
static void RegisterTIPWow64(LPCTSTR szTIPName);
static BOOL RegisterRUNKey(LPCTSTR szParam);
static BOOL MakeSIDList();
    
// HKL Helpers
static void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault);
static BOOL HKLHelp412ExistInPreload(HKEY hKeyCU);
static HKL GetHKLfromHKLM(LPTSTR argszIMEFile);
static void RestoreMajorVersionRegistry();

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static TCHAR g_szCurrentDirectory[MAX_PATH] = {0};     // Directory in where this EXE resides.
static TCHAR g_szScriptFile[MAX_PATH] = {0};           // File name (not full path) of script file.
static TCHAR g_szSetupProgram[MAX_PATH] = {0};         // File name (not full path) of setup program.
static TCHAR g_szSystemDirectory[MAX_PATH] = {0};      // System directory.
static TCHAR g_szErrorMessage[200] = {0};              // Global buffer for last error message.
static BOOL  g_fDebugLog = FALSE;                      // Dump debug message when true.
static BOOL  g_fErrorLog = FALSE;                      // Dump error message when true.

static DWORD g_dwMajorVersion  = 0;                    // Package version of this installation.
static DWORD g_dwMiddleVersion = 0;
static DWORD g_dwMinorVersion  = 0;
static DWORD g_dwBuildNumber   = 0;

static std::set <FLE> g_FileList;                      // FileListSet. Used to store set of file paths given by "CmdFileList"
                                                       // script command.

TCHAR g_szVersionKeyCur[MAX_PATH] = {0};
BOOL g_fExistNewerVersion = FALSE;

/*---------------------------------------------------------------------------
    WinMain
---------------------------------------------------------------------------*/
INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    LPTSTR szHitPtr;
    LPTSTR szCommandLine = new TCHAR[lstrlen(GetCommandLine()) + 1];

    if (szCommandLine == NULL)
        return (0);
    
    // szCommandLine contains all command line.
    // Will be modified by _tcstok.
    lstrcpy(szCommandLine, GetCommandLine());

// TEMP Code
//    LogOutDCPrintf(TEXT("WinMain CommandLine arg: %s"), szCommandLine);

    CoInitialize(NULL);

    szHitPtr = _tcstok(szCommandLine, TEXT("\""));
    // g_szCurrentDirectory has path for the process. (IMKRINST.EXE)
    lstrcpy(g_szCurrentDirectory, szHitPtr);

    szHitPtr = _tcsrchr(g_szCurrentDirectory, TEXT('\\'));
    // if g_szCurrentDirectory contains full path,
    if (szHitPtr != NULL)
        {                                             
        *szHitPtr = 0;                                // terminate with the last '\' character to obtain current directory,
        lstrcpy(g_szSetupProgram, szHitPtr + 1);      // then copy the rest (after last '\') to g_szScriptFile.
        }
    else
        {
        lstrcpy(g_szSetupProgram, g_szCurrentDirectory);      // Otherwise (g_szCurrentDirectory is not full path), copy entire
        GetCurrentDirectory(MAX_PATH, g_szCurrentDirectory);  // to g_szScriptFile and obtain current directory by GetCurrentDirectory.
        }

    lstrcpy(g_szScriptFile, g_szSetupProgram);
    szHitPtr = _tcsrchr(g_szScriptFile, TEXT('.'));
    if (szHitPtr != NULL)                                  // If g_szScriptFile contains '.' character, find the last one
        *szHitPtr = 0;                                     // and terminate string with it, then concatenate ".inf" to it.
                                                           // Usually it results ".exe" -> ".inf" replacement. If g_szScriptFile

    // doesn't have '.' character, just concatenate ".ini".
    lstrcat(g_szScriptFile, TEXT(".ini"));

    // Get system32 dir
    GetSystemDirectory(g_szSystemDirectory, ARRAYSIZE(g_szSystemDirectory));
    
    // g_szCurrentDirectory, g_szSetupProgram, g_szSystemDirectory and g_szScriptFile are prepared.
    // szCommandLine will be no longer used.
    // We can use these environment variable in the process.
    SetEnvironmentVariable(TEXT("SETUPSOURCE"), g_szCurrentDirectory);
    SetEnvironmentVariable(TEXT("SETUPEXE"),    g_szSetupProgram);
    SetEnvironmentVariable(TEXT("SETUPINF"),    g_szScriptFile);
    SetEnvironmentVariable(TEXT("SYSTEMDIR"),   g_szSystemDirectory);
    
    delete[] szCommandLine;
    szCommandLine = NULL;

    //////////////////////////////////////////////////////////////////////////
    // Read and run Script file
    switch (ProcessScriptFile())
        {
    case errNoError:
        break;
    case errPreSetupCheck:
        {
#ifdef NEVER
            for(set<FLE>::iterator itFLE = g_FileList.begin(); itFLE != g_FileList.end(); itFLE++){
                DebugLog(TEXT("Cleanup: Deleting Source file: %s"), itFLE->szFileName);
                DeleteFile(itFLE->szFileName);
            }
#endif // NEVER
        }
        break;
    default:
        DebugLog(g_szErrorMessage);
        }
    
#ifdef NEVER
    for (set<FLE>::iterator itFLE = g_FileList.begin(); itFLE != g_FileList.end(); itFLE++)
        {
        ErrorLog(TEXT("Warning: File %s in CmdFileList will be removed without any processing"), itFLE->szFileName);
        DeleteFile(itFLE->szFileName);
        }
#endif // NEVER
    
    CoUninitialize();
    
    return(0);
}

/////////////////////////////////////////////////////////////////////////////
// Main Script Processing functions
/////////////////////////////////////////////////////////////////////////////
inline LPCTSTR GetParameter(LPTSTR szLineBuffer)
{
    return(szLineBuffer + lstrlen(szLineBuffer) + 1);
}

/*---------------------------------------------------------------------------
    ProcessScriptFile
    Read script file. Dispatch commands for each line.
---------------------------------------------------------------------------*/
DWORD WINAPI ProcessScriptFile()
{
    TCHAR szScriptFilePath[MAX_PATH];
    FILE *fileScript;

    wsprintf(szScriptFilePath, TEXT("%s\\%s"), g_szCurrentDirectory, g_szScriptFile);

    fileScript = _tfopen(szScriptFilePath, TEXT("rt"));
    
    if (fileScript != NULL)
        {
        TCHAR szLineBuffer[_cchBuffer];
        LPTSTR szCommand;

        // Parse command
        // Command form <Command>:<Parameter>
        while (_fgetts(szLineBuffer, _cchBuffer, fileScript) != NULL)
            {
            // Chop CR code.
            szLineBuffer[lstrlen(szLineBuffer) - 1] = 0;

            // Empty or Comment line
            if (lstrlen(szLineBuffer) == 0 || (_tcsncmp(TEXT("//"), szLineBuffer, 2) == 0))
                continue;

            DebugLog(TEXT("Line: %s"), szLineBuffer);
           
            szCommand = _tcstok(szLineBuffer, TEXT(":"));

            if (szCommand == NULL)
            {                                        // Dispatch each commands.
                DebugLog(TEXT("Ignore line"));
            }
            else if (lstrcmpi(szCommand, TEXT("DebugLogOn")) == 0)
            {
                g_fDebugLog = TRUE;
                g_fErrorLog = TRUE;
                DebugLog(TEXT("Turn on DebugLog"));
            }
            else if (lstrcmpi(szCommand, TEXT("DebugLogOff")) == 0)
            {
                DebugLog(TEXT("Turn off DebugLog"));
                g_fDebugLog = FALSE;
                }
            else if (lstrcmpi(szCommand, TEXT("ErrorLogOn")) == 0)
                {
                g_fErrorLog = TRUE;
                DebugLog(TEXT("Turn on DebugLog"));
                }
            else if (lstrcmpi(szCommand, TEXT("ErrorLogOff")) == 0)
                {
                DebugLog(TEXT("Turn off DebugLog"));
                g_fErrorLog = FALSE;
                }
            else if (lstrcmpi(szCommand, TEXT("FileList")) == 0)
                {
                if (!CmdFileList(GetParameter(szCommand)))
                    return(errFileList);
                }
            else if (lstrcmpi(szCommand, TEXT("SetupDefaultParameters")) == 0)
                {
                if (!CmdSetupDefaultParameters())
                    return(errSetDefaultParameters);
                }
            else if (lstrcmpi(szCommand, TEXT("SetVersion")) == 0)
                {
                if (!CmdSetVersion(GetParameter(szCommand)))
                    return(errSetVersion);
                }
            else if (lstrcmpi(szCommand, TEXT("PreSetupCheck")) == 0)
                {
                if (!CmdPreSetupCheck(GetParameter(szCommand)))
                    return(errPreSetupCheck);
                }
            else if (lstrcmpi(szCommand, TEXT("RenamePEFile")) == 0)
                {
                if (!CmdRenamePEFile(GetParameter(szCommand)))
                    return(errRenameFile);
                }
            else if (lstrcmpi(szCommand, TEXT("RenameFile")) == 0)
                {
                if (!CmdRenameFile(GetParameter(szCommand)))
                    return(errRenameFile);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterIMEandTIP")) == 0)
                {
                if (!CmdRegisterIMEandTIP(GetParameter(szCommand)))
                    return(errRegisterIMEandTIP);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterPackageVersion")) == 0)
                 {
                if (!CmdRegisterPackageVersion())
                    return(errRegisterPackageVersion);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterInterface")) == 0)
                {
                if (!CmdRegisterInterface(GetParameter(szCommand)))
                    return(errRegisterInterface);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterInterfaceWow64")) == 0)
                {
                if (!CmdRegisterInterfaceWow64(GetParameter(szCommand)))
                    return(errRegisterInterfaceWow64);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterPadOrder")) == 0)
                {
                if (!CmdRegisterPadOrder())
                    return(errRegisterPadOrder);
                }
            else if (lstrcmpi(szCommand, TEXT("AddToPreload")) == 0)
                {
                if (!CmdAddToPreload(GetParameter(szCommand)))
                    return(errAddToPreload);
                }
            else if (lstrcmpi(szCommand, TEXT("PrepareMigration")) == 0)
                {
                if (!CmdPrepareMigration(GetParameter(szCommand)))
                    return(errPrepareMigration);
                }
            else if (lstrcmpi(szCommand, TEXT("CreateDirectory")) == 0)
                {
                if (!CmdCreateDirectory(GetParameter(szCommand)))
                    return(errCmdCreateDirectory);
                }
            else if (lstrcmpi(szCommand, TEXT("RegisterHelpDirs")) == 0)
                {
                if (!CmdRegisterHelpDirs())
                    return(errCmdRegisterHelpDirs);
                }
            else
                DebugLog(TEXT("Ignore line"));
            }
            
        fclose(fileScript);
        }
    else
        {
        wsprintf(g_szErrorMessage, TEXT("Cannot open %s"), g_szScriptFile);
        return(errNoFile);
        }

    return(errNoError);
}

/////////////////////////////////////////////////////////////////////////////
// Command handlers. Which are invoked from ProcessScriptFile
/////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    CmdSetupDefaultParameters
    Setup default parameters. For now, it only sets default ProductVersion value.
---------------------------------------------------------------------------*/
#define MAKE_STR(a) #a
#define MAKE_VERSTR(a, b, c, d) MAKE_STR(a.b.c.d)

#define VERRES_VERSIONSTR MAKE_VERSTR(VERRES_VERSION_MAJOR, VERRES_VERSION_MINOR, VERRES_VERSION_BUILD, VERRES_VERSION_REVISION)

BOOL CmdSetupDefaultParameters()
{
    _stscanf(TEXT(VERRES_VERSIONSTR), TEXT("%d.%d.%d.%d"), &g_dwMajorVersion, &g_dwMiddleVersion, &g_dwMinorVersion, &g_dwBuildNumber);

    wsprintf(g_szVersionKeyCur, "%s\\%d.%d\\%s", g_szVersionKey, g_dwMajorVersion, g_dwMiddleVersion, g_szVersion);

    DebugLog(TEXT("CmdSetupDefaultParameters: Version Info : %d.%d.%d.%d"), g_dwMajorVersion, g_dwMiddleVersion, g_dwMinorVersion, g_dwBuildNumber);

    return(TRUE);
}

/*---------------------------------------------------------------------------
    CmdSetVersion
    Overwrites default ProductVersion value with value provided in script file.
---------------------------------------------------------------------------*/
BOOL CmdSetVersion(LPCTSTR szParam)
{
    int iNum = _stscanf(szParam, TEXT("%d.%d.%d.%d"), &g_dwMajorVersion, &g_dwMiddleVersion, &g_dwMinorVersion, &g_dwBuildNumber);

    wsprintf(g_szVersionKeyCur, "%s\\%d.%d\\%s", g_szVersionKey, g_dwMajorVersion, g_dwMiddleVersion, g_szVersion);

    if (iNum == 4)
        {
        DebugLog(TEXT("CmdSetVersion: Version Info : %d.%d.%d.%d"), g_dwMajorVersion, g_dwMiddleVersion, g_dwMinorVersion, g_dwBuildNumber);
        return(TRUE);
        }
    else
        {
        ErrorLog(TEXT("CmdSetVersion: Failed to retrieve version number from string [%s]"), szParam);
        wsprintf(g_szErrorMessage, TEXT("CmdSetVersion: Failed to retrieve version number from string [%s]"), szParam);
        return(FALSE);
        }
}


/*---------------------------------------------------------------------------
    CmdFileList
    Add file to the file list. Files in the file list will be deleted when they become no longer needed.
---------------------------------------------------------------------------*/
BOOL CmdFileList(LPCTSTR szFormat)
{
    FLE flElem;
    TCHAR szExpandedFileName[MAX_PATH];
    
    flElem.fRemoved = FALSE;
    lstrcpy(flElem.szFileName, szFormat);

    if (ExpandEnvironmentStrings(flElem.szFileName, szExpandedFileName, sizeof(szExpandedFileName)/sizeof(TCHAR)))
        lstrcpy(flElem.szFileName, szExpandedFileName);

    // Add the element to file list set.
    if (g_FileList.insert(flElem).second)
        DebugLog(TEXT("Add to CmdFileList \"%s\" -> Added."), szFormat);
    else
        ErrorLog(TEXT("Add to CmdFileList \"%s\" -> Not added. Duplicate?"), szFormat);

    return(TRUE);
}


/*---------------------------------------------------------------------------
    CmdPreSetupCheck
    Check whether the newer IME has been installed. 
    Return TRUE when we can proceed. 
    !!! FALSE will terminates setup. !!!
---------------------------------------------------------------------------*/
BOOL CmdPreSetupCheck(LPCTSTR szParam)
{
    HKEY hKey;
    TCHAR szInstalledVersionString[30];
    DWORD cbInstalledVersionString = sizeof(szInstalledVersionString);
    DWORD dwInstalledMajorVersion, dwInstalledMiddleVersion, dwInstalledMinorVersion, dwInstalledBuildNumber;

    BOOL fResult = TRUE;

    RestoreMajorVersionRegistry();
    
    //
    // root
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
        {
        cbInstalledVersionString = sizeof(szInstalledVersionString);
        
        RegQueryValueEx(hKey, g_szVersion, NULL, NULL, (LPBYTE)szInstalledVersionString, &cbInstalledVersionString);
        
        if (_stscanf(szInstalledVersionString, TEXT("%d.%d"), &dwInstalledMajorVersion, &dwInstalledMiddleVersion) == 2)
            {
            if (VersionComparison2(g_dwMajorVersion, g_dwMiddleVersion) < VersionComparison2(dwInstalledMajorVersion, dwInstalledMiddleVersion))
                {
                DebugLog(TEXT("Newer version of IME has been already installed."));
                wsprintf(g_szErrorMessage, TEXT("Newer version of IME has been already installed. but, continue to setup"));
                g_fExistNewerVersion = TRUE;
                }
            }
        RegCloseKey(hKey);
        }

    //
    // current
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKeyCur, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        cbInstalledVersionString = sizeof(szInstalledVersionString);
            
        RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE)szInstalledVersionString, &cbInstalledVersionString);
        if (_stscanf(szInstalledVersionString, TEXT("%d.%d.%d.%04d"), 
                &dwInstalledMajorVersion, &dwInstalledMiddleVersion, &dwInstalledMinorVersion, &dwInstalledBuildNumber) == 4)
            {
            if (  VersionComparison4(g_dwMajorVersion, g_dwMiddleVersion, g_dwMinorVersion, g_dwBuildNumber) 
                < VersionComparison4(dwInstalledMajorVersion, dwInstalledMiddleVersion, dwInstalledMinorVersion, dwInstalledBuildNumber))
                {
                DebugLog(TEXT("Newer version of IME has been already installed."));
                wsprintf(g_szErrorMessage, TEXT("Newer version of IME has been already installed."));
                fResult = FALSE;
                    }
            }
        RegCloseKey(hKey);
        }
    
    return(fResult);
}

/*---------------------------------------------------------------------------
    CmdRenamePEFile
    Rename file with PE format version comparison.
---------------------------------------------------------------------------*/
BOOL CmdRenamePEFile(LPCTSTR szParam)
{
    TCHAR szSrc[MAX_PATH], szDst[MAX_PATH];
    TCHAR szExpandedSrc[MAX_PATH], szExpandedDst[MAX_PATH];
    LPTSTR szHitPtr;
    DWORD dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
    DWORD dwSrcMajorVersion, dwSrcMiddleVersion, dwSrcMinorVersion, dwSrcBuildNumber;
    DWORD dwDstMajorVersion, dwDstMiddleVersion, dwDstMinorVersion, dwDstBuildNumber;

    szHitPtr = _tcschr(szParam, TEXT(','));
    if (szHitPtr == NULL)
        {
        ErrorLog(TEXT("CmdRenamePEFile: Invalid parameters (%s)"), szParam);
        wsprintf(g_szErrorMessage, TEXT("CmdRenamePEFile: Invalid parameters (%s)"), szParam);
        return(FALSE);
        }
    *szHitPtr = 0;
    lstrcpy(szSrc, szParam);
    lstrcpy(szDst, szHitPtr + 1);                // Here, szDst may contain optional parameter.

    szHitPtr = _tcschr(szDst, TEXT(','));
    if (NULL != szHitPtr)
        {
        *szHitPtr = 0;
        _stscanf(szHitPtr + 1, TEXT("%d"), &dwFileAttributes);
        }

    TrimString(szSrc);
    TrimString(szDst);

    ExpandEnvironmentStrings(szSrc, szExpandedSrc, sizeof(szExpandedSrc));
    ExpandEnvironmentStrings(szDst, szExpandedDst, sizeof(szExpandedDst));

    DebugLog(TEXT("CmdRenamePEFile: szExpandedSrc = %s, szExpandedDst = %s"), szExpandedSrc, szExpandedDst);

    GetPEFileVersion(szExpandedSrc, &dwSrcMajorVersion, &dwSrcMiddleVersion, &dwSrcMinorVersion, &dwSrcBuildNumber);
    GetPEFileVersion(szExpandedDst, &dwDstMajorVersion, &dwDstMiddleVersion, &dwDstMinorVersion, &dwDstBuildNumber);

    DebugLog(TEXT("SrcVersion: (%d.%d.%d.%d), DstVersion: (%d.%d.%d.%d)"), dwSrcMajorVersion, dwSrcMiddleVersion, dwSrcMinorVersion, dwSrcBuildNumber,
                                                                           dwDstMajorVersion, dwDstMiddleVersion, dwDstMinorVersion, dwDstBuildNumber);
    if (VersionComparison4(0, 0, 0, 0) == VersionComparison4(dwSrcMajorVersion, dwSrcMinorVersion, dwSrcMiddleVersion, dwSrcBuildNumber))
        ErrorLog(TEXT("Version of source file (%s) is 0.0.0.0. May be file not found."), szSrc);

    if(VersionComparison4(dwSrcMajorVersion, dwSrcMiddleVersion, dwSrcMinorVersion, dwSrcBuildNumber) < 
        VersionComparison4(dwDstMajorVersion, dwDstMiddleVersion, dwDstMinorVersion, dwDstBuildNumber))
        {
        DebugLog(TEXT("CmdRenamePEFile: Source version is less than Destination. Copy skipped and Source will be deleted."));

        if(DeleteFile(szSrc))
            {
            FLE fleKey;
            lstrcpy(fleKey.szFileName, szSrc);
            g_FileList.erase(fleKey);
            }
        else
            DebugLog(TEXT("CmdRenamePEFile: Failed to delete Source file (%s)"), szSrc);
        }
    else
        {
        DebugLog(TEXT("CmdRenamePEFile: Invoke ActRenameFile"));
        ActRenameFile(szSrc, szDst, dwFileAttributes);
        }

    return(TRUE);
}

/*---------------------------------------------------------------------------
    CmdRenameFile
    Rename file without version comparison
---------------------------------------------------------------------------*/
BOOL CmdRenameFile(LPCTSTR szParam)
{
    TCHAR  szSrc[MAX_PATH], szDst[MAX_PATH];
    TCHAR  szExpandedSrc[MAX_PATH], szExpandedDst[MAX_PATH];
    LPTSTR szHitPtr;
    DWORD  dwFileAttributes = FILE_ATTRIBUTE_NORMAL;

    szHitPtr = _tcschr(szParam, TEXT(','));
    if (szHitPtr == NULL)
        {
        ErrorLog(TEXT("CmdRenameFile: Invalid parameters (%s)"), szParam);
        wsprintf(g_szErrorMessage, TEXT("CmdRenameFile: Invalid parameters (%s)"), szParam);
        return(FALSE);
        }
    *szHitPtr = 0;
    lstrcpy(szSrc, szParam);
    lstrcpy(szDst, szHitPtr + 1);                // Here, szDst may contain optional parameter.

    szHitPtr = _tcschr(szDst, TEXT(','));
    if (szHitPtr != NULL)
        {
        *szHitPtr = 0;
        _stscanf(szHitPtr + 1, TEXT("%d"), &dwFileAttributes);
        }

    TrimString(szSrc);
    TrimString(szDst);

    ExpandEnvironmentStrings(szSrc, szExpandedSrc, sizeof(szExpandedSrc));
    ExpandEnvironmentStrings(szDst, szExpandedDst, sizeof(szExpandedDst));

    DebugLog(TEXT("RanemeFile: szExpandedSrc = %s, szExpandedDst = %s"), szExpandedSrc, szExpandedDst);

    ActRenameFile(szExpandedSrc, szExpandedDst, dwFileAttributes);

    return(TRUE);
}

/*---------------------------------------------------------------------------
    RegisterIMEWithFixedHKL
---------------------------------------------------------------------------*/
void RegisterIMEWithFixedHKL(LPCTSTR szHKL, LPCTSTR szIMEFileName, LPCTSTR szIMEName)
{
    HKEY hKeyKbdLayout;
    HKEY hKeyOneIME;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts"),
                   &hKeyKbdLayout) != ERROR_SUCCESS)
        return;

    if (RegCreateKey(hKeyKbdLayout,
                szHKL,
                &hKeyOneIME) != ERROR_SUCCESS)
        {
        RegCloseKey(hKeyKbdLayout);
        return;
        }

    if (RegSetValueEx(hKeyOneIME,
                TEXT("Ime File"),
                0,
                REG_SZ,
                (CONST BYTE*)szIMEFileName,
                (lstrlen(szIMEFileName) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS)
        goto WriteImeLayoutFail;

    if (RegSetValueEx(hKeyOneIME,
                TEXT("Layout Text"),
                0,
                REG_SZ,
                (CONST BYTE*)szIMEName,
                (lstrlen(szIMEName) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS)
        goto WriteImeLayoutFail;

WriteImeLayoutFail:
    RegCloseKey(hKeyOneIME);
    RegCloseKey(hKeyKbdLayout);
}

/*---------------------------------------------------------------------------
    CmdRegisterInterface
    Invoke SelfReg. If given file is DLL, call DllRegisterServer export function. If given file is EXE, run it with "/RegServer" 
    command line option.
---------------------------------------------------------------------------*/
typedef HRESULT (STDAPICALLTYPE *pfnDllRegisterServerType)(void);
BOOL CmdRegisterInterface(LPCTSTR szParam)
{
    TCHAR szExpandedModulePath[MAX_PATH];
    HRESULT hr = S_FALSE;
        
    ExpandEnvironmentStrings(szParam, szExpandedModulePath, sizeof(szExpandedModulePath));
    TrimString(szExpandedModulePath);

    INT iLen = 0;
    iLen = lstrlen(szExpandedModulePath);

    if (iLen < 4)
        {
        ErrorLog(TEXT("CmdRegisterInterface: Too short szExpandedModulePath (%s)"), szExpandedModulePath);
        wsprintf(g_szErrorMessage, TEXT("CmdRegisterInterface: Invalid Parameters."));
        return(FALSE);
        }

    if (lstrcmpi(TEXT(".dll"), &szExpandedModulePath[iLen - 4]) == 0)
        {
        DebugLog(TEXT("CmdRegisterInterface: DLL mode for %s"), szExpandedModulePath);

        HINSTANCE hLib = LoadLibrary(szExpandedModulePath);

        if (hLib != NULL)
            {
            pfnDllRegisterServerType pfnDllRegisterServer = (pfnDllRegisterServerType)GetProcAddress(hLib, "DllRegisterServer");
            if (pfnDllRegisterServer != NULL)
                {
                hr = pfnDllRegisterServer();
                ErrorLog(TEXT("CmdRegisterInterface: hResult=%x"), hr);
                }
            FreeLibrary(hLib);
            }
        }
    else
        {
        if (lstrcmpi(TEXT(".exe"), &szExpandedModulePath[iLen - 4]) == 0)
            {
            DebugLog(TEXT("CmdRegisterInterface: EXE mode for %s"), szExpandedModulePath);

            TCHAR szCommandBuffer[MAX_PATH * 2];
            wsprintf(szCommandBuffer, TEXT("%s /RegServer"), szExpandedModulePath);

            STARTUPINFO si;
            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);
            si.dwFlags = STARTF_USESHOWWINDOW;
            si.wShowWindow  = SW_HIDE;

            PROCESS_INFORMATION pi;
            ZeroMemory(&pi, sizeof(pi));
            
            if (CreateProcess(NULL, szCommandBuffer, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &si, &pi))
                {
                DebugLog(TEXT("CmdRegisterInterface: Running \"%s\". Waiting for the process termination."), szCommandBuffer);

                WaitForSingleObject(pi.hProcess, INFINITE);

                DebugLog(TEXT("CmdRegisterInterface: \"%s\" terminates."), szCommandBuffer);

                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                hr = S_OK;
                }
            else
                {
                DWORD dwError = GetLastError();

                ErrorLog(TEXT("CmdRegisterInterface: CreateProcess(\"%s\") failed with error code = %d(%x)"), szCommandBuffer, dwError, dwError);
                }
            }
            else
                ErrorLog(TEXT("Cannot detect module type for %s. Skipped."), szExpandedModulePath);
        }
    
    return(SUCCEEDED(hr));
}

/*---------------------------------------------------------------------------
    CmdRegisterInterfaceWow64
    Invoke SelfReg. If given file is DLL, call DllRegisterServer export function. If given file is EXE, run it with "/RegServer" 
    command line option.
---------------------------------------------------------------------------*/
BOOL CmdRegisterInterfaceWow64(LPCTSTR szParam)
{
#if defined(_M_IA64)
    TCHAR szExpandedModulePath[MAX_PATH];
    TCHAR szCommandBuffer[MAX_PATH * 2];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    
    ExpandEnvironmentStrings(szParam, szExpandedModulePath, sizeof(szExpandedModulePath));
    TrimString(szExpandedModulePath);

    INT iLen = 0;
    iLen = lstrlen(szExpandedModulePath);

    if (iLen < 4)
        {
        ErrorLog(TEXT("CmdRegisterInterfaceWow64: Too short szExpandedModulePath (%s)"), szExpandedModulePath);
        wsprintf(g_szErrorMessage, TEXT("CmdRegisterInterface: Invalid Parameters."));
        return(FALSE);
        }

    if (lstrcmpi(TEXT(".dll"), &szExpandedModulePath[iLen - 4]) == 0)
        {
        // First get systemWow64Directory
        TCHAR szSysWow64Dir[MAX_PATH] = TEXT("");
        HMODULE hmod = GetModuleHandle(TEXT("kernel32.dll"));
        DebugLog(TEXT("CmdRegisterInterfaceWow64: DLL mode for %s"), szExpandedModulePath);

        if (hmod == NULL)
            {
            DebugLog(TEXT("CmdRegisterInterfaceWow64: Faile to load kernel32.dll"));
            return (TRUE);
            }

        UINT (WINAPI* pfnGetSystemWow64Directory)(LPTSTR, UINT);

        (FARPROC&)pfnGetSystemWow64Directory = GetProcAddress (hmod, "GetSystemWow64DirectoryA");

        if (pfnGetSystemWow64Directory == NULL)
            {
            DebugLog(TEXT("CmdRegisterInterfaceWow64: Faile to load GetSystemWow64DirectoryA API"));
            return (TRUE);
            }

        /*
         * if GetSystemWow64Directory fails and sets the last error to
         * ERROR_CALL_NOT_IMPLEMENTED, we're on a 32-bit OS
         */
        if (((pfnGetSystemWow64Directory)(szSysWow64Dir, ARRAYSIZE(szSysWow64Dir)) == 0) &&
            (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED))
                {
                DebugLog(TEXT("CmdRegisterInterfaceWow64: Failed to load GetSystemWow64DirectoryA API"));
                return (TRUE);
                }

        wsprintf(szCommandBuffer, TEXT("%s\\regsvr32.exe \"%s\" /s"), szSysWow64Dir, szExpandedModulePath);
        }
    else 
        if (lstrcmpi(TEXT(".exe"), &szExpandedModulePath[iLen - 4]) == 0)
            {
            DebugLog(TEXT("CmdRegisterInterfaceWow64: EXE mode for %s"), szExpandedModulePath);
            wsprintf(szCommandBuffer, TEXT("\"%s\" /RegServer"), szExpandedModulePath);
            }
        else
            {
            ErrorLog(TEXT("Cannot detect module type for %s. Skipped."), szExpandedModulePath);
            // Return true not to stop further processing.
            return (TRUE);
            }

        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(si);
        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow  = SW_HIDE;

        ZeroMemory(&pi, sizeof(pi));
        
        if (CreateProcess(NULL, szCommandBuffer, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &si, &pi))
            {
            DebugLog(TEXT("CmdRegisterInterfaceWow64: Running \"%s\". Waiting for the process termination."), szCommandBuffer);

            WaitForSingleObject(pi.hProcess, INFINITE);

            DebugLog(TEXT("CmdRegisterInterfaceWow64: \"%s\" terminates."), szCommandBuffer);

            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            }
        else
            {
            DWORD dwError = GetLastError();

            ErrorLog(TEXT("CmdRegisterInterfaceWow64: CreateProcess(\"%s\") failed with error code = %d(%x)"), szCommandBuffer, dwError, dwError);
            }
#endif
    return(TRUE);
}

/*---------------------------------------------------------------------------
    CmdRegisterIMEandTIP
    Register IME using IMM API and TIP
---------------------------------------------------------------------------*/
BOOL CmdRegisterIMEandTIP(LPCTSTR szParam)
{
    TCHAR szIMEFileName[MAX_PATH], szTIPName[MAX_PATH], szTIPNameWow64[MAX_PATH];
    TCHAR *szHitPtr;
    TCHAR *szHitPtr2;
    HKL hIME61KL = 0;
    TCHAR szHKL[10];
    TCHAR szNonFullPath[MAX_PATH];
    HKEY hKey;
    
    szHitPtr  = _tcschr(szParam, TEXT(','));
    szHitPtr2 = _tcschr(szHitPtr + 1, TEXT(','));        // because there are three parameters
    if (szHitPtr2 == NULL)
        {
        ErrorLog(TEXT("CmdRegisterIMEandTIP: Invalid parameters (%s)"), szParam);
        wsprintf(g_szErrorMessage, TEXT("CmdRegisterIMEandTIP: Invalid parameters (%s)"), szParam);
        return(FALSE);
        }
    *szHitPtr = 0;
    *szHitPtr2 = 0;
    lstrcpy(szIMEFileName, szParam);
    lstrcpy(szTIPName, szHitPtr + 1);
    lstrcpy(szTIPNameWow64, szHitPtr2 + 1);

    TrimString(szIMEFileName);
    TrimString(szTIPName);
    TrimString(szTIPNameWow64);
    
    ParseEnvVar(szIMEFileName, MAX_PATH);
    ParseEnvVar(szTIPName, MAX_PATH);
    ParseEnvVar(szTIPNameWow64, MAX_PATH);
    
    DebugLog(TEXT("CmdRegisterIMEandTIP: IMEFileName = %s, TIPFileName = %s szTIPNameWow64 = %s"), szIMEFileName, szTIPName, szTIPNameWow64);


    /////////////////////////////////////////////////////////////////////////////
    //    IME registration
    if ((szHitPtr = _tcsrchr(szIMEFileName, TEXT('\\'))) != NULL)
        szHitPtr++;
    else
        szHitPtr = szIMEFileName;

    lstrcpy(szNonFullPath, szHitPtr);

    hIME61KL = GetHKLfromHKLM(szNonFullPath);

    if (hIME61KL == (HKL)0)
        DebugLog(TEXT("CmdRegisterIMEandTIP: hIME61KL is zero %x --  error"), hIME61KL);

    //if (hKL && HKLHelp412ExistInPreload(HKEY_CURRENT_USER))
    //    {
    //  HKLHelpSetDefaultKeyboardLayout(HKEY_CURRENT_USER, hKL, FALSE);
        //hKL = ImmInstallIME(szIMEFileName, szLayoutText);
    //    }
        

    /////////////////////////////////////////////////////////////////////////////
    // TIP registration
    // Regster wow64 TIP first to avoid regstry overwrite problem.
    RegisterTIPWow64(szTIPNameWow64);
    RegisterTIP(szTIPName);
    
    /////////////////////////////////////////////////////////////////////////////
    // IME and TIP - make substitution
    TCHAR szTIPGuid[MAX_PATH];
    TCHAR szLangProfile[MAX_PATH];
    
    CLSIDToStringA(CLSID_KorIMX, szTIPGuid);
    DebugLog(TEXT("CmdRegisterIMEandTIP: CLSID_KorIMX guid=%s"), szTIPGuid);

    // make a reg key
    wsprintf(szLangProfile, SZTIPREG_LANGPROFILE_TEMPLATE, szTIPGuid);

    /////////////////////////////////////////////////////////////////////////////
    // Add Substitute HKL value to the TIP registry
    if (hIME61KL != 0 && RegOpenKeyEx(HKEY_LOCAL_MACHINE, szLangProfile, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        TCHAR szSubKeyName[MAX_PATH], szHKL[MAX_PATH];
        DWORD dwIndex;
        HKEY hSubKey;

        wsprintf(szHKL, TEXT("0x%x"), hIME61KL);
        dwIndex = 0;
        
        while (RegEnumKey(hKey, dwIndex, szSubKeyName, MAX_PATH) != ERROR_NO_MORE_ITEMS)
                {
                if (RegOpenKeyEx(hKey,szSubKeyName,0,KEY_ALL_ACCESS, &hSubKey) == ERROR_SUCCESS)
                    {
                    RegSetValueEx(hSubKey, TEXT("SubstituteLayout"), 0,REG_SZ,(BYTE *)szHKL, sizeof(TCHAR)*(lstrlen(szHKL)+1));
                    RegCloseKey(hSubKey);
                    }
            dwIndex++;
                }
            RegCloseKey(hKey);
            }

#if defined(_M_IA64)
    // make a reg key
    wsprintf(szLangProfile, SZTIPREG_LANGPROFILE_TEMPLATE_WOW64, szTIPGuid);

    /////////////////////////////////////////////////////////////////////////////
    // Add Substitute HKL value to the TIP registry
    if (hIME61KL != 0 && RegOpenKeyEx(HKEY_LOCAL_MACHINE, szLangProfile, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        TCHAR szSubKeyName[MAX_PATH], szHKL[MAX_PATH];
        DWORD dwIndex;
        HKEY hSubKey;

        wsprintf(szHKL, TEXT("0x%x"), hIME61KL);
        dwIndex = 0;
        
        while (RegEnumKey(hKey, dwIndex, szSubKeyName, MAX_PATH) != ERROR_NO_MORE_ITEMS)
                {
                if (RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_ALL_ACCESS, &hSubKey) == ERROR_SUCCESS)
                    {
                    RegSetValueEx(hSubKey, TEXT("SubstituteLayout"), 0, REG_SZ, (BYTE*)szHKL, sizeof(TCHAR)*(lstrlen(szHKL)+1));
                    RegCloseKey(hSubKey);
                    }
                dwIndex++;
                }
        RegCloseKey(hKey);
        }
#endif

    return(TRUE);
}

/*---------------------------------------------------------------------------
    CmdRegisterRUNKey
    Register package version
---------------------------------------------------------------------------*/
BOOL CmdRegisterPackageVersion(void)
{
    HKEY hKey;
    TCHAR szVersionString[30];

    // Write RootVersion reg only if this is latest IME.
    if (g_fExistNewerVersion == FALSE)
        {
        if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL))
            {
            wsprintf(szVersionString, TEXT("%d.%d"), g_dwMajorVersion, g_dwMiddleVersion);
            RegSetValueEx(hKey, g_szVersion, 0, REG_SZ, (CONST BYTE *)szVersionString, (lstrlen(szVersionString) + 1) * sizeof(TCHAR));
            RegCloseKey(hKey);
            }
        }
    
    // Current
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKeyCur, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
        {
        wsprintf(szVersionString, TEXT("%d.%d.%d.%d"), g_dwMajorVersion, g_dwMiddleVersion, g_dwMinorVersion, g_dwBuildNumber);
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (CONST BYTE *)szVersionString, (lstrlen(szVersionString) + 1) * sizeof(TCHAR));
        RegCloseKey(hKey);
        }

    return(TRUE);
}



//
// Register Applet order
//

#define FE_KOREAN   // need Korean stuff
#include "../fecommon/imembx/guids.h"


typedef
struct tagAPPLETCLSID 
{
    const GUID *pguidClsid;
    BOOL fNoUIM;
} APPLETCLSID;

typedef
struct tagAPPLETIID 
{
    const GUID *pguidIID;
} APPLETIID;

/*---------------------------------------------------------------------------
    CmdRegisterPadOrder
    Not support WOW64.
---------------------------------------------------------------------------*/
BOOL CmdRegisterPadOrder(void)
{
    HKEY hKey;
    TCHAR szClsid[MAX_PATH];
    TCHAR szKey[MAX_PATH];
    
    static const APPLETCLSID appletClsid[] = 
    {
        { &CLSID_ImePadApplet_MultiBox, FALSE },
        {0},
    };

    static const APPLETIID appletIID[] = 
    {
        { &IID_MultiBox },
        {0},
    };

    //
    // Applet clsid
    //
    for (INT i = 0; appletClsid[i].pguidClsid; i++)
        {
        CLSIDToStringA(*appletClsid[i].pguidClsid, szClsid);
        wsprintf(szKey, TEXT("%s\\%s"), SZAPPLETCLSID, szClsid);
        
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
            {
            if(appletClsid[i].fNoUIM)
                {
                DWORD dw = 1;
                RegSetValueEx(hKey, TEXT("nouim"), 0, NULL, (BYTE*)&dw, sizeof(DWORD));
                }

            RegCloseKey(hKey);
            }
        }


    //
    // Applet iid
    //
    TCHAR szSubKey[MAX_PATH];

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZAPPLETIID, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
            {
            for (INT i = 0; appletIID[i].pguidIID; i++)
                {
                CLSIDToStringA(*appletIID[i].pguidIID, szKey);
                wsprintf(szSubKey, TEXT("%d"), i);
                RegSetValueEx(hKey, szSubKey, 0, REG_SZ, (BYTE*)szKey, (lstrlen(szKey)+1)*sizeof(TCHAR));
                }
            RegCloseKey(hKey);
            }

    return(TRUE);
}

/*---------------------------------------------------------------------------
    CmdCreateDirectory
---------------------------------------------------------------------------*/
BOOL CmdCreateDirectory(LPCTSTR szParam)
{
    TCHAR szDirectory[MAX_PATH], szExpandedDirectory[MAX_PATH];

    lstrcpy(szDirectory, szParam);
    TrimString(szDirectory);
    ExpandEnvironmentStrings(szDirectory, szExpandedDirectory, sizeof(szExpandedDirectory)/sizeof(TCHAR));

    CreateDirectory(szExpandedDirectory, NULL);

    return(TRUE);

}

/*---------------------------------------------------------------------------
    CmdAddToPreload
    Add HKL for given IMEFile to current user's preload. The HKL won't become default IME.
---------------------------------------------------------------------------*/
BOOL CmdAddToPreload(LPCTSTR szParam)
{
    TCHAR tszIMEFileName[MAX_PATH];
    HKL hKL;

    // If there is no Kor IME exist in preload, we shouldn't add Kor IME.
    if (!HKLHelp412ExistInPreload(HKEY_CURRENT_USER))
        {
        DebugLog(TEXT("CmdAddToPreload: No 0412 HKL exist in HKCU\\Preload"));
        return TRUE;
        }

    lstrcpy(tszIMEFileName, szParam);
    TrimString(tszIMEFileName);

    hKL = GetHKLfromHKLM(tszIMEFileName);

    DebugLog(TEXT("CmdAddToPreload: Calling SetDefaultKeyboardLayout(HKEY_CURRENT_USER, %x, FALSE)"), hKL);
    HKLHelpSetDefaultKeyboardLayout(HKEY_CURRENT_USER, hKL, FALSE);

    return(TRUE);
}

/*---------------------------------------------------------------------------
    fOldIMEsExist
    Register Run regi onl if old IME exist in system.
---------------------------------------------------------------------------*/
static BOOL fOldIMEsExist()
{
    HKL hKL;

    static LPCSTR m_szOldIMEs[] = 
        {
        "msime95.ime",    // Win 95 IME
        "msime95k.ime",   // NT 4 IME
        "imekr98u.ime",    // IME98
        "imekr.ime",    // Office 10 IME
        ""
        };

    CHAR** ppch = (CHAR**)&m_szOldIMEs[0];

    while (ppch && **ppch)
        {
        hKL = GetHKLfromHKLM(*ppch);
        if (hKL)
            return TRUE;    // existing
        ppch++;
        }
    return FALSE;
}


/*---------------------------------------------------------------------------
    DisableTIP60ByDefault
---------------------------------------------------------------------------*/
VOID DisableTIP60ByDefault()
{
    // KorIMX CLSID
    // {766A2C14-B226-4fd6-B52A-867B3EBF38D2}
    const static CLSID CLSID_KorTIP60  =  
        {
        0x766A2C14,
        0xB226,
        0x4FD6,
        {0xb5, 0x2a, 0x86, 0x7b, 0x3e, 0xbf, 0x38, 0xd2}
        };

    const static GUID guidProfile60 = 
    // {E47ABB1E-46AC-45f3-8A89-34F9D706DA83}
        {
        0xe47abb1e,
        0x46ac,
        0x45f3,
        {0x8a, 0x89, 0x34, 0xf9, 0xd7, 0x6, 0xda, 0x83}
        };
        
    // Set default Tip as for Cicero.
    CoInitialize(NULL);

    ITfInputProcessorProfiles *pProfile;
    HRESULT hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (SUCCEEDED(hr)) 
        {
        pProfile->EnableLanguageProfileByDefault(CLSID_KorTIP60, 
                                        MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), guidProfile60, FALSE);
                                        
        pProfile->Release();
        }
    else
        {
        OurEnableLanguageProfileByDefault(CLSID_KorTIP60, MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), guidProfile60, FALSE);
        }
    CoUninitialize();
}

/*---------------------------------------------------------------------------
    CmdPrepareMigration
---------------------------------------------------------------------------*/
BOOL CmdPrepareMigration(LPCTSTR szParam)
{
    // Disable TIP 6.0 from HKLM by default
    // This will handle Office 10 install after Whistler mig exe removed from run reg.
    DisableTIP60ByDefault();

    // First user SID list
    if (MakeSIDList() == FALSE)
        return FALSE;

    //Register IMEKRMIG.EXE to run reg Key on "Software\Microsoft\Windows\CurrentVersion\Run"
    return RegisterRUNKey(szParam);
}

/*---------------------------------------------------------------------------
    CmdRegisterHelpDirs
---------------------------------------------------------------------------*/
BOOL CmdRegisterHelpDirs()
{
    TCHAR  szFileNameFullPath[MAX_PATH], szFileName[MAX_PATH];
    LPTSTR szExtension, szFileNamePtr;
    HKEY   hKey;

    for (std::set<FLE>::iterator itFLE = g_FileList.begin(); itFLE != g_FileList.end(); itFLE++)
        {
        lstrcpy(szFileNameFullPath, itFLE->szFileName);
        szExtension = _tcsrchr(szFileNameFullPath, TEXT('.'));
        if (szExtension == NULL)
            continue;

        if (lstrcmpi(szExtension, TEXT(".CHM")) == 0)
            {
            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\HTML Help"), 0, NULL, 
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
                {
                szFileNamePtr  = _tcsrchr(szFileNameFullPath, TEXT('\\'));
                // Get file name
                lstrcpy(szFileName, szFileNamePtr+1);
                // Get rid of file name we only need path.
                *(szFileNamePtr+1) = 0;
                RegSetValueEx(hKey, szFileName, 0, REG_SZ, (LPBYTE)szFileNameFullPath, (lstrlen(szFileNameFullPath)+1)*sizeof(TCHAR));
                }
            }
        else
            if (lstrcmpi(szExtension, TEXT(".HLP")) == 0)
            {
            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\Help"), 0, NULL, 
                                    REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL) == ERROR_SUCCESS)
                    {
                    // Get file name
                    lstrcpy(szFileName, szFileNamePtr+1);
                    // Get rid of file name we only need path.
                    *(szFileNamePtr+1) = 0;
                    RegSetValueEx(hKey, szFileName, 0, REG_SZ, (LPBYTE)szFileNameFullPath, (lstrlen(szFileNameFullPath)+1)*sizeof(TCHAR));
                    }
            }
        }
    return(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// Private functions
/////////////////////////////////////////////////////////////////////////////

//
// Debug output routine.
//
void cdecl LogOutDCPrintf(LPCTSTR lpFmt, va_list va)
{
    static INT DCLine = 0;
    HDC hDC = GetDC((HWND)0);
    TCHAR sz[512];
    HANDLE hFile;
    DWORD dwWrite;
    
    wvsprintf(sz, lpFmt, va );
    lstrcat(sz, TEXT("|    "));
    TextOut(hDC, 0, DCLine*16, sz, lstrlen(sz));

    if (DCLine++ > 50)
        DCLine = 0;
    
    hFile = CreateFile(TEXT("\\IMKRINST.LOG"), GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile != INVALID_HANDLE_VALUE)
        {
        SetFilePointer(hFile, 0, NULL, FILE_END);
        WriteFile(hFile, sz, lstrlen(sz), &dwWrite, NULL);
        WriteFile(hFile, TEXT("\r\n"), 2, &dwWrite, NULL);
        CloseHandle(hFile);
        }

    ReleaseDC((HWND)0, hDC);
}

void DebugLog(LPCTSTR szFormat, ...)
{
    va_list va;

    va_start(va, szFormat);

    if (g_fDebugLog)
        LogOutDCPrintf(szFormat, va);

    va_end(va);
}

void ErrorLog(LPCTSTR szFormat, ...)
{
    va_list va;

    va_start(va, szFormat);

    if (g_fErrorLog)
        LogOutDCPrintf(szFormat, va);

    va_end(va);
}


/*---------------------------------------------------------------------------
    ParseEnvVar
    Evaluate environment variable. Modiry given string.
---------------------------------------------------------------------------*/
INT ParseEnvVar(LPTSTR szBuffer, const UINT arg_nLength)
{
    INT iTranslated=0, i, j;
    TCHAR *pLParen, *pRParen, *pStart = szBuffer;
    INT nLength = min(arg_nLength, MAX_PATH);
    static TCHAR szInternalBuffer[MAX_PATH*2], szValue[MAX_PATH];

    szInternalBuffer[0] = 0;
    for (i=0; i<nLength; i++)
        {
        if (szBuffer[i] == 0)
            break;
            
        if (szBuffer[i] == '%')
            {
            pLParen = &(szBuffer[i]);
            pRParen = NULL;

            for (j=1; i+j<nLength; j++)
                {
                if (szBuffer[i+j] == 0)
                    break;

                if (szBuffer[i+j] == TEXT('%'))
                    {
                    pRParen = &(szBuffer[i+j]);
                    break;
                    }
                }

            if (pRParen)
                {
                *pLParen = 0;
                *pRParen = 0;
                lstrcat(szInternalBuffer, pStart);
                
                if (GetEnvironmentVariable(pLParen+1, szValue, sizeof(szValue)/sizeof(TCHAR)) == 0)
                    {
                    lstrcat(szInternalBuffer, TEXT("%"));
                    lstrcat(szInternalBuffer, pLParen+1);
                    lstrcat(szInternalBuffer, TEXT("%"));
                    }
                else
                    {
                    lstrcat(szInternalBuffer, szValue);
                    iTranslated++;
                    }
                pStart = pRParen+1;
                i += j;
                }
            }
        }
        
    if (iTranslated)
        {
        lstrcat(szInternalBuffer, pStart);
        lstrcpyn(szBuffer, szInternalBuffer, arg_nLength);
        }
        
    return(iTranslated);
}

/*---------------------------------------------------------------------------
    TrimString
    Chop head/tail white space from given string. Given string will be modified.
---------------------------------------------------------------------------*/
void TrimString(LPTSTR szString)
{
    INT iBuffSize = lstrlen(szString) + 1;
    LPTSTR szBuffer = new TCHAR[iBuffSize];

    if (szBuffer != NULL)
        {
        INT iHeadSpace, iTailSpace;

        lstrcpy(szBuffer, szString);

        iHeadSpace = (INT)_tcsspn(szBuffer, TEXT(" \t"));
        _tcsrev(szBuffer);
        iTailSpace = (INT)_tcsspn(szBuffer, TEXT(" \t"));
        _tcsrev(szBuffer);

        szBuffer[lstrlen(szBuffer) - iTailSpace] = 0;
        lstrcpy(szString, szBuffer + iHeadSpace);
        }

    if (szBuffer != NULL)
        {
        delete[] szBuffer;
        szBuffer = NULL;
        }
}

/*---------------------------------------------------------------------------
    fExistFile
---------------------------------------------------------------------------*/
BOOL fExistFile(LPCTSTR szFilePath)
{
    BOOL fResult = TRUE;

    if (GetFileAttributes(szFilePath) == -1)
        fResult = FALSE;
    
    return(fResult);
}


/*---------------------------------------------------------------------------
    ReplaceFileOnReboot
    Writes wininit.ini rename section. Note that this function writes lines in reverse order (down to upper).
---------------------------------------------------------------------------*/
BOOL WINAPI ReplaceFileOnReboot(LPCTSTR pszExisting, LPCTSTR pszNew)
{
    if (MoveFileEx(pszExisting, pszNew, MOVEFILE_DELAY_UNTIL_REBOOT)) 
        return TRUE;
    else
        return FALSE;
}

/*---------------------------------------------------------------------------
    GetPEFileVersion
    Get version information from PE format.
---------------------------------------------------------------------------*/
void GetPEFileVersion(LPTSTR szFilePath, DWORD *pdwMajorVersion, DWORD *pdwMiddleVersion, DWORD *pdwMinorVersion, DWORD *pdwBuildNumber)
{
    *pdwMajorVersion = *pdwMiddleVersion = *pdwMinorVersion = *pdwBuildNumber = 0;

    DWORD dwDummy, dwVerResSize;
    
    dwVerResSize = GetFileVersionInfoSize(szFilePath, &dwDummy);
    if (dwVerResSize)
        {
        BYTE *pbData = new BYTE[dwVerResSize];

        if (NULL != pbData)
            {
            if(GetFileVersionInfo(szFilePath, 0, dwVerResSize, pbData))
                {
                VS_FIXEDFILEINFO *pffiVersion;
                UINT cbffiVersion;

                if(VerQueryValue(pbData, TEXT("\\"), (LPVOID *)&pffiVersion, &cbffiVersion))
                    {
                    *pdwMajorVersion = HIWORD(pffiVersion->dwFileVersionMS);
                    *pdwMiddleVersion = LOWORD(pffiVersion->dwFileVersionMS);
                    *pdwMinorVersion = HIWORD(pffiVersion->dwFileVersionLS);
                    *pdwBuildNumber = LOWORD(pffiVersion->dwFileVersionLS);
                    }
                }
            }

        if (NULL != pbData)
            {
            delete[] pbData;
            pbData = NULL;
            }
        }
}

/*---------------------------------------------------------------------------
    ActRenameFile
    MoveFile. If destination file exists, it will be overwritten. If existing destination file cannot be
    overwritten in this session, file replacement is reserved to be held after rebooting.
---------------------------------------------------------------------------*/

BOOL ActRenameFile(LPCTSTR szSrcPath, LPCTSTR tszDstPath, DWORD dwFileAttributes)
{
    BOOL fReplaceAfterReboot = FALSE;
    BOOL fResult = TRUE;

    FLE fleKey;
    lstrcpy(fleKey.szFileName, szSrcPath);
    
    if (g_FileList.end() == g_FileList.find(fleKey))
        ErrorLog(TEXT("ActRenameFile: WARNING: Cannot find source file [%s] in CmdFileList"), szSrcPath);

    if (!fExistFile(szSrcPath))
        {
        ErrorLog(TEXT("ActRenameFile: Source file [%s] doesn't exist."), szSrcPath);
        wsprintf(g_szErrorMessage, TEXT("ActRenameFile: Source file [%s] doesn't exist."), szSrcPath);
        return(FALSE);
        }

    if (fExistFile(tszDstPath))
        {
        SetFileAttributes(tszDstPath, FILE_ATTRIBUTE_NORMAL);

        if(!DeleteFile(tszDstPath))
            {
            DWORD dwError = GetLastError();
            fReplaceAfterReboot = TRUE;

            DebugLog(TEXT("ActRenameFile: Cannot delete destination file [%s] with error code = %d(%x)"), tszDstPath, dwError, dwError);
            }
        }

    if (!fReplaceAfterReboot)
        {
        if(MoveFile(szSrcPath, tszDstPath))
            {
            SetFileAttributes(szSrcPath, dwFileAttributes);
            DebugLog(TEXT("ActRenameFile: MoveFile(%s, %s) succeeded."), szSrcPath, tszDstPath);
            }
        else
            {
            DWORD dwError = GetLastError();
            DebugLog(TEXT("ActRenameFile: MoveFile(%s, %s) failed with error code = %d(%x)."), szSrcPath, tszDstPath, dwError, dwError);
            DebugLog(TEXT("ActRenameFile: Try again with fReplaceAfterReboot."));
            fReplaceAfterReboot = TRUE;
            }
        }
    
    if (fReplaceAfterReboot)
        {
        SetFileAttributes(szSrcPath, dwFileAttributes);    // In this case, change file attributes for Src path.
        ReplaceFileOnReboot(szSrcPath, tszDstPath);        // Since this function writes lines in reverse order, deletion of
        DebugLog(TEXT("ActRenameFile: ReplaceFileOnReboot(%s, %s)."), szSrcPath, tszDstPath);
        ReplaceFileOnReboot(tszDstPath, NULL);              // tszDstPath will come first.
        DebugLog(TEXT("ActRenameFile: ReplaceFileOnReboot(%s, NULL)."), tszDstPath);
        }

    if (fResult)
        g_FileList.erase(fleKey);

    return(fResult);
}

///////////////////////////////////////////////////////////////////////////////
// This should sync with SERVER.CPP in TIP folder
// TIP Categories to be added
const REGISTERCAT c_rgRegCat[] =
{
    {&GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER,     &CLSID_KorIMX},
    {&GUID_TFCAT_TIP_KEYBOARD,                 &CLSID_KorIMX},
    {&GUID_TFCAT_PROPSTYLE_CUSTOM,             &GUID_PROP_OVERTYPE},
    {NULL, NULL}
};


// TIP Profile name
const REGTIPLANGPROFILE c_rgProf[] =
{
    { MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), &GUID_Profile, SZ_TIPDISPNAME, SZ_TIPMODULENAME, (IDI_UNIKOR-IDI_ICONBASE), IDS_PROFILEDESC },
    {0, &GUID_NULL, L"", L"", 0, 0}
};
//
///////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    RegisterTIP

    Write neccessary registry key and values for TIP
---------------------------------------------------------------------------*/
void RegisterTIP(LPCTSTR szTIPName)
{
    HKEY  hKey;
    TCHAR szTIPGuid[MAX_PATH];
    TCHAR szTIPProfileGuid[MAX_PATH];
    TCHAR szSubKey[MAX_PATH];
    DWORD dwValue;

    DebugLog(TEXT("RegisterTIP: (%s)."), szTIPName);
        
    // Run self reg
    // If self reg fails, run custom TIP registration
    if (!CmdRegisterInterface(szTIPName))
        {
        TCHAR szExpandedTIPPath[MAX_PATH];

        DebugLog(TEXT("RegisterTIP: TIP self reg failed, Run custom reg"));

        // Expand Env var
        ExpandEnvironmentStrings(szTIPName, szExpandedTIPPath, sizeof(szExpandedTIPPath));

        // Register TIP CLSID
        if (!RegisterServer(CLSID_KorIMX, SZ_TIPSERVERNAME, szExpandedTIPPath, TEXT("Apartment"), NULL))
            {
            DebugLog(TEXT("RegisterTIP: RegisterServer failed"));
            return;
            }

        if (!OurRegisterTIP(szExpandedTIPPath, CLSID_KorIMX, SZ_TIPNAME, c_rgProf))
            {
            DebugLog(TEXT("RegisterTIP: szExpandedTIPPath failed"));
            return;
            }

        if (FAILED(OurRegisterCategories(CLSID_KorIMX, c_rgRegCat)))
            {
            DebugLog(TEXT("RegisterTIP: OurRegisterCategories failed"));
            return;
            }

        }

    // Get String format GUIDs
    CLSIDToStringA(CLSID_KorIMX, szTIPGuid);
    CLSIDToStringA(GUID_Profile, szTIPProfileGuid);

    /////////////////////////////////////////////////////////////////////////////
    // If no Kor IME is in .default user.
    // Set HKLM [HKLM\Software\Microsoft\CTF\TIP\TIP classid\LanguageProfile\Language ID\Guid Profile]
    //     "Enable" = "0" (DWORD)
    if (RegOpenKeyEx(HKEY_USERS, TEXT(".DEFAULT"), 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        if (!HKLHelp412ExistInPreload(hKey))
            {
            HKEY hKProfRegKey;
            // Create "Software\Microsoft\CTF\TIP\{CLSID_KorIMX}\LanguageProfile\0x00000412\{CLSID_INPUTPROFILE}"
            wsprintf(szSubKey, TEXT("%s%s\\LanguageProfile\\0x00000412\\%s"), TEXT("SOFTWARE\\Microsoft\\CTF\\TIP\\"), szTIPGuid, szTIPProfileGuid);
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_ALL_ACCESS, &hKProfRegKey) == ERROR_SUCCESS)
                {
                // Enabled
                DebugLog(TEXT("RegisterTIP: IME HKL not exist in HKU\\.Default disable TIP"));
                dwValue= 0;
                RegSetValueEx(hKProfRegKey, TEXT("Enable"), 0, REG_DWORD, (BYTE*)&dwValue, sizeof(dwValue));
                RegCloseKey(hKProfRegKey);
                }
            }

        RegCloseKey(hKey);
        }

}


/*---------------------------------------------------------------------------
    RegisterTIPWow64

    Write neccessary registry key and values for TIP
---------------------------------------------------------------------------*/
void RegisterTIPWow64(LPCTSTR szTIPName)
{
#if defined(_M_IA64)
    // Run just selfreg. Cicero doesn't use "HKLM\Software\Wow6432Node\Microsoft\CTF\TIP\"
    CmdRegisterInterfaceWow64(szTIPName);
#endif
}

////////////////////////////////////////////////////////////////////////////
// HKL Helper functions
////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    GetHKLfromHKLM
---------------------------------------------------------------------------*/
HKL GetHKLfromHKLM(LPTSTR argszIMEFile)
{
    HKL  hklAnswer = 0;
    HKEY hKey, hSubKey;
    DWORD i, cbSubKey, cbIMEFile;
    TCHAR szSubKey[MAX_PATH], szIMEFile[MAX_PATH];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\Keyboard Layouts"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        for (i=0; ;i++)
            {
            cbSubKey = MAX_PATH;
            if (RegEnumKeyEx(hKey, i, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
                break;

            RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey);

            cbIMEFile=MAX_PATH;
            if (RegQueryValueEx(hSubKey, TEXT("IME File"), NULL, NULL, (LPBYTE)szIMEFile, &cbIMEFile) == ERROR_SUCCESS)
                {
                if (lstrcmpi(argszIMEFile, szIMEFile) == 0)
                    {
                    RegCloseKey(hSubKey);
                    _stscanf(szSubKey, TEXT("%08x"), &hklAnswer);
                    break;
                    }
                }
            RegCloseKey(hSubKey);
            }
            
        RegCloseKey(hKey);
        }
        
    return(hklAnswer);
}

/*---------------------------------------------------------------------------
    HKLHelpSetDefaultKeyboardLayout
---------------------------------------------------------------------------*/
void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault)
{
    TCHAR szKL[20];
    BYTE  Data[MAX_PATH];
    DWORD cbData;
    TCHAR szSubKey[MAX_PATH];
    HKEY  hKey,hSubKey;
    DWORD NumKL;

    wsprintf(szKL, TEXT("%08x"), hKL);

    RegOpenKeyEx(hKeyHKCU, TEXT("Keyboard Layout\\Preload"), 0, KEY_ALL_ACCESS, &hKey);
    RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumKL, NULL, NULL, NULL, NULL);

    for (DWORD i=0; i<NumKL; i++)
        {
        wsprintf(szSubKey, TEXT("%d"), i+1);
        cbData = MAX_PATH;
        RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

        if (lstrcmpi((LPCTSTR)Data, szKL) == 0)
            break;
        }

    // if hKL is not exist create it.
    if (NumKL == i)
        {
        wsprintf(szSubKey, TEXT("%d"), i+1);
        RegSetValueEx(hKey, szSubKey, 0, REG_SZ, (const LPBYTE)szKL, (lstrlen(szKL)+1)*sizeof(TCHAR));
        NumKL++;
        }

    // Set hKL as first, Shift down other.
    if(fSetToDefault)
        {
        for(int j=i; j>0; j--)
            {
            wsprintf(szSubKey, TEXT("%d"),j);

            cbData = MAX_PATH;
            RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

            wsprintf(szSubKey, TEXT("%d"),j+1);
            RegSetValueEx(hKey, szSubKey, 0, REG_SZ, Data, cbData);
            }
        RegSetValueEx(hKey, TEXT("1"), 0, REG_SZ, (const LPBYTE)szKL, (lstrlen(szKL)+1)*sizeof(TCHAR));
        }
    RegCloseKey(hKey);

    (void)LoadKeyboardLayout(szKL, KLF_ACTIVATE);
    // To activate IME2002 right now without reboot.
    if(fSetToDefault)
        (void)SystemParametersInfo(SPI_SETDEFAULTINPUTLANG, 0, &hKL, SPIF_SENDCHANGE);
}


#define MAX_NAME 100

/*---------------------------------------------------------------------------
    HKLHelp412ExistInPreload
---------------------------------------------------------------------------*/
BOOL HKLHelp412ExistInPreload(HKEY hKeyCU)
{
    HKEY hKey, hSubKey;
    int i ,j;
    DWORD cbName, cbData;
    CHAR szName[MAX_NAME];
    CHAR szData[MAX_NAME];
    HKL  hkl;
    FILETIME ftLastWriteTime;
    BOOL fResult = FALSE;

    if (RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        for (j=0; cbName=MAX_NAME, cbData=MAX_NAME, RegEnumValue(hKey, j, szName, &cbName, NULL, NULL, (LPBYTE)szData, &cbData) != ERROR_NO_MORE_ITEMS; j++)
            {
            // See If Korean KL exist. Just compare last LCID part if it's 0x412.
            // IME hkl set 0xE000 on hiword.
            sscanf(szData, "%08x", &hkl);
            if ((HIWORD(hkl) & 0xe000) && LOWORD(hkl) == 0x0412)
                {
                fResult = TRUE;
                break;
                }
            }
        RegCloseKey(hKey);
        }

    return(fResult);
}


/*---------------------------------------------------------------------------
    RegisterRUNKey
    Register IME using IMM API and TIP
---------------------------------------------------------------------------*/
BOOL RegisterRUNKey(LPCTSTR szParam)
{
    TCHAR szKey[MAX_PATH];
    TCHAR szFilename[MAX_PATH];
    TCHAR *szHitPtr;
    HKEY hRunKey;

    szHitPtr = _tcschr(szParam, TEXT(','));
    if (szHitPtr == NULL)
        {
        ErrorLog(TEXT("RegisterRUNKey: Invalid parameters (%s)"), szParam);
        wsprintf(g_szErrorMessage, TEXT("RegisterRUNKey: Invalid parameters (%s)"), szParam);
        return(FALSE);
        }
    *szHitPtr = 0;
    lstrcpy(szKey, szParam);
    lstrcpy(szFilename, szHitPtr + 1);

    TrimString(szKey);
    TrimString(szFilename);

    ParseEnvVar(szKey, MAX_PATH);
    ParseEnvVar(szFilename, MAX_PATH);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRunKey, NULL) == ERROR_SUCCESS)
        {
        RegSetValueEx(hRunKey, szKey, 0, REG_SZ, (CONST BYTE *)szFilename, (lstrlen(szFilename)+1)*sizeof(TCHAR));
        RegCloseKey(hRunKey);
        }

    return(TRUE);
}


/*---------------------------------------------------------------------------
    MakeSIDList
    Gets all users' SID and list that in the reg for migration
---------------------------------------------------------------------------*/
BOOL MakeSIDList()
{
    HKEY hKey, hUserList;
    DWORD i, cbName;
    BOOL fNoMoreSID = FALSE;
    TCHAR szMigRegKey[MAX_PATH], szName[500];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"), 0, KEY_READ, &hKey) ==ERROR_SUCCESS)
        {
        lstrcpy(szMigRegKey, g_szIMERootKey);
        lstrcat(szMigRegKey, TEXT("\\MigrateUser"));

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szMigRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hUserList, NULL) == ERROR_SUCCESS)
            {
            for (i=0; !fNoMoreSID; i++)
                {
                cbName = 500;
                if (RegEnumKeyEx(hKey, i, szName, &cbName, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
                    fNoMoreSID = TRUE;
                else
                    {
                    // Do not add Local Service and Network Service pid
                    if (lstrlen(szName) > 8)
                        RegSetValueEx(hUserList, szName, 0, REG_SZ, (BYTE *)TEXT(""), sizeof(TCHAR)*2);
                    }
                }

            //Change MigrateUser List security settings
            BYTE pSD[1000];
            InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
            SetSecurityDescriptorDacl(pSD, FALSE, NULL, FALSE);
            RegSetKeySecurity(hUserList, DACL_SECURITY_INFORMATION, pSD);                

            RegCloseKey(hUserList);
            }
        RegCloseKey(hKey);
        }
    return (TRUE);
}

/*---------------------------------------------------------------------------
    RestoreMajorVersionRegistry

    Restore IME major version reg value. 
    It could be overwritten during Win9x to NT upgrade.
---------------------------------------------------------------------------*/
void RestoreMajorVersionRegistry()
{
    HKEY  hKey;
    
    ///////////////////////////////////////////////////////////////////////////
    // Restore IME major version reg value. 
    // It could be overwritten during Win9x to NT upgrading.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        CHAR  szVersion[MAX_PATH];
        DWORD cbVersion = MAX_PATH;
    	CHAR szMaxVesrion[MAX_PATH];
		FILETIME time;
		float flVersion, flMaxVersion;

        lstrcpy(szMaxVesrion, "0");
 		for (int i=0; cbVersion = MAX_PATH, RegEnumKeyEx(hKey, i, szVersion, &cbVersion, NULL, NULL, NULL, &time) != ERROR_NO_MORE_ITEMS; i++)
            {
            if (lstrcmp(szVersion, szMaxVesrion) > 0)
                lstrcpy(szMaxVesrion, szVersion);
            }

        lstrcpy(szVersion, "0");
        RegQueryValueEx(hKey, g_szVersion, NULL, NULL, (BYTE *)szVersion, &cbVersion);
        flVersion = (float)atof(szVersion);
        flMaxVersion = (float)atof(szMaxVesrion);

        if (flVersion < flMaxVersion)
            RegSetValueEx(hKey, g_szVersion, 0, REG_SZ, (BYTE *)szMaxVesrion, (sizeof(CHAR)*lstrlen(szMaxVesrion)));

        RegCloseKey(hKey);
	}
    ///////////////////////////////////////////////////////////////////////////
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\apientry.cpp ===
/****************************************************************************
    APIENTRY.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    API entries between IMM32 and IME

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "apientry.h"
#include "common.h"
#include "ui.h"
#include "hauto.h"
#include "dllmain.h"
#include "hanja.h"
#include "escape.h"
#include "config.h"
#include "names.h"
#include "winex.h"
#include "hanja.h"
#include "cpadsvr.h"
#include "debug.h"

///////////////////////////////////////////////////////////////////////////////
// ImeMenu Define
#define NUM_ROOT_MENU_L 4
#define NUM_ROOT_MENU_R 1
#define NUM_SUB_MENU_L 0
#define NUM_SUB_MENU_R 0

#define IDIM_ROOT_ML_1       0x10
#define IDIM_ROOT_ML_2       0x11
#define IDIM_ROOT_ML_3       0x12
#define IDIM_ROOT_ML_4       0x13
#define IDIM_ROOT_MR_1       0x30

///////////////////////////////////////////////////////////////////////////////
// Private function Declarations
PRIVATE BOOL IsInSystemSetupMode();
PRIVATE BOOL IsRunningAsLocalSystem();
PRIVATE BOOL IsRunningInOOBE();
PRIVATE BOOL PASCAL Select(HIMC hImc, BOOL fSelect);
PRIVATE VOID PASCAL UpdateOpenCloseState(PCIMECtx pImeCtx);
PRIVATE VOID PASCAL ToAsciiExHangulMode(PCIMECtx pImeCtx, UINT uVirKey, UINT uScanCode, CONST LPBYTE lpbKeyState);
PRIVATE BOOL PASCAL ToAsciiExHanja(PCIMECtx pImeCtx, UINT uVirKey, CONST LPBYTE lpbKeyState);

PRIVATE WCHAR PASCAL Banja2Junja(WCHAR bChar);
PRIVATE BOOL  PASCAL IsKSC5601(WCHAR wcCur);


/*----------------------------------------------------------------------------
    ImeInquire

    This function handle initialization of IME. It also returns IMEINFO structure 
    and UI class name of IME
----------------------------------------------------------------------------*/
BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPTSTR lpszWndClass, DWORD dwSystemInfoFlags)
{
    BOOL    fRet = fFalse;

    Dbg(DBGID_API, TEXT("ImeInquire():lpIMEInfo = 0x%08lX, dwSystemInfoFlags = 0x%08lX"), lpIMEInfo, dwSystemInfoFlags);

    if (lpIMEInfo)
        {
        lpIMEInfo->dwPrivateDataSize = sizeof(IMCPRIVATE);    // The private data in an IME context.
        lpIMEInfo->fdwProperty =  IME_PROP_AT_CARET            // IME conversion window is at caret position.
                                | IME_PROP_NEED_ALTKEY        // ALT key pass into ImeProcessKey
                                | IME_PROP_CANDLIST_START_FROM_1 // Candidate list start from 1
                                | IME_PROP_END_UNLOAD;

        if (IsMemphis() || IsWinNT5orUpper())
            lpIMEInfo->fdwProperty |= IME_PROP_COMPLETE_ON_UNSELECT; // Complete when IME unselected.

        lpIMEInfo->fdwConversionCaps =   IME_CMODE_NATIVE        // IMEs in NATIVE mode else ALPHANUMERIC mode
                                       | IME_CMODE_FULLSHAPE    // else in SBCS mode
                                       | IME_CMODE_HANJACONVERT;// Hangul hanja conversion

        lpIMEInfo->fdwSentenceCaps = 0;                            // IME sentence mode capability
        lpIMEInfo->fdwUICaps = 0;
        lpIMEInfo->fdwSCSCaps = SCS_CAP_COMPSTR;                // IME can generate the composition string by SCS_SETSTR
        lpIMEInfo->fdwSelectCaps = SELECT_CAP_CONVERSION;        // ImeSetCompositionString capability

        // Set Unicode flag if system support it
        if (vfUnicode == fTrue)
            lpIMEInfo->fdwProperty |= IME_PROP_UNICODE;    // String content of the Input Context will be UNICODE

        // NT5 Unicode injection through VK_PACKET
        if (IsWinNT5orUpper())
            lpIMEInfo->fdwProperty |= IME_PROP_ACCEPT_WIDE_VKEY;
            
        // Return Unicode string for Unicode environment
#ifndef UNDER_CE // Windows CE always Unicode
        if (vfUnicode == fTrue) 
            StrCopyW((LPWSTR)lpszWndClass, wszUIClassName);
        else
            lstrcpyA(lpszWndClass, szUIClassName);
#else // UNDER_CE
        lstrcpyW(lpszWndClass, wszUIClassName);
#endif // UNDER_CE

        fRet = fTrue;
        }
    
    //////////////////////////////////////////////////////////////////////////
    // 16 bit application check
    // If client is 16 bit Apps, only allow KS C-5601 chars.

    if (IsWinNT())
        {
        // Win98 does not pass dwSystemInfoFlags;
        vpInstData->dwSystemInfoFlags = dwSystemInfoFlags;
            
        if (dwSystemInfoFlags & IME_SYSINFO_WOW16)
            vpInstData->f16BitApps = fTrue;

        // If in MT setup mode(system setup, upgrading and OOBE), display IME status window.
        if (IsInSystemSetupMode())
            vpInstData->dwSystemInfoFlags |= IME_SYSINFO_WINLOGON;
        }
    else
        {
        // user GetProcessVersion
        DWORD dwVersion = GetProcessVersion(GetCurrentProcessId());
        // Windowss 3.x
        if (HIWORD(dwVersion) <= 3)
            {
            vpInstData->f16BitApps = fTrue;
        #ifdef DEBUG
            DebugOutT(TEXT("!!! 16bit Apps running under Win9x !!!\r\n"));
        #endif
            }
        }

    // If 16bit apps, always disable ISO10646(full range Hangul)
    if (vpInstData->f16BitApps == fTrue)
        vpInstData->fISO10646 = fFalse;
        
    return fRet;
}

/*----------------------------------------------------------------------------
    ImeConversionList

    obtain the list of candidate list from one character
----------------------------------------------------------------------------*/
DWORD WINAPI ImeConversionList(HIMC hIMC, LPCTSTR lpSource, LPCANDIDATELIST lpDest, DWORD dwBufLen, UINT uFlag)
{
    WCHAR wchHanja;

    Dbg(DBGID_API, TEXT("ImeConversionList():hIMC = 0x%08lX, *lpSource = %04X, dwBufLen =%08lX"), hIMC, *(LPWSTR)lpSource, dwBufLen);

    if (hIMC == NULL)
        return 0;
        
    if (lpSource == NULL || *(LPWSTR)lpSource==0)
        return 0;

    // If dwBufLen==0 then should return buffer size
    if (dwBufLen && lpDest == NULL)
        return 0;

    //
    // Code Conversion
    //
    // CONFIRM: Win98 send Unicode or not?
    if (IsMemphis() || IsWinNT())
        wchHanja = *(LPWSTR)lpSource;
    else 
        {
        if (MultiByteToWideChar(CP_KOREA, MB_PRECOMPOSED, lpSource, 2, &wchHanja, 1) == 0)
            return 0;
        }

    switch (uFlag)
        {
        case GCL_CONVERSION:
            return GetConversionList(wchHanja, lpDest, dwBufLen);
            break;
        case GCL_REVERSECONVERSION:
        case GCL_REVERSE_LENGTH:
            break;
        default:
            DbgAssert(0);
        }
    return (0);
}

/*----------------------------------------------------------------------------
    ImeConfigure

    Open IME configuration DLG
----------------------------------------------------------------------------*/
BOOL WINAPI ImeConfigure(HKL hKL, HWND hWnd, DWORD dwMode, LPVOID lpData)
{
    BOOL fRet = fFalse;

    Dbg    (DBGID_API, TEXT("ImeConfigure():hKL = 0x%08lX, dwMode = 0x%08lX"), hKL, dwMode);
    
    switch (dwMode)
        {
        case IME_CONFIG_GENERAL:
            if (ConfigDLG(hWnd))
                fRet = fTrue;
            break;

        default:
            break;
        }
    return fRet;
}

/*----------------------------------------------------------------------------
    ImeDestroy
----------------------------------------------------------------------------*/
BOOL WINAPI ImeDestroy(UINT uReserved)
{
    Dbg(DBGID_API, TEXT("ImeDestroy(): Bye  *-<\r\nSee Again !"));
    if (uReserved)
        return (fFalse);
    else
        return (fTrue);
}

/*----------------------------------------------------------------------------
    ImeEscape

    Support Korean IME escape functions
----------------------------------------------------------------------------*/
LRESULT WINAPI ImeEscape(HIMC hIMC, UINT uSubFunc, LPVOID lpData)
{
    PCIMECtx     pImeCtx = GetIMECtx(hIMC);
    LRESULT        lRet;

    if (pImeCtx == NULL)
        return 0;
        
    Dbg(DBGID_API, TEXT("ImeEscape():hIMC = 0x%08lX, uSubFunc = 0x%08lX"), hIMC, uSubFunc);
    switch (uSubFunc)
        {
        case IME_ESC_AUTOMATA:
            lRet = EscAutomata(pImeCtx, (LPIMESTRUCT32)lpData, fTrue);
            break;

        case IME_AUTOMATA:
            lRet = EscAutomata(pImeCtx, (LPIMESTRUCT32)lpData, fFalse);
            break;

        case IME_GETOPEN:
            lRet = EscGetOpen(pImeCtx, (LPIMESTRUCT32)lpData);
            break;

        // Popup Hanja candidate window
        case IME_ESC_HANJA_MODE:
            if (lRet = EscHanjaMode(pImeCtx, (LPSTR)lpData, fTrue))
                {
                pImeCtx->SetCandidateMsg(CIMECtx::MSG_OPENCAND);
                pImeCtx->GenerateMessage();
                }
            break;

        // 16bit apps(Win 3.1) compatibility
        case IME_HANJAMODE:
            if (lRet = EscHanjaMode(pImeCtx, (LPSTR)lpData, fFalse))
                {
                pImeCtx->SetCandidateMsg(CIMECtx::MSG_OPENCAND);
                pImeCtx->GenerateMessage();
                }
            break;

        case IME_SETOPEN:
            lRet = EscSetOpen(pImeCtx, (LPIMESTRUCT32)lpData);
            break;

        case IME_MOVEIMEWINDOW:
            lRet = EscMoveIMEWindow(pImeCtx, (LPIMESTRUCT32)lpData);
            break;

        case 0x1100:
            lRet = EscGetIMEKeyLayout(pImeCtx, (LPIMESTRUCT32)lpData);
            break;

        default:
            Dbg(DBGID_Misc, TEXT("Unknown ImeEscape() subfunc(#0x%X) is called."), uSubFunc);
            return (0);
        }
    return (lRet);
    
}

/*----------------------------------------------------------------------------
    ImeSetActiveContext
----------------------------------------------------------------------------*/
BOOL WINAPI ImeSetActiveContext(HIMC hIMC, BOOL fActive)
{
    Dbg(DBGID_API, TEXT("ImeSetActiveContext():hIMC = 0x%08lX, fActive = 0x%d"), hIMC, fActive);

    // Initialize composition context. For Korean IME, don't need to kee composition str,
    // when context changed.
    //if (pImeCtx)
        //{
        //pImeCtx->ClearCompositionStrBuffer();
        //pImeCtx->GetAutomata()->InitState();
        //pImeCtx->ResetComposition();
        //}
// CONFIRM: Is this really safe to disable?
#if 0
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;

    Dbg(DBGID_API, _T("ImeSetActiveContext():hIMC = 0x%08lX, fActive = 0x%d"), hIMC, fActive);

    if (!hIMC)
        return fFalse;

    lpIMC = ImmLockIMC(hIMC);
    if (!lpIMC)
        return fFalse;

    if (fActive)
        {
        if (lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr)) 
            {
            if (lpCompStr->dwCompStrLen)
                {
                 CIMEData            ImeData;

                // if composition character mismatched with Automata object's reset with lpCompStr
                // I'm really suspicious when this situation occurs. I think never occur... -cslim
                if (pInstData->pMachine->GetCompositionChar()
                    != *(LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset)) 
                    {
                    pInstData->pMachine->InitState();
                    pInstData->pMachine->
                        SetCompositionChar(*(LPWSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset));
                    }
                }
            ImmUnlockIMCC(lpIMC->hCompStr);
            }
        }

    ImmUnlockIMC(hIMC);
#endif

    return fTrue;
}

/*----------------------------------------------------------------------------
    ImeProcessKey

    Return fTrue if IME should process the key
----------------------------------------------------------------------------*/
BOOL WINAPI ImeProcessKey(HIMC hIMC, UINT uVirKey, LPARAM lParam, CONST LPBYTE lpbKeyState)
{
    PCIMECtx pImeCtx;
    WORD     uScanCode;
    BOOL     fRet = fFalse;

    Dbg(DBGID_API, TEXT("ImeProcessKey():hIMC=0x%08lX, uVKey=0x%04X, lParam=0x%08lX"), hIMC, uVirKey, lParam);

    // NT5 Unicode injection
    uVirKey   = (UINT)LOWORD(uVirKey);
    uScanCode = HIWORD(lParam);
    
    if (uVirKey == VK_PROCESSKEY)    // Mouse button clicked
        { 
        Dbg(DBGID_Key, TEXT("ImeProcessKey : return fTrue - Mouse Button Pressed"));
        return fTrue;
        } 
    else if (uScanCode & KF_UP) 
        {
        Dbg(DBGID_Key, TEXT("ImeProcessKey : return fFalse - KF_UP"));
        return (fFalse);
        } 
    else if (uVirKey == VK_SHIFT) // no SHIFT key
        {
        Dbg(DBGID_Key, TEXT("ImeProcessKey : return fFalse - VK_SHIFT"));
        return (fFalse);
        } 
    else if (uVirKey == VK_CONTROL) // no CTRL key
        {
        Dbg(DBGID_Key, TEXT("ImeProcessKey : return fFalse - VK_CONTROL"));
        return (fFalse);
        } 
    else if (uVirKey == VK_HANGUL || uVirKey == VK_JUNJA || uVirKey == VK_HANJA) 
        {
         Dbg(DBGID_Key, TEXT("ImeProcessKey : return fTrue - VK_HANGUL, VK_JUNJA, VK_HANJA"));
        return (fTrue);
        }
    else 
        {
        // need more check
        }

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;
    
    // If IME close, return with no action.
    if (pImeCtx->IsOpen() == fFalse)
        {              
        Dbg(DBGID_Key, TEXT("ImeProcessKey : return fFalse - IME closed"));
        return fFalse;
        }

    // If Hanja conv mode return fTrue. ImeToAsciiEx will handle.
    if (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)
        {
        return fTrue;
        }
    
    // If interim state
    if (pImeCtx->GetCompBufLen())
        {
        // If ALT key down and in composition process, finalize it.
        if (uVirKey == VK_MENU) 
            {
            Dbg(DBGID_Key, TEXT("ImeProcessKey : Finalize and return fFalse - VK_MENU"));
            pImeCtx->FinalizeCurCompositionChar();
            pImeCtx->GenerateMessage();
            }
        else 
            {
            Dbg(DBGID_Key, TEXT("ImeProcessKey : Interim state. Key pressed except ALT"));
            fRet = fTrue;
            }
        } 
    else // If composition string does not exist,
        {         
        // if Ctrl+xx key, do not process in non-interim mode
        if (IsControlKeyPushed(lpbKeyState) == fFalse)
            {
            // If Hangul mode
            if (pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) 
                {    // Start of hangul composition
                WORD         wcCur;

                wcCur = pImeCtx->GetAutomata()->GetKeyMap(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 );
                // 2beolsik Alphanumeric keys have same layout as English key
                // So we don't need process when user pressed Alphanumeric key under 2beolsik
                if ( (wcCur && pImeCtx->GetGData()->GetCurrentBeolsik() != KL_2BEOLSIK) || (wcCur & H_HANGUL) )
                    fRet = fTrue;
                }

            // if IME_CMODE_FULLSHAPE
            if (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE) 
                {
                if (CHangulAutomata::GetEnglishKeyMap(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0))
                    fRet = fTrue;
                }
            }
        }

    // NT 5 Unicode injection
    if (uVirKey == VK_PACKET)
        {
        Dbg(DBGID_Key, TEXT("ImeProcessKey : VK_PACKET"));
        fRet = fTrue;
        }
        
    Dbg(DBGID_Key, TEXT("ImeProcessKey : return value = %d"), fRet);
    return fRet;
}

/*----------------------------------------------------------------------------
    NotifyIME

    Change the status of IME according to the given parameter
----------------------------------------------------------------------------*/
BOOL WINAPI NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
    PCIMECtx          pImeCtx;
    BOOL             fRet = fFalse;

    Dbg(DBGID_API, TEXT("NotifyIME():hIMC = 0x%08lX, dwAction = 0x%08lX, dwIndex = 0x%08lX, dwValue = 0x%08lX"), hIMC, dwAction, dwIndex, dwValue);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;

    switch (dwAction)
        {
    case NI_COMPOSITIONSTR:
           switch (dwIndex)
            {
        //////////////////////////////////////////////////////////
        case CPS_COMPLETE:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_COMPOSITIONSTR-CPS_COMPLETE"));

            // If composition state
            if (pImeCtx->GetCompBufLen()) 
                {
                // For ESC_HANJAMODE call this, we should reset comp str.
                pImeCtx->ResetComposition();
                pImeCtx->SetResultStr(pImeCtx->GetCompBufStr());
                pImeCtx->SetEndComposition(fTrue);
                pImeCtx->StoreComposition();

                // Raid #104
                if (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)
                    {
                    // Cancel Hanja change mode
                    pImeCtx->SetConversionMode(pImeCtx->GetConversionMode() & ~IME_CMODE_HANJACONVERT);
                    pImeCtx->SetCandidateMsg(CIMECtx::MSG_CLOSECAND);
                    }

                // Clear all automata states
                pImeCtx->GetAutomata()->InitState();
                pImeCtx->GenerateMessage();

                fRet = fTrue;
                }
            break;
    
        //////////////////////////////////////////////////////////
        case CPS_CANCEL:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_COMPOSITIONSTR-CPS_CANCEL"));

            // if composition string exist, remove it and send WM_IME_ENDCOMPOSITION
            if (pImeCtx->GetCompBufLen())
                {
                pImeCtx->SetEndComposition(fTrue);
                pImeCtx->GenerateMessage();
                pImeCtx->ClearCompositionStrBuffer();
                
                fRet = fTrue;
                }
            break;
        
        //////////////////////////////////////////////////////////                    
        case CPS_CONVERT: 
        case CPS_REVERT:

        default:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_COMPOSITIONSTR-CPS_CONVERT or CPS_REVERT !!! NOT IMPMLEMENTED !!!"));
            break;
            } // switch (dwIndex)
        break;

    case NI_OPENCANDIDATE:
        Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_OPENCANDIDATE"));
        // if not Hanja mocde
        if (!(pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT))
            {
            if (pImeCtx->GetCompBufLen() && GenerateHanjaCandList(pImeCtx))
                {
                pImeCtx->SetCandidateMsg(CIMECtx::MSG_OPENCAND);
                // Set Hanja conv mode
                pImeCtx->SetConversionMode(pImeCtx->GetConversionMode() | IME_CMODE_HANJACONVERT);
                OurSendMessage(pImeCtx->GetAppWnd(), WM_IME_NOTIFY, IMN_SETCONVERSIONMODE, 0L);
                pImeCtx->GenerateMessage();
                fRet = fTrue;
                }
            }
        break;

    case NI_CLOSECANDIDATE:
        if (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)
            {
            pImeCtx->SetCandidateMsg(CIMECtx::MSG_CLOSECAND);
            // Set clear Hanja conv mode
            pImeCtx->SetConversionMode(pImeCtx->GetConversionMode() & ~IME_CMODE_HANJACONVERT);
            // To Notify to UI wnd
            OurSendMessage(pImeCtx->GetAppWnd(), WM_IME_NOTIFY, IMN_SETCONVERSIONMODE, 0L);
            pImeCtx->GenerateMessage();
            fRet = fTrue;
            }
        break;

    case NI_SELECTCANDIDATESTR:
    case NI_SETCANDIDATE_PAGESTART:
        Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_SETCANDIDATE_PAGESTART"));
        if (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)
            {
            pImeCtx->SetCandStrSelection(dwValue);
            pImeCtx->SetCandidateMsg(CIMECtx::MSG_CHANGECAND);
            pImeCtx->GenerateMessage();
            fRet = fTrue;
            }
        break;

    case NI_CONTEXTUPDATED:
        Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_CONTEXTUPDATED"));
        switch (dwValue)
            {
        case IMC_SETOPENSTATUS:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_CONTEXTUPDATED - IMC_SETOPENSTATUS"));
            Dbg(DBGID_IMENotify, TEXT("pImeCtx->GetConversionMode() = 0x%08lX"), pImeCtx->GetConversionMode());
            UpdateOpenCloseState(pImeCtx);
            fRet = fTrue;
            break;                        

        case IMC_SETCONVERSIONMODE:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_CONTEXTUPDATED - IMC_SETCONVERSIONMODE"));
            Dbg(DBGID_IMENotify, TEXT("pImeCtx->GetConversionMode() = 0x%08lX"), pImeCtx->GetConversionMode());
            UpdateOpenCloseState(pImeCtx);
            fRet = fTrue;
            break;                        
        //case IMC_SETSTATUSWINDOWPOS:
        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETCOMPOSITIONWINDOW:
            //DbgAssert(0);
            fRet = fTrue;
            break;

        default:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_CONTEXTUPDATED - Unhandeled IMC value = 0x%08lX"), dwValue);
            break;
            } // switch (dwValue)
        break;
            
    case NI_IMEMENUSELECTED:
        Dbg(DBGID_IMENotify, TEXT("NotifyIME(): NI_IMEMENUSELECTED"));
        switch (dwIndex) 
            {
        case IDIM_ROOT_MR_1:
            // BUGBUG: NT Bug #379149
            // Because Internat uses SendMessage, If user does not cancel the DLG, Deadlock occurs.
            // ImeConfigure(GetKeyboardLayout(NULL), pImeCtx->GetAppWnd(), IME_CONFIG_GENERAL, NULL);
            OurPostMessage(GetActiveUIWnd(), WM_MSIME_PROPERTY, 0L, IME_CONFIG_GENERAL);
            break;
        case IDIM_ROOT_ML_4: 
            fRet = OurImmSetConversionStatus(hIMC, 
                    (pImeCtx->GetConversionMode() & ~IME_CMODE_HANGUL) | IME_CMODE_FULLSHAPE,
                    pImeCtx->GetSentenceMode());
            break;
        case IDIM_ROOT_ML_3:
            fRet = OurImmSetConversionStatus(hIMC, 
                    pImeCtx->GetConversionMode() & ~(IME_CMODE_HANGUL | IME_CMODE_FULLSHAPE),
                    pImeCtx->GetSentenceMode());
            break;
        case IDIM_ROOT_ML_2: 
            fRet = OurImmSetConversionStatus(hIMC, 
                    pImeCtx->GetConversionMode() | IME_CMODE_HANGUL | IME_CMODE_FULLSHAPE,
                    pImeCtx->GetSentenceMode());
            break;
        case IDIM_ROOT_ML_1:
            fRet = OurImmSetConversionStatus(hIMC, 
                    (pImeCtx->GetConversionMode() | IME_CMODE_HANGUL) & ~IME_CMODE_FULLSHAPE,
                    pImeCtx->GetSentenceMode());
            break;
            } //         switch (dwIndex) 
        break;
        
    case NI_CHANGECANDIDATELIST:
    case NI_FINALIZECONVERSIONRESULT:
    case NI_SETCANDIDATE_PAGESIZE:
        default:
            Dbg(DBGID_IMENotify, TEXT("NotifyIME(): Unhandeled NI_ value = 0x%08lX"), dwAction);
        break;
        } // switch (dwAction)

    return fRet;
}

/*----------------------------------------------------------------------------
    ImeSelect

    Initialize/Uninitialize IME private context
----------------------------------------------------------------------------*/
BOOL WINAPI ImeSelect(HIMC hIMC, BOOL fSelect)    // fTrue-initialize, fFalse-uninitialize(free resource)
{
    BOOL fRet = fFalse;

    Dbg(DBGID_API, TEXT("ImeSelect():hIMC = 0x%08lX, fSelect = 0x%d"), hIMC, fSelect);

    if (!hIMC) // if invalid input context handle
        {
        DbgAssert(0);
        return fFalse;
        }

    // If DLL_PROCESS_DETACH already called once.
    if (vfDllDetachCalled)
        {
        return fFalse;
        }

    fRet = Select(hIMC, fSelect);

    return fRet;
}

/*----------------------------------------------------------------------------
    ImeSetCompositionString
----------------------------------------------------------------------------*/
BOOL WINAPI ImeSetCompositionString(HIMC hIMC, DWORD dwIndex, LPVOID lpComp,
                                    DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
{
    PCIMECtx     pImeCtx;
    WCHAR        wcComp;
    BOOL        fSendStart, 
                fRet = fFalse;

    Dbg(DBGID_API|DBGID_SetComp, TEXT("ImeSetCompositionString():hIMC = 0x%08lX, dwIndex = 0x%08lX, lpComp = 0x%04X"), hIMC, dwIndex, *(LPWSTR)lpComp);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;

    if (dwIndex == SCS_SETSTR)
        {
        // Conv mode check
        if ((pImeCtx->GetConversionMode() & IME_CMODE_HANGUL)==0)
            {
            Dbg(DBGID_API|DBGID_SetComp, TEXT("!!! WARNING !!!: ImeSetCompositionString(): English mode"));
            return fFalse;
            }

        // Send WM_IME_STARTCOMPOSITION if not interim state.
        fSendStart = pImeCtx->GetCompBufLen() ? fFalse : fTrue;

        wcComp = L'\0';
        // Parameter check
        if (lpComp != NULL && *(LPWSTR)lpComp != L'\0' && dwCompLen != 0)
            {
            if (pImeCtx->IsUnicodeEnv())
                wcComp = *(LPWSTR)lpComp;
            else
                if (MultiByteToWideChar(CP_KOREA, MB_PRECOMPOSED, (LPSTR)lpComp, 2, &wcComp, 1) == 0)
                    {
                    DbgAssert(0);
                    wcComp = 0;
                    }

            // Hangul range check
            if ( (wcComp > 0x3130  && wcComp < 0x3164) || 
                 (wcComp >= 0xAC00 && wcComp < 0xD7A4) )
                {
                pImeCtx->SetCompositionStr(wcComp);
                pImeCtx->StoreComposition();
                }
            else
                {
                Dbg(DBGID_SetComp, TEXT("!!! WARNING !!!: lpComp is null or Input character is not Hangul"));
                DbgAssert(0);
                wcComp = 0;
                }
            }

        // Send WM_IME_STARTCOMPOSITION
        if (fSendStart)
            pImeCtx->SetStartComposition(fTrue);

        // REVIEW: Even if wcComp ==0, Should send WM_IME_COMPOSITION
        // Send composition char
        //SetTransBuffer(lpTransMsg, WM_IME_COMPOSITION, 
        //                (WPARAM)wcComp, (GCS_COMPSTR|GCS_COMPATTR|CS_INSERTCHAR|CS_NOMOVECARET));

        // Set Automata state if non-null comp char
        if (wcComp) 
            pImeCtx->GetAutomata()->SetCompositionChar(wcComp);
        else
            {
            // REVIEW: Even if wcComp ==0, Should send WM_IME_COMPOSITION
            pImeCtx->ClearCompositionStrBuffer();
            pImeCtx->AddMessage(WM_IME_COMPOSITION, 0, (GCS_COMPSTR|GCS_COMPATTR|CS_INSERTCHAR|CS_NOMOVECARET));
            pImeCtx->SetEndComposition(fTrue);
            pImeCtx->GetAutomata()->InitState();
            }

        // Generate IME message
        pImeCtx->GenerateMessage();

        fRet = fTrue;
        }

    return fRet;
}
    
/*----------------------------------------------------------------------------
    ImeToAsciiEx
----------------------------------------------------------------------------*/
UINT WINAPI ImeToAsciiEx(UINT uVirKey, UINT uScanCode, CONST LPBYTE lpbKeyState,
                         LPTRANSMSGLIST lpTransBuf, UINT fuState, HIMC hIMC)
{
    PCIMECtx pImeCtx;
    UINT     uNumMsg=0;
    WORD     bKeyCode;

    Dbg(DBGID_API, TEXT("ImeToAsciiEx(): hIMC = 0x%08lX, uVirKey = 0x%04X, uScanCode = 0x%04X"), hIMC, uVirKey, uScanCode);
    Dbg(DBGID_Key, TEXT("lpbKeyState = 0x%08lX, lpdwTransBuf = 0x%08lX, fuState = 0x%04X"), lpbKeyState, lpTransBuf, fuState);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return 0;

    // Start process key
    pImeCtx->SetProcessKeyStatus(fTrue);

    // special message buffer for ToAsciiEx()
    pImeCtx->SetTransMessage(lpTransBuf);

    ///////////////////////////////////////////////////////////////////////////
    // If Hanja conv mode
    if (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)
        {
        if (ToAsciiExHanja(pImeCtx, uVirKey, lpbKeyState) == fFalse)
            goto ToAsciiExExit_NoMsg;
        }
    else
        {
        ///////////////////////////////////////////////////////////////////////////
        // W2K specific - Unicode injection
        if (LOWORD(uVirKey) == VK_PACKET) 
            {
            WCHAR wch = HIWORD(uVirKey);
            Dbg(DBGID_Key, TEXT("ImeToAsciiEx: VK_PACKET arrived(NonHanja conv mode)"));

            // If composition char exist, first finalize and append injection char, then send all.
            if (pImeCtx->GetCompBufLen()) 
                {
                pImeCtx->FinalizeCurCompositionChar();
                pImeCtx->AppendResultStr(wch);
                }
            else
                // If no composition char exist, just insert injection char as finalized char.
                pImeCtx->SetResultStr(wch);
            goto ToAsciiExExit;
            }

        ///////////////////////////////////////////////////////////////////////////
        // If Non-Hanja conv mode
        switch (uVirKey) 
            {
        case VK_PROCESSKEY:    // if mouse button clicked 
            Dbg(DBGID_Key, TEXT("ImeToAsciiEx : VK_PROCESSKEY"));
            if (pImeCtx->GetCompBufLen()) 
                pImeCtx->FinalizeCurCompositionChar();
            break;
        
        case VK_HANGUL :
            Dbg(DBGID_Key, "             -  VK_HANGUL");
            if (pImeCtx->GetCompBufLen()) 
                pImeCtx->FinalizeCurCompositionChar();

            OurImmSetConversionStatus(hIMC, 
                                    pImeCtx->GetConversionMode()^IME_CMODE_HANGUL, 
                                    pImeCtx->GetSentenceMode());
            UpdateOpenCloseState(pImeCtx);
            break;

        case VK_JUNJA :
            Dbg(DBGID_Key, TEXT("             -  VK_JUNJA"));
            if (pImeCtx->GetCompBufLen()) 
                pImeCtx->FinalizeCurCompositionChar();

            pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);

            OurImmSetConversionStatus(hIMC, 
                                        pImeCtx->GetConversionMode()^IME_CMODE_FULLSHAPE,
                                        pImeCtx->GetSentenceMode());
            UpdateOpenCloseState(pImeCtx);
            break;

        case VK_HANJA :
            Dbg(DBGID_Key, TEXT("             -  VK_HANJA"));
            if (pImeCtx->GetCompBufLen())
                {
                // Keep current composition str
                pImeCtx->SetCompositionStr(pImeCtx->GetCompBufStr());
                if (GenerateHanjaCandList(pImeCtx))
                    {
                    pImeCtx->SetCandidateMsg(CIMECtx::MSG_OPENCAND);
                    OurImmSetConversionStatus(hIMC, 
                                            pImeCtx->GetConversionMode() | IME_CMODE_HANJACONVERT, 
                                            pImeCtx->GetSentenceMode());
                    }
                }
            else
                pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);
            break;

        default :
            // if hangul mode
            if (pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) 
                ToAsciiExHangulMode(pImeCtx, uVirKey, uScanCode, lpbKeyState);
            else 
                // if junja mode
                if (    (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE)
                     && (bKeyCode = CHangulAutomata::GetEnglishKeyMap(uVirKey, 
                                    (IsShiftKeyPushed(lpbKeyState) ? 1 : 0))) )
                    {
                    if (uVirKey >= 'A' && uVirKey <= 'Z') 
                        {
                        bKeyCode = CHangulAutomata::GetEnglishKeyMap(uVirKey, 
                                    (IsShiftKeyPushed(lpbKeyState) ? 1 : 0) 
                                     ^ ((lpbKeyState[VK_CAPITAL] & 0x01) ? 1: 0));
                        }
                        
                    bKeyCode = Banja2Junja(bKeyCode);
                    pImeCtx->SetResultStr(bKeyCode);
                    }
                // Unknown mode
                else 
                    {
                    DbgAssert(0);
                    pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);
                    }
            } // switch (uVirKey) 
        }
        
ToAsciiExExit:
    pImeCtx->StoreComposition();
    //pImeCtx->StoreCandidate();
    pImeCtx->FinalizeMessage();    // final setup for IME Messages

ToAsciiExExit_NoMsg:
    uNumMsg = pImeCtx->GetMessageCount();
    pImeCtx->ResetMessage();    // reset
    pImeCtx->SetTransMessage((LPTRANSMSGLIST)NULL);// start process key
    pImeCtx->SetProcessKeyStatus(fFalse);

    return (uNumMsg);
}

/*----------------------------------------------------------------------------
    ToAsciiExHangulMode

    Subroutine used by ImeToAsciiEx.
----------------------------------------------------------------------------*/
VOID PASCAL ToAsciiExHangulMode(PCIMECtx pImeCtx, UINT uVirKey, UINT uScanCode, CONST LPBYTE lpbKeyState)
{
    CHangulAutomata* pAutomata;
    WCHAR              wcCur;
    UINT              uNumMsg=0;

    Dbg(DBGID_API, TEXT("ToAsciiExHangulMode()"));
    pAutomata = pImeCtx->GetAutomata();
    DbgAssert(pAutomata != NULL);
    
    switch (uVirKey) 
        {
    ///////////////////////////////////////////////////////////
    // Back space processing
    case VK_BACK :
        Dbg(DBGID_Key, TEXT("ImeToAsciiEx : VK_BACK"));
        if (pAutomata->BackSpace()) 
            {
            wcCur = pAutomata->GetCompositionChar();
            if (pImeCtx->GetGData()->GetJasoDel() == fFalse) 
                {
                pAutomata->InitState();
                wcCur = 0;
                }

            if (wcCur) 
                {
                pImeCtx->SetCompositionStr(wcCur);
                break;
                }
            else 
                {
                Dbg(DBGID_Key, TEXT("ImeToAsciiEx : VK_BACK - Empty char"));

                // Send Empty Composition stringto clear message
                pImeCtx->AddMessage(WM_IME_COMPOSITION, 0, (GCS_COMPSTR|GCS_COMPATTR|CS_INSERTCHAR|CS_NOMOVECARET));
                
                // Send Close composition window message
                pImeCtx->SetEndComposition(fTrue);
                break;
                }
            }
        else 
            {
            // BUG :
            DbgAssert(0);
            // Put the Backspace message into return buffer.
            pImeCtx->AddMessage(WM_CHAR, (WPARAM)VK_BACK, (LPARAM)0x000E0001L); //(uScanCode << 16) | 1UL
            }
        break;

    default :
        // Ctrl+xx processing bug #60
        if (IsControlKeyPushed(lpbKeyState)) 
            {
            pImeCtx->FinalizeCurCompositionChar();
            pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);
            }
        else
            switch (pAutomata->Machine(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 ))
                {
            case HAUTO_COMPOSITION:
                // Send start composition msg. if no composition exist.
                if (pImeCtx->GetCompBufLen() == 0)
                    pImeCtx->SetStartComposition(fTrue);

                // Get Current composition char
                wcCur = pAutomata->GetCompositionChar();

                // if ISO10646 flag disabled, should permit only KSC5601 chars
                if (vpInstData->fISO10646== fFalse)
                    {
                    Dbg(DBGID_API, TEXT("ToAsciiExHangulMode - ISO10646 Off"));
                    if (IsKSC5601(wcCur) == fFalse) 
                        {
                        Dbg(DBGID_API, TEXT("ToAsciiExHangulMode - Non KSC5601 char"));
                        // To cancel last Jaso
                        pAutomata->BackSpace();
                        // Complete
                        pAutomata->MakeComplete();
                        pImeCtx->SetResultStr(pAutomata->GetCompleteChar());
                        // Run Automata again
                        pAutomata->Machine(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 );
                        wcCur = pAutomata->GetCompositionChar();
                        }
                    }

                pImeCtx->SetCompositionStr(wcCur);
                break;

            case HAUTO_COMPLETE:
                pImeCtx->SetResultStr(pAutomata->GetCompleteChar());
                pImeCtx->SetCompositionStr(pAutomata->GetCompositionChar());
                break;

            ////////////////////////////////////////////////////////
            // User pressed Alphanumeric key.
            // When user type alphanumeric char in interim state.
            // ImeProcessKey should guarantee return fTrue only if 
            // hangul key pressed or alphanumeric key(including special keys) 
            // pressed in interim state or Fullshape mode.
            case HAUTO_NONHANGULKEY:
                wcCur = pAutomata->GetKeyMap(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0);
                    
                if (wcCur && (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE))
                    wcCur = Banja2Junja(wcCur);

                // if interim state
                if (pImeCtx->GetCompBufLen()) 
                    {
                    //DbgAssert(lpImcP->fdwImeMsg & MSG_ALREADY_START);
                    pImeCtx->FinalizeCurCompositionChar();
                    if (wcCur)
                        pImeCtx->AppendResultStr(wcCur);
                    else
                        pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);
                    } 
                else // Not interim state
                    {    
                    if (wcCur)
                        pImeCtx->SetResultStr(wcCur);
                    else
                        // if not alphanumeric key(special key), just send it to App
                        pImeCtx->AddKeyDownMessage(uVirKey, uScanCode);
                    }
                break;

            default :
            DbgAssert(0);
                } // switch (pAutomata->Machine(uVirKey, (lpbKeyState[VK_SHIFT] & 0x80) ? 1 : 0 ) ) 
        } // switch (uVirKey) 
    
    return;
}

/*----------------------------------------------------------------------------
    ToAsciiExHanja

    Subroutine used by ImeToAsciiEx. Handle key code in Hanja conversion mode on

    Returns True only if there is message need to generated.
----------------------------------------------------------------------------*/
BOOL PASCAL ToAsciiExHanja(PCIMECtx pImeCtx, UINT uVirKey, CONST LPBYTE lpbKeyState)
{
    UINT             uNumMsg = 0;
    DWORD           iStart;
    WORD            bKeyCode;
    LPCANDIDATELIST lpCandList;
    WCHAR            wcHanja, wchInject;

    Dbg(DBGID_Hanja, TEXT("ToAsciiExHanja(): IME_CMODE_HANJACONVERT"));

       
    // if Left Alt key or Ctrl+xx down or no cand info.
    if (pImeCtx->GetPCandInfo() == NULL || pImeCtx->GetPCandInfo()->dwCount == 0)
        {
        Dbg(DBGID_Hanja, TEXT("ToAsciiExHanja(): WARNING no cand info. send MSG_CLOSE_CANDIDATE"));
        pImeCtx->SetCandidateMsg(CIMECtx::MSG_CLOSECAND);
        // Cancel Hanja conversion mode
        OurImmSetConversionStatus(pImeCtx->GetHIMC(), 
                                  pImeCtx->GetConversionMode() & ~IME_CMODE_HANJACONVERT, 
                                  pImeCtx->GetSentenceMode());
        return fTrue;
        }

    wchInject = HIWORD(uVirKey);
    uVirKey   = LOWORD(uVirKey);
    
    lpCandList = (LPCANDIDATELIST)((LPBYTE)pImeCtx->GetPCandInfo() + sizeof(CANDIDATEINFO));
    iStart = (lpCandList->dwSelection / lpCandList->dwPageSize) * lpCandList->dwPageSize;

    // FIXED : In Hanja conversion mode, for selection candidate, use english keymap
    bKeyCode = CHangulAutomata::GetEnglishKeyMap(uVirKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 );
    if (bKeyCode && (uVirKey != VK_PACKET))
        {
        if (bKeyCode >= '1' && bKeyCode <= '9' 
            && iStart + bKeyCode - '1' < lpCandList->dwCount)
            {
            wcHanja = pImeCtx->GetCandidateStr(iStart + bKeyCode - '1');
            Dbg(DBGID_Hanja, TEXT("ImeToAsciiEx-HANJACONVERT : wcHanja = 0x%04X"), wcHanja);

            pImeCtx->SetEndComposition(fTrue);
            pImeCtx->SetCandidateMsg(CIMECtx::MSG_CLOSECAND);
            pImeCtx->SetResultStr(wcHanja);

            OurImmSetConversionStatus(pImeCtx->GetHIMC(), 
                                        pImeCtx->GetConversionMode() & ~IME_CMODE_HANJACONVERT,
                                        pImeCtx->GetSentenceMode());
            // pImeCtx->ClearCompositionStrBuffer();
            }
        else
            goto Exit_NoHandledKey;
        }
    else
        {
        switch (uVirKey)
            {
            case VK_HANJA :
            case VK_ESCAPE :
            case VK_PROCESSKEY :
            case VK_HANGUL :
            // Added for left and right Window buttons
            case VK_LWIN : case VK_RWIN : 
            case VK_APPS :
            case VK_MENU :
            case VK_PACKET :
                // FIXED : Bug #27
                // Word notify CPS_COMPLETE when user ALT down in hanja conv mode
                // then send double finalize char
                // check if composition char exist
                DbgAssert(pImeCtx->GetCompBufLen()); // Comp string should be exist in Hanja conv mode.
                if (pImeCtx->GetCompBufLen()) 
                    {
                    // FIXED : if ESC_HANJA called, MSG_ALREADY_START is not set
                    //           This prevent MSG_END_COMPOSITION.
                    pImeCtx->SetEndComposition(fTrue);
                    pImeCtx->SetResultStr(pImeCtx->GetCompBufStr());
                    
                    // Unicode injection
                    if (uVirKey == VK_PACKET)
                        {
                        Dbg(DBGID_Key|DBGID_Hanja, TEXT("ImeToAsciiEx: VK_PACKET arrived(Hanja conv mode Comp char exist) - Append 0x%x"), wchInject);
                        pImeCtx->AppendResultStr(wchInject);
                        }
                    }

                pImeCtx->SetCandidateMsg(CIMECtx::MSG_CLOSECAND);

                // Cancel Hanja conversion mode
                OurImmSetConversionStatus(pImeCtx->GetHIMC(), 
                                        pImeCtx->GetConversionMode() & ~IME_CMODE_HANJACONVERT, 
                                        pImeCtx->GetSentenceMode());
                break;

            case VK_LEFT :
                if (iStart)
                    {
                    lpCandList->dwPageStart -= CAND_PAGE_SIZE;
                    lpCandList->dwSelection -= CAND_PAGE_SIZE;
                    pImeCtx->SetCandidateMsg(CIMECtx::MSG_CHANGECAND);
                    }
                else
                    goto Exit_NoHandledKey;

                // Keep current composition str
                   pImeCtx->SetCompositionStr(pImeCtx->GetCompBufStr());
                break;

            case VK_RIGHT :
                if (iStart + CAND_PAGE_SIZE < lpCandList->dwCount)
                    { 
                    lpCandList->dwPageStart += CAND_PAGE_SIZE;
                    lpCandList->dwSelection += CAND_PAGE_SIZE;
                    pImeCtx->SetCandidateMsg(CIMECtx::MSG_CHANGECAND);
                    }
                else
                    goto Exit_NoHandledKey;

                // Keep current composition str
                pImeCtx->SetCompositionStr(pImeCtx->GetCompBufStr());
                break;

            default :
                // Keep current composition str
                // pImeCtx->SetCompositionStr(pImeCtx->GetCompBufStr());
                goto Exit_NoHandledKey;
            }
        }

    return fTrue;
    
Exit_NoHandledKey:
    MessageBeep(MB_ICONEXCLAMATION);
    return fFalse;
}

/*----------------------------------------------------------------------------
    ImeRegisterWord

    NOT USED
----------------------------------------------------------------------------*/
BOOL WINAPI ImeRegisterWord(LPCTSTR lpszReading, DWORD dwStyle, LPCTSTR lpszString)
{
    Dbg(DBGID_API, TEXT("ImeRegisterWord() : NOT IMPLEMENTED"));
    return fFalse;
}

/*----------------------------------------------------------------------------
    ImeUnregisterWord

    NOT USED
----------------------------------------------------------------------------*/
BOOL WINAPI ImeUnregisterWord(LPCTSTR lpszReading, DWORD dwStyle, LPCTSTR lpszString)
{
    Dbg(DBGID_API, TEXT("ImeUnregisterWord() : NOT IMPLEMENTED"));
    return fFalse;
}

/*----------------------------------------------------------------------------
    ImeGetRegisterWordStyle

    NOT USED
----------------------------------------------------------------------------*/
UINT WINAPI ImeGetRegisterWordStyle(UINT nItem, LPSTYLEBUF lpStyleBuf)
{
    Dbg(DBGID_API, TEXT("ImeGetRegisterWordStyle() : NOT IMPLEMENTED"));
    return (0);
}

/*----------------------------------------------------------------------------
    ImeEnumRegisterWord

    NOT USED
----------------------------------------------------------------------------*/
UINT WINAPI ImeEnumRegisterWord(REGISTERWORDENUMPROC lpfnRegisterWordEnumProc,
            LPCTSTR lpszReading, DWORD dwStyle, LPCTSTR lpszString, LPVOID lpData)
{
    Dbg(DBGID_API, TEXT("ImeEnumRegisterWord() : NOT IMPLEMENTED"));
    return (0);
}

/*----------------------------------------------------------------------------
    ImeGetImeMenuItems
----------------------------------------------------------------------------*/
DWORD WINAPI ImeGetImeMenuItems(HIMC hIMC, DWORD dwFlags, DWORD dwType, 
                                LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, 
                                DWORD dwSize)
{
    PCIMECtx     pImeCtx;
    DWORD        dwNumOfItems=0;

    Dbg(DBGID_API, TEXT("ImeGetImeMenuItems() : "));

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return 0;
    
    if (!lpImeMenu)
        {
        if (!lpImeParentMenu)
            {
            if (dwFlags & IGIMIF_RIGHTMENU)
                dwNumOfItems = NUM_ROOT_MENU_R;
            else
                dwNumOfItems = NUM_ROOT_MENU_L;
            goto ImeGetImeMenuItemsExit;
            }
        else
            {
            if (dwFlags & IGIMIF_RIGHTMENU)
                dwNumOfItems = NUM_SUB_MENU_R;
            else
                dwNumOfItems = NUM_SUB_MENU_L;
            goto ImeGetImeMenuItemsExit;
            }
        return 0;
        }

    if (!lpImeParentMenu)  
        {
        if (dwFlags & IGIMIF_RIGHTMENU)
            {
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFOW);
            lpImeMenu->fType = 0;
            lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_ROOT_MR_1;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            OurLoadStringW(vpInstData->hInst, IDS_CONFIG, lpImeMenu->szString, IMEMENUITEM_STRING_SIZE);
            lpImeMenu->hbmpItem = 0;

            dwNumOfItems = NUM_ROOT_MENU_R;
            }
        else // Left Menu
            {
            // 1. Hangul Halfshape menu
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFOW);
            lpImeMenu->fType = IMFT_RADIOCHECK;
            if ((pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) && 
                !(pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE))
                lpImeMenu->fState = IMFS_CHECKED;
            else
                lpImeMenu->fState = 0;

            lpImeMenu->wID = IDIM_ROOT_ML_1;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            OurLoadStringW(vpInstData->hInst, IDS_IME_HANGUL_HALF, lpImeMenu->szString, IMEMENUITEM_STRING_SIZE);
            lpImeMenu->hbmpItem = 0;

            // 2. Hangul Fullshape menu
            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFOW);
            lpImeMenu->fType = IMFT_RADIOCHECK;
            if ((pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) && 
                (pImeCtx->GetConversionMode()& IME_CMODE_FULLSHAPE))
                lpImeMenu->fState = IMFS_CHECKED;
            else
                lpImeMenu->fState = 0;

            lpImeMenu->wID = IDIM_ROOT_ML_2;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            OurLoadStringW(vpInstData->hInst, IDS_IME_HANGUL_FULL, lpImeMenu->szString, IMEMENUITEM_STRING_SIZE);
            lpImeMenu->hbmpItem = 0;


            // 3. English Halfshape menu
            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFOW);
            lpImeMenu->fType = IMFT_RADIOCHECK;
            if (!(pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) && 
                !(pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE))
                lpImeMenu->fState = IMFS_CHECKED;
            else
                lpImeMenu->fState = 0;

            lpImeMenu->wID = IDIM_ROOT_ML_3;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            OurLoadStringW(vpInstData->hInst, IDS_IME_ENG_HALF, lpImeMenu->szString, IMEMENUITEM_STRING_SIZE);
            lpImeMenu->hbmpItem = 0;

            // 4. English Fullshape menu
            lpImeMenu++;
            lpImeMenu->cbSize = sizeof(IMEMENUITEMINFOW);
            lpImeMenu->fType = IMFT_RADIOCHECK;
            if ( !(pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) && 
                  (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE))
                lpImeMenu->fState = IMFS_CHECKED;
            else
                lpImeMenu->fState = 0;
            lpImeMenu->wID = IDIM_ROOT_ML_4;
            lpImeMenu->hbmpChecked = 0;
            lpImeMenu->hbmpUnchecked = 0;
            OurLoadStringW(vpInstData->hInst, IDS_IME_ENG_FULL, lpImeMenu->szString, IMEMENUITEM_STRING_SIZE);
            lpImeMenu->hbmpItem = 0;

            // return total number of menu list
            dwNumOfItems = NUM_ROOT_MENU_L;
            }
        }

ImeGetImeMenuItemsExit:
    return dwNumOfItems;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Private Helper Functions
//

//
// OS setup (Whistler,Win2K) sets this flag
//
BOOL IsInSystemSetupMode()
{
   LPCSTR szKeyName = "SYSTEM\\Setup";
   DWORD  dwType, dwSize;
   HKEY   hKeySetup;
   DWORD  dwSystemSetupInProgress = 0;
   DWORD  dwUpgradeInProcess = 0;
   DWORD  dwOOBEInProcess = 0;
   LONG   lResult;

   if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_READ, &hKeySetup) == ERROR_SUCCESS)
        {
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hKeySetup, TEXT("SystemSetupInProgress"), NULL, &dwType, (LPBYTE) &dwSystemSetupInProgress, &dwSize);
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hKeySetup, TEXT("UpgradeInProgress"), NULL, &dwType, (LPBYTE) &dwUpgradeInProcess, &dwSize);
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(hKeySetup, TEXT("OobeInProgress"), NULL, &dwType, (LPBYTE) &dwOOBEInProcess, &dwSize);

        if (dwSystemSetupInProgress == 1 || dwUpgradeInProcess == 1 || dwOOBEInProcess == 1)
            {
            RegCloseKey (hKeySetup);
            return TRUE;
            }
        RegCloseKey (hKeySetup);
        }

    if (IsWinNT5orUpper() && (IsRunningAsLocalSystem() || IsRunningInOOBE()))
        return TRUE;
        
    return FALSE ;
}

//+----------------------------------------------------------------------------
//
//  Function:   RunningAsLocalSystem
//
//  Synopsis:   Detects whether we're running in the System account.
//
//  Arguments:  None
//
//  Returns:    TRUE  if the service is running as LocalSystem
//              FALSE if it is not or if any errors were encountered
//
//-----------------------------------------------------------------------------
BOOL IsRunningAsLocalSystem()
{
    SID    LocalSystemSid = { SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID };

 

    BOOL   fCheckSucceeded;
    BOOL   fIsLocalSystem = FALSE;

 

    fCheckSucceeded = CheckTokenMembership(NULL,
                                           &LocalSystemSid,
                                           &fIsLocalSystem);

 

    return (fCheckSucceeded && fIsLocalSystem);
}

/*----------------------------------------------------------------------------
    IsRunningInOOBE

    Bug #401732:IME Status window does not come up on the registration page of WPA in the windows starting mode
----------------------------------------------------------------------------*/
BOOL IsRunningInOOBE()
{
    TCHAR  achModule[MAX_PATH];
    TCHAR  ch;
    LPTSTR pch;
    LPTSTR pchFileName;
    
    if (GetModuleFileName(NULL, achModule, ARRAYSIZE(achModule)) == 0)
        return FALSE;

    pch = pchFileName = achModule;

    while ((ch = *pch) != 0)
        {
        pch = CharNext(pch);

        if (ch == '\\')
            pchFileName = pch;
        }
    
    if (lstrcmpi(pchFileName, TEXT("msoobe.exe")) == 0)
        return TRUE;

    return FALSE;
}
    
BOOL PASCAL Select(HIMC hIMC, BOOL fSelect)
{
    PCIMECtx    pImeCtx  = NULL;
    BOOL         fRet     = fTrue;

    // If IME select On
    if (fSelect) 
        {
        IMCPRIVATE      imcPriv;
        IImeIPoint1*    pIP      = NULL;
        LPCImeIPoint    pCIImeIPoint = NULL;
        DWORD             dwInitStatus = 0;

        // Clear all private buffer
        ZeroMemory(&imcPriv, sizeof(IMCPRIVATE));

        //////////////////////////////////////////////////////////////////////
        // Create IImeIPoint1 instance
        //////////////////////////////////////////////////////////////////////
        if ((pCIImeIPoint = new CIImeIPoint)==NULL)
            return fFalse;
        // This increments the reference count
        if (FAILED(pCIImeIPoint->QueryInterface(IID_IImeIPoint1, (VOID **)&pIP)))
            return fFalse;
        AST(pIP != NULL);
        imcPriv.pIPoint = pIP;

        // initialize IImeIPoint interface. This will create CImeCtx object
        Dbg(DBGID_API, "ImeSelect - init IP");
        pCIImeIPoint->Initialize(hIMC);

        //////////////////////////////////////////////////////////////////////
        // Get CImeCtx object from IImeIPoint1
        //////////////////////////////////////////////////////////////////////
        pCIImeIPoint->GetImeCtx((VOID**)&pImeCtx);
        AST(pImeCtx != NULL);
        if (pImeCtx == NULL) 
            {
            Dbg( DBGID_API, "ImeSelect - pImeCtx == NULL" );
            return fFalse;
            }

        // Set pImeCtx
        imcPriv.pImeCtx = pImeCtx;

        // Set hIMC for compare
        imcPriv.hIMC = hIMC;

        //////////////////////////////////////////////////////////////////////
        // Set IMC private buffer
        //////////////////////////////////////////////////////////////////////
        Dbg(DBGID_API, TEXT("ImeSelect - set priv buf"));
           SetPrivateBuffer(hIMC, &imcPriv, sizeof(IMCPRIVATE));

        // Set Unicode flag
        pImeCtx->SetUnicode(vfUnicode);
        
        //////////////////////////////////////////////////////////////////////
        // Set initial IMC states if not already set
        //////////////////////////////////////////////////////////////////////
        pImeCtx->GetInitStatus(&dwInitStatus);

        // if INPUTCONTEXT member are not initialized, initialize it.
        if (!(dwInitStatus & INIT_CONVERSION))
            {
            pImeCtx->SetOpen(fFalse);    // Initial IME close status == Alphanumeric mode
            pImeCtx->SetConversionMode(IME_CMODE_ALPHANUMERIC); // Set initial conversion mode.
            dwInitStatus |= INIT_CONVERSION;
            }
#if 0
// !!! We don't need this code NT5 IMM does it !!!
        else
            {
            // When IME switched from other IME, for example KKIME,
            // status window sometimes not updated to correct info because KKIME maintains 
            // conversion mode independetly from Open/Close status and they uses non-Korean
            // conversion mode like IME_CMODE_KATAKANA or IME_CMODE_ROMAN. 
            // So need to adjust conversion mode according to Open/Clos Status and current
            // conversion mode.

               if (pImeCtx->IsOpen() == fFalse && pImeCtx->GetConversionMode() != IME_CMODE_ALPHANUMERIC)
                   pImeCtx->SetConversionMode(IME_CMODE_ALPHANUMERIC);
            else                
               if (pImeCtx->IsOpen() && (pImeCtx->GetConversionMode() & (IME_CMODE_HANGUL|IME_CMODE_FULLSHAPE)) == fFalse)
                   pImeCtx->SetConversionMode(IME_CMODE_HANGUL);
            }
#endif

        if (!(dwInitStatus & INIT_LOGFONT))
            {
            LOGFONT* pLf = pImeCtx->GetLogFont();

            //////////////////////////////////////////////////////////////////
            // Note: Win98 does not support CreateFontW(). 
            //       But, imc->logfont->lfFaceName is UNICODE!
            if (IsMemphis() || IsWinNT())
                StrCopyW((LPWSTR)pLf->lfFaceName, wzIMECompFont);
            else
                lstrcpyA(pLf->lfFaceName, szIMECompFont);

            // Gulim 9pt
            pLf->lfHeight = 16;
            pLf->lfEscapement = 0;
            pLf->lfOrientation = 0;
            pLf->lfWeight = FW_NORMAL;
            pLf->lfItalic = fFalse;
            pLf->lfUnderline = fFalse;
            pLf->lfStrikeOut = fFalse;
            pLf->lfCharSet = HANGUL_CHARSET;
            pLf->lfOutPrecision = OUT_DEFAULT_PRECIS;
            pLf->lfClipPrecision = CLIP_DEFAULT_PRECIS;
            pLf->lfQuality = DEFAULT_QUALITY;
            pLf->lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
            dwInitStatus |= INIT_LOGFONT;
            }

        if (!(dwInitStatus & INIT_STATUSWNDPOS))
            {
            pImeCtx->SetStatusWndPos((pImeCtx->GetGDataRaw())->ptStatusPos);
            dwInitStatus |= INIT_STATUSWNDPOS;
            }
       
        if (!(dwInitStatus & INIT_COMPFORM))
            {
            pImeCtx->SetCompositionFormStyle(CFS_DEFAULT);
            dwInitStatus |= INIT_COMPFORM;
            }

        // Set New initialization status
        pImeCtx->SetInitStatus(dwInitStatus);
        }
    else // fSelect
        {
        IImeIPoint1*  pIP = GetImeIPoint(hIMC);
        LPCImePadSvr lpCImePadSvr;
        CIMCPriv     ImcPriv;
        LPIMCPRIVATE pImcPriv;

        // Cleanup Private buffer and release IImeIPoint1
        // Always OnImeSelect already cleanup.
        if (pIP)
            pIP->Release();

        lpCImePadSvr = CImePadSvr::GetCImePadSvr();
        if(lpCImePadSvr)
            lpCImePadSvr->SetIUnkIImeIPoint((IUnknown *)NULL);

        if (ImcPriv.LockIMC(hIMC)) 
            {
            ImcPriv->pIPoint = (IImeIPoint1*)NULL;
            ImcPriv->pImeCtx = NULL;
            ImcPriv.ResetPrivateBuffer();            
            }
        }

    Dbg(DBGID_API, "Select() exit hIMC=%x, fSelect=%d", hIMC, fSelect);
    return (fTrue);
}

//////////////////////////////////////////////////////////////////////////////
// Conversion mode and Open/Close Helper functions
// In Kor IME, Open status equal to Han mode and Close status equal to Eng mode
// So, we change pair open status with conversion mode, and vice versa.

//////////////////////////////////////////////////////////////////////////////
// UpdateOpenCloseState()
// Purpose :
//        Set Open/Close state according to conversion mode
//        if Eng mode - set Close
//        if Han mode - Set Open
VOID PASCAL UpdateOpenCloseState(PCIMECtx pImeCtx)
{
    if (   (pImeCtx->GetConversionMode() & IME_CMODE_HANGUL)
        || (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE)
        || (pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT) ) 
        {
        if (pImeCtx->IsOpen() == fFalse) 
            OurImmSetOpenStatus(pImeCtx->GetHIMC(), fTrue);
        }
    else
        {
        if (pImeCtx->IsOpen()) 
            OurImmSetOpenStatus(pImeCtx->GetHIMC(), fFalse);
        }
}

#if NOTUSED
//////////////////////////////////////////////////////////////////////////////
// UpdateConversionState()
// Purpose :
//        Set Conversion state according to Open/Close status
//        if Open - Set Han mode
//        if Close - Set Eng mode
VOID PASCAL UpdateConversionState(HIMC hIMC)
{
    LPINPUTCONTEXT  lpIMC;

    if (lpIMC = OurImmLockIMC(hIMC)) 
    {
        if (OurImmGetOpenStatus(hIMC)) 
        {
            if ( !(lpIMC->fdwConversion & (IME_CMODE_HANGUL|IME_CMODE_FULLSHAPE)) )
            {
                OurImmSetConversionStatus(hIMC, lpIMC->fdwConversion | IME_CMODE_HANGUL,
                                    lpIMC->fdwSentence);
            }
            DbgAssert(lpIMC->fdwConversion & (IME_CMODE_HANGUL|IME_CMODE_FULLSHAPE));
        }
        else
        {
            // BUG: IME_CMODE_HANJACONVERT ????
            if (lpIMC->fdwConversion & (IME_CMODE_HANGUL|IME_CMODE_FULLSHAPE))
                OurImmSetConversionStatus(hIMC, lpIMC->fdwConversion & ~(IME_CMODE_HANGUL|IME_CMODE_FULLSHAPE),
                                    lpIMC->fdwSentence);
            DbgAssert(!(lpIMC->fdwConversion & IME_CMODE_HANGUL));
        }
        OurImmUnlockIMC(hIMC);
    }
}
#endif

/*----------------------------------------------------------------------------
    Banja2Junja

    Convert Ascii Half shape to Full shape character
----------------------------------------------------------------------------*/
WCHAR PASCAL Banja2Junja(WCHAR bChar) //, LPDWORD lpTransBuf, LPCOMPOSITIONSTRING lpCompStr)
{
    WCHAR wcJunja;

    if (bChar == L' ')
        wcJunja = 0x3000;    // FullWidth space
    else 
        if (bChar == L'~')
            wcJunja = 0xFF5E;
        else
            if (bChar == L'\\')
                wcJunja = 0xFFE6;   // FullWidth WON sign
            else
                   wcJunja = 0xFF00 + (WORD)(bChar - (BYTE)0x20);

    Dbg(DBGID_Misc, TEXT("Banja2Junja: wcJunja = 0x%04X"), wcJunja);
    return wcJunja;
}

/*----------------------------------------------------------------------------
    IsKSC5601

    Test if character within the KSC 5601
    Return True if input Unicode chracter has correspoding KSC 5601 code
----------------------------------------------------------------------------*/
BOOL PASCAL IsKSC5601(WCHAR wcCur)
{
    WCHAR    wcUni[2];
    BYTE    szWansung[4];

    wcUni[0] = wcCur;
    wcUni[1] = 0;

    // check if compatibility Hangul jamo
    if (wcCur >= 0x3131 && wcCur <= 0x3163)
        return fTrue;
        
    // Convert to ANSI
    if (WideCharToMultiByte(CP_KOREA, 0, wcUni, 1, (LPSTR)szWansung, sizeof(szWansung), NULL, NULL)==0) 
        {
        DbgAssert(0);
        return fFalse;
        }
    else 
        {
        // KSC 5601 Area in 949 cp
        if (   (szWansung[0]>=0xB0 && szWansung[0]<=0xC8) 
            && (szWansung[1]>=0xA1 && szWansung[1]<=0xFE) )
            return fTrue;
        else
            return fFalse;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\cicbtn.cpp ===
//
// cicbtn.cpp
//
// base code: nuibase sample
//

#include "precomp.h"
#include "cicbtn.h"
#include "common.h"
#include "cicero.h"
#include <olectl.h>

#define CICBTN_ITEMSINK_COOKIE 0x80000004

//////////////////////////////////////////////////////////////////////////////
//
// CCicButton
//
//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCicButton::~CCicButton()
{
    SafeRelease(m_plbiSink);
}

//+---------------------------------------------------------------------------
//
// InitInfo
//
//----------------------------------------------------------------------------

void CCicButton::InitInfo(REFCLSID rclsid, 
                                REFGUID rguid, 
                                DWORD dwStyle, 
                                ULONG ulSort,
                                LPWSTR pszDesc)
{
    // init nuiInfo.
    m_lbiInfo.clsidService = rclsid;
    m_lbiInfo.guidItem = rguid;
    m_lbiInfo.dwStyle = dwStyle;
    m_lbiInfo.ulSort = ulSort;
    StrCopyW(m_lbiInfo.szDescription, pszDesc);
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    *pInfo = m_lbiInfo;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetStatus(DWORD *pdwStatus)
{
    *pdwStatus = m_dwStatus;
    
    if (m_fEnable)    // enable?
        {
        // do nothing
        }
    else
        *pdwStatus |= TF_LBI_STATUS_DISABLED;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CCicButton::Show(BOOL fShow)
{
    ITfLangBarItemSink* pSink;

    ShowInternal(fShow);
    pSink = GetSink();
    if (pSink)
        pSink->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

HRESULT CCicButton::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    HRESULT hr;

    if (IsEqualIID(IID_ITfLangBarItemSink, riid))
        {
        if (m_plbiSink)
            hr = CONNECT_E_CANNOTCONNECT;
        else
            {
            hr = punk->QueryInterface(IID_ITfLangBarItemSink, (void **)&m_plbiSink);
            if (SUCCEEDED(hr))
                *pdwCookie = CICBTN_ITEMSINK_COOKIE;
            }
        }
    else
        hr = CONNECT_E_CANNOTCONNECT;
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

HRESULT CCicButton::UnadviseSink(DWORD dwCookie)
{
    if (CICBTN_ITEMSINK_COOKIE  != dwCookie)
        return E_FAIL;

    if (!m_plbiSink)
        return E_UNEXPECTED;

    m_plbiSink->Release();
    m_plbiSink = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

HRESULT CCicButton::ShowInternal(BOOL fShow, BOOL fNotify)
{
    m_fShown = fShow;
    DWORD dwOldStatus = m_dwStatus;

    if (fShow)
        m_dwStatus &= ~TF_LBI_STATUS_HIDDEN;
    else
        m_dwStatus |= TF_LBI_STATUS_HIDDEN;

    if (fNotify && (dwOldStatus != m_dwStatus) && m_plbiSink)
         m_plbiSink->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCicButton::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
        {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
        }
    else if (IsEqualIID(riid, IID_ITfLangBarItemButton))
        {
        *ppvObj = SAFECAST(this, ITfLangBarItemButton *);
        }
    else if (IsEqualIID(riid, IID_ITfSource))
        {
        *ppvObj = SAFECAST(this, ITfSource *);
        }

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CCicButton::AddRef()
{
    return ++m_cRef;
}

#ifdef NEVER // each button object has this
STDAPI_(ULONG) CCicButton::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}
#endif // NEVER


//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CCicButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    switch (click)
        {
        case TF_LBI_CLK_RIGHT:
            return OnRButtonUp(pt, prcArea);
        case TF_LBI_CLK_LEFT:
            return OnLButtonUp(pt, prcArea);
        }
        
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CCicButton::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    pt, prcArea; // no ref
   return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CCicButton::OnRButtonUp(const POINT pt, const RECT *prcArea)
{
    pt, prcArea; // no ref
   return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CCicButton::InitMenu(ITfMenu *pMenu)
{
    pMenu; // no ref
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CCicButton::OnMenuSelect(UINT uID)
{
    uID; // no ref
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetIcon(HICON *phIcon)
{
    phIcon; // no ref
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetText(BSTR *pbstrText)
{
    if (!pbstrText)
        return E_INVALIDARG;

    *pbstrText = OurSysAllocString(m_szText);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetTooltipString(BSTR *pbstrToolTip)
{
    if (!pbstrToolTip)
        return E_INVALIDARG;

    *pbstrToolTip = OurSysAllocString(m_szToolTip);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\candui.cpp ===
/****************************************************************************
    CANDUI.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Candidate window UI functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "debug.h"
#include "ui.h"
#include "lexheader.h"
#include "names.h"
#include "escape.h"
#include "imedefs.h"
#include "hanja.h"
#include "winex.h"

///////////////////////////////////////////////////////////////////////////////
// Private data
// =====-- START OF SHARED DATA --=====
#pragma data_seg(".MSIMESHR") 
PRIVATE RECT rcCandCli = { 0, 0, 319, 29 },
            rcLArrow  = { 15, 4, 27, 25 }, rcRArrow = { 292, 4, 304, 25 },
            s_rcCandBtn[CAND_PAGE_SIZE] = { 
                                {  30, 4,  57, 25 }, {  59, 4,  86, 25 },
                                   {  88, 4, 115, 25 }, { 117, 4, 144, 25 },
                                   { 146, 4, 173, 25 }, { 175, 4, 202, 25 },
                                   { 204, 4, 231, 25 }, { 233, 4, 260, 25 },
                                   { 262, 4, 289, 25 }   };
#pragma data_seg()
// =====-- END OF SHARED DATA --=====

///////////////////////////////////////////////////////////////////////////////
// Private functions
PRIVATE VOID PASCAL PaintCandWindow(HWND hCandWnd, HDC hDC);
PRIVATE BOOL PASCAL CandOnSetCursor(HWND hCandWnd, WORD Message);
PRIVATE VOID PASCAL AdjustCandBoundry(LPPOINT lpptCandWnd);
PRIVATE VOID PASCAL AdjustCandRectBoundry(PCIMECtx pImeCtx, LPPOINT lpptCaret);

#ifdef NOTUSED
PRIVATE VOID NotifyTooltip( HWND hCandWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    HGLOBAL            hUIPrivate;
    LPUIPRIV        lpUIPrivate;
    HWND            hUIWnd;
    MSG                msg;
    POINT            ptCur;

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)
        return;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)         // can not draw candidate window
        return;

    ZeroMemory(&msg, sizeof(MSG));
    msg.hwnd = hCandWnd; msg.message = message;
    msg.wParam = 0; //msg.lParam = 0x00050023L;
    
    if (message == WM_SETCURSOR) 
        {
        GetCursorPos(&ptCur);
        ScreenToClient(hCandWnd, &ptCur);
        msg.lParam = (ptCur.y << 16) | ptCur.x;
        }
    else 
        {
        msg.message = message;
        msg.wParam    = wParam;
        msg.lParam    = lParam;
        }

    Dbg(DBGID_Cand, TEXT("CandOnSetCursor(): WM_MOUSEMOVE - msg.lParam= 0x%08lX"), msg.lParam),
    OurSendMessage(lpUIPrivate->hCandTTWnd, TTM_RELAYEVENT, 0, (LPARAM) (LPMSG) &msg);
    GlobalUnlock(hUIPrivate);
}
#endif

///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK CandWndProc(HWND hCandWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    Dbg(DBGID_UI, TEXT("CandWndProc():uMessage = 0x%08lX, wParam = 0x%04X, lParam = 0x%08lX"), uMessage, wParam, lParam);

    switch (uMessage)
        {
        case WM_IME_CHAR :            case WM_IME_COMPOSITIONFULL :
        case WM_IME_COMPOSITION :    case WM_IME_CONTROL :
        case WM_IME_SELECT :
        case WM_IME_SETCONTEXT :    case WM_IME_STARTCOMPOSITION :
        case WM_IME_ENDCOMPOSITION :
                return 0;

        case WM_SETCURSOR:
                CandOnSetCursor( (HWND) wParam, HIWORD(lParam) );
            return 1;

        case WM_PAINT:
                {
                HDC         hDC;
                PAINTSTRUCT ps;

                hDC = BeginPaint(hCandWnd, &ps);
                PaintCandWindow(hCandWnd, hDC);
                EndPaint(hCandWnd, &ps);
                }
            break;

        default :
            return DefWindowProc(hCandWnd, uMessage, wParam, lParam);
        }
    return (0L);
}


VOID PASCAL OpenCand(HWND hUIWnd)
{
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;
    HIMC        hIMC;
    PCIMECtx    pImeCtx;
    POINT       ptWnd, ptClientWnd;
    CIMEData    ImeData;

#if 1 // MultiMonitor
    RECT rcWorkArea;
#endif

    Dbg(DBGID_Cand, TEXT("OpenCand():"));
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)          // can not draw candidate window
        {
        DbgAssert(0);
        return;
        }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)         // can not draw candidate window
        return;

    // Check WM_IME_SETCONTEXT lParam
    if ((lpUIPrivate->uiShowParam & ISC_SHOWUICANDIDATEWINDOW)==0)
        {
        Dbg(DBGID_Cand, TEXT("!!! No ISC_SHOWUICANDIDATEWINDOW bit exit OpenCand()"));
        goto OpenCandUnlockUIPriv;
        }


    hIMC = GethImcFromHwnd(hUIWnd);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        {
        DbgAssert(0);
        goto OpenCandUnlockUIPriv;
        }

    //if (!(fdwImeMsg & MSG_ALREADY_OPEN)) 
    //    {
        // Sometime the application call ImmNotifyIME to cancel the
        // composition before it process IMN_OPENCANDIDATE.
        // We should avoid to process this kind of IMN_OPENCANDIDATE.
    //    goto OpenCandUnlockIMC;
    //    }
    if (pImeCtx->GetCompBufLen() == 0)
        {
        DbgAssert(0);
        goto OpenCandUnlockUIPriv;
        }

    if (pImeCtx->GetCandidateFormIndex(0) == 0) 
        {
        //ptWnd = lpIMC->cfCandForm[0].ptCurrentPos;
        pImeCtx->GetCandidateFormPos(&ptWnd, 0);

        ClientToScreen(pImeCtx->GetAppWnd(), &ptWnd);

        if (pImeCtx->GetCandidateFormStyle(0) & CFS_FORCE_POSITION) 
            {
            Dbg(DBGID_Cand, TEXT("OpenCand(): CFS_FORCE_POSITION"));
            } 
        else 
            if (pImeCtx->GetCandidateFormStyle(0) == CFS_EXCLUDE) 
                {
                //RECT rcCand;

                Dbg(DBGID_Cand, TEXT("OpenCand(): CFS_EXCLUDE"));
                //if (lpUIPrivate->hCandWnd) {
                //    GetWindowRect(lpUIPrivate->hCandWnd, &rcCand);
                //} else {
                //    *(LPPOINT)&rcCand = ptWnd;
                //}
                AdjustCandRectBoundry(pImeCtx, &ptWnd);

                } 
            else 
                if (pImeCtx->GetCandidateFormStyle(0) == CFS_CANDIDATEPOS) 
                    {
                    Dbg(DBGID_Cand, TEXT("OpenCand(): CFS_CANDIDATEPOS"));
                    AdjustCandBoundry(&ptWnd);
                    } 
                else 
                    {
                    goto OpenCandDefault;
                    }
        } 
    else // if (lpIMC->cfCandForm[0].dwIndex != 0)
        {
OpenCandDefault:
    Dbg(DBGID_Cand, TEXT("OpenCand(): OpenCandDefault"));
    /*
        if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
            ptWnd.x = ptWnd.y = 0;
            ClientToScreen(lpUIPrivate->hCompWnd, &ptWnd);

            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
        } else {
            POINT ptNew;

            ptWnd = lpIMC->cfCompForm.ptCurrentPos;
            ClientToScreen(lpIMC->hWnd, &ptWnd);

            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
            ptNew = ptWnd;

            // try to simulate the position of composition window
            AdjustCompPosition(lpIMC, &ptWnd, &ptNew);
        }
    */
    //    CalcCandPos(lpIMC, &ptWnd);
    
#if 1 // MultiMonitor
        ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcWorkArea);
        ptWnd.x = rcWorkArea.right - ImeData->xCandWi;
        ptWnd.y = rcWorkArea.bottom - ImeData->yCandHi;
#else
        ptWnd.x = ImeData->rcWorkArea.right - ImeData->xCandWi;
        ptWnd.y = ImeData->rcWorkArea.bottom - ImeData->yCandHi;
#endif
        pImeCtx->SetCandidateFormStyle(CFS_CANDIDATEPOS);
        ptClientWnd = ptWnd;
        ScreenToClient(pImeCtx->GetAppWnd(), &ptClientWnd);
        pImeCtx->SetCandidateFormPos(ptClientWnd);
        }

    if (lpUIPrivate->hCandWnd) 
        {
        Dbg(DBGID_Cand, TEXT("OpenCand - SetWindowPos"), ptWnd.x, ptWnd.y);

        SetWindowPos(lpUIPrivate->hCandWnd, NULL,
                    ptWnd.x, ptWnd.y,
                    0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
        } 
    else 
        {
        Dbg(DBGID_Cand, TEXT("OpenCand - CreateWindowEx x=%d, y=%d"), ptWnd.x, ptWnd.y);

        // Create Candidate window
        lpUIPrivate->hCandWnd = CreateWindowEx(0,
                                        szCandClassName, NULL,
                                        WS_POPUP|WS_DISABLED,
                                        ptWnd.x, ptWnd.y,
                                        ImeData->xCandWi, ImeData->yCandHi,
                                        hUIWnd, 
                                        (HMENU)NULL, 
                                        vpInstData->hInst, 
                                        NULL);

        if (lpUIPrivate->hCandWnd == NULL)
            goto OpenCandUnlockUIPriv;

        // Create candidate TT
        if (IsWinNT())
            lpUIPrivate->hCandTTWnd = CreateWindowW(
                                            wszTooltipClassName, 
                                            NULL,
                                            TTS_ALWAYSTIP|WS_DISABLED, 
                                            CW_USEDEFAULT, CW_USEDEFAULT, 
                                            CW_USEDEFAULT, CW_USEDEFAULT,
                                            lpUIPrivate->hCandWnd, 
                                            (HMENU) NULL, 
                                            vpInstData->hInst, 
                                            NULL);
        else
            lpUIPrivate->hCandTTWnd = CreateWindow(
                                            szTooltipClassName, 
                                            NULL,
                                            TTS_ALWAYSTIP|WS_DISABLED, 
                                            CW_USEDEFAULT, CW_USEDEFAULT, 
                                            CW_USEDEFAULT, CW_USEDEFAULT,
                                            lpUIPrivate->hCandWnd, 
                                            (HMENU) NULL, 
                                            vpInstData->hInst, 
                                            NULL);
        DbgAssert(lpUIPrivate->hCandTTWnd != 0);
        
        if (lpUIPrivate->hCandTTWnd) 
            {
            TOOLINFO        ti;
        
            ZeroMemory(&ti, sizeof(TOOLINFO));
            ti.cbSize = sizeof(TOOLINFO);
            ti.uFlags = 0;
            ti.hwnd = lpUIPrivate->hCandWnd;
            ti.hinst = vpInstData->hInst;

            // Reset Tooltip data
            for (INT i=0; i<CAND_PAGE_SIZE; i++) 
                {
                ti.uId = i;
                ti.lpszText = "";
                ti.rect = s_rcCandBtn[i];
                OurSendMessage(lpUIPrivate->hCandTTWnd, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
                }
            }

        }

    ShowCand(hUIWnd, SW_SHOWNOACTIVATE);

OpenCandUnlockUIPriv:
    GlobalUnlock(hUIPrivate);
    return;
}


///////////////////////////////////////////////////////////////////////////////
//
VOID PASCAL AdjustCandBoundry(LPPOINT lpptCandWnd)
{
    CIMEData            ImeData;
#if 1 // MultiMonitor
    RECT rcWorkArea;
    RECT rcCandWnd;
#endif
    Dbg(DBGID_UI, TEXT("AdjustCandBoundry():"));

#if 1 // MultiMonitor
    *(LPPOINT)&rcCandWnd = *(LPPOINT)lpptCandWnd;
    rcCandWnd.right = rcCandWnd.left + ImeData->xCandWi;
    rcCandWnd.bottom = rcCandWnd.top + ImeData->yCandHi;

    ImeMonitorWorkAreaFromRect(&rcCandWnd, &rcWorkArea);

    if (lpptCandWnd->x < rcWorkArea.left) {
        lpptCandWnd->x = rcWorkArea.left;
    } else if (lpptCandWnd->x + ImeData->xCandWi > rcWorkArea.right) {
        lpptCandWnd->x = rcWorkArea.right - ImeData->xCandWi;
    } else {
    }

    if (lpptCandWnd->y < rcWorkArea.top) {
        lpptCandWnd->y = rcWorkArea.top;
    } else if (lpptCandWnd->y + ImeData->yCandHi > rcWorkArea.bottom) {
        lpptCandWnd->y = rcWorkArea.bottom - ImeData->yCandHi;
    } else {
    }

#else
    if (lpptCandWnd->x < ImeData->rcWorkArea.left) {
        lpptCandWnd->x = ImeData->rcWorkArea.left;
    } else if (lpptCandWnd->x + ImeData->xCandWi > ImeData->rcWorkArea.right) {
        lpptCandWnd->x = ImeData->rcWorkArea.right - ImeData->xCandWi;
    } else {
    }

    if (lpptCandWnd->y < ImeData->rcWorkArea.top) {
        lpptCandWnd->y = ImeData->rcWorkArea.top;
    } else if (lpptCandWnd->y + ImeData->yCandHi > ImeData->rcWorkArea.bottom) {
        lpptCandWnd->y = ImeData->rcWorkArea.bottom - ImeData->yCandHi;
    } else {
    }
#endif
}

VOID PASCAL AdjustCandRectBoundry(PCIMECtx pImeCtx, LPPOINT lpptCaret)               // the caret position. Screen coord
{
    RECT      rcExclude, rcCandRect, rcInterSect;
    POINT     ptCurrentPos;
    CIMEData ImeData;

    // translate from client coordinate to screen coordinate
    // rcExclude = lpIMC->cfCandForm[0].rcArea;
    pImeCtx->GetCandidateForm(&rcExclude);
    pImeCtx->GetCandidateFormPos(&ptCurrentPos);

    rcExclude.left += lpptCaret->x - ptCurrentPos.x;
    rcExclude.right += lpptCaret->x - ptCurrentPos.x;

    rcExclude.top += lpptCaret->y - ptCurrentPos.y;
    rcExclude.bottom += lpptCaret->y - ptCurrentPos.y;

    AdjustCandBoundry(lpptCaret);

    *(LPPOINT)&rcCandRect = *lpptCaret;
    rcCandRect.right = rcCandRect.left + ImeData->xCandWi;
    rcCandRect.bottom = rcCandRect.top + ImeData->yCandHi;

    if (IntersectRect(&rcInterSect, &rcCandRect, &rcExclude))
    {
#if 1 // MultiMonitor
        RECT rcWorkArea;
        ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcWorkArea);
        // Adjust y-axis only
        if ( (rcExclude.bottom + ImeData->yCandHi) < rcWorkArea.bottom )
            lpptCaret->y = rcExclude.bottom;
        else
            lpptCaret->y = rcExclude.top - ImeData->yCandHi;

#else
        // Adjust y-axis only
        if ( (rcExclude.bottom + ImeData->yCandHi) < ImeData->rcWorkArea.bottom )
            lpptCaret->y = rcExclude.bottom;
        else
            lpptCaret->y = rcExclude.top - ImeData->yCandHi;
#endif
    }
}

BOOL fSetCandWindowPos(HWND  hCandWnd)
{
    HWND     hUIWnd;
    HIMC     hIMC;
    PCIMECtx pImeCtx;
    POINT    ptWnd;
    CIMEData ImeData;

    if (hCandWnd == 0)
        {
        DbgAssert(0);
        return fTrue;
        }
    hUIWnd = GetWindow(hCandWnd, GW_OWNER);

    hIMC = GethImcFromHwnd(hUIWnd);
    //if (!hIMC) 
    //    {
    //    DbgAssert(0);        
    //  return fFalse;
    //    }

    //lpIMC = (LPINPUTCONTEXT)OurImmLockIMC(hIMC);
    //if (!lpIMC) 
    //    {
    //    DbgAssert(0);        
    //  return fFalse;
    //    }

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;

    //ptWnd = lpIMC->cfCandForm[0].ptCurrentPos;
    pImeCtx->GetCandidateFormPos(&ptWnd);
    
    ClientToScreen(pImeCtx->GetAppWnd(), &ptWnd);

    if (pImeCtx->GetCandidateFormStyle() & CFS_FORCE_POSITION) 
        {
        } 
    else 
        if (pImeCtx->GetCandidateFormStyle() == CFS_EXCLUDE) 
        {
        RECT rcCand;

        GetWindowRect(hCandWnd, &rcCand);
        AdjustCandRectBoundry(pImeCtx, &ptWnd);

        if (ptWnd.x == rcCand.left && ptWnd.y == rcCand.right)
            return (0L);
        } 
    else 
    if (pImeCtx->GetCandidateFormStyle() == CFS_CANDIDATEPOS) 
        {
        AdjustCandBoundry(&ptWnd);
        } 
    else 
    if (pImeCtx->GetCandidateFormStyle() == CFS_DEFAULT) 
        {
#if 1 // MultiMonitor
        RECT rcWorkArea;
        ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcWorkArea);
        ptWnd.x = rcWorkArea.right - ImeData->xCandWi;
        ptWnd.y = rcWorkArea.bottom - ImeData->yCandHi;
#else
        ptWnd.x = ImeData->rcWorkArea.right - ImeData->xCandWi;
        ptWnd.y = ImeData->rcWorkArea.bottom - ImeData->yCandHi;
#endif
        }

    SetWindowPos(hCandWnd, NULL, ptWnd.x, ptWnd.y, 0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    return (0L);
    }


// Show the candidate window
VOID ShowCand(HWND hUIWnd, INT nShowCandCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    Dbg(DBGID_Cand, TEXT("ShowCand(): nShowCandCmd = %d"), nShowCandCmd);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)          // can not darw candidate window
        return;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)          // can not draw candidate window
        return;

    if (nShowCandCmd == SW_SHOWNOACTIVATE)
        nShowCandCmd = vfWndOpen[CAND_WINDOW] ? SW_SHOWNOACTIVATE : SW_HIDE;

    if (lpUIPrivate->nShowCandCmd == nShowCandCmd)
        goto SwCandNoChange;

    if (lpUIPrivate->hCandWnd)
        {
        ShowWindow(lpUIPrivate->hCandWnd, nShowCandCmd);
        lpUIPrivate->nShowCandCmd = nShowCandCmd;
        }
    else
        lpUIPrivate->nShowCandCmd = SW_HIDE;

SwCandNoChange:
    GlobalUnlock(hUIPrivate);
    return;
}


BOOL PASCAL CandOnSetCursor(HWND hCandWnd, WORD message)
{
    INT iLoop;
    POINT    ptPos;

    SetCursor(LoadCursor(vpInstData->hInst, MAKEINTRESOURCE(IDC_IME_HAND)));
    
    switch (message)
    {
        case WM_LBUTTONDOWN:
            GetCursorPos(&ptPos);
            ScreenToClient(hCandWnd, &ptPos);
            if (PtInRect((LPRECT)&rcCandCli, ptPos))
            {
                if (!PtInRect((LPRECT)&rcLArrow, ptPos)
                        && !PtInRect((LPRECT)&rcRArrow, ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[0], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[1], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[2], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[3], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[4], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[5], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[6], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[7], ptPos)
                        && !PtInRect((LPRECT)&s_rcCandBtn[8], ptPos))
                    MessageBeep(MB_ICONEXCLAMATION);
            }
            break;

        case WM_LBUTTONUP:
            GetCursorPos(&ptPos);
            ScreenToClient(hCandWnd, &ptPos);
            if (PtInRect((LPRECT)&rcLArrow, ptPos))
            {
                keybd_event(VK_LEFT, 0, KEYEVENTF_EXTENDEDKEY, 0);
                keybd_event(VK_LEFT, 0, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);
            }
            else if (PtInRect((LPRECT)&rcRArrow, ptPos))
            {
                keybd_event(VK_RIGHT, 0, KEYEVENTF_EXTENDEDKEY, 0);
                keybd_event(VK_RIGHT, 0, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);
            }
            else
            {
                for (iLoop = 0; iLoop < CAND_PAGE_SIZE; iLoop++)
                    if (PtInRect((LPRECT)&s_rcCandBtn[iLoop], ptPos))
                    {    
                        keybd_event((BYTE)(iLoop + '1'), 0, 0, 0);
                        keybd_event((BYTE)(iLoop + '1'), 0, KEYEVENTF_KEYUP, 0);
                        break;
                    }
            }
            break;

        case WM_MOUSEMOVE:
        //case WM_LBUTTONDOWN:
        //case WM_LBUTTONUP:
            {
                HGLOBAL            hUIPrivate;
                LPUIPRIV        lpUIPrivate;
                HWND            hUIWnd;
                MSG                msg;
                POINT            ptCur;

                hUIWnd = GetWindow(hCandWnd, GW_OWNER);
                hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
                if (!hUIPrivate) {
                    break;
                }
                lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
                if (!lpUIPrivate) {         // can not draw candidate window
                    break;
                }
                ZeroMemory(&msg, sizeof(MSG));
                msg.message = message;
                msg.hwnd = hCandWnd;
                msg.wParam = 0; //msg.lParam = 0x00050023L;
                GetCursorPos(&ptCur);
                ScreenToClient(hCandWnd, &ptCur);
                msg.lParam = MAKELONG(ptCur.x, ptCur.y);
                Dbg(DBGID_Cand|DBGID_UI, TEXT("CandOnSetCursor(): WM_MOUSEMOVE - msg.lParam= 0x%08lX"), msg.lParam),
                OurSendMessage(lpUIPrivate->hCandTTWnd, TTM_RELAYEVENT, 0, (LPARAM) (LPMSG) &msg);
                GlobalUnlock(hUIPrivate);
            }
            break;
    }    
    return fTrue;
}


VOID PASCAL PaintCandWindow(HWND hCandWnd, HDC hDC)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    PCIMECtx    pImeCtx;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
//  LPSTR       lpCandStr;
    HFONT       hFontFix, hOldFont;
    DWORD       iLoop, iStart;
    HBITMAP        hBMCand, hBMCandNum, hBMCandArr1, hBMCandArr2;
    INT         iSaveBkMode;
    TOOLINFO    ti;
    HGLOBAL        hUIPrivate;
    LPUIPRIV    lpUIPrivate;


    Dbg(DBGID_UI, TEXT("PaintCandWindow"));

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);
    
    hIMC = GethImcFromHwnd(hUIWnd);
    
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)
        {
        DbgAssert(0);
        return;
        }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)
        return;

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        {
        DbgAssert(0);
        goto PaintCandWindowExit;
        }
    
    lpCandInfo = pImeCtx->GetPCandInfo();
    if (lpCandInfo == NULL)
        {
        DbgAssert(0);
        goto PaintCandWindowExit;
        }

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo + sizeof(CANDIDATEINFO));
    Dbg(DBGID_UI, TEXT("PaintCandWindow - dwCount = %d"), lpCandList->dwCount);

    if (lpCandList->dwCount)
        {
        if (IsWinNT())
            hFontFix = CreateFontW(
                            -16,0,0,0, 
                            0,0,0,0,
                            HANGUL_CHARSET,
                            OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, 
                             DEFAULT_QUALITY, 
                             FIXED_PITCH, 
                             wzIMECompFont);
         else
            hFontFix = CreateFontA(
                            -16,0,0,0, 
                            0,0,0,0,
                            HANGUL_CHARSET,
                            OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, 
                             DEFAULT_QUALITY, 
                             FIXED_PITCH, 
                             szIMECompFont);
             
        
        hOldFont = (HFONT)SelectObject(hDC, hFontFix);
        // Load bitmaps
        hBMCand = (HBITMAP)OurLoadImage(MAKEINTRESOURCE(IDB_CAND_WIN),
                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );
        hBMCandNum = (HBITMAP)OurLoadImage(MAKEINTRESOURCE(IDB_CAND_NUM),
                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );
        hBMCandArr1 = (HBITMAP)OurLoadImage(MAKEINTRESOURCE(IDB_CAND_ARRY1),
                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );
        hBMCandArr2 = (HBITMAP)OurLoadImage(MAKEINTRESOURCE(IDB_CAND_ARRY2),
                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );

        DrawBitmap(hDC, 0, 0, hBMCand);
        iSaveBkMode = SetBkMode(hDC, TRANSPARENT);
        iStart = (lpCandList->dwSelection / lpCandList->dwPageSize) * lpCandList->dwPageSize;

        ZeroMemory(&ti, sizeof(TOOLINFO));
        ti.cbSize = sizeof(TOOLINFO);
        ti.uFlags = 0;
        ti.hwnd = hCandWnd;
        ti.hinst = vpInstData->hInst;

        // Paint current page 9 candidate chars
        for (iLoop = 0; iLoop < CAND_PAGE_SIZE && iStart+iLoop < lpCandList->dwCount; iLoop++)
            {
            // Set text color
            if ( (iStart + iLoop) >= GetNumOfK0() )    // if K1 Hanja set it blue color
                {
                // If button face is black
                if (GetSysColor(COLOR_3DFACE) == RGB(0,0,0)) 
                    SetTextColor(hDC, RGB(0, 128, 255));
                else
                    SetTextColor(hDC, RGB(0, 0, 255));
                }
            else
                SetTextColor(hDC, GetSysColor(COLOR_MENUTEXT));

//          lpCandStr = (LPSTR)((LPSTR)lpCandList + lpCandList->dwOffset[iStart + iLoop]);
            OurTextOutW(hDC, s_rcCandBtn[iLoop].left + 10, s_rcCandBtn[iLoop].top +3, 
                            pImeCtx->GetCandidateStr(iStart + iLoop));
//                            (LPWSTR)lpCandStr, 
//                            1);
//            Dbg(DBGID_UI, TEXT("PaintCandWindow -  Cand Char = 0x%04x"), *(LPWSTR)lpCandStr);

            // Set tooltip info
            if (IsWin(lpUIPrivate->hCandTTWnd))
                {
                CIMEData     ImeData;
                CHAR        szCurSense[MAX_SENSE_LENGTH+6+1]; // 6 reserved for Unicode display(Format "U+0000")
                WCHAR        wszCurSense[MAX_SENSE_LENGTH+6+1]; // 6 reserved for Unicode display(Format "U+0000")
                CHAR        szHanjaMeaning[MAX_SENSE_LENGTH+1];
                WCHAR        wzHangulOfHanja[2];  // Need just one character
                CHAR        szHangulOfHanja[4];    // One DBCS + One Null + extra byte
                LPWSTR        pwszMeaning;

                // Init local vars
                szCurSense[0]  = '\0';
                wszCurSense[0] = L'\0';
                szHanjaMeaning[0] = '\0';
                wzHangulOfHanja[0] = L'\0';
                szHangulOfHanja[0] = '\0';
                    
                ti.uId = iLoop;
                // Get the meaning of current Hanja 
                if (pwszMeaning = pImeCtx->GetCandidateMeaningStr(iStart+iLoop)) 
                    {
                    
                    // Get Hangul pronounciation of current Hanja 
                    wzHangulOfHanja[0] = GetCurrentHangulOfHanja();
                    wzHangulOfHanja[1] = L'\0';

                    if (IsWinNT())
                        {
                        if (ImeData->fCandUnicodeTT)
                            wsprintfW(wszCurSense, L"%s %s\r\nU+%04X", 
                                      pwszMeaning, 
                                      wzHangulOfHanja,
                                      (WORD)pImeCtx->GetCandidateStr(iStart + iLoop));
                        else
                            wsprintfW(wszCurSense, L"%s %s", pwszMeaning, wzHangulOfHanja);

                        ti.lpszText = (LPSTR)wszCurSense;
                        }
                    else // If not NT, convert to ANSI
                        {
                        if (WideCharToMultiByte(CP_KOREA, 0, 
                                            pwszMeaning, 
                                            -1, 
                                            (LPSTR)szHanjaMeaning, 
                                            sizeof(szHanjaMeaning), 
                                            NULL, 
                                            NULL) == 0)
                            szHanjaMeaning[0] = 0;

                        if (WideCharToMultiByte(CP_KOREA, 0, 
                                            wzHangulOfHanja, 
                                            -1, 
                                            (LPSTR)szHangulOfHanja, 
                                            sizeof(szHangulOfHanja), 
                                            NULL, 
                                            NULL) == 0)
                            szHangulOfHanja[0] = 0;

                        if (ImeData->fCandUnicodeTT)
                            wsprintfA(szCurSense, "%s %s\r\nU+%04X", 
                                      szHanjaMeaning, 
                                      szHangulOfHanja,
                                      (WORD)pImeCtx->GetCandidateStr(iStart + iLoop));
                        else
                            wsprintfA(szCurSense, "%s %s", szHanjaMeaning, szHangulOfHanja);

                        ti.lpszText = szCurSense;
                        }
                    }
                else
                    {
                    if (ImeData->fCandUnicodeTT)
                        {
                        wsprintfA(szCurSense, "U+%04X", (WORD)pImeCtx->GetCandidateStr(iStart + iLoop));
                        ti.lpszText = szCurSense;
                        }
                    }

                // Set Tooltip Text
                if (ti.lpszText)
                    {
                    UINT uiMsgUpdateTxt = TTM_UPDATETIPTEXTW;
                    
                    if (!IsWinNT())
                        uiMsgUpdateTxt = TTM_UPDATETIPTEXT;
                    OurSendMessage(lpUIPrivate->hCandTTWnd, uiMsgUpdateTxt, 0, (LPARAM) (LPTOOLINFO) &ti);
                    
                    //  To force the tooltip control to use multiple lines
                    OurSendMessage(lpUIPrivate->hCandTTWnd, TTM_SETMAXTIPWIDTH, 0, 300);
                    }
                }
            }
            
        SetBkMode(hDC, iSaveBkMode);
        // Reset blank cand list tooltip
        if (iLoop < CAND_PAGE_SIZE) 
            {
            ti.lpszText = NULL;
            for (; iLoop < CAND_PAGE_SIZE; iLoop++) 
                {
                ti.uId = iLoop;
                OurSendMessage(lpUIPrivate->hCandTTWnd, TTM_UPDATETIPTEXT, 0, (LPARAM) (LPTOOLINFO) &ti);
                DrawBitmap(hDC, s_rcCandBtn[iLoop].left + 3, s_rcCandBtn[iLoop].top + 6, hBMCandNum);
                }
            }
        //
        if (iStart)
            DrawBitmap(hDC, 19, 8, hBMCandArr1);
        
        if (iStart + CAND_PAGE_SIZE < lpCandList->dwCount)
            DrawBitmap(hDC, 296, 8, hBMCandArr2);

        DeleteObject(hBMCand);
        DeleteObject(hBMCandNum);
        DeleteObject(hBMCandArr1);
        DeleteObject(hBMCandArr2);
        SelectObject(hDC, hOldFont);
        DeleteObject(hFontFix);
        }
    
PaintCandWindowExit:
    GlobalUnlock(hUIPrivate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\cicbtn.h ===
//
// cicbtn.h
//

#ifndef _CICBTN_H_
#define _CICBTN_H_

#include "msctf.h"
#include <initguid.h>
#include "..\CiceroLib\inc\slbarid.h"

#define CICBTN_TOOLTIP_MAX	256
#define CICBTN_TEXT_MAX	256

class __declspec(novtable) CCicButton : public ITfSource, public ITfLangBarItemButton
{
public:
    CCicButton()
    {
		m_uid       = (UINT)-1;
		m_dwStatus  = 0;
		m_fShown    = FALSE;
		m_fEnable   = TRUE;
		m_szText[0] = L'\0';
		m_plbiSink  = NULL;
		m_cRef      = 1;
	}
    ~CCicButton();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
	//virtual STDMETHODIMP_(ULONG) Release(void);

    void InitInfo(REFCLSID clsid, REFGUID rguid, DWORD dwStyle, ULONG ulSort, LPWSTR pszDesc);
    virtual STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    virtual STDMETHODIMP GetStatus(DWORD *pdwStatus);
    virtual STDMETHODIMP Show(BOOL fShow);
    virtual STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);
    virtual STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    virtual STDMETHODIMP UnadviseSink(DWORD dwCookie);
	virtual STDMETHODIMP OnClick( /* [in] */ TfLBIClick click, /* [in] */ POINT pt, /* [in] */ const RECT __RPC_FAR *prcArea);
	virtual STDMETHODIMP InitMenu( /* [in] */ ITfMenu __RPC_FAR *pMenu);
	virtual STDMETHODIMP OnMenuSelect( /* [in] */ UINT wID);
	virtual STDMETHODIMP GetIcon( /* [out] */ HICON __RPC_FAR *phIcon);
	virtual STDMETHODIMP GetText( /* [out] */ BSTR __RPC_FAR *pbstrText);

    virtual HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    virtual HRESULT OnRButtonUp(const POINT pt, const RECT *prcArea);

    DWORD GetStyle() {return m_lbiInfo.dwStyle;}
    void SetStyle(DWORD dwStyle) {m_lbiInfo.dwStyle = dwStyle;}

    GUID* GetGuidItem() {return &m_lbiInfo.guidItem;}

    DWORD GetStatusInternal() {return m_dwStatus;}
    void SetStatusInternal(DWORD dw) {m_dwStatus = dw;}
    HRESULT ShowInternal(BOOL fShow, BOOL fNotify = FALSE);

    void SetOrClearStatus(DWORD dw, BOOL fSet);

    ITfLangBarItemSink *GetSink() { return m_plbiSink; }

    void SetText(WCHAR *psz);
    void SetToolTip(WCHAR *psz);
	void SetStatus(DWORD dwStatus);
	void Enable(BOOL fEnable);
	BOOL IsEnable() { return m_fEnable;	}
	void ShowDefault(BOOL fShowDefault);

	void SetID(UINT uid) { m_uid = uid;  }
	UINT GetID()	     { return m_uid; }

	void UpdateButton();

protected:
    //DWORD _dwStatus;
    TF_LANGBARITEMINFO m_lbiInfo;
    WCHAR m_szToolTip[CICBTN_TOOLTIP_MAX];
    long m_cRef;
    ITfLangBarItemSink *m_plbiSink;

private:
    DWORD m_dwCookie;
	DWORD m_dwStatus;
	BOOL m_fShown;
	BOOL m_fEnable;
	UINT m_uid;
    WCHAR m_szText[CICBTN_TEXT_MAX];
};

inline
void CCicButton::SetOrClearStatus(DWORD dw, BOOL fSet)
{
    if (fSet)
        m_dwStatus |= dw;
    else
        m_dwStatus &= ~dw;
}

inline
void CCicButton::SetToolTip(WCHAR *psz)
{
    StrnCopyW(m_szToolTip, psz, CICBTN_TOOLTIP_MAX);
}


inline
void CCicButton::SetStatus(DWORD dwStatus)
{
	BOOL fShown = m_fShown;
	m_dwStatus = dwStatus;
	ShowInternal(fShown);
}

inline
void CCicButton::Enable(BOOL fEnable)
{
	m_fEnable = fEnable;
	if(fEnable) {	// enable?
		m_dwStatus &= ~TF_LBI_STATUS_DISABLED;
	} else {
		m_dwStatus |= TF_LBI_STATUS_DISABLED;
	}
}

inline
void CCicButton::ShowDefault(BOOL fShowDefault)
{
	if( fShowDefault == FALSE ) {
		m_lbiInfo.dwStyle |= TF_LBI_STYLE_HIDDENBYDEFAULT;
	} else {
		m_lbiInfo.dwStyle &= ~TF_LBI_STYLE_HIDDENBYDEFAULT;
	}
}

inline
void CCicButton::SetText(WCHAR *psz)
{
	StrnCopyW(m_szText, psz, CICBTN_TEXT_MAX);
}

inline
void CCicButton::UpdateButton()
{
	if (m_plbiSink)
		m_plbiSink->OnUpdate(TF_LBI_BTNALL| /*TF_LBI_BITMAP |*/ TF_LBI_STATUS /*| TF_LBI_BMPALL*/);
}

#endif // _CICBTN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\apientry.h ===
/****************************************************************************
	APIENTRY.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Header file for API entries between IMM32 and IME

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_APIENTRY_H__INCLUDED_)
#define _APIENTRY_H__INCLUDED_

#include "debug.h"

extern "C" {
DWORD WINAPI ImeGetImeMenuItems(HIMC hIMC, DWORD dwFlags, DWORD dwType, 
								LPIMEMENUITEMINFO lpImeParentMenu, LPIMEMENUITEMINFO lpImeMenu, 
								DWORD dwSize);
}

///////////////////////////////////////////////////////////////////////////////
// Inline Functions

// Fill a TransMsg Helper function
inline 
void SetTransBuffer(LPTRANSMSG lpTransMsg, 
					UINT message, WPARAM wParam, LPARAM lParam)
{
	DbgAssert(lpTransMsg != NULL);
	lpTransMsg->message = message;
	lpTransMsg->wParam = wParam;
	lpTransMsg->lParam = lParam;
}

#endif // !defined (_APIENTRY_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\cicero.h ===
/****************************************************************************
	CICERO.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Cicero Toolbar Handling

	History:
	29-MAY-2000 cslim       Ported from KKIME
*****************************************************************************/

#ifndef __CICERO_H__
#define __CICERO_H__

#include "msctf.h"

//
// !! external functions must not in the extern "C" {}
//
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

extern BOOL vfCicero;

BOOL WINAPI CiceroInitialize();
BOOL WINAPI CiceroTerminate();
HRESULT WINAPI Cicero_CreateLangBarMgr(ITfLangBarMgr **pppbm);

__inline BOOL WINAPI IsCicero(VOID)
{
	return vfCicero;
}

BSTR OurSysAllocString(const OLECHAR* pOleSz);

#ifdef __cplusplus
}            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#endif // __CICERO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\cimecb.cpp ===
/****************************************************************************
    CIMECB.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IME PAD wrapper functions

    History:
    23-APR-1999 cslim       Created
*****************************************************************************/
#include "precomp.h"
#include "cimecb.h"
#include "pad.h"
#include "UI.h"

static LPCImeCallback g_lpCImeCallback = NULL;

LPCImeCallback CImeCallback::Fetch(VOID)
{
    if(g_lpCImeCallback) {
        return g_lpCImeCallback;
    }
    g_lpCImeCallback = new CImeCallback();
    return g_lpCImeCallback;
}

VOID
CImeCallback::Destroy(VOID)
{
    //OutputDebugString("CImeCallback::Destroy START\n");
    if(g_lpCImeCallback) {
        //OutputDebugString("--> g_lpCImeCallback is allocated\n");
        delete g_lpCImeCallback;
        g_lpCImeCallback = NULL;
    }
    //OutputDebugString("CImeCallback::Destroy END\n");
}

CImeCallback::CImeCallback()
{
    m_cRef = 1;
}

CImeCallback::~CImeCallback()
{

}

HRESULT __stdcall CImeCallback::QueryInterface(REFIID refiid, LPVOID* ppv)
{
    if(refiid == IID_IUnknown) {
        *ppv = static_cast<IUnknown *>(this);
    }
    else if(refiid == IID_IImeCallback) {
        *ppv = static_cast<IImeCallback *>(this);
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}

ULONG    __stdcall CImeCallback::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG   __stdcall CImeCallback::Release()
{
    if(InterlockedDecrement(&m_cRef) == 0) {
        //Delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT __stdcall CImeCallback::GetApplicationHWND(HWND *pHwnd)
{
    //----------------------------------------------------------------
    //Get Application's Window Handle.
    //----------------------------------------------------------------
    if(pHwnd) {
        *pHwnd = GetActiveUIWnd();
        return S_OK;
    }
    return S_FALSE;
}

HRESULT __stdcall CImeCallback::Notify(UINT notify, WPARAM wParam, LPARAM lParam)
{
    HWND hUIWnd;
    
#ifdef _DEBUG
    CHAR szBuf[256];
    wsprintf(szBuf, "Cimecallback::NOtify notify [%d]\n", notify);
    OutputDebugString(szBuf);
#endif
    switch(notify) {
    case IMECBNOTIFY_IMEPADCLOSED:
        //----------------------------------------------------------------
        //ImePad has Closed. repaint toolbar...
        //----------------------------------------------------------------
        // UI::IMEPadNotify();
        hUIWnd = GetActiveUIWnd();
        if (hUIWnd)
            {
            OurPostMessage(hUIWnd, WM_MSIME_UPDATETOOLBAR, 0, 0);
            }
        break;
    default:
        break;
    }
    return S_OK;
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\cicero.cpp ===
/****************************************************************************
    CICERO.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Cicero Toolbar Handling

    History:
    29-MAY-2000 cslim       Ported from KKIME
*****************************************************************************/

#include "precomp.h"
#include "cicero.h"
#include "gdata.h"

BOOL vfCicero = fFalse;

#define SZCICEROMODULE    "msctf.dll"
HMODULE g_hCicero = (HMODULE)0;

#define SZOLEAUTOMODULE    "oleaut32.dll"
HMODULE g_hOleAuto = (HMODULE)0;

typedef HRESULT(* FPTF_CreateLangBarMgr)(ITfLangBarMgr **pppbm);
static FPTF_CreateLangBarMgr pFPTF_CreateLangBarMgr = 0;

typedef BSTR(* FPSysAllocString)(const OLECHAR* pOleSz);
static  FPSysAllocString pFPSysAllocString = 0;

static BOOL IsDisabledTextServices();

/*----------------------------------------------------------------------------
    CiceroInitialize

    Load Cicero Language bar
----------------------------------------------------------------------------*/
BOOL WINAPI CiceroInitialize()
{
    // Winlogon process wouldn't run Cicero
    if (vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON 
        || IsDisabledTextServices())
        return fFalse;
        
    if (g_hCicero == (HMODULE)0) 
        {
        g_hCicero=LoadLibrary(SZCICEROMODULE);
        if (!g_hCicero)
            return fFalse;
        }

    if (g_hOleAuto == (HMODULE)0) 
        {
        g_hOleAuto=LoadLibrary(SZOLEAUTOMODULE);
        if (!g_hOleAuto)
            return fFalse;
        }

    if (pFPTF_CreateLangBarMgr == NULL)
        pFPTF_CreateLangBarMgr = (FPTF_CreateLangBarMgr)GetProcAddress(g_hCicero, "TF_CreateLangBarMgr");

    if (pFPTF_CreateLangBarMgr)
        vfCicero = fTrue;

    if (pFPSysAllocString == NULL)
        pFPSysAllocString = (FPSysAllocString)GetProcAddress(g_hOleAuto, "SysAllocString");

    if (pFPSysAllocString)
        {
        // ok
        }

    return vfCicero;
}

/*----------------------------------------------------------------------------
    CiceroTerminate

    Terminate Cicero Language bar service
----------------------------------------------------------------------------*/
BOOL WINAPI CiceroTerminate()
{
    BOOL fRetCic = fFalse;
    BOOL fRetOle = fFalse;
    
    if (g_hCicero)
        {
        FreeLibrary(g_hCicero);
        g_hCicero = NULL;
        vfCicero = fFalse;
        fRetCic= fTrue;
        }
        
    if (g_hOleAuto)
        {
        FreeLibrary(g_hOleAuto);
        g_hOleAuto = NULL;
        fRetOle    = fTrue;
        }
        
    if (fRetCic && fRetOle)
        return fTrue;
    else        
        return fFalse;
}

/*----------------------------------------------------------------------------
    Cicero_CreateLangBarMgr

    Create Cicero Lang bar manager object
----------------------------------------------------------------------------*/
HRESULT WINAPI Cicero_CreateLangBarMgr(ITfLangBarMgr **pppbm)
{
    *pppbm = NULL;
    
    if (vfCicero && g_hCicero)
        return pFPTF_CreateLangBarMgr(pppbm);

    return S_FALSE;
}

/*----------------------------------------------------------------------------
    OurSysAllocString
----------------------------------------------------------------------------*/
BSTR OurSysAllocString(const OLECHAR* pOleSz)
{
    if (pFPSysAllocString)
        return pFPSysAllocString(pOleSz);

    return NULL;
}

//+---------------------------------------------------------------------------
//
// IsDisabledTextServices
// 
// Copied from immxutil.cpp
//----------------------------------------------------------------------------
BOOL IsDisabledTextServices()
{
    static const TCHAR c_szCTFKey[]     = TEXT("SOFTWARE\\Microsoft\\CTF");
    static const TCHAR c_szDiableTim[]  = TEXT("Disable Thread Input Manager");

    HKEY hKey;

    if (RegOpenKey(HKEY_CURRENT_USER, c_szCTFKey, &hKey) == ERROR_SUCCESS)
    {
        DWORD cb;
        DWORD dwDisableTim = 0;

        cb = sizeof(DWORD);

        RegQueryValueEx(hKey,
                        c_szDiableTim,
                        NULL,
                        NULL,
                        (LPBYTE)&dwDisableTim,
                        &cb);

        RegCloseKey(hKey);

        //
        // Ctfmon disabling flag is set, so return fail CreateInstance.
        //
        if (dwDisableTim)
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\cmode.cpp ===
/****************************************************************************
   CMODE.CPP : CMode class implementation which manage conversion mode button
                      on the Cicero Toolbar

   History:
      10-JAN-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "cmode.h"
#include "gdata.h"
#include "ui.h"
#include "winex.h"
#include "resource.h"

// {3CB8145F-8A84-4d53-8899-5783B942FBDE}
const GUID GUID_LBI_KORIME_CMODE = 
{
    0x3cb8145f, 0x8a84, 0x4d53,
    { 0x88, 0x99, 0x57, 0x83, 0xb9, 0x42, 0xfb, 0xde }
};

/*---------------------------------------------------------------------------
    CMode::CMode
---------------------------------------------------------------------------*/
CMode::CMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    szText[0] = L'\0';
        
    // Set Add/Remove text and tootip text
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_TT_HAN_ENG, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_SYSTEMLANGBARITEM_KEYBOARD, 
                GUID_LBI_KORIME_CMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_SHOWNINTRAY | TF_LBI_STYLE_TEXTCOLORICON,
                200, 
                szText);
    SetToolTip(szText);

    // Set button text
    szText[0] = L'\0';
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_BUTTON_HAN_ENG, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}


/*---------------------------------------------------------------------------
    CMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CMode::Release()
{
    long cr;

    cr = --m_cRef;
    DbgAssert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    CMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI CMode::GetIcon(HICON *phIcon)
{
    DWORD dwCM = GetCMode();
    UINT uiIcon = 0;
    static const UINT uidIcons[2][2] = 
    {
        { IDI_CMODE_ENGLISH, IDI_CMODE_ENGLISHW },
        { IDI_CMODE_HANGUL,  IDI_CMODE_HANGULW }
    };

    if (m_pTb->IsOn() && (m_pTb->GetConversionMode() & IME_CMODE_HANGUL))
        uiIcon = 1;

    if (IsHighContrastBlack())
        uiIcon = uidIcons[uiIcon][1];
    else
        uiIcon = uidIcons[uiIcon][0];
    
    *phIcon = (HICON)LoadImage(vpInstData->hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    CMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    CMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
#if 0
    DWORD dwConvMode;

    dwConvMode = m_pTb->GetConversionMode();

    // Toggle Hangul mode
    if (dwConvMode & IME_CMODE_HANGUL)
        dwConvMode &= ~TIP_HANGUL_MODE;
    else
        dwConvMode |= TIP_HANGUL_MODE;

    SetCMode(dwConvMode);
#endif

    keybd_event(VK_HANGUL, 0, 0, 0);
    keybd_event(VK_HANGUL, 0, KEYEVENTF_KEYUP, 0);

    return S_OK;
}

#if 0
//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    HMENU hMenu;
    DWORD dwConvMode;
    PCIMECtx pImeCtx;
    CHAR  szText[256];
    UINT  uiId;
    int   nRet;

    hMenu      = CreatePopupMenu();
    dwConvMode = GetCMode();

    if (dwConvMode & IME_CMODE_HANGUL)
        uiId = IDS_CIC_ENGLISH_MODE;
    else
        uiId = IDS_CIC_HANGUL_MODE;

    // Add Hangul/English mode menu
    OurLoadStringA(vpInstData->hInst, uiId, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, szText);

    // Add Cancel menu
    OurLoadStringA(vpInstData->hInst, IDS_CIC_CANCEL, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 0, szText);

    nRet = TrackPopupMenuEx(hMenu, 
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, GetActiveUIWnd(), NULL);
    switch (nRet)
        {
    case 1: 
        dwConvMode = GetCMode();

        // Toggle Hangul mode
        if (dwConvMode & IME_CMODE_HANGUL)
            dwConvMode &= ~IME_CMODE_HANGUL;
        else
            dwConvMode |= IME_CMODE_HANGUL;

        pImeCtx = m_pTb->GetImeCtx();
        if (pImeCtx)
            OurImmSetConversionStatus(pImeCtx->GetHIMC(), 
                                      dwConvMode, pImeCtx->GetSentenceMode());
        break;
        }

    DestroyMenu(hMenu);

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\cimecb.h ===
#ifndef __C_IME_CALLBACK_H__
#define __C_IME_CALLBACK_H__
#include "../../fecommon/include/iimecb.h"

class CImeCallback;
typedef CImeCallback*	LPCImeCallback;
class CImeCallback: public IImeCallback
{
public:	
	//----------------------------------------------------------------
	//IUnknown
	//----------------------------------------------------------------
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID* ppvObj);
    virtual ULONG	__stdcall AddRef();
    virtual ULONG   __stdcall Release();
	//----------------------------------------------------------------
	//IImeConnectionPoint method
	//----------------------------------------------------------------
	virtual HRESULT __stdcall GetApplicationHWND(HWND *pHWND);
	virtual HRESULT __stdcall Notify(UINT notify, WPARAM wParam, LPARAM lParam);
	CImeCallback(FARPROC lpfn);
	CImeCallback();
	~CImeCallback();
	//Temporary
	static LPCImeCallback Fetch(VOID);
	static VOID Destroy(VOID); //990803:ToshiaK
	void *operator new(size_t size) { return GlobalAlloc(GMEM_FIXED, size);}
	void operator  delete(void *pv) { GlobalFree(pv);}
private:	
	static	m_lpCImeCallback;
	LONG	m_cRef; 
};

#endif //__C_IIME_CALLBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\compui.cpp ===
/****************************************************************************
    COMPUI.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Composition window UI functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "ui.h"
#include "imedefs.h"
#include "names.h"
#include "escape.h"
#include "winex.h"
#include "cicero.h"
#include "debug.h"
#include "resource.h"

PRIVATE  VOID PASCAL PaintCompWindow(HWND hCompWnd, HDC hDC);

///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK CompWndProc(HWND hCompWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    Dbg(DBGID_UI, TEXT("CompWndProc():uMessage = 0x%08lX, wParam = 0x%04X, lParam = 0x%08lX"), uMessage, wParam, lParam);

    switch (uMessage)
        {
        case WM_IME_CHAR: 
        case WM_IME_COMPOSITIONFULL:
        case WM_IME_COMPOSITION:
        case WM_IME_CONTROL:
        case WM_IME_SELECT:
        case WM_IME_SETCONTEXT:
        case WM_IME_STARTCOMPOSITION:
        case WM_IME_ENDCOMPOSITION:
            return (0L);

        case WM_PAINT:
            {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hCompWnd, &ps);
            PaintCompWindow(hCompWnd, hDC);
            EndPaint(hCompWnd, &ps);
            }
            break;
        default :
            return DefWindowProc(hCompWnd, uMessage, wParam, lParam);
        }
    return (0L);
}

VOID PASCAL PaintCompWindow(HWND hCompWnd, HDC hDC)
{
    HWND        hWndUI;
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    HFONT        hFontFix, hOldFont;
    HBITMAP        hBMComp;
    INT         iSaveBkMode;

    hWndUI = GetWindow(hCompWnd, GW_OWNER);
    hIMC = GethImcFromHwnd(hWndUI);


    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return;

       Dbg(DBGID_UI, TEXT("PaintCompWindow():CompCh = 0x%X"), pImeCtx->GetCompBufStr());

    if (pImeCtx->GetCompBufLen())
        {
        // Create font
        if (IsWinNT())
            hFontFix = CreateFontW(
                            -16,0,0,0, 
                            0,0,0,0,
                            HANGUL_CHARSET,
                            OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, 
                             DEFAULT_QUALITY, 
                             FIXED_PITCH, 
                             wzIMECompFont);
         else
            hFontFix = CreateFontA(
                            -16,0,0,0, 
                            0,0,0,0,
                            HANGUL_CHARSET,
                            OUT_DEFAULT_PRECIS,
                             CLIP_DEFAULT_PRECIS, 
                             DEFAULT_QUALITY, 
                             FIXED_PITCH, 
                             szIMECompFont);
        hOldFont = (HFONT)SelectObject(hDC, hFontFix);

        // Draw comp window Bitmap
        hBMComp = (HBITMAP)OurLoadImage(MAKEINTRESOURCE(IDB_COMP_WIN), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );
        DrawBitmap(hDC, 0, 0, hBMComp);
        
        iSaveBkMode = SetBkMode(hDC, TRANSPARENT);
        // Set text color
        SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
        OurTextOutW(hDC, 3, 3, pImeCtx->GetCompBufStr());

        // restore and delete created objects
        SelectObject(hDC, hOldFont);
        SetBkMode(hDC, iSaveBkMode);
        DeleteObject(hBMComp);
        DeleteObject(hFontFix);
        }
}

// open comp window
VOID PASCAL OpenComp(HWND hUIWnd)
{
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    INT         nShowCompCmd;
    POINT        ptClientComp;
    CIMEData    ImeData;

       Dbg(DBGID_UI, TEXT("OpenComp()"));

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    // can not draw comp window
    if (!hUIPrivate) 
        {
        DbgAssert(0);
        return;
        }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)
        return;

    // Check WM_IME_SETCONTEXT lParam
    if ((lpUIPrivate->uiShowParam & ISC_SHOWUICOMPOSITIONWINDOW) == 0)
        goto OpenCompUnlockUIPriv;
    
    hIMC = GethImcFromHwnd(hUIWnd);
    pImeCtx = GetIMECtx(hIMC);
    if (pImeCtx == NULL) 
        {
        Dbg(DBGID_UI, TEXT("OpenComp - Invalid hImc"));

        ImeData->ptCompPos.x = ImeData->rcWorkArea.right - COMP_SIZEX;
        ImeData->ptCompPos.y = ImeData->rcWorkArea.bottom - COMP_SIZEY;
        nShowCompCmd = SW_HIDE;
        } 
    else 
        {
#if 1 // MultiMonitor
        RECT rcWorkArea;
        
        ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcWorkArea);

        // if client window exist in same monitor as status window
        if (!IsCicero() && PtInRect(&rcWorkArea, ImeData->ptStatusPos)) 
            {
            ImeData->ptCompPos.x = 
                (ImeData->ptStatusPos.x+ImeData->xStatusWi+UI_GAPX + COMP_SIZEX > ImeData->rcWorkArea.right) ?
                ImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : ImeData->ptStatusPos.x + ImeData->xStatusWi + UI_GAPX;
            ImeData->ptCompPos.y = ImeData->ptStatusPos.y;
            Dbg(DBGID_UI, TEXT("OpenComp - PtInRect x = %d, y = %d"), ImeData->ptCompPos.x, ImeData->ptCompPos.y);
            }
        else 
            {   
            // if client window appeared in different monitor from status window resides,
            // then display left top of workarea of client window montitor
            ImeData->ptCompPos.x = 0;
            ImeData->ptCompPos.y = 0;
            }
#else
        ImeData->ptCompPos.x = 
            (ImeData->ptStatusPos.x+ImeData->xStatusWi+UI_GAPX + COMP_SIZEX > ImeData->rcWorkArea.right) ?
            ImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : ImeData->ptStatusPos.x + ImeData->xStatusWi + UI_GAPX;
        ImeData->ptCompPos.y = ImeData->ptStatusPos.y;
#endif
        // Set Comp wnd position of HIMC in client coordinate
        ptClientComp = ImeData->ptCompPos;
           ScreenToClient(pImeCtx->GetAppWnd(), &ptClientComp);
           pImeCtx->SetCompositionFormPos(ptClientComp);

        nShowCompCmd = SW_SHOWNOACTIVATE;
        } 

    if (lpUIPrivate->hCompWnd) 
        {
        SetWindowPos(lpUIPrivate->hCompWnd, NULL,
                    ImeData->ptCompPos.x, ImeData->ptCompPos.y,
                    0, 0,
                    SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
        } 
    else 
        {
           Dbg(DBGID_UI, TEXT("OpenComp - CreateWindow x = %d, y = %d"), ImeData->ptCompPos.x, ImeData->ptCompPos.y);
        // create comp window
        lpUIPrivate->hCompWnd = CreateWindow(
                                    szCompClassName, TEXT("\0"),
                                    WS_DISABLED | WS_POPUP,
                                    ImeData->ptCompPos.x, ImeData->ptCompPos.y,
                                    COMP_SIZEX, COMP_SIZEX, 
                                    hUIWnd, (HMENU)NULL, vpInstData->hInst, NULL);
        DbgAssert(lpUIPrivate->hCompWnd != 0);
        
        //if (!lpUIPrivate->hCompWnd)
        //    goto OpenCompUnlockUIPriv;
        }
    
    //if (pImeCtx)
    //    ShowComp(hUIWnd, SW_SHOWNOACTIVATE);

OpenCompUnlockUIPriv:
    GlobalUnlock(hUIPrivate);
    return;
    }

// Show the composition window
VOID ShowComp(HWND hUIWnd, INT nShowCompCmd)
    {
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    
    Dbg(DBGID_UI, TEXT("ShowComp(): nShowCompCmd = %d"), nShowCompCmd);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);

    // can not draw comp window
    if (!hUIPrivate)
        {
        DbgAssert(0);
        return;
        }
        
    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)
        {
        DbgAssert(0);
        return;
        }

    hIMC = GethImcFromHwnd(hUIWnd);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        goto SwCompNoChange;

    // b#53794
    // Some absurd Apps send WM_IME_START_COMPOSITION and WM_IME_COMPOSITION,
    // even though they have no composition string
    // In this case wrong composition window appears in screen like white square or something.
    if (nShowCompCmd == SW_SHOWNOACTIVATE)
        {
        if (pImeCtx->GetCompBufLen() == 0 || vfWndOpen[COMP_WINDOW] == fFalse)
            nShowCompCmd = SW_HIDE;
        }

    if (lpUIPrivate->nShowCompCmd == nShowCompCmd)
        goto SwCompNoChange;

    if (lpUIPrivate->hCompWnd) 
        {
        ShowWindow(lpUIPrivate->hCompWnd, nShowCompCmd);
        lpUIPrivate->nShowCompCmd = nShowCompCmd;
        }
    else
        lpUIPrivate->nShowCompCmd = SW_HIDE;

SwCompNoChange:
    GlobalUnlock(hUIPrivate);
}


BOOL fSetCompWindowPos(HWND hCompWnd)
{
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    RECT        rcCur;
    POINT         ptNew;
    CIMEData    ImeData;

    // No composition window
    if (hCompWnd == 0)
        return fFalse;

    hIMC = GethImcFromHwnd(GetWindow(hCompWnd, GW_OWNER));
    //if (!hIMC) 
    //    {
    //    DbgAssert(0);
    //    return fFalse;
    //    }

    //lpIMC = (LPINPUTCONTEXT)OurImmLockIMC(hIMC);
    //if (!lpIMC)
    //    {
    //    DbgAssert(0);
    //    return fFalse;
    //    }

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;
        
    Dbg(DBGID_UI, TEXT("fSetCompWindowPos()"));

    if (pImeCtx->GetCompositionFormStyle() & CFS_RECT)
        {
        Dbg(DBGID_UI, TEXT("fSetCompWindowPos(): CFS_RECT"));
        pImeCtx->GetCompositionForm(&rcCur);
        ptNew.x = rcCur.left;
        ptNew.y = rcCur.top;
        ClientToScreen(pImeCtx->GetAppWnd(), &ptNew);
        }
    else 
        if (pImeCtx->GetCompositionFormStyle() & CFS_POINT)
        {
        Dbg(DBGID_UI, TEXT("fSetCompWindowPos(): CFS_POINT"));
        pImeCtx->GetCompositionForm(&ptNew);
        ClientToScreen(pImeCtx->GetAppWnd(), &ptNew);
        }
        else 
            {   // For CFS_DEFAULT
            Dbg(DBGID_UI, TEXT("fSetCompWindowPos(): CFS_DEFAULT"));
    #if 1 // MultiMonitor
            RECT  rcWorkArea;

            ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcWorkArea);
                
            // if client window exist in same monitor as status window
            if ( PtInRect(&rcWorkArea, ImeData->ptStatusPos) ) 
                {
                ptNew.x = 
                    (ImeData->ptStatusPos.x+ImeData->xStatusWi+UI_GAPX + COMP_SIZEX > ImeData->rcWorkArea.right) ?
                    ImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : ImeData->ptStatusPos.x + ImeData->xStatusWi + UI_GAPX;
                ptNew.y = ImeData->ptStatusPos.y;
                }
            else 
                {    // if client window appeared in different monitor from status window resides,
                    // then display right bottom of workarea of client window montitor
                ptNew.x = rcWorkArea.right - COMP_SIZEX;
                ptNew.y = rcWorkArea.bottom - COMP_SIZEY;
                }
    #else
            ptNew.x = 
                (ImeData->ptStatusPos.x+ImeData->xStatusWi+UI_GAPX + COMP_SIZEX > ImeData->rcWorkArea.right) ?
                ImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : ImeData->ptStatusPos.x + ImeData->xStatusWi + UI_GAPX;
            ptNew.y = ImeData->ptStatusPos.y;
    #endif
            ImeData->ptCompPos = ptNew;
            ScreenToClient(pImeCtx->GetAppWnd(), &ptNew);
            pImeCtx->SetCompositionFormPos(ptNew);
            }

    SetWindowPos(hCompWnd, NULL,
                ptNew.x, ptNew.y,
                0, 0, SWP_NOACTIVATE|SWP_NOCOPYBITS|SWP_NOSIZE|SWP_NOZORDER);

    return (fTrue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\cmode.h ===
//
// CMODE.H
//

#if !defined (__CMODE_H__INCLUDED_)
#define __CMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class CMode : public CCicButton
{
public:
    CMode(CToolBar *ptb);
    ~CMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
 //   HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:
	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __CMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\config.h ===
/****************************************************************************
	CONFIG.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IME Configuration DLG and registry access functions

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_CONFIG_H__INCLUDED_)
#define _CONFIG_H__INCLUDED_

//////////////////////////////////////////////////////////////////////////////
// Bit const for SetRegValues
#define GETSET_REG_STATUSPOS		0x0001
#define GETSET_REG_IMEKL			0x0002
#define GETSET_REG_JASODEL			0x0004
#define GETSET_REG_ISO10646			0x0008
#define GETSET_REG_STATUS_BUTTONS	0x0010
#define GETSET_REG_KSC5657			0x0020
#define GETSET_REG_CANDUNICODETT	0x0040
#define GETSET_REG_ALL				0xFFFF

extern BOOL ConfigDLG(HWND hWnd);
extern BOOL GetRegValues(UINT uGetBits);	// get configuration info from reg. and set it to pImeData
extern BOOL GetStatusWinPosReg(POINT *pptStatusWinPosReg);
extern BOOL SetRegValues(UINT uSetBits); // set configuration info to reg.


#endif //!defined (_CONFIG_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\debug.h ===
/****************************************************************************
	DEBUG.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Debug functions

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_DEBUG_H__INCLUDED_)
#define _DEBUG_H__INCLUDED_
//#include <StdArg.H>            // va_list, va_start()

// Debug flag
extern DWORD vdwDebug;

#define	DBGID_API 		0x00000001	// IME API called
#define	DBGID_Key 		0x00000002
#define	DBGID_Mode 		0x00000004
#define	DBGID_UI 		0x00000008
#define	DBGID_UIObj 	0x00000010
#define	DBGID_Cand 		0x00000020
#define	DBGID_Conv 		0x00000040
#define	DBGID_UIWin 	0x00000080
#define	DBGID_IMECnt 	0x00000100
#define	DBGID_Tray 		0x00000200
#define	DBGID_UIMsg 	0x00000400
#define	DBGID_Mem	 	0x00000800
#define	DBGID_ARRData 	0x00001000
#define	DBGID_Mouse	 	0x00002000
#define	DBGID_SendMsg 	0x00004000
#define	DBGID_Automata 	0x00008000
#define	DBGID_IMENotify	0x00010000
#define	DBGID_Hanja 	0x00020000
#define DBGID_CompChar  0x00040000
#define DBGID_IMEDATA   0x00080000
#define DBGID_SetComp   0x00100000
#define DBGID_IMEPAD    0x00200000


#define	DBGID_Misc 		0x01000000

// destination
#define	DBGID_OUTCOM	0x00000000
#define	DBGID_OUTVIDEO	0x10000000
#define	DBGID_OUTFILE	0x20000000

#ifdef DEBUG
// Start of debug code
#define DbgW(a)	DebugOutW(a)
VOID InitDebug(VOID);

#define AST(a) _AST(__FILE__, __LINE__, a, #a, fFalse)
#define AST_EX(a) _AST(__FILE__, __LINE__, a, #a, fTrue)
#define DbgAssert	AST_EX

inline VOID DebugOut(LPCSTR pSz)
	{
	static INT DCLine = 0;
	//
	// out to com
	//
	OutputDebugStringA(pSz);

	//
	// out to video
	//
	if (vdwDebug & DBGID_OUTVIDEO) 
		{
		HDC hDC = GetDC((HWND)0);
		static CHAR sz[512];
		wsprintfA((LPSTR)sz, "%s||", (CHAR*)pSz);
		TextOutA(hDC, 0, DCLine*16, (LPSTR)sz, lstrlenA((LPSTR)sz));

		if( DCLine++ > 50 ) 
			{
			DCLine = 0;
			}
		ReleaseDC( (HWND)0, hDC );
		}

	//
	// out to file
	//
	if (vdwDebug & DBGID_OUTFILE) 
		{
		HANDLE hFile;
		DWORD dwWrite;
		hFile = CreateFile(TEXT("C:\\IMEDBGKO.TXT"), GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0 );
		SetFilePointer(hFile, 0, NULL, FILE_END);
		WriteFile( hFile, pSz, lstrlenA(pSz), &dwWrite, NULL );
		WriteFile( hFile, "\r\n", 2, &dwWrite, NULL );
		CloseHandle(hFile);
		}
	}

inline VOID DebugOutW(LPCWSTR pwSz)
	{	
	static CHAR pSz[1280] = {0};
	INT cwch = lstrlenW( pwSz );
	INT cch = WideCharToMultiByte( 949, 0, (LPWSTR)pwSz, -1, NULL, NULL, NULL, NULL );
	WideCharToMultiByte( 949, 0, (LPWSTR)pwSz, cwch, pSz, sizeof(pSz), NULL, NULL );
	pSz[cch-1] = 0;
	DebugOut( pSz );
	}

inline VOID DebugOutT(LPTSTR pwSz)
	{
	#if !defined (UNICODE)
		DebugOut(pwSz);
	#else
		DebugOutW(pwSz);
	#endif
	}
	
inline void cdecl Dbg( DWORD dID, LPCTSTR szFormat, ...)
	{
	static TCHAR szOutput[512];
	va_list valist;

	szOutput[0] = 0;
	if( vdwDebug & dID ) 
		{
		va_start( valist, szFormat );
		wvsprintf(szOutput, szFormat, valist);
		va_end(valist);
		
		lstrcat(szOutput, TEXT("\r\n"));
		DebugOutT(szOutput);
		}
	return;
	}

inline void _AST(LPCSTR szFile, INT iLine, BOOL fAssert, LPCSTR pSz, BOOL fBreak)
	{
	if( fAssert == fFalse ) 
		{
		static CHAR szOutput[512];
		wsprintfA(szOutput, "* * * * * A S S E R T I O N  F A I L E D * * * * *\r\n%s(%d)  :  value=%d / %s", szFile, iLine, fTrue, pSz  );
		lstrcatA(szOutput, "\r\n");
//#if !defined (UNICODE)
		DebugOut(szOutput);
//#else
//		DebugOutW(szOutput);
//#endif
		if( fBreak == fTrue ) 
			{
			__try 
				{ 
				DebugBreak(); 
				}
			__except(EXCEPTION_EXECUTE_HANDLER) 
				{ 
				OutputDebugStringA("DebugBreak"); 
				}
			}
		}
	}
#else
// Start of retail code
// Define Dbg as void(0) will not compile with 64bit compiler
#define Dbg		/##/	// Dbg should be appeared as one line. Even brace will cause compile error.
#define DbgW	/##/
#define DbgAssert(a)
#define DebugOut(a)
#define DebugOutW(a)
#define DebugOutT(a)
#define AST(a)	
#define AST_EX(a)	
// End of retail code

#endif // ifndef _DEBUG

#endif // !defined (_DEBUG_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\config.cpp ===
/****************************************************************************
    CONFIG.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IME Configuration DLG and registry access functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "ui.h"
#include "imedefs.h"
#include "debug.h"
#include "common.h"
#include "names.h"
#include "winex.h"
#include "config.h"
#include "cicero.h"
#include "resource.h"

// Config DLG Help ID
#define IDH_GRP_STATUSWIN               1001
#define IDH_JUNBAN_TOGGLE               1002
#define IDH_HANJA_CONV                  1003
#define IDH_GRP_KEYLAYOUT               1004
#define IDH_2BEOLSIK                    1005
#define IDH_3BEOLSIK_390                1006
#define IDH_3BEOLSIK_FINAL              1007
#define IDH_DELJASO                     1008
#define IDH_K1HANJA                        1009

// Private functions
static void PASCAL AddPage(LPPROPSHEETHEADERW ppsh, UINT id, DLGPROC pfn);
static INT_PTR CALLBACK ConfigDLGProc1(HWND hDlg, UINT message, 
                                   WPARAM wParam, LPARAM lParam);
static int *GetContextHelpList();
static BOOL IsValidCtrlIdForHelp(INT *helpList, INT ctrlId);
static void GetHelpFileName();

int *GetContextHelpList()
{
    // Context Help Ids of PropertySheet
    static int ProDlgCtxHelpList[] = 
        {
        IDC_GRP_KEYLAYOUT,  IDH_GRP_KEYLAYOUT,
        IDC_GRP_STATUSWIN,  IDH_GRP_STATUSWIN,
        IDC_JUNBAN_TOGGLE,  IDH_JUNBAN_TOGGLE,
        IDC_HANJA_CONV,     IDH_HANJA_CONV,
        IDC_2BEOLSIK,       IDH_2BEOLSIK,   
        IDC_3BEOLSIK_390,   IDH_3BEOLSIK_390,
        IDC_3BEOLSIK_FINAL, IDH_3BEOLSIK_FINAL,
        IDC_DELJASO,        IDH_DELJASO,
        IDC_K1HANJA,        IDH_K1HANJA,
        0,      0
        };
    return ProDlgCtxHelpList;
}

BOOL IsValidCtrlIdForHelp(INT *helpList, INT ctrlId)
{
    INT *p;
    for(p = helpList; *p != 0;  p+=2) 
        {
        if(ctrlId == *p)
            return fTrue;
        }
    return fFalse;
}

void GetHelpFileName(LPTSTR szHelpFileNameFull, int cchszHelpFileNameFull)
{
    // WARNING: This only will work for NT or Win98. For Win95 need to check system locale
    OurLoadStringA(vpInstData->hInst, IDS_CONTEXTHELP_FILENAME, szHelpFileNameFull, MAX_PATH);
}

static HWND hwndPropSheet = (HWND)0;
static BOOL g_fDestroyPropNow = FALSE;

BOOL ConfigDLG(HWND hwndParent)
{
    static HPROPSHEETPAGE  rPages[1];
    static PROPSHEETHEADERW psh;
       static WCHAR szCaption[64];
    MSG    msg;
    BOOL   fRet = fFalse;

    // If config DLG already created
    if (IsWindow(hwndPropSheet))
        {
        SetForegroundWindow(hwndPropSheet);
        return fTrue;
        }

    // init msg
    ZeroMemory(&msg, sizeof(MSG));
    
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_NOAPPLYNOW | PSH_USEICONID | PSH_MODELESS | PSH_USEPAGELANG;
    psh.hwndParent = hwndParent;
    psh.hInstance = vpInstData->hInst;

    if (IsWinNT())
        OurLoadStringW(vpInstData->hInst, IDS_PROGRAM, szCaption, sizeof(szCaption)/sizeof(WCHAR));
    else
        OurLoadStringA(vpInstData->hInst, IDS_PROGRAM, (LPSTR)szCaption, sizeof(szCaption));
    psh.pszCaption = szCaption;
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = rPages;

    AddPage(&psh, IDD_CONFIG_PAGE1, ConfigDLGProc1);

//    if (PropertySheet(&psh) != -1)
//        return fTrue;
//    else
//        return fFalse;
    
    if (IsWinNT())
        hwndPropSheet = (HWND)PropertySheetW(&psh);
    else
        hwndPropSheet = (HWND)PropertySheetA((PROPSHEETHEADERA*)&psh);

    while (IsWindow(hwndPropSheet) && OurGetMessage(&msg, NULL, 0x00, 0x00))
        {
        // If the modeless guy is up and is ready to be destroyed
        // (PropSheet_GetCurrentPageHwnd returns NULL) then destroy the dialog.
        
        // PropSheet_GetCurrentPageHwnd will return NULL after the OK or Cancel 
        // button has been pressed and all of the pages have been notified. The 
        // Apply button doesn't cause this to happen.
        if(/*g_fDestroyPropNow == fTrue || */(hwndPropSheet && (NULL == PropSheet_GetCurrentPageHwnd(hwndPropSheet)))) {
            //enable the parent first to prevent another window from becoming the foreground window
            //EnableWindow(hwndParent, TRUE);
            DestroyWindow(hwndPropSheet);
            //break;
        }

        //use PropSheet_IsDialogMessage instead of IsDialogMessage
        if(!PropSheet_IsDialogMessage(hwndPropSheet, &msg))
            {
            TranslateMessage(&msg);
            if (IsWinNT())
                DispatchMessageW(&msg);
            else
                DispatchMessageA(&msg);
            }
        }
    
    hwndPropSheet = (HWND)0;
    
//    if (g_fDestroyPropNow == fTrue) // closed a property sheet by the other process
//        PostMessage(hwndParent, WM_PAUSERESUME, TRUE, FALSE);    // close engine

//    g_fDestroyPropNow = fFalse;

    return fTrue;
}

void PASCAL AddPage(LPPROPSHEETHEADERW ppsh, UINT idDlg, DLGPROC pfn)
{
    //if (ppsh->nPages < 3)
    //{
    PROPSHEETPAGE psp;
    ZeroMemory(&psp, sizeof(psp));

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DLGINDIRECT;
    psp.hInstance = vpInstData->hInst;
    psp.pResource = ExLoadDialogTemplate(GetSystemDefaultLangID(), vpInstData->hInst, MAKEINTRESOURCE(idDlg));
    psp.pfnDlgProc = pfn;
    psp.lParam = 0;

    ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);
    if (ppsh->phpage[ppsh->nPages])
      ppsh->nPages++;
   //}
}

INT_PTR CALLBACK ConfigDLGProc1(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    UINT i;
    static StatusButtonTypes prevButtonTypes[MAX_NUM_OF_STATUS_BUTTONS];
    static UINT    uPrevNumOfButtons, uPrevKeyboardType;
    static BOOL    fPrevJasoDel;
    static BOOL fK1Hanja;
    BOOL fShowIME=fTrue;
    BOOL fFound = fFalse;
    TCHAR  szHelpFileNameFull[MAX_PATH];
    CIMEData    ImeData(CIMEData::SMReadWrite);

    // When no IME instance is running on the system, we should init shared mem.
    ImeData.InitImeData();

    Dbg(DBGID_Misc, TEXT("ConfigDLGProc"));

    switch(message)
        {
        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
                {
            case PSN_APPLY:
                DbgAssert(uPrevNumOfButtons <= MAX_NUM_OF_STATUS_BUTTONS);
                ImeData->uNumOfButtons = uPrevNumOfButtons;

                for (i = 0; i<MAX_NUM_OF_STATUS_BUTTONS; i++)
                    ImeData->StatusButtons[i].m_ButtonType = prevButtonTypes[i];

                UpdateStatusButtons(ImeData);
                UpdateStatusWinDimension();

                ImeData.SetCurrentBeolsik(uPrevKeyboardType);
                ImeData.SetJasoDel(fPrevJasoDel);
                ImeData.SetKSC5657Hanja(fK1Hanja);
                SetRegValues(GETSET_REG_STATUS_BUTTONS|GETSET_REG_IMEKL|GETSET_REG_JASODEL|GETSET_REG_KSC5657);
                break;
                    
            default:
                return fFalse;
                }
            break;

        case WM_INITDIALOG:
            DbgAssert(ImeData->uNumOfButtons <= MAX_NUM_OF_STATUS_BUTTONS);
            uPrevNumOfButtons = ImeData->uNumOfButtons;

            // Backup current button status
            for (i=0; i<MAX_NUM_OF_STATUS_BUTTONS; i++)
                prevButtonTypes[i] = ImeData->StatusButtons[i].m_ButtonType;

            for (i = 0; i < uPrevNumOfButtons; i++) 
                {
                switch (prevButtonTypes[i]) 
                    {
                    case JUNJA_BANJA_TOGGLE_BUTTON:
                        CheckDlgButton(hDlg, IDC_JUNBAN_TOGGLE, BST_CHECKED);
                        break;
                    case HANJA_CONV_BUTTON:
                        CheckDlgButton(hDlg, IDC_HANJA_CONV, BST_CHECKED);
                        break;
                    case IME_PAD_BUTTON:
                        CheckDlgButton(hDlg, IDC_IMEPAD, BST_CHECKED);
                        break;
                    }
                }

            // Get Show IME stataus window flag
            // If this flag is fFalse disable all show button check boxes
            SystemParametersInfo(SPI_GETSHOWIMEUI, 0, (PVOID)&fShowIME, 0);
            if (fShowIME==fFalse || IsCicero())
                {
                EnableWindow(GetDlgItem(hDlg, IDC_JUNBAN_TOGGLE), fFalse);
                EnableWindow(GetDlgItem(hDlg, IDC_HANJA_CONV), fFalse);
                EnableWindow(GetDlgItem(hDlg, IDC_IMEPAD), fFalse);
                }

            #if defined(_M_IA64)
                EnableWindow(GetDlgItem(hDlg, IDC_IMEPAD), fFalse);
            #endif

            uPrevKeyboardType = ImeData.GetCurrentBeolsik();
            CheckRadioButton(hDlg, IDC_2BEOLSIK, IDC_3BEOLSIK_FINAL, IDC_2BEOLSIK+uPrevKeyboardType);
            fPrevJasoDel = ImeData.GetJasoDel();
            if (fPrevJasoDel)
                CheckDlgButton(hDlg, IDC_DELJASO, BST_CHECKED);
            else
                CheckDlgButton(hDlg, IDC_DELJASO, BST_UNCHECKED);

            // KSC-5657 Hanja
            fK1Hanja = ImeData.GetKSC5657Hanja() && (vpInstData->f16BitApps == fFalse) && !IsWin95();
            if (fK1Hanja)
                CheckDlgButton(hDlg, IDC_K1HANJA, BST_CHECKED);
            else
                CheckDlgButton(hDlg, IDC_K1HANJA, BST_UNCHECKED);

            // If 16 bit Apps disable K1 Hanja
            if (vpInstData->f16BitApps || IsWin95())
                EnableWindow(GetDlgItem(hDlg, IDC_K1HANJA), fFalse);

            return fTrue;

        case WM_COMMAND:
            switch (wParam)
               {
            case IDC_2BEOLSIK:
                //if (IsDlgButtonChecked(hDlg, IDC_2BEOLSIK)) {
                    uPrevKeyboardType = KL_2BEOLSIK;
                //}
                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_3BEOLSIK_390:
                uPrevKeyboardType = KL_3BEOLSIK_390;
                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_3BEOLSIK_FINAL:
                uPrevKeyboardType = KL_3BEOLSIK_FINAL;
                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;
                
            case IDC_JUNBAN_TOGGLE:
                // Jun/Banja toggle button setting
                if (IsDlgButtonChecked(hDlg, IDC_JUNBAN_TOGGLE)) 
                    {
                    if (prevButtonTypes[1] != JUNJA_BANJA_TOGGLE_BUTTON)
                        {
                        for (i = uPrevNumOfButtons-1; i >= 1; i--)
                            prevButtonTypes[i+1] = prevButtonTypes[i];
                        prevButtonTypes[1] = JUNJA_BANJA_TOGGLE_BUTTON;
                        uPrevNumOfButtons++;
                        }
                    }
                else 
                    {
                    if (prevButtonTypes[1] == JUNJA_BANJA_TOGGLE_BUTTON)
                        {
                        for (i = 1; i < uPrevNumOfButtons-1; i++)
                            prevButtonTypes[i] = prevButtonTypes[i+1];
                        prevButtonTypes[uPrevNumOfButtons] = NULL_BUTTON;
                        uPrevNumOfButtons--;
                        }
                    }
                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_HANJA_CONV:
                for (i = 1; i < uPrevNumOfButtons; i++)
                    {
                    if (prevButtonTypes[i] == HANJA_CONV_BUTTON)
                        {
                        fFound = fTrue;
                        break;
                        }
                    }
                    
                // Hanja conv button setting
                if (IsDlgButtonChecked(hDlg, IDC_HANJA_CONV))
                    {
                    if (fFound == fFalse)
                        {
                        if (prevButtonTypes[uPrevNumOfButtons-1] == IME_PAD_BUTTON)
                            {
                            prevButtonTypes[uPrevNumOfButtons-1] = HANJA_CONV_BUTTON;
                            prevButtonTypes[uPrevNumOfButtons] = IME_PAD_BUTTON;
                            }
                        else
                            {
                            prevButtonTypes[uPrevNumOfButtons] = HANJA_CONV_BUTTON;
                            }
                        uPrevNumOfButtons++;
                        }
                    }
                else
                    {
                    if (fFound == fTrue)
                        {
                        uPrevNumOfButtons--;
                        for (; i < uPrevNumOfButtons; i++)
                            prevButtonTypes[i] = prevButtonTypes[i+1];
                        prevButtonTypes[uPrevNumOfButtons] = NULL_BUTTON;
                        }
                    }

                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_IMEPAD:
                if (IsDlgButtonChecked(hDlg, IDC_IMEPAD))
                    {
                    if (prevButtonTypes[uPrevNumOfButtons-1] != IME_PAD_BUTTON)
                        prevButtonTypes[uPrevNumOfButtons++] = IME_PAD_BUTTON;
                    }
                else
                    {
                    if (prevButtonTypes[uPrevNumOfButtons-1] == IME_PAD_BUTTON)
                        prevButtonTypes[--uPrevNumOfButtons] = NULL_BUTTON;
                    }

                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_DELJASO:
                if (IsDlgButtonChecked(hDlg, IDC_DELJASO))
                    fPrevJasoDel = fTrue;
                else
                    fPrevJasoDel = fFalse;

                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_K1HANJA:
                if (IsDlgButtonChecked(hDlg, IDC_K1HANJA))
                    fK1Hanja = fTrue;
                else
                    fK1Hanja = fFalse;
                OurSendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            default:
                return fFalse;
               }
            break;

        case WM_CONTEXTMENU:
            GetHelpFileName(szHelpFileNameFull, MAX_PATH);
            WinHelp((HWND)wParam, 
                    szHelpFileNameFull, 
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)(LPVOID)GetContextHelpList());
            return 0;

        case WM_HELP:
            INT *pHelpList;
            pHelpList = GetContextHelpList();
            if(IsValidCtrlIdForHelp(pHelpList, ((LPHELPINFO)lParam)->iCtrlId)) 
                {
                GetHelpFileName(szHelpFileNameFull, MAX_PATH);
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                        szHelpFileNameFull,
                        HELP_WM_HELP,
                        (ULONG_PTR)pHelpList);
                }
            return 0;

        default:
            return fFalse;
        }
    return fTrue;
}

BOOL GetStatusWinPosReg(POINT *pptStatusWinPosReg)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb;
    BOOL    fSuccess = fFalse;

    // Prevent Winlogon process from accessing registry
    if ((vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON)) 
        return fFalse;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, g_szIMEKL, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        dwCb = sizeof(dwBuf);
        if (RegQueryValueEx(hKey, g_szStatusPos, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS)
            {
            pptStatusWinPosReg->x = HIWORD(dwBuf);
            pptStatusWinPosReg->y = LOWORD(dwBuf);
            fSuccess = fTrue;
            }
            
        RegCloseKey(hKey);
        }

    return fSuccess;
}

///////////////////////////////////////////////////////////////////////////////
//
BOOL GetRegValues(UINT uGetBits)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb, dwType;
    CHAR    szLexFileName[MAX_PATH];
    CIMEData    ImeData(CIMEData::SMReadWrite);
    BOOL    fSuccess = fTrue;

    Dbg(DBGID_Misc, "GetRegValues()");

    if (RegOpenKeyEx(HKEY_CURRENT_USER, g_szIMERootKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        ///////////////////////////////////////////////////////////////////
        // IME Keyboard Layout
        if (uGetBits & GETSET_REG_IMEKL) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szIMEKL, NULL, NULL, (LPBYTE)&dwBuf, &dwCb)
                == ERROR_SUCCESS) 
                {
                if (/*dwBuf >= KL_2BEOLSIK &&*/ dwBuf <= KL_3BEOLSIK_FINAL)
                    ImeData.SetCurrentBeolsik(dwBuf);
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Status window pos
        if (uGetBits & GETSET_REG_STATUSPOS) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szStatusPos, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS)
                {
                ImeData->ptStatusPos.x = HIWORD(dwBuf);
                ImeData->ptStatusPos.y = LOWORD(dwBuf);
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Status window button setting
        if (uGetBits & GETSET_REG_STATUS_BUTTONS) 
            {
            BYTE ButtonReg[MAX_NUM_OF_STATUS_BUTTONS+1];
            int        nButton;

            dwCb = sizeof(ButtonReg);
            dwType = REG_BINARY;
            if (RegQueryValueEx(hKey, g_szStatusButtons, NULL, &dwType, (LPBYTE)&ButtonReg, &dwCb) == ERROR_SUCCESS)
                {
                if (ButtonReg[0] == 0)
                    ButtonReg[0] = 1;
                    
                if (ButtonReg[0]<=MAX_NUM_OF_STATUS_BUTTONS) 
                    {
                    for (nButton=0; nButton<ButtonReg[0]; nButton++) 
                        {
                        // button data validity check
                    #if !defined(_M_IA64)
                        if (ButtonReg[nButton+1] <= IME_PAD_BUTTON && ButtonReg[nButton+1] != NULL_BUTTON)
                    #else
                        if (ButtonReg[nButton+1] <= HANJA_CONV_BUTTON && ButtonReg[nButton+1] != NULL_BUTTON)
                    #endif
                            ImeData->StatusButtons[nButton].m_ButtonType = (StatusButtonTypes)ButtonReg[nButton+1];
                        else
                            break;
                        }
                    ImeData->uNumOfButtons = nButton;
                    UpdateStatusButtons(ImeData);
                    UpdateStatusWinDimension();
                    }
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Deletion by Jaso
        if (uGetBits & GETSET_REG_JASODEL) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szCompDel, NULL, NULL, (LPBYTE)&dwBuf, &dwCb)
                    == ERROR_SUCCESS)
                ImeData.SetJasoDel(dwBuf);
            }


        if (uGetBits & GETSET_REG_ISO10646) 
            {
            Dbg(DBGID_Misc, "GetRegValues() : vpInstData->f16BitApps = %d", vpInstData->f16BitApps);

            // If 16bit apps, always disable ISO10646(full range Hangul)
            if (vpInstData->f16BitApps == fTrue)
                {
                vpInstData->fISO10646 = fFalse;
                }
            else
                {
                dwCb = sizeof(dwBuf);
                if (RegQueryValueEx(hKey, g_szXWEnable, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) 
                    == ERROR_SUCCESS)
                    vpInstData->fISO10646 = dwBuf;
                else
                    fSuccess = fFalse;

                // For Win95 and Win98 lookup INI file for ISO10646 setting.
                // ISO10646.EXE set registry
                if (!IsWinNT())
                    vpInstData->fISO10646 = GetProfileInt(g_szXWEnable, 
                                                    OurGetModuleFileName(fFalse), 
                                                    vpInstData->fISO10646);
                }
            }

        // Get KSC5657 K1 Hanja flag
        if (uGetBits & GETSET_REG_KSC5657) 
            {
            dwCb = sizeof(dwBuf);
            dwType = REG_DWORD;
            if (RegQueryValueEx(hKey, g_szEnableK1Hanja, NULL, &dwType, (LPBYTE)&dwBuf, &dwCb)    == ERROR_SUCCESS) 
                ImeData->fKSC5657Hanja = dwBuf;
            else
                ImeData->fKSC5657Hanja = fFalse;
            }

        // Get Unicode Tooltip Cand window flag
        // Currently this has no UI part which means hidden spec so no need SetReg now.
        if (uGetBits & GETSET_REG_CANDUNICODETT) 
            {
            dwCb = sizeof(dwBuf);
            dwType = REG_DWORD;
            if (RegQueryValueEx(hKey, g_szEnableCandUnicodeTT, NULL, &dwType, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS) 
                ImeData->fCandUnicodeTT = dwBuf;
            else
                ImeData->fCandUnicodeTT = fFalse;
            }

        RegCloseKey(hKey);
        }
    else
        {
        fSuccess = fFalse;
        // DbgBreak can happen when logon and cumbersome especially in stress machine running chk build.
        // DbgAssert(0);
        }

    return fSuccess;
}

BOOL SetRegValues(UINT uSetBits)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb;
    int        nButton;
    CIMEData    ImeData;

    ///////////////////////////////////////////////////////////////////////////
    // Set status pos
    if (RegCreateKey(HKEY_CURRENT_USER, g_szIMERootKey, &hKey) == ERROR_SUCCESS) 
        {
        if (uSetBits & GETSET_REG_STATUSPOS) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = (ImeData->ptStatusPos.x << 16) | (ImeData->ptStatusPos.y & 0xFFFF);  // HIWORD : X, LOWORD : Y
            RegSetValueEx(hKey, g_szStatusPos, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);

            }

        if (uSetBits & GETSET_REG_STATUS_BUTTONS) 
            {
            BYTE ButtonReg[MAX_NUM_OF_STATUS_BUTTONS+1];
            dwCb = sizeof(ButtonReg);

            DbgAssert(ImeData->uNumOfButtons <= MAX_NUM_OF_STATUS_BUTTONS);
            // set number of button as the first element of array
            if (ImeData->uNumOfButtons<=MAX_NUM_OF_STATUS_BUTTONS)
                ButtonReg[0] = (BYTE)ImeData->uNumOfButtons;

            for (nButton=0; nButton < (INT)ImeData->uNumOfButtons; nButton++) 
                ButtonReg[nButton+1] = ImeData->StatusButtons[nButton].m_ButtonType;
                
            // clear
            for (; nButton<MAX_NUM_OF_STATUS_BUTTONS; nButton++)
                ButtonReg[nButton+1] = NULL_BUTTON;

            RegSetValueEx(hKey, g_szStatusButtons, 0, REG_BINARY, (LPBYTE)&ButtonReg, dwCb);
            }


        if (uSetBits & GETSET_REG_IMEKL) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetCurrentBeolsik();
            RegSetValueEx(hKey, g_szIMEKL, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }
        
        if (uSetBits & GETSET_REG_JASODEL) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetJasoDel();
            RegSetValueEx(hKey, g_szCompDel, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }

        // Get KSC5657 K1 Hanja flag
        if (uSetBits & GETSET_REG_KSC5657) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetKSC5657Hanja();
            RegSetValueEx(hKey, g_szEnableK1Hanja, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }

        RegCloseKey(hKey);
        }
    else 
        return fFalse;
        
    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\dllmain.h ===
/****************************************************************************
	DLLMAIN.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	DLL Main entry function

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_DLLMAIN_H__INCLUDED_)
#define _DLLMAIN_H__INCLUDED_

extern BOOL vfDllDetachCalled;
void InitImeData();

#endif //!defined (_DLLMAIN_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\debug.cpp ===
/****************************************************************************
    DEBUG.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Debug functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#ifdef DEBUG

#include "PreComp.h"
#include "debug.h"
#include "common.h"

// ====-- SHARED SECTION START --====
#pragma data_seg(".DBGSHR")
DWORD vdwDebug = DBGID_OUTCOM;    // Default output to COM port
#pragma data_seg() 
// ====-- SHARED SECTION END --====

VOID InitDebug(VOID)
{
    HKEY        hKey;
    DWORD        size;
    BOOL        rc = fFalse;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, g_szIMERootKey, 0, KEY_READ, &hKey) !=  ERROR_SUCCESS) 
        {
        return;
        }
    size = sizeof(DWORD);
    if ( RegQueryValueEx( hKey, TEXT("DebugOption"), NULL, NULL, (LPBYTE)&vdwDebug, &size) ==  ERROR_SUCCESS) 
        {
        rc = fTrue;
        }

    RegCloseKey( hKey );

    return;
}

#endif  // _DEBUG

/*------------------------------------------------------------------------
    _purecall

    Stub for that super-annoying symbol the compiler generates for pure
    virtual functions
    Copied from MSO9 Dbgassert.cpp
---------------------------------------------------------------- RICKP -*/
int __cdecl _purecall(void)
{
#ifdef DEBUG
    DbgAssert(0);
    OutputDebugStringA("Called pure virtual function");
#endif
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\escape.h ===
/****************************************************************************
	ESCAPE.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	ImeEscape functions
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_ESCAPE__H__INCLUDED_)
#define _ESCAPE__H__INCLUDED_

// For User Interface
#define COMP_WINDOW     0
#define STATE_WINDOW    1
#define CAND_WINDOW     2

extern BOOL    vfWndOpen[3];

#pragma pack(push, MYIMESTRUCT)
#pragma pack(2)

#define GET_LPSOURCEW(lpks)  (LPWSTR)((LPBYTE)(lpks)+(lpks)->dchSource)
#define GET_LPDESTW(lpks)    (LPWSTR)((LPBYTE)(lpks)+(lpks)->dchDest)
#define GET_LPSOURCEA(lpks)  (LPSTR)((LPBYTE)(lpks)+(lpks)->dchSource)
#define GET_LPDESTA(lpks)    (LPSTR)((LPBYTE)(lpks)+(lpks)->dchDest)

typedef struct tagIMESTRUCT32
{
    WORD        fnc;                    // function code
    WORD        wParam;                 // word parameter
    WORD        wCount;                 // word counter
    WORD        dchSource;              // offset to Source from top of memory object
    WORD        dchDest;                // offset to Desrination from top of memory object
    DWORD       lParam1;
    DWORD       lParam2;
    DWORD       lParam3;
} IMESTRUCT32;

typedef IMESTRUCT32         *PIMESTRUCT32;
typedef IMESTRUCT32 NEAR    *NPIMESTRUCT32;
typedef IMESTRUCT32 FAR     *LPIMESTRUCT32;

#pragma pack(pop, MYIMESTRUCT)

extern INT EscHanjaMode(PCIMECtx pImeCtx, LPSTR lpIME32, BOOL fNewFunc);
extern INT EscGetOpen(PCIMECtx pImeCtx, LPIMESTRUCT32 lpIME32);
extern INT EscSetOpen(PCIMECtx pImeCtx, LPIMESTRUCT32 lpIME32);
extern INT EscAutomata(PCIMECtx pImeCtx, LPIMESTRUCT32 lpIME32, BOOL fNewFunc);
extern INT EscMoveIMEWindow(PCIMECtx pImeCtx, LPIMESTRUCT32 lpIME32);
extern INT EscGetIMEKeyLayout(PCIMECtx pImeCtx, LPIMESTRUCT32 lpIME32);

#endif // !defined (_ESCAPE__H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\escape.cpp ===
/****************************************************************************
    ESCAPE.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    ImeEscape functions
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "ui.h"
#include "debug.h"
#include "hanja.h"
#include "escape.h"
#include "apientry.h"

// IME_AUTOMATA subfunctions
#define IMEA_INIT               0x01
#define IMEA_NEXT               0x02
#define IMEA_PREV               0x03
// IME_MOVEIMEWINDOW
#define MCW_DEFAULT             0x00
#define MCW_WINDOW              0x02
#define MCW_SCREEN              0x04

BOOL    vfWndOpen[3] = { fTrue, fTrue, fTrue };
static WORD    wWndCmd[3] = { MCW_DEFAULT, MCW_DEFAULT, MCW_DEFAULT };

///////////////////////////////////////////////////////////////////////////////
// IME_ESC_HANJA_MODE processing routine called by ImeEscape
// Korean specific 
// It is for conversion from Hangul to Hanja the Input parameter (LPSTR)lpData
// is filled with Hangul charactert which will be converted to Hanja.
int EscHanjaMode(PCIMECtx pImeCtx, LPSTR lpIME32, BOOL fNewFunc)
{
    LPWSTR pwchSrc;
    LPSTR  pchSrc;
    WCHAR  wchSrc;
    INT    iRet = fFalse;

    // Update IMC values with lpIME32
    if (pImeCtx->IsUnicodeEnv())
        {
        pwchSrc = (fNewFunc) ? (LPWSTR)lpIME32 : GET_LPSOURCEW((LPIMESTRUCT32)lpIME32);
        if (pwchSrc == NULL || *pwchSrc == L'\0')
            {
            DbgAssert(0);
            return 0;
            }
        wchSrc = *pwchSrc;
        }
    else
        {
        pchSrc = (fNewFunc) ? (LPSTR)lpIME32 : GET_LPSOURCEA((LPIMESTRUCT32)lpIME32);
        if (pchSrc == NULL || *pchSrc == '\0')
            {
            DbgAssert(0);
            return 0;
            }

        if (MultiByteToWideChar(CP_KOREA, MB_PRECOMPOSED, pchSrc, 2, &wchSrc, 1) == 0)
            {
            return 0;
            }
        }

    Dbg(DBGID_Hanja, TEXT("EscHanjaMode = %04X"), wchSrc);
    if (GenerateHanjaCandList(pImeCtx, wchSrc))
        {
        // Set current comp str
        if (pImeCtx->IsUnicodeEnv())
            pImeCtx->SetCompBufStr(wchSrc);
        else
            pImeCtx->SetCompBufStr(*pchSrc, *(pchSrc+1));

           // Change to Hanja conv mode
        iRet = OurImmSetConversionStatus(pImeCtx->GetHIMC(), pImeCtx->GetConversionMode() | IME_CMODE_HANJACONVERT,
                pImeCtx->GetSentenceMode());
        }
    else  // if failed to convert
        {
        MessageBeep(MB_ICONEXCLAMATION);
        }

    Dbg(DBGID_Hanja, TEXT("EscHanjaMode return = %d"), iRet);
    return (iRet);
}


INT EscGetOpen(PCIMECtx pIMECtx, LPIMESTRUCT32 lpIME32)
{
    LPIMEDATA   lpImeData = pIMECtx->GetGDataRaw();
    INT         iRet = fTrue;

    if (lpIME32->dchSource > CAND_WINDOW)
        iRet = fFalse;
    else
        {
        iRet = vfWndOpen[lpIME32->dchSource] | 0x80000000UL;
        lpIME32->wCount = wWndCmd[lpIME32->dchSource];

        switch (lpIME32->wCount)
            {
        case MCW_DEFAULT:
            switch (lpIME32->dchSource) 
                {
            case COMP_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->ptStatusPos.y,
                                        (lpImeData->ptStatusPos.x+lpImeData->xStatusWi+UI_GAPX + COMP_SIZEX > lpImeData->rcWorkArea.right) ?
                                        lpImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : lpImeData->ptStatusPos.x + lpImeData->xStatusWi + UI_GAPX);
                break;
            case STATE_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->rcWorkArea.bottom - lpImeData->yStatusHi,
                                    lpImeData->rcWorkArea.right - lpImeData->xStatusWi);
                break;
            case CAND_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->rcWorkArea.bottom - lpImeData->yCandHi,
                                    lpImeData->rcWorkArea.right - lpImeData->xCandWi);

                break;

                }
            break;

        case MCW_SCREEN:
            switch (lpIME32->dchSource)
                {
            case COMP_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->ptCompPos.y, lpImeData->ptCompPos.x);
                break;

            case STATE_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->ptStatusPos.y, lpImeData->ptStatusPos.x);
                break;

            case CAND_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->rcWorkArea.bottom - lpImeData->yCandHi,
                                            lpImeData->rcWorkArea.right  - lpImeData->xCandWi);
                break;
                }
            break;

        case MCW_WINDOW:
            switch (lpIME32->dchSource)
                {
            case COMP_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->ptCompPos.y, lpImeData->ptCompPos.x);
                break;

            case STATE_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->ptStatusPos.y, lpImeData->ptStatusPos.x);
                break;

            case CAND_WINDOW:
                lpIME32->lParam1 = MAKELONG(lpImeData->rcWorkArea.bottom - lpImeData->yCandHi,
                                            lpImeData->rcWorkArea.right  - lpImeData->xCandWi);
                break;
                }
            lpIME32->lParam1 -= lpIME32->lParam2;
            break;

        default:
            iRet = fFalse;
            }
        }
    return (iRet);
}

INT EscSetOpen(PCIMECtx pIMECtx, LPIMESTRUCT32 lpIME32)
{
    BOOL    fTmp;
    HWND    hDefIMEWnd;
    INT        iRet = fTrue;

    if (lpIME32->dchSource > CAND_WINDOW)
        iRet = fFalse;
    else
        {
        fTmp = vfWndOpen[lpIME32->dchSource];
        vfWndOpen[lpIME32->dchSource] = lpIME32->wParam;
        iRet = fTmp | 0x80000000UL;
        if (lpIME32->dchSource == STATE_WINDOW)
            {
            hDefIMEWnd = OurImmGetDefaultIMEWnd(pIMECtx->GetAppWnd());
            if (hDefIMEWnd)
                OurSendMessage(hDefIMEWnd, WM_IME_NOTIFY,
                        (lpIME32->wParam)? IMN_OPENSTATUSWINDOW: IMN_CLOSESTATUSWINDOW, 0L);
            }
        }
        
    return (iRet);
}

INT EscMoveIMEWindow(PCIMECtx pIMECtx, LPIMESTRUCT32 lpIME32)
{
    LPIMEDATA pImeData = pIMECtx->GetGDataRaw();
    INT       iRet        = fTrue;


    if (lpIME32->dchSource > CAND_WINDOW)
        iRet = fFalse;
    else
        {
        switch (wWndCmd[lpIME32->dchSource] = lpIME32->wParam)
           {
        case MCW_DEFAULT:
            switch (lpIME32->dchSource)
                {
            case COMP_WINDOW:
                pImeData->ptCompPos.x = (pImeData->ptStatusPos.x+pImeData->xStatusWi+UI_GAPX + COMP_SIZEX > pImeData->rcWorkArea.right) ?
                                        pImeData->ptStatusPos.x - UI_GAPX - COMP_SIZEX : pImeData->ptStatusPos.x + pImeData->xStatusWi + UI_GAPX;
                pImeData->ptCompPos.y = pImeData->ptStatusPos.y;
                break;

            case STATE_WINDOW:
                pImeData->ptStatusPos.x = pImeData->rcWorkArea.right - pImeData->xStatusWi;
                pImeData->ptStatusPos.y = pImeData->rcWorkArea.bottom - pImeData->yStatusHi;
                break;

            case CAND_WINDOW:
                //pImeData->ptCandPos.x = pImeData->rcWorkArea.right - pImeData->xCandWi;
                //pImeData->ptCandPos.y = pImeData->rcWorkArea.bottom - pImeData->yCandHi;
                break;
                }
            break;

        case MCW_WINDOW:
        case MCW_SCREEN:
            switch (lpIME32->dchSource)
                {
            case COMP_WINDOW:
                pImeData->ptCompPos.x = LOWORD(lpIME32->lParam1);
                pImeData->ptCompPos.y = HIWORD(lpIME32->lParam1);
                break;

            case STATE_WINDOW:
                pImeData->ptStatusPos.x = LOWORD(lpIME32->lParam1);
                pImeData->ptStatusPos.y = HIWORD(lpIME32->lParam1);
                break;

            case CAND_WINDOW:
                //pImeData->ptCandPos.x = LOWORD(lpIME32->lParam1);
                //pImeData->ptCandPos.y = HIWORD(lpIME32->lParam1);
                break;
                }
            break;

        default:
            iRet = fFalse;
            }
        }
    return (iRet);
}


INT EscAutomata(PCIMECtx pIMECtx, LPIMESTRUCT32 lpIME32, BOOL fNewFunc)
{
//    LPCOMPOSITIONSTRING lpCompStr;
    INT        iRet = fFalse;
    WCHAR    wcCur;

    Dbg(DBGID_Automata, TEXT("EscAutomata: fNewFunc=%d, lpIME32->wParam=%04X, lpIME32->lParam1=0x%08X, lpIME32->lParam2=0x%08X, lpIME32->lParam3=0x%08X"), fNewFunc, lpIME32->wParam, lpIME32->lParam1, lpIME32->lParam2, lpIME32->lParam3 );

    if (fNewFunc)
        {
        iRet = ImeProcessKey(pIMECtx->GetHIMC(), lpIME32->wParam,
                             lpIME32->lParam1, (LPBYTE)lpIME32 + (INT_PTR)lpIME32->dchSource);
        if (iRet)
            {
            lpIME32->wCount = (WORD)ImeToAsciiEx(lpIME32->wParam,
                    HIWORD(lpIME32->lParam1), (LPBYTE)lpIME32 + lpIME32->dchSource,
                    (LPTRANSMSGLIST)((LPBYTE)lpIME32 + (INT_PTR)lpIME32->dchDest), 0, pIMECtx->GetHIMC());
            }
        else 
            if (lpIME32->wParam != VK_MENU)
            {
                LPTRANSMSGLIST    lpTransBuf;
                LPTRANSMSG        lpTransMsg;

                lpIME32->wCount = 1;
                lpTransBuf = (LPTRANSMSGLIST)((LPBYTE)lpIME32 + (INT_PTR)lpIME32->dchDest);
                lpTransMsg = lpTransBuf->TransMsg;
                SetTransBuffer(lpTransMsg, (HIWORD(lpIME32->lParam1) & 0x8000)? WM_IME_KEYUP: WM_IME_KEYDOWN, lpIME32->wParam, lpIME32->lParam1);
                lpTransMsg++;
                
                iRet = fTrue;
            }
        }
    else
        {
        CHangulAutomata *pAutoMata = pIMECtx->GetAutomata();
        DbgAssert(pAutoMata != NULL);

            // It's only for HWin31 IME app compatibility layer
        switch (lpIME32->wParam)
            {
        //lpIME32->dchSource = bState;
        case IMEA_INIT:
            pIMECtx->ClearCompositionStrBuffer();
            break;

        case IMEA_NEXT:
            //HangeulAutomata(
            //        Atm_table[uCurrentInputMethod - IDD_2BEOL][lpIME32->dchSource - 0x20],
            //        NULL, lpCompStr);
            DbgAssert(0);
            break;

        case IMEA_PREV:
            //HangeulAutomata(0x80, NULL, lpCompStr); // 0x80 is for VK_BACK
            pAutoMata->BackSpace();
            wcCur = pAutoMata->GetCompositionChar();

            if (pIMECtx->GetGData()->GetJasoDel() == fFalse) 
                {
                pAutoMata->InitState();
                wcCur = 0;
                }

            if (wcCur)
                {
                pIMECtx->SetCompositionStr(wcCur);
                pIMECtx->StoreComposition();
                }
            else
                pIMECtx->ClearCompositionStrBuffer();
            break;
        }
        iRet = fTrue;
    }

    return (iRet);
}

int EscGetIMEKeyLayout(PCIMECtx pIMECtx, LPIMESTRUCT32 lpIME32)
{
    lpIME32->lParam1 = (LONG)(pIMECtx->GetGData()->GetCurrentBeolsik());
    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\dllmain.cpp ===
/****************************************************************************
    DLLMAIN.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    DLL Main entry function

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "dllmain.h"
#include "ui.h"
#include "hauto.h"
#include "config.h"
#include "winex.h"
#include "hanja.h"
#include "cpadsvr.h"
#include "cimecb.h"
#include "cicero.h"
#include "debug.h"


#if 1 // MultiMonitor support
LPFNMONITORFROMWINDOW g_pfnMonitorFromWindow = NULL;
LPFNMONITORFROMPOINT  g_pfnMonitorFromPoint  = NULL;
LPFNMONITORFROMRECT   g_pfnMonitorFromRect   = NULL;
LPFNGETMONITORINFO    g_pfnGetMonitorInfo    = NULL;
#endif

extern "C" BOOL WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);

///////////////////////////////////////////////////////////////////////////////
PRIVATE BOOL APIInitialize();
PRIVATE BOOL LoadMMonitorService();
//PRIVATE BOOL DetachIme();

BOOL vfDllDetachCalled = fFalse;
///////////////////////////////////////////////////////////////////////////////
// D L L M A I N
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason)
        {
        case DLL_PROCESS_ATTACH:
        // init Debugger module
        #ifdef _DEBUG
        InitDebug();
            {
            TCHAR sz[128];
            GetModuleFileName( NULL, sz, 127 );
            DebugOutT(TEXT("IMEKR61.IME - DLL_PROCESS_ATTACH - "));
            DebugOutT(sz);
            DebugOutT(TEXT("\r\n"));
            }

        _CRT_INIT(hinstDLL, dwReason, pvReserved);
            
        #endif

            ///////////////////////////////////////////////////////////////////
            // Initialize per process data
            vpInstData = &vInstData;
            vpInstData->hInst = hinstDLL;
            vpInstData->dwSystemInfoFlags = 0;

            ///////////////////////////////////////////////////////////////////
            // Default value of fISO10646
            // Default enable 11,172 Hangul.
            // CONFIRM: How to set default of this value for Win95???
            vpInstData->fISO10646 = fTrue;
            vpInstData->f16BitApps = fFalse;
            
            // Load IMM32
            StartIMM();

            // Initialize Shared memory
            CIMEData::InitSharedData();

            // Initialize proc
            APIInitialize();

            // Initialize UI
            RegisterImeUIClass(vpInstData->hInst);
            // init common control
            InitCommonControls();

            // Init UI TLS
            OnUIProcessAttach();

            // Init IME Pad
            CImePadSvr::OnProcessAttach((HINSTANCE)hinstDLL);

            break;

        case DLL_PROCESS_DETACH:
            vfDllDetachCalled = fTrue;
            // IImeCallBack
            CImeCallback::Destroy();

            // IME Pad
            CImePadSvr::OnProcessDetach();

            // UnInit UI TLS
            OnUIProcessDetach();

            // UI uninitialization
            UnregisterImeUIClass(vpInstData->hInst);

            // Close lex file if has opened ever.
            CloseLex();

            // Close shared memory
            CIMEData::CloseSharedMemory();

            // Unload IMM32
            EndIMM();
        
        #ifdef _DEBUG
                {
                TCHAR sz[128];
                GetModuleFileName(NULL, sz, 127);
                DebugOutT(TEXT("IMEKR.IME - DLL_PROCESS_DETACH - "));
                DebugOutT( sz );
                DebugOutT(TEXT("\r\nBye! See you again! *-<\r\nModule name: "));
                DebugOutT(sz);
                }

            // Comment out _CRT_INIT call due to AV in KERNEL32.DLL on Win9x.
             //_CRT_INIT(hinstDLL, dwReason, pvReserved);

        #endif // _DEBUG
            break;

        case DLL_THREAD_ATTACH:
        #ifdef _DEBUG
            DebugOutT(TEXT("DllMain() : DLL_THREAD_ATTACH"));
        #endif
            CImePadSvr::OnThreadAttach();
            break;

        case DLL_THREAD_DETACH:
        #ifdef _DEBUG
            DebugOutT(TEXT("DllMain() : DLL_THREAD_DETACH"));
        #endif
            CImePadSvr::OnThreadDetach();
            OnUIThreadDetach();
            break;
        }
    return fTrue;
}

/*----------------------------------------------------------------------------
    APIInitialize

    Init UI and detect 16 bit apps
----------------------------------------------------------------------------*/
PRIVATE BOOL APIInitialize()
{
    DWORD dwType = 1;    

#ifdef DEBUG
        DebugOutT(TEXT("APIInitialize()\r\n"));
#endif

    // System support Unicode? Win98 and NT support Unicode IME
    vfUnicode = IsUnicodeUI();

    // Register private window messages
    InitPrivateUIMsg();
    
    // Load MultiMonitor procs
    LoadMMonitorService();

   return fTrue;
}


///////////////////////////////////////////////////////////////////////////////
BOOL LoadMMonitorService()
{
#if 1 // MultiMonitor support
    HMODULE hUser32;
#endif

#ifdef DEBUG
    OutputDebugString(TEXT("LoadMMonitorService: \r\n"));
#endif

#if 1 // MultiMonitor support
    //////////////////////////////////////////////////////////////////////////
    // Load Multimonitor functions
    //////////////////////////////////////////////////////////////////////////
    if ((hUser32 = GetModuleHandle(TEXT("USER32"))) &&
        (*(FARPROC*)&g_pfnMonitorFromWindow   = GetProcAddress(hUser32,"MonitorFromWindow")) &&
        (*(FARPROC*)&g_pfnMonitorFromRect     = GetProcAddress(hUser32,"MonitorFromRect")) &&
        (*(FARPROC*)&g_pfnMonitorFromPoint    = GetProcAddress(hUser32,"MonitorFromPoint")) &&
        (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoA")))
        {
        return fTrue;
        }
    else
        {
        g_pfnMonitorFromWindow    = NULL;
        g_pfnMonitorFromRect      = NULL;
        g_pfnMonitorFromPoint     = NULL;
        g_pfnGetMonitorInfo          = NULL;
        return fFalse;
        }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\fmode.cpp ===
/****************************************************************************
   FMODE.CPP : FMode class implementation which manage Full/Half shape mode 
                   button on the Cicero Toolbar

   History:
      23-FEB-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "fmode.h"
#include "gdata.h"
#include "ui.h"
#include "winex.h"
#include "resource.h"

// {D770009D-DC5C-4d2d-8DA1-8B1211E5B69C}
const GUID GUID_LBI_KORIME_FMODE = 
{
    0xd770009d,
    0xdc5c,
    0x4d2d,
    { 0x8d, 0xa1, 0x8b, 0x12, 0x11, 0xe5, 0xb6, 0x9c }
};

/*---------------------------------------------------------------------------
    FMode::FMode
---------------------------------------------------------------------------*/
FMode::FMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    szText[0] = L'\0';
    
    m_pTb = ptb;

    // Set Add/Remove text and tootip text
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_TT_JUN_BAN, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_SYSTEMLANGBARITEM_KEYBOARD, 
                GUID_LBI_KORIME_FMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_HIDDENBYDEFAULT | TF_LBI_STYLE_TEXTCOLORICON, 
                210, 
                szText);
    SetToolTip(szText);

    // Set button text
    szText[0] = L'\0';
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_BUTTON_JUN_BAN, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}

/*---------------------------------------------------------------------------
    CMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) FMode::Release()
{
    long cr;

    cr = --m_cRef;
    DbgAssert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    FMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI FMode::GetIcon(HICON *phIcon)
{
    DWORD dwCM = GetCMode();
    UINT uiIcon = 0;
    static const UINT uidIcons[2][2] = 
    {
        { IDI_CMODE_BANJA, IDI_CMODE_BANJAW },
        { IDI_CMODE_JUNJA,  IDI_CMODE_JUNJAW }
    };

    if (m_pTb->IsOn() && (m_pTb->GetConversionMode() & IME_CMODE_FULLSHAPE))
        uiIcon = 1;

    if (IsHighContrastBlack())
        uiIcon = uidIcons[uiIcon][1];
    else
        uiIcon = uidIcons[uiIcon][0];

    *phIcon = (HICON)LoadImage(vpInstData->hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    FMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI FMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    FMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI FMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT FMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
#if 0
    DWORD dwConvMode;

    dwConvMode = GetCMode();

    // Toggle Full/Half mode
    if (dwConvMode & TIP_JUNJA_MODE)
        dwConvMode &= ~TIP_JUNJA_MODE;
    else
        dwConvMode |= TIP_JUNJA_MODE;

    SetCMode(dwConvMode);
#endif

    keybd_event(VK_JUNJA, 0, 0, 0);
    keybd_event(VK_JUNJA, 0, KEYEVENTF_KEYUP, 0);

    return S_OK;
}

#if 0
//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT FMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    HMENU    hMenu;
    DWORD    dwConvMode;
    PCIMECtx pImeCtx;
    CHAR       szText[256];
    UINT     uiId;    
    int      nRet;
    
    hMenu      = CreatePopupMenu();
    dwConvMode = GetCMode();

    if (dwConvMode & IME_CMODE_FULLSHAPE)
        uiId = IDS_CIC_BANJA_MODE;
    else
        uiId = IDS_CIC_JUNJA_MODE;

    // Add Banja/Junja mode menu
    OurLoadStringA(vpInstData->hInst, uiId, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, szText);

    // Add Cancel menu
    OurLoadStringA(vpInstData->hInst, IDS_CIC_CANCEL, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 0, szText);

    nRet = TrackPopupMenuEx(hMenu, 
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, GetActiveUIWnd(), NULL);
    switch (nRet)
        {
    case 1: 
        dwConvMode = GetCMode();

        // Toggle Full/Half mode
        if (dwConvMode & IME_CMODE_FULLSHAPE)
            dwConvMode &= ~IME_CMODE_FULLSHAPE;
        else
            dwConvMode |= IME_CMODE_FULLSHAPE;

        pImeCtx = m_pTb->GetImeCtx();
        if (pImeCtx)
            OurImmSetConversionStatus(pImeCtx->GetHIMC(), 
                                      dwConvMode, pImeCtx->GetSentenceMode());
        break;
        }

    DestroyMenu(hMenu);

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\fmode.h ===
//
// FMODE.H
//

#if !defined (__FMODE_H__INCLUDED_)
#define __FMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class FMode : public CCicButton
{
public:
    FMode(CToolBar *ptb);
    ~FMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
//    HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:
	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __FMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\gdata.h ===
/****************************************************************************
	GDATA.J

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Instance data and Shared memory data management functions

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_GDATA_H__INCLUDED_)
#define _GDATA_H__INCLUDED_

#include "ui.h"

class CIMEData;

PUBLIC BOOL InitSharedData();
VOID InitImeData(CIMEData& ImeData);
PUBLIC BOOL CloseSharedMemory();

#define IMEDATA_MAGIC_NUMBER 		0x12345678	// This will repesent whether IMEDATA initialized or not


// Type of IME Hangul keyboard layout
enum _KeyBoardType 
{ 
	KL_2BEOLSIK = 0, KL_3BEOLSIK_390, KL_3BEOLSIK_FINAL 
};

#define NUM_OF_IME_KL			3

///////////////////////////////////////////////////////////////////////////////
// Global data  S H A R E D  to all IME instance
struct IMEDATA 
    {
    ULONG		ulMagic;

	// Workarea
	RECT		rcWorkArea;
	
	// Configuration of the IME
	UINT		uiCurrentKeylayout;
	BOOL		fJasoDel;		// Backspace : delete per jaso or char
								// which means All ISO-10646 hangul.
	BOOL		fKSC5657Hanja;	// K1(KSC-5657) Hanja enable
	BOOL		fCandUnicodeTT;

	// Status window
	UINT		uNumOfButtons;
	//_StatusButtonTypes	ButtonTypes[MAX_NUM_OF_STATUS_BUTTONS];
	INT			iCurButtonSize;

    INT         xStatusWi;      // width of status window
    INT         yStatusHi;      // high of status window

	LONG		xStatusRel, yStatusRel;

	INT			xButtonWi;
	INT			yButtonHi;
	INT			cxStatLeftMargin, cxStatRightMargin,
				cyStatMargin, cyStatButton;
	RECT		rcButtonArea;
	POINT       ptStatusPos;

	// Candidate window
    INT         xCandWi;
    INT         yCandHi;

	// Comp window pos
	POINT       ptCompPos;

	// This should be last - ia64 alignment issue
	StatusButton StatusButtons[MAX_NUM_OF_STATUS_BUTTONS];
};

typedef IMEDATA	*LPIMEDATA;

//////////////////////////////////////////////////////////////////////////////
// I N S T A N C E  D A T A
// Per Process Data
struct INSTDATA 
    {
	HINSTANCE		hInst;		// IME DLL instance handle
	DWORD			dwSystemInfoFlags;
	BOOL			fISO10646;	// XWansung area hangul enabled, 
	BOOL			f16BitApps;
    };
typedef INSTDATA	*LPINSTDATA;

// Global variables
PUBLIC BOOL 		vfUnicode;
PUBLIC INSTDATA		vInstData;
PUBLIC LPINSTDATA	vpInstData;

/////////////////////////////////////////////////////////////////////////////
// Class CIMEData
//
// Purpose : Shared memory handling across process boundary.
//           This use MapViewOfFile() to mapping local process memory and Unlock 
//           automatically when reference count become zero
// Note    : Currently Read only flag behaves same as R/W flag.
class CIMEData
    {
    public:
        enum LockType { SMReadOnly, SMReadWrite };
       
        CIMEData(LockType lockType=SMReadWrite);
        ~CIMEData() { UnlockSharedMemory(); }

        static BOOL InitSharedData();
        static BOOL CloseSharedMemory();

		void InitImeData();

        LPIMEDATA LockROSharedData();
        LPIMEDATA LockRWSharedData();
        BOOL UnlockSharedMemory();
        LPIMEDATA operator->() { DbgAssert(m_pImedata != 0);  return m_pImedata; }
        LPIMEDATA GetGDataRaw() { DbgAssert(m_pImedata != 0); return m_pImedata; }
        UINT GetCurrentBeolsik() { return (m_pImedata ? m_pImedata->uiCurrentKeylayout : 0); }
		VOID SetCurrentBeolsik(UINT icurBeolsik);		
		BOOL GetJasoDel() { return (m_pImedata ? m_pImedata->fJasoDel : 1); }
		VOID SetJasoDel(BOOL fJasoDel) { m_pImedata->fJasoDel = fJasoDel; }
		BOOL GetKSC5657Hanja() { return (m_pImedata ? m_pImedata->fKSC5657Hanja : 0); }
		VOID SetKSC5657Hanja(BOOL f5657) { m_pImedata->fKSC5657Hanja = f5657; }

		
    private:
        LPIMEDATA m_pImedata;
        PRIVATE HANDLE m_vhSharedData;
    };

inline
CIMEData::CIMEData(LockType lockType)
    {
    DbgAssert(m_vhSharedData != 0);
    Dbg(DBGID_IMEDATA, TEXT("CIMEData(): Const"));
    m_pImedata = 0;
    LockRWSharedData();
    }

inline
LPIMEDATA CIMEData::LockROSharedData()
    {
    DbgAssert(m_vhSharedData != 0);
    Dbg(DBGID_IMEDATA, TEXT("CIMEData::LockROSharedData()"));

    if (m_vhSharedData)
	    m_pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ, 0, 0, 0);
    DbgAssert(m_pImedata != 0);
    return m_pImedata;
    }

inline    
LPIMEDATA CIMEData::LockRWSharedData()
    {
    DbgAssert(m_vhSharedData != 0);
    Dbg(DBGID_IMEDATA, TEXT("CIMEData::LockRWSharedData()"));
    
    if (m_vhSharedData)
    	{
		Dbg(DBGID_IMEDATA, TEXT("CIMEData::LockRWSharedData(): m_vhSharedData is null call MapViewOfFile"));
	    m_pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
	    }
    DbgAssert(m_pImedata != 0);
	return m_pImedata;
    }

// For unlocking shared memory
inline
BOOL CIMEData::UnlockSharedMemory()
    {
    Dbg(DBGID_IMEDATA, TEXT("CIMEData::UnlockSharedMemory(): Lock count zero UnmapViewOfFile"));
    UnmapViewOfFile(m_pImedata);
    m_pImedata = 0;
    return fTrue;
    }

inline
VOID CIMEData::SetCurrentBeolsik(UINT uicurBeolsik) 
{ 
	DbgAssert(/*uicurBeolsik>=KL_2BEOLSIK &&*/ uicurBeolsik<=KL_3BEOLSIK_FINAL);

	m_pImedata->uiCurrentKeylayout = uicurBeolsik; 
}

#endif // _GDATA_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\guids.cpp ===
#define INITGUID

#include "imepad_.h"
#include "ipoint1.h"
#include "iimecb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\hanja.h ===
/****************************************************************************
	HANJA.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Hanja conversion and dictionary lookup functions. Dictionary index is 
	stored as globally shared memory.
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_HANJA_H__INCLUDED_)
#define _HANJA_H__INCLUDED_

#include "LexHeader.h"

#define CAND_PAGE_SIZE 			9

#define MAX_CANDSTR				128	// !!! max num of candidate !!! 
									// currently '' has total 103 candidate str

PUBLIC UINT vuNumofK0, vuNumofK1;
PUBLIC WCHAR  vwcHangul;

PUBLIC BOOL EnsureHanjaLexLoaded();
PUBLIC BOOL CloseLex();
PUBLIC BOOL GenerateHanjaCandList(PCIMECtx pImeCtx, WCHAR wcHangul = 0);
PUBLIC DWORD GetConversionList(WCHAR wcReading, LPCANDIDATELIST lpCandList, DWORD dwBufLen);

__inline UINT GetNumOfK0() { return vuNumofK0; }
__inline UINT GetNumOfK1() { return vuNumofK1; }
//inline LPWSTR GetHanjaMeaning(int i) { return vprwszHanjaMeaning[i]; }
__inline WCHAR  GetCurrentHangulOfHanja() { return vwcHangul; }

#endif // !defined (_HANJA_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\hanja.cpp ===
/****************************************************************************
    HANJA.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Hanja conversion and dictionary lookup functions. Dictionary index is 
    stored as globally shared memory.
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "apientry.h"
#include "ui.h"
#include "debug.h"
#include "lexheader.h"
#include "hanja.h"
#include "immsec.h"
#include "winex.h"
#include "common.h"
#include <WINERROR.H>

// NT5 Globally shared memory. 
// If NT5 or upper append "Global\" to object name to make it global to all session.
// We don't need to consider NT4 Terminal Server since we don't have Kor TS NT4
const TCHAR IMEKR_LEX_SHAREDDATA_MUTEX_NAME[]          = TEXT("ImeKrLex.Mutex");
const TCHAR IMEKR_LEX_SHAREDDATA_MUTEX_NAME_GLOBAL[] = TEXT("Global\\ImeKrLex.Mutex");
const TCHAR IMEKR_LEX_SHAREDDATA_NAME[]              = TEXT("ImeKrLexHangul2Hanja.SharedMemory");
const TCHAR IMEKR_LEX_SHAREDDATA_NAME_GLOBAL[]          = TEXT("Global\\ImeKrLexHangul2Hanja.SharedMemory");


UINT   vuNumofK0=0, vuNumofK1=0;
WCHAR  vwcHangul=0;

// Private data
PRIVATE BOOL    vfLexOpen = fFalse;
PRIVATE HANDLE vhLex=0;
PRIVATE HANDLE vhLexIndexTbl=0;
PRIVATE UINT    vuNumOfHangulEntry=0;
PRIVATE DWORD viBufferStart=0;    // seek point

// Private functions
PRIVATE BOOL OpenLex();
//static VOID ClearHanjaSenseArray();
PRIVATE INT SearchHanjaIndex(WCHAR wHChar, _LexIndex *pLexIndexTbl);

/*
CHanja::CHanja()
    {
    vfLexOpen = fFalse;
    vhLex = vhLexIndexTbl = vhLexIndexTbl = NULL;
    vuNumOfHangulEntry = 0;

    for (int i=0; i<MAX_CANDSTR; i++) 
        vprwszHanjaMeaning[i] = 0;
    }
*/

BOOL EnsureHanjaLexLoaded()
{
    _DictHeader *pLexHeader;
    DWORD         dwReadBytes;
    CHAR         szLexFileName[MAX_PATH], szLexPathExpanded[MAX_PATH];
    HKEY        hKey;
    DWORD        dwType, dwCb;
    CIMEData    ImeData;

    if (vfLexOpen)
        return fTrue;

    // Get Lex file name with full path
    szLexFileName[0] = 0;
    szLexPathExpanded[0] = 0;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szIMERootKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        dwCb = sizeof(szLexFileName);
        dwType = REG_SZ;

        if (RegQueryValueEx(hKey, g_szDictionary, NULL, &dwType, (LPBYTE)szLexFileName, &dwCb) == ERROR_SUCCESS)
            ExpandEnvironmentStrings(szLexFileName, szLexPathExpanded, sizeof(szLexPathExpanded));
        RegCloseKey(hKey);
        }

    DbgAssert(szLexPathExpanded[0] != 0);
    if (szLexPathExpanded[0] == 0)
        return fFalse;

    vhLex = CreateFile(szLexPathExpanded, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
    if (vhLex==INVALID_HANDLE_VALUE) 
        {
        DbgAssert(0);
        return fFalse;
        }

    pLexHeader = new _DictHeader;
    if (!pLexHeader)
        return fFalse;

    if (ReadFile(vhLex, pLexHeader, sizeof(_DictHeader), &dwReadBytes, 0) == 0 || (dwReadBytes != sizeof(_DictHeader)))
        {
        DbgAssert(0);
        return fFalse;
        }

    // Set member vars
    vuNumOfHangulEntry = pLexHeader->NumOfHangulEntry;
    viBufferStart = pLexHeader->iBufferStart;

    if (pLexHeader->Version < LEX_VERSION || pLexHeader->Version > LEX_COMPATIBLE_VERSION_LIMIT ) 
        {
        delete pLexHeader;
        return fFalse;
        }
        
    if (lstrcmpA(pLexHeader->COPYRIGHT_HEADER, COPYRIGHT_STR)) 
        {
        delete pLexHeader;
        return fFalse;
        }

    // Read Index table
    SetFilePointer(vhLex, pLexHeader->Headersize, 0, FILE_BEGIN);    
    delete pLexHeader;

    return OpenLex();
}

BOOL OpenLex()
{
    BOOL          fRet = fFalse;
    _LexIndex     *pLexIndexTbl;
    HANDLE         hMutex;
    DWORD         dwReadBytes;
    
    ///////////////////////////////////////////////////////////////////////////
    // Mapping Lex file
    // The dictionary index is shared data between all IME instance
    if (IsWinNT5orUpper())
        hMutex=CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_LEX_SHAREDDATA_MUTEX_NAME_GLOBAL);
    else
        hMutex=CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_LEX_SHAREDDATA_MUTEX_NAME);

    if (hMutex != NULL)
        {
        if (DoEnterCriticalSection(hMutex) == fFalse)
            goto ExitOpenLexCritSection;

        if (IsWinNT5orUpper())
            vhLexIndexTbl = OpenFileMapping(FILE_MAP_READ, fTrue, IMEKR_LEX_SHAREDDATA_NAME_GLOBAL);
        else
            vhLexIndexTbl = OpenFileMapping(FILE_MAP_READ, fTrue, IMEKR_LEX_SHAREDDATA_NAME);

        if(vhLexIndexTbl)
            {
            Dbg(DBGID_Hanja|DBGID_Mem, TEXT("CHanja::OpenLex() - File mapping already exists"));
            fRet = fTrue;
            }
        else
            {
            // if no file mapping exist
            if (IsWinNT5orUpper())
                vhLexIndexTbl    = CreateFileMapping(INVALID_HANDLE_VALUE, GetIMESecurityAttributes(), PAGE_READWRITE, 
                                    0, sizeof(_LexIndex)*(vuNumOfHangulEntry),
                                    IMEKR_LEX_SHAREDDATA_NAME_GLOBAL);
            else
                vhLexIndexTbl    = CreateFileMapping(INVALID_HANDLE_VALUE, GetIMESecurityAttributes(), PAGE_READWRITE, 
                                    0, sizeof(_LexIndex)*(vuNumOfHangulEntry),
                                    IMEKR_LEX_SHAREDDATA_NAME);

            if (vhLexIndexTbl) 
                {
                Dbg(DBGID_Hanja|DBGID_Mem, TEXT("CHanja::OpenLex() - File mapping Created"));
                pLexIndexTbl = (_LexIndex*)MapViewOfFile(vhLexIndexTbl, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
                if (!pLexIndexTbl)
                    goto ExitOpenLexCritSection;

                if (ReadFile(vhLex, pLexIndexTbl, vuNumOfHangulEntry*sizeof(_LexIndex), &dwReadBytes, 0) == 0 
                    || dwReadBytes == vuNumOfHangulEntry*sizeof(_LexIndex))
                    fRet = fTrue;
                else
                    fRet = fFalse;
                
                UnmapViewOfFile(pLexIndexTbl);
                }
        #ifdef _DEBUG
            else
                DbgAssert(0);
        #endif
            }
            
    ExitOpenLexCritSection:
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
        }
    
    FreeIMESecurityAttributes();

    vfLexOpen = fRet;
    return fRet;
}

BOOL CloseLex()
{
    //ClearHanjaSenseArray();
    
    if (vhLexIndexTbl) 
        {
        CloseHandle(vhLexIndexTbl);
        vhLexIndexTbl = 0;
        }

    if (vhLex) 
        {
        CloseHandle(vhLex);
        vhLex = 0;
        }

    vfLexOpen =  fFalse;
    return fTrue;
}

///////////////////////////////////////////////////////////////////////////////
BOOL GenerateHanjaCandList(PCIMECtx pImeCtx, WCHAR wcHangul)
{
    WCHAR       wcCandChar;
    INT         iMapCandStr;
    UINT        uNumOfCandStr;
    _LexIndex    *pLexIndexTbl;
    WCHAR        wszMeaning[MAX_SENSE_LENGTH+1];
    BYTE        cchMeaning = 0;
    DWORD        dwReadBytes;
    BOOL        fRet = fFalse;

    Dbg(DBGID_Hanja, "GenerateHanjaCandList");
    if (!EnsureHanjaLexLoaded()) 
        {
        MessageBeep(MB_ICONEXCLAMATION);
        return fFalse;
        }

    // Get Current composition char
    if (wcHangul == 0)
        wcHangul = pImeCtx->GetCompBufStr();
        
    if (wcHangul == 0)
        return fFalse;

    pLexIndexTbl = (_LexIndex*)MapViewOfFile(vhLexIndexTbl, FILE_MAP_READ, 0, 0, 0);
    if (!pLexIndexTbl) 
        {
        Dbg(DBGID_Hanja, TEXT("pLexIndexTbl==0"));
        DbgAssert(0);    
        return fFalse;
        }

    if ((iMapCandStr = SearchHanjaIndex(wcHangul, pLexIndexTbl)) < 0)
        MessageBeep(MB_ICONEXCLAMATION);
    else
        {
        // Set member vars
        vwcHangul = wcHangul;
        vuNumofK0 = pLexIndexTbl[iMapCandStr].wNumOfK0;

        // Is K1 Hanja enabled?
        if (pImeCtx->GetGData()->GetKSC5657Hanja() && (vpInstData->f16BitApps == fFalse) && !IsWin95())
            vuNumofK1 = pLexIndexTbl[iMapCandStr].wNumOfK1;
        else
            vuNumofK1 = 0;

        uNumOfCandStr = vuNumofK0 + vuNumofK1;
        if (uNumOfCandStr == 0)
            goto GenerateHanjaCandListExit;

        Dbg(DBGID_Hanja, "Hangul = 0x%04X, K0=%d, K1=%d, iMapCandStr=%d", vwcHangul, vuNumofK0, vuNumofK1, iMapCandStr);

        // Seek to mapping Hanja
        SetFilePointer(vhLex, viBufferStart + pLexIndexTbl[iMapCandStr].iOffset, 0, FILE_BEGIN);    

        // Read all candidates
        for (UINT i = 0; i < uNumOfCandStr; i++)
            {
            ReadFile(vhLex, &wcCandChar, sizeof(WCHAR), &dwReadBytes, 0);
            ReadFile(vhLex, &cchMeaning, sizeof(BYTE), &dwReadBytes, 0);
            if (wcCandChar && (cchMeaning < MAX_SENSE_LENGTH*sizeof(WCHAR)))
                {
                if (cchMeaning)
                    {
                    if (ReadFile(vhLex, wszMeaning, cchMeaning, &dwReadBytes, 0) == 0)
                        goto GenerateHanjaCandListExit;
                    }
                
                wszMeaning[cchMeaning>>1] = L'\0';
                Dbg(DBGID_Hanja, "Read Cand[%d], Hanja=0x%04X", i, wcCandChar);
                pImeCtx->AppendCandidateStr(wcCandChar, wszMeaning);
                }
            }

        pImeCtx->StoreCandidate();
        
        fRet = fTrue;
        }

    GenerateHanjaCandListExit:
        UnmapViewOfFile(pLexIndexTbl);

    return fRet;
    }

// For ImeConversionList.
DWORD GetConversionList(WCHAR wcReading, LPCANDIDATELIST lpCandList, DWORD dwBufLen)
    {
    _LexIndex            *pLexIndexTbl;
    INT                    iMaxCand;
    INT                    i, iMapCandStr;
    UINT                uNumOfCandStr;
    DWORD                dwSize, readBytes, dwStartOfCandStr;
    BYTE                senseLen;
    WCHAR                szSense[MAX_SENSE_LENGTH];
    CIMEData            ImeData;

    if (!EnsureHanjaLexLoaded())
        return (0L);

    // Calculate possible maximum candidates dwBufLen can contain.
    if (dwBufLen) 
        {
        iMaxCand = dwBufLen - sizeof(CANDIDATELIST) + sizeof(DWORD); // Minus header info.(unvariable part)
        iMaxCand = iMaxCand / (sizeof(DWORD) + (sizeof(WCHAR)*2)); // DWORD: offset, WCHAR*2: 1 Character + null
        }
    else 
        iMaxCand = 0;

    pLexIndexTbl = (_LexIndex*)MapViewOfFile(vhLexIndexTbl, FILE_MAP_READ, 0, 0, 0);
    if (!pLexIndexTbl) 
        {
        DbgAssert(0);    
        return (0L);
        }

    dwSize = 0;

    if ((iMapCandStr = SearchHanjaIndex(wcReading, pLexIndexTbl)) < 0) 
        goto ConversionExit1;
    else
        {
        vuNumofK0 = pLexIndexTbl[iMapCandStr].wNumOfK0;
        
        if (ImeData->fKSC5657Hanja && (vpInstData->f16BitApps == fFalse) && !IsWin95())
            vuNumofK1 = pLexIndexTbl[iMapCandStr].wNumOfK1;
        else
            vuNumofK1 = 0;

        uNumOfCandStr = vuNumofK0 + vuNumofK1;
        if (uNumOfCandStr == 0)    // if no Hanja found
            goto ConversionExit1;

        dwSize =  sizeof(CANDIDATELIST) + uNumOfCandStr*sizeof(DWORD)
                    + uNumOfCandStr * sizeof(WCHAR) * 2;
        // return required buffer size
        if (dwBufLen == NULL)
            goto ConversionExit1;
        lpCandList->dwSize  = dwSize;
        lpCandList->dwStyle = IME_CAND_READ;
        lpCandList->dwCount = uNumOfCandStr;
        lpCandList->dwPageStart = lpCandList->dwSelection = 0;
        lpCandList->dwPageSize = CAND_PAGE_SIZE;
    
        //
        SetFilePointer(vhLex, viBufferStart + pLexIndexTbl[iMapCandStr].iOffset, 0, FILE_BEGIN);    

        dwStartOfCandStr = sizeof(CANDIDATELIST) 
                         + sizeof(DWORD) * uNumOfCandStr; // for dwOffset array
                        
        for (i = 0; (i < (INT)uNumOfCandStr) && (i < iMaxCand); i++)
            {
            WCHAR    wchHanja;
            LPWSTR    lpwchCand;
            LPSTR    lpchCand;
            CHAR     szCand[4] = ""; // one DBCS + one Null + one extra

            lpCandList->dwOffset[i] = dwStartOfCandStr + (i<<2);

            if (ReadFile(vhLex, &wchHanja, sizeof(WCHAR), &readBytes, 0) == 0)
                goto ConversionExit1;

            // if Unicode environment
            if (vfUnicode)
                {
                lpwchCand = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[i]);
                *lpwchCand++ = wchHanja;
                *lpwchCand = L'\0';
                }
            else
                {
                // Convert to ANSI
                WideCharToMultiByte(CP_KOREA, 0, 
                                    &wchHanja, 1, (LPSTR)szCand, sizeof(szCand), 
                                    NULL, NULL);
                lpchCand = (LPSTR)((LPSTR)lpCandList + lpCandList->dwOffset[i]);
                *lpchCand++ = szCand[0];
                *lpchCand++ = szCand[1];
                *lpchCand = '\0';
                }
            // Skip meaning
            ReadFile(vhLex, &senseLen, sizeof(BYTE), &readBytes, 0);
            if (senseLen < MAX_SENSE_LENGTH)
                ReadFile(vhLex, szSense, senseLen, &readBytes, 0);
            }
        }

    // if buffer size too small to copy all conversion list info
    if (i == iMaxCand && i < (INT)uNumOfCandStr) 
        {
        lpCandList->dwSize = dwSize = (sizeof(CANDIDATELIST) - sizeof(DWORD))+ i*sizeof(DWORD) + i*sizeof(WCHAR)*2;
        lpCandList->dwCount = (UINT)i;
        }

ConversionExit1:
    UnmapViewOfFile(pLexIndexTbl);

    return (dwSize);
}

INT SearchHanjaIndex(WCHAR wHChar, _LexIndex *pLexIndexTbl)
{
    int iHead = 0, iTail = vuNumOfHangulEntry-1, iMid;

    while (iHead <= iTail)
        {
        iMid = (iHead + iTail) >> 1;

        if (pLexIndexTbl[iMid].wcHangul > wHChar)
            iTail = iMid - 1;
        else 
            if (pLexIndexTbl[iMid].wcHangul < wHChar)
                iHead = iMid + 1;
            else 
                return (iMid);
        }

    return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\gdata.cpp ===
/****************************************************************************
    GDATA.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Instance data and Shared memory data management functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "hanja.h"
#include "immsec.h"
#include "debug.h"
#include "config.h"
#include "gdata.h"

///////////////////////////////////////////////////////////////////////////////
// Per process variables
// Make sure all per process data shoulde be initialized
BOOL         vfUnicode = fTrue;
INSTDATA      vInstData = {0};
LPINSTDATA     vpInstData = NULL;
// CIMEData static variables
HANDLE       CIMEData::m_vhSharedData = 0;


static const CHAR IMEKR_IME_SHAREDDATA_MUTEX_NAME[] =  "ImeKr61ImeData.Mutex";
static const CHAR IMEKR_IME_SHAREDDATA_NAME[] = "ImeKr61ImeData.SharedMemory";

BOOL CIMEData::InitSharedData()
{
    HANDLE hMutex;
    BOOL fRet = fFalse;
    LPIMEDATA pImedata;

    Dbg(DBGID_Mem, TEXT("InitSharedData"));

       hMutex = CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_IME_SHAREDDATA_MUTEX_NAME);
       if (hMutex != NULL)
           {
           // *** Begin Critical Section ***
           DoEnterCriticalSection(hMutex);

        if((m_vhSharedData = OpenFileMapping(FILE_MAP_READ|FILE_MAP_WRITE, fTrue, IMEKR_IME_SHAREDDATA_NAME)))
            {
            Dbg(DBGID_Mem, TEXT("InitSharedData - IME shared data already exist"));
            fRet = fTrue;
            }
        else    // if shared memory does not exist
            {
            m_vhSharedData = CreateFileMapping(INVALID_HANDLE_VALUE, GetIMESecurityAttributes(), PAGE_READWRITE, 
                                0, sizeof(IMEDATA),
                                IMEKR_IME_SHAREDDATA_NAME);
            DbgAssert(m_vhSharedData != 0);
            // if shared memory not exist create it
            if (m_vhSharedData) 
                {
                  Dbg(DBGID_Mem, TEXT("InitSharedData::InitSharedData() - File mapping Created"));
                pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);

                if (!pImedata)
                    {
                    DbgAssert(0);
                    goto ExitCreateSharedData;
                    }

                // initialize the data to zero
                ZeroMemory(pImedata, sizeof(IMEDATA));
                // Unint value of status and comp window position
                pImedata->ptStatusPos.x = pImedata->ptStatusPos.y = -1;
                pImedata->ptCompPos.x = pImedata->ptCompPos.y = -1;

                // Unmap memory
                UnmapViewOfFile(pImedata);
                Dbg(DBGID_Mem, TEXT("IME shared data handle created successfully"));
                fRet = fTrue;
                }
            }
            
    ExitCreateSharedData:
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
           // *** End Critical Section ***
           }
    FreeIMESecurityAttributes();
    
    return fRet;
}

// Close shared memory handle. This called when process detach time.
BOOL CIMEData::CloseSharedMemory()
{
    HANDLE hMutex;
    BOOL fRet = fTrue;

    Dbg(DBGID_Mem, TEXT("CloseSharedMemory"));

    hMutex = CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_IME_SHAREDDATA_MUTEX_NAME);
    if (hMutex != NULL)
        {
           // *** Begin Critical Section ***
           DoEnterCriticalSection(hMutex);
        if (m_vhSharedData)
            {
            if (fRet = CloseHandle(m_vhSharedData))
                m_vhSharedData = 0;
            DbgAssert(fRet);
            }
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
           // *** End Critical Section ***
        }
       FreeIMESecurityAttributes();

    return fTrue;
}

///////////////////////////////////////////////////////////////////////////////
void CIMEData::InitImeData()
{
    POINT ptStatusWinPosReg;

    // Get Work Area
    SystemParametersInfo(SPI_GETWORKAREA, 0, &(m_pImedata->rcWorkArea), 0);

    // if current status window position different from registy, reset reg value
    if (GetStatusWinPosReg(&ptStatusWinPosReg))
        {
        if (ptStatusWinPosReg.x != m_pImedata->ptStatusPos.x ||
            ptStatusWinPosReg.y != m_pImedata->ptStatusPos.y)
            SetRegValues(GETSET_REG_STATUSPOS);
        }

    // Reset magic number for Winlogon process.
    if ((vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON) != 0)
        m_pImedata->ulMagic = 0;

    // If IMEDATA is not initialized ever, fill it with default value first,
    // and then try to read from registry.
    // If IMEDATA overwritten by any reason, it will recover to initial data.
    if (m_pImedata->ulMagic != IMEDATA_MAGIC_NUMBER)
        {
        // Set magic number only if not a Winlogon process
        // If current process is WinLogon, we should reload user setting after login
        if ((vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON) == 0)
            m_pImedata->ulMagic = IMEDATA_MAGIC_NUMBER;

        // Default option setting. It can be changed according to registry in ImeSelect
        SetCurrentBeolsik(KL_2BEOLSIK);
        m_pImedata->fJasoDel = fTrue;
        m_pImedata->fKSC5657Hanja = fFalse;

        // Default status Buttons
#if !defined(_M_IA64)
        m_pImedata->uNumOfButtons = 3;
#else
        m_pImedata->uNumOfButtons = 2;
#endif
        m_pImedata->iCurButtonSize = BTN_MIDDLE;
        m_pImedata->StatusButtons[0].m_ButtonType = HAN_ENG_TOGGLE_BUTTON;
        m_pImedata->StatusButtons[1].m_ButtonType = HANJA_CONV_BUTTON;
#if !defined(_M_IA64)
        m_pImedata->StatusButtons[2].m_ButtonType = IME_PAD_BUTTON;
        m_pImedata->StatusButtons[3].m_ButtonType = NULL_BUTTON;
#else
        m_pImedata->StatusButtons[2].m_ButtonType = NULL_BUTTON;
#endif

        // init with default button status
        UpdateStatusButtons(*this);

        m_pImedata->cxStatLeftMargin = 3; // 9; if left two vertical exist
        m_pImedata->cxStatRightMargin = 3;
        m_pImedata->cyStatMargin = 3;

        m_pImedata->cyStatButton = m_pImedata->cyStatMargin;

        // Get all regstry info
        GetRegValues(GETSET_REG_ALL);

        UpdateStatusWinDimension();
        //
        m_pImedata->xCandWi = 320;
        m_pImedata->yCandHi = 30;
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\hauto.h ===
/****************************************************************************
	HAUTO.CPP

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Hangul composition state machine class
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (__HAUTOMATA_H__)
#define __HAUTOMATA_H__

#include "debug.h"

// Number of each component
#define NUM_OF_CHOSUNG  19
#define NUM_OF_JUNGSUNG 21
#define NUM_OF_JONGSUNG 28

#define NUM_OF_DOUBLE_CHOSUNG   5
#define NUM_OF_DOUBLE_JUNGSUNG  7
#define NUM_OF_DOUBLE_JONGSUNG_2BEOL 11
#define NUM_OF_DOUBLE_JONGSUNG_3BEOL 13

#define UNICODE_HANGUL_BASE					0xAC00
#define UNICODE_HANGUL_END					0xD7A3
#define UNICODE_HANGUL_COMP_JAMO_START		0x3131
#define UNICODE_HANGUL_COMP_JAMO_VOWEL_START		0x314F
#define UNICODE_HANGUL_COMP_JAMO_END		0x3163
#define UNICODE_HANGUL_COMP_JAMO_START_FILL	0x3130
#define UNICODE_HANGUL_COMP_JAMO_SIOT		0x3145

///////////////////////////////////////////
// HANGUL Jaso inernal difinitions
// ChoSung
#define _KIYEOK_			1		// ''	
#define _SSANGKIYEOK_		2		// ''
#define _NIEUN_				3		// ''
#define _TIKEUT_			4		// ''
#define _SSANGTIKEUT_		5		// ''
#define _RIEUL_				6		// ''
#define _MIEUM_				7		// ''
#define _PIEUP_				8		// ''
#define _SSANGPIEUP_		9		// ''
#define _SIOS_				10		// ''
#define _SSANGSIOS_			11		// ''
#define _IEUNG_				12		// ''
#define _CIEUC_				13		// ''
#define _SSANGCIEUC_		14		// ''
#define _CHIEUCH_			15		// ''
#define _KHIEUKH_			16		// ''
#define _THIEUTH_			17		// ''
#define _PHIEUPH_			18		// ''
#define _HIEUH_				19		// ''

// JungSung
#define _A_					1		// ''
#define _AE_				2		// ''
#define _YA_				3		// ''
#define _YAE_				4		// ''
#define _EO_				5		// ''
#define _E_					6		// ''
#define _YEO_				7		// ''
#define _YE_				8		// ''
#define _O_					9		// ''
#define _WA_				10		// ''
#define _WAE_				11		// ''
#define _OE_				12		// ''
#define _YO_				13		// ''
#define _U_					14		// ''
#define _WEO_				15		// ''
#define _WE_				16		// ''
#define _WI_				17		// ''
#define _YU_				18		// ''
#define _EU_				19		// ''
#define _YI_				20		// ''
#define _I_					21		// ''
////////////////////////////////////////

// JongSung
#define _JONG_KIYEOK_			1		// ''	
#define _JONG_SSANGKIYEOK_		2		// ''
#define _JONG_KIYEOK_SIOS		3
#define _JONG_NIEUN_			4		// ''
#define _JONG_NIEUN_CHIEUCH_	5		// ''
#define _JONG_NIEUN_HIEUH_		6		// ''
#define _JONG_TIKEUT_			7		// ''
#define _JONG_RIEUL_			8		// ''
#define _JONG_RIEUL_KIYEOK_		9		// ''
#define _JONG_RIEUL_MIUM_		10		// ''
#define _JONG_RIEUL_PIEUP_		11		// ''
#define _JONG_RIEUL_SIOS_		12		// ''
#define _JONG_RIEUL_THIEUTH_	13		// ''
#define _JONG_RIEUL_PHIEUPH_	14		// ''
#define _JONG_RIEUL_HIEUH_		15		// ''
#define _JONG_MIEUM_			16		// ''
#define _JONG_PIEUP_			17		// ''
#define _JONG_PIEUP_SIOS		18		// ''
#define _JONG_SIOS_				19		// ''
#define _JONG_SSANGSIOS_		20		// ''
#define _JONG_IEUNG_			21		// ''
#define _JONG_CIEUC_			22		// ''
#define _JONG_CHIEUCH_			23		// ''
#define _JONG_KHIEUKH_			24		// ''
#define _JONG_THIEUTH_			25		// ''
#define _JONG_PHIEUPH_			26		// ''
#define _JONG_HIEUH_			27		// ''
//
const int MaxInterimStackSize = 6;		// Maximum stack size is 6.
										// At most 6 key input
										// to complete one Hangul Char.
										// ex) (3 beolsik)
enum HAutomataReturnState 
	{ 
	  HAUTO_NONHANGULKEY,
	  HAUTO_COMPOSITION,	// Hagul still in interim state.
	  HAUTO_COMPLETE,		// One hangul char completed and have chars 
							// will takeover as next input.
	  HAUTO_IMPOSSIBLE
	};

const WORD H_HANGUL = 0x8000;

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata Abstract Class
//
class CHangulAutomata
	{
public:
	CHangulAutomata() {	InitState(); }

// Attributes
public:

// Operations
public:
	void InitState() 
		{ 
		m_CurState = m_NextState = 0;
		m_wInternalCode = 0;
		m_Chosung = m_Jungsung = m_Jongsung = 0;
		m_wcComposition = m_wcComplete = L'\0';
		InterimStack.Init();
		}
	virtual HAutomataReturnState Machine(UINT KeyCode, int iShift) = 0;
	virtual BOOL IsInputKey(UINT KeyCode, int iShift) = 0;
	virtual BOOL IsHangulKey(UINT KeyCode, int iShift) = 0;
	virtual WORD GetKeyMap(UINT KeyCode, int iShift) = 0;
	virtual BOOL SetCompositionChar(WCHAR wcComp) = 0;
	
	static WORD GetEnglishKeyMap(UINT KeyCode, int iShift) { return bETable[KeyCode][iShift]; }
	BOOL BackSpace();
	BOOL MakeComplete();
	WCHAR GetCompositionChar() { return m_wcComposition; }
	WCHAR GetCompleteChar() { return m_wcComplete; }

// Implementation
public:
	virtual ~CHangulAutomata() {}

protected:
	void MakeComposition();
	BOOL MakeComplete(WORD wcComplete);
	WORD FindChosungComb(WORD wPrevCode);
	WORD FindJunsungComb(WORD wPrevCode);
	virtual WORD FindJonsungComb(WORD wPrevCode) = 0;
	void SeparateDJung(LPWORD pJungSung);
	void SeparateDJong(LPWORD pJongSung);

	virtual HAutomataReturnState Input(WORD InternalCode) = 0;
	//
	struct InterimStackEntry 
		{
		WORD	m_wInternalCode;
		WORD	m_CurState;
		WORD	m_Chosung, m_Jungsung, m_Jongsung;
		WCHAR	m_wcCode;
		};

	///////////////////////////////////////////////////////////////////////////
	//
	class CInterimStack 
		{
	protected:
		InterimStackEntry	m_StackBuffer[MaxInterimStackSize];	
		int	m_sp;		// Stack pointer

	public:
		CInterimStack() { m_sp = 0; }
		~CInterimStack() {}
		void Init() { m_sp = 0; }
		void Push(InterimStackEntry& InterimEntry);
		void Push(WORD wInternalCode, WORD CurState, 
				  WORD Chosung, WORD Jungsung, WORD Jongsung, WCHAR wcCode);

		InterimStackEntry* CInterimStack::Pop() 
			{
			DbgAssert(m_sp > 0);
			return &m_StackBuffer[--m_sp];
			}

		InterimStackEntry* CInterimStack::GetTop() 
			{
			DbgAssert(m_sp > 0);
			return &m_StackBuffer[m_sp-1];
			}

		BOOL IsEmpty() { return m_sp == 0; }
		};
	///////////////////////////////////////////////////////////////////////////
	CInterimStack InterimStack;

protected:
	WORD	m_CurState, m_NextState;
	WORD	m_wInternalCode, m_Chosung, m_Jungsung, m_Jongsung;
	WCHAR	m_wcComposition;
	WCHAR	m_wcComplete;
	//
	const static BYTE  bETable[256][2];
	const static BYTE  Cho2Jong[NUM_OF_CHOSUNG+1];
	const static BYTE  Jong2Cho[NUM_OF_JONGSUNG];
	};

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata2 Keyboard layout #1 (2 beolsik)
//
class CHangulAutomata2 : public CHangulAutomata
{
public:
	CHangulAutomata2() { }

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift);
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift);
	WORD GetKeyMap(UINT KeyCode, int iShift);
	BOOL SetCompositionChar(WCHAR wcComp);
	
// Implementation
public:
	~CHangulAutomata2() { }

protected:
	WORD FindJonsungComb(WORD wPrevCode);
	HAutomataReturnState Input(WORD InternalCode);
		
protected:
	// This enum should be matched with m_NextState
	// DO NOT change without changing _Transistion_state !
	enum _Transistion_state { FINAL=8, TAKEOVER=9, FIND=10 };
	static const WORD m_NextStateTbl[8][5];
	static const WORD H_CONSONANT, H_VOWEL, H_DOUBLE, H_ONLYCHO;
	static WORD wHTable[256][2];
	static BYTE  rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_2BEOL+1][3];
};


/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata3 Keyboard layout #2 (3 beolsik)
class CHangulAutomata3 : public CHangulAutomata
{
public:
	CHangulAutomata3() {}

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift);
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift);
	WORD GetKeyMap(UINT KeyCode, int iShift);
	BOOL SetCompositionChar(WCHAR wcComp);

// Implementation
public:
	~CHangulAutomata3() { }

protected:
	WORD FindJonsungComb(WORD wPrevCode);
	HAutomataReturnState Input(WORD InternalCode);
	
protected:
	enum _Transistion_state { FINAL=11, FIND=12 };
	static const WORD m_NextStateTbl[11][6];
	static const WORD H_CHOSUNG, H_JUNGSUNG, H_JONGSUNG, H_DOUBLE;
	static WORD wHTable[256][2];
	static BYTE  rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_3BEOL+1][3];
};

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata3 Keyboard layout #3 (3 beolsik final)
class CHangulAutomata3Final : public CHangulAutomata3
{
public:
	CHangulAutomata3Final() {}

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift) ;
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift); 
	WORD GetKeyMap(UINT KeyCode, int iShift);

// Implementation
public:
	~CHangulAutomata3Final() { }

protected:
	static WORD wHTable[256][2];
};

///////////////////////////////////////////////////////////////////////////////
// Inline functions

inline
void CHangulAutomata::CInterimStack::Push(InterimStackEntry& InterimEntry) 
	{
	DbgAssert(m_sp<MaxInterimStackSize);
	m_StackBuffer[m_sp++] =  InterimEntry;
	}

inline
void CHangulAutomata::CInterimStack::Push(WORD wInternalCode, WORD CurState, 
				  WORD Chosung, WORD Jungsung, WORD Jongsung, WCHAR wcCode) 
	{
	DbgAssert(m_sp<=5);
	m_StackBuffer[m_sp].m_wInternalCode =  wInternalCode;
	m_StackBuffer[m_sp].m_CurState =  CurState;
	m_StackBuffer[m_sp].m_Chosung =  Chosung;
	m_StackBuffer[m_sp].m_Jungsung =  Jungsung;
	m_StackBuffer[m_sp].m_Jongsung =  Jongsung;
	m_StackBuffer[m_sp++].m_wcCode =  wcCode;
	}

// CHangulAutomata2
inline
HAutomataReturnState CHangulAutomata2::Machine(UINT KeyCode, int iShift) 
	{
	return (Input(wHTable[KeyCode][iShift]));
	}

inline
BOOL CHangulAutomata2::IsInputKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata2::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata2::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}


// CHangulAutomata3
inline
HAutomataReturnState CHangulAutomata3::Machine(UINT KeyCode, int iShift) 
	{
	DbgAssert(KeyCode<256);
	return (Input(wHTable[KeyCode][iShift]));
	}

inline
BOOL CHangulAutomata3::IsInputKey(UINT KeyCode, int iShift)
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata3::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata3::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return 0;
	}

// CHangulAutomata3Final
inline 
HAutomataReturnState CHangulAutomata3Final::Machine(UINT KeyCode, int iShift) 
	{
	DbgAssert(KeyCode<256);
	return (Input(wHTable[KeyCode][iShift]));
	}

inline 
BOOL CHangulAutomata3Final::IsInputKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata3Final::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata3Final::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return 0;
	}

#endif // !defined (__HAUTOMATA_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\hauto.cpp ===
/****************************************************************************
    HAUTO.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Hangul composition state machine class
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "hauto.h"
#include "debug.h"

// Code conversion table from Chosung to Jongsung.
const 
BYTE  CHangulAutomata::Cho2Jong[NUM_OF_CHOSUNG+1] = //(+ 1 means including fill code at 0)
    { 0, 
      1,  2,  4,  7,  0,  8, 16, 17,  0, 19,
     20, 21, 22,  0, 23, 24, 25, 26, 27
    };

// Code conversion table from Jongsung to Chosung.
const 
BYTE  CHangulAutomata::Jong2Cho[NUM_OF_JONGSUNG] = // Jongsung has inherent fill code
    {  0, 
        1,  2,  0,  3,  0,  0,  4,  6,  0,  0,
        0,  0,  0,  0,  0,  7,  8,  0, 10, 11,
       12, 13, 15, 16, 17, 18, 19  
    };

// Combination table for double jongsung.
BYTE  CHangulAutomata2::rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_2BEOL+1][3] = 
    {
        {  1, 19,  3 }, {  4, 22,  5 }, 
        {  4, 27,  6 },    {  8,  1,  9 }, 
        {  8, 16, 10 },    {  8, 17, 11 }, 
        {  8, 19, 12 },    {  8, 25, 13 }, 
        {  8, 26, 14 }, {  8, 27, 15 }, 
        { 17, 19, 18 },
        { 0,   0,  0 }
    };

BYTE  CHangulAutomata3::rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_3BEOL+1][3] = 
    {
        // 3Beolsik has two more Double Jongsung conditions.
        {  1,  1,  2 },    // KiYeok+KiYeok = Double KiYeok
        {  1, 19,  3 }, {  4, 22,  5 }, 
        {  4, 27,  6 },    {  8,  1,  9 }, 
        {  8, 16, 10 },    {  8, 17, 11 }, 
        {  8, 19, 12 },    {  8, 25, 13 }, 
        {  8, 26, 14 }, {  8, 27, 15 }, 
        { 17, 19, 18 },    
        { 19, 19, 20 },  // Sios+Sios = Double Sios
        { 0,   0,  0 }
    };


#if (NOT_USED)
static
WORD CHangulAutomata::DblJong2Cho(WORD DblJong)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    int i = NUM_OF_DOUBLE_JONGSUNG;
    
    for (; i>0; i--, pDbl--)
        if ( (*pDbl)[2] == DblJong ) 
            return Jong2Cho[(*pDbl)[1]];

    return 0;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// 2 beolsik input state category
const WORD CHangulAutomata2::H_CONSONANT = 0x0000 | H_HANGUL;    // Consonant
const WORD CHangulAutomata2::H_VOWEL     = 0x0100 | H_HANGUL;    // Vowel
const WORD CHangulAutomata2::H_DOUBLE    = 0x0200 | H_HANGUL;    // Double combination possible
const WORD CHangulAutomata2::H_ONLYCHO   = 0x0400 | H_HANGUL;    // Chosung only

// 3 beolsik input state category
const WORD CHangulAutomata3::H_CHOSUNG   = 0x0000 | H_HANGUL;    // ChoSung
const WORD CHangulAutomata3::H_JUNGSUNG  = 0x0200 | H_HANGUL;   // JungSung
const WORD CHangulAutomata3::H_JONGSUNG  = 0x0400 | H_HANGUL;   // JongSung
const WORD CHangulAutomata3::H_DOUBLE    = 0x0100 | H_HANGUL;    // Double combination possible

///////////////////////////////////////////////////////////////////////////////
// bHTable[] structure
//
// 2 Beolsik
//     H I G H  B Y T E  L O W  B Y T E
//    7 6 5 4 3 2 1 0  7 6 5 4 3 2 1 0          
//   +-+-------+-----+---------------+
//   | |       |     |               |
//   +-+-------+-----+---------------+
//     High 8   : Hangul or English
//   High 2-0 : used for input state category field.
//   Low  4-0 : Hangul component code (internal code)
//

// ====-- SHARED SECTION START --====
#pragma data_seg(".MSIMESHR")
WORD  CHangulAutomata2::wHTable[256][2] =
{
//  { Hangul normal, Hangul shift, English normal, English shift }
    // 2 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 0x30, 0x29 }, //  48, 0x30: VK_0
    { 0x31, 0x21 }, //  49, 0x31: VK_1
    { 0x32, 0x40 }, //  50, 0x32: VK_2
    { 0x33, 0x23 }, //  51, 0x33: VK_3
    { 0x34, 0x24 }, //  52, 0x34: VK_4
    { 0x35, 0x25 }, //  53, 0x35: VK_5
    { 0x36, 0x5E }, //  54, 0x36: VK_6
    { 0x37, 0x26 }, //  55, 0x37: VK_7
    { 0x38, 0x2A }, //  56, 0x38: VK_8
    { 0x39, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    {  7 | H_CONSONANT,  7 | H_CONSONANT },                            //  65, 0x41: VK_A        
    { 18 | H_VOWEL, 18 | H_VOWEL },                                    //  66, 0x42: VK_B        
    { 15 | H_CONSONANT, 15 | H_CONSONANT },                            //  67, 0x43: VK_C        
    { 12 | H_CONSONANT, 12 | H_CONSONANT },                            //  68, 0x44: VK_D        
    {  4 | H_CONSONANT,  5 | H_ONLYCHO},                            //  69, 0x45: VK_E        
    {  6 | H_CONSONANT | H_DOUBLE,  6 | H_CONSONANT | H_DOUBLE },    //  70, 0x46: VK_F        
    { 19 | H_CONSONANT, 19 | H_CONSONANT },                            //  71, 0x47: VK_G        
    {  9 | H_VOWEL | H_DOUBLE,  9 | H_VOWEL | H_DOUBLE },            //  72, 0x48: VK_H        
    {  3 | H_VOWEL,  3 | H_VOWEL },                                    //  73, 0x49: VK_I        
    {  5 | H_VOWEL,  5 | H_VOWEL },                                    //  74, 0x4A: VK_J        
    {  1 | H_VOWEL,  1 | H_VOWEL },                                    //  75, 0x4B: VK_K        
    { 21 | H_VOWEL, 21 | H_VOWEL },                                    //  76, 0x4C: VK_L        
    { 19 | H_VOWEL | H_DOUBLE, 19 | H_VOWEL | H_DOUBLE },            //  77, 0x4D: VK_M        
    { 14 | H_VOWEL | H_DOUBLE, 14 | H_VOWEL | H_DOUBLE },            //  78, 0x4E: VK_N        
    {  2 | H_VOWEL,  4 | H_VOWEL },                                    //  79, 0x4F: VK_O        
    {  6 | H_VOWEL,  8 | H_VOWEL },                                    //  80, 0x50: VK_P        
    {  8 | H_CONSONANT | H_DOUBLE,  9 | H_ONLYCHO },                //  81, 0x51: VK_Q        
    {  1 | H_CONSONANT | H_DOUBLE,  2 | H_CONSONANT },                //  82, 0x52: VK_R        
    {  3 | H_CONSONANT | H_DOUBLE,  3 | H_CONSONANT | H_DOUBLE },    //  83, 0x53: VK_S        
    { 10 | H_CONSONANT, 11 | H_CONSONANT },                            //  84, 0x54: VK_T        
    {  7 | H_VOWEL, 7 | H_VOWEL },                                    //  85, 0x55: VK_U        
    { 18 | H_CONSONANT, 18 | H_CONSONANT },                            //  86, 0x56: VK_V        
    { 13 | H_CONSONANT, 14 | H_ONLYCHO },                            //  87, 0x57: VK_W        
    { 17 | H_CONSONANT, 17 | H_CONSONANT },                            //  88, 0x58: VK_X        
    { 13 | H_VOWEL, 13 | H_VOWEL },                                    //  89, 0x59: VK_Y        
    { 16 | H_CONSONANT, 16 | H_CONSONANT },                            //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    { 0x3B, 0x3A }, // 186, 0xBA:    ;    :
    { 0x3D, 0x2B }, // 187, 0xBB:    =    +
    { 0x2C, 0x3C }, // 188, 0xBC:    ,    <
    { 0x2D, 0x5F }, // 189, 0xBD:    -    _
    { 0x2E, 0x3E }, // 190, 0xBE:    .    >
    { 0x2F, 0x3F }, // 191, 0xBF:    /    ?
    { 0x60, 0x7E }, // 192, 0xC0:    `    ~
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:    [    {
    { 0x5C, 0x7C }, // 220, 0xDC:    \    |
    { 0x5D, 0x7D }, // 221, 0xDD:    ]    }
    { 0x27, 0x22 }, // 222, 0xDE:    '    "
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

WORD  CHangulAutomata3::wHTable[256][2] =
{
    // 3 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 16 | H_CHOSUNG, 0x29 },                    //  48, 0x30: VK_0        )
    { 27 | H_JONGSUNG, 22 | H_JONGSUNG },        //  49, 0x31: VK_1        
    { 20 | H_JONGSUNG, 0x40 },                    //  50, 0x32: VK_2        @
    { 17 | H_JONGSUNG | H_DOUBLE, 0x23 },        //  51, 0x33: VK_3        #
    { 13 | H_JUNGSUNG, 0x24 },                    //  52, 0x34: VK_4        $
    { 18 | H_JUNGSUNG, 0x25 },                    //  53, 0x35: VK_5        %
    {  3 | H_JUNGSUNG, 0x5E },                    //  54, 0x36: VK_6        ^
    {  8 | H_JUNGSUNG, 0x26 },                    //  55, 0x37: VK_7        &
    { 20 | H_JUNGSUNG, 0x2A },                    //  56, 0x38: VK_8        *
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 21 | H_JONGSUNG,  7 | H_JONGSUNG},    //  65, 0x41: VK_A        
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x21 },    //  66, 0x42: VK_B        !
    {  6 | H_JUNGSUNG, 10 | H_JONGSUNG},    //  67, 0x43: VK_C        
    { 21 | H_JUNGSUNG,  9 | H_JONGSUNG},    //  68, 0x44: VK_D        
    {  7 | H_JUNGSUNG, 24 | H_JONGSUNG},    //  69, 0x45: VK_E        
    {  1 | H_JUNGSUNG,  2 | H_JONGSUNG},    //  70, 0x46: VK_F        
    { 19 | H_JUNGSUNG | H_DOUBLE, 0x2F },    //  71, 0x47: VK_G        /
    {  3 | H_CHOSUNG, 0x27 },                //  72, 0x48: VK_H        ,
    {  7 | H_CHOSUNG, 0x38 },                //  73, 0x49: VK_I        8
    { 12 | H_CHOSUNG, 0x34 },                //  74, 0x4A: VK_J        4
    {  1 | H_CHOSUNG | H_DOUBLE, 0x35 },    //  75, 0x4B: VK_K        5
    { 13 | H_CHOSUNG | H_DOUBLE, 0x36 },    //  76, 0x4C: VK_L        6
    { 19 | H_CHOSUNG, 0x31 },        //  77, 0x4D: VK_M        1
    { 10 | H_CHOSUNG | H_DOUBLE, 0x30 },    //  78, 0x4E: VK_N        0
    { 15 | H_CHOSUNG, 0x39 },                //  79, 0x4F: VK_O        9
    { 18 | H_CHOSUNG, 0x3E },                //  80, 0x50: VK_P        >
    { 19 | H_JONGSUNG | H_DOUBLE,  26 | H_JONGSUNG},    //  81, 0x51: VK_Q        
    {  2 | H_JUNGSUNG, 4 | H_JUNGSUNG},                    //  82, 0x52: VK_R        
    {  4 | H_JONGSUNG | H_DOUBLE,  6 | H_JONGSUNG},        //  83, 0x53: VK_S        
    {  5 | H_JUNGSUNG, 0x3B },                            //  84, 0x54: VK_T        ;
    {  4 | H_CHOSUNG | H_DOUBLE, 0x37 },                //  85, 0x55: VK_U        7
    {  9 | H_JUNGSUNG | H_DOUBLE, 15 | H_JONGSUNG },    //  86, 0x56: VK_V        
    {  8 | H_JONGSUNG | H_DOUBLE, 25 | H_JONGSUNG},        //  87, 0x57: VK_W        
    {  1 | H_JONGSUNG | H_DOUBLE, 18 | H_JONGSUNG },    //  88, 0x58: VK_X        
    {  6 | H_CHOSUNG, 0x3C },                            //  89, 0x59: VK_Y        <
    { 16 | H_JONGSUNG,  23 | H_JONGSUNG },                //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    {  8 | H_CHOSUNG | H_DOUBLE, 0x3A },    // 186, 0xBA:        :
    { 0x3D, 0x2B },                            // 187, 0xBB:
    { 0x2C, 0x32 },                            // 188, 0xBC:    ,    2
    { 0x2D, 0x5F },                            // 189, 0xBD:
    { 0x2E, 0x33 },                            // 190, 0xBE:    .    3
    {  9 | H_JUNGSUNG | H_DOUBLE, 0x3F },    // 191, 0xBF:        ?
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:    [    {
    { 0x5C, 0x7C }, // 220, 0xDC:    \    |
    { 0x5D, 0x7D }, // 221, 0xDD:    ]    }
    { 17 | H_CHOSUNG, 0x22 }, // 222, 0xDE:        "
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

WORD  CHangulAutomata3Final::wHTable[256][2] =
{
    // 3 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 16 | H_CHOSUNG, 0x7E },                    //  48, 0x30: VK_0        ~
    { 27 | H_JONGSUNG,  2 | H_JONGSUNG },        //  49, 0x31: VK_1        
    { 20 | H_JONGSUNG,  9 | H_JONGSUNG },        //  50, 0x32: VK_2         
    { 17 | H_JONGSUNG|H_DOUBLE, 22 | H_JONGSUNG },    //  51, 0x33: VK_3        
    { 13 | H_JUNGSUNG, 14 | H_JONGSUNG },            //  52, 0x34: VK_4        
    { 18 | H_JUNGSUNG, 13 | H_JONGSUNG },            //  53, 0x35: VK_5        
    {  3 | H_JUNGSUNG, 0x3D },                    //  54, 0x36: VK_6        =
    {  8 | H_JUNGSUNG, 0x22 },                    //  55, 0x37: VK_7        "
    { 20 | H_JUNGSUNG, 0x22 },                    //  56, 0x38: VK_8        "
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x27 },        //  57, 0x39: VK_9  '
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 21 | H_JONGSUNG,  7 | H_JONGSUNG},    //  65, 0x41: VK_A        
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x3F },    //  66, 0x42: VK_B        ?
    {  6 | H_JUNGSUNG, 24 | H_JONGSUNG},    //  67, 0x43: VK_C        
    { 21 | H_JUNGSUNG, 11 | H_JONGSUNG},    //  68, 0x44: VK_D        
    {  7 | H_JUNGSUNG,  5 | H_JONGSUNG},    //  69, 0x45: VK_E        
    {  1 | H_JUNGSUNG, 10 | H_JONGSUNG},    //  70, 0x46: VK_F        
    { 19 | H_JUNGSUNG | H_DOUBLE, 4 | H_JUNGSUNG },    //  71, 0x47: VK_G        
    {  3 | H_CHOSUNG, 0x30 },                //  72, 0x48: VK_H        0
    {  7 | H_CHOSUNG, 0x37 },                //  73, 0x49: VK_I        7
    { 12 | H_CHOSUNG, 0x31 },                //  74, 0x4A: VK_J        1
    {  1 | H_CHOSUNG | H_DOUBLE, 0x32 },    //  75, 0x4B: VK_K        2
    { 13 | H_CHOSUNG | H_DOUBLE, 0x33 },    //  76, 0x4C: VK_L        3
    { 19 | H_CHOSUNG, 0x22},                //  77, 0x4D: VK_M        "
    { 10 | H_CHOSUNG | H_DOUBLE, 0x2D },    //  78, 0x4E: VK_N        -
    { 15 | H_CHOSUNG, 0x38 },                //  79, 0x4F: VK_O        8
    { 18 | H_CHOSUNG, 0x39 },                //  80, 0x50: VK_P        9
    { 19 | H_JONGSUNG | H_DOUBLE,  26 | H_JONGSUNG},    //  81, 0x51: VK_Q        
    {  2 | H_JUNGSUNG, 15 | H_JONGSUNG},                //  82, 0x52: VK_R        
    {  4 | H_JONGSUNG | H_DOUBLE,  6 | H_JONGSUNG},        //  83, 0x53: VK_S        
    {  5 | H_JUNGSUNG, 12 | H_JONGSUNG },                            //  84, 0x54: VK_T        
    {  4 | H_CHOSUNG | H_DOUBLE, 0x36 },                //  85, 0x55: VK_U        6
    {  9 | H_JUNGSUNG | H_DOUBLE,  3 | H_JONGSUNG },    //  86, 0x56: VK_V        
    {  8 | H_JONGSUNG | H_DOUBLE, 25 | H_JONGSUNG},        //  87, 0x57: VK_W        
    {  1 | H_JONGSUNG | H_DOUBLE, 18 | H_JONGSUNG },    //  88, 0x58: VK_X        
    {  6 | H_CHOSUNG, 0x35 },                            //  89, 0x59: VK_Y        5
    { 16 | H_JONGSUNG,  23 | H_JONGSUNG },                //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    {  8 | H_CHOSUNG | H_DOUBLE, 0x34 },    // 186, 0xBA:        4
    { 0x3E, 0x2B },                            // 187, 0xBB:    >    +
    { 0x2C, 0x2C },                            // 188, 0xBC:    ,    ,
    { 0x29, 0x3B },                            // 189, 0xBD:    )    ;
    { 0x2E, 0x2E },                            // 190, 0xBE:    .    .
    {  9 | H_JUNGSUNG | H_DOUBLE, 0x21 },    // 191, 0xBF:        !
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x28, 0x25 }, // 219, 0xDB:    (    %
    { 0x3A, 0x5C }, // 220, 0xDC:    :    '\'
    { 0x3C, 0x2F }, // 221, 0xDD:    <    /
    { 17 | H_CHOSUNG, 0x00 }, // 222, 0xDE:    
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

const 
BYTE  CHangulAutomata::bETable[256][2] =
{
    // English normal, English shift for Junja(Full shape) mode
    { 0x00, 0x00 }, //   0, 0x00: 
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 0x30, 0x29 }, //  48, 0x30: VK_0
    { 0x31, 0x21 }, //  49, 0x31: VK_1
    { 0x32, 0x40 }, //  50, 0x32: VK_2
    { 0x33, 0x23 }, //  51, 0x33: VK_3
    { 0x34, 0x24 }, //  52, 0x34: VK_4
    { 0x35, 0x25 }, //  53, 0x35: VK_5
    { 0x36, 0x5E }, //  54, 0x36: VK_6
    { 0x37, 0x26 }, //  55, 0x37: VK_7
    { 0x38, 0x2A }, //  56, 0x38: VK_8
    { 0x39, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 0x61, 0x41 }, //  65, 0x41: VK_A
    { 0x62, 0x42 }, //  66, 0x42: VK_B
    { 0x63, 0x43 }, //  67, 0x43: VK_C
    { 0x64, 0x44 }, //  68, 0x44: VK_D
    { 0x65, 0x45 }, //  69, 0x45: VK_E
    { 0x66, 0x46 }, //  70, 0x46: VK_F
    { 0x67, 0x47 }, //  71, 0x47: VK_G
    { 0x68, 0x48 }, //  72, 0x48: VK_H
    { 0x69, 0x49 }, //  73, 0x49: VK_I
    { 0x6A, 0x4A }, //  74, 0x4A: VK_J
    { 0x6B, 0x4B }, //  75, 0x4B: VK_K
    { 0x6C, 0x4C }, //  76, 0x4C: VK_L
    { 0x6D, 0x4D }, //  77, 0x4D: VK_M
    { 0x6E, 0x4E }, //  78, 0x4E: VK_N
    { 0x6F, 0x4F }, //  79, 0x4F: VK_O
    { 0x70, 0x50 }, //  80, 0x50: VK_P
    { 0x71, 0x51 }, //  81, 0x51: VK_Q
    { 0x72, 0x52 }, //  82, 0x52: VK_R
    { 0x73, 0x53 }, //  83, 0x53: VK_S
    { 0x74, 0x54 }, //  84, 0x54: VK_T
    { 0x75, 0x55 }, //  85, 0x55: VK_U
    { 0x76, 0x56 }, //  86, 0x56: VK_V
    { 0x77, 0x57 }, //  87, 0x57: VK_W
    { 0x78, 0x58 }, //  88, 0x58: VK_X
    { 0x79, 0x59 }, //  89, 0x59: VK_Y
    { 0x7A, 0x5A }, //  90, 0x5A: VK_Z
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    { 0x3B, 0x3A }, // 186, 0xBA:
    { 0x3D, 0x2B }, // 187, 0xBB:
    { 0x2C, 0x3C }, // 188, 0xBC:
    { 0x2D, 0x5F }, // 189, 0xBD:
    { 0x2E, 0x3E }, // 190, 0xBE:
    { 0x2F, 0x3F }, // 191, 0xBF:
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:
    { 0x5C, 0x7C }, // 220, 0xDC:
    { 0x5D, 0x7D }, // 221, 0xDD:
    { 0x27, 0x22 }, // 222, 0xDE:
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};


static 
WORD Int2UniCho[NUM_OF_CHOSUNG+1] = 
    {
    0,    // fill [0]
    UNICODE_HANGUL_COMP_JAMO_START + 0,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 1,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 3,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 6,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 7,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 8,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 16,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 17,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 18,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 20,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 21,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 22,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 23,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 24,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 25,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 26,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 27,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 28,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 29,    // 
    };

static 
WORD Int2UniJong[NUM_OF_JONGSUNG] = 
    {
    0,    // fill [0]
    UNICODE_HANGUL_COMP_JAMO_START + 0,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 1,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 2,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 3,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 4,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 5,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 6,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 8,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 9,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 10,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 11,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 12,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 13,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 14,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 15,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 16,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 17,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 19,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 20,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 21,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 22,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 23,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 25,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 26,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 27,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 28,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 29,    // 
    };

// Compatibility Jamo Consonant map
static
BYTE CompJamoMapTable[30][2] =
    {
        // Jamo code , Jongsung Flag : Only if it can't be chosung then make it jongsung
        { _KIYEOK_,                0 },
        { _SSANGKIYEOK_,        0 },
        { _JONG_KIYEOK_SIOS,    1 },
        { _NIEUN_,                0 },
        { _JONG_NIEUN_CHIEUCH_, 1 },
        { _JONG_NIEUN_HIEUH_,    1 },
        { _TIKEUT_,                0 },    
        { _SSANGTIKEUT_,        0 },
        { _RIEUL_,                0 },
        { _JONG_RIEUL_KIYEOK_,    1 },
        { _JONG_RIEUL_MIUM_,    1 },
        { _JONG_RIEUL_PIEUP_,    1 },
        { _JONG_RIEUL_SIOS_,    1 },
        { _JONG_RIEUL_THIEUTH_,    1 },
        { _JONG_RIEUL_PHIEUPH_,    1 },
        { _JONG_RIEUL_HIEUH_,    1 },
        { _MIEUM_,                0 },
        { _PIEUP_,                0 },
        { _SSANGPIEUP_,            0 },
        { _JONG_PIEUP_SIOS,        1 },
        { _SIOS_,                0 }, 
        { _SSANGSIOS_,            0 }, 
        { _IEUNG_,                0 },    
        { _CIEUC_,                0 },
        { _SSANGCIEUC_,            0 },
        { _CHIEUCH_,            0 },
        { _KHIEUKH_,            0 },
        { _THIEUTH_,            0 },
        { _PHIEUPH_,            0 },
        { _HIEUH_,                0 },
    };


static
BYTE JongSungSep[NUM_OF_JONGSUNG][2] =
    {
        {    0,    0    },
        { _JONG_KIYEOK_,            0        },    //_JONG_KIYEOK_        
        { _JONG_SSANGKIYEOK_,        0        },    //_JONG_SSANGKIYEOK_    
        { _JONG_KIYEOK_,    _JONG_SIOS_        },    //_JONG_KIYEOK_SIOS    
        { _JONG_NIEUN_,                0        },    //_JONG_NIEUN_        
        { _JONG_NIEUN_,        _JONG_CIEUC_    },    //_JONG_NIEUN_CIEUC_
        { _JONG_NIEUN_,        _JONG_HIEUH_    },    //_JONG_NIEUN_HIEUH_    
        { _JONG_TIKEUT_,            0        },    //_JONG_TIKEUT_        
        { _JONG_RIEUL_,                0        },    //_JONG_RIEUL_        
        { _JONG_RIEUL_,        _JONG_KIYEOK_    },    //_JONG_RIEUL_KIYEOK_
        { _JONG_RIEUL_,        _JONG_MIEUM_    },    //_JONG_RIEUL_MIUM_        
        { _JONG_RIEUL_,        _JONG_PIEUP_    },    //_JONG_RIEUL_PIEUP_
        { _JONG_RIEUL_,        _JONG_SIOS_        },    //_JONG_RIEUL_SIOS_    
        { _JONG_RIEUL_,        _JONG_THIEUTH_    },    //_JONG_RIEUL_THIEUTH_
        { _JONG_RIEUL_,        _JONG_PHIEUPH_    },    //_JONG_RIEUL_PHIEUPH_    
        { _JONG_RIEUL_,        _JONG_HIEUH_    },    //_JONG_RIEUL_HIEUH_
        { _JONG_MIEUM_,                0        },    //_JONG_MIEUM_        
        { _JONG_PIEUP_,                0        },    //_JONG_PIEUP_        
        { _JONG_PIEUP_,        _JONG_SIOS_        },    //_JONG_PIEUP_SIOS
        { _JONG_SIOS_,                0        },    //_JONG_SIOS_        
        { _JONG_SSANGSIOS_,            0        },    //_JONG_SSANGSIOS_    
        { _JONG_IEUNG_,                0        },    //_JONG_IEUNG_            
        { _JONG_CIEUC_,                0        },    //_JONG_CIEUC_            
        { _JONG_CHIEUCH_,            0        },    //_JONG_CHIEUCH_
        { _JONG_KHIEUKH_,            0        },    //_JONG_KHIEUKH_    
        { _JONG_THIEUTH_,            0        },    //_JONG_THIEUTH_    
        { _JONG_PHIEUPH_,            0        },    //_JONG_PHIEUPH_
        { _JONG_HIEUH_,                0        }    //_JONG_HIEUH_    
    };

static
BYTE JungSungSep[NUM_OF_JUNGSUNG+1][2] =
    {
        {    0,    0    },
        { _A_,                    0    },    // _A_,    
        { _AE_,                    0    },    //_AE_,    
        { _YA_,                    0    },    //_YA_,    
        { _YAE_,                0    },    //_YAE_,
        { _EO_,                    0    },    //_EO_,    
        { _E_,                    0    },    //_E_,    
        { _YEO_,                0    },    //_YEO_,
        { _YE_,                    0    },    //_YE_,    
        { _O_,                    0    },    //_O_,    
        { _O_,                _A_        },    //_WA_,    
        { _O_,                _AE_    },    //_WAE_,
        { _O_,                _I_        },    //_OE_,    
        { _YO_,                    0    },    //_YO_,    
        { _U_,                    0    },    //_U_,    
        { _U_,                _EO_    },    //_WEO_,
        { _U_,                _E_        },    //_WE_,    
        { _U_,                _I_        },    //_WI_,    
        { _YU_,                    0    },    //_YU_,    
        { _EU_,                    0    },    //_EU_,    
        { _EU_,                _I_        },    //_YI_,    
        { _I_,                    0    }    //_I_,    
    };
#pragma data_seg()
// ====-- SHARED SECTION END --====

///////////////////////////////////////////////////////////////////////////////
// CHangulAutomata class member function
BOOL CHangulAutomata::MakeComplete()
{
    if (m_wcComposition) 
        {
        m_wcComplete = m_wcComposition;
        
        // clear composition char
        m_wcComposition = 0;
        
        // Init interim stack
        InterimStack.Init();
        m_Chosung = m_Jungsung = m_Jongsung = 0;
        
        // Init state
        m_CurState = 0;
        return fTrue;
        }
    else
        return fFalse;
}

// Complete used when takeover occurs
BOOL CHangulAutomata::MakeComplete(WORD wcComplete)
{
    if (wcComplete) 
        {
        m_wcComplete = wcComplete;
        // clear composition char
        m_wcComposition = 0;
        // Init interim stack
        InterimStack.Init();
        m_Jungsung = m_Jongsung = 0;
        return fTrue;
        }
    else
        return fFalse;
}

void CHangulAutomata::MakeComposition()
{
    DbgAssert(m_Chosung || m_Jungsung || m_Jongsung);
    // if Hangul
    if (m_Chosung && m_Jungsung) 
        {
        m_wcComposition = UNICODE_HANGUL_BASE 
                            + (m_Chosung-1) * NUM_OF_JUNGSUNG * (NUM_OF_JONGSUNG)    // +1 : jongsung fill
                            + (m_Jungsung-1) * (NUM_OF_JONGSUNG)
                            + m_Jongsung;
        }
    else // Hangul jamo
         // Currently map to compatiblity area. This should be changed if jamo glyphs available.
        {
            if (m_Chosung)
                m_wcComposition = Int2UniCho[m_Chosung];
            else
                if (m_Jungsung)
                    m_wcComposition = UNICODE_HANGUL_COMP_JAMO_START + 30 + m_Jungsung-1;
                    else 
                    if (m_Jongsung)
                        m_wcComposition = Int2UniJong[m_Jongsung];
        }
    // Push to interim stack
    InterimStack.Push(m_wInternalCode, m_CurState, m_Chosung, m_Jungsung, m_Jongsung, 
                      m_wcComposition);
    Dbg(DBGID_Automata, TEXT("CHangulAutomata::MakeComposition(), m_CurState=%d, m_Chosung=%d, m_Jungsung=%d, m_Jongsung=%d, m_wcComposition = 0x%04X"), m_CurState,  m_Chosung, m_Jungsung, m_Jongsung, m_wcComposition);
    //
}

WORD CHangulAutomata::FindChosungComb(WORD wPrevCode)
{
    // Combination table for double chosung. (only for 3beolsik)
    static BYTE  rgbDChoTbl[NUM_OF_DOUBLE_CHOSUNG][3] = 
        {
            {  1,  1,  2 }, {  4,  4,  5 },        //   -> ,   -> 
            {  8,  8,  9 }, { 10, 10, 11 },        //   -> ,   -> 
            { 13, 13, 14 }                        //   -> 
        };

    BYTE (*pDbl)[3] = rgbDChoTbl;    // pointer a little bit faster than array access.
    int i = NUM_OF_DOUBLE_CHOSUNG;
    WORD wCurCode = m_wInternalCode & 0xFF;

    for (; i>0; i--, pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] == wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

WORD CHangulAutomata::FindJunsungComb(WORD wPrevCode)
{
    // Combination table for double jungsung.
    static BYTE  rgbDJungTbl[NUM_OF_DOUBLE_JUNGSUNG][3] = 
        {
            {  9,  1, 10 }, {  9,  2, 11 },        //   -> ,   -> 
            {  9, 21, 12 }, { 14,  5, 15 },        //   -> ,   -> 
            { 14,  6, 16 }, { 14, 21, 17 },        //   -> ,   -> 
            { 19, 21, 20 }                        //   -> 
        };
    BYTE (*pDbl)[3] = rgbDJungTbl;
    int i = NUM_OF_DOUBLE_JUNGSUNG;
    WORD wCurCode = m_wInternalCode & 0xFF;
    
    for (; i>0; i--, pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] == wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}


WORD CHangulAutomata2::FindJonsungComb(WORD wPrevCode)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    wPrevCode = Cho2Jong[wPrevCode];
    WORD wCurCode = Cho2Jong[m_wInternalCode & 0xFF];
    
    for (; (*pDbl)[0]; pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] ==  wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

WORD CHangulAutomata3::FindJonsungComb(WORD wPrevCode)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    // 3BeolSik internal code have Jongsung code
    WORD wCurCode = m_wInternalCode & 0xFF;
    
    for (; (*pDbl)[0]; pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] ==  wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

BOOL CHangulAutomata::BackSpace()
{
    InterimStackEntry*    pInterimEntry;

    if (InterimStack.IsEmpty())
        return fFalse;
    else 
        {
        InterimStack.Pop();
        if (!InterimStack.IsEmpty()) 
            {
            pInterimEntry = InterimStack.GetTop();
            m_wcComposition = pInterimEntry->m_wcCode;
            m_CurState = pInterimEntry->m_CurState;
            m_Chosung = pInterimEntry->m_Chosung;
            m_Jungsung = pInterimEntry->m_Jungsung;
            m_Jongsung = pInterimEntry->m_Jongsung;
            }
        else
            InitState();
        return fTrue;
        }    
}

void CHangulAutomata::SeparateDJung(LPWORD pJungSung)
{
    WORD wJungSung = pJungSung[0];
    pJungSung[0] = JungSungSep[wJungSung][0];
    pJungSung[1] = JungSungSep[wJungSung][1];
}

void CHangulAutomata::SeparateDJong(LPWORD pJongSung)
{
    WORD wJongSung = pJongSung[0];
    pJongSung[0] = JongSungSep[wJongSung][0];
    pJongSung[1] = JongSungSep[wJongSung][1];
}


///////////////////////////////////////////////////////////////////////////////
//
// Assume : Input wcComp has valid Unicode Hangul value
// (wcComp>0x3130 && wcComp<0x3164) || (wcComp>=0xAC00 && wcComp<0xD7A4)) 
//
BOOL CHangulAutomata2::SetCompositionChar(WCHAR wcComp)
{
    WORD wUnicodeHangulOffset;
    WORD wChosung;
    WORD wJungsung[2], wJongsung[2];

    Dbg(DBGID_SetComp, TEXT("CHangulAutomata2::SetCompositionChar: wcComp = %c(0x%X)"), wcComp, wcComp), 

    InitState();

    wChosung = wJungsung[0] = wJungsung[1] = wJongsung[0] = wJongsung[1] = 0;

    if (wcComp <= UNICODE_HANGUL_COMP_JAMO_END && wcComp >= UNICODE_HANGUL_COMP_JAMO_START) 
        {
        Dbg(DBGID_SetComp, TEXT("COMP_JAMO"));
        // Consonant or vowel ?
        if (wcComp < UNICODE_HANGUL_COMP_JAMO_VOWEL_START) 
            {
            wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_COMP_JAMO_START);
            // Jongsung or Chosung ?
            if (CompJamoMapTable[wUnicodeHangulOffset][1]) 
                {
                wJongsung[0] = CompJamoMapTable[wUnicodeHangulOffset][0];
                SeparateDJong(wJongsung);
                Dbg(DBGID_Automata, TEXT("SetCompositionChar() : wJongsung[0]=%04x, wJongsung[1]=%04x"), wJongsung[0], wJongsung[1]);
                }
            else 
                wChosung = CompJamoMapTable[wUnicodeHangulOffset][0];

            }
        else 
            {
            wJungsung[0] = wcComp - UNICODE_HANGUL_COMP_JAMO_VOWEL_START + 1;
            SeparateDJung(wJungsung);
            }
        } 
    else 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_BASE);
        wChosung = (WORD)( wUnicodeHangulOffset / 
                                    (NUM_OF_JONGSUNG*NUM_OF_JUNGSUNG)) + 1;    // +1 to skip fill code

        wJungsung[0] = (WORD)(wUnicodeHangulOffset / NUM_OF_JONGSUNG
                                                        % NUM_OF_JUNGSUNG) + 1;
        SeparateDJung(wJungsung);

        wJongsung[0] = (WORD)(wUnicodeHangulOffset % NUM_OF_JONGSUNG);    // jongsung already has fill code
        SeparateDJong(wJongsung);
        }

    ///////////////////////////////////////////////////////////////////////////
    // Push process
    if (wChosung) 
        {
        m_Chosung = m_wInternalCode = wChosung;
        m_CurState = 1; // Chosung state
        MakeComposition();
        }

    if (wJungsung[0]) 
        {
        m_Jungsung = m_wInternalCode  = wJungsung[0];
        if (m_Jungsung == _O_ || m_Jungsung == _U_ || m_Jungsung == _EU_) 
            m_CurState = 3; // Double Jungsung possible state
        else
            m_CurState = 2; // Single Jungsung state
        MakeComposition();
        }

    if (wJungsung[1]) 
        {
        DbgAssert(wJungsung[0] == _O_ || wJungsung[0] == _U_ || wJungsung[0] == _EU_);
        m_wInternalCode = wJungsung[1];
        m_Jungsung = FindJunsungComb(wJungsung[0]);
        DbgAssert(m_Jungsung);
        m_CurState = 2; // Jungsung state
        MakeComposition();
        }

    //
    if (wJongsung[0]) 
        {
        m_wInternalCode  = Jong2Cho[wJongsung[0]];
        m_Jongsung = wJongsung[0];

        // KiYeok, Nieun, Rieul and Pieup: Double jongsong possible chars.
        if (m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_)
            m_CurState = 5; // Double Jongsung possible state
        else
            m_CurState = 4; // Single Jongsung state
        MakeComposition();
        }

    if (wJongsung[1]) 
        {
        DbgAssert(m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
                || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_);
        m_wInternalCode = Jong2Cho[wJongsung[1]];
        m_Jongsung = FindJonsungComb(Jong2Cho[wJongsung[0]]);

        DbgAssert(m_Jongsung);
        m_CurState = 4; // Jongsung state
        MakeComposition();
        }
    return fTrue;
}



///////////////////////////////////////////////////////////////////////////////
//    Transition table of 2beolsik hangul automata
const WORD CHangulAutomata2::m_NextStateTbl[8][5] = 
    {
        /////////////////////////////////////////////////////
        //    Sa        Va            Sb        Vb            Sc            State
        {     1,         6,             1,         7,            1        },    // 0 : Start
        {    FIND,     2,            FIND,     3,            FINAL    },    // 1 : Chosung
        {     4,        FINAL,         5,        FINAL,        FINAL    },    // 2 : Single Jungsung
        {     4,        FIND,         5,        FINAL,        FINAL    },    // 3 : Double Jungsung possible
        {    FINAL,    TAKEOVER,    FINAL,    TAKEOVER,    FINAL    },    // 4 : Single Jongsung
        {    FIND,    TAKEOVER,    FIND,    TAKEOVER,    FINAL    },    // 5 : Double Jongsung possible
        {    FINAL,    FINAL,        FINAL,    FINAL,        FINAL    },    // 6 : Single Jungsung(without chosung)
        {    FINAL,    FIND,        FINAL,    FINAL,        FINAL    }    // 7 : Double Jungsung possible(without chosung)
    };
///////////////////////////////////////////////////////////////////////////////

HAutomataReturnState CHangulAutomata2::Input(WORD InternalCode)
{
    WORD wSymbol, wFind;
    InterimStackEntry*    pPrevInterim;

    // Check if hangul key
    if ( !(InternalCode & H_HANGUL) )
        return HAUTO_NONHANGULKEY;    // This keycode need not handled in automata.
                                    // Calling function should handle it properly.

    // Copy internal code to member data
    m_wInternalCode = InternalCode;
    wSymbol = (m_wInternalCode >> 8) & 0x7F;
    m_NextState = m_NextStateTbl[m_CurState][wSymbol];

    switch (m_NextState) 
        {
        // Chosung
        case 1 :    m_Chosung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jungsung
        case 2 : case 3 : case 6 : case 7 :
                    m_Jungsung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jongsung
        case 4 : case 5 :
                    m_Jongsung = Cho2Jong[m_wInternalCode & 0xFF];
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;

        case FINAL :
                    MakeComplete();
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case TAKEOVER :
                    pPrevInterim = InterimStack.Pop();
                    m_Chosung = pPrevInterim->m_wInternalCode & 0xFF;
                    pPrevInterim = InterimStack.Pop();
                    MakeComplete(pPrevInterim->m_wcCode);
                    m_CurState = 1;
                    // FIXED : should call MakeComposition() to push interim state
                    MakeComposition();    
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case FIND :
            switch (m_CurState) 
            {
            case 7 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jungsung = wFind;
                        m_CurState = 6;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else 
                        { 
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            
            case 3 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jungsung = wFind;
                        m_CurState = 2;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else 
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            
            case 5 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jongsung = wFind;
                        m_CurState = 4;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else  
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;

            // Only DJongsung case. same as case 5 except clearing chosung
            case 1: 
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Chosung = 0;
                        m_Jongsung = wFind;
                        m_CurState = 4;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else  
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            }
        }
    // impossible
    DbgAssert(0);
    return HAUTO_IMPOSSIBLE;
}


///////////////////////////////////////////////////////////////////////////////
//    Transition table of 3 beolsik 390 hangul automata
const WORD CHangulAutomata3::m_NextStateTbl[11][6] = 
    {
        ////////////////////////////////////////////////////////////
        //    Sa        Sb        Va            Vb            Sc        Sd            State
        {     1,         2,        7,             8,             9,         10        },    // 0 : Start
        {    FINAL,    FINAL,    3,             4,            FINAL,    FINAL    },    // 1 : Chosung
        {    FINAL,    FIND,    3,             4,            FINAL,    FINAL    },    // 2 : Double Chosung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,         5,         6        },    // 3 : Jungsung
        {    FINAL,    FINAL,    FIND,        FINAL,         5,         6        },    // 4 : Double Jungsung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 5 : Jongsung
        {    FINAL,    FINAL,    FINAL,        FINAL,        FIND,    FIND    },    // 6 : Double Jongsung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 7 : Single Jungsung (without chosung)
        {    FINAL,    FINAL,    FIND,        FINAL,        FINAL,    FINAL    },    // 8 : Double Jungsung possible(without chosung)
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 9 : Single Jongsung(without chosung)
        {    FINAL,    FINAL,    FINAL,        FINAL,        FIND,    FIND    }    // 10 : Double Jongsung possible(without chosung)

    };
///////////////////////////////////////////////////////////////////////////////

HAutomataReturnState CHangulAutomata3::Input(WORD InternalCode)
{
    WORD wSymbol, wFind;
    InterimStackEntry*    pPrevInterim;

    // Check if hangul key
    if (!(InternalCode & H_HANGUL))
        return HAUTO_NONHANGULKEY;    // This keycode need not handled in automata.
                                    // Calling function should handle it properly.

    // Get internal code from keycode
    m_wInternalCode = InternalCode;
    wSymbol = (m_wInternalCode >> 8) & 0x7F;
    m_NextState = m_NextStateTbl[m_CurState][wSymbol];

    switch (m_NextState) 
        {
        // Chosung
        case 1 : case 2 :    
                    m_Chosung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jungsung
        case 3 : case 4 : case 7 : case 8 :
                    m_Jungsung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jongsung
        case 5 : case 6 : case 9 : case 10 :
                    m_Jongsung = m_wInternalCode & 0xFF;
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        case FINAL :
                    MakeComplete();
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case FIND :
            switch (m_CurState) 
            {
            case 8 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jungsung = wFind;
                        m_CurState = 7;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else 
                    { 
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 4 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jungsung = wFind;
                        m_CurState = 3;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else 
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 6 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jongsung = wFind;
                        m_CurState = 5;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 10 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jongsung = wFind;
                        m_CurState = 7;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;

            case 2 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindChosungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Chosung = wFind;
                        m_CurState = 1;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            }
        }

    // impossible
    DbgAssert(0);
    return HAUTO_IMPOSSIBLE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Assume : Input wcComp has valid Unicode Hangul value
// (wcComp>0x3130 && wcComp<0x3164) || (wcComp>=0xAC00 && wcComp<0xD7A4)) 
//
BOOL CHangulAutomata3::SetCompositionChar(WCHAR wcComp)
{
    WORD wUnicodeHangulOffset;
    WORD wChosung;
    WORD wJungsung[2], wJongsung[2];

    wChosung = wJungsung[0] = wJungsung[1] = wJongsung[0] = wJongsung[1] = 0;
    InitState();

    if (wcComp <= UNICODE_HANGUL_COMP_JAMO_END && wcComp >= UNICODE_HANGUL_COMP_JAMO_START) 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_COMP_JAMO_START);
        
        // Consonant or vowel ?
        if (wcComp < UNICODE_HANGUL_COMP_JAMO_VOWEL_START) 
            {
            // Jongsung or Chosung ?
            if (CompJamoMapTable[wUnicodeHangulOffset][1]) 
                {
                wJongsung[0] = CompJamoMapTable[wUnicodeHangulOffset][0];
                SeparateDJong(wJongsung);
                }
            else 
                wChosung = CompJamoMapTable[wUnicodeHangulOffset][0];

            }
        else 
            {
            wJungsung[0] = wcComp - UNICODE_HANGUL_COMP_JAMO_VOWEL_START + 1;
            SeparateDJung(wJungsung);
            }
        } 
    else 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_BASE);
        wChosung = (WORD)( wUnicodeHangulOffset / 
                                    (NUM_OF_JONGSUNG*NUM_OF_JUNGSUNG)) + 1;

        wJungsung[0] = (WORD)(wUnicodeHangulOffset / NUM_OF_JONGSUNG
                                                        % NUM_OF_JUNGSUNG) + 1;
        SeparateDJung(wJungsung);

        wJongsung[0] = (WORD)(wUnicodeHangulOffset % NUM_OF_JONGSUNG);
        SeparateDJong(wJongsung);
        }

    ///////////////////////////////////////////////////////////////////////////
    // Push process
    if (wChosung) 
        {
        m_Chosung = m_wInternalCode = wChosung;
        // KiYeok, TiKeut, Pieup, Sios, Cieuc
        if (m_Chosung == _KIYEOK_ || m_Chosung == _TIKEUT_ 
           || m_Chosung == _PIEUP_|| m_Chosung == _SIOS_ || m_Chosung == _CIEUC_)
            m_CurState = 2; // Double Chosung possible state
        else
            m_CurState = 1; // Chosung state
        MakeComposition();
        }

    if (wJungsung[0]) 
        {
        m_Jungsung = m_wInternalCode  = wJungsung[0];
        if (m_Jungsung == _O_ || m_Jungsung == _U_ || m_Jungsung == _EU_) 
            m_CurState = 4; // Double Jungsung possible state
        else
            m_CurState = 3; // Single Jungsung state
        MakeComposition();
        }

    if (wJungsung[1]) 
        {
        DbgAssert(wJungsung[0] == _O_|| wJungsung[0] == _U_ || wJungsung[0] == _EU_);
        m_wInternalCode = wJungsung[1];
        m_Jungsung = FindJunsungComb(wJungsung[0]);
        DbgAssert(m_Jungsung);
        m_CurState = 3; // Jungsung state
        MakeComposition();
        }

    //
    if (wJongsung[0]) 
        {
        m_wInternalCode  = wJongsung[0];
        m_Jongsung = wJongsung[0];
        // KiYeok, Nieun, Rieul, Pieup and Sios: Double jongsong possible chars.
        if (m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_ || m_Jongsung == _JONG_SIOS_)
            m_CurState = 6; // Double Jongsung possible state
        else
            m_CurState = 5; // Single Jongsung state
        MakeComposition();
        }

    if (wJongsung[1]) 
        {
        DbgAssert(m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_ || m_Jongsung == _JONG_SIOS_);

        m_wInternalCode = wJongsung[1];
        m_Jongsung = FindJonsungComb(wJongsung[0]);

        DbgAssert(m_Jongsung);
        m_CurState = 5; // Jongsung state
        MakeComposition();
        }
    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\hjmode.h ===
//
// HJMODE.H
//

#if !defined (__HJMODE_H__INCLUDED_)
#define __HJMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class HJMode : public CCicButton
{
public:
    HJMode(CToolBar *ptb);
    ~HJMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:

	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __HJMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\imc.h ===
/****************************************************************************
	IMC.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IME Context abstraction class
	
	History:
	20-JUL-1999 cslim       Created
*****************************************************************************/

#if !defined(_IMC_H__INCLUDED_)
#define _IMC_H__INCLUDED_

#include "gdata.h"

// No GCS_COMPCLAUSE
#define GCS_COMP_KOR (GCS_COMPSTR|GCS_COMPATTR)

class CIMECtx 
{
// Ctor and Dtor
public:
	CIMECtx(HIMC hIMC);
	~CIMECtx();

// CIMECtx Methods
public:
	CIMEData* GetGData();
	LPIMEDATA GetGDataRaw();
	CHangulAutomata* GetAutomata();
	HIMC  GetHIMC();
	HWND  GetAppWnd();
	HWND  GetUIWnd();
	VOID  SetUIWnd(HWND hUIWnd);
	HIMCC GetHCandInfo();
	LPCANDIDATEINFO GetPCandInfo();

	HIMCC GetHCompStr();
	HIMCC GetHMsgBuf();
	BOOL  IsOpen();
	VOID  SetOpen(BOOL fOpen);
	VOID  SetStatusWndPos(POINT &pt);
	VOID  GetStatusWndPos(POINT* pPt);
	DWORD SetConversionMode(DWORD dwConvMode);
	DWORD GetConversionMode();
	DWORD SetSentenceMode(DWORD dwSentMode);
	DWORD GetSentenceMode();

	LOGFONT* GetLogFont();

	// Initial status
	VOID SetInitStatus(DWORD dwInitState);
	VOID GetInitStatus(LPDWORD pdwInitState);

	// Composition string
	VOID SetCompositionStr(WCHAR wch);
	WCHAR GetCompositionStr();
	WCHAR GetCompBufStr();
	VOID SetCompBufStr(WCHAR wch);
	VOID SetCompBufStr(CHAR chHigh, CHAR chLow);
	VOID ClearCompositionStrBuffer();
	VOID SetResultStr(WCHAR* pwSz);
	VOID SetResultStr(WCHAR wch1, WCHAR wch2=0);
	VOID AppendResultStr(WCHAR wch);
	VOID FinalizeCurCompositionChar();

	VOID ResetComposition();
	VOID StoreComposition();
	BOOL IsCompositionString();
	DWORD GetCompBufLen();
	VOID SetStartComposition(BOOL fStart);
	VOID SetEndComposition(BOOL fEnd);
	//LPCOMPOSITIONSTRING GetCompositionStrBuffer() { DbgAssert(m_pCompStr!=NULL); return m_pCompStr; }
	
	// Cand string
	VOID ResetCandidate();
	VOID AppendCandidateStr(WCHAR wcCand, LPWSTR wszMeaning);
	WCHAR GetCandidateStr(INT iIdx);
	LPWSTR GetCandidateMeaningStr(INT iIdx);
	INT GetCandidateCount();
	VOID StoreCandidate();
	enum MSG_CAND { MSG_NONE = 0, MSG_OPENCAND, MSG_CLOSECAND, MSG_CHANGECAND };
	VOID SetCandidateMsg(UINT uiMsg);
	VOID SetCandStrSelection(DWORD dwSel);

	// Composition form
	VOID GetCompositionForm(LPCOMPOSITIONFORM* ppCompForm);
	VOID SetCompositionFormStyle(DWORD dwStyle);
	DWORD GetCompositionFormStyle();
	VOID SetCompositionFormPos(POINT pt);
	VOID GetCompositionForm(POINT* pPt);
	VOID GetCompositionForm(RECT* pRc);

	// Cand Form
	DWORD GetCandidateFormIndex(INT iIdxCand);
	VOID SetCandidateFormIndex(INT iIdx, INT iIdxCand = 0);
	DWORD GetCandidateFormStyle(INT iIdxCand = 0);
	VOID SetCandidateFormStyle(DWORD dwStyle, INT iIdxCand = 0);
	VOID GetCandidateForm(RECT* pRc, INT iIdxCand = 0);
	VOID SetCandidateFormArea(RECT* pRc, INT iIdxCand = 0);
	VOID GetCandidateFormPos(POINT* pPt, INT iIdxCand = 0);
	VOID SetCandidateFormPos(POINT pt, INT iIdxCand = 0);
	/////////////////////////////////////////////////
	//  MSG buffer structure support
	VOID SetTransMessage(LPTRANSMSGLIST pMessage);
	VOID ResetMessage();
	INT  GetMessageCount();
	BOOL FinalizeMessage();
	VOID FlushCandMessage();
	BOOL GenerateMessage();
	INT  AddMessage(UINT uiMessage, WPARAM wParam = 0, LPARAM lParam = 0);
	VOID AddKeyDownMessage(WPARAM wParam = 0, LPARAM lParam = 0);

	/////////////////////////////////////////////////
	//  Unicode environment
	BOOL IsUnicodeEnv(VOID);
	VOID SetUnicode(BOOL fUnicode);
	VOID NonUnicodeConversion(WCHAR* pwStr, INT* pcchStr, CHAR* pwOStr, BYTE* pbAtr, INT* pcchAtr, BYTE* pbOAtr, DWORD* pdwCls, INT* pcchCls, DWORD* pdwOCls);

	VOID SetProcessKeyStatus(BOOL fSet);
	BOOL IsProcessKeyStatus(VOID);

	// new and delete operator overloading
	void* operator new(size_t size);
	void  operator delete(void *lp);

// Implementation
private:
	VOID InitCompStrStruct();
	/////////////////////////////////////////////////
	//  Private status
	VOID ResetGCS();
	DWORD GetGCS();
	VOID DelGCS(DWORD dwGCS);
	VOID AddGCS(DWORD dwGCS);
	DWORD ValidateGCS();

	void ClearCandMeaningArray();

// Implementation
protected:
	CIMEData* 	m_pCIMEData;
	
// Internal data
private:
	// IME Context handle and pointer
	HIMC 			m_hIMC;
	LPINPUTCONTEXT	m_pIMC;

    // hangul Automata. Created once and will be shared between all apps.
	CHangulAutomata*   m_rgpHangulAutomata[NUM_OF_IME_KL];

	// Unicode flag
	BOOL 			m_fUnicode;	// TRUE=UNICODE env. FALSE=NON UNICODE env

	// Composition string support
	LPCOMPOSITIONSTRING	m_pCompStr;

	// Candidate list support
	LPCANDIDATEINFO		m_pCandInfo;
	INT 				m_iciCandidate;
	LPWSTR				m_pCandStr;
	LPWSTR*				m_rgpCandMeaningStr;
	
	// Msg generation support
	BOOL m_fEndComposition;		// don't call AddMes( WM_IME_ENDCOMPOSITION) now
	BOOL m_fStartComposition;	// don't call AddMes( WM_IME_STARTCOMPOSITION) now
//	BOOL m_fStartCompMsgSent;
	UINT m_uiSendCand;
	BOOL m_fKeyProcessing;		// TRUE while ImeProcessKey()

	// REVIEW: see KKIME ui.cpp SetOpenStatusWindow( TRUE );
	BOOL m_fOpenStatusWindow;	// open status window status

	// for WM_IME_COMPOSITION flag
	DWORD m_dwGCS;			
	/////////////////////////////////////////////////
	//  Composition string buffer
	WCHAR m_wcComp;							// Comp string always 1 char long
	WCHAR m_wzResult[nMaxResultStrLen + 2];	// Result string maximum 2 chars + one null + one extra wchar
	// ANSI Composition string
	UCHAR m_szComp[nMaxCompStrLen*2 + 2]; 	// 2: one null + extra byte
	UCHAR m_szResult[nMaxResultStrLen*2 + 4]; // 2: one null + extra bytes


	/////////////////////////////////////////////////
	//  MSG buffer structure support
	UINT 			m_uiMsgCount;
	LPTRANSMSG		m_pMessage;
	LPTRANSMSGLIST	m_pTransMessage;	// for ToAsciiEx

	// WM_IME_KEYDOWN support
	BOOL			m_fKeyDown;
	WPARAM			m_wParamKeyDown;
	LPARAM			m_lParamKeyDown;
	
	/////////////////////////////////////////////////
	// Private status
	DWORD m_dwCandInfoSize;
	DWORD m_dwMessageSize;
};
typedef CIMECtx* PCIMECtx;


//////////////////////////////////////////////////////////////////////////////
// Inline functions
__inline
CIMEData* CIMECtx::GetGData()
{
	return m_pCIMEData;
}

__inline
LPIMEDATA CIMECtx::GetGDataRaw()
{
	return m_pCIMEData->GetGDataRaw();
}

__inline
CHangulAutomata* CIMECtx::GetAutomata()
{
	AST_EX(m_pCIMEData != NULL);
	if (m_pCIMEData)
		return m_rgpHangulAutomata[m_pCIMEData->GetCurrentBeolsik()];
	else
		return m_rgpHangulAutomata[0];
}

__inline
HIMC CIMECtx::GetHIMC()
{
	return m_hIMC;
}

__inline
HWND CIMECtx::GetAppWnd()	// m_hIMC->hWnd
{
	AST_EX(m_pIMC != NULL);
	if (m_pIMC == NULL)
		return (HWND)0;
	return m_pIMC->hWnd;
}

__inline
HIMCC CIMECtx::GetHCandInfo()
{
	AST_EX(m_pIMC != NULL);
	AST_EX(m_pIMC->hCandInfo != (HIMCC)0);
	if (m_pIMC == NULL)
		return NULL;
	return m_pIMC->hCandInfo;
}

__inline
LPCANDIDATEINFO CIMECtx::GetPCandInfo() 
{ 
	return m_pCandInfo; 
}

__inline
HIMCC CIMECtx::GetHCompStr()
{
	AST_EX(m_pIMC != NULL);
	AST_EX(m_pIMC->hCompStr != (HIMCC)0);
	if (m_pIMC == NULL)
		return NULL;
	return m_pIMC->hCompStr;
}

__inline
HIMCC CIMECtx::GetHMsgBuf()
{
	AST_EX(m_pIMC != NULL);
	AST_EX(m_pIMC->hMsgBuf != (HIMCC)0);
	if (m_pIMC == NULL)
		return NULL;
	return m_pIMC->hMsgBuf;
}

__inline
VOID  CIMECtx::SetOpen(BOOL fOpen)
{
	m_pIMC->fOpen = fOpen;
}

__inline
BOOL CIMECtx::IsOpen()
{
	// sometime IMM sets 0xffffffff as TRUE
	if (m_pIMC == NULL) 
		return fFalse;
	return (m_pIMC->fOpen ? fTrue : fFalse);
}

__inline
VOID CIMECtx::SetStatusWndPos(POINT &pt)
{
	m_pIMC->ptStatusWndPos = pt;
}

__inline
VOID CIMECtx::GetStatusWndPos(POINT* pPt)
{
	*pPt = m_pIMC->ptStatusWndPos;
}

__inline
DWORD CIMECtx::SetConversionMode(DWORD dwConvMode)
{
	DWORD dwPrevConv = m_pIMC->fdwConversion;
	m_pIMC->fdwConversion = dwConvMode;
	return dwPrevConv;	// return previous conversion mode
}

__inline
DWORD CIMECtx::GetConversionMode()
{
	return m_pIMC->fdwConversion;
}

__inline
DWORD CIMECtx::SetSentenceMode(DWORD dwSentMode)
{
	DWORD dwPrevSent = m_pIMC->fdwSentence;
	m_pIMC->fdwSentence = dwSentMode;
	return dwPrevSent;	// return previous sentence mode
}

__inline
DWORD CIMECtx::GetSentenceMode()
{
	return m_pIMC->fdwSentence;
}

__inline
LOGFONT* CIMECtx::GetLogFont()
{
	return (&(m_pIMC->lfFont.A));
}

// Composition form
__inline
VOID CIMECtx::GetCompositionForm(LPCOMPOSITIONFORM *ppCompForm)
{
	*ppCompForm = &m_pIMC->cfCompForm;
}

__inline
VOID CIMECtx::SetCompositionFormStyle(DWORD dwStyle)
{
	m_pIMC->cfCompForm.dwStyle = dwStyle;
}

__inline
DWORD CIMECtx::GetCompositionFormStyle()
{
	return m_pIMC->cfCompForm.dwStyle;
}

__inline
VOID CIMECtx::SetCompositionFormPos(POINT pt)
{
	m_pIMC->cfCompForm.ptCurrentPos = pt;
}

__inline
VOID CIMECtx::GetCompositionForm(POINT* pPt)
{
	pPt->x = m_pIMC->cfCompForm.ptCurrentPos.x;
	pPt->y = m_pIMC->cfCompForm.ptCurrentPos.y;
}

__inline
VOID CIMECtx::GetCompositionForm(RECT* pRc)
{
	CopyRect(pRc, &m_pIMC->cfCompForm.rcArea);
}


__inline
VOID CIMECtx::SetInitStatus(DWORD dwInitState)
{
	m_pIMC->fdwInit = dwInitState;
}

__inline
VOID CIMECtx::GetInitStatus(LPDWORD pdwInitState)
{
	*pdwInitState = m_pIMC->fdwInit;
}

__inline
VOID CIMECtx::SetCompositionStr(WCHAR wch)
{
	DbgAssert(wch != 0);
	m_wcComp = wch;
	AddGCS(GCS_COMPSTR);
}

__inline
WCHAR CIMECtx::GetCompositionStr()
{
	return m_wcComp;
}

// WARNING: This function will set raw data to comp buffer directly. 
// Pls. very careful to use this function. It could break everything.
__inline
VOID  CIMECtx::SetCompBufStr(WCHAR wch)
{
	DbgAssert(IsUnicodeEnv() == fTrue);
	m_pCompStr->dwCompStrLen = m_pCompStr->dwCompAttrLen = 1;
	*((LPBYTE)m_pCompStr + m_pCompStr->dwCompAttrOffset) = ATTR_INPUT;
	*(LPWSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset) = wch;
}

// For ANSI conversion
__inline
VOID  CIMECtx::SetCompBufStr(CHAR chHigh, CHAR chLow)
{
	DbgAssert(IsUnicodeEnv() == fFalse);
	m_pCompStr->dwCompStrLen  = 2;
	m_pCompStr->dwCompAttrLen = 1;
	*((LPBYTE)m_pCompStr + m_pCompStr->dwCompAttrOffset) = ATTR_INPUT;
	*(LPSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset) = chHigh;
	*(LPSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset + 1) = chLow;
}

// WARNING: This function will set raw data to comp buffer directly. 
// Pls. very careful to use this function. It could break everything.
__inline
VOID CIMECtx::ClearCompositionStrBuffer()
{
	Dbg(DBGID_Key, TEXT("ClearCompositionStrBuffer():"));

	if (m_pCompStr)
		{
		m_pCompStr->dwCompStrLen = m_pCompStr->dwCompAttrLen = 0;
		*(LPWSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset) = L'\0';
		*((LPBYTE)m_pCompStr + m_pCompStr->dwCompAttrOffset) = 0;
		}
}

__inline
VOID CIMECtx::SetResultStr(LPWSTR pwSz)
{
	DbgAssert(pwSz != NULL);
	m_wzResult[0] = *pwSz++;
	m_wzResult[1] = *pwSz;
	AddGCS(GCS_RESULTSTR);
}

__inline
VOID CIMECtx::SetResultStr(WCHAR wch1, WCHAR wch2)
{
	DbgAssert(wch1 != 0);
	Dbg(DBGID_Key, "CIMECtx::SetResultStr - wch1 = 0x%04X, wch2 = 0x%04X", wch1, wch2);
	m_wzResult[0] = wch1;
	m_wzResult[1] = wch2;
	AddGCS(GCS_RESULTSTR);
}

__inline
VOID CIMECtx::AppendResultStr(WCHAR wch)
{
	DbgAssert(wch != 0);
	if (m_wzResult[0] == L'\0')
		m_wzResult[0] = wch;
	else
		m_wzResult[1] = wch;
	AddGCS(GCS_RESULTSTR);
}

__inline
VOID CIMECtx::FinalizeCurCompositionChar()
{
	GetAutomata()->MakeComplete();
	SetResultStr(GetAutomata()->GetCompleteChar());
	SetEndComposition(fTrue);
	if (!IsProcessKeyStatus())
		StoreComposition();
}

__inline
VOID CIMECtx::ResetComposition()
{
	m_wcComp = L'\0';
	ZeroMemory(m_wzResult, sizeof(m_wzResult));
}

__inline
BOOL CIMECtx::IsCompositionString()
{
	return (m_wcComp ? fTrue : fFalse);
}

__inline
DWORD CIMECtx::GetCompBufLen()
{
	if (GetHCompStr() != NULL)
		return (m_pCompStr->dwCompStrLen);
	else
		return 0;
}

__inline
VOID CIMECtx::SetStartComposition(BOOL fStart)
{
	m_fStartComposition = fStart;
}

__inline
VOID CIMECtx::SetEndComposition(BOOL fEnd)
{
	m_fEndComposition = fEnd;
}

__inline
VOID CIMECtx::ResetCandidate()
{
	ClearCandMeaningArray();
	m_iciCandidate = 0;
}

__inline
INT CIMECtx::GetCandidateCount()
{
	return m_iciCandidate;
}

__inline
VOID CIMECtx::SetCandidateMsg(UINT uiMsg)
{
	m_uiSendCand = uiMsg;
}

__inline
VOID CIMECtx::SetCandStrSelection(DWORD dwSel)
{
	LPCANDIDATELIST	lpCandList;
	if (m_pCandInfo == NULL || m_pCandInfo->dwCount == 0)
		{
		DbgAssert(0);
		return;
		}
	lpCandList = (LPCANDIDATELIST)((LPBYTE)m_pCandInfo + sizeof(CANDIDATEINFO));
	lpCandList->dwPageStart = (dwSel / lpCandList->dwPageSize) * lpCandList->dwPageSize;
    lpCandList->dwSelection = dwSel;
}

/////////////////////////////////////////////////
// Candidate form
__inline
DWORD CIMECtx::GetCandidateFormIndex(INT iIdxCand)
{
	return m_pIMC->cfCandForm[iIdxCand].dwIndex;
}

__inline
VOID CIMECtx::SetCandidateFormIndex(INT iIdx, INT iIdxCand)
{
	m_pIMC->cfCandForm[iIdxCand].dwIndex = (DWORD)iIdx;
}

__inline
VOID CIMECtx::SetCandidateFormStyle(DWORD dwStyle, INT iIdxCand)
{
	m_pIMC->cfCandForm[iIdxCand].dwStyle = dwStyle;
}

__inline
DWORD CIMECtx::GetCandidateFormStyle(INT iIdxCand)
{
	return m_pIMC->cfCandForm[iIdxCand].dwStyle;
}

__inline
VOID CIMECtx::GetCandidateForm(RECT* pRc, INT iIdxCand)
{
	CopyRect( pRc, &m_pIMC->cfCandForm[iIdxCand].rcArea );
}

__inline
VOID CIMECtx::SetCandidateFormArea(RECT* pRc, INT iIdxCand)
{
	CopyRect( &m_pIMC->cfCandForm[iIdxCand].rcArea, pRc );
}

__inline
VOID CIMECtx::GetCandidateFormPos(POINT* pPt, INT iIdxCand)
{
	pPt->x = m_pIMC->cfCandForm[iIdxCand].ptCurrentPos.x;
	pPt->y = m_pIMC->cfCandForm[iIdxCand].ptCurrentPos.y;
}

__inline
VOID CIMECtx::SetCandidateFormPos(POINT pt, INT iIdxCand)
{
	m_pIMC->cfCandForm[iIdxCand].ptCurrentPos = pt;
}

/////////////////////////////////////////////////
//  MSG buffer structure support
__inline
VOID CIMECtx::SetTransMessage(LPTRANSMSGLIST pMessage)
{
	m_pTransMessage = pMessage;
}

__inline
VOID CIMECtx::ResetMessage()
{
	m_uiMsgCount = 0;
	m_pTransMessage = NULL; // trans message now NULL
	m_fEndComposition = fFalse;
	m_fStartComposition = fFalse;
	m_uiSendCand = 0;
	m_fKeyDown = fFalse;
}

__inline
INT CIMECtx::GetMessageCount()
{
	return m_uiMsgCount;
}

__inline
VOID CIMECtx::AddKeyDownMessage(WPARAM wParam, LPARAM lParam)
{
	m_fKeyDown = fTrue;
	m_wParamKeyDown = wParam;
	m_lParamKeyDown = lParam;
}

/////////////////////////////////////////////////
//  Unicode environment
__inline
BOOL CIMECtx::IsUnicodeEnv(VOID)
{
	return m_fUnicode;
}

/////////////////////////////////////////////////
//  Private status
__inline
VOID CIMECtx::ResetGCS(VOID)
{
	m_dwGCS = 0;
}

__inline
DWORD CIMECtx::GetGCS(VOID)
{
	return m_dwGCS;
}

__inline
VOID CIMECtx::DelGCS(DWORD dwGCS)
{
	m_dwGCS &= ~dwGCS;
}

__inline
VOID CIMECtx::AddGCS(DWORD dwGCS)
{
	m_dwGCS |= dwGCS;
}

__inline
DWORD CIMECtx::ValidateGCS(VOID)
{
	if (m_wcComp == 0)
		DelGCS(GCS_COMP_KOR);

	if (m_wzResult[0] == 0)
		DelGCS(GCS_RESULT);

	return m_dwGCS;
}

__inline
VOID CIMECtx::SetUnicode(BOOL fUnicode)
{
	m_fUnicode = fUnicode;
}
	
__inline
VOID CIMECtx::SetProcessKeyStatus(BOOL fSet)
{
	m_fKeyProcessing = fSet;
}

__inline
BOOL CIMECtx::IsProcessKeyStatus(VOID)
{
	return m_fKeyProcessing;
}

__inline
void* CIMECtx::operator new(size_t size)
{
	return (void*)GlobalAllocPtr(GHND, size);
}

__inline
void CIMECtx::operator delete(void* pv)
{
	if (pv)
		GlobalFreePtr(pv);
}


#endif // _IMC_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\hjmode.cpp ===
/****************************************************************************
   HJMODE.CPP : HJMode class managing Hanja button on the Cicero Toolbar

   History:
      25-FEB-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "hjmode.h"
#include "gdata.h"
#include "winex.h"
#include "resource.h"

// {F7410340-28E0-4aeb-ADBC-C579FD00B43D}
const GUID GUID_LBI_KORIME_HJMODE = 
{
    0xf7410340, 
    0x28e0, 
    0x4aeb,
    { 0xad, 0xbc, 0xc5, 0x79, 0xfd, 0x0, 0xb4, 0x3d }
};

/*---------------------------------------------------------------------------
    HJMode::HJMode
---------------------------------------------------------------------------*/
HJMode::HJMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    szText[0] = L'\0';
    
    m_pTb = ptb;

    // Set Add/Remove text and tootip text
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_TT_HANJA_CONV, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_SYSTEMLANGBARITEM_KEYBOARD, 
                GUID_LBI_KORIME_HJMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_TEXTCOLORICON, 
                220, 
                szText);
    SetToolTip(szText);

    // Set button text
    szText[0] = L'\0';
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_BUTTON_HANJA_CONV, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}



/*---------------------------------------------------------------------------
    HJMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) HJMode::Release()
{
    long cr;

    cr = --m_cRef;
    DbgAssert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    HJMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI HJMode::GetIcon(HICON *phIcon)
{
    UINT uiIcon;

    if (IsHighContrastBlack())
        uiIcon = IDI_CMODE_HANJAW;
    else
        uiIcon = IDI_CMODE_HANJA;

    *phIcon = (HICON)LoadImage(vpInstData->hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);

    return S_OK;
}

/*---------------------------------------------------------------------------
    HJMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI HJMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    HJMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI HJMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
    HJMode::OnLButtonUp
---------------------------------------------------------------------------*/
HRESULT HJMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    keybd_event(VK_HANJA, 0, 0, 0);
    keybd_event(VK_HANJA, 0, KEYEVENTF_KEYUP, 0);

    return S_OK;
}


/*---------------------------------------------------------------------------
    HJMode::OnRButtonUp
---------------------------------------------------------------------------*/
HRESULT HJMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
/*
    HMENU hMenu;
    DWORD dwConvMode;

    hMenu = CreatePopupMenu();
    char *pszStatus = (GetCMode() & TIP_JUNJA_MODE) ? "Banja mode" : "Junja mode";
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, pszStatus);
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 0, "Cancel");

    int nRet = TrackPopupMenuEx(hMenu, 
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, m_pTb->GetOwnerWnd(), NULL);
    switch (nRet)
    {
        case 1: 
            dwConvMode = GetCMode();

            // Toggle Full/Half mode
            if (dwConvMode & TIP_JUNJA_MODE)
                dwConvMode &= ~TIP_JUNJA_MODE;
            else
                dwConvMode |= TIP_JUNJA_MODE;

            SetCMode(dwConvMode);
            break;
    }

    DestroyMenu(hMenu);
*/
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\imcsub.cpp ===
/****************************************************************************
    IMCSUB.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Subroutines related to HIMC
    !!! NEED FULL REVIEW ALL FUNCTIONS NEED TO USE AND WORKS CORRECTLY !!!
    
    History:
    21-JUL-1999 cslim       Created(Borrowed almost part from KKIME)
*****************************************************************************/

#include "precomp.h"
#include "imc.h"
#include "imcsub.h"
#include "debug.h"

CIMECtx* GetIMECtx(HIMC hIMC)
{
    CIMECtx* pImeCtx;
    CIMCPriv ImcPriv;
    
    if (hIMC == (HIMC)0)
        return NULL;

    if (ImcPriv.LockIMC(hIMC) == fFalse) 
        {
        return NULL;
        }

    if (ImcPriv->hIMC != hIMC) 
        {
        AST(ImcPriv->hIMC == hIMC);
        return NULL;
        }

    pImeCtx = ImcPriv->pImeCtx;

    if (pImeCtx == NULL) 
        {
        AST(pImeCtx != NULL);
        return NULL;
        }

    if (pImeCtx->GetHIMC() != hIMC)
        {
        AST(pImeCtx->GetHIMC() == hIMC);
        return NULL;
        }

    if (ImcPriv->pIPoint == NULL)
        {
        AST(ImcPriv->pIPoint != NULL);
        return NULL;
        }

    return pImeCtx;
}

//IImePadInternal* GetImePad( HIMC hIMC )
//{
    //
    // new : because, IMEPad is per process object
    //
    //Toshiak
//    return GetIImePadInThread();
//    hIMC; //no ref;
//}


BOOL CloseInputContext(HIMC hIMC)
{
    Dbg(DBGID_API, "CloseInputContext::hiMC == %x .\r\n", hIMC);

    if (hIMC) 
        {
        // Because ImeSelect has not been called from IMM on WIN95,
        // clean up hIMC private buffer here.
        CIMCPriv ImcPriv(hIMC);
        IMCPRIVATE* pImcPriv;
        pImcPriv = ImcPriv;
        if (pImcPriv) 
            {
            Dbg(DBGID_API, "CloseInputContext::ImeSelect has not called yet.\r\n");

            // REVIEW:
            if (pImcPriv->pIPoint)
                {
                Dbg(DBGID_API, "CloseInputContext::IPoint Release\r\n");
                pImcPriv->pIPoint->Release();
                pImcPriv->pIPoint = NULL;
                }
            pImcPriv->hIMC = (HIMC)0;
            }
        ImcPriv.ResetPrivateBuffer();
        return fFalse;
        }
    return fTrue;
}

VOID SetPrivateBuffer(HIMC hIMC, VOID* pv, DWORD dwSize)
{
    VOID* pvPriv;
    DWORD dwCurrentSize;
    LPINPUTCONTEXT pCtx;
    
    if (hIMC == NULL)
        return;

    pCtx = (INPUTCONTEXT*)OurImmLockIMC(hIMC);
    if (pCtx == NULL || pCtx->hPrivate == NULL)
        return;

    dwCurrentSize = OurImmGetIMCCSize(pCtx->hPrivate);

    // Check if need to re-allocate
    if (dwCurrentSize < dwSize) 
        { 
        OurImmUnlockIMCC( pCtx->hPrivate );
        pCtx->hPrivate = OurImmReSizeIMCC(pCtx->hPrivate, dwSize);
        AST_EX(pCtx->hPrivate != (HIMCC)0);
        if (pCtx->hPrivate == (HIMCC)0)
            return;
        pvPriv = (VOID*)OurImmLockIMCC(pCtx->hPrivate);
        } 
    else 
        {
        // already sized
        pvPriv = (VOID*)OurImmLockIMCC(pCtx->hPrivate);
        }

    if (pvPriv)
        CopyMemory(pvPriv, pv, dwSize);

    OurImmUnlockIMCC(pCtx->hPrivate);
    OurImmUnlockIMC(hIMC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\imcsub.h ===
/****************************************************************************
	IMCSUB.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Subroutines related to HIMC.
	!!! NEED FULL REVIEW ALL FUNCTIONS NEED TO USE AND WORKS CORRECTLY !!!
	
	History:
	21-JUL-1999 cslim       Created(Borrowed almost part from KKIME)
*****************************************************************************/

#if !defined (_IMCSUB_H__INCLUDED_)
#define _IMCSUB_H__INCLUDED_

#include "ipoint.h"

//////////////////////////////////////////////////////////////////////////////
// IME private data for each context
typedef struct tagIMCPRIVATE 
{
	HIMC hIMC;
	// DWORD        fdwImeMsg;      // what messages should be generated
    // DWORD        dwCompChar;     // wParam of WM_IME_COMPOSITION
	// DWORD        dwCmpltChar;    // wParam of WM_IME_COMPOSITION with GCS_RESULTSTR
    // DWORD        fdwGcsFlag;     // lParam for WM_IME_COMPOSITION
    IImeIPoint1* pIPoint;
	CIMECtx*	 pImeCtx;         // same as pIPoint->GetImeCtx(x)
} IMCPRIVATE ;
typedef IMCPRIVATE	*PIMCPRIVATE;
typedef IMCPRIVATE	*LPIMCPRIVATE;

/*
typedef struct tagIMCPRIVATE 
{
	HIMC hIMC;
	IImeKbd*			pImeKbd;
	IImeIPoint*			pIPoint;
	IImeConvert*		pConvert;
	IImePadInternal* 	pImePad;
	IMECtx*				pImeCtx;	// same as pIPoint->GetImeCtx( x )
} IMCPRIVATE;
*/

PUBLIC VOID SetPrivateBuffer(HIMC hIMC, VOID* pv, DWORD dwSize);
PUBLIC BOOL CloseInputContext(HIMC hIMC);

//////////////////////////////////////////////////////////////////////////////
// Inline functions

PUBLIC CIMECtx* GetIMECtx(HIMC hIMC);	// in api.cpp

// CIMCPriv class Handle IME Private buffer
class CIMCPriv
{
public:
    CIMCPriv() { m_hIMC = NULL; m_inputcontext = NULL; m_priv = NULL; }
    CIMCPriv(HIMC hIMC);
    ~CIMCPriv() { UnLockIMC(); }

public:
    BOOL LockIMC(HIMC hIMC);
    void UnLockIMC();
    void ResetPrivateBuffer();

    operator LPIMCPRIVATE()      { return m_priv; }
    LPIMCPRIVATE operator->() { AST(m_priv != NULL); return m_priv; }

private:
    HIMC m_hIMC;
    LPINPUTCONTEXT m_inputcontext;
    LPIMCPRIVATE   m_priv;
};

//
// Inline functions
//
inline CIMCPriv::CIMCPriv(HIMC hIMC)
{
    AST(hIMC != NULL);
    m_hIMC = NULL;
    m_inputcontext = NULL;
    m_priv = NULL;

    LockIMC(hIMC);    
}

inline BOOL CIMCPriv::LockIMC(HIMC hIMC)
{
    if (hIMC != NULL)
        {
        m_hIMC = hIMC;
        m_inputcontext = (LPINPUTCONTEXT)OurImmLockIMC(hIMC);
        if (m_inputcontext)
            {
            // hIMC->hPrivate was not allocated properly. e.g ImeSelect(TRUE)was not called.
            if (OurImmGetIMCCSize(m_inputcontext->hPrivate) != sizeof(IMCPRIVATE))
                return fFalse;

            m_priv = (LPIMCPRIVATE)OurImmLockIMCC(m_inputcontext->hPrivate);
            }
        }

    return (hIMC != NULL && m_priv != NULL);
}

inline void CIMCPriv::UnLockIMC()
{
    if (m_hIMC != NULL && m_inputcontext != NULL)
        {
        OurImmUnlockIMCC(m_inputcontext->hPrivate);
        OurImmUnlockIMC(m_hIMC);
        }
}

inline void CIMCPriv::ResetPrivateBuffer()
{
    AST(m_hIMC != NULL);
    
    if (m_inputcontext && m_priv)
        {
        m_priv->hIMC = (HIMC)0;
        }
}

__inline IImeIPoint1* GetImeIPoint(HIMC hIMC)
{
    CIMCPriv ImcPriv;
    
	if (ImcPriv.LockIMC(hIMC) == fFalse) 
		{
		return NULL;
		}
	return ImcPriv->pIPoint;
}

#endif // _IMCSUB_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\immsec.h ===
#if !defined (_IMMSEC_H__INCLUDED_)
#define _IMMSEC_H__INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif
PSECURITY_ATTRIBUTES CreateSecurityAttributes(VOID);
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa);
BOOL IsNT(VOID);
PSECURITY_ATTRIBUTES GetIMESecurityAttributes(VOID);
PSECURITY_ATTRIBUTES GetIMESecurityAttributesEx(VOID);
VOID FreeIMESecurityAttributes(VOID);
PSECURITY_ATTRIBUTES CreateSecurityAttributesEx(VOID);
PSID MyCreateSidEx(VOID);
#ifdef __cplusplus
}
#endif

#endif // !_IMMSEC_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\imc.cpp ===
/****************************************************************************
    IMC.H

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IME Context abstraction class
    
    History:
    21-JUL-1999 cslim       Created
*****************************************************************************/

#include "precomp.h"
#include "hanja.h"
#include "imc.h"
#include "debug.h"

/*----------------------------------------------------------------------------
    CIMECtx::CIMECtx

    Ctor
----------------------------------------------------------------------------*/
CIMECtx::CIMECtx(HIMC hIMC)
{
    m_fUnicode = fTrue;    // default is UNICODE

    m_dwMessageSize = 0;
    m_dwCandInfoSize = 0;
    
    // Init Context variables
    m_hIMC = hIMC;
    m_pIMC = OurImmLockIMC(m_hIMC);

    //m_hCandInfo = m_pIMC->hCandInfo;
    m_pCandInfo = (LPCANDIDATEINFO)OurImmLockIMCC(GetHCandInfo());

    //m_hCompStr = m_pIMC->hCompStr;
    InitCompStrStruct();
    
    //m_hMessage = m_pIMC->hMsgBuf;
    m_pMessage = (LPTRANSMSG)OurImmLockIMCC(GetHMsgBuf());

    // Reset composition info.
    ResetComposition();

    // Reset candidate infos
    m_pCandStr = NULL;
    m_rgpCandMeaningStr    = NULL;
    ResetCandidate();
    
    // Reset GCS flag to zero
    ResetGCS();
    
    // initialize message buffer
    ResetMessage();
    
    // clear hCompStr
    ClearCompositionStrBuffer();

    //////////////////////////////////////////////////////////////////////
    // initialize Shared memory. If this is only IME in the system
    // Shared memory will be created as file mapping object.
    //////////////////////////////////////////////////////////////////////
    m_pCIMEData = new CIMEData;
    DbgAssert(m_pCIMEData != 0);
    
    // Initialize IME shared memory to default value and set reg value if avaliable
    // Read registry: Do not call it in the DllMain
    if (m_pCIMEData)
        m_pCIMEData->InitImeData();
    // Initialize Hangul Automata
    //GetAutomata()->InitState();

    //////////////////////////////////////////////////////////////////////////
    // Create All three IME Automata instances
    m_rgpHangulAutomata[KL_2BEOLSIK]        = new CHangulAutomata2;
    m_rgpHangulAutomata[KL_3BEOLSIK_390]   = new CHangulAutomata3;
    m_rgpHangulAutomata[KL_3BEOLSIK_FINAL] = new CHangulAutomata3Final;
}

/*----------------------------------------------------------------------------
    CIMECtx::CIMECtx

    Dtor
----------------------------------------------------------------------------*/
CIMECtx::~CIMECtx()
{
    if (m_pCIMEData)
        {
        delete m_pCIMEData;
        m_pCIMEData =  NULL;
        }

    // Release Cand info
    if (GetHCandInfo())
        OurImmUnlockIMCC(GetHCandInfo());
    m_pCandInfo = NULL;

    // Release Comp str
    if (GetHCompStr())
        OurImmUnlockIMCC(GetHCompStr());
    m_pCompStr = NULL;

    // Release Msg buffer
    ResetMessage();
    if (GetHMsgBuf())
        OurImmUnlockIMCC(GetHMsgBuf());
    m_pMessage = NULL;

    // Reset hIMC
    OurImmUnlockIMC(m_hIMC);
    m_pIMC = NULL;
    m_hIMC = NULL;

    // Free candidate private buffer
    if (m_pCandStr)
        {
        GlobalFree(m_pCandStr);
        m_pCandStr = NULL;
        }
        
    if (m_rgpCandMeaningStr)
        {
        ClearCandMeaningArray();
        GlobalFree(m_rgpCandMeaningStr);
        m_rgpCandMeaningStr = NULL;
        }

    // delete Automata 
    for (INT i=0; i<NUM_OF_IME_KL; i++)
        if (m_rgpHangulAutomata[i])
            delete m_rgpHangulAutomata[i];
}

/*----------------------------------------------------------------------------
    CIMECtx::InitCompStrStruct

    Initialize and reallocater composition string buffer
----------------------------------------------------------------------------*/
VOID CIMECtx::InitCompStrStruct()
{
    INT iAllocSize;

    if (m_pIMC == NULL)
        return;
    
    // Calc COMPOSITIONSTRING buffer size.
    iAllocSize = sizeof(COMPOSITIONSTRING) +
                // composition string plus NULL terminator
                nMaxCompStrLen   * sizeof(WCHAR) + sizeof(WCHAR) +
                // composition attribute
                nMaxCompStrLen   * sizeof(WORD) +
                // result string plus NULL terminator
                nMaxResultStrLen * sizeof(WCHAR) + sizeof(WCHAR);

    // For avoiding miss alignment
    iAllocSize += 2;

    // Reallocation COMPOSITION buffer
    m_pIMC->hCompStr = OurImmReSizeIMCC(GetHCompStr(), iAllocSize);
    AST_EX(m_pIMC->hCompStr != (HIMCC)0);
    if (m_pIMC->hCompStr == (HIMCC)0) 
        {
        DbgAssert(0);
        return;
        }
        
    if (m_pCompStr = (LPCOMPOSITIONSTRING)OurImmLockIMCC(GetHCompStr()))
        {
        // CONFIRM: Need to clear memory??
        ZeroMemory(m_pCompStr, iAllocSize);

        // Store total size
        m_pCompStr->dwSize = iAllocSize;

        // REVIEW: Does we need Null termination??
        // Store offset. All offset is static which will be calculated in compile time
        m_pCompStr->dwCompStrOffset   = sizeof(COMPOSITIONSTRING);
        m_pCompStr->dwCompAttrOffset  = sizeof(COMPOSITIONSTRING) + 
                                        nMaxCompStrLen * sizeof(WCHAR) + sizeof(WCHAR);     // length of comp str
        m_pCompStr->dwResultStrOffset = sizeof(COMPOSITIONSTRING) + 
                                        nMaxCompStrLen * sizeof(WCHAR) + sizeof(WCHAR) +     // length of comp str
                                        nMaxCompStrLen * sizeof(WORD)  +  2;                // length of comp str attr
        }

    Dbg(DBGID_CompChar, "InitCompStrStruct m_pIMC->hCompStr = 0x%x, m_pCompStr = 0x%x", m_pIMC->hCompStr, m_pCompStr);
}

/*----------------------------------------------------------------------------
    CIMECtx::StoreComposition

    Store all composition result to IME context buffer
----------------------------------------------------------------------------*/
VOID CIMECtx::StoreComposition()
{
    LPWSTR pwsz;
    LPSTR  psz;

    Dbg(DBGID_Key, "StoreComposition GCS = 0x%x", GetGCS());

    // Check composition handle validity
    if (GetHCompStr() == NULL || m_pCompStr == NULL)
        return ;

    //////////////////////////////////////////////////////////////////////////
    // Comp Str
    if (GetGCS() & GCS_COMPSTR)
        {
        Dbg(DBGID_Key, "StoreComposition - GCS_COMPSTR comp str = 0x%04X", m_wcComp);
        DbgAssert(m_wcComp != 0);
        // Composition string. dw*StrLen contains character count
        if (IsUnicodeEnv())
            {
            m_pCompStr->dwCompStrLen = 1;
            pwsz = (LPWSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset);
            *pwsz++ = m_wcComp;    // Store composition char
            *pwsz   = L'\0';
            }
        else
            {
            // Byte length
            m_pCompStr->dwCompStrLen = 2;
            // Convert to ANSI
            WideCharToMultiByte(CP_KOREA, 0, 
                                &m_wcComp, 1, (LPSTR)m_szComp, sizeof(m_szComp), 
                                NULL, NULL );
            psz = (LPSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset);
            *psz++ = m_szComp[0];
            *psz++ = m_szComp[1];
            *psz = '\0';
            }
            
        // Composition attribute. Always set
        m_pCompStr->dwCompAttrLen = 1;
        *((LPBYTE)m_pCompStr + m_pCompStr->dwCompAttrOffset) = ATTR_INPUT;
        } 
    else 
        {
        // Reset length
        m_pCompStr->dwCompStrLen = 0;
        m_pCompStr->dwCompAttrLen = 0;
        }

    //////////////////////////////////////////////////////////////////////////
    // Result Str
    if (GetGCS() & GCS_RESULTSTR)
        {
        Dbg(DBGID_Key, "StoreComposition - GCS_RESULTSTR comp str = 0x%04x, 0x%04X", m_wzResult[0], m_wzResult[1]);

        // Composition string. dw*StrLen contains character count
        if (IsUnicodeEnv())
            {
            // Result string length 1 or 2
            m_pCompStr->dwResultStrLen = m_wzResult[1] ? 2 : 1; // lstrlenW(m_wzResult); 
            pwsz = (LPWSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwResultStrOffset);
            *pwsz++ = m_wzResult[0]; // Store composition result string
            if (m_wzResult[1])
                *pwsz++ = m_wzResult[1]; // Store composition result string
            *pwsz = L'\0';
            }
        else
            {
            // Result string length 2 or 3
            m_pCompStr->dwResultStrLen = m_wzResult[1] ? 3 : 2; // lstrlenW(m_wzResult); 
            // Convert to ANSI
            WideCharToMultiByte(CP_KOREA, 0, 
                                m_wzResult, (m_wzResult[1] ? 2 : 1), 
                                (LPSTR)m_szResult, sizeof(m_szResult), 
                                NULL, NULL );
                                
            psz = (LPSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwResultStrOffset);
            *psz++ = m_szResult[0];
            *psz++ = m_szResult[1];
            if (m_wzResult[1])
                *psz++ = m_szResult[2];
            *psz = '\0';
            }
        }
    else 
        {
        m_pCompStr->dwResultStrLen = 0;
        }
}

/////////////////////////////////////////////////
//  CANDIDATEINFO STRUCTURE SUPPORT
/////////////////////////////////////////////////
VOID CIMECtx::AppendCandidateStr(WCHAR wcCand, LPWSTR wszMeaning)
{
    Dbg(DBGID_Hanja, "AppendCandidateStr");
    
    // Alocate cand string and meaning buffer
    if (m_pCandStr == NULL)
        {
        m_pCandStr =(LPWSTR)GlobalAlloc(GPTR, sizeof(WCHAR)*MAX_CANDSTR);
        DbgAssert(m_pCandStr != NULL);
        }

    if (m_rgpCandMeaningStr == NULL)
        {
        m_rgpCandMeaningStr = (LPWSTR*)GlobalAlloc(GPTR, sizeof(LPWSTR)*MAX_CANDSTR);
        DbgAssert(m_rgpCandMeaningStr != NULL);
        }

    if (m_pCandStr == NULL || m_rgpCandMeaningStr == NULL)
        return;

    // Append candidate char
    DbgAssert(m_iciCandidate < MAX_CANDSTR);
    if (m_iciCandidate >= MAX_CANDSTR)
        return;
        
    m_pCandStr[m_iciCandidate] = wcCand;

    // Append candidate meaning
    if (wszMeaning[0])
        {
        m_rgpCandMeaningStr[m_iciCandidate] = (LPWSTR)GlobalAlloc(GPTR, sizeof(WCHAR)*(lstrlenW(wszMeaning)+1));
        if (m_rgpCandMeaningStr[m_iciCandidate] == NULL)
            return;
        StrCopyW(m_rgpCandMeaningStr[m_iciCandidate], wszMeaning);
        }
    else
        m_rgpCandMeaningStr[m_iciCandidate] = NULL;

    m_iciCandidate++;
}

WCHAR CIMECtx::GetCandidateStr(INT iIdx)
{
    if (iIdx < 0 || iIdx >= MAX_CANDSTR)
        {
        DbgAssert(0);
        return L'\0';
        }
    if (iIdx >= m_iciCandidate)
        {
        DbgAssert(0);
        return L'\0';
        }
    return m_pCandStr[iIdx];
}

LPWSTR CIMECtx::GetCandidateMeaningStr(INT iIdx)
{
    if (m_rgpCandMeaningStr == NULL || 
        m_rgpCandMeaningStr[iIdx] == NULL || 
        iIdx >= MAX_CANDSTR || iIdx < 0)
        {
        // DbgAssert(0); It happen for symbol mapping
        return NULL;
        }
    else
        return m_rgpCandMeaningStr[iIdx];
}

VOID CIMECtx::StoreCandidate()
{
    INT                 iAllocSize;
    LPCANDIDATELIST        lpCandList;

    Dbg(DBGID_Key, "StoreCandidate");

    if (GetHCandInfo() == NULL)
        return ; // do nothing

    // Calc CANDIDATEINFO buffer size
    iAllocSize = sizeof(CANDIDATEINFO) +
                 sizeof(CANDIDATELIST) +                // candlist struct
                 m_iciCandidate * sizeof(DWORD) +        // cand index
                   m_iciCandidate * sizeof(WCHAR) * 2;    // cand strings with null termination

    // Alllocate buffer
    if (m_dwCandInfoSize < (DWORD)iAllocSize) // need to re-allocate
        {
        // reallocation COMPOSITION buffer
        OurImmUnlockIMCC(GetHCandInfo());
        m_pIMC->hCandInfo = OurImmReSizeIMCC(GetHCandInfo(), iAllocSize);
        AST_EX(m_pIMC->hCandInfo != (HIMCC)0);

        if (m_pIMC->hCandInfo == (HIMCC)0)
            return;

        m_pCandInfo = (CANDIDATEINFO*)OurImmLockIMCC(GetHCandInfo());
        m_dwCandInfoSize = (DWORD)iAllocSize;
        }

    // Check if m_pCandInfo is valid
    if (m_pCandInfo == NULL)
        return;

    // Fill cand info
    m_pCandInfo->dwSize = iAllocSize;
    m_pCandInfo->dwCount = 1;
    m_pCandInfo->dwOffset[0] = sizeof(CANDIDATEINFO);

    // Fill cand list
    lpCandList = (LPCANDIDATELIST)((LPBYTE)m_pCandInfo + m_pCandInfo->dwOffset[0]);
    lpCandList->dwSize = iAllocSize - sizeof(CANDIDATEINFO);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = m_iciCandidate;
    lpCandList->dwPageStart = lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CAND_PAGE_SIZE;


    INT iOffset = sizeof(CANDIDATELIST) 
                  + sizeof(DWORD) * (m_iciCandidate); // for dwOffset array

    for (INT i = 0; i < m_iciCandidate; i++)
        {
        LPWSTR  wszCandStr;
        LPSTR   szCandStr;
        CHAR    szCand[4] = "\0\0";    // Cand string always 1 char(2 bytes) + extra one byte
        
        lpCandList->dwOffset[i] = iOffset;
        if (IsUnicodeEnv())
            {
            wszCandStr = (LPWSTR)((LPSTR)lpCandList + iOffset);
            *wszCandStr++ = m_pCandStr[i];
            *wszCandStr++ = L'\0';
            iOffset += sizeof(WCHAR) * 2;
            }
        else
            {
            // Convert to ANSI
            WideCharToMultiByte(CP_KOREA, 0, 
                                &m_pCandStr[m_iciCandidate], 1, (LPSTR)szCand, sizeof(szCand), 
                                NULL, NULL );

            szCandStr = (LPSTR)((LPSTR)lpCandList + iOffset);
            *szCandStr++ = szCand[0];
            *szCandStr++ = szCand[1];
            *szCandStr = '\0';
            iOffset += 3; // DBCS + NULL
            }
        }
}

/////////////////////////////////////////////////
//  MSGBUF STRUCTURE SUPPORT
BOOL CIMECtx::FinalizeMessage()
{
    DWORD  dwCurrentGCS;
    WPARAM wParam;

    Dbg(DBGID_Key, "FinalizeMessage");

    // support WM_IME_STARTCOMPOSITION
    if (m_fStartComposition == fTrue)
        {
        Dbg(DBGID_Key, "FinalizeMessage - WM_IME_STARTCOMPOSITION");
        AddMessage(WM_IME_STARTCOMPOSITION);
        }

    // support WM_IME_ENDCOMPOSITION
    if (m_fEndComposition == fTrue)
        {
        Dbg(DBGID_Key, "FinalizeMessage - WM_IME_ENDCOMPOSITION");

        AddMessage(WM_IME_ENDCOMPOSITION);

        // Clear all automata states
        GetAutomata()->InitState();
        }


    // GCS validation before set to IMC
    dwCurrentGCS = ValidateGCS();
    if (dwCurrentGCS & GCS_RESULTSTR)
        {
        Dbg(DBGID_Key, "FinalizeMessage - WM_IME_COMPOSITION - GCS_RESULTSTR 0x%04x", m_wzResult[0]);

        if (IsUnicodeEnv())
            AddMessage(WM_IME_COMPOSITION, m_wzResult[0], GCS_RESULTSTR);
        else
            {
            // Set ANSI code
            wParam = ((WPARAM)m_szResult[0] << 8) | m_szResult[1];
            AddMessage(WM_IME_COMPOSITION, wParam, GCS_RESULTSTR);
            }
        }

    if (dwCurrentGCS & GCS_COMP_KOR)
        {
        Dbg(DBGID_Key, "FinalizeMessage - WM_IME_COMPOSITION - GCS_COMP_KOR 0x%04x", m_wcComp);

        if (IsUnicodeEnv())
            AddMessage(WM_IME_COMPOSITION, m_wcComp, (GCS_COMP_KOR|GCS_COMPATTR|CS_INSERTCHAR|CS_NOMOVECARET));
        else
            {
            // Set ANSI code
            wParam = ((WPARAM)m_szComp[0] << 8) | m_szComp[1];
            AddMessage(WM_IME_COMPOSITION, wParam, (GCS_COMP_KOR|GCS_COMPATTR|CS_INSERTCHAR|CS_NOMOVECARET));
            }
        }

    ResetGCS();    // reset now

    // O10 Bug #150012
    // support WM_IME_ENDCOMPOSITION
    if (m_fEndComposition == fTrue)
        {
        ResetComposition();
        ResetCandidate();
        }

    FlushCandMessage();

    //////////////////////////////////////////////////////////////////////////
    // WM_IME_KEYDOWN: This should be added after all composition message
    if (m_fKeyDown)
        AddMessage(WM_IME_KEYDOWN, m_wParamKeyDown, (m_lParamKeyDown << 16) | 1UL);

    return TRUE;
}

VOID CIMECtx::FlushCandMessage()
{
    switch (m_uiSendCand)
        {
    case MSG_NONE:        // Do nothing
        break;
    case MSG_OPENCAND:
        AddMessage(WM_IME_NOTIFY, IMN_OPENCANDIDATE, 1);
        break;
    case MSG_CLOSECAND:
        AddMessage(WM_IME_NOTIFY, IMN_CLOSECANDIDATE, 1);
        ResetCandidate();
        break;
    case MSG_CHANGECAND:
        AddMessage(WM_IME_NOTIFY, IMN_CHANGECANDIDATE, 1);
        break;
    default:
        DbgAssert(0);    // Error
        break;
        }
        
    m_uiSendCand = MSG_NONE;
}


BOOL CIMECtx::GenerateMessage()
{
    BOOL fResult = fFalse;
    INT iMsgCount;

    Dbg(DBGID_Key, "GenerateMessage");

    if (IsProcessKeyStatus())
        return fFalse;    // Do nothing
        
    FinalizeMessage();
    iMsgCount = GetMessageCount();
    ResetMessage();
    
    if (iMsgCount > 0)
        fResult = OurImmGenerateMessage(m_hIMC);

    return fResult;
}

INT CIMECtx::AddMessage(UINT uiMessage, WPARAM wParam, LPARAM lParam)
{
    LPTRANSMSG pImeMsg;

    Dbg(DBGID_Key, "AddMessage uiMessage=0x%X, wParam=0x%04X, lParam=0x%08lX", uiMessage, wParam, lParam);

    if (GetHMsgBuf() == NULL)
        return m_uiMsgCount;

    m_uiMsgCount++;

    //////////////////////////////////////////////////////////////////////////
    // Check if this data stream created by ImeToAsciiEx()
    if (m_pTransMessage) 
        {    
        Dbg(DBGID_Key, "AddMessage - use Transbuffer(ImeToAscii)");
        
        // Check if need reallocate message buffer
        if (m_pTransMessage->uMsgCount >= m_uiMsgCount) 
            {
            // Fill msg buffer
            pImeMsg = &m_pTransMessage->TransMsg[m_uiMsgCount - 1];
            pImeMsg->message = uiMessage;
            pImeMsg->wParam = wParam;
            pImeMsg->lParam = lParam;
            } 
        else 
            {
            DbgAssert(0);
            // pre-allocated buffer is full - use hMsgBuf instead.
            UINT uiMsgCountOrg = m_uiMsgCount;          // backup
            m_uiMsgCount = 0;                          // reset anyway
            LPTRANSMSGLIST pHeader = m_pTransMessage; // backup
            SetTransMessage(NULL);                      // use hMsgBuf
            
            for (UINT i=0; i<uiMsgCountOrg; i++)
                AddMessage(pHeader->TransMsg[i].message, pHeader->TransMsg[i].wParam, pHeader->TransMsg[i].lParam);

            // finally adds current message
            AddMessage(uiMessage, wParam, lParam);
            }
        } 
    else  // m_pTransMessage. Not called from ImeToAsciiEx()
        {
        UINT  iMaxMsg = m_dwMessageSize / sizeof(TRANSMSG);
        DWORD dwNewSize;
        Dbg(DBGID_Key, "AddMessage - use hMsgBuf");    

        if (m_uiMsgCount > iMaxMsg) 
            {
            Dbg(DBGID_Key, "AddMessage - Reallocate");
            // Reallocation message buffer
            OurImmUnlockIMCC(GetHMsgBuf());
            dwNewSize = max(16, m_uiMsgCount) * sizeof(TRANSMSG);    // At least 16 cand list

            m_pIMC->hMsgBuf = OurImmReSizeIMCC(GetHMsgBuf(), dwNewSize);
            AST_EX(m_pIMC->hMsgBuf != (HIMCC)0);

            if (m_pIMC->hMsgBuf == (HIMCC)0)
                return m_uiMsgCount;

            m_pMessage = (LPTRANSMSG)OurImmLockIMCC(GetHMsgBuf());
            m_dwMessageSize = dwNewSize;
            }

        // Fill msg buffer
        pImeMsg = m_pMessage + m_uiMsgCount - 1;
        pImeMsg->message = uiMessage;
        pImeMsg->wParam = wParam;
        pImeMsg->lParam = lParam;

        // set message count
        m_pIMC->dwNumMsgBuf = m_uiMsgCount;
        }
    
    return m_uiMsgCount;
}

/*----------------------------------------------------------------------------
    CIMECtx::GetCompBufStr

    Get current hCompStr comp str. If Win95, convert it to Unicode
----------------------------------------------------------------------------*/
WCHAR CIMECtx::GetCompBufStr()
{
    WCHAR wch;

    if (GetHCompStr() == NULL || m_pCompStr == NULL)
        return L'\0';

    if (IsUnicodeEnv())
        return *(LPWSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset);
    else
        {
        if (MultiByteToWideChar(CP_KOREA, MB_PRECOMPOSED, 
                                (LPSTR)((LPBYTE)m_pCompStr + m_pCompStr->dwCompStrOffset), 
                                2, 
                                &wch, 
                                1))
            return wch;
        else
            return L'\0';

        }
}

/*----------------------------------------------------------------------------
    CIMECtx::ClearCandMeaningArray
----------------------------------------------------------------------------*/
void CIMECtx::ClearCandMeaningArray() 
{
    if (m_rgpCandMeaningStr == NULL)
        return;

    for (int i=0; i<MAX_CANDSTR; i++) 
        {
        if (m_rgpCandMeaningStr[i] == NULL)
            break;

        GlobalFree(m_rgpCandMeaningStr[i]);
        m_rgpCandMeaningStr[i] = 0;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\imedefs.h ===
/****************************************************************************
	IMEDEFS.CPP

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Structure and const Definition for various functions
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_IMEDEFS_H__INCLUDED_)
#define _IMEDEFS_H__INCLUDED_

#include "hauto.h"
#include "debug.h"
#include "ui.h"

///////////////////////////////////////////////////////////////////////////////
#define IME_AUTOMATA        0x30
#define IME_HANJAMODE       0x31

///////////////////////////////////////////////////////////////////////////////
// Configuration const related to registry values

//
#define MAX_NAME_LENGTH         32
#define CAND_PER_PAGE			9	// Candidate per page

///////////////////////////////////////////////////////////////////////////////
// Max number of hangul composition chars
const WORD nMaxCompStrLen	=	1;
const WORD nMaxResultStrLen	=	2;	// #59, #78 Max result str can be 2 char
									// Hangul+Alphanumeric


///////////////////////////////////////////////////////////////////////////////
// window extra for UI windows
#define UI_MOVE_OFFSET          0
#define UI_MOVE_XY              4
// if UI_MOVE_OFFSET == WINDOW_NOT_DRAG, not in drag operation
#define WINDOW_NOT_DRAG         -1

///////////////////////////////////////////////////////////////////////////////
// IME Message processing status bits
///////////////////////////////////////////////////////////////////////////////
#define ISC_OPEN_STATUS_WINDOW          0x04000000
#define ISC_SHOW_UI_ALL                 (ISC_SHOWUIALL| /*ISC_SHOW_SOFTKBD|*/ISC_OPEN_STATUS_WINDOW)
#define ISC_SETCONTEXT_UI               (ISC_SHOWUIALL /*|ISC_SHOW_SOFTKBD*/)
#if !defined(_M_IA64)
#define MAX_NUM_OF_STATUS_BUTTONS	4
#else
#define MAX_NUM_OF_STATUS_BUTTONS	3
#endif
#define NUM_OF_BUTTON_SIZE			3

class CToolBar;

// IME private UI data
typedef struct tagUIPRIV 
{          
	HWND    hCompWnd;           // composition window
    INT     nShowCompCmd;

	// Status Window
    HWND    hStatusWnd; 
    INT     nShowStatusCmd;
	HWND	hStatusTTWnd;
	LPARAM	uiShowParam;
	
	// Candidate window
    HWND    hCandWnd;
    INT     nShowCandCmd;
	HWND	hCandTTWnd;

	// Cicero Toolbar object
	CToolBar *m_pCicToolbar;
} UIPRIV;

typedef UIPRIV      *PUIPRIV;
typedef UIPRIV		*LPUIPRIV;

///////////////////////////////////////////////////////////////////////////////
#if 1 // MultiMonitor support
typedef HMONITOR (WINAPI *LPFNMONITORFROMWINDOW)(HWND, DWORD);
typedef HMONITOR (WINAPI *LPFNMONITORFROMPOINT)(POINT, DWORD);
typedef HMONITOR (WINAPI *LPFNMONITORFROMRECT)(LPRECT, DWORD);
typedef BOOL     (WINAPI *LPFNGETMONITORINFO)(HMONITOR, LPMONITORINFO);

// definition in init.cpp
extern LPFNMONITORFROMWINDOW g_pfnMonitorFromWindow;
extern LPFNMONITORFROMPOINT  g_pfnMonitorFromPoint;
extern LPFNMONITORFROMRECT   g_pfnMonitorFromRect;
extern LPFNGETMONITORINFO    g_pfnGetMonitorInfo;
#endif

#endif // !defined (_IMEDEFS_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\indicml.h ===
/**********************************************************************/
/*      INDICML.H - Indicator Service Manager definitions             */
/*                                                                    */
/*      Copyright (c) 1993-1997  Microsoft Corporation                */
/**********************************************************************/

#ifndef _INDICML_
#define _INDICML_        // defined if INDICML.H has been included

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------
//
// The messages for Indicator Window.
//
//---------------------------------------------------------------------
#define INDICM_SETIMEICON         (WM_USER+100)
#define INDICM_SETIMETOOLTIPS     (WM_USER+101)
#define INDICM_REMOVEDEFAULTMENUITEMS     (WM_USER+102)
#define RDMI_LEFT         0x0001
#define RDMI_RIGHT        0x0002


//---------------------------------------------------------------------
//
// INDICATOR_WND will be used by the IME to find indicator window.
// IME should call FindWindow(INDICATOR_WND) to get it.
//
//---------------------------------------------------------------------
#ifdef _WIN32

#define INDICATOR_CLASSW         L"Indicator"
#define INDICATOR_CLASSA         "Indicator"

#ifdef UNICODE
#define INDICATOR_CLASS          INDICATOR_CLASSW
#else
#define INDICATOR_CLASS          INDICATOR_CLASSA
#endif

#else
#define INDICATOR_CLASS          "Indicator"
#endif

#ifdef __cplusplus
}
#endif

#endif  // _INDICML_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\immsec.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    immsec.c

Abstract:

    security code called by IMEs 

Author:

    Chae Seong Lim [cslim] 23-Dec-1997
    Takao Kitano [takaok] 01-May-1996

Revision History:
    Chae Seong Lim [cslim] 971223 Korean IME version
    Hiroaki Kanokogi [hiroakik] 960624  Modified for MSIME96
    Hiroaki Kanokogi [hiroakik] 960911  NT #11911

--*/

#include "precomp.h"
#define _USEINIME_
//#ifndef _USEINIME_    // .IME does not need
//#include <dbgmgr.h>
//#include <misc/memalloc.h>
//#endif // _USEINIME_
#include "immsec.h"
#include "winex.h"


#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

//
// internal functions
//
PSID MyCreateSid( DWORD dwSubAuthority );
#ifndef _USEINIME_
POSVERSIONINFO GetVersionInfo(VOID);
#endif // _USEINIME_

//
// debug functions
//
#ifdef DEBUG
#define ERROROUT(x)      ErrorOut( x )
#define WARNOUT(x)       WarnOut( x )
#else
#define ERROROUT(x) 
#define WARNOUT(x)       
#endif

#ifdef DEBUG
VOID WarnOut( PTSTR pStr )
{
    OutputDebugString( pStr );
}

VOID ErrorOut( PTSTR pStr )
{
    DWORD dwError;
    DWORD dwResult;
    static TCHAR buf1[512];
    static TCHAR buf2[512];

    dwError = GetLastError();
    dwResult = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwError,
                              MAKELANGID( LANG_ENGLISH, LANG_NEUTRAL ),
                              buf1,
                              512,
                              NULL );                                   
    
    if ( dwResult > 0 ) {
        wsprintfA(buf2, "%s:%s(0x%x)", pStr, buf1, dwError);
    } else {
        wsprintfA(buf2, "%s:(0x%x)", pStr, dwError);
    }
    OutputDebugString( buf2 );
}
#endif


//
// GetIMESecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeIMESecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//

static PSECURITY_ATTRIBUTES pSAIME = NULL;
//static PSECURITY_ATTRIBUTES pSAIME_UserDic = NULL;

PSECURITY_ATTRIBUTES GetIMESecurityAttributes(VOID)
{
    if (IsWinNT())
        return (pSAIME==NULL) ? (pSAIME=CreateSecurityAttributes()) : pSAIME;
    else
        return NULL;
}

#if NOT_USED
PSECURITY_ATTRIBUTES GetIMESecurityAttributesEx(VOID)
{
    if (IsWinNT())
        return (pSAIME_UserDic==NULL) ? (pSAIME_UserDic=CreateSecurityAttributesEx()) : pSAIME_UserDic;
    else
        return NULL;
}
#endif
//
// FreeIMESecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      GetIMESecurityAttributes() call.
//

VOID FreeIMESecurityAttributes()
{
    if (pSAIME!=NULL)
        FreeSecurityAttributes(pSAIME);
//    if (pSAIME_UserDic!=NULL)
//        FreeSecurityAttributes(pSAIME_UserDic);

    pSAIME = NULL;
//    pSAIME_UserDic = NULL;
}


//
// CreateSecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributes()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    DWORD                cbacl;

    PSID                 psid1, psid2, psid3, psid4;
    BOOL                 fResult;

    psid1 = MyCreateSid( SECURITY_INTERACTIVE_RID );
    if ( psid1 == NULL )
        return NULL;


    psid2 = MyCreateSid( SECURITY_LOCAL_SYSTEM_RID );
    if ( psid2 == NULL )
        goto Fail5;


    psid3 = MyCreateSid( SECURITY_SERVICE_RID );
    if ( psid3 == NULL )
        goto Fail4;


    psid4 = MyCreateSid( SECURITY_NETWORK_RID );
    if ( psid4 == NULL )
        goto Fail3;

    
    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SIDs we've just created.
    //
    cbacl =  sizeof(ACL) + 
             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) * 4 + 
             GetLengthSid(psid1) + GetLengthSid(psid2) + GetLengthSid(psid3) + GetLengthSid(psid4);

    pacl = (PACL)MEMALLOC( cbacl );
    if ( pacl == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed") );
        goto Fail2;
    }

    fResult = InitializeAcl( pacl, cbacl, ACL_REVISION );
    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeAcl failed") );
        goto Fail;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid1 );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid2 );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid3 );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        goto Fail;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid4 );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        goto Fail;
    }

    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid ( psid1 );
    FreeSid ( psid2 );
    FreeSid ( psid3 );
    FreeSid ( psid4 );

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidAcl returns fFalse!"));
        MEMFREE( pacl );
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC( sizeof( SECURITY_ATTRIBUTES ) );
    if ( psa == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psa failed") );
        MEMFREE( pacl );
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC( SECURITY_DESCRIPTOR_MIN_LENGTH );
    if ( psd == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psd failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        return NULL;
    }

    if ( ! InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION ) ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl( psd,
                                         fTrue,
                                         pacl,
                                         fFalse );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    } 

    if (!IsValidSecurityDescriptor(psd)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = fTrue;

    return psa;

Fail:
    MEMFREE( pacl );
Fail2:
    FreeSid ( psid4 );
Fail3:
    FreeSid ( psid3 );
Fail4:
    FreeSid ( psid2 );
Fail5:
    FreeSid ( psid1 );
    return NULL;
}

PSID MyCreateSid( DWORD dwSubAuthority )
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid( &SidAuthority,
                                        1,
                                        dwSubAuthority,
                                        0,0,0,0,0,0,0,
                                        &psid );
    if ( ! fResult ) {
        ERROROUT( TEXT("MyCreateSid:AllocateAndInitializeSid failed") );
        return NULL;
    }

    if ( ! IsValidSid( psid ) ) {
        WARNOUT( TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid( psid );
        return NULL;
    }

    return psid;
}

//
// FreeSecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      CreateSecurityAttributes() call.
//
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa )
{
    BOOL fResult;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    PACL pacl;

    fResult = GetSecurityDescriptorDacl( psa->lpSecurityDescriptor,
                                         &fDaclPresent,
                                         &pacl,
                                         &fDaclDefaulted );                  
    if ( fResult ) {
        if ( pacl != NULL )
            MEMFREE( pacl );
    } else {
        ERROROUT( TEXT("FreeSecurityAttributes:GetSecurityDescriptorDacl failed") );
    }

    MEMFREE( psa->lpSecurityDescriptor );
    MEMFREE( psa );
}


#ifdef NOT_USED
//
// Function Below is added to give GENERIC_ALL to everyone for UserDictionary
// which is accessed from network (not interactive).
// 960911 HiroakiK NT #11911
//

//
// CreateSecurityAttributesEx()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access for everyone
//                 ^^^^^^^^
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributesEx()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    DWORD                cbacl;

    PSID                 psid;
    BOOL                 fResult;

    //
    // create a sid for everyone access
    //
    psid = MyCreateSidEx();
    if ( psid == NULL ) {
        return NULL;
    } 

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SID we've just created.
    //
    cbacl =  sizeof(ACL) + 
             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) + 
             GetLengthSid(psid);

    pacl = (PACL)MEMALLOC( cbacl );
    if ( pacl == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed") );
        FreeSid ( psid );
        return NULL;
    }

    fResult = InitializeAcl( pacl, cbacl, ACL_REVISION );
    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeAcl failed") );
        FreeSid ( psid );
        MEMFREE( pacl );
        return NULL;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        MEMFREE( pacl );
        FreeSid ( psid );
        return NULL;
    }


    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid ( psid );

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidAcl returns fFalse!"));
        MEMFREE( pacl );
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC( sizeof( SECURITY_ATTRIBUTES ) );
    if ( psa == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psa failed") );
        MEMFREE( pacl );
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC( SECURITY_DESCRIPTOR_MIN_LENGTH );
    if ( psd == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psd failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        return NULL;
    }

    if ( ! InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION ) ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl( psd,
                                         fTrue,
                                         pacl,
                                         fFalse );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    } 


    if (!IsValidSecurityDescriptor(psd)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = fFalse;

    return psa;
}

PSID MyCreateSidEx(VOID)
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid( &SidAuthority,
                                        1,
                                        SECURITY_WORLD_RID,
                                        0,0,0,0,0,0,0,
                                        &psid );
    if ( ! fResult ) {
        ERROROUT( TEXT("MyCreateSid:AllocateAndInitializeSid failed") );
        return NULL;
    }

    if ( ! IsValidSid( psid ) ) {
        WARNOUT( TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid( psid );
        return NULL;
    }

    return psid;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\imemisc.cpp ===
/****************************************************************************
    IMEMISC.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    MISC utility functions
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "imedefs.h"

static BOOL ValidateProductSuite(LPTSTR SuiteName);

#if (FUTURE_VERSION)
// Currently this IME will run on the NT5 only. We don't need to check Hydra in NT4
// Even we have no plan to create Korean NT4 TS
BOOL IsHydra(void)
{
    static DWORD fTested = fFalse, fHydra = fFalse;

    if (!fTested) 
        {
        fHydra = ValidateProductSuite(TEXT("Terminal Server"));
        fTested = fTrue;
        }
        
    return(fHydra);
}

BOOL ValidateProductSuite(LPTSTR SuiteName)
{
    BOOL rVal = fFalse;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPTSTR ProductSuite = NULL;
    LPTSTR p;

    Rslt = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                &hKey
                );
    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueEx( hKey, TEXT("ProductSuite"), NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPTSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueEx( hKey, TEXT("ProductSuite"), NULL, &Type, (LPBYTE) ProductSuite, &Size );
    if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p) 
        {
        if (lstrcmpi( p, SuiteName ) == 0) 
            {
            rVal = fTrue;
            break;
            }
        p += (lstrlen( p ) + 1);
        }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

    return rVal;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\immsys.cpp ===
/****************************************************************************
    IMMSYS.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Load/Unload IMM Apis dynamically not link with imm32.lib
    Inlcude Immdev.h and Indicml.h
    
    History:
    14-JUL-1999 cslim       Copied from KKIME2001 source tree
*****************************************************************************/

#ifndef UNDER_CE // Windows CE does not use private way.

/* -- IMMSYS support as following APIs --
    OurImmSetOpenStatus
    OurImmGetOpenStatus
    OurImmGetContext
    OurImmGetConversionStatus
    OurImmSetConversionStatus
    OurImmSetStatusWindowPos
    OurImmConfigureIMEA
    OurImmEscapeA
    OurImmNotifyIME
    OurImmLockIMCC
    OurImmReSizeIMCC
    OurImmUnlockIMCC
    OurImmGetIMCCSize
    OurImmGenerateMessage
    OurImmLockIMC
    OurImmUnlockIMC
//    OurImmRequestMessageW: Commented becuase used only by KK IME(Reconversion, document feed)
    OurImmGetDefaultIMEWnd
    OurImmGetIMEFileNameA
    OutImmIsIME()
----------------------------------------*/


#define LIBNAME    TEXT("imm32.dll")
#include "precomp.h"


typedef BOOL(WINAPI* FPOurImmSetOpenStatus)(HIMC hIMC, BOOL fOpen);
typedef BOOL(WINAPI* FPOurImmGetOpenStatus)(HIMC hIMC);
typedef HIMC(WINAPI* FPOurImmGetContext)(HWND hWnd);
typedef BOOL(WINAPI* FPOurImmGetConversionStatus)(HIMC hIMC, LPDWORD pdwConv, LPDWORD pdwSent);
typedef BOOL(WINAPI* FPOurImmSetConversionStatus)(HIMC hIMC, DWORD dwConv, DWORD dwSent);
typedef BOOL(WINAPI* FPOurImmSetStatusWindowPos)(HIMC hIMC, LPPOINT pPt);
typedef BOOL(WINAPI* FPOurImmConfigureIME)(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);
typedef LRESULT(WINAPI* FPOurImmEscapeA)(HKL hKL, HIMC hIMC, UINT ui, LPVOID pv);
typedef BOOL(WINAPI* FPOurImmNotifyIME)(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);
typedef LPVOID(WINAPI* FPOurImmLockIMCC)(HIMCC hIMCC);
typedef HIMCC(WINAPI* FPOurImmReSizeIMCC)(HIMCC hIMCC, DWORD dw);
typedef BOOL(WINAPI* FPOurImmUnlockIMCC)(HIMCC hIMCC);
typedef DWORD(WINAPI* FPOurImmGetIMCCSize)(HIMCC hIMCC);
typedef BOOL(WINAPI* FPOurImmGenerateMessage)(HIMC hIMC);
typedef LPINPUTCONTEXT(WINAPI* FPOurImmLockIMC)(HIMC hIMC);
typedef BOOL(WINAPI* FPOurImmUnlockIMC)(HIMC hIMC);
//typedef LRESULT(WINAPI* FPOurImmRequestMessageW)(HIMC hIMC, WPARAM wParam, LPARAM lParam);
typedef HWND(WINAPI* FPOurImmGetDefaultIMEWnd)(HWND hWnd);
typedef UINT(WINAPI* FPOurImmGetIMEFileNameA)(HKL hKL, CHAR* psz, UINT uBufLen);
typedef BOOL(WINAPI* FPOurImmIsIME)(HKL hKL);

static FPOurImmSetOpenStatus pFPOurImmSetOpenStatus = 0;
static FPOurImmGetOpenStatus pFPOurImmGetOpenStatus = 0;
static FPOurImmGetContext pFPOurImmGetContext = 0;
static FPOurImmGetConversionStatus pFPOurImmGetConversionStatus = 0;
static FPOurImmSetConversionStatus pFPOurImmSetConversionStatus = 0;
static FPOurImmSetStatusWindowPos pFPOurImmSetStatusWindowPos = 0;
static FPOurImmConfigureIME pFPOurImmConfigureIME = 0;
static FPOurImmEscapeA pFPOurImmEscapeA = 0;
static FPOurImmNotifyIME pFPOurImmNotifyIME = 0;
static FPOurImmLockIMCC pFPOurImmLockIMCC = 0;
static FPOurImmReSizeIMCC pFPOurImmReSizeIMCC = 0;
static FPOurImmUnlockIMCC pFPOurImmUnlockIMCC = 0;
static FPOurImmGetIMCCSize pFPOurImmGetIMCCSize = 0;
static FPOurImmGenerateMessage pFPOurImmGenerateMessage = 0;
static FPOurImmLockIMC pFPOurImmLockIMC = 0;
static FPOurImmUnlockIMC pFPOurImmUnlockIMC = 0;
//static FPOurImmRequestMessageW pFPOurImmRequestMessageW = 0;
static FPOurImmGetDefaultIMEWnd pFPOurImmGetDefaultIMEWnd = 0;
static FPOurImmGetIMEFileNameA pFPOurImmGetIMEFileNameA = 0;
static FPOurImmIsIME pFPOurImmIsIME = 0;

static HMODULE hImmLib = (HMODULE)0;

BOOL StartIMM(VOID)
{
    if( hImmLib != (HANDLE)0 ) {
        return TRUE;
    }

    hImmLib = LoadLibrary( LIBNAME );
    if( hImmLib == (HANDLE)0 ) {
        return TRUE;
    }

    pFPOurImmSetOpenStatus = (FPOurImmSetOpenStatus)GetProcAddress( hImmLib, "ImmSetOpenStatus" );
    pFPOurImmGetOpenStatus = (FPOurImmGetOpenStatus)GetProcAddress( hImmLib, "ImmGetOpenStatus" );
    pFPOurImmGetContext = (FPOurImmGetContext)GetProcAddress( hImmLib, "ImmGetContext" );
    pFPOurImmGetConversionStatus = (FPOurImmGetConversionStatus)GetProcAddress( hImmLib, "ImmGetConversionStatus" );
    pFPOurImmSetConversionStatus = (FPOurImmSetConversionStatus)GetProcAddress( hImmLib, "ImmSetConversionStatus" );
    pFPOurImmSetStatusWindowPos = (FPOurImmSetStatusWindowPos)GetProcAddress( hImmLib, "ImmSetStatusWindowPos" );
    pFPOurImmConfigureIME = (FPOurImmConfigureIME)GetProcAddress( hImmLib, "ImmConfigureIMEA" );
    pFPOurImmEscapeA = (FPOurImmEscapeA)GetProcAddress( hImmLib, "ImmEscapeA" );
    pFPOurImmNotifyIME = (FPOurImmNotifyIME)GetProcAddress( hImmLib, "ImmNotifyIME" );
     pFPOurImmLockIMCC = (FPOurImmLockIMCC)GetProcAddress( hImmLib, "ImmLockIMCC" );
    pFPOurImmReSizeIMCC = (FPOurImmReSizeIMCC)GetProcAddress( hImmLib, "ImmReSizeIMCC" );
    pFPOurImmUnlockIMCC = (FPOurImmUnlockIMCC)GetProcAddress( hImmLib, "ImmUnlockIMCC" );
    pFPOurImmGetIMCCSize = (FPOurImmGetIMCCSize)GetProcAddress( hImmLib, "ImmGetIMCCSize" );
    pFPOurImmGenerateMessage = (FPOurImmGenerateMessage)GetProcAddress( hImmLib, "ImmGenerateMessage" );
    pFPOurImmLockIMC = (FPOurImmLockIMC)GetProcAddress( hImmLib, "ImmLockIMC" );
    pFPOurImmUnlockIMC = (FPOurImmUnlockIMC)GetProcAddress( hImmLib, "ImmUnlockIMC" );
//    pFPOurImmRequestMessageW = (FPOurImmRequestMessageW)GetProcAddress( hImmLib, "ImmRequestMessageW" );
    pFPOurImmGetDefaultIMEWnd = (FPOurImmGetDefaultIMEWnd)GetProcAddress( hImmLib, "ImmGetDefaultIMEWnd" );
    pFPOurImmGetIMEFileNameA = (FPOurImmGetIMEFileNameA)GetProcAddress( hImmLib, "ImmGetIMEFileNameA" );
    pFPOurImmIsIME = (FPOurImmIsIME)GetProcAddress( hImmLib, "ImmIsIME" );

    return FALSE;
}

VOID EndIMM(VOID)
{
    FreeLibrary( hImmLib );
}


//
// OurImmSetOpenStatus
//
BOOL OurImmSetOpenStatus(HIMC hIMC, BOOL fOpen)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->SetOpenStatus( hIMC, fOpen ) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmSetOpenStatus ) {
        return pFPOurImmSetOpenStatus(hIMC, fOpen );
    }
    return FALSE;
}

//
// OurImmGetOpenStatus
//
BOOL OurImmGetOpenStatus(HIMC hIMC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->GetOpenStatus( hIMC ) == S_OK ? TRUE : FALSE);
    }
#endif
    if( pFPOurImmGetOpenStatus ) {
        // * check *
        //
        // sometime IMM sets 0xffffffff as TRUE
        //
        return (pFPOurImmGetOpenStatus( hIMC ) ? TRUE : FALSE);
    }
    return FALSE;
}
    
//
// OurImmGetContext
//
HIMC OurImmGetContext(HWND hWnd)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        HIMC hIMC = (HIMC)0;
        vpAIMM->GetContext( hWnd, &hIMC );
        return hIMC;
    }
#endif
    if( pFPOurImmGetContext ) {
        return pFPOurImmGetContext(hWnd );
    }
    return NULL;
}

//
// OurImmGetConversionStatus
//
BOOL OurImmGetConversionStatus(HIMC hIMC, LPDWORD pdwConv, LPDWORD pdwSent)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->GetConversionStatus(hIMC, pdwConv, pdwSent ) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmGetConversionStatus ) {
        return pFPOurImmGetConversionStatus(hIMC, pdwConv, pdwSent );
    }
    return NULL;
}

//
// OurImmSetConversionStatus
//
BOOL OurImmSetConversionStatus(HIMC hIMC, DWORD dwConv, DWORD dwSent)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->SetConversionStatus(hIMC, dwConv, dwSent) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmSetConversionStatus ) {
        return pFPOurImmSetConversionStatus(hIMC, dwConv, dwSent);
    }
    return NULL;
}

//
// OurImmSetStatusWindowPos
//
BOOL OurImmSetStatusWindowPos(HIMC hIMC, LPPOINT pPt)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->SetStatusWindowPos( hIMC, pPt) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmSetStatusWindowPos ) {
        return pFPOurImmSetStatusWindowPos( hIMC, pPt);
    }
    return NULL;
}

//
// OurImmConfigureIME
//
BOOL OurImmConfigureIME(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->ConfigureIMEA(hKL, hWnd, dw, (REGISTERWORDA*)pv ) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmConfigureIME ) {
        return pFPOurImmConfigureIME(hKL, hWnd, dw, pv );
    }
    return NULL;
}

//
// OurImmEscapeA
//
LRESULT OurImmEscapeA(HKL hKL, HIMC hIMC, UINT ui, LPVOID pv)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        LRESULT lRet = 0;
        vpAIMM->EscapeA(hKL, hIMC, ui, pv, &lRet );
        return lRet;
    }
#endif
    if( pFPOurImmEscapeA ) {
        return pFPOurImmEscapeA(hKL, hIMC, ui, pv );
    }
    return NULL;
}

//
// OurImmNotifyIME
//
BOOL OurImmNotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->NotifyIME(hIMC, dwAction, dwIndex, dwValue ) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmNotifyIME ) {
        return pFPOurImmNotifyIME(hIMC, dwAction, dwIndex, dwValue );
    }
    return NULL;
}

//
// OurImmLockIMCC
//
LPVOID OurImmLockIMCC(HIMCC hIMCC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        VOID* pv = NULL;
        vpAIMM->LockIMCC( hIMCC, &pv);
        return pv;
    }
#endif
    if( pFPOurImmLockIMCC ) {
        return pFPOurImmLockIMCC( hIMCC);
    }
    return NULL;
}

//
// OurImmReSizeIMCC
//
HIMCC OurImmReSizeIMCC(HIMCC hIMCC, DWORD dw)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        HIMCC hIMCC2 = (HIMCC)0;
        vpAIMM->ReSizeIMCC(hIMCC, dw, &hIMCC2 );
        return hIMCC2;
    }
#endif
    if( pFPOurImmReSizeIMCC ) {
        return pFPOurImmReSizeIMCC(hIMCC, dw );
    }
    return NULL;
}

//
// OurImmUnlockIMCC
//
BOOL OurImmUnlockIMCC(HIMCC hIMCC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->UnlockIMCC(hIMCC )  == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmUnlockIMCC ) {
        return pFPOurImmUnlockIMCC(hIMCC );
    }
    return NULL;
}

//
// OurImmGetIMCCSize
//
DWORD OurImmGetIMCCSize(HIMCC hIMCC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        DWORD dwSize = 0;
        vpAIMM->GetIMCCSize(hIMCC, &dwSize );
        return dwSize;
    }
#endif
    if( pFPOurImmGetIMCCSize ) {
        return pFPOurImmGetIMCCSize(hIMCC );
    }
    return NULL;
}

//
// OurImmGenerateMessage
//
BOOL OurImmGenerateMessage(HIMC hIMC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->GenerateMessage( hIMC) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmGenerateMessage ) {
        return pFPOurImmGenerateMessage( hIMC);
    }
    return NULL;
}

//
// OurImmLockIMC
//
LPINPUTCONTEXT OurImmLockIMC(HIMC hIMC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        LPINPUTCONTEXT pI = NULL;
        vpAIMM->LockIMC( hIMC, &pI);
        return pI;
    }
#endif
    if( pFPOurImmLockIMC ) {
        return pFPOurImmLockIMC( hIMC);
    }
    return NULL;
}

//
// OurImmUnlockIMC
//
BOOL OurImmUnlockIMC(HIMC hIMC)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return (vpAIMM->UnlockIMC( hIMC ) == S_OK) ? TRUE : FALSE;
    }
#endif
    if( pFPOurImmUnlockIMC ) {
        return pFPOurImmUnlockIMC( hIMC );
    }
    return NULL;
}

#if NOTUSED
//
// OurImmRequestMessageW
//
LRESULT OurImmRequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        return 0;    //vpAIMM->UnlockIMC( hIMC );
    }
#endif
    if( pFPOurImmRequestMessageW ) {
        return pFPOurImmRequestMessageW( hIMC, wParam, lParam );
    }
    return NULL;
}
#endif

//
// OurImmGetDefaultIMEWnd
//
HWND OurImmGetDefaultIMEWnd(HWND hWnd )
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        HWND hWndDef = (HWND)0;
        vpAIMM->GetDefaultIMEWnd(hWnd, &hWndDef);
        return hWndDef;
    }
#endif
    if( pFPOurImmGetDefaultIMEWnd ) {
        return pFPOurImmGetDefaultIMEWnd(hWnd);
    }
    return NULL;
}

UINT OurImmGetIMEFileNameA(HKL hKL, LPSTR pszName, UINT uBufLen)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        UINT ui = 0;
        vpAIMM->GetIMEFileNameA(hKL, uBufLen, pszName, &ui);
        return ui;
    }
#endif
    if( pFPOurImmGetIMEFileNameA ) {
        return pFPOurImmGetIMEFileNameA(hKL, pszName, uBufLen);
    }
    return NULL;
}

//
// OurImmIsIME
//
BOOL OurImmIsIME(HKL hKL)
{
#ifdef _AIMM_
    if( IsAIME() == TRUE && vpAIMM) {
        // why? BOOL fRet = FALSE;
        return (vpAIMM->IsIME(hKL) == S_OK) ? TRUE : FALSE;
        //return fRet;
    }
#endif
    if( pFPOurImmIsIME ) {
        return pFPOurImmIsIME(hKL );
    }
    return FALSE;
}
#endif // UNDER_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\imemisc.h ===
/****************************************************************************
	IMEMISC.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	MISC utility functions
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_IMEMISC_H__INCLUDED_)
#define _IMEMISC_H__INCLUDED_

extern POSVERSIONINFO GetVersionInfo();
// extern BOOL IsHydra(void); For future version

#endif // _IMEMISC_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\immsys.h ===
/****************************************************************************
	IMMSYS.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Load/Unload IMM Apis dynamically not link with imm32.lib
	Inlcude Immdev.h and Indicml.h
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/
#if !defined (_IMMSYS_H__INCLUDED_)
#define _IMMSYS_H__INCLUDED_

#ifndef UNDER_CE 

// include Win32 immdev.h (copied from nt\public\oak\inc\immdev.h)
#include "immdev.h"
// include indicator Service Manager definitions 
#include "indicml.h"

// IMM.DLL Load/Unload functions
BOOL StartIMM();
VOID EndIMM();

// Internal IMM functions
BOOL OurImmSetOpenStatus(HIMC hIMC, BOOL fOpen);
BOOL OurImmGetOpenStatus(HIMC hIMC);
HIMC OurImmGetContext(HWND hWnd);
BOOL OurImmGetConversionStatus(HIMC hIMC, LPDWORD pdwConv, LPDWORD pdwSent);
BOOL OurImmSetConversionStatus(HIMC hIMC, DWORD dwConv, DWORD dwSent);
BOOL OurImmSetStatusWindowPos(HIMC hIMC, LPPOINT pPt);
BOOL OurImmConfigureIME(HKL hKL, HWND hWnd, DWORD dw, LPVOID pv);
LRESULT OurImmEscapeA(HKL hKL, HIMC hIMC, UINT ui, LPVOID pv);
BOOL OurImmNotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

LPVOID OurImmLockIMCC(HIMCC hIMCC);
HIMCC  OurImmReSizeIMCC(HIMCC hIMCC, DWORD dw);
BOOL   OurImmUnlockIMCC(HIMCC hIMCC);
DWORD  OurImmGetIMCCSize(HIMCC hIMCC);

BOOL OurImmGenerateMessage(HIMC hIMC);
LPINPUTCONTEXT OurImmLockIMC(HIMC hIMC);
BOOL OurImmUnlockIMC(HIMC hIMC);
//LRESULT OurImmRequestMessageW(HIMC hIMC, WPARAM wParam, LPARAM lParam);
HWND OurImmGetDefaultIMEWnd(HWND);
UINT OurImmGetIMEFileNameA(HKL, LPSTR, UINT uBufLen);
BOOL OurImmIsIME(HKL hKL);

#else
///////////////////////////////////////////////////////////////////////////////
// !!! START OF WINCE !!!
#ifndef _IMM_CE
#define _IMM_CE

#include	<imm.h>
#include	<stub_ce.h> // Windows CE Stub for unsupported APIs / kill other define

// the data structure used for WM_SYSCOPYDATA message
typedef struct tagLMDATA
{
        DWORD   dwVersion;
        DWORD   flags;
        DWORD   cnt;
        DWORD   dwOffsetSymbols;
        DWORD   dwOffsetSkip;
        DWORD   dwOffsetScore;
        BYTE    ab[1];
} LMDATA, *PLMDATA;

// flags in LMDATA
#define LMDATA_SYMBOL_BYTE  0x00000001
#define LMDATA_SYMBOL_WORD  0x00000002
#define LMDATA_SYMBOL_DWORD 0x00000004
#define LMDATA_SYMBOL_QWORD 0x00000008
#define LMDATA_SKIP_BYTE    0x00000010
#define LMDATA_SKIP_WORD    0x00000020
#define LMDATA_SCORE_BYTE   0x00000040
#define LMDATA_SCORE_WORD   0x00000080
#define LMDATA_SCORE_DWORD  0x00000100
#define LMDATA_SCORE_QWORD  0x00000200
#define LMDATA_SCORE_FLOAT  0x00000400
#define LMDATA_SCORE_DOUBLE 0x00000800

// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW      0x0001
#define IMR_CANDIDATEWINDOW        0x0002
#define IMR_COMPOSITIONFONT        0x0003
#define IMR_RECONVERTSTRING        0x0004
#define IMR_CONFIRMRECONVERTSTRING 0x0005
#define IMR_QUERYPOSITION          0x0006
#define IMR_DOCUMENTFEED           0x0007

typedef struct tagIMEPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMEPOSITION, *PIMEPOSITION, NEAR *NPIMEPOSITION, FAR *LPIMEPOSITION;

#define IME_SMODE_CONVERSATION          0x0010

#define NI_IMEMENUSELECTED              0x0018

#define IME_ESC_GETHELPFILENAME         0x100b

#ifdef IMFS_GRAYED
#undef IMFS_GRAYED
#endif
#define IMFS_GRAYED          MF_GRAYED

#define IME_CONFIG_DICTIONARYEDIT     20

// ID for dwIndex of GUIDELINE Structure
#define GL_ID_TOOMANYRECONV                   0x00008001

#define	IMNPRIVATESIGN		(0x98A)
typedef struct tagIMNPRIVATE {
	UINT uSign;		// magic ID : IME98=98
	UINT uId;		// private id
	LPARAM lParam; // lParam
} IMNPRIVATE, * PIMNPRIVATE;

/**********************************************************************/
/*      INDICML.H - Indicator Service Manager definitions             */
/*                                                                    */
/*      Copyright (c) 1993-1997  Microsoft Corporation                */
/**********************************************************************/

#ifndef _INDICML_
#define _INDICML_        // defined if INDICML.H has been included

#ifdef __cplusplus
extern "C" {
#endif

//---------------------------------------------------------------------
//
// The messages for Indicator Window.
//
//---------------------------------------------------------------------
#define INDICM_SETIMEICON         (WM_USER+100)
#define INDICM_SETIMETOOLTIPS     (WM_USER+101)

//---------------------------------------------------------------------
//
// INDICATOR_WND will be used by the IME to find indicator window.
// IME should call FindWindow(INDICATOR_WND) to get it.
//
//---------------------------------------------------------------------
#ifdef _WIN32

#define INDICATOR_CLASSW         L"Indicator"
#define INDICATOR_CLASSA         "Indicator"

#ifdef UNICODE
#define INDICATOR_CLASS          INDICATOR_CLASSW
#else
#define INDICATOR_CLASS          INDICATOR_CLASSA
#endif

#else
#define INDICATOR_CLASS          "Indicator"
#endif

#define INDICM_REMOVEDEFAULTMENUITEMS     (WM_USER+102)
#define RDMI_LEFT         0x0001
#define RDMI_RIGHT        0x0002


#ifdef __cplusplus
}
#endif

#endif  // _INDICML_

//
// NT5 enhanvce
//
#ifndef VK_PACKET
	#define IME_PROP_ACCEPT_WIDE_VKEY 	0x20
	#define	VK_PACKET		0xe7
#endif // VK_PACKET

// Just maps private IMM functions into originals
#define OurImmSetOpenStatus 		ImmSetOpenStatus
#define OurImmGetOpenStatus 		ImmGetOpenStatus
#define OurImmGetContext 		ImmGetContext
#define OurImmGetConversionStatus	ImmGetConversionStatus
#define OurImmSetConversionStatus	ImmSetConversionStatus
#define OurImmSetStatusWindowPos	ImmSetStatusWindowPos
#define OurImmConfigureIME		ImmConfigureIMEW
#define OurImmEscapeA			ImmEscapeW
#define OurImmNotifyIME			ImmNotifyIME
#define OurImmLockIMCC			ImmLockIMCC
#define OurImmReSizeIMCC		ImmReSizeIMCC
#define OurImmUnlockIMCC		ImmUnlockIMCC
#define OurImmGetIMCCSize		ImmGetIMCCSize
#define OurImmGenerateMessage		ImmGenerateMessage
#define OurImmLockIMC			ImmLockIMC
#define OurImmUnlockIMC			ImmUnlockIMC
#define OurImmGetDefaultIMEWnd 		ImmGetDefaultIMEWnd
//#define OurImmRequestMessageW		ImmRequestMessageW

#endif // _IMM_CE
// !!! END OF WINCE !!!
///////////////////////////////////////////////////////////////////////////////
#endif // UNDER_CE

#endif // _IMMSYS_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\ipoint.cpp ===
/****************************************************************************
    IPOINT.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IImeIPoint1 interface
    
    History:
    20-JUL-1999 cslim       Created
*****************************************************************************/

#include "precomp.h"
#include "ipoint.h"
#include "imepad.h"    // IImeIPoint
#include "debug.h"

/*----------------------------------------------------------------------------
    CImeIPoint::CImeIPoint

    Ctor
----------------------------------------------------------------------------*/
CIImeIPoint::CIImeIPoint()
{
    m_cRef           = 0;
    m_pCIMECtx    = NULL;
    m_hIMC        = (HIMC)0;
    //m_pfnCallback = (IPUIControlCallBack)NULL;
    m_dwCharNo      = 1;
}

/*----------------------------------------------------------------------------
    CImeIPoint::~CIImeIPoint

    Dtor
----------------------------------------------------------------------------*/
CIImeIPoint::~CIImeIPoint()
{
    if (m_pCIMECtx)
        {
        if (m_pCIMECtx)
            {
            delete m_pCIMECtx;
            m_pCIMECtx = NULL;
            }
        m_hIMC = (HIMC)0;
//        m_pfnCallback = (IPUIControlCallBack)NULL;
        }
}

/*----------------------------------------------------------------------------
    CImeIPoint::QueryInterface
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::QueryInterface(REFIID riid, LPVOID * ppv)
{
    if(riid == IID_IUnknown) 
        {
        Dbg(DBGID_IMEPAD, ("IID_IUnknown\n"));
        *ppv = static_cast<IImeIPoint1 *>(this);
        }
    else 
    if(riid == IID_IImeIPoint1) 
        {
        Dbg(DBGID_IMEPAD, TEXT("IID_IImeIPoint1\n"));
        *ppv = static_cast<IImeIPoint1 *>(this);
        }
    else 
        {
        Dbg(DBGID_IMEPAD, ("Unknown Interface ID\n"));
        *ppv = NULL;
        return E_NOINTERFACE;
        }

    // Increase ref counter
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();

    return S_OK;
}

/*----------------------------------------------------------------------------
    CImeIPoint::AddRef
----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CIImeIPoint::AddRef(VOID)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/*----------------------------------------------------------------------------
    CImeIPoint::Release
----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CIImeIPoint::Release(VOID)
{
    ULONG res = InterlockedDecrement((LPLONG)&m_cRef);
    if (res == 0L)
        delete this;
    return res;
}

/*----------------------------------------------------------------------------
    CImeIPoint::Initialize
----------------------------------------------------------------------------*/
HRESULT CIImeIPoint::Initialize(HIMC hIMC)
{
    m_hIMC = hIMC;

    if (hIMC)
        m_pCIMECtx = new CIMECtx(hIMC);

    return (S_OK);
}

#ifndef DEBUG
    #define DumpFEInfo    /##/
#else
/*----------------------------------------------------------------------------
    DumpFEInfo

    Dump LPIMEFAREASTINFO. Debug only
----------------------------------------------------------------------------*/
VOID DumpFEInfo(LPIMEFAREASTINFO lpInfo, INT count)
{
    Dbg(DBGID_IMEPAD, "DumpFEInfo Start\n");
    Dbg(DBGID_IMEPAD, "lpInfo [0x%08x]\n", lpInfo);
    Dbg(DBGID_IMEPAD, "lpInfo->dwSize [%d]\n",     lpInfo->dwSize);
    Dbg(DBGID_IMEPAD, "lpInfo->dwType [0x%08x]\n", lpInfo->dwType);

    LPWSTR lpwstr;

    switch(lpInfo->dwType) 
        {
    case IMEFAREASTINFO_TYPE_COMMENT:
        Dbg(DBGID_IMEPAD, ("-->dwType is IMEFAREASTINFO_TYPE_COMMENT\n"));
        lpwstr = (LPWSTR)lpInfo->dwData;
        for(int i=0;i < count; i++) 
            {
            //DbgW(DBGID_IMEPAD, L"%d [%s]\n", i, lpwstr);
            lpwstr = lpwstr + lstrlenW(lpwstr)+1;
            }
        break;
        }


    Dbg(DBGID_IMEPAD, ("DumpFEInfo End\n"));
}
#endif // _DEBUG

/*----------------------------------------------------------------------------
    CImeIPoint::InsertImeItem

    Multibox input call this method
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::InsertImeItem(IPCANDIDATE* pImeItem, INT iPos, DWORD *lpdwCharId)
{
    DWORD dwCharId;

    // Check Parameters
    DbgAssert(pImeItem != NULL && pImeItem->dwSize > 0);
    
    if (pImeItem == NULL || pImeItem->dwSize <= 0)
        return S_FALSE;

    Dbg(DBGID_IMEPAD, "CImeIPoint::InsertImeItem\n");
    Dbg(DBGID_IMEPAD, "pImeItem [0x%08x]\n", pImeItem);
    Dbg(DBGID_IMEPAD, "pImeItem->dwSize    [%d]\n", pImeItem->dwSize);
    Dbg(DBGID_IMEPAD, "pImeItem->iSelIndex [%d]\n", pImeItem->iSelIndex);
    Dbg(DBGID_IMEPAD, "pImeItem->nCandidate[%d]\n", pImeItem->nCandidate);
    Dbg(DBGID_IMEPAD, "pImeItem->dwPrivateDataOffset[%d]\n", pImeItem->dwPrivateDataOffset);
    Dbg(DBGID_IMEPAD, "pImeItem->dwPrivateDataSize  [%d]\n", pImeItem->dwPrivateDataSize);
    DumpFEInfo((LPIMEFAREASTINFO)((LPBYTE)pImeItem + pImeItem->dwPrivateDataOffset), pImeItem->nCandidate);

    Dbg(DBGID_IMEPAD, "lpdwCharId [0x%08x] [%d]\n", lpdwCharId, lpdwCharId ? *lpdwCharId : 0xFFFFF);


    //INT i;

    //for(i = 0; i < pImeItem->nCandidate; i++) 
    //    {
    //    LPWSTR lpwstr = (LPWSTR)((PBYTE)pImeItem + pImeItem->dwOffset[i]);
        //Dbg(DBGID_IMEPAD, (L"pImeItem->dwOffset[%d]=[%d] String[%s]\n", i, pImeItem->dwOffset[i], lpwstr));
    //    }

    // If interim state, finalize it first
    if (m_pCIMECtx->GetCompBufLen())
        {
        m_pCIMECtx->FinalizeCurCompositionChar();
        m_pCIMECtx->GenerateMessage();
        }

    // Just out first candidate. Discard all others
    // Access 2000 hangs if send only result string.
    m_pCIMECtx->SetStartComposition(fTrue);
    m_pCIMECtx->GenerateMessage();

    m_pCIMECtx->SetEndComposition(fTrue);
    m_pCIMECtx->SetResultStr(*(LPWSTR)((PBYTE)pImeItem + pImeItem->dwOffset[0]));
    m_pCIMECtx->StoreComposition();
    m_pCIMECtx->GenerateMessage();
    
    // Increase Char serial number
    m_dwCharNo++;
    dwCharId = m_dwCharNo;
    if (lpdwCharId)
        {
        dwCharId |= ((*lpdwCharId) & (~ IPCHARID_CHARNO_MASK));
        *lpdwCharId = dwCharId;
        }

    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ReplaceImeItem
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::ReplaceImeItem(
    INT             iPos,       // = IPINS_CURRENT:use current IP position and 
                           //                  set IP to the end of insert chars.
                           // = 0-n: The offset of all composition string to set 
                           //         IP position, before insert chars. 
                           //         and IP back to original position.
    INT             iTargetLen, 
    IPCANDIDATE* pImeItem,
    DWORD         *lpdwCharId)
{
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::InsertStringEx
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::InsertStringEx(WCHAR* pwSzInsert, INT cchSzInsert, DWORD *lpdwCharId)
{
    DWORD dwCharId;

    Dbg(DBGID_IMEPAD, TEXT("CIImeIPoint::InsertStringEx : *pwSzInsert=0x%04X, cchSzInsert=%d, *lpdwCharId = 0x%04X"), *pwSzInsert, cchSzInsert, *lpdwCharId);

    // Check Parameters
    DbgAssert(pwSzInsert != NULL && cchSzInsert > 0);
    
    if (pwSzInsert == NULL || cchSzInsert <= 0)
        return S_FALSE;

    // Insert comp string to IME

    // If interim state, finalize it first
    if (m_pCIMECtx->GetCompBufLen())
        {
        m_pCIMECtx->FinalizeCurCompositionChar();
        m_pCIMECtx->GenerateMessage();
        }

    // Add all chars in string as finalized string
    for (INT i=0; i<cchSzInsert; i++)
        {
        // Access 2000 hangs if send only result string.
        m_pCIMECtx->SetStartComposition(fTrue);
        m_pCIMECtx->GenerateMessage();

        m_pCIMECtx->SetEndComposition(fTrue);
        m_pCIMECtx->SetResultStr(*(pwSzInsert + i));
        m_pCIMECtx->StoreComposition();
        m_pCIMECtx->GenerateMessage();
    
        // Increase Char serial number
        m_dwCharNo++;
        dwCharId = m_dwCharNo;
        if (lpdwCharId)
            {
            dwCharId |= ((*lpdwCharId) & (~ IPCHARID_CHARNO_MASK));
            *lpdwCharId = dwCharId;
            }
        }
    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::DeleteCompString
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::DeleteCompString(INT    iPos,
                             INT    cchSzDel)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::DeleteCompString\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ReplaceCompString
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::ReplaceCompString(INT     iPos,
                                              INT        iTargetLen, 
                                              WCHAR    *pwSzInsert,
                                              INT        cchSzInsert,
                                              DWORD    *lpdwCharId)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::ReplaceCompString\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ControlIME
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::ControlIME(DWORD dwIMEFuncID, LPARAM lpara)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::ControlIME, dwIMEFuncID=0x%04X, lpara=0x%08lX\n"), dwIMEFuncID, lpara);

    // TODO:
    
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::GetAllCompositionInfo
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::GetAllCompositionInfo(WCHAR**    ppwSzCompStr,
                                  DWORD**    ppdwCharID,
                                  INT        *pcchCompStr,
                                  INT        *piIPPos,
                                  INT        *piStartUndetStrPos,
                                  INT        *pcchUndetStr,
                                  INT        *piEditStart,
                                  INT        *piEditLen)
{
    // TODO:
    Dbg(DBGID_IMEPAD, ("CImeIPoint::GetAllCompositionInfo START\n"));

    if(ppwSzCompStr) 
        {
        *ppwSzCompStr = NULL; //(LPWSTR)CoTaskMemAlloc(sizeof(WCHAR)*10);
        //CopyMemory(*ppwSzCompStr, L"{ꏈ", sizeof(WCHAR)*6);
        }
        
    if(ppdwCharID) 
        {
        *ppdwCharID = NULL; //(DWORD *)CoTaskMemAlloc(sizeof(DWORD)*10);
        //for(int i = 0; i < 5; i++) 
        //    {
        //    (*ppdwCharID)[i] = i;
        //    }
        }
        
    *pcchCompStr = 0;
    *piIPPos     = 0;
    *piStartUndetStrPos = 0;
    *pcchUndetStr =0;
    *piEditStart = 0;
    *piEditLen = 0;
    Dbg(DBGID_IMEPAD, ("CImeIPoint::GetAllCompositionInfo END\n"));

    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::GetIpCandidate
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::GetIpCandidate(DWORD        dwCharId,
                           IPCANDIDATE **ppImeItem,
                           INT *        piColumn,
                           INT *        piCount)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::GetIpCandidate\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::SelectIpCandidate
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::SelectIpCandidate(DWORD dwCharId, INT iselno)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::SetIpCandidate\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::UpdateContext

    Update IME context and send it to the application
----------------------------------------------------------------------------*/
STDMETHODIMP CIImeIPoint::UpdateContext(BOOL fGenerateMessage)
{
    Dbg(DBGID_IMEPAD, ("CImeIPoint::UpdateContext\n"));

    // TODO:
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\inlines.h ===
//	Inline functions

#if !defined (_INLINES_H__INCLUDED_)
#define _INLINES_H__INCLUDED_

#include "debug.h"
#include "imemisc.h"

#ifndef DEBUG
/////////////////////////////////////////////////////////////////////////////
// New and Delete operator overloading
/*---------------------------------------------------------------------------
	operator new
	Unicode String compare
---------------------------------------------------------------------------*/
__inline void* __cdecl operator new(size_t size)
{
	return (void*)GlobalAllocPtr(GMEM_FIXED, size);
}

/*---------------------------------------------------------------------------
	operator new
	Unicode String compare
---------------------------------------------------------------------------*/
__inline void __cdecl operator delete(void* pv)
{
	if (pv)
		GlobalFreePtr(pv);
}
#endif

// DATA.CPP
__inline BOOL DoEnterCriticalSection(HANDLE hMutex)
{
	if(WAIT_FAILED==WaitForSingleObject(hMutex, 3000))	// Wait 3 seconds
		return(fFalse);
	return(fTrue);
}
    

__inline 
LRESULT OurSendMessage( HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	DWORD_PTR 	dwptResult;
	LRESULT		lResult;
	
	DbgAssert( hWnd != (HWND)0 );
	Dbg( DBGID_SendMsg, TEXT("SendMsg - hW=%x uiMsg=%x wP=%x lP=%x"), hWnd, uiMsg, wParam, lParam );

	lResult = SendMessageTimeout( hWnd, uiMsg, wParam, lParam, SMTO_NORMAL, 8000, &dwptResult );
	if( lResult == 0 ) // application didn't respond
		{ 
		AST( lResult != 0 );
		Dbg( DBGID_SendMsg, TEXT("SendMsg - *TIMEOUT*"));
		PostMessage( hWnd, uiMsg, wParam, lParam );		// post anyway
		}
	Dbg( DBGID_SendMsg, TEXT("SendMsg - Exit = %x hW=%x uiMsg=%x wP=%x lP=%x"), dwptResult, hWnd, uiMsg, wParam, lParam );

	return (LRESULT)dwptResult;
}

/////////////////////////////////////////////////////////////////////////////
// Wide String Functions 
// Win95 does not support lstrcmpW, lstrcpyW, lstrcatW

/*---------------------------------------------------------------------------
	StrCmpW
	Unicode String compare
---------------------------------------------------------------------------*/
__inline INT StrCmpW(WCHAR* pwSz1, WCHAR* pwSz2)
{
	INT cch1 = lstrlenW( pwSz1 );
	INT cch2 = lstrlenW( pwSz2 );

	if( cch1 != cch2 ) {
		return cch2 - cch1;
	}

	INT i;
	for( i=0; i<cch1; i++ ) {
		if( pwSz1[i] != pwSz2[i] ) {
			return i+1;
		}
	}
	return 0;

}

/*---------------------------------------------------------------------------
	StrCopyW
	Unicode String copy
---------------------------------------------------------------------------*/
__inline INT StrCopyW(LPWSTR pwSz1, LPCWSTR pwSz2)
{
	INT cch = 0;
	while( *pwSz2 ) {
		*pwSz1 = *pwSz2;
		pwSz1 ++;
		pwSz2 ++;
		cch++;
	}
	*pwSz1 = L'\0';
	return cch;
}


/*---------------------------------------------------------------------------
	StrnCopyW
	Unicode String copy
---------------------------------------------------------------------------*/
__inline LPWSTR StrnCopyW(LPWSTR pwDest, LPCWSTR pwSrc, UINT uiCount)
{
	LPWSTR pwStart = pwDest;

	while (uiCount && (*pwDest++ = *pwSrc++))	// copy string 
		uiCount--;

	if (uiCount)							    // pad out with zeroes
		while (--uiCount)
			*pwDest++ = 0;

	return (pwStart);
}

__inline 
LRESULT OurSendMessageNoPost( HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	DWORD_PTR 	dwptResult;
	LRESULT		lResult;

	Dbg( DBGID_SendMsg, TEXT("SendMsgNoPost - hW=%x uiMsg=%x wP=%x lP=%x"), hWnd, uiMsg, wParam, lParam );
	lResult = SendMessageTimeout( hWnd, uiMsg, wParam, lParam, SMTO_NORMAL, 100, &dwptResult );
	Dbg( DBGID_SendMsg, TEXT("SendMsgNoPost - Exit = %x hW=%x uiMsg=%x wP=%x lP=%x"), dwptResult, hWnd, uiMsg, wParam, lParam );
	return (LRESULT)dwptResult;
}

__inline 
BOOL IsWin( HWND hWnd )
{
	return (hWnd && IsWindow(hWnd));
}

__inline 
LRESULT OurPostMessage( HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	LRESULT lResult;

	Dbg( DBGID_SendMsg, TEXT("PostMsg - hW=%x uiMsg=%x wP=%x lP=%x"), hWnd, uiMsg, wParam, lParam );
	lResult = PostMessage( hWnd, uiMsg, wParam, lParam);
	return (LRESULT)lResult;
}

__inline 
BOOL	IsShiftKeyPushed( LPBYTE lpbKeyState )
{
	return lpbKeyState[VK_SHIFT] & 0x80;
}

__inline 
BOOL IsControlKeyPushed( LPBYTE lpbKeyState )
{
	return lpbKeyState[VK_CONTROL] & 0x80;
}

#endif // __INLINES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\pad.h ===
/****************************************************************************
	PAD.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IME PAD wrapper functions

	History:
	10-APR-1999 cslim       Created
*****************************************************************************/

#if !defined (_PAD_H__INCLUDED_)
#define _PAD_H__INCLUDED_

BOOL BootPad(HWND hUIWnd, UINT uiType, LPARAM lParam);

#endif // _PAD_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\lexheader.h ===
#if !defined(_LEXHEADER_H__INCLUDED_)
#define _LEXHEADER_H__INCLUDED_

#define DEFAULT_LEX_FILE_NAME "IMEKR.LEX"	// if no reg found will use this name
#define DICT_HEADER_SIZE 512
#define COPYRIGHT_STR "(C) 1997 Hangul Engineering Team. Microsoft Corp. All rights reserved.\n"
#define LEX_VERSION					0x1100
#define LEX_COMPATIBLE_VERSION_LIMIT	0x2000
#define LEX_FILE_NAME _T("IMEKR.LEX")

#define TOTAL_NUMBER_OF_HANGUL_MAPPING	(484 + 18) // K0+K1 + # of symbols( - )
#define TOTAL_NUMBER_OF_HANJA			7744
#define MAX_NUMBER_OF_HANJA_SAME_PRONUNC 103
#define MAX_SENSE_LENGTH	50

struct  _DictHeader {
	char	COPYRIGHT_HEADER[150];
	WORD	Version;
	UINT	NumOfHangulEntry;
	UINT	MaxNumOfHanja;
	DWORD	Headersize;
	DWORD	iBufferStart;	// seek point
	UINT	uiNumofHanja;
	DWORD	reserved[10];
	_DictHeader() { 
		Version = 0;
		iBufferStart = Headersize= 0;

		ZeroMemory(reserved, sizeof(reserved));
		ZeroMemory(COPYRIGHT_HEADER, sizeof(COPYRIGHT_HEADER));
		lstrcpy(COPYRIGHT_HEADER, COPYRIGHT_STR);
		COPYRIGHT_HEADER[lstrlen(COPYRIGHT_HEADER)+1] = '\032';
	}
};

struct _LexIndex {
	WCHAR	wcHangul;
	WORD	wNumOfK0, wNumOfK1;
	UINT	iOffset;

	_LexIndex() {
		wcHangul = 0;
		wNumOfK0 = wNumOfK1 = 0;
		iOffset = 0;
	}
};

struct HanjaToHangulIndex 
{
	WCHAR	wchHanja;
	WCHAR	wchHangul;
	UINT	iOffset;

	HanjaToHangulIndex() 
	{
		wchHanja = wchHangul = 0;
		iOffset = 0;
	}
};


#endif // !defined(_LEXHEADER_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\ipoint.h ===
/****************************************************************************
	IPOINT.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IImeIPoint1 interface
	
	History:
	20-JUL-1999 cslim       Created
*****************************************************************************/

#if !defined(_IPOINT_H__INCLUDED_)
#define _IPOINT_H__INCLUDED_

#include <objbase.h>
#include "ipoint1.h"
#include "imc.h"

class CIImeIPoint : public IImeIPoint1
{
// Ctor and Dtor
public:
	CIImeIPoint();
	~CIImeIPoint();

// IImePoint1 Methods
public:
	STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID * ppvObj);
	STDMETHODIMP_(ULONG) AddRef(VOID);
	STDMETHODIMP_(ULONG) Release(VOID);
	
	STDMETHODIMP InsertImeItem		(IPCANDIDATE* pImeItem, INT iPos, DWORD *lpdwCharId);
	STDMETHODIMP ReplaceImeItem		(INT iPos, INT iTargetLen, IPCANDIDATE* pImeItem, DWORD *lpdwCharId);
	STDMETHODIMP InsertStringEx		(WCHAR* pwSzInsert, INT cchSzInsert, DWORD *lpdwCharId);
	STDMETHODIMP DeleteCompString	(INT	iPos, INT cchSzDel);
	STDMETHODIMP ReplaceCompString	(INT	iPos,
									 INT	iTargetLen, 
									 WCHAR	*pwSzInsert, 
									 INT	cchSzInsert,
									 DWORD	*lpdwCharId);
	STDMETHODIMP ControlIME			(DWORD dwIMEFuncID, LPARAM lpara);
	STDMETHODIMP GetAllCompositionInfo(WCHAR	**ppwSzCompStr,
										DWORD	**ppdwCharID,
										INT		*pcchCompStr,
										INT		*piIPPos,
										INT		*piStartUndetStrPos,
										INT		*pcchUndetStr,
										INT		*piEditStart,
										INT		*piEditLen);
	STDMETHODIMP GetIpCandidate		(DWORD dwCharId,
										IPCANDIDATE **ppImeItem,
										INT *piColumn,
										INT *piCount);
	STDMETHODIMP SelectIpCandidate	(DWORD dwCharId, INT iselno);
	STDMETHODIMP UpdateContext		(BOOL fGenerateMessage);

// Helper functions
public:
	HRESULT Initialize(HIMC hIMC);
	VOID GetImeCtx(VOID** ppImeCtx )
	{
		*ppImeCtx = (VOID*)m_pCIMECtx;
	}

// Internal data
protected:
	ULONG		m_cRef;			// Ref count
	CIMECtx*	m_pCIMECtx;		// IME Input Context handle

	HIMC		m_hIMC;

	// char serial number
	DWORD		m_dwCharNo;
};
typedef CIImeIPoint* LPCImeIPoint;

#endif // _IPOINT_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\pmode.cpp ===
/****************************************************************************
   PMODE.CPP : PMode class implementation which manage conversion mode button
                  on the Cicero Toolbar

   History:
      10-JAN-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "pmode.h"
#include "gdata.h"
#include "ui.h"
#include "winex.h"
#include "resource.h"

// {9B34BF53-340A-45bd-9885-61B278EA454E}
const GUID GUID_LBI_KORIME_PMODE = 
{
    0x9b34bf53, 
    0x340a, 
    0x45bd, 
    { 0x98, 0x85, 0x61, 0xb2, 0x78, 0xea, 0x45, 0x4e }
};

/*---------------------------------------------------------------------------
    PMode::PMode
---------------------------------------------------------------------------*/
PMode::PMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    szText[0] = L'\0';
    
    m_pTb = ptb;

    // Set Add/Remove text and tootip text
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_TT_IME_PAD, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_SYSTEMLANGBARITEM_KEYBOARD, 
                GUID_LBI_KORIME_PMODE,
                TF_LBI_STYLE_BTN_BUTTON,
                230, 
                szText);
    SetToolTip(szText);

    // Set button text. Use tooltip text.
    // OurLoadStringW(vpInstData->hInst, IDS_STATUS_BUTTON_IME_PAD, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}

/*---------------------------------------------------------------------------
    PMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) PMode::Release()
{
    long cr;

    cr = --m_cRef;
    DbgAssert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    PMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI PMode::GetIcon(HICON *phIcon)
{
    DWORD dwCM   = GetCMode();
    UINT  uiIcon = IDI_CMODE_IMEPAD;
    
    *phIcon = LoadIcon(vpInstData->hInst, MAKEINTRESOURCE(uiIcon));
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    PMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI PMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    PMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI PMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT PMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{

    OurPostMessage(GetActiveUIWnd(), WM_MSIME_IMEPAD, 0, 0);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT PMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\names.h ===
/****************************************************************************
	NAMES.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Const strings
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (__NAMES_H__)
#define __NAMES_H__

const CHAR szModuleName[] 	  = "IMEKR2002.IME";
const CHAR szUIClassName[]	  = "IMEKR2002_MAIN";
const WCHAR wszUIClassName[]	  = L"IMEKR2002_MAIN";
const CHAR szStatusClassName[]	  = "IMEKR2002_STAT";
const CHAR szCompClassName[]	  = "IMEKR2002_COMP";
const CHAR szCandClassName[]	  = "IMEKR2002_CAND";
const CHAR szTooltipClassName[]	  = "IMEKR2002_TOOLTIP";
const WCHAR wszTooltipClassName[] = L"IMEKR2002_TOOLTIP";

const WCHAR wzIMECompFont[] = { 0xAD74, 0xB9BC, 0x0000 };	// Gulim
const CHAR  szIMECompFont[] = "\xB1\xBC\xB8\xB2";

#endif //!defined (__NAMES_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\pad.cpp ===
/****************************************************************************
    PAD.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IME PAD wrapper functions

    History:
    10-APR-1999 cslim       Created
*****************************************************************************/

#include "precomp.h"
#include "cpadsvr.h"
#include "pad.h"
#include "cimecb.h"


BOOL BootPad(HWND hUIWnd, UINT uiType, LPARAM lParam)
{
    LPCImePadSvr lpCImePadSvr;
    HIMC         hIMC;
    IImeIPoint1* pIP;
    INT             iRet;
    BOOL         fVisible;
    BOOL          fRet = fFalse;
    
    Dbg(DBGID_IMEPAD, TEXT("BootPad() : hUIWnd = 0x%04X, uiType = 0x%04X, lParam = 0x%08lX"), hUIWnd, uiType, lParam);

    lpCImePadSvr = CImePadSvr::LoadCImePadSvr(CIMEPADSVR_SHAREDMEM);
    
    if(lpCImePadSvr)
        {
        // Check if already visible state. Toggle IME Pad
        lpCImePadSvr->IsVisible(&fVisible);
        if (fVisible)
            {
            lpCImePadSvr->ShowUI(fFalse);
            // CImePadSvr::DestroyCImePadSvr();
            return fTrue;
            }

        iRet = lpCImePadSvr->Initialize(MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), 0, NULL);
        DbgAssert(iRet == 0);
        if (iRet ==0) // Succeeded
            {
            hIMC = GethImcFromHwnd(hUIWnd);
            pIP = GetImeIPoint(hIMC);

            if (pIP)
                {
                lpCImePadSvr->SetIUnkIImeIPoint((IUnknown *)pIP);
                lpCImePadSvr->SetIUnkIImeCallback((IUnknown *)CImeCallback::Fetch());
                lpCImePadSvr->ShowUI(fTrue);
                }
            else
                {
                DbgAssert(0);
                return fFalse;
                }
                
            fRet = fTrue;
            }
        else
            CImePadSvr::DestroyCImePadSvr();
        }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\pmode.h ===
//
// CMODE.H
//

#if !defined (__PMODE_H__INCLUDED_)
#define __PMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class PMode : public CCicButton
{
public:
    PMode(CToolBar *ptb);
    ~PMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:
	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __PMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\precomp.h ===
/****************************************************************************
	PRECOMP.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Precompiled header
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#define _IMM_
#include	<windows.h>
#include	<windowsx.h>
#undef _IMM_
#include <commctrl.h>
#include "immdev.h"
#include "immsys.h"
#include <ime.h>

// fTrue and fFalse
#ifndef fTrue
	#define fTrue 1
#endif
#ifndef fFalse
	#define fFalse 0
#endif

// PRIVATE and PUBLIC
#ifndef PRIVATE
	#define PRIVATE static
#endif
#ifndef PUBLIC
	#define PUBLIC extern
#endif

#define CP_KOREA (949)

// Project specific headers
#pragma hdrstop
#include "inlines.h"
#include "imedefs.h"
#include "imc.h"
#include "imcsub.h"
#include "gdata.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\propmode.h ===
//
// PROPBUT.H
//

#if !defined (__PROPBUT_H__INCLUDED_)
#define __PROPBUT_H__INCLUDED_

#include "buttoncc.h"
#include "toolbar.h"

class PropertyButton : public CLBarItemButtonBase
{
public:
    PropertyButton(CToolBar *ptb);
    ~PropertyButton() {}

    STDMETHODIMP GetIcon(HICON *phIcon);

private:
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);

	CToolBar *m_pTb;
};

#endif // __PROPBUT_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\statusui.cpp ===
/****************************************************************************
    STATUSUI.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Status window UI functions
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "ui.h"
#include "config.h"
#include "names.h"
#include "escape.h"
#include "winex.h"
#include "cpadsvr.h"
#include "debug.h"

#define ABS(A)      ((A) <  0  ? -(A) : (A))
inline BOOL IsValidButton(INT iButton)
{
    return (iButton>=0 && iButton<MAX_NUM_OF_STATUS_BUTTONS);
}

///////////////////////////////////////////////////////////////////////////////
PRIVATE VOID PASCAL FrameControl(HDC hDC, RECT* pRc, INT iState);
PRIVATE VOID PASCAL PaintStatusWindow(HWND hStatusWnd, HDC hDC);
PRIVATE BOOL StatusOnSetCursor(HWND, HWND, UINT, UINT);
PRIVATE VOID StatusOnLButtonUp(HWND, INT, INT, UINT);
PRIVATE VOID StatusOnMouseMove(HWND, INT, INT, UINT);

PRIVATE VOID PASCAL DestroyStatusWindow(HWND hStatusWnd);
PRIVATE VOID PASCAL AdjustStatusBoundary(LPPOINT lppt);
PRIVATE VOID PASCAL UpdateStatusTooltip(HWND hStatusWnd, HWND hStatusTTWnd);

PRIVATE BOOL    vfAnyButtonDown=fFalse;
PRIVATE BOOL    vfPrevButton=-1;
PRIVATE POINT vfptDown;

///////////////////////////////////////////////////////////////////////////////
struct _StatusButtonInfo 
    {
    int        m_Width, m_Height;
    WORD    m_BmpNormalID[MAX_NUM_OF_STATUS_BUTTONS];
    WORD    m_BmpOnMouseID[MAX_NUM_OF_STATUS_BUTTONS];
    WORD    m_BmpPushedID[MAX_NUM_OF_STATUS_BUTTONS];
    WORD    m_BmpDownOnMouseID[MAX_NUM_OF_STATUS_BUTTONS];
    WORD    m_ToolTipStrID[MAX_NUM_OF_STATUS_BUTTONS];
    };

static _StatusButtonInfo StatusButtonInfo[NUM_OF_BUTTON_SIZE] = 
    {
        // Small size button
        { 0, 0, },
        
        // Medium size button
        { 19, 19,  // Bitmap size
    #if !defined(_M_IA64)
        // Normal buttons images
        {IDB_STAT_HANGUL,         IDB_STAT_BANJA,        IDB_STAT_CHINESEOFF,      IDB_STAT_IMEPAD}, 
        // Pushed and mouse hover images
        {IDB_STAT_ON_ENGLISH,     IDB_STAT_ON_JUNJA,     IDB_STAT_CHINESEOFF,      IDB_STAT_IMEPAD},
        // Pushed buttons
        {IDB_STAT_ENGLISH,        IDB_STAT_JUNJA,        IDB_STAT_CHINESEOFF,      IDB_STAT_IMEPAD_DOWN},
        // Pushed and mouse down images
        {IDB_STAT_ENGLISH_ONDOWN, IDB_STAT_JUNJA_ONDOWN, IDB_STAT_CHINESEOFF,      IDB_STAT_IMEPAD/*IDB_STAT_IMEPAD_DOWNHOVER*/},
        // Tooltips string
        {IDS_STATUS_TT_HAN_ENG,   IDS_STATUS_TT_JUN_BAN, IDS_STATUS_TT_HANJA_CONV, IDS_STATUS_TT_IME_PAD},
    #else
        // Normal buttons images
        {IDB_STAT_HANGUL,         IDB_STAT_BANJA,        IDB_STAT_CHINESEOFF }, 
        // Pushed and mouse hover images
        {IDB_STAT_ON_ENGLISH,     IDB_STAT_ON_JUNJA,     IDB_STAT_CHINESEOFF },
        // Pushed buttons
        {IDB_STAT_ENGLISH,        IDB_STAT_JUNJA,        IDB_STAT_CHINESEOFF },
        // Pushed and mouse down images
        {IDB_STAT_ENGLISH_ONDOWN, IDB_STAT_JUNJA_ONDOWN, IDB_STAT_CHINESEOFF },
        // Tooltips string
        {IDS_STATUS_TT_HAN_ENG,   IDS_STATUS_TT_JUN_BAN, IDS_STATUS_TT_HANJA_CONV },
    #endif
        },

        // Large size button
        { 0, 0, }
    };

void UpdateStatusButtons(CIMEData &ImeData)
{
    UINT i;
    INT iButtonSize;
    INT iButtonType;

    iButtonSize = ImeData->iCurButtonSize;

#ifdef DEBUG
    OutputDebugString(TEXT("UpdateStatusButtons():\r\n"));
#endif

    ImeData->xButtonWi = StatusButtonInfo[iButtonSize].m_Width;
    ImeData->yButtonHi = StatusButtonInfo[iButtonSize].m_Height;

    DbgAssert(ImeData->uNumOfButtons <= MAX_NUM_OF_STATUS_BUTTONS);
    for (i=0; i<ImeData->uNumOfButtons; i++) 
        {
        iButtonType = ImeData->StatusButtons[i].m_ButtonType;

        ImeData->StatusButtons[i].m_BmpNormalID  = StatusButtonInfo[iButtonSize].m_BmpNormalID[iButtonType];
        ImeData->StatusButtons[i].m_BmpOnMouseID = StatusButtonInfo[iButtonSize].m_BmpOnMouseID[iButtonType];
        ImeData->StatusButtons[i].m_BmpPushedID  = StatusButtonInfo[iButtonSize].m_BmpPushedID[iButtonType];
        ImeData->StatusButtons[i].m_BmpDownOnMouseID = StatusButtonInfo[iButtonSize].m_BmpDownOnMouseID[iButtonType];
        ImeData->StatusButtons[i].m_ToolTipStrID = StatusButtonInfo[iButtonSize].m_ToolTipStrID[iButtonType];
        // Default value is enabled
        ImeData->StatusButtons[i].m_fEnable = fTrue;
        }
}

void UpdateStatusWinDimension()
{
    CIMEData    ImeData(CIMEData::SMReadWrite);

    // Caculate status window size
    ImeData->xStatusWi =  ImeData->cxStatLeftMargin + ImeData->cxStatRightMargin
                          + ImeData->xButtonWi * ImeData->uNumOfButtons;
                          //+ ImeData->cxStatMargin*2;//62;
    ImeData->yStatusHi = ImeData->cyStatMargin*2
                          + ImeData->yButtonHi;
                          //+ pImeData->cyCaptionHeight;// + 2;
                          //+ pImeData->cyStatMargin; //24;

    // Caculate button area.
    ImeData->rcButtonArea.left   = ImeData->cxStatLeftMargin;
    ImeData->rcButtonArea.top    = ImeData->cyStatButton;
    
    ImeData->rcButtonArea.right  = ImeData->xButtonWi*ImeData->uNumOfButtons 
                                    + ImeData->rcButtonArea.left;
    ImeData->rcButtonArea.bottom = /*ImeData->cyStatMargin*2 +*/ ImeData->cyStatButton + ImeData->yButtonHi;
}


///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK StatusWndProc(HWND hStatusWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    POINT ptCursor;    

    Dbg(DBGID_UI, TEXT("StatusWndProc():uMessage = 0x%08lX, wParam = 0x%04X, lParam = 0x%08lX"), uMessage, wParam, lParam);

    switch (uMessage) 
        {
        case WM_IME_CHAR:            case WM_IME_COMPOSITIONFULL:
        case WM_IME_COMPOSITION:    case WM_IME_CONTROL:
        case WM_IME_SELECT:
        case WM_IME_SETCONTEXT:        case WM_IME_STARTCOMPOSITION:
        case WM_IME_ENDCOMPOSITION:
            return (0L);

        HANDLE_MSG(hStatusWnd, WM_SETCURSOR, StatusOnSetCursor);
        HANDLE_MSG(hStatusWnd, WM_LBUTTONUP, StatusOnLButtonUp);
        HANDLE_MSG(hStatusWnd, WM_MOUSEMOVE, StatusOnMouseMove);

        case WM_DESTROY:
            DestroyStatusWindow(hStatusWnd);
            break;

        case WM_PAINT:
            {
                HDC         hDC;
                PAINTSTRUCT ps;

                hDC = BeginPaint(hStatusWnd, &ps);
                PaintStatusWindow(hStatusWnd, hDC);
                EndPaint(hStatusWnd, &ps);
            }
            break;

        case WM_TIMER:
            {
            CIMEData    ImeData;

            GetCursorPos(&ptCursor);
            ScreenToClient(hStatusWnd, &ptCursor);
            if ( PtInRect(&ImeData->rcButtonArea, ptCursor) == fFalse )
                {
                InitButtonState();
                KillTimer( hStatusWnd, TIMER_UIBUTTON );
                InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
                }
            }
            break;
            
        default :
                return DefWindowProc(hStatusWnd, uMessage, wParam, lParam);
        }
    return (0L);
}

///////////////////////////////////////////////////////////////////////////////
// S T A T U S  W I N D O W  M S G  R O U T I N E S
BOOL StatusOnSetCursor(HWND hStatusWnd, HWND hWndCursor, UINT codeHitTest, UINT message)
{
    POINT ptCursor, ptSavCursor;
    RECT  rcWnd;
    BOOL  fDragArea = fFalse;
    int      iCurButton;
    HWND        hUIWnd;
    CIMEData       ImeData(CIMEData::SMReadWrite);

    GetCursorPos(&ptCursor);
    ptSavCursor = ptCursor;
    ScreenToClient(hStatusWnd, &ptCursor);

    Dbg(DBGID_UI, TEXT("StatusOnSetCursor():  ptCursor.x = %d, ptCursor.y = %d"), ptCursor.x, ptCursor.y);

    SetCursor(LoadCursor(NULL, IDC_ARROW));
    if (PtInRect(&ImeData->rcButtonArea, ptCursor)) 
        {
        //SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
    else 
        {
    //    SetCursor(LoadCursor(vpInstData->hInst, MAKEINTRESOURCE(IDC_IME_HAND)));
        fDragArea = fTrue;
        }

    switch (message)
        {
        case WM_LBUTTONDOWN:
            SetCapture(hStatusWnd);
            if (fDragArea) // if drag start
                {
                SystemParametersInfo(SPI_GETWORKAREA, 0, &ImeData->rcWorkArea, 0);
                SetWindowLong(hStatusWnd, UI_MOVE_XY, MAKELONG(ptSavCursor.x, ptSavCursor.y));
                GetWindowRect(hStatusWnd, &rcWnd);
                SetWindowLong(hStatusWnd, UI_MOVE_OFFSET, 
                                          MAKELONG(ptSavCursor.x - rcWnd.left, ptSavCursor.y - rcWnd.top));
                } 
            else 
                {
                InitButtonState();
                if (!ImeData->StatusButtons[(ptCursor.x-ImeData->cxStatLeftMargin)/ImeData->xButtonWi].m_fEnable)
                    {
                    ReleaseCapture();
                    break;
                    }
                vfPrevButton = (ptCursor.x-ImeData->cxStatLeftMargin)/ImeData->xButtonWi;
                vfptDown = ptSavCursor;
                ImeData->StatusButtons[vfPrevButton].m_uiButtonState = BTNSTATE_ONMOUSE | BTNSTATE_DOWN;
                vfAnyButtonDown = fTrue;
                InvalidateRect(hStatusWnd, &ImeData->rcButtonArea, fFalse);
                }

            break;

        case WM_LBUTTONUP:
//            if ((fdwUIFlags & UIF_CHIPRESS) && PtInRect((LPRECT)&rcChi, ptPos)) {
//                    keybd_event(VK_HANJA, 0, 0, 0);
//                    keybd_event(VK_HANJA, 0, KEYEVENTF_KEYUP, 0);
//                    fdwUIFlags &= ~UIF_CHIPRESS;
//            }
            break;

        case WM_RBUTTONDOWN:
            // if right button click, finalize interim
            HIMC hIMC;
    
            hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
            hIMC = GethImcFromHwnd(hUIWnd);
            if (hIMC)
                OurImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
            break;

        case WM_RBUTTONUP:
            //UIPopupMenu(GetWindow(hStatusWnd, GW_OWNER));
            OurPostMessage(GetWindow(hStatusWnd, GW_OWNER), WM_MSIME_OPENMENU, 0, 0);
            break;

        case WM_MOUSEMOVE:
            iCurButton = (ptCursor.x-ImeData->cxStatLeftMargin)/ImeData->xButtonWi;
            if (!IsValidButton(iCurButton))
                break;
                
            if (!ImeData->StatusButtons[iCurButton].m_fEnable)
                break;
                
            if (fDragArea) 
                {
                if (vfPrevButton != -1 &&
                    (ImeData->StatusButtons[vfPrevButton].m_uiButtonState & BTNSTATE_ONMOUSE))
                    {
                    ImeData->StatusButtons[vfPrevButton].m_uiButtonState &= ~BTNSTATE_ONMOUSE;
                    InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
                    }
                }
            else 
                {
                if (!(ImeData->StatusButtons[iCurButton].m_uiButtonState & BTNSTATE_ONMOUSE))
                    {
                    ImeData->StatusButtons[iCurButton].m_uiButtonState |= BTNSTATE_ONMOUSE;
                    if (vfPrevButton != -1) 
                        ImeData->StatusButtons[vfPrevButton].m_uiButtonState = BTNSTATE_NORMAL;
                    
                    vfPrevButton = iCurButton;
                    SetTimer(hStatusWnd, TIMER_UIBUTTON, 200, NULL);
                    InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
                    }
                }
            break;
        }

    if (hStatusWnd)
        {
        // Send Tooltip relay msg
        HGLOBAL            hUIPrivate;
        LPUIPRIV        lpUIPrivate;
        MSG                msg;

        hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
        hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
        if (!hUIPrivate)
            return fTrue;
        
        lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
        if (!lpUIPrivate) // can not draw candidate window
            return fTrue;
        
        if (lpUIPrivate->hStatusTTWnd) 
            {
            ZeroMemory(&msg, sizeof(MSG));
            msg.message = message;
            msg.hwnd = hStatusWnd; 
            msg.wParam = 0;
            msg.lParam = MAKELONG(ptCursor.x, ptCursor.y);
            OurSendMessage(lpUIPrivate->hStatusTTWnd, TTM_RELAYEVENT, 0, (LPARAM) (LPMSG) &msg);
            }
        
        GlobalUnlock(hUIPrivate);
        }

    return fTrue;
}

// if mouse down, and user move mouse cursor
void StatusOnMouseMove(HWND hStatusWnd, int xPos, int yPos, UINT wParam)
{
    POINT    ptCursor;
    int        iCurButton;
    RECT    rcWnd;
    LONG     lCursorOffset;
    CIMEData    ImeData(CIMEData::SMReadWrite);

    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) 
        {
        GetCursorPos(&ptCursor);
        SetWindowLong(hStatusWnd, UI_MOVE_XY, MAKELONG(ptCursor.x, ptCursor.y));

        lCursorOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

        // calculate the org by the offset
        ptCursor.x -= (*(LPPOINTS)&lCursorOffset).x;
        ptCursor.y -= (*(LPPOINTS)&lCursorOffset).y;
    
        fSetStatusWindowPos(hStatusWnd, &ptCursor);
        }
    else 
        {
        GetCursorPos(&ptCursor);
        if (vfAnyButtonDown && 
            (ABS(vfptDown.x - ptCursor.x)>3 || ABS(vfptDown.y - ptCursor.y)>3) ) 
            {
            SystemParametersInfo(SPI_GETWORKAREA, 0, &ImeData->rcWorkArea, 0);
            SetWindowLong(hStatusWnd, UI_MOVE_XY, MAKELONG(vfptDown.x, vfptDown.y));
            GetWindowRect(hStatusWnd, &rcWnd);
            SetWindowLong(hStatusWnd, UI_MOVE_OFFSET, 
                        MAKELONG(vfptDown.x - rcWnd.left, vfptDown.y - rcWnd.top));

            lCursorOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

            // calculate the org by the offset
            ptCursor.x -= (*(LPPOINTS)&lCursorOffset).x;
            ptCursor.y -= (*(LPPOINTS)&lCursorOffset).y;
    
            fSetStatusWindowPos(hStatusWnd, &ptCursor);

            InitButtonState();
            }
        else
            {
            ptCursor.x = xPos;    ptCursor.y = yPos;
            iCurButton = (ptCursor.x-ImeData->cxStatLeftMargin)/ImeData->xButtonWi;
            if (IsValidButton(iCurButton))
                {
                if (PtInRect(&ImeData->rcButtonArea, ptCursor)) 
                    {
                    if ( !(ImeData->StatusButtons[iCurButton].m_uiButtonState & BTNSTATE_ONMOUSE) ) 
                        {
                        ImeData->StatusButtons[iCurButton].m_uiButtonState |= BTNSTATE_ONMOUSE;
                        if (vfPrevButton != -1) 
                            {
                            ImeData->StatusButtons[vfPrevButton].m_uiButtonState = BTNSTATE_NORMAL;
                            vfPrevButton = iCurButton;
                            }
                        InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
                        }
                    }
                else 
                    {
                    InitButtonState();
                    InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
                    }
                }
            }
        }
}

void StatusOnLButtonUp(HWND hStatusWnd, int x, int y, UINT keyFlags)
{
    POINT    ptCursor;
    int        iCurButton;
    CIMEData    ImeData(CIMEData::SMReadWrite);

    Dbg(DBGID_UI, TEXT("StatusOnLButtonUp() : x=%d, y=%d"), x, y);
    vfAnyButtonDown = fFalse;
    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) 
        {
        Dbg(DBGID_UI, TEXT("StatusOnLButtonUp() : Dragging mode"));
        LPARAM lTmpCursor, lTmpOffset;
        
        lTmpCursor = GetWindowLong(hStatusWnd, UI_MOVE_XY);
        lTmpOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

        // calculate the org by the offset
        ptCursor.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
        ptCursor.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

        SetWindowLong(hStatusWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
        ReleaseCapture();

        fSetStatusWindowPos(hStatusWnd, &ptCursor);
        } 
    else 
        {
        Dbg(DBGID_UI, TEXT("StatusOnLButtonUp() : Non-Dragging mode. Button check"));

        ReleaseCapture();

        ptCursor.x = x;    ptCursor.y = y;
        if (!PtInRect(&ImeData->rcButtonArea, ptCursor)) 
            {
            InitButtonState();
            goto StatusOnLButtonUpExit;
            }

        iCurButton = (x-ImeData->cxStatLeftMargin)/ImeData->xButtonWi;
        if (IsValidButton(iCurButton))
            {
            ImeData->StatusButtons[vfPrevButton].m_uiButtonState &= ~BTNSTATE_DOWN;

            switch (ImeData->StatusButtons[iCurButton].m_ButtonType) 
                {
                case HAN_ENG_TOGGLE_BUTTON:
                    //if (lpIMC->fdwConversion & IME_CMODE_HANGUL)
                    //    ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
                    //fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_HANGUL;
                    //OurImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
                    keybd_event(VK_HANGUL, 0, 0, 0);
                    keybd_event(VK_HANGUL, 0, KEYEVENTF_KEYUP, 0);
                    //ImeData->StatusButtons[iCurButton].m_uiButtonState = BTNSTATE_ONMOUSE;
                    break;
                    
                case JUNJA_BANJA_TOGGLE_BUTTON:
                    //fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_FULLSHAPE;
                    //OurImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
                    keybd_event(VK_JUNJA, 0, 0, 0);
                    keybd_event(VK_JUNJA, 0, KEYEVENTF_KEYUP, 0);
                    break;
                    
                case HANJA_CONV_BUTTON:
                    //fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_HANJACONVERT;
                    keybd_event(VK_HANJA, 0, 0, 0);
                    keybd_event(VK_HANJA, 0, KEYEVENTF_KEYUP, 0);
                    break;
                    
                case IME_PAD_BUTTON:
                    OurPostMessage(GetWindow(hStatusWnd, GW_OWNER), WM_MSIME_IMEPAD, 0, 0);
                    break;

                default:
                    DbgAssert(0);    // impossible
                }
            }
        }

StatusOnLButtonUpExit:
    InvalidateRect( hStatusWnd, &ImeData->rcButtonArea, fFalse );
}

///////////////////////////////////////////////////////////////////////////////
// Static functions
void PASCAL DestroyStatusWindow(HWND hStatusWnd)
{
    HWND     hUIWnd;
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate) // can not darw status window
        return;


    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) // can not draw status window
        return;
    
    lpUIPrivate->nShowStatusCmd = SW_HIDE;

    lpUIPrivate->hStatusWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

// open status window
void PASCAL OpenStatus(HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HIMC     hIMC;
    PCIMECtx pImeCtx;
    CIMEData ImeData(CIMEData::SMReadWrite);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate) // can not darw status window
        return;
    
    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) // can not draw status window
        return;

    if (ImeData->ptStatusPos.x == -1)
        GetRegValues(GETSET_REG_STATUSPOS|GETSET_REG_STATUS_BUTTONS);


    // if fail to read reg
    if (ImeData->ptStatusPos.x == -1) 
        {
        // DbgAssert(0);
        // Default position
        ImeData->ptStatusPos.x = ImeData->rcWorkArea.right - ImeData->xStatusWi;
        ImeData->ptStatusPos.y = ImeData->rcWorkArea.bottom - ImeData->yStatusHi;
        }

    hIMC = GethImcFromHwnd(hUIWnd);
    if (pImeCtx = GetIMECtx(hIMC))
        {
        // Adjust Status window position force to whithin work area
        AdjustStatusBoundary(&ImeData->ptStatusPos);
        pImeCtx->SetStatusWndPos(ImeData->ptStatusPos);
        } 

    if (lpUIPrivate->hStatusWnd) 
        {
        SetWindowPos(lpUIPrivate->hStatusWnd, 0,
                    ImeData->ptStatusPos.x, ImeData->ptStatusPos.y,
                    ImeData->xStatusWi, ImeData->yStatusHi,
                    SWP_NOACTIVATE|SWP_NOZORDER);
        } 
    else 
        {    // create status window
        lpUIPrivate->hStatusWnd = CreateWindowEx(
                                    0,
                                    szStatusClassName, TEXT("\0"),
                                    WS_POPUP|WS_DISABLED,
                                    ImeData->ptStatusPos.x, ImeData->ptStatusPos.y,
                                    ImeData->xStatusWi, ImeData->yStatusHi, 
                                    hUIWnd, (HMENU)NULL, vpInstData->hInst, NULL);

        if (!lpUIPrivate->hStatusWnd)
            goto OpenStatusUnlockUIPriv;

        SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
        SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_XY, 0L);

        // Create Tooltip window
        if (IsWinNT())
            lpUIPrivate->hStatusTTWnd = CreateWindowW(wszTooltipClassName, NULL,
                                            TTS_ALWAYSTIP|WS_DISABLED, 
                                            CW_USEDEFAULT, CW_USEDEFAULT, 
                                            CW_USEDEFAULT, CW_USEDEFAULT,
                                            lpUIPrivate->hStatusWnd, (HMENU) NULL, vpInstData->hInst, NULL);
        else
            lpUIPrivate->hStatusTTWnd = CreateWindow(szTooltipClassName, NULL,
                                            TTS_ALWAYSTIP|WS_DISABLED, 
                                            CW_USEDEFAULT, CW_USEDEFAULT, 
                                            CW_USEDEFAULT, CW_USEDEFAULT,
                                            lpUIPrivate->hStatusWnd, (HMENU) NULL, vpInstData->hInst, NULL);
    
        DbgAssert(lpUIPrivate->hStatusTTWnd != 0);
        }


    // Check if Pad button disable state
    for (UINT iButton=0; iButton<(ImeData->uNumOfButtons); iButton++)
        {
        if ((ImeData->StatusButtons[iButton].m_ButtonType == IME_PAD_BUTTON))
            {
            if ((vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON) != 0)
                ImeData->StatusButtons[iButton].m_fEnable = fFalse;
            else
                ImeData->StatusButtons[iButton].m_fEnable = fTrue;
            }
        }

    // Draw status button tooltip
    UpdateStatusTooltip(lpUIPrivate->hStatusWnd, lpUIPrivate->hStatusTTWnd);

    ShowStatus(hUIWnd, SW_SHOWNOACTIVATE);

OpenStatusUnlockUIPriv:
    GlobalUnlock(hUIPrivate);
    return;
}

// Show the status window
void ShowStatus(HWND hUIWnd, int nShowStatusCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    Dbg(DBGID_UI, TEXT("ShowStatus():  hUIWnd = 0x%X, nShowStatusCmd = %d"), hUIWnd, nShowStatusCmd);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)     // can not darw status window
        {
        DbgAssert(0);
        return;
        }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)    // can not draw status window
        {
        DbgAssert(0);
        return;
        }

    //
    if (nShowStatusCmd == SW_SHOWNOACTIVATE)
        nShowStatusCmd = vfWndOpen[STATE_WINDOW] ? SW_SHOWNOACTIVATE : SW_HIDE;

    if (!lpUIPrivate->hStatusWnd) 
        {
        // DbgAssert(0);    This occurs if IME status win hide mode
        // not in show status window mode
        } 
    else 
        if (lpUIPrivate->nShowStatusCmd == nShowStatusCmd) 
            {
            // Aleady show/hide status mode
            Dbg(DBGID_UI, TEXT("ShowStatus(): Already Show/Hide mode. No update"));
            } 
        else 
            {
            CIMEData ImeData;

            // Bug: In Win98. close/open status window msg sequence is cause problem 
            //      when IME config DLG popup
            AdjustStatusBoundary(&ImeData->ptStatusPos);            
            SetWindowPos(lpUIPrivate->hStatusWnd, 0,
                        ImeData->ptStatusPos.x, ImeData->ptStatusPos.y,
                        ImeData->xStatusWi, ImeData->yStatusHi,
                        SWP_NOACTIVATE|SWP_NOZORDER);
            ShowWindow(lpUIPrivate->hStatusWnd, nShowStatusCmd);                        
            lpUIPrivate->nShowStatusCmd = nShowStatusCmd;
            }
    
    GlobalUnlock(hUIPrivate);
    return;
}


void PASCAL FrameControl(HDC hDC, RECT* pRc, int iState)
{
    HPEN hPenHigh = 0;
    HPEN hPenShadow = 0;

    switch( iState ) 
        {
        case BTNSTATE_PUSHED:
        case BTNSTATE_HANJACONV:
            hPenHigh = CreatePen( PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW) );
            hPenShadow = CreatePen( PS_SOLID, 1, RGB(255,255,255) );
            break;
        case BTNSTATE_ONMOUSE:
            hPenHigh = CreatePen( PS_SOLID, 1, RGB(255,255,255) );
            hPenShadow = CreatePen( PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW) );
            break;
        default:
            break;
        }

    //FillRect( hDC, pRc, GetSysColorBrush(COLOR_3DFACE) );    // base
    if( iState == BTNSTATE_PUSHED || iState == BTNSTATE_ONMOUSE || iState == BTNSTATE_HANJACONV) 
        {
        HPEN hPenOld = (HPEN)SelectObject( hDC, hPenHigh );
        MoveToEx( hDC, pRc->left, pRc->bottom, NULL );
        LineTo( hDC, pRc->left, pRc->top );
        LineTo( hDC, pRc->right, pRc->top );
        SelectObject( hDC, hPenShadow );
        LineTo( hDC, pRc->right, pRc->bottom );
        LineTo( hDC, pRc->left-1, pRc->bottom );
        SelectObject( hDC, hPenOld );
        DeleteObject( hPenHigh );
        DeleteObject( hPenShadow );
        }
}

// Raster Ops
#define ROP_PSDPxax  0x00B8074AL

void PASCAL PaintStatusWindow(HWND   hStatusWnd, HDC    hDC)
{
    HWND     hUIWnd;
    HIMC     hIMC;
    PCIMECtx pImeCtx;
    //DWORD     dwCMode, dwSent;
    //BOOL     fOpen;
    UINT     uiButtonState, uiDrawButtonShape;
    //HBRUSH        hCaptionBrush;
    HBITMAP     /*hBMStatusWin, hBMOld,*/ hBMButtonOld, /*hBMClient,*/ hBMTmpButton;
    RECT     rcFrame, rcButton;//, rcCaption;
    int         ixButton, iyButton;
    CIMEData  ImeData;
    // to prevent blinking, use second buffer
    HDC         hDCMem = CreateCompatibleDC(hDC);
    HBITMAP     hBmpShow = CreateCompatibleBitmap(hDC, ImeData->xStatusWi, ImeData->yStatusHi);
    HBITMAP     hBmpOldShow = (HBITMAP)SelectObject( hDCMem, hBmpShow );
    HDC         hButtonMemDC = CreateCompatibleDC(hDC);
    LPCTSTR     lpszBtnResouceName;
    
    Dbg(DBGID_UI, TEXT("PaintStatusWindow():  hStatusWnd = 0x%X"), hStatusWnd);

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hIMC = GethImcFromHwnd(hUIWnd);
    //if (!hIMC)
    //    {
    //    DbgAssert(0);
    //    return;
    //    }

    if ((pImeCtx = GetIMECtx(hIMC))==NULL)
        return;

    // Get conversion and open status and
    // fOpen = OurImmGetOpenStatus(hIMC);
    // OurImmGetConversionStatus(hIMC, &dwCMode, &dwSent);

    // Draw Frame
    GetClientRect( hStatusWnd, &rcFrame );
    DbgAssert(ImeData->xStatusWi == rcFrame.right);
    FillRect(hDCMem, &rcFrame, GetSysColorBrush(COLOR_3DFACE));
    DrawEdge(hDCMem, &rcFrame, EDGE_RAISED, BF_RECT);

#if NOTUSED
    // Draw left two verticals
    ::SetRect(&rcButton, 2, ImeData->cyStatMargin-1, 4, ImeData->yStatusHi - ImeData->cyStatMargin);
    FrameControl(hDCMem, &rcButton, BTNSTATE_ONMOUSE);
    ::SetRect(&rcButton, 6, ImeData->cyStatMargin-1, 8, ImeData->yStatusHi - ImeData->cyStatMargin);
    FrameControl(hDCMem, &rcButton, BTNSTATE_ONMOUSE);
#endif

    // Button 1 : This button Always Han/Eng toggle button.
    ixButton = ImeData->cxStatLeftMargin; iyButton = ImeData->cyStatButton;

    for (UINT iButton=0; iButton<ImeData->uNumOfButtons; iButton++) 
        {
        uiButtonState = ImeData->StatusButtons[iButton].m_uiButtonState;
        uiDrawButtonShape = BTNSTATE_NORMAL;

        switch (ImeData->StatusButtons[iButton].m_ButtonType) 
            {
        case HAN_ENG_TOGGLE_BUTTON :
            // if English mode
            if (!(pImeCtx->GetConversionMode() & IME_CMODE_HANGUL))
                {
                // English button always pushed
                uiDrawButtonShape = BTNSTATE_PUSHED;
                // Down and hovering
                if (uiButtonState  & BTNSTATE_DOWN)  // if BTNSTATE_DOWN set, always BTNSTATE_ONMOUSE set too
                    lpszBtnResouceName = // Dented white gray GA
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpDownOnMouseID);
                else
                // If just mouse cursor hovering
                if (uiButtonState & BTNSTATE_ONMOUSE) 
                    {
                    lpszBtnResouceName = // Dented white gray GA
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpOnMouseID);
                    }
                // No mouse
                else
                    lpszBtnResouceName = // Dented gray GA
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                }
            else 
                {
                // Down and hovering
                if (uiButtonState & BTNSTATE_DOWN) // if BTNSTATE_DOWN set, always BTNSTATE_ONMOUSE set too
                    {
                    uiDrawButtonShape = BTNSTATE_PUSHED;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                    }
                else
                    {
                    // Down or hovering
                    if (uiButtonState & BTNSTATE_ONMOUSE)
                        uiDrawButtonShape = BTNSTATE_ONMOUSE;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpNormalID);
                    }
                }
            break;

        case JUNJA_BANJA_TOGGLE_BUTTON:
            if (pImeCtx->IsOpen() && (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE)) 
                {
                uiDrawButtonShape = BTNSTATE_PUSHED;
                if (uiButtonState  & BTNSTATE_DOWN) // if BTNSTATE_DOWN set, always BTNSTATE_ONMOUSE set too
                    lpszBtnResouceName = // Dented white gray GA
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpDownOnMouseID);
                else
                if (uiButtonState & BTNSTATE_ONMOUSE)
                    lpszBtnResouceName = 
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpOnMouseID);
                else
                    lpszBtnResouceName = 
                        MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                }
            else 
                {
                if (uiButtonState & BTNSTATE_DOWN) 
                    {
                    uiDrawButtonShape = BTNSTATE_PUSHED;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                    }
                else 
                    {
                    if (uiButtonState & BTNSTATE_ONMOUSE)
                        uiDrawButtonShape = BTNSTATE_ONMOUSE;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpNormalID);
                    }
                }
            break;

        case HANJA_CONV_BUTTON:
            if ((pImeCtx->GetConversionMode() & IME_CMODE_HANJACONVERT)) 
                {
                uiDrawButtonShape = BTNSTATE_PUSHED;
                if (uiButtonState & BTNSTATE_ONMOUSE)
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpOnMouseID);
                else
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                }
            else 
                {
                if (uiButtonState & BTNSTATE_DOWN) 
                    {
                    uiDrawButtonShape = BTNSTATE_PUSHED;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                    }
                else 
                    {
                    if (uiButtonState & BTNSTATE_ONMOUSE)
                        uiDrawButtonShape = BTNSTATE_ONMOUSE;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpNormalID);
                    }
                }
            break;
            
        case IME_PAD_BUTTON:
            LPCImePadSvr lpCImePadSvr;
            BOOL fVisible;

            lpCImePadSvr = CImePadSvr::GetCImePadSvr();
            fVisible = fFalse;

            if (lpCImePadSvr) 
                lpCImePadSvr->IsVisible(&fVisible);

            if (lpCImePadSvr && fVisible)
                {
                uiDrawButtonShape = BTNSTATE_PUSHED;
                if (uiButtonState & BTNSTATE_ONMOUSE)
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpOnMouseID);
                else
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                }
            else
                {
                if (uiButtonState & BTNSTATE_DOWN) 
                    {
                    uiDrawButtonShape = BTNSTATE_PUSHED;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpPushedID);
                    }
                else
                    {
                    if (uiButtonState & BTNSTATE_ONMOUSE)
                        uiDrawButtonShape = BTNSTATE_ONMOUSE;
                    lpszBtnResouceName = MAKEINTRESOURCE(ImeData->StatusButtons[iButton].m_BmpNormalID);
                    }
                }
            break;
        
        default:
            DbgAssert(0);
            }

        // use LoadImage instead LoadBitmap to change button face color according to system setting
        // LR_LOADMAP3DCOLORS flag does it.
        hBMTmpButton = (HBITMAP)OurLoadImage(lpszBtnResouceName, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_LOADMAP3DCOLORS );
        hBMButtonOld = (HBITMAP)SelectObject(hButtonMemDC, hBMTmpButton);

        if (ImeData->StatusButtons[iButton].m_fEnable)
            {
            if (   ImeData->StatusButtons[iButton].m_uiButtonState==BTNSTATE_PUSHED 
                || ImeData->StatusButtons[iButton].m_uiButtonState==BTNSTATE_HANJACONV) 
                {
                BitBlt(hDCMem, ixButton+1, iyButton+1, ImeData->xButtonWi, ImeData->yButtonHi, hButtonMemDC, 0, 0, SRCCOPY);
                }
            else
                BitBlt(hDCMem, ixButton, iyButton, ImeData->xButtonWi, ImeData->yButtonHi, hButtonMemDC, 0, 0, SRCCOPY);
            }
        else
            {
            BITMAP  bmp;
            HDC    hDCMono;
            HBITMAP hBmpMono, hBmpOldMono;
            HBRUSH hBr, hOldBr;

            GetObject(hBMTmpButton, sizeof(BITMAP), &bmp);
            // mono bitmap
            hDCMono     = CreateCompatibleDC(hDC);
            hBmpMono   = CreateBitmap(bmp.bmWidth/*-2*/, bmp.bmHeight/*-2*/, 1, 1, NULL);
            hBmpOldMono = (HBITMAP)SelectObject(hDCMono, hBmpMono);

            // initalize whole area with 0's
            PatBlt(hDCMono, 0, 0,  bmp.bmWidth-2,  bmp.bmHeight-2, WHITENESS);

            SetBkColor(hButtonMemDC, GetSysColor(COLOR_3DFACE));
            BitBlt(hDCMono, 0, 0,  bmp.bmWidth,  bmp.bmHeight, hButtonMemDC, 0, 0, SRCCOPY);
            
            SetBkColor(hButtonMemDC, GetSysColor(COLOR_3DHILIGHT));
            // OR in the new 1's
            BitBlt(hDCMono, 0, 0, bmp.bmWidth,  bmp.bmHeight, hButtonMemDC, 0, 0, SRCPAINT);

            // - mask proc end
            SetTextColor(hDCMem, 0L);                  // 0's in mono -> 0 (for ROP)
            SetBkColor(hDCMem, (COLORREF)0x00FFFFFFL); // 1's in mono -> 1

            // disabled - draw the hilighted shadow
            hBr    = GetSysColorBrush(COLOR_3DHILIGHT);
            hOldBr = (HBRUSH)SelectObject(hDCMem, hBr);
            if (hBr && hOldBr)
                {
                // draw hilight color where we have 0's in the mask
                BitBlt(hDCMem, ixButton, iyButton, ImeData->xButtonWi, ImeData->yButtonHi, hDCMono, 0, 0, ROP_PSDPxax);
                SelectObject(hDCMem, hOldBr);
                DeleteObject(hBr);
                }

            hBr    = GetSysColorBrush(COLOR_3DSHADOW);
            hOldBr = (HBRUSH)SelectObject(hDCMem, hBr);
            if (hBr && hOldBr)
                {
                // draw the shadow color where we have 0's in the mask
                BitBlt(hDCMem, ixButton-1, iyButton-1, ImeData->xButtonWi, ImeData->yButtonHi, hDCMono, 0, 0, ROP_PSDPxax);
                SelectObject(hDCMem, hOldBr);
                DeleteObject(hBr);
                }

            if (hBmpMono) 
                {
                SelectObject(hDCMono, hBmpOldMono);
                DeleteObject(hBmpMono);
                DeleteDC(hDCMono);
                }
            }
        
        SelectObject(hButtonMemDC, hBMButtonOld);
        DeleteObject(hBMTmpButton);
        //
        ::SetRect(&rcButton, ixButton, iyButton, ixButton+ImeData->xButtonWi-1, iyButton+ImeData->yButtonHi-1);
        FrameControl(hDCMem, &rcButton, uiDrawButtonShape);
        //
        ixButton += ImeData->xButtonWi;
        }

    BitBlt(hDC, 0, 0, ImeData->xStatusWi, ImeData->yStatusHi, hDCMem, 0, 0, SRCCOPY);

    DeleteObject(hButtonMemDC);
    SelectObject(hDCMem, hBmpOldShow);
    DeleteObject(hDCMem);
    DeleteObject(hBmpShow);
}

void PASCAL AdjustStatusBoundary(LPPOINT lppt)
{
    CIMEData    ImeData(CIMEData::SMReadWrite);
#if 1 // MultiMonitor support
    RECT rcWorkArea;//, rcMonitorWorkArea;

        {
        RECT rcStatusWnd;

        *(LPPOINT)&rcStatusWnd = *lppt;

        rcStatusWnd.right = rcStatusWnd.left + ImeData->xStatusWi;
        rcStatusWnd.bottom = rcStatusWnd.top + ImeData->yStatusHi;

        ImeMonitorWorkAreaFromRect(&rcStatusWnd, &rcWorkArea);
        }

    // display boundary check
    if (lppt->x < rcWorkArea.left) 
        lppt->x = rcWorkArea.left;
    else 
        if (lppt->x + ImeData->xStatusWi > rcWorkArea.right) 
        lppt->x = (rcWorkArea.right - ImeData->xStatusWi);

    if (lppt->y < rcWorkArea.top)
        lppt->y = rcWorkArea.top;
    else 
        if (lppt->y + ImeData->yStatusHi + 1 > rcWorkArea.bottom)
            lppt->y = rcWorkArea.bottom - ImeData->yStatusHi + 1;
    
    //rcMonitorWorkArea = rcWorkArea;
    //OffsetRect(&rcMonitorWorkArea, -rcMonitorWorkArea.left, -rcMonitorWorkArea.top);
    //DbgAssert(rcMonitorWorkArea.right!=0);
    //DbgAssert(rcMonitorWorkArea.bottom!=0);
    if (rcWorkArea.right-rcWorkArea.left != 0)
        ImeData->xStatusRel = ( ((long)(lppt->x+ImeData->xStatusWi-rcWorkArea.left))<<16 ) 
                                / (rcWorkArea.right-rcWorkArea.left);
    if (rcWorkArea.bottom-rcWorkArea.top != 0)
        ImeData->yStatusRel = ( ((long)(lppt->y+ImeData->yStatusHi-rcWorkArea.top))<<16 ) 
                                / (rcWorkArea.bottom-rcWorkArea.top);

#else
    // display boundary check
    if (lppt->x < ImeData->rcWorkArea.left)
        lppt->x = ImeData->rcWorkArea.left;
    else 
        if (lppt->x + ImeData->xStatusWi > ImeData->rcWorkArea.right)
        lppt->x = (ImeData->rcWorkArea.right - ImeData->xStatusWi);

    if (lppt->y < ImeData->rcWorkArea.top) 
        lppt->y = ImeData->rcWorkArea.top;
    else 
        if (lppt->y + ImeData->yStatusHi > ImeData->rcWorkArea.bottom)
            lppt->y = (ImeData->rcWorkArea.bottom - ImeData->yStatusHi);
#endif

    return;
}

BOOL fSetStatusWindowPos(HWND hStatusWnd, POINT *ptStatusWndPos)
{
    HWND     hUIWnd;
    HIMC     hIMC;
    PCIMECtx pImeCtx;
    // LPINPUTCONTEXT     lpIMC;
    POINT     ptCtxStatusWnd;
    RECT     rcStatusWnd;
    CIMEData ImeData(CIMEData::SMReadWrite);

    Dbg(DBGID_UI, TEXT("fSetStatusWindowPos(): hStatusWnd=0x%X, ptStatusWndPos = 0x%08lX"), hStatusWnd, ptStatusWndPos);

    DbgAssert(hStatusWnd != 0);
    if (hStatusWnd == 0)
        {
        DbgAssert(0);
        return fFalse;
        }
        
    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    GetWindowRect(hStatusWnd, &rcStatusWnd);

    hIMC = GethImcFromHwnd(hUIWnd);
    //if (hIMC == 0)
    //    {
    //    DbgAssert(0);
    //    return fFalse;
    //    }

    //lpIMC = (LPINPUTCONTEXT)OurImmLockIMC(hIMC);
    //if (lpIMC == 0)
    //    {
    //    DbgAssert(0);
    //    return fFalse;
    //    }

    if ((pImeCtx = GetIMECtx(hIMC))==NULL)
        return fFalse;

    pImeCtx->GetStatusWndPos(&ptCtxStatusWnd);
    // if ptStatusWndPos is NULL, Set current IMC value
    // IMN_SETSTATUSWINDOWPOS
    if (ptStatusWndPos == NULL)    
        {
        if (   ptCtxStatusWnd.x != rcStatusWnd.left 
            || ptCtxStatusWnd.y != rcStatusWnd.top) 
            {   
            // display boundary adjust
            AdjustStatusBoundary(&ptCtxStatusWnd);
            ImeData->ptStatusPos = ptCtxStatusWnd;
            }
        }
    else    // Set ptStatusWndPos to IMC. StatusOnLButtonUp() 
        {
        if (   ptStatusWndPos->x != rcStatusWnd.left 
            || ptStatusWndPos->y != rcStatusWnd.top) 
            {   
            // display boundary adjust
            AdjustStatusBoundary(ptStatusWndPos);
            ImeData->ptStatusPos = *ptStatusWndPos;
            pImeCtx->SetStatusWndPos(*ptStatusWndPos);
            }
        }

    ///////////////////////////////////////////////////////////////////////////
    SetWindowPos(hStatusWnd, 0,
                ImeData->ptStatusPos.x, ImeData->ptStatusPos.y,
                0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    // Set reg value
    SetRegValues(GETSET_REG_STATUSPOS);
    
    return (fTrue);
}


void InitButtonState()
{
    CIMEData    ImeData(CIMEData::SMReadWrite);
    for (int i=0; i<MAX_NUM_OF_STATUS_BUTTONS;i++)
        ImeData->StatusButtons[i].m_uiButtonState = BTNSTATE_NORMAL;
    vfPrevButton = -1;
}

void StatusDisplayChange(HWND hUIWnd)
{
    RECT     rcMonitorWorkArea, rcMonitorWorkArea2;
    POINT    ptNewStatus;
    HIMC     hIMC;
    PCIMECtx pImeCtx;
    CIMEData ImeData;

    hIMC = GethImcFromHwnd(hUIWnd);
    //if (hIMC == 0)
    //    {
    //    DbgAssert(0);
    //    return;
    //    }

    //lpIMC = OurImmLockIMC(hIMC);

    if ((pImeCtx = GetIMECtx(hIMC))==NULL)
        return;

    // If still not initialized, skip status win pos adjust.
    if (ImeData->ptStatusPos.x == -1)
        return;
        
    ImeMonitorWorkAreaFromWindow(pImeCtx->GetAppWnd(), &rcMonitorWorkArea);
    
    rcMonitorWorkArea2 = rcMonitorWorkArea;
    OffsetRect(&rcMonitorWorkArea2, -rcMonitorWorkArea2.left, -rcMonitorWorkArea2.top);
    ptNewStatus.x = ((rcMonitorWorkArea2.right * ImeData->xStatusRel + 0x8000)>>16) + rcMonitorWorkArea.left
                    -ImeData->xStatusWi;
    if (ptNewStatus.x < 0)
        ptNewStatus.x = 0;
    ptNewStatus.y = ((rcMonitorWorkArea2.bottom * ImeData->yStatusRel + 0x8000)>>16) + rcMonitorWorkArea.top
                    -ImeData->yStatusHi;
    if (ptNewStatus.y < 0)
        ptNewStatus.y = 0;

    Dbg(DBGID_UI, TEXT("StatusDisplayChange() : xStatusRel = %d, yStatusRel=%d, newX=%d, newY=%d"),  (int)(ImeData->xStatusRel), (int)(ImeData->yStatusRel), ptNewStatus.x, ptNewStatus.y);
    ImeData->ptStatusPos = ptNewStatus;
    SetRegValues(GETSET_REG_STATUSPOS);
}


void PASCAL UpdateStatusTooltip(HWND hStatusWnd, HWND hStatusTTWnd)
{
    TOOLINFO    ti;
    CHAR        szTooltip[80];
    WCHAR        wszTooltip[80];
    CIMEData    ImeData;
    UINT         uiMsgAdd = TTM_ADDTOOLW;

    if (IsWin(hStatusWnd) && IsWin(hStatusTTWnd))
        {
        ZeroMemory(&ti, sizeof(TOOLINFO));
        ti.cbSize = sizeof(TOOLINFO);
        ti.uFlags = 0;
        ti.hwnd = hStatusWnd;
        ti.hinst = vpInstData->hInst;

        //
        ti.rect.left   = ImeData->cxStatLeftMargin; 
        ti.rect.right  = ti.rect.left + ImeData->xButtonWi;
        ti.rect.top    = ImeData->cyStatButton;
        ti.rect.bottom = ti.rect.top  + ImeData->yButtonHi;

        if (!IsWinNT())
            uiMsgAdd = TTM_ADDTOOL;
            
        // Set Button text
        for (UINT i=0; i<ImeData->uNumOfButtons; i++) 
            {
            ti.uId = i;

            if (IsWinNT())
                {
                OurLoadStringW(vpInstData->hInst, ImeData->StatusButtons[i].m_ToolTipStrID, 
                               wszTooltip, sizeof(wszTooltip)/sizeof(WCHAR));
                ti.lpszText = (LPSTR)wszTooltip;
                }
            else
                {
                OurLoadStringA(vpInstData->hInst, ImeData->StatusButtons[i].m_ToolTipStrID, 
                               szTooltip, sizeof(szTooltip)/sizeof(CHAR));
                ti.lpszText = szTooltip;
                }
                
            OurSendMessage(hStatusTTWnd, uiMsgAdd, 0, (LPARAM)(LPTOOLINFO)&ti);    

            // Next Button area
            ti.rect.left += ImeData->xButtonWi;
            ti.rect.right += ImeData->xButtonWi;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\propmode.cpp ===
/****************************************************************************
   PROPMODE.CPP : PropertyButton class managing Hanja button on the Cicero Toolbar

   History:
      25-FEB-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "propmode.h"
#include "ui.h"
#include "winex.h"
#include "resource.h"

extern const CLSID CLDSID_LBI_KORIME_IMM32; // {0198111B-FE89-4b4c-8619-8A5E015F29D8}

// {83DC4284-4BAC-4231-87F1-A4ADE98603B2}
const GUID GUID_LBI_KORIME_PROP_BUTTON = 
{ 
    0x83dc4284,
    0x4bac,
    0x4231,
    { 0x87, 0xf1, 0xa4, 0xad, 0xe9, 0x86, 0x3, 0xb2 }
};

/*---------------------------------------------------------------------------
    PropertyButton::PropertyButton
---------------------------------------------------------------------------*/
PropertyButton::PropertyButton(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    // Set Add/Remove text and tootip text
    OurLoadStringW(vpInstData->hInst, IDS_STATUS_BUTTON_PROP, szText, sizeof(szText)/sizeof(WCHAR));
    InitNuiInfo(CLDSID_LBI_KORIME_IMM32, 
                GUID_LBI_KORIME_PROP_BUTTON,
                TF_LBI_STYLE_BTN_BUTTON, 
                1, 
                szText);
    SetToolTip(szText);

    // Set button text
    SetText(szText);
}

/*---------------------------------------------------------------------------
    PropertyButton::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI PropertyButton::GetIcon(HICON *phIcon)
{
    *phIcon = LoadIcon(vpInstData->hInst, MAKEINTRESOURCE(IDI_CMODE_PROP));
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    PropertyButton::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI PropertyButton::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    PropertyButton::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI PropertyButton::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
    PropertyButton::OnLButtonUp
---------------------------------------------------------------------------*/
HRESULT PropertyButton::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    OurPostMessage(GetActiveUIWnd(), WM_MSIME_PROPERTY, 0L, IME_CONFIG_GENERAL);

    return S_OK;
}


/*---------------------------------------------------------------------------
    PropertyButton::OnRButtonUp
---------------------------------------------------------------------------*/
HRESULT PropertyButton::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IMEKOR.rc
//
#define IDS_ABOUT                       1
#define IDS_CONFIG                      2
#define IDS_PROGRAM                     3
#define IDS_DELBYJASO                   4
#define IDS_2BEOL                       5
#define IDS_3BEOL390                    6
#define IDS_3BEOLFINAL                  7
#define IDS_JUNJA                       8
#define IDS_BANJA                       9
#define IDS_HANGUL                      10
#define IDS_ENGLISH                    	11
#define IDS_STATUS_BUTTON_HAN_ENG		12
#define IDS_STATUS_BUTTON_JUN_BAN		13
#define IDS_STATUS_BUTTON_HANJA_CONV	14
#define IDS_STATUS_BUTTON_PROP			16
#define IDS_STATUS_TT_HAN_ENG           17
#define IDS_STATUS_TT_JUN_BAN           18
#define IDS_STATUS_TT_HANJA_CONV        19
#define IDS_STATUS_TT_IME_PAD           20
#define IDS_TT_DISABLE                  21
#define IDS_IME_HANGUL_FULL             22
#define IDS_IME_HANGUL_HALF             23
#define IDS_IME_ENG_FULL                24
#define IDS_IME_ENG_HALF                25
#define IDS_IME_DISABLE                 26
#define IDS_IME_TT_HANGUL_FULL          27
#define IDS_IME_TT_HANGUL_HALF          28
#define IDS_IME_TT_ENG_FULL             29
#define IDS_IME_TT_ENG_HALF             30
#define IDS_IME_TT_DISABLE              31
#define IDS_CONTEXTHELP_FILENAME        32
#define IDS_HELP_FILENAME				33
#define IDS_HELP_DISPLAYNAME			34


#define IDI_UNIKOR                      103
#define IDB_STAT_WINDOW                 104
#define TIMER_UIBUTTON                  105
#define IDB_STAT_HANGUL                 106
#define IDB_STAT_ENGLISH                107
#define IDB_STAT_BANJA                  108
#define IDB_STAT_JUNJA                  109
#define IDB_STAT_CHINESEOFF             110
#define IDB_STAT_CHINESEON              111
#define IDC_IME_HAND                    112
#define IDB_CAND_WIN                    114
#define IDB_CAND_NUM                    118
#define IDB_CAND_ARRY2                  119
#define IDB_CAND_ARRY1                  120
#define IDR_STATUS_POPUP                124
#define IDD_CONFIG_PAGE1                125
#define IDB_COMP_WIN                    131
#define IDB_STAT_ON_HANGUL              132
#define IDB_STAT_ON_ENGLISH             132
#define IDI_CM_BASE                     133
#define IDI_CM_HANGUL                   133
#define IDB_STAT_ON_JUNJA               133
#define IDI_CM_ENGLISH                  134
#define IDB_STAT_HANGUL_ONDOWN          134
#define IDB_STAT_ENGLISH_ONDOWN         134
#define IDI_CM_DISABLE                  135
#define IDB_STAT_JUNJA_ONDOWN           135
#define IDI_IME_HANGUL_HALF             139
#define IDI_IME_ENG_FULL                140
#define IDI_IME_ENG_HALF                141
#define IDI_IME_HANGUL_FULL             142
#define IDI_IME_DISABLE                 143
#define IDB_STAT_PADHWX                 157
#define IDB_STAT_IMEPAD                 157
#define IDB_STAT_IMEPAD_DOWN            158
// Cicero button Icons
#define IDI_CMODE_HANGUL				160
#define IDI_CMODE_HANGULW				161
#define IDI_CMODE_ENGLISH				162
#define IDI_CMODE_ENGLISHW				163
#define IDI_CMODE_BANJA					164
#define IDI_CMODE_BANJAW				165
#define IDI_CMODE_JUNJA					166
#define IDI_CMODE_JUNJAW				167
#define IDI_CMODE_HANJA					168
#define IDI_CMODE_HANJAW				169
#define IDI_CMODE_IMEPAD                170

#define IDC_GRP_KEYLAYOUT               1001
#define IDC_GRP_STATUSWIN               1002
#define IDC_JUNBAN_TOGGLE               1003
#define IDC_HANJA_CONV                  1004
#define IDC_2BEOLSIK                    1005
#define IDC_3BEOLSIK_390                1006
#define IDC_3BEOLSIK_FINAL              1007
#define IDC_DELJASO                     1008
#define IDC_K1HANJA                     1009
#define IDC_IMEPAD                      1010
#define IDC_IME_ICON                    1020
#define ID_CONFIG                       40001
#define ID_2BEOLSIK                     40003
#define ID_3BEOLSIK390                  40004
#define ID_3BEOLSIKFINAL                40005
#define ID_JASO_DELETION                40006
#define ID_HANGUL_MODE                  40007
#define ID_ENGLISH_MODE                 40008
#define ID_ABOUT                        40009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        159
#define _APS_NEXT_COMMAND_VALUE         40011
#define _APS_NEXT_CONTROL_VALUE         1021
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\toolbar.h ===
//
//  TOOLBAR.H
//
//  History:
//      29-MAY-2000 CSLIM Adapted to IME
//      24-JAN-2000 CSLIM Created

#if !defined (__TOOLBAR_H__INCLUDED_)
#define __TOOLBAR_H__INCLUDED_

#include "imc.h"

class CMode;
class FMode;
class HJMode;
class PMode;
class PropertyButton;
class CSysHelpSink;

#define UPDTTB_NONE		0x00000000
#define UPDTTB_CMODE	0x00000001
#define UPDTTB_FHMODE	0x00000002  // Full/Half shape mode
#define UPDTTB_HJMODE	0x00000004  // Hanja mode
#define UPDTTB_PAD		0x00000008  // Pad button
#define UPDTTB_PROP		0x00000010  // Properties button

#define UPDTTB_ALL (UPDTTB_CMODE|UPDTTB_FHMODE|UPDTTB_HJMODE|UPDTTB_PAD|UPDTTB_PROP)

class CToolBar
{
public:
	CToolBar();
	~CToolBar();

	BOOL Initialize();
	void Terminate();

	void CheckEnable();
	void SetCurrentIC(PCIMECtx pImeCtx);

	DWORD SetConversionMode(DWORD dwConvMod);
	DWORD GetConversionMode(PCIMECtx pImeCtx = NULL);
//	UINT  GetConversionModeIDI(PCIMECtx pImeCtx = NULL);

	BOOL Update(DWORD dwUpdate = UPDTTB_NONE, BOOL fRefresh = fFalse);

	BOOL IsOn(PCIMECtx pImeCtx = NULL);
	BOOL SetOnOff(BOOL fOn);

	PCIMECtx GetImeCtx()	{ return m_pImeCtx;	}
	HWND GetOwnerWnd(PCIMECtx pImeCtx = NULL);

	// Syshelp callback (Cicero)
	static HRESULT SysInitMenu(void *pv, ITfMenu* pMenu);
	static HRESULT OnSysMenuSelect(void *pv, UINT uiCmd);

private:
	PCIMECtx m_pImeCtx;

	BOOL			  m_fToolbarInited;
	CMode  	 		  *m_pCMode;
	FMode  	 		  *m_pFMode;
	HJMode 	 		  *m_pHJMode;
#if !defined(_M_IA64)
	PMode  	 		  *m_pPMode;
#endif
	CSysHelpSink       *m_pSysHelp;

	CMode *GetCMode()		{ return m_pCMode;  }
	FMode *GetFMode()		{ return m_pFMode;  }
	HJMode *GetHJMode()		{ return m_pHJMode; }
#if !defined(_M_IA64)
	PMode  *GetPMode()      { return m_pPMode;  }
#endif
};

#endif	// __TOOLBAR_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\syshelp.cpp ===
//
// syshelp.cpp
//

#include "precomp.h"
#include "syshelp.h"

#define SAFECASTLOCAL(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))
#define SafeReleaseLocal(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}
#define SafeReleaseLocalClear(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        punk = NULL;            \
    }                           \
}



STDAPI CSysHelpSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfSystemLangBarItemSink))
    {
        *ppvObj = SAFECASTLOCAL(this, ITfSystemLangBarItemSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSysHelpSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSysHelpSink::Release()
{
    long cr;

    cr = --_cRef;

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CSysHelpSink::CSysHelpSink(SYSHELPINITMENU pfnInitMenu, SYSHELPMENUSELECT pfnMenuSelect, void *pv)
{
    _pfnInitMenu = pfnInitMenu;
    _pfnMenuSelect = pfnMenuSelect;
    _pv = pv;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CSysHelpSink::~CSysHelpSink()
{
}

//+---------------------------------------------------------------------------
//
// Advise
//
//----------------------------------------------------------------------------

HRESULT CSysHelpSink::_Advise(ITfLangBarItemMgr *plbimgr, REFGUID rguid)
{
    HRESULT hr;
    ITfSource *source = NULL;
    ITfLangBarItem *plbi = NULL;

    hr = E_FAIL;

    if (plbimgr == NULL) {
        goto Exit;
    }

    if (plbimgr->GetItem(rguid, &plbi) != S_OK)
        goto Exit;

    // Satori#3713 ; plbi can be NULL
    if (plbi == NULL) {
        goto Exit;
    }

    if (FAILED(plbi->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfSystemLangBarItemSink, this, &_dwCookie)))
        goto Exit;

    hr = S_OK;
    _guid = rguid;

Exit:
    SafeReleaseLocal(source);
    SafeReleaseLocal(plbi);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Unadvise
//
//----------------------------------------------------------------------------

HRESULT CSysHelpSink::_Unadvise(ITfLangBarItemMgr *plbimgr)
{
    HRESULT hr;
    ITfSource *source = NULL;
    ITfLangBarItem *plbi = NULL;

    hr = E_FAIL;

    if (FAILED(plbimgr->GetItem(_guid, &plbi)))
        goto Exit;

    // Satori#3713 ; plbi can be NULL
    if (plbi == NULL) {
        goto Exit;
    }

    if (FAILED(plbi->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeReleaseLocal(source);
    SafeReleaseLocal(plbi);
    return hr;
}

//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CSysHelpSink::InitMenu(ITfMenu *pMenu)
{
    return _pfnInitMenu(_pv, pMenu);
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CSysHelpSink::OnMenuSelect(UINT wID)
{
    return _pfnMenuSelect(_pv, wID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\toolbar.cpp ===
/****************************************************************************
   TOOLBAR.CPP : Cicero Toolbar button management class

   History:
      24-JAN-2000 CSLim Created
****************************************************************************/

#include "precomp.h"
#include "common.h"
#include "cicero.h"
#include "cmode.h"
#include "fmode.h"
#include "hjmode.h"
#include "pmode.h"
#include "toolbar.h"
#include "ui.h"
#include "syshelp.h"
#include "winex.h"

/*---------------------------------------------------------------------------
    CToolBar::CToolBar
    Ctor
---------------------------------------------------------------------------*/
CToolBar::CToolBar()
{
    m_fToolbarInited = fFalse;
    m_pImeCtx        = NULL;
    m_pCMode         = NULL;
    m_pFMode         = NULL;
    m_pHJMode        = NULL;
#if !defined(_M_IA64)    
    m_pPMode         = NULL;
#endif
    m_pSysHelp       = NULL;
}

/*---------------------------------------------------------------------------
    CToolBar::~CToolBar
    Dtor
---------------------------------------------------------------------------*/
CToolBar::~CToolBar()
{
    m_pImeCtx = NULL;
}

/*---------------------------------------------------------------------------
    CToolBar::Initialize
    
    Initialize Toolbar buttons. Add to Cic main toolbar.
---------------------------------------------------------------------------*/
BOOL CToolBar::Initialize()
{
    ITfLangBarMgr     *pLMgr     = NULL;
    ITfLangBarItemMgr *pLItemMgr = NULL;
    DWORD              dwThread  = 0;
    HRESULT            hr;

    if (IsCicero() == fFalse)
        return fFalse;    // do nothing

    if (m_fToolbarInited) // already made it
        return fTrue;    // do nothing
        
    // initialization
    if (FAILED(Cicero_CreateLangBarMgr(&pLMgr)))
        return fFalse; // error to create a object

    // Get Lang bar manager
    if (FAILED(pLMgr->GetThreadLangBarItemMgr(GetCurrentThreadId(), &pLItemMgr, &dwThread)))
        {
        pLMgr->Release();
        DbgAssert(0);
        return fFalse; // error to create a object
        }

    // no need it.
    pLMgr->Release();

    //////////////////////////////////////////////////////////////////////////
    // Create Han/Eng toggle button
    if (!(m_pCMode = new CMode(this))) 
        {
        hr = E_OUTOFMEMORY;
        return fFalse;
        }
    pLItemMgr->AddItem(m_pCMode);

    //////////////////////////////////////////////////////////////////////////
    // Create Full/Half shape toggle button
    if (!(m_pFMode = new FMode(this))) 
        {
        hr = E_OUTOFMEMORY;
        return fFalse;
        }
    pLItemMgr->AddItem(m_pFMode);

    //////////////////////////////////////////////////////////////////////////
    // Create Hanja Conv button
    if (!(m_pHJMode = new HJMode(this))) 
        {
        hr = E_OUTOFMEMORY;
        return fFalse;
        }
    pLItemMgr->AddItem(m_pHJMode);

#if !defined(_M_IA64)
    //////////////////////////////////////////////////////////////////////////
    // Create IME Pad button
    if (!(m_pPMode = new PMode(this))) 
        {
        hr = E_OUTOFMEMORY;
        return fFalse;
        }
    pLItemMgr->AddItem(m_pPMode);
#endif

    // Update all button
    CheckEnable();
    m_pCMode->UpdateButton();
    m_pFMode->UpdateButton();
    m_pHJMode->UpdateButton();
#if !defined(_M_IA64)
    m_pPMode->UpdateButton();
#endif
    // SYSHelp support
    m_pSysHelp = new CSysHelpSink(SysInitMenu, OnSysMenuSelect, (VOID*)this);
    if (m_pSysHelp && pLItemMgr)
        m_pSysHelp->_Advise(pLItemMgr, GUID_LBI_HELP);

    m_fToolbarInited = fTrue;
    
    return fTrue;
}

/*---------------------------------------------------------------------------
    CToolBar::CheckEnable
---------------------------------------------------------------------------*/
void CToolBar::CheckEnable()
{
    if (m_pCMode == NULL || m_pFMode == NULL || m_pHJMode == NULL 
        #if !defined(_M_IA64)
            || m_pPMode == NULL
        #endif
    )
        return;

    if (m_pImeCtx == NULL) // empty or disabled(exclude cand ui)
        {
        m_pCMode->Enable(fFalse);
        m_pFMode->Enable(fFalse);
        m_pHJMode->Enable(fFalse);
#if !defined(_M_IA64)        
        m_pPMode->Enable(fFalse);
#endif
        }
    else
        {
        m_pCMode->Enable(fTrue);
        m_pFMode->Enable(fTrue);
        m_pHJMode->Enable(fTrue);
#if !defined(_M_IA64)
        m_pPMode->Enable(fTrue);
#endif
        }
}
/*---------------------------------------------------------------------------
    CToolBar::SetCurrentIC
---------------------------------------------------------------------------*/
void CToolBar::SetCurrentIC(PCIMECtx pImeCtx)
{
    m_pImeCtx = pImeCtx;

    CheckEnable();    // enable or disable context

    // changed context - update all toolbar buttons
    Update(UPDTTB_ALL, fTrue);
}

/*---------------------------------------------------------------------------
    CToolBar::Terminate
    
    Delete toolbar buttonsfrom Cic main toolbar.
---------------------------------------------------------------------------*/
void CToolBar::Terminate()
{
    ITfLangBarMgr     *pLMgr     = NULL;
    ITfLangBarItemMgr *pLItemMgr = NULL;
    DWORD              dwThread  = 0;

    if (IsCicero() && m_fToolbarInited)
        {
        // initialization
        if (FAILED(Cicero_CreateLangBarMgr(&pLMgr)))
            return; // error to create a object

        if (FAILED(pLMgr->GetThreadLangBarItemMgr(GetCurrentThreadId(), &pLItemMgr, &dwThread)))
            {
            pLMgr->Release();
            DbgAssert(0);
            return; // error to create a object
            }

        // no need it.
        pLMgr->Release();

#if !defined(_M_IA64)
        if (m_pPMode) 
            {
            pLItemMgr->RemoveItem(m_pPMode);
            SafeReleaseClear(m_pPMode);
            }
#endif
        if (m_pHJMode) 
            {
            pLItemMgr->RemoveItem(m_pHJMode);
            SafeReleaseClear(m_pHJMode);
            }
        
        if (m_pFMode) 
            {
            pLItemMgr->RemoveItem(m_pFMode);
            SafeReleaseClear(m_pFMode);
            }

        if (m_pCMode) 
            {
            pLItemMgr->RemoveItem(m_pCMode);
            SafeReleaseClear(m_pCMode);
            }

        // Release Syshelp
        if (m_pSysHelp)
            {
            m_pSysHelp->_Unadvise(pLItemMgr);
            SafeReleaseClear(m_pSysHelp);
            }

        pLItemMgr->Release();

        //Toolbar uninited.
        m_fToolbarInited = fFalse;
        }
}

/*---------------------------------------------------------------------------
    CToolBar::SetConversionMode
    
    Foward the call to CKorIMX
---------------------------------------------------------------------------*/
DWORD CToolBar::SetConversionMode(DWORD dwConvMode)
{
    if (m_pImeCtx)
        return m_pImeCtx->SetConversionMode(dwConvMode);

    return 0;
}

/*---------------------------------------------------------------------------
    CToolBar::GetConversionMode

    Foward the call to CKorIMX
---------------------------------------------------------------------------*/
DWORD CToolBar::GetConversionMode(PCIMECtx pImeCtx)
{
    if (pImeCtx == NULL)
        pImeCtx = m_pImeCtx;
        
    if (pImeCtx)
        return pImeCtx->GetConversionMode();

    return 0;
}

/*---------------------------------------------------------------------------
    CToolBar::IsOn

    Foward the call to CKorIMX
---------------------------------------------------------------------------*/
BOOL CToolBar::IsOn(PCIMECtx pImeCtx)
{
    if (pImeCtx == NULL)
        pImeCtx = m_pImeCtx;

    if (pImeCtx)
        return pImeCtx->IsOpen();

    return fFalse;
}

/*---------------------------------------------------------------------------
    CToolBar::SetOnOff

    Foward the call to CKorIMX
---------------------------------------------------------------------------*/
BOOL CToolBar::SetOnOff(BOOL fOn)
{
    if (m_pImeCtx) 
        {
        m_pImeCtx->SetOpen(fOn);
        return fOn;
        }
        
    return fFalse;
}

/*---------------------------------------------------------------------------
    CToolBar::GetOwnerWnd

    Foward the call to CKorIMX
---------------------------------------------------------------------------*/
HWND CToolBar::GetOwnerWnd(PCIMECtx pImeCtx)
{
#if 0
    if (pImeCtx == NULL)
        pImeCtx = m_pImeCtx;

    if (pImeCtx)
        return pImeCtx->GetUIWnd();

    return 0;
#endif
    return GetActiveUIWnd();
}

/*---------------------------------------------------------------------------
    CToolBar::GetOwnerWnd

    Update buttons. dwUpdate has update bits corresponding each button.
---------------------------------------------------------------------------*/
BOOL CToolBar::Update(DWORD dwUpdate, BOOL fRefresh)
{
    DWORD dwFlag = TF_LBI_BTNALL;

    if (!IsCicero())
        return fTrue;
        
    if (fRefresh)
        dwFlag |= TF_LBI_STATUS;

    if ((dwUpdate & UPDTTB_CMODE) && m_pCMode && m_pCMode->GetSink())
        m_pCMode->GetSink()->OnUpdate(dwFlag);

    if ((dwUpdate & UPDTTB_FHMODE) && m_pFMode && m_pFMode->GetSink())
        m_pFMode->GetSink()->OnUpdate(dwFlag);

    if ((dwUpdate & UPDTTB_HJMODE) && m_pHJMode && m_pHJMode->GetSink())
        m_pHJMode->GetSink()->OnUpdate(dwFlag);

#if !defined(_M_IA64)
    if ((dwUpdate & UPDTTB_PAD) && m_pPMode && m_pPMode->GetSink())
        m_pPMode->GetSink()->OnUpdate(dwFlag);
#endif

    return fTrue;
}

/*---------------------------------------------------------------------------
    CToolBar::OnSysMenuSelect

    Cicero Help menu callback
---------------------------------------------------------------------------*/
HRESULT CToolBar::OnSysMenuSelect(void *pv, UINT uiCmd)
{
    UNREFERENCED_PARAMETER(pv);
    UNREFERENCED_PARAMETER(uiCmd);

    CHAR szHelpFileName[MAX_PATH];
    CHAR szHelpCmd[MAX_PATH];

    szHelpFileName[0] = '\0';
        
    // Load Help display name
    OurLoadStringA(vpInstData->hInst, IDS_HELP_FILENAME, szHelpFileName, sizeof(szHelpFileName)/sizeof(CHAR));

    wsprintf(szHelpCmd, "hh.exe %s", szHelpFileName);
    WinExec(szHelpCmd, SW_NORMAL);
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    CToolBar::SysInitMenu

    Cicero Help menu callback
---------------------------------------------------------------------------*/
HRESULT CToolBar::SysInitMenu(void *pv, ITfMenu* pMenu)
{
    WCHAR    szText[MAX_PATH];
    HRESULT  hr;

    szText[0] = L'\0';
    
    if (pv == NULL || pMenu == NULL)
        return S_OK;

    // Load Help display name
    OurLoadStringW(vpInstData->hInst, IDS_HELP_DISPLAYNAME, szText, sizeof(szText)/sizeof(WCHAR));

    hr = pMenu->AddMenuItem(UINT(-1),  0, 
                            NULL /*hbmpColor*/, NULL /*hbmpMask*/, szText, lstrlenW(szText), NULL);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\syshelp.h ===
//
// syshelp.h
//

#ifndef _SYSHELP_H_
#define _SYSHELP_H_

#include "msctf.h"

//
// CSysHelpSink
//
typedef HRESULT (*SYSHELPINITMENU)(void *pv, ITfMenu *pMenu);
typedef HRESULT (*SYSHELPMENUSELECT)(void *pv, UINT wID);

//////////////////////////////////////////////////////////////////////////////
//
// CSysHelpSink
//
//////////////////////////////////////////////////////////////////////////////

class CSysHelpSink : public ITfSystemLangBarItemSink
{
public:
    CSysHelpSink(SYSHELPINITMENU pfnInitMenu, SYSHELPMENUSELECT pfnMenuSelect, void *pv);
    ~CSysHelpSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfSource
    //
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);

	HRESULT _Advise(ITfLangBarItemMgr *plbimgr, REFGUID rguid);
    HRESULT _Unadvise(ITfLangBarItemMgr *plbimgr);

private:
    SYSHELPINITMENU _pfnInitMenu;
    SYSHELPMENUSELECT _pfnMenuSelect;
    DWORD _dwCookie;
    void *_pv;
    GUID _guid;
    long _cRef;
};



#endif // _SYSHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\ui.cpp ===
/****************************************************************************
    UI.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    UI functions
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "apientry.h"
#include "ui.h"
#include "imedefs.h"
#include "names.h"
#include "config.h"
#include "debug.h"
#include "shellapi.h"
#include "winex.h"
#include "imcsub.h"
#include "cpadsvr.h"
#include "pad.h"
#include "cicero.h"
#include "toolbar.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////////
PRIVATE LRESULT CALLBACK UIWndProc(HWND hUIWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
PRIVATE BOOL HandlePrivateMessage(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);

PRIVATE LRESULT PASCAL NotifyUI(HWND hUIWnd, WPARAM wParam, LPARAM lParam);
PRIVATE VOID PASCAL StatusWndMsg(HWND hUIWnd, BOOL fOn);
PRIVATE HWND PASCAL GetStatusWnd(HWND hUIWnd);
PRIVATE VOID PASCAL ShowUI(HWND hUIWnd, int nShowCmd);
PRIVATE VOID PASCAL OnImeSetContext(HWND hUIWnd, BOOL fOn, LPARAM lShowUI);
PRIVATE VOID PASCAL OnImeSelect(HWND hUIWnd, BOOL fOn);
PRIVATE HWND PASCAL GetCandWnd(HWND hUIWnd);
PRIVATE HWND PASCAL GetCompWnd(HWND hUIWnd);
PRIVATE LRESULT PASCAL GetCandPos(HWND hUIWnd, LPCANDIDATEFORM lpCandForm);
PRIVATE LRESULT PASCAL GetCompPos(HWND hUIWnd, LPCOMPOSITIONFORM lpCompForm);
PRIVATE VOID PASCAL UIWndOnCommand(HWND hUIWnd, int id, HWND hWndCtl, UINT codeNotify);

// Commented out SetIndicator because #199
PRIVATE BOOL PASCAL SetIndicator(PCIMECtx pImeCtx);

__inline
BOOL PASCAL SetIndicator(HIMC hIMC)
{
    PCIMECtx pImeCtx;
    
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return fFalse;
    else
        return SetIndicator(pImeCtx);
}

//////////////////////////////////////////////////////////////////////////////
// TLS
#define UNDEF_TLSINDEX    -1                    
DWORD vdwTLSIndex = UNDEF_TLSINDEX;    // Thread Local Strage initial value.

//////////////////////////////////////////////////////////////////////////////
// Private UI messages
UINT WM_MSIME_PROPERTY = 0;         // Invoke property DLG
UINT WM_MSIME_UPDATETOOLBAR = 0; // Redraw status window(Toolbar)
UINT WM_MSIME_OPENMENU = 0;         // Pop up status window context menu
UINT WM_MSIME_IMEPAD = 0;         // Boot up IME Pad

// Message string
#define RWM_PROPERTY      "MSIMEProperty"
#define RWM_UPDATETOOLBAR "MSIMEUpdateToolbar"
#define RWM_OPENMENU      "MSIMEOpenMenu"
#define RWM_IMEPAD        "MSIMEIMEPAD"

/*----------------------------------------------------------------------------
    InitPrivateUIMsg

    Register all IME private UI messages
----------------------------------------------------------------------------*/
BOOL InitPrivateUIMsg()
{
    WM_MSIME_PROPERTY      = RegisterWindowMessageA(RWM_PROPERTY);
    WM_MSIME_UPDATETOOLBAR = RegisterWindowMessageA(RWM_UPDATETOOLBAR);
    WM_MSIME_OPENMENU      = RegisterWindowMessageA(RWM_OPENMENU);
    WM_MSIME_IMEPAD        = RegisterWindowMessageA(RWM_IMEPAD);

    return fTrue;
}

/*----------------------------------------------------------------------------
    RegisterImeUIClass

    Register all IME UI calsses
----------------------------------------------------------------------------*/
BOOL RegisterImeUIClass(HANDLE hInstance)
{
    WNDCLASSEXA     wc;
    HANDLE             hMod;
    BOOL            fRet = fTrue;

    // Init wc zero
    ZeroMemory(&wc, sizeof(WNDCLASSEXA));
    
    wc.cbSize           = sizeof(WNDCLASSEXW);
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = sizeof(LONG_PTR) * 2;        // for IMMGWLP_IMC and IMMGWLP_PRIVATE
                                                    // and for move offset of Status window
    wc.hIcon            = NULL; 
    wc.hInstance        = (HINSTANCE)hInstance;
    wc.hCursor          = LoadCursor((HINSTANCE)NULL, IDC_ARROW);
    wc.lpszMenuName     = NULL;
    wc.hbrBackground    = (HBRUSH)GetStockObject(NULL_BRUSH);
    wc.hIconSm          = NULL;

    // Assumption
    DbgAssert(sizeof(WNDCLASSEXA) == sizeof(WNDCLASSEXW));

    ///////////////////////////////////////////////////////////////////////////
    // IME UI server class

    wc.style         = CS_VREDRAW | CS_HREDRAW | CS_IME;
    wc.lpfnWndProc   = UIWndProc;
    
    // Create Unicode window when NT
    if (IsWinNT())
        {
        LPWNDCLASSEXW     pwcW = (LPWNDCLASSEXW)&wc;

        // IME UI class UNICODE name
        pwcW->lpszClassName = wszUIClassName;

        if ((fRet = RegisterClassExW(pwcW)) == fFalse)
            goto RegisterImeUIClassExit;

        }
    else
        {
        // IME UI class ANSI name
        wc.lpszClassName = szUIClassName;

        if ((fRet = RegisterClassEx(&wc)) == fFalse)
            goto RegisterImeUIClassExit;
        }

    ///////////////////////////////////////////////////////////////////////////
    // IME status class
    wc.style         = CS_VREDRAW | CS_HREDRAW | CS_IME;
    wc.lpfnWndProc   = StatusWndProc;
    wc.lpszClassName = szStatusClassName;
    if ((fRet = RegisterClassEx(&wc)) == fFalse)
        goto RegisterImeUIClassExit;

    // Cand and composition wnd do not need extra wnd bytes
    wc.cbWndExtra    = 0;    
    
    ///////////////////////////////////////////////////////////////////////////
    // IME candidate class
    wc.lpfnWndProc   = CandWndProc;
    wc.lpszClassName = szCandClassName;
    if ((fRet = RegisterClassEx(&wc)) == fFalse)
        goto RegisterImeUIClassExit;

    ///////////////////////////////////////////////////////////////////////////
    // IME composition class
    wc.lpfnWndProc   = CompWndProc;
    wc.lpszClassName = szCompClassName;
    if ((fRet = RegisterClassEx(&wc)) == fFalse)
        goto RegisterImeUIClassExit;

    ///////////////////////////////////////////////////////////////////////////
    // Register Our Tooltip class
    hMod = GetModuleHandle("comctl32.dll");
    DbgAssert(hMod != 0);
    // If NT, register W class for Unicode text display on tooltip
    if (IsWinNT())
        {
        WNDCLASSEXW wcw;
        // Init wcw
        ZeroMemory(&wcw, sizeof(WNDCLASSEXW));
        
        wcw.cbSize = sizeof(WNDCLASSEXW);
        
        if (!GetClassInfoExW(NULL, wszTooltipClassName, &wcw))
            {
            GetClassInfoExW(NULL, TOOLTIPS_CLASSW, &wcw);
            wcw.cbSize = sizeof(WNDCLASSEXW);
            wcw.style |= CS_IME;
            wcw.hInstance = (HINSTANCE)hMod;
            wcw.lpszClassName = wszTooltipClassName;
            if ((fRet = RegisterClassExW(&wcw)) == fFalse)
                goto RegisterImeUIClassExit;
            }
        }
    else
        {
        wc.cbSize = sizeof(WNDCLASSEX);
        
        if (!GetClassInfoEx(NULL, szTooltipClassName, &wc))
            {
            GetClassInfoEx(NULL, TOOLTIPS_CLASS, &wc);
            wc.cbSize = sizeof(WNDCLASSEX);
            wc.style |= CS_IME;
            wc.hInstance = (HINSTANCE)hMod;
            wc.lpszClassName = szTooltipClassName;
            if ((fRet = RegisterClassEx(&wc)) == fFalse)
                goto RegisterImeUIClassExit;
            }
        }
        
RegisterImeUIClassExit:
#ifdef DEBUG
    OutputDebugString("RegisterImeUIClass() : return\r\n");
#endif
    DbgAssert(fRet);
    return fRet;
}


BOOL UnregisterImeUIClass(HANDLE hInstance)
{
    BOOL    fRet = fTrue;

    // Unregister Status window class
    UnregisterClass(szStatusClassName, (HINSTANCE)hInstance);

    // Unregister Candidate window class
    UnregisterClass(szCandClassName, (HINSTANCE)hInstance);

    // Unregister Composition window class
    UnregisterClass(szCompClassName, (HINSTANCE)hInstance);

    // Unregister Tooltip window class
    UnregisterClass(szTooltipClassName, (HINSTANCE)hInstance);

    // Unregister UI class window class
    UnregisterClass(szUIClassName, (HINSTANCE)hInstance); 
    
    return fRet;
}

/*----------------------------------------------------------------------------
    UIWndProc

    IME UI wnd messgae proc
----------------------------------------------------------------------------*/
LRESULT CALLBACK UIWndProc(HWND hUIWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV    lpUIPrivate;
    LRESULT        lRet;
    LRESULT        lResult = 0;
    
    Dbg(DBGID_UI, TEXT("UIWndProc():uMessage = 0x%08lX, wParam = 0x%04X, lParam = 0x%08lX"), uMessage, wParam, lParam);

    switch (uMessage)
        {
    HANDLE_MSG(hUIWnd, WM_COMMAND, UIWndOnCommand);
    case WM_CREATE:
        Dbg(DBGID_UI, TEXT("UIWndProc(): WM_CREATE- UI window Created"));
        // create storage for UI setting
        hUIPrivate = GlobalAlloc(GHND, sizeof(UIPRIV));
        if (!hUIPrivate) 
            {
            DbgAssert(0);
            return 1L;
            }

        if ((lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate))==0)
            return 1L;

        // Set UI show default value. 
        lpUIPrivate->uiShowParam = ISC_SHOWUIALL;
        
        SetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE, (LONG_PTR)hUIPrivate);
        // set the default position for UI window, it is hide now
        //SetWindowPos(hUIWnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER);
        //ShowWindow(hUIWnd, SW_SHOWNOACTIVATE);

        // Chcek if this is Winlogon process in Win9x
        if (!IsWinNT())
            {
            if (IsExplorerProcess() == fFalse && IsExplorer() == fFalse)
                vpInstData->dwSystemInfoFlags |= IME_SYSINFO_WINLOGON;
            }

        // Init Cicero service
        CiceroInitialize();
        DbgAssert(lpUIPrivate->m_pCicToolbar == NULL);

        if (IsCicero())
            lpUIPrivate->m_pCicToolbar = new CToolBar();
        
        GlobalUnlock(hUIPrivate);
        return 0;

    case WM_DESTROY:
        Dbg(DBGID_UI, TEXT("UIWndProc(): WM_DESTROY- UI window destroyed"));

        // Destroy IME Pad if exist
        CImePadSvr::DestroyCImePadSvr();

        hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
        if (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate))
            {
            Dbg(DBGID_UI, TEXT("         - WM_DESTROY Destroy all UI windows"));

            if (lpUIPrivate->hStatusTTWnd) 
                DestroyWindow(lpUIPrivate->hCandTTWnd);

            if (lpUIPrivate->hStatusWnd)
                DestroyWindow(lpUIPrivate->hStatusWnd);

            if (lpUIPrivate->hCandTTWnd)
                DestroyWindow(lpUIPrivate->hCandTTWnd);
            
            if (lpUIPrivate->hCandWnd)
                DestroyWindow(lpUIPrivate->hCandWnd);
        
            if (lpUIPrivate->hCompWnd)
                DestroyWindow(lpUIPrivate->hCompWnd);

            // Terminate Cicero service
            if (IsCicero())
                {
                if (lpUIPrivate->m_pCicToolbar)
                    {
                    lpUIPrivate->m_pCicToolbar->Terminate();
                    delete lpUIPrivate->m_pCicToolbar;
                    lpUIPrivate->m_pCicToolbar = NULL;
                    }
                // Issue: This call causes AV on Win9x
                // CiceroTerminate();
                }
            
            GlobalUnlock(hUIPrivate);
            GlobalFree(hUIPrivate);
            SetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE, (LONG_PTR)0L);
            }

        return 0;

    case WM_IME_NOTIFY:
        return NotifyUI(hUIWnd, wParam, lParam);
    
    case WM_IME_SETCONTEXT:
        Dbg(DBGID_UI, TEXT("            - WM_IME_SETCONTEXT"));
        OnImeSetContext(hUIWnd, (BOOL)wParam, lParam);
        return 0;

    // WM_IME_CONTROL: Return Non-zero means failure otherwise 0
    case WM_IME_CONTROL:
        Dbg(DBGID_UI, TEXT("            - WM_IME_CONTROL"));
        switch (wParam) 
            {
        case IMC_GETCANDIDATEPOS:
            return GetCandPos(hUIWnd, (LPCANDIDATEFORM)lParam);

        case IMC_GETCOMPOSITIONWINDOW:
            return GetCompPos(hUIWnd, (LPCOMPOSITIONFORM)lParam);

        case IMC_GETSTATUSWINDOWPOS:
                {
                HWND        hStatusWnd;
                RECT        rcStatusWnd;

                Dbg(DBGID_UI, TEXT("UIWndProc() - WM_IME_CONTROL - IMC_GETSTATUSWINDOWPOS"));
                hStatusWnd = GetStatusWnd(hUIWnd);
                if (!hStatusWnd)
                    return (1L);

                if (!GetWindowRect(hStatusWnd, &rcStatusWnd))
                     return (1L);

                return (MAKELRESULT(rcStatusWnd.left, rcStatusWnd.top));
                }
            break;
            
        case IMC_GETCOMPOSITIONFONT:
                {
                HFONT        hFontFix;
                LPLOGFONT    lpLogFont;
                LOGFONT        lfFont;

                hFontFix = CreateFont(-16,0,0,0,0,0,0,0,129,OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, FIXED_PITCH, szIMECompFont);
                lpLogFont = (LPLOGFONT)lParam;
                if (GetObject(hFontFix, sizeof(lfFont), (LPVOID)&lfFont))
                    *lpLogFont = lfFont;
                DeleteObject(hFontFix);
                }
            break;

        default:
            return (1L);
            }
        return 0;

    //
    case WM_IME_STARTCOMPOSITION:
        OpenComp(hUIWnd);
        return 0;

    case WM_IME_COMPOSITION:
        HWND hCompWnd;
        hCompWnd = GetCompWnd(hUIWnd);
        if (hCompWnd)   // Do not use Update() !
            {
            ShowComp(hUIWnd, SW_SHOWNOACTIVATE);
            InvalidateRect(hCompWnd, NULL, fTrue);
            }
        return 0;

    case WM_IME_ENDCOMPOSITION:
        hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
        if (hUIPrivate && (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate))) 
            {
            // if comp wnd exist, destroy it.
            if (lpUIPrivate->hCompWnd)
                {
                ShowComp(hUIWnd, SW_HIDE);
                DestroyWindow(lpUIPrivate->hCompWnd);
                lpUIPrivate->hCompWnd = 0;
                }
            GlobalUnlock(hUIPrivate);
            }
        return 0;

    case WM_IME_SELECT:
        Dbg(DBGID_UI, TEXT("            - WM_IME_SELECT"));
        OnImeSelect(hUIWnd, (BOOL)wParam);
        return 0;
    
    case WM_DISPLAYCHANGE:
            {
            CIMEData    ImeData(CIMEData::SMReadWrite);

            Dbg(DBGID_UI, TEXT("            - WM_DISPLAYCHANGE"));
            SystemParametersInfo(SPI_GETWORKAREA, 0, &ImeData->rcWorkArea, 0);
            hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
            if ( lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate) ) 
                {
                StatusDisplayChange(hUIWnd);
                GlobalUnlock(hUIPrivate);
                }
            return 0;
            }
    default:
        if (vfUnicode == fTrue && IsWinNT() == fTrue)
            lResult = DefWindowProcW(hUIWnd, uMessage, wParam, lParam);
        else
            lResult = DefWindowProc(hUIWnd, uMessage, wParam, lParam);
        }

    // if Private msg
    if (uMessage >= 0xC000)
        {
        // if private msg proccessed return value
        if (HandlePrivateMessage(hUIWnd, uMessage, wParam, lParam, &lRet))
            return lRet;
        }

    return lResult;
}

/*----------------------------------------------------------------------------
    HandlePrivateMessage

    IME UI private messgae handler
----------------------------------------------------------------------------*/
PRIVATE BOOL HandlePrivateMessage(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    LRESULT     lRet = 0;
    BOOL         fProcessed = fFalse;

    if (msg == WM_MSIME_PROPERTY)
        {
        fProcessed = fTrue;
        hIMC = GethImcFromHwnd(hWnd);
        if (pImeCtx = GetIMECtx(hIMC))
            ImeConfigure(NULL, pImeCtx->GetAppWnd(), (DWORD)lParam, NULL);
        DbgAssert(pImeCtx != NULL);
        }
    else
    if (msg == WM_MSIME_UPDATETOOLBAR)
        {
        HWND hStatusWnd;

        fProcessed = fTrue;
        hStatusWnd = GetStatusWnd(hWnd);
        if (hStatusWnd) 
            {
            CIMEData    ImeData;
            InvalidateRect(hStatusWnd, &ImeData->rcButtonArea, fFalse);
            }
        }
    else
    if (msg == WM_MSIME_OPENMENU)
        {
        fProcessed = fTrue;
        UIPopupMenu(hWnd);
        }
    else
    if (msg == WM_MSIME_IMEPAD)
        {
        if ((vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON) == 0)
            {
            hIMC = GethImcFromHwnd(hWnd);
            if (pImeCtx = GetIMECtx(hIMC)) 
                SetForegroundWindow(pImeCtx->GetAppWnd()); // trick
            DbgAssert(pImeCtx != NULL);

            // Boot Pad
            BootPad(hWnd, (UINT)wParam, lParam);
            }
        }
        
    *plRet = lRet;
    return fProcessed;
}

//////////////////////////////////////////////////////////////////////////////
LRESULT PASCAL NotifyUI(HWND hUIWnd, WPARAM wParam, LPARAM lParam)
{
    HWND     hWnd;
    HGLOBAL     hUIPrivate;
    LPUIPRIV lpUIPrivate;
    LONG     lRet = 0;

    Dbg(DBGID_UI, TEXT("NotifyUI(): hUIWnd = 0x%X wParam = 0x%04X, lParam = 0x%08lX"), hUIWnd, wParam, lParam);

    switch (wParam) 
        {
    case IMN_OPENSTATUSWINDOW:
        Dbg(DBGID_UI, TEXT("NotifyUI(): IMN_OPENSTATUSWINDOW"));
        StatusWndMsg(hUIWnd, fTrue);
        break;

    case IMN_CLOSESTATUSWINDOW:
        Dbg(DBGID_UI, TEXT("NotifyUI(): IMN_CLOSESTATUSWINDOW"));
        StatusWndMsg(hUIWnd, fFalse);
        break;

    case IMN_SETSTATUSWINDOWPOS:
        Dbg(DBGID_UI, TEXT("NotifyUI(): IMN_SETSTATUSWINDOWPOS"));
        if (!IsCicero())
            {
            fSetStatusWindowPos(GetStatusWnd(hUIWnd), NULL);
            fSetCompWindowPos(GetCompWnd(hUIWnd));
            }
        break;

    // IMN_SETCOMPOSITIONWINDOW called for all user key press
    case IMN_SETCOMPOSITIONWINDOW:
        hWnd = GetCompWnd(hUIWnd);
        if (hWnd)
            fSetCompWindowPos(hWnd);
        break;

    case IMN_OPENCANDIDATE:
        Dbg(DBGID_UI, TEXT("         - IMN_OPENCANDIDATE"));
        OpenCand(hUIWnd);
        break;
        
    case IMN_CLOSECANDIDATE:
        Dbg(DBGID_UI, TEXT("         - IMN_CLOSECANDIDATE"));
        if (lParam & 0x00000001) 
            {
            hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
            if (hUIPrivate && (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate))) 
                {
                if (lpUIPrivate->hCandWnd) 
                    {
                    ShowCand(hUIWnd, SW_HIDE);
                    DestroyWindow(lpUIPrivate->hCandWnd);
                    lpUIPrivate->hCandWnd = 0;
                    }
                    
                if (lpUIPrivate->hCandTTWnd) 
                    {
                    DestroyWindow(lpUIPrivate->hCandTTWnd);
                    lpUIPrivate->hCandTTWnd = 0;
                    }
                GlobalUnlock(hUIPrivate);
                }
            }
        break;
    
    case IMN_SETCANDIDATEPOS:
        hWnd = GetCandWnd(hUIWnd);
        if (hWnd)
            fSetCandWindowPos(hWnd);
        break;

    case IMN_CHANGECANDIDATE:
        Dbg(DBGID_UI, TEXT("           - Redraw cand window"));
        hWnd = GetCandWnd(hUIWnd);
        //RedrawWindow(hStatusWnd, &ImeData->rcButtonArea, NULL, RDW_INVALIDATE);
        InvalidateRect(hWnd, NULL, fFalse);
        break;

    case IMN_SETOPENSTATUS:        
        SetIndicator(GethImcFromHwnd(hUIWnd));
        break;

    case IMN_SETCONVERSIONMODE:
        hWnd = GetStatusWnd(hUIWnd);
        if (hWnd) 
            {
            CIMEData    ImeData(CIMEData::SMReadWrite);
            Dbg(DBGID_UI, TEXT("           - Redraw status window"));
            //RedrawWindow(hWnd, &ImeData->rcButtonArea, NULL, RDW_INVALIDATE);
            InvalidateRect(hWnd, &ImeData->rcButtonArea, fFalse);
            }
        SetIndicator(GethImcFromHwnd(hUIWnd));

        // Update Cicero buttons
        if (IsCicero() && (hUIPrivate = GethUIPrivateFromHwnd(hUIWnd)) && 
                          (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate)) != NULL)
            {
            lpUIPrivate->m_pCicToolbar->Update(UPDTTB_CMODE|UPDTTB_FHMODE);
            GlobalUnlock(hUIPrivate);
            }
        break;

    default:
        Dbg(DBGID_UI, TEXT("NotifyUI(): Unhandled IMN = 0x%04X"), wParam);
        lRet = fTrue;
        }

    return lRet;
}


///////////////////////////////////////////////////////////////////////////////
// Called when IMN_OPENSTATUSWINDOW/IMN_CLOSESTATUSWINDOW occurs
// set the show hide state and
// show/hide the status window
void PASCAL StatusWndMsg(HWND hUIWnd, BOOL fOn)
{
    HGLOBAL  hUIPrivate;
    HIMC     hIMC;
    register LPUIPRIV lpUIPrivate;

    Dbg(DBGID_UI, TEXT("StatusWndMsg(): hUIWnd = 0x%X, fOn = %d"), hUIWnd, fOn);

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);

    if (!hUIPrivate) 
        {
        DbgAssert(0);
        return;
        }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) 
        {
        DbgAssert(0);
        return;
        }

    hIMC = GethImcFromHwnd(hUIWnd);

    // if Cicero enabled, Init/Terminate Cicero toolbar.
    // Office 10 #249973: I moved init position to here from OnImeSetContext.
    // But make sure all user's "HKEY_CURRENT_USER\Control Panel\Input Method\Show Status" shuold be "1"
    // Setup will do this by enumerating HKEY_USERS
    if (IsCicero())
        {
        if (fOn)
            {
            if (lpUIPrivate->m_pCicToolbar)
                lpUIPrivate->m_pCicToolbar->Initialize();
            }
        else
            {
            if (lpUIPrivate->m_pCicToolbar)
                lpUIPrivate->m_pCicToolbar->Terminate();            
            }
        }
    else
        {
        if (fOn) 
            {
            InitButtonState();    // b#159
            OpenStatus(hUIWnd);
            } 

        if (lpUIPrivate->hStatusWnd == 0)
            {
            Dbg(DBGID_UI, TEXT("StatusWndMsg(): Null Status window handle"));
            GlobalUnlock(hUIPrivate);
            return;
            }

        if (fOn) 
            {
            if (hIMC)
                ShowStatus(hUIWnd, SW_SHOWNOACTIVATE);
            else
                {
                ShowStatus(hUIWnd, SW_HIDE);
                Dbg(DBGID_UI, TEXT("StatusWndMsg(): hIMC == 0, Call ShowStatus(HIDE)"));
                }
            }
        else 
            {
            DestroyWindow(lpUIPrivate->hStatusWnd);
            Dbg(DBGID_UI, TEXT("StatusWndMsg(): Call ShowStatus(HIDE)"));
            }
        }
    // Unlock UI private handle
    GlobalUnlock(hUIPrivate);
}

/*----------------------------------------------------------------------------
    OnUIProcessAttach
----------------------------------------------------------------------------*/
BOOL OnUIProcessAttach()
{
    DbgAssert(vdwTLSIndex == UNDEF_TLSINDEX);
    if (vdwTLSIndex == UNDEF_TLSINDEX)
        {
        vdwTLSIndex  = ::TlsAlloc();    //Get new TLS index.
        if (vdwTLSIndex == UNDEF_TLSINDEX)
            {
            Dbg(DBGID_UI, "-->SetActiveUIWnd ::TlsAlloc Error ret [%d]\n", GetLastError());
            return fFalse;
            }
        }
        
    return fTrue;
}

/*----------------------------------------------------------------------------
    OnUIProcessDetach
----------------------------------------------------------------------------*/
BOOL OnUIProcessDetach()
{
    if (TlsFree(vdwTLSIndex) == 0)
        {
        Dbg(DBGID_UI, "-->::TlsFree Error [%d]\n", GetLastError());
        return fFalse;
        }
    vdwTLSIndex = UNDEF_TLSINDEX;

    return fTrue;
}

/*----------------------------------------------------------------------------
    OnUIThreadDetach
----------------------------------------------------------------------------*/
BOOL OnUIThreadDetach()
{
    if (vdwTLSIndex != UNDEF_TLSINDEX)
        TlsSetValue(vdwTLSIndex, NULL);

    return fTrue;
}

/*----------------------------------------------------------------------------
    SetActiveUIWnd

    Save current Active UI wnd handle to TLS
----------------------------------------------------------------------------*/
VOID SetActiveUIWnd(HWND hWnd)
{
    Dbg(DBGID_UI, "SetActiveUIWnd(hWnd=%lx) \r\n", hWnd);

    if (IsWin(hWnd) == fFalse) 
        {
        Dbg(DBGID_UI, "SetActiveUIWnd( hWnd=%lx ) - no window\r\n", hWnd );
        return;
        }

    if (TlsSetValue(vdwTLSIndex, (LPVOID)hWnd) == 0)
        {
        Dbg(DBGID_UI, "-->LoadCImePadSvr() TlsSetValue Failed [%d]\n", GetLastError());
        TlsSetValue(vdwTLSIndex, NULL);
        return;
        }
}

/*----------------------------------------------------------------------------
    GetActiveUIWnd

    Retrieve  current Active UI wnd handle from TLS
----------------------------------------------------------------------------*/
HWND GetActiveUIWnd()
{
    return (HWND)TlsGetValue(vdwTLSIndex); 
}

// Called by OnImeSetContext() and OnImeSelect()
void PASCAL ShowUI(HWND   hUIWnd, int nShowCmd)
{
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;
    
    Dbg(DBGID_UI, TEXT("ShowUI() : nShowCmd=%d"), nShowCmd);

#if 0
    if (nShowCmd != SW_HIDE) 
        {
        // Check if hIMC and hPrivate is valid
        // If not valid hide all UI windows.
        hIMC = GethImcFromHwnd(hUIWnd);
        lpIMC = (LPINPUTCONTEXT)OurImmLockIMC(hIMC);
        lpImcP = (LPIMCPRIVATE)GetPrivateBuffer(hIMC);

        if (!(hIMC && lpIMC && lpImcP))
            nShowCmd = SW_HIDE;
        }
#else
    hIMC = GethImcFromHwnd(hUIWnd);
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
            nShowCmd = SW_HIDE;
#endif

    ///////////////////////////////////////////////////////////////////////////
    // Lock hUIPrivate
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);

    // can not draw status window
    if (!hUIPrivate)
        return;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    // can not draw status window
    if (!lpUIPrivate)
        return;

    // Hide all UI window and return immediately
    if (nShowCmd == SW_HIDE) 
        {
        Dbg(DBGID_UI, TEXT("ShowUI() : hiding all UI"));
        ShowStatus(hUIWnd, SW_HIDE);
        ShowComp(hUIWnd, SW_HIDE);
        ShowCand(hUIWnd, SW_HIDE);
        
        // FIXED : if (nShowCmd == SW_HIDE) hIMC and lpIMC->hPrivate not Locked
        // So you need not Unlock 
        goto ShowUIUnlockUIPrivate;
        }

    //////////////////
    // Status window
    if (lpUIPrivate->hStatusWnd)
        {
        // if currently hide, show it.
        if (lpUIPrivate->nShowStatusCmd == SW_HIDE)
            ShowStatus(hUIWnd, SW_SHOWNOACTIVATE);
        else
            {
            // sometime the WM_ERASEBKGND is eaten by the app
            RedrawWindow(lpUIPrivate->hStatusWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE/*|RDW_ERASE*/);
            }
        }
/*
    //////////////////////
    // Composition window
    if (lpUIPrivate->hCompWnd)
        {
        if (lpUIPrivate->nShowCompCmd == SW_HIDE)
            ShowComp(hUIWnd, SW_SHOWNOACTIVATE);
        else                
            {
            // sometime the WM_ERASEBKGND is eaten by the app
            RedrawWindow(lpUIPrivate->hCompWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }
        } 

    ////////////////////
    // Candidate window
    if (lpUIPrivate->hCandWnd) 
        {
        if (lpUIPrivate->nShowCandCmd == SW_HIDE)
            ShowCand(hUIWnd, SW_SHOWNOACTIVATE);
        else
            {
            // some time the WM_ERASEBKGND is eaten by the app
            RedrawWindow(lpUIPrivate->hCandWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

        fSetCandWindowPos(lpUIPrivate->hCandWnd);
        } 
*/
ShowUIUnlockUIPrivate:
    GlobalUnlock(hUIPrivate);        
    return;
}

////////////////////////////////////////////////////////////////////////
// WM_IME_SETCONTEXT sent whenever user activated/deactivated a window
void PASCAL OnImeSetContext(HWND hUIWnd, BOOL fOn, LPARAM lShowUI)
{
    HGLOBAL      hUIPrivate;
    LPUIPRIV     lpUIPrivate;
    HWND        hwndIndicator = FindWindow(INDICATOR_CLASS, NULL);
    HIMC        hIMC = NULL;
    PCIMECtx     pImeCtx;

    Dbg(DBGID_UI, TEXT("OnImeSetContext(): hUIWnd = 0x%X fOn = %d"), hUIWnd, fOn);

    // Get UI private memory
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (hUIPrivate == 0 || (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate)) == 0)
        {
        ShowUI(hUIWnd, SW_HIDE);
        // Set disabled Pen Icon 
        if (fOn)
            SetIndicator((PCIMECtx)NULL);
        goto LOnImeSetContextExit;
        }

    // Init Cicero service
    CiceroInitialize();

    // If Cicero enabled, init toolbar
    if (IsCicero())
        {
        // Create Toolbar object and store it to private memory
        if (lpUIPrivate->m_pCicToolbar == NULL)
            lpUIPrivate->m_pCicToolbar = new CToolBar();

        DbgAssert(lpUIPrivate->m_pCicToolbar != NULL);
        }

    hIMC = GethImcFromHwnd(hUIWnd);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        {
        ShowUI(hUIWnd, SW_HIDE);
        // Set disabled Pen Icon 
        if (fOn)
            SetIndicator((PCIMECtx)NULL);

        // Disable cicero buttons
        if (IsCicero() && lpUIPrivate->m_pCicToolbar)
            lpUIPrivate->m_pCicToolbar->SetCurrentIC(NULL);
            
        goto LOnImeSetContextExit2;
        }

    if (fOn)
        {
        // Store UI Window handle to TLS
        SetActiveUIWnd(hUIWnd);
        
        // Keep lParam
        lpUIPrivate->uiShowParam = lShowUI;

        if (pImeCtx->GetCandidateFormIndex(0) != 0)
            pImeCtx->SetCandidateFormIndex(CFS_DEFAULT, 0);

        // Remove right Help menu item on Pen Icon 
        if (hwndIndicator)
            {
            PostMessage(hwndIndicator, 
                        INDICM_REMOVEDEFAULTMENUITEMS , 
                        RDMI_RIGHT, 
                        (LPARAM)GetKeyboardLayout(NULL));
            // Set Pen Icon
            SetIndicator(pImeCtx);
            }
            
        // For display Status window.
        ShowUI(hUIWnd, SW_SHOWNOACTIVATE);

        if (IsCicero() && lpUIPrivate->m_pCicToolbar)
            lpUIPrivate->m_pCicToolbar->SetCurrentIC(pImeCtx);
        }

LOnImeSetContextExit2:
    GlobalUnlock(hUIPrivate);

LOnImeSetContextExit:
    LPCImePadSvr lpCImePadSvr = CImePadSvr::GetCImePadSvr();
    if(lpCImePadSvr) 
        {
        BOOL fAct = (BOOL)(fOn && hIMC);
        if (fAct) 
            {
            IImeIPoint1* pIP = GetImeIPoint(hIMC);
            //HWND hWnd          = GetStatusWnd(hUIWnd);

            //ImePadSetCurrentIPoint(hWnd, pIp);
            lpCImePadSvr->SetIUnkIImeIPoint((IUnknown *)pIP);
            //UpdatePadButton(pUI->GetWnd());
            // Don't need to repaint. StatusOnPaint will do it
            //if (hWnd)
            //    InvalidateRect(hWnd, NULL, fFalse);
            }
        lpCImePadSvr->Notify(IMEPADNOTIFY_ACTIVATECONTEXT, fAct, 0);
        }

    return;
}

///////////////////////////////////////////////////////////////////////////////
// WM_IME_SELECT sent when user change IME
void PASCAL OnImeSelect(HWND hUIWnd, BOOL fOn)
{
    HGLOBAL      hUIPrivate;
    LPUIPRIV     lpUIPrivate;
    HWND        hwndIndicator = FindWindow(INDICATOR_CLASS, NULL);
    HIMC           hIMC;
    PCIMECtx     pImeCtx;

    Dbg(DBGID_UI, TEXT("OnImeSelect(): hUIWnd = 0x%Xm fOn = %d"), hUIWnd, fOn);

    // Get UI private memory
    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (hUIPrivate == 0 || (lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate)) == 0)
        {
        ShowUI(hUIWnd, SW_HIDE);
        // Set disabled Pen Icon 
        SetIndicator((PCIMECtx)NULL);
        return;
        }

    // Init Cicero service
    CiceroInitialize();

    // If Cicero enabled, init toolbar
    if (IsCicero())
        {
        // Create Toolbar object and store it to private memory
        if (lpUIPrivate->m_pCicToolbar == NULL)
            lpUIPrivate->m_pCicToolbar = new CToolBar();
            
        DbgAssert(lpUIPrivate->m_pCicToolbar != NULL);
        }

    hIMC = GethImcFromHwnd(hUIWnd);

    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        {
        ShowUI(hUIWnd, SW_HIDE);
        // Set disabled Pen Icon 
        SetIndicator((PCIMECtx)NULL);

        // Disable cicero buttons
        if (IsCicero() && lpUIPrivate->m_pCicToolbar)
            lpUIPrivate->m_pCicToolbar->SetCurrentIC(NULL);

        return;
        }

    if (fOn)
        {
        // Store UI Window handle to TLS. Sometimes when user switch IME only WM_IME_SELECT sent. No WM_IME_SETCONTEXT msg.
        SetActiveUIWnd(hUIWnd);

        if (pImeCtx->GetCandidateFormIndex(0) != 0)
            pImeCtx->SetCandidateFormIndex(CFS_DEFAULT, 0);

        // Remove right Help menu item on Pen Icon 
        if (hwndIndicator)
            {
            Dbg(DBGID_UI, TEXT("OnImeSelect(): Post indicator message"), hUIWnd, fOn);

            PostMessage(hwndIndicator, 
                        INDICM_REMOVEDEFAULTMENUITEMS , 
                        RDMI_RIGHT, 
                        (LPARAM)GetKeyboardLayout(NULL));
            // Set Pen Icon
            SetIndicator(pImeCtx);
            }

        // If Cicero enabled, init toolbar
        if (IsCicero() && lpUIPrivate->m_pCicToolbar)
            lpUIPrivate->m_pCicToolbar->SetCurrentIC(pImeCtx);
        }


    // IME PAD
    LPCImePadSvr lpCImePadSvr = CImePadSvr::GetCImePadSvr();
    if(lpCImePadSvr) 
        {
        BOOL fAct = (BOOL)(fOn && hIMC);
        if (fAct) 
            {
            IImeIPoint1* pIP = GetImeIPoint(hIMC);
            lpCImePadSvr->SetIUnkIImeIPoint((IUnknown *)pIP);
            }
        lpCImePadSvr->Notify(IMEPADNOTIFY_ACTIVATECONTEXT, fAct, 0);
        }

    // Close input sontext here
    // Because ImeSelect has not called from IMM on WIN95.
    if (fOn == fFalse)
        {
        DWORD dwCMode = 0, dwSent = 0;

        // If Hanja conversion mode when uninit, cancel it.
        OurImmGetConversionStatus(hIMC, &dwCMode, &dwSent);
        if (dwCMode & IME_CMODE_HANJACONVERT)
            OurImmSetConversionStatus(hIMC, dwCMode & ~IME_CMODE_HANJACONVERT, dwSent);

        // if interim state, make complete current comp string
        // But IMM sends CPS_CANCEL when user change layout
        if (pImeCtx->GetCompBufLen()) 
            {
            pImeCtx->FinalizeCurCompositionChar();
            pImeCtx->GenerateMessage();
            }

        CloseInputContext(hIMC);
        }
        
    GlobalUnlock(hUIPrivate);
}

HWND PASCAL GetStatusWnd(HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hStatusWnd;

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)           // can not darw status window
        return (HWND)NULL;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)         // can not draw status window
        return (HWND)NULL;

    hStatusWnd = lpUIPrivate->hStatusWnd;

    GlobalUnlock(hUIPrivate);
    return (hStatusWnd);
}

HWND PASCAL GetCandWnd(HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCandWnd;

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)          // can not darw candidate window
        return (HWND)NULL;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)         // can not draw candidate window
        return (HWND)NULL;

    hCandWnd = lpUIPrivate->hCandWnd;

    GlobalUnlock(hUIPrivate);
    return (hCandWnd);
}

HWND PASCAL GetCompWnd(HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCompWnd;

    hUIPrivate = GethUIPrivateFromHwnd(hUIWnd);
    if (!hUIPrivate)          // can not draw comp window
        return (HWND)NULL;

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)         // can not draw comp window
        return (HWND)NULL;

    hCompWnd = lpUIPrivate->hCompWnd;
    GlobalUnlock(hUIPrivate);

    return (hCompWnd);
}

LRESULT PASCAL GetCandPos(HWND hUIWnd, LPCANDIDATEFORM lpCandForm)
{
    HWND        hCandWnd;
    RECT        rcCandWnd;
    HIMC         hIMC;
    PCIMECtx     pImeCtx;

    if (lpCandForm->dwIndex != 0)
        return (1L);

    hCandWnd = GetCandWnd(hUIWnd);

    if (!hCandWnd)
        return (1L);

    if (!GetWindowRect(hCandWnd, &rcCandWnd))
        return (1L);

    hIMC = GethImcFromHwnd(hUIWnd);
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return (1L);

    //*lpCandForm = lpIMC->cfCandForm[0];
    lpCandForm->dwIndex = pImeCtx->GetCandidateFormIndex(0);
    lpCandForm->dwStyle = pImeCtx->GetCandidateFormStyle(0);
    pImeCtx->GetCandidateForm(&lpCandForm->rcArea, 0);
    lpCandForm->ptCurrentPos = *(LPPOINT)&rcCandWnd;

    return (0L);
}

LRESULT PASCAL GetCompPos(HWND hUIWnd, LPCOMPOSITIONFORM lpCompForm)
{
    HWND        hCompWnd;
    RECT        rcCompWnd;
    HIMC         hIMC;
    PCIMECtx     pImeCtx;

    hCompWnd = GetCompWnd(hUIWnd);

    if (!hCompWnd)
        return (1L);

    if (!GetWindowRect(hCompWnd, &rcCompWnd))
        return (1L);

    hIMC = GethImcFromHwnd(hUIWnd);
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return (1L);

    lpCompForm->dwStyle = pImeCtx->GetCompositionFormStyle();
    pImeCtx->GetCompositionForm(&lpCompForm->ptCurrentPos);
    pImeCtx->GetCompositionForm(&lpCompForm->rcArea);

    return (0L);
}


///////////////////////////////////////////////////////////////////////////////
// Popup menu message handler
void PASCAL UIWndOnCommand(HWND hUIWnd, INT id, HWND hWndCtl, UINT codeNotify)
{
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    CHAR        szBuffer[256];
    CIMEData    ImeData(CIMEData::SMReadWrite);

    szBuffer[0] = '\0';
    
    hIMC = GethImcFromHwnd(hUIWnd);
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return;

    switch (id)
        {
    case ID_CONFIG:
        ImeConfigure(0, pImeCtx->GetAppWnd(), IME_CONFIG_GENERAL, NULL);
        break;

    case ID_ABOUT:
        OurLoadStringA(vpInstData->hInst, IDS_PROGRAM, szBuffer, sizeof(szBuffer));
        ShellAbout(pImeCtx->GetAppWnd(), szBuffer, NULL, (HICON)LoadImage((HINSTANCE)vpInstData->hInst,
                    MAKEINTRESOURCE(IDI_UNIKOR), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR));
        break;

    //////////////////////////////////////////////////////////////////////
    // IME internal Keyboard layout change message
    case ID_2BEOLSIK: 
    case ID_3BEOLSIK390: 
    case ID_3BEOLSIKFINAL :
        if (ImeData.GetCurrentBeolsik() != (UINT)(id - ID_2BEOLSIK))
            {
            pImeCtx->GetAutomata()->InitState();
            pImeCtx->GetGData()->SetCurrentBeolsik(id - ID_2BEOLSIK);
            pImeCtx->GetAutomata()->InitState();

            SetRegValues(GETSET_REG_IMEKL);
            }
        break;

    //////////////////////////////////////////////////////////////////////
    // Han/Eng Toggle
    case ID_HANGUL_MODE :
        if (!(pImeCtx->GetConversionMode() & IME_CMODE_HANGUL)) 
               {
            OurImmSetConversionStatus(hIMC, 
                                    pImeCtx->GetConversionMode() ^ IME_CMODE_HANGUL, 
                                    pImeCtx->GetSentenceMode());
            }
        break;

    case ID_ENGLISH_MODE :
        if (pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) 
               {
            OurImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
            OurImmSetConversionStatus(hIMC, 
                                    pImeCtx->GetConversionMode() ^ IME_CMODE_HANGUL, 
                                    pImeCtx->GetSentenceMode());
            }
        break;

    //////////////////////////////////////////////////////////////////////
    // Hangul deletion per jaso or char.
    case ID_JASO_DELETION:
        ImeData.SetJasoDel(!ImeData.GetJasoDel());
        SetRegValues(GETSET_REG_JASODEL);
        break;

    default :
        Dbg(DBGID_UI, TEXT("UIWndOnCommand() - Unknown command"));
        break;
        }
    return;
}

void UIPopupMenu(HWND hUIWnd)
{
    HMENU   hMenu, hPopupMenu;
    POINT   ptCurrent;
    UINT    uiCurSel;
    HIMC        hIMC;
    PCIMECtx     pImeCtx;
    CIMEData    ImeData;

    hIMC = GethImcFromHwnd(hUIWnd);
    if ((pImeCtx = GetIMECtx(hIMC)) == NULL)
        return;

    GetCursorPos(&ptCurrent);
    hMenu = OurLoadMenu(vpInstData->hInst, MAKEINTRESOURCE(IDR_STATUS_POPUP));
    if (hMenu != NULL)
        {
        hPopupMenu = GetSubMenu(hMenu, 0);
        if (hPopupMenu == NULL)
            return;
            
        // Keyboard type selection radio button
        uiCurSel = ID_2BEOLSIK + ImeData.GetCurrentBeolsik();
        CheckMenuRadioItem(hPopupMenu, ID_2BEOLSIK, ID_3BEOLSIKFINAL, uiCurSel, MF_BYCOMMAND);

        // Han/Eng mode selection radio button
        uiCurSel = ID_HANGUL_MODE + ((pImeCtx->GetConversionMode() & IME_CMODE_HANGUL) ? 0 : 1);
        CheckMenuRadioItem(hPopupMenu, ID_HANGUL_MODE, ID_ENGLISH_MODE, uiCurSel, MF_BYCOMMAND);

        // Hangul jaso deletion
        if (ImeData.GetJasoDel())
            CheckMenuItem(hPopupMenu, ID_JASO_DELETION, MF_BYCOMMAND | MF_CHECKED);
        else
            CheckMenuItem(hPopupMenu, ID_JASO_DELETION, MF_BYCOMMAND | MF_UNCHECKED);

        // if Winlogon process, gray all config menu
        if (vpInstData->dwSystemInfoFlags & IME_SYSINFO_WINLOGON) 
                {
            EnableMenuItem(hPopupMenu, ID_CONFIG, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hPopupMenu, ID_2BEOLSIK, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hPopupMenu, ID_3BEOLSIK390, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hPopupMenu, ID_3BEOLSIKFINAL, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hPopupMenu, ID_JASO_DELETION, MF_BYCOMMAND | MF_GRAYED);
            }
        TrackPopupMenu(hPopupMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
                        ptCurrent.x, ptCurrent.y, 0, hUIWnd, NULL);
        DestroyMenu(hMenu);
        }
}

BOOL PASCAL SetIndicator(PCIMECtx pImeCtx)
{
    ATOM        atomIndicator;
    CHAR        sztooltip[IMEMENUITEM_STRING_SIZE];
    int            nIconIndex;
    HWND        hwndIndicator;
    
    Dbg(DBGID_Tray, TEXT("SetIndicator Enter"));
    hwndIndicator = FindWindow(INDICATOR_CLASS, NULL);

    if (!hwndIndicator)
        {
        Dbg(DBGID_Tray, TEXT("!!! WARNING !!!: Indicator window not found"));
        return fFalse;
        }
        
    // init sztooltip
    sztooltip[0] = 0;
    
    // Default value is disabled.
    OurLoadStringA(vpInstData->hInst, IDS_IME_TT_DISABLE, sztooltip, IMEMENUITEM_STRING_SIZE);
    nIconIndex = 5;

    if (pImeCtx) 
        {
        // If IME closed, English half mode
        if (pImeCtx->IsOpen() == fFalse)
            {
            OurLoadStringA(vpInstData->hInst, IDS_IME_TT_ENG_HALF, sztooltip, IMEMENUITEM_STRING_SIZE);
            nIconIndex= 3;
            }
        else
            {
            // If Hangul mode
            if (pImeCtx->GetConversionMode()  & IME_CMODE_HANGUL) 
                {
                if (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE)
                    {
                    OurLoadStringA(vpInstData->hInst, IDS_IME_TT_HANGUL_FULL, sztooltip, IMEMENUITEM_STRING_SIZE);
                    nIconIndex = 4;
                    }
                else
                    {
                    OurLoadStringA(vpInstData->hInst, IDS_IME_TT_HANGUL_HALF, sztooltip, IMEMENUITEM_STRING_SIZE);
                    nIconIndex = 1;
                    }
                }
            else 
                // Non-Hangul mode
                if (pImeCtx->GetConversionMode() & IME_CMODE_FULLSHAPE)
                    {
                    OurLoadStringA(vpInstData->hInst, IDS_IME_TT_ENG_FULL, sztooltip, IMEMENUITEM_STRING_SIZE);
                    nIconIndex = 2;
                    }
            }
        }
    
    Dbg(DBGID_Tray, TEXT("SetIndicator: PostMessage: nIconIndex=%d"), nIconIndex);
    PostMessage(hwndIndicator, INDICM_SETIMEICON, nIconIndex, (LPARAM)GetKeyboardLayout(NULL));
    
    // Should use GlobalFindAtom b#57121
    atomIndicator = GlobalFindAtom(sztooltip);
    // If no global atom exist, add it
    if (!atomIndicator)
        atomIndicator = GlobalAddAtom(sztooltip);

    DbgAssert(atomIndicator);
    
    if (atomIndicator)
        {
        Dbg(DBGID_Tray, TEXT("SetIndicator: PostMessage: atomIndicator=%s"), sztooltip);
        PostMessage(hwndIndicator, INDICM_SETIMETOOLTIPS, atomIndicator, (LPARAM)GetKeyboardLayout(NULL));
        }
    
    return fTrue;;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\ui.h ===
/****************************************************************************
	UI.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	UI functions
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_UI_H__INCLUDED_)
#define _UI_H__INCLUDED_

// CIMEData class forward declaration.
class CIMEData;

// UI.CPP
PUBLIC UINT WM_MSIME_PROPERTY;		// Invoke property DLG
PUBLIC UINT WM_MSIME_UPDATETOOLBAR; // Redraw status window(Toolbar)
PUBLIC UINT WM_MSIME_OPENMENU;		// Pop up status window context menu
PUBLIC UINT WM_MSIME_IMEPAD;		// Boot up IME Pad

PUBLIC BOOL InitPrivateUIMsg();
PUBLIC BOOL RegisterImeUIClass(HANDLE hInstance);
PUBLIC BOOL UnregisterImeUIClass(HANDLE hInstance);
PUBLIC BOOL OnUIProcessAttach();
PUBLIC BOOL OnUIProcessDetach();
PUBLIC BOOL OnUIThreadDetach();
PUBLIC VOID SetActiveUIWnd(HWND hWnd);
PUBLIC HWND GetActiveUIWnd();
PUBLIC VOID UIPopupMenu(HWND hStatusWnd);
//PUBLIC VOID HideStatus();

///////////////////////////////////////////////////////////////////////////////
// StatusUI.Cpp
PUBLIC VOID PASCAL OpenStatus(HWND hUIWnd);
PUBLIC LRESULT CALLBACK StatusWndProc(HWND hStatusWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
PUBLIC VOID ShowStatus(HWND hUIWnd, INT nShowStatusCmd);
PUBLIC VOID UpdateStatusButtons(CIMEData &IMEData);
PUBLIC VOID UpdateStatusWinDimension();
PUBLIC VOID StatusDisplayChange(HWND hUIWnd);
PUBLIC VOID InitButtonState();
PUBLIC BOOL fSetStatusWindowPos(HWND hStatusWnd, POINT *ptStatusWndPos = NULL);


///////////////////////////////////////////////////////////////////////////////
// CandUI.Cpp
PUBLIC VOID PASCAL OpenCand(HWND hUIWnd);
PUBLIC LRESULT CALLBACK CandWndProc(HWND hCandWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
PUBLIC VOID ShowCand(HWND hUIWnd, INT nShowCandCmd);
PUBLIC BOOL fSetCandWindowPos(HWND hCandWnd);


///////////////////////////////////////////////////////////////////////////////
// CompUI.Cpp
#define COMP_SIZEX	22
#define COMP_SIZEY	22
#define UI_GAPX		10
PUBLIC VOID PASCAL OpenComp(HWND hUIWnd);
PUBLIC LRESULT CALLBACK CompWndProc(HWND hCompWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
PUBLIC VOID ShowComp(HWND hUIWnd, INT nShowCompCmd);
PUBLIC BOOL fSetCompWindowPos(HWND hCompWnd);

///////////////////////////////////////////////////////////////////////////////
// UISubs.CPP
enum StatusButtonTypes 
{ 
	HAN_ENG_TOGGLE_BUTTON, 
	JUNJA_BANJA_TOGGLE_BUTTON, 
	HANJA_CONV_BUTTON,
	IME_PAD_BUTTON,
	NULL_BUTTON = 0xFF
};

// Button status
#define BTNSTATE_NORMAL		0	// normal
#define BTNSTATE_ONMOUSE	1	// mouse cursor on the button
#define BTNSTATE_PUSHED		2	// pushed
#define BTNSTATE_DOWN		4	// pushed
#define BTNSTATE_HANJACONV  8	// If hanja conv mode, button always pushed

// Button size
#define BTN_SMALL			0
#define BTN_MIDDLE			1
#define BTN_LARGE			2

struct StatusButton 
{
	StatusButtonTypes m_ButtonType;
	WORD	m_BmpNormalID, m_BmpOnMouseID, m_BmpPushedID, m_BmpDownOnMouseID;
	WORD	m_ToolTipStrID;
	INT		m_uiButtonState;
	BOOL   m_fEnable;

	StatusButton() 
		{
		m_ButtonType = NULL_BUTTON;
		m_BmpNormalID = m_BmpPushedID = m_ToolTipStrID = 0;
		m_fEnable = fTrue;
		m_uiButtonState = BTNSTATE_NORMAL;
		}
};

PUBLIC VOID PASCAL FrameControl(HDC hDC, RECT* pRc, INT iState);
PUBLIC VOID PASCAL DrawBitmap(HDC hDC, LONG xStart, LONG yStart, HBITMAP hBitmap);
PUBLIC BOOL PASCAL SetIndicatorIcon(INT nIconIndex, ATOM atomToolTip);
PUBLIC VOID UpdateStatusButtonInfo();
PUBLIC HANDLE WINAPI OurLoadImage( LPCTSTR pszName, UINT uiType, INT cx, INT cy, UINT uiLoad);
PUBLIC BOOL WINAPI OurTextOutW(HDC hDC, INT x, INT y, WCHAR wch);

#if 1 // MultiMonitor support
PUBLIC void PASCAL ImeMonitorWorkAreaFromWindow(HWND hAppWnd, RECT* pRect);
PUBLIC void PASCAL ImeMonitorWorkAreaFromPoint(POINT, RECT* pRect);
PUBLIC void PASCAL ImeMonitorWorkAreaFromRect(LPRECT, RECT* pRect);
PUBLIC HMONITOR PASCAL ImeMonitorFromRect(LPRECT lprcRect);
#endif

///////////////////////////////////////////////////////////////////////////////
// Inline Functions
inline
HIMC GethImcFromHwnd(HWND hWnd)
{
	if (hWnd == (HWND)0 || IsWindow(hWnd) == fFalse) 
		return (HIMC)NULL;
	else
		return (HIMC)GetWindowLongPtr(hWnd, IMMGWLP_IMC);
}

inline
HGLOBAL GethUIPrivateFromHwnd(HWND hWnd)
{
	if (hWnd == (HWND)0 || IsWindow(hWnd) == fFalse) 
		return (HIMC)NULL;
	else
		return (HGLOBAL)GetWindowLongPtr(hWnd, IMMGWLP_PRIVATE);
}

#endif // !defined (_UI_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\ntmigexe\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\winex.cpp ===
/****************************************************************************
    WINEX.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Windows API extension functions
    
    History:
    19-JUL-1999 cslim       Created
*****************************************************************************/

#include "precomp.h"
#include "winex.h"

static LPSTR GetModuleName(BOOL fFullPath = fFalse);

BOOL vf16BitApps = fFalse;

POSVERSIONINFO GetVersionInfo()
{
    static BOOL fFirstCallVerInfo = fTrue;
    static OSVERSIONINFO os;

    if (fFirstCallVerInfo) 
        {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &os ) )
            fFirstCallVerInfo = fFalse;
        }
        
    return &os;
}

BOOL WINAPI IsWinNT() 
{ 
    static BOOL fFirstCallNT4 = fTrue;
    static BOOL fNT4 = fFalse;

    if (fFirstCallNT4 == fFalse)
        return fNT4;

    fFirstCallNT4 = fFalse;
    fNT4 = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (GetVersionInfo()->dwMajorVersion >= 4);

    return fNT4;
}

BOOL WINAPI IsWinNT5orUpper() 
{ 
    static BOOL fFirstCallNT5 = fTrue;
    static BOOL fNT5 = fFalse;

    if (fFirstCallNT5 == fFalse)
        return fNT5;

    fFirstCallNT5 = fFalse;
    fNT5 = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
             (GetVersionInfo()->dwMajorVersion >= 5);

    return fNT5;
}

BOOL WINAPI IsMemphis() 
{ 
    static BOOL fFirstCallMemphis = fTrue;
    static BOOL fMemphis = fFalse;

    if (fFirstCallMemphis == fFalse)
        return fMemphis;

    fFirstCallMemphis = fFalse;
    
    fMemphis = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
                (GetVersionInfo()->dwMajorVersion >= 4) &&
                (GetVersionInfo()->dwMinorVersion  >= 10);

    return fMemphis;
}

BOOL WINAPI IsWin95() 
{
    static BOOL fFirstCallIsWin95 = fTrue;
    static BOOL fIsWin95 = fFalse;

    if (fFirstCallIsWin95 == fFalse)
        return fIsWin95;

    fIsWin95 = !IsWinNT() && !IsMemphis();

    return fIsWin95;
}


LPSTR OurGetModuleFileName(BOOL fFullPath)
{
    LPSTR pch;
    LPSTR pchFilename;

    static CHAR szFile[MAX_PATH] = {0};

    if (szFile[0] == '\0')
        GetModuleFileName(NULL, szFile, MAX_PATH);

    if (fFullPath)
        return szFile;

    pch = szFile;
    pchFilename = NULL;
    
    while (*pch++) 
        {
        if (*pch == '\\')
            pchFilename = pch + 1;
        }

    return pchFilename;
}

inline Min(INT a, INT b) 
{
     return ((a)<(b)?(a):(b)) ;
}

//////////////////////////////////////////////////////////////////
// Function : OurLoadStringW
// Type     : INT
// Purpose  : Wrapper of LoadStrinW() API.
//              Load Unicode string with specified Language 
//              in any platform.
// Args     : 
//          : LANGID    lgid 
//          : HINSTANCE hInst 
//          : UINT        uID 
//          : LPWSTR    lpBuffer 
//          : INT        nBufferMax 
// Return   : 
// DATE     : 971028
//////////////////////////////////////////////////////////////////
INT WINAPI OurLoadStringW(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, INT nBufferMax)
{
    INT     cchwstr = 0;
    UINT    block, num;
    HRSRC   hres;
    HGLOBAL hgbl;
    LPWSTR  lpwstr;

    if (!hInst || !lpBuffer)
        return 0;

    block = (uID >>4)+1;
    num   = uID & 0xf;

    hres = FindResourceEx(hInst,
                          RT_STRING,
                          MAKEINTRESOURCE(block),
                          GetSystemDefaultLangID());

    if (hres == NULL)
        hres = FindResourceEx(hInst,
                          RT_STRING,
                          MAKEINTRESOURCE(block),
                          MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));

    if (!hres)
        goto Error;

    if ((hgbl = LoadResource(hInst, hres)) == NULL)
        goto Error;

    if ((lpwstr = (LPWSTR)LockResource(hgbl)) == NULL)
        goto Error;

    for(UINT i = 0; i < num; i++)
        lpwstr += *lpwstr + 1;

    cchwstr = *lpwstr;
    CopyMemory(lpBuffer, lpwstr+1, Min(cchwstr, nBufferMax-1) * sizeof(WCHAR));
    
 Error:
     lpBuffer[Min(cchwstr, nBufferMax-1)]= (WCHAR)0x0000;
    return cchwstr;
}

//////////////////////////////////////////////////////////////////
// Function : ExLoadStringA
// Type     : INT
// Purpose  : Wrapper of LoadStringA().
// Args     : 
//          : LANGID    lgid
//          : HINSTANCE hInst 
//          : INT        uID 
//          : LPSTR        lpBuffer 
//          : INT        nBufferMax 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
INT WINAPI OurLoadStringA(HINSTANCE hInst, INT uID, LPSTR lpBuffer, INT nBufferMax)
{
    INT cchstr;
    LPWSTR lpwstr;

    if (!hInst || !lpBuffer)
        return 0;

    if ((lpwstr = (LPWSTR)GlobalAllocPtr(GHND, nBufferMax*sizeof(WCHAR))) == NULL)
        return 0;

    // Call wide version
    OurLoadStringW(hInst, uID, lpwstr, nBufferMax/2);
    
    // W to A
    cchstr = WideCharToMultiByte(CP_ACP, 
                              0, 
                              lpwstr, -1,
                              lpBuffer, nBufferMax, 
                              NULL, NULL); 

    if (cchstr)
        cchstr--;    // remove NULL char

    GlobalFreePtr(lpwstr);
    return cchstr;
}


//////////////////////////////////////////////////////////////////
// Function : ExLoadMenuTemplate
// Type     : MENUTEMPLATE *
// Purpose  : 
// Args     : 
//          : LANGID lgid 
//          : HINSTANCE hInstance 
//          : LPCSTR pchTemplate 
// Return   : 
// DATE     : 
//////////////////////////////////////////////////////////////////
static MENUTEMPLATE* ExLoadMenuTemplate(LANGID        lgid,
                                         HINSTANCE    hInstance,
                                         LPCSTR    pchTemplate)
{
    HRSRC  hResMenu;
    HANDLE hMenuTmpl;

    hResMenu = FindResourceEx(hInstance, RT_MENU, pchTemplate, lgid);

    if((hResMenu == NULL) && (lgid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)))
        {
        hResMenu = FindResourceEx(hInstance,
                                 RT_MENU,
                                 pchTemplate,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
        }
        
    if (hResMenu == NULL)
        return NULL; 

    hMenuTmpl = LoadResource( hInstance, hResMenu );
    if(hMenuTmpl == NULL)
        return NULL; /* failed */

    return (MENUTEMPLATE *)LockResource( hMenuTmpl );
}

HMENU WINAPI OurLoadMenu(HINSTANCE hInstance, LPCSTR lpMenuName)
{
    MENUTEMPLATE* pMenuTmpl;
    pMenuTmpl = ExLoadMenuTemplate(GetSystemDefaultLangID(), hInstance, lpMenuName);
    if (pMenuTmpl)
        return LoadMenuIndirect(pMenuTmpl);
    else
        return (HMENU)NULL;
}

DLGTEMPLATE* WINAPI ExLoadDialogTemplate(LANGID lgid, HINSTANCE hInstance, LPCSTR pchTemplate)
{
    HRSRC  hResDlg;
    HANDLE hDlgTmpl;

    hResDlg = FindResourceExA(hInstance, RT_DIALOG, pchTemplate, lgid);

    if ((hResDlg == NULL) && (lgid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)))
        hResDlg = FindResourceExA(hInstance,
                                  RT_DIALOG,
                                  pchTemplate,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

    if (hResDlg == NULL)
        return NULL; 

    hDlgTmpl = LoadResource(hInstance, hResDlg);

    if(hDlgTmpl == NULL)
        return NULL; /* failed */

    return (DLGTEMPLATE *)LockResource(hDlgTmpl);
}

BOOL WINAPI OurGetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
{
    if (IsWinNT())
        return ::GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    else
        return ::GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}

LPSTR GetModuleName(BOOL fFullPath)
{
    static CHAR szFile[MAX_PATH] = {0};

    if (szFile[0] == '\0' )
        GetModuleFileName( NULL, szFile, MAX_PATH );

    if (fFullPath)
        return szFile;

    LPSTR pch = szFile;
    LPSTR pchFilename = NULL;

    while(*pch++) 
        {
        if (*pch == '\\')
            pchFilename = pch + 1;
        }

    return pchFilename;
}

BOOL IsExplorerProcess()
{
    static BOOL fExplorer = FALSE;
    static BOOL fFirst = TRUE;

    if (fFirst == fFalse)
        return fExplorer;

    fFirst = fFalse;

    LPSTR pchFilename = GetModuleName();
    
    if (pchFilename && lstrcmpi(pchFilename, "EXPLORER.EXE") == 0) 
        { // if this process is MSIME9xM.EXE
        fExplorer = fTrue;
        }

    return fExplorer;
}

BOOL IsExplorer()
{
    if (FindWindow("Progman", NULL) != (HWND)0)
        return fTrue;
    else
        return fFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\winex.h ===
/****************************************************************************
	WINEX.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Windows API extension functions
	
	History:
	19-JUL-1999 cslim       Created
*****************************************************************************/

#if !defined (_WINEX_H__INCLUDED_)
#define _WINEX_H__INCLUDED_

// Global variable

// Function declare
PUBLIC BOOL WINAPI IsWinNT();
PUBLIC BOOL WINAPI IsWinNT5orUpper() ;
PUBLIC BOOL WINAPI IsMemphis();
PUBLIC BOOL WINAPI IsWin95();
PUBLIC LPSTR OurGetModuleFileName(BOOL fFullPath);
PUBLIC INT WINAPI OurLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, INT nBufferMax);
PUBLIC INT WINAPI OurLoadStringA(HINSTANCE hInst, INT uID, LPSTR lpBuffer, INT nBufferMax);
PUBLIC HMENU WINAPI OurLoadMenu(HINSTANCE hInstance, LPCSTR lpMenuName);
PUBLIC DLGTEMPLATE* WINAPI ExLoadDialogTemplate(LANGID lgid, HINSTANCE hInstance, LPCSTR pchTemplate);
PUBLIC BOOL WINAPI OurGetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
PUBLIC BOOL IsExplorerProcess();
PUBLIC BOOL IsExplorer();

__inline BOOL IsUnicodeUI(VOID)
{
	return (IsWinNT() || IsMemphis());
}

/*---------------------------------------------------------------------------
	IsHighContrast
---------------------------------------------------------------------------*/
inline
BOOL IsHighContrastBlack()
{
	// high contrast black
	return (GetSysColor(COLOR_3DFACE) == RGB(0,0,0));
}

#endif // _WINEX_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\ntmigexe\hklhelp.h ===
#define MAX_NAME 100

#ifdef __cplusplus
extern "C" {
#endif

HKL  GetHKLfromHKLM(LPSTR argszIMEFile);
HKL  GetDefaultIMEFromHKCU(HKEY hKeyCU);
BOOL HKLHelpExistInPreload(HKEY hKeyCU, HKL hKL);
BOOL HKLHelp412ExistInPreload(HKEY hKeyCU);
void HKLHelpRemoveFromPreload(HKEY hKeyCU, HKL hKL);
void HKLHelpRemoveFromControlSet(HKL hKL);
void HKLHelpRegisterIMEwithForcedHKL(HKL hKL, LPSTR szIMEFile, LPSTR szTitle);
void HKLHelpGetLayoutString(HKL hKL, LPSTR szLayoutString, DWORD *pcbSize);
void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault);
void SetDefaultKeyboardLayoutForDefaultUser(const HKL hKL);
BOOL AddPreload(HKEY hKeyCU, HKL hKL);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\imm32\uisubs.cpp ===
/****************************************************************************
    UISUBS.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    UI subfunctions
    
    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "precomp.h"
#include "ui.h"
#include "imedefs.h"
#include "winex.h"
#include "debug.h"

// For OurLoadImage()
typedef struct tagCOLORRPL 
    {
    COLORREF    cColOrg;
    COLORREF    cColRpl;
    } COLORRPL;

VOID PASCAL DrawBitmap(
    HDC hDC, 
    LONG xStart, 
    LONG yStart, 
    HBITMAP hBitmap)
    {
    HDC     hMemDC;
    HBITMAP hBMOld;
    BITMAP  bm;
    POINT   pt;

    if (hDC == 0 || hBitmap == 0)
        return;
        
    hMemDC = CreateCompatibleDC(hDC);
    hBMOld = (HBITMAP)SelectObject(hMemDC, hBitmap);
    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
    DbgAssert(&bm != NULL);
    pt.x = bm.bmWidth;
    pt.y = bm.bmHeight;
    BitBlt(hDC, xStart, yStart, pt.x, pt.y, hMemDC, 0, 0, SRCCOPY);
    SelectObject(hMemDC, hBMOld);
    DeleteDC(hMemDC);

    return;
    }

HBITMAP WINAPI ReplaceBitmapColor( HBITMAP hBmp, UINT uiColor, COLORRPL* pColOrg )
{
    BITMAP  bmp;
    HBITMAP hBmpNew;
    HDC     hDC, hDCNew, hDCBmp;
    HBITMAP hBmpOld1;
    
    if (GetObject(hBmp, sizeof(BITMAP), &bmp) == 0)
        return 0;

    hBmpNew = CreateBitmap( bmp.bmWidth, bmp.bmHeight, 1, bmp.bmBitsPixel, (VOID*)NULL );

    hDC = GetDC( 0 );
    
    if ((hDCNew = CreateCompatibleDC(hDC)) == 0)
        return 0;
        
    if ((hDCBmp = CreateCompatibleDC(hDC)) == 0)
        {
        DeleteDC(hDCNew);
        return 0;
        }
    
    hBmpOld1 = (HBITMAP)SelectObject(hDCBmp, hBmpNew);

    //
    // Special case : LIGHT GRAY COLOR on WinNT
    //
    COLORRPL* pCol = (COLORRPL*)GlobalAlloc(GPTR, uiColor * sizeof(COLORRPL) );
    INT x = 0;
    INT y = 0;
    UINT iCol = 0;
    COLORREF col = {0};

    for( iCol = 0; iCol < uiColor; iCol++ ) {
        pCol[iCol].cColOrg = SetPixel( hDCBmp, 0, 0, pColOrg[iCol].cColOrg);    // #IMPORTANT# - copy
        pCol[iCol].cColRpl= pColOrg[iCol].cColRpl;    // copy
    }

    // master copy
    HBITMAP hBmpOld  = (HBITMAP)SelectObject(hDCNew, hBmp);
    BitBlt(hDCBmp, 0, 0, bmp.bmWidth, bmp.bmHeight, hDCNew, 0, 0, SRCCOPY); // Fxx
    SelectObject(hDCNew, hBmpOld);
    DeleteObject(hBmp);
    DeleteDC(hDCNew);

    // replace color
    for( y=0; y<bmp.bmHeight; y++ ) {
        for( x=0; x<bmp.bmWidth; x++ ) {
            col = GetPixel( hDCBmp, x, y );
            for( iCol = 0; iCol < uiColor; iCol++ ) {
                if( col == pCol[iCol].cColOrg ) {
                    SetPixel( hDCBmp, x, y, pCol[iCol].cColRpl );
                }
            }
        }
    }

    GlobalFree(pCol);

    SelectObject(hDCBmp, hBmpOld1);

    DeleteDC(hDCBmp);

    ReleaseDC(0, hDC);

    hBmp = hBmpNew;
    return hBmp;
}


HANDLE WINAPI OurLoadImage( LPCTSTR pszName, UINT uiType, INT cx, INT cy, UINT uiLoad)
{
    #define    MAXREPL    3
    HBITMAP hBmp = (HBITMAP)0;

    if (vpInstData->hInst == NULL)
        return NULL;
    
    if (GetSysColor(COLOR_3DFACE) == RGB(0,0,0))
        {
        static COLORRPL colRpl[MAXREPL] = 
            {
            RGB(0,0,0), RGB(255,255,255),
            RGB(192,192,192), RGB(0,0,0),
            RGB(0,0,128), RGB(0,192,192),
            };
        HBITMAP hBmpNew;
        
        uiLoad &= ~LR_LOADMAP3DCOLORS;
        hBmp = (HBITMAP)LoadImage(vpInstData->hInst, pszName, uiType, cx, cy, uiLoad);
        if (hBmp == 0)
            return 0;
        hBmpNew = ReplaceBitmapColor(hBmp, MAXREPL, (COLORRPL*)&colRpl);
        DeleteObject(hBmp);
        hBmp = hBmpNew;
        } 
    else 
        {
        hBmp = (HBITMAP)LoadImage(vpInstData->hInst, pszName, uiType, cx, cy, uiLoad);
        }
        
    return hBmp;
}


BOOL WINAPI OurTextOutW(HDC hDC, INT x, INT y, WCHAR wch)
{
    CHAR szOut[4]; // For one DBCS plus one SBCS NULL + extra one byte
    INT cch;
    
    if (IsWinNT() || IsMemphis())
        return TextOutW( hDC, x, y, &wch, 1);

    // Convert to ANSI
    cch = WideCharToMultiByte(CP_KOREA, 0, 
                        &wch, 1, (LPSTR)szOut, sizeof(szOut), 
                        NULL, NULL );
    DbgAssert(cch == 2);
    return TextOutA(hDC, x, y, szOut, cch);
}

#if 1 // MultiMonitor support
/**********************************************************************/
/* ImeMonitorFromWindow()                                             */
/**********************************************************************/
HMONITOR PASCAL ImeMonitorFromWindow(
    HWND hAppWnd)
{
    if (!g_pfnMonitorFromWindow) { return NULL; }

    return (*g_pfnMonitorFromWindow)(hAppWnd, MONITOR_DEFAULTTONEAREST);
}

/**********************************************************************/
/* ImeMonitorWorkAreaFromWindow()                                     */
/**********************************************************************/
void PASCAL ImeMonitorWorkAreaFromWindow(HWND hAppWnd, RECT* pRect)
{
    HMONITOR hMonitor;
    CIMEData    ImeData;
    RECT        rect;
    
    hMonitor = ImeMonitorFromWindow(hAppWnd);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = ImeData->rcWorkArea;

        (*g_pfnGetMonitorInfo)(hMonitor, &sMonitorInfo);
        *pRect = sMonitorInfo.rcWork;
    } else {
        *pRect = ImeData->rcWorkArea;
    }
}

/**********************************************************************/
/* ImeMonitorFromPoint()                                             */
/**********************************************************************/
HMONITOR PASCAL ImeMonitorFromPoint(
    POINT ptPoint)
{
    if (!g_pfnMonitorFromPoint) { return NULL; }

    return (*g_pfnMonitorFromPoint)(ptPoint, MONITOR_DEFAULTTONEAREST);
}

/**********************************************************************/
/* ImeMonitorWorkAreaFromPoint()                                      */
/**********************************************************************/
void PASCAL ImeMonitorWorkAreaFromPoint(POINT ptPoint, RECT* pRect)
{
    HMONITOR hMonitor;
    CIMEData    ImeData;

    hMonitor = ImeMonitorFromPoint(ptPoint);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = ImeData->rcWorkArea;

        (*g_pfnGetMonitorInfo)(hMonitor, &sMonitorInfo);

        *pRect = sMonitorInfo.rcWork;
    } else {
        *pRect = ImeData->rcWorkArea;
    }
}

/**********************************************************************/
/* ImeMonitorFromRect()                                               */
/**********************************************************************/
HMONITOR PASCAL ImeMonitorFromRect(
    LPRECT lprcRect)
{
    if (!g_pfnMonitorFromRect) { return NULL; }

    return (*g_pfnMonitorFromRect)(lprcRect, MONITOR_DEFAULTTONEAREST);
}

/**********************************************************************/
/* ImeMonitorWorkAreaFromRect()                                       */
/**********************************************************************/
void PASCAL ImeMonitorWorkAreaFromRect(LPRECT lprcRect, RECT* pRect)
{
    HMONITOR hMonitor;
    CIMEData    ImeData;

    hMonitor = ImeMonitorFromRect(lprcRect);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);
        // init a default value to avoid GetMonitorInfo fails
        sMonitorInfo.rcWork = ImeData->rcWorkArea;

        (*g_pfnGetMonitorInfo)(hMonitor, &sMonitorInfo);

        *pRect = sMonitorInfo.rcWork;
    } else {
        *pRect = ImeData->rcWorkArea;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\inc\common.h ===
//
//   Common.h : Common const and defines
//
//   History:
//   14-DEC-2000 CSLim Created

#if !defined (__COMMON_H__INCLUDED_)
#define __COMMON_H__INCLUDED_

// IME6.1 Root reg key location
const TCHAR g_szIMERootKey[] 		 = TEXT("Software\\Microsoft\\IMEKR\\6.1");
const TCHAR g_szIMEDirectoriesKey[]  = TEXT("Software\\Microsoft\\IMEKR\\6.1\\Directories");
const TCHAR g_szDictionary[]  	= TEXT("Dictionary");  // Basic Hanja lex full path with file name "IMEKR.LEX"
const TCHAR g_szDicPath[]  	= TEXT("DictionaryPath"); // Extended lex path
const TCHAR g_szHelpPath[] 	= TEXT("HelpPath");

// IME Properties reg values
const TCHAR g_szXWEnable[]		 	  = TEXT("ISO10646");
const TCHAR g_szIMEKL[]		 		  = TEXT("InputMethod");
const TCHAR g_szCompDel[]		 	  = TEXT("CompDel");
const TCHAR g_szStatusPos[]			  = TEXT("StatusPos");
const TCHAR g_szCandPos[]		 	  = TEXT("CandPos");
const TCHAR g_szStatusButtons[]  	  = TEXT("StatusButtons");
const TCHAR g_szLexFileNameKey[] 	  = TEXT("LexFile");
const TCHAR g_szEnableK1Hanja[]  	  = TEXT("KSC5657");
const TCHAR g_szEnableCandUnicodeTT[] = TEXT("CandUnicodeTT");

// IME Main version key
const TCHAR g_szVersionKey[] 		  = TEXT("Software\\Microsoft\\IMEKR");
const TCHAR g_szVersion[]             = TEXT("version");

#ifdef _DEBUG
#define SZ_TIPSERVERNAME	TEXT("DBGKRCIC")
#define SZ_TIPNAME			L"DBGKRCIC"
#define SZ_TIPDISPNAME		L"Korean Input System (IME 2002) (Debug)"
#define SZ_TIPMODULENAME   L"imekrcic.dll"
#else /* !DEBUG */
#define SZ_TIPSERVERNAME	TEXT("IMEKRCIC")
#define SZ_TIPNAME			L"IMEKRCIC"
#define SZ_TIPDISPNAME		L"Korean Input System (IME 2002)"
#define SZ_TIPMODULENAME   L"imekrcic.dll"
#endif /* !DEBUG */

// Korean TIP CLSID
// {766A2C15-B226-4fd6-B52A-867B3EBF38D2}
DEFINE_GUID(CLSID_KorIMX, 0x766A2C15, 0xB226, 0x4FD6, 0xb5, 0x2a, 0x86, 0x7b, 0x3e, 0xbf, 0x38, 0xd2);

// Korean TIP profile
// {83C18F16-5DD8-4157-A34A-3C5AB2089E11}
DEFINE_GUID(GUID_Profile, 0x83c18f16, 0x5dd8, 0x4157, 0xa3, 0x4a, 0x3c, 0x5a, 0xb2, 0x8, 0x9e, 0x11);


//
// generic COM stuff
//
#define SafeRelease(punk)       \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
    }                           \
}                   

#define SafeReleaseClear(punk)  \
{                               \
    if ((punk) != NULL)         \
    {                           \
        (punk)->Release();      \
        (punk) = NULL;          \
    }                           \
}  

//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

#endif // !defined (__COMMON_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\ntmigexe\private.h ===
//
//  Private.h
//
//  Contents:   Private header for korimx project.
//

#if !defined (__PRIVATE_H__INCLUDED_)
#define __PRIVATE_H__INCLUDED_

#include <windows.h>
#include <windowsx.h>
#include <msi.h>
#include <msiquery.h>

#define fTrue   1
#define fFalse  0

#endif  // __PRIVATE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\setup\custdllm\private.h ===
//
//  Private.h
//
//  Contents:   Private header for korimx project.
//

#if !defined (__PRIVATE_H__INCLUDED_)
#define __PRIVATE_H__INCLUDED_

#include <windows.h>
#include <windowsx.h>
#include <msi.h>
#include <msiquery.h>

#define fTrue   1
#define fFalse  0

#endif  // __PRIVATE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\ntmigexe\hklhelp.cpp ===
#include "private.h"
#include <stdio.h>
#include <stdlib.h>
#include "HKLHelp.h"

extern BOOL WINAPI IsNT();

typedef char KeyNameType[MAX_NAME];

// Forward decls.
static void SortRegKeys(KeyNameType *hKLKeyList, KeyNameType *hKLList, INT Num);
static void RenumberPreload(HKEY hKeyCU);
static void SwitcHKLtoIME61();
static BOOL CALLBACK EnumChildProcForSwitchKL(HWND hWnd, LPARAM lParam);
static BOOL CALLBACK EnumProcForSwitchKL(HWND hWnd, LPARAM lParam);

/*---------------------------------------------------------------------------
	GetHKLfromHKLM
---------------------------------------------------------------------------*/
HKL GetHKLfromHKLM(LPSTR argszIMEFile)
{
    HKL  hklAnswer = 0;
    HKEY hKey, hSubKey;
    DWORD i, cbSubKey, cbIMEFile;
    TCHAR szSubKey[MAX_PATH], szIMEFile[MAX_PATH];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\Keyboard Layouts", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    	{
        for (i=0; ;i++)
        	{
        	cbSubKey = MAX_PATH;
			if (RegEnumKeyEx(hKey, i, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
				break;
        	
            RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey);

            cbIMEFile=MAX_PATH;
            if (RegQueryValueEx(hSubKey,"IME File",NULL,NULL,(LPBYTE)szIMEFile, &cbIMEFile) == ERROR_SUCCESS)
            	{
                if (lstrcmpi(argszIMEFile, szIMEFile) == 0)
                	{
                    RegCloseKey(hSubKey);
                    sscanf(szSubKey, "%08x", &hklAnswer);
                    break;
                	}
            	}
            RegCloseKey(hSubKey);
        	}
        	
        RegCloseKey(hKey);
    	}
    	
    return(hklAnswer);
}

/*---------------------------------------------------------------------------
	GetDefaultIMEFromHKCU
---------------------------------------------------------------------------*/
HKL GetDefaultIMEFromHKCU(HKEY hKeyCU)
{
    HKEY hKey;
    DWORD cbData;
    BYTE Data[MAX_NAME];
    HKL hKL = 0;

    cbData=sizeof(Data);
    
    if (IsNT())
    	{
        RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_READ, &hKey);
        RegQueryValueEx(hKey, "1", 0, NULL, Data, &cbData);
        RegCloseKey(hKey);
    	}
    else
    	{          // Case of non-NT
        RegOpenKeyEx(hKeyCU, "keyboard layout\\preload\\1", 0, KEY_READ, &hKey);
        RegQueryValueEx(hKey, "", 0, NULL, Data, &cbData);
        RegCloseKey(hKey);
    	}

    sscanf((const char *)Data,"%08x",&hKL);
    return(hKL);
}


/*---------------------------------------------------------------------------
	HKLHelpExistInPreload
---------------------------------------------------------------------------*/
BOOL HKLHelpExistInPreload(HKEY hKeyCU, HKL hKL)
{
    HKEY hKey,hSubKey;
    CHAR szKL[20];
    int i,j;
    DWORD cbName,cbData;
    CHAR Name[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;
    BOOL fResult = FALSE;

    wsprintf(szKL,"%08x",hKL);
    if (IsNT())
    	{
		if (RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
			for (j=0; cbName=MAX_NAME, cbData=MAX_NAME, RegEnumValue(hKey, j, Name, &cbName, NULL, NULL, Data, &cbData) != ERROR_NO_MORE_ITEMS; j++)
				{
				if (lstrcmpi((LPCSTR)Data, szKL) == 0)
					{
					fResult = TRUE;
					break;
					}
				}
	        RegCloseKey(hKey);
	        }
    	}
    else
    	{          // Case of non-NT
        if (RegOpenKeyEx(hKeyCU, "keyboard layout\\preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        	{
			for (i=0; cbName=MAX_NAME, RegEnumKeyEx(hKey, i, Name, &cbName, 0, NULL, NULL, &ftLastWriteTime) != ERROR_NO_MORE_ITEMS; i++)
				{
				RegOpenKeyEx(hKey, Name, 0, KEY_ALL_ACCESS, &hSubKey);
				cbData=MAX_NAME;
				RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
				RegCloseKey(hSubKey);
				
				if (lstrcmpi((LPCSTR)Data, szKL) == 0)
					{
					fResult = TRUE;
					break;
					}
				}
        	RegCloseKey(hKey);
			}
    	}

    return(fResult);
}


/*---------------------------------------------------------------------------
	HKLHelp412ExistInPreload
---------------------------------------------------------------------------*/
BOOL HKLHelp412ExistInPreload(HKEY hKeyCU)
{
    HKEY hKey, hSubKey;
    int i ,j;
    DWORD cbName, cbData;
    CHAR szName[MAX_NAME];
    CHAR szData[MAX_NAME];
    HKL  hkl;
    FILETIME ftLastWriteTime;
    BOOL fResult = FALSE;

    if (IsNT())
    	{
		if (RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
			for (j=0; cbName=MAX_NAME, cbData=MAX_NAME, RegEnumValue(hKey, j, szName, &cbName, NULL, NULL, (LPBYTE)szData, &cbData) != ERROR_NO_MORE_ITEMS; j++)
				{
				// See If Korean KL exist. Just compare last LCID part if it's 0x412.
				// IME hkl set 0xE000 on hiword.
				sscanf(szData, "%08x", &hkl);
				if ((HIWORD(hkl) & 0xe000) && LOWORD(hkl) == 0x0412)
					{
					fResult = TRUE;
					break;
					}
				}
	        RegCloseKey(hKey);
	        }
    	}
    else
    	{          // Case of non-NT
        if (RegOpenKeyEx(hKeyCU, "keyboard layout\\preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        	{
			for (i=0; cbName=MAX_NAME, RegEnumKeyEx(hKey, i, szName, &cbName, 0, NULL, NULL, &ftLastWriteTime) != ERROR_NO_MORE_ITEMS; i++)
				{
				RegOpenKeyEx(hKey, szName, 0, KEY_ALL_ACCESS, &hSubKey);
				cbData=MAX_NAME;
				RegQueryValueEx(hSubKey, "", 0, NULL, (LPBYTE)szData, &cbData);
				RegCloseKey(hSubKey);

				sscanf(szData, "%08x", &hkl);
				if ((HIWORD(hkl) & 0xe000) && LOWORD(hkl) == 0x0412)
					{
					fResult = TRUE;
					break;
					}
				}
        	RegCloseKey(hKey);
			}
    	}

    return(fResult);
}

/*---------------------------------------------------------------------------
	HKLHelpRemoveFromPreload
---------------------------------------------------------------------------*/
void HKLHelpRemoveFromPreload(HKEY hKeyCU, HKL hKL)
{
    HKEY hKey,hSubKey;
    char szKL[20];
    int  i, j;
    DWORD cbName,cbData;
    CHAR szName[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;

    wsprintf(szKL, "%08x", hKL);
    
    if (IsNT())
    	{
        if (RegOpenKeyEx(hKeyCU,"Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
	        for (j=0; ; j++)
	        	{
	        	cbName = MAX_NAME;
	        	cbData = MAX_NAME;
	        	if (RegEnumValue(hKey, j, szName, &cbName, NULL, NULL, Data, &cbData) == ERROR_NO_MORE_ITEMS )
	        		break;
	        	
	            if (lstrcmpi((const char *)Data,szKL) == 0)
	            	{
	                RegDeleteValue(hKey, szName);
	                break;
	            	}
	        	}
	        RegCloseKey(hKey);
	        }
    	}
    else
    	{
    	if (RegOpenKeyEx(hKeyCU,"keyboard layout\\preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    		{
	        for (i=0; ; i++)
	        	{
	        	cbName = MAX_NAME;
	        	if (RegEnumKeyEx(hKey, i, szName, &cbName, 0, NULL, NULL, &ftLastWriteTime) == ERROR_NO_MORE_ITEMS)
	        		break;
	        	
	            RegOpenKeyEx(hKey, szName, 0, KEY_ALL_ACCESS, &hSubKey);
	            cbData = MAX_NAME;
	            RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
	            RegCloseKey(hSubKey);
	            
	            if (lstrcmpi((const char *)Data,szKL) == 0)
	            	{
	                RegDeleteKey(hKey, szName);
	                break;
	            	}
	        	}
	        	
	        RegCloseKey(hKey);
	        }
    	}

    RenumberPreload(hKeyCU);
}

/*---------------------------------------------------------------------------
	HKLHelpRemoveFromControlSet
---------------------------------------------------------------------------*/
void HKLHelpRemoveFromControlSet(HKL hKL)
{
    HKEY hKey;
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,"System\\CurrentControlSet\\control\\keyboard layouts",0,KEY_ALL_ACCESS,&hKey) == ERROR_SUCCESS)
    	{
        CHAR szKeyName[10];
        wsprintf(szKeyName, "%08x", hKL);
        RegDeleteKey(hKey, szKeyName);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpRegisterIMEwithForcedHKL
---------------------------------------------------------------------------*/
void HKLHelpRegisterIMEwithForcedHKL(HKL hKL, LPSTR szIMEFile, LPSTR szTitle)
{
    CHAR szRegPath[MAX_PATH];
    DWORD dwDisposition;
    HKEY hKey;
    CHAR szIMEFileUpper[MAX_PATH];
    
    for (INT i = 0; szIMEFile[i] != 0; i++)
        szIMEFileUpper[i] = (CHAR)toupper(szIMEFile[i]);

    szIMEFileUpper[i] = 0;
    
    wsprintf(szRegPath, "System\\CurrentControlSet\\Control\\Keyboard Layouts\\%08x", hKL);
    
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
    	{
        RegSetValueEx(hKey, "Ime File", 0, REG_SZ, (LPBYTE)szIMEFileUpper, lstrlen(szIMEFile)+1);
        RegSetValueEx(hKey, "Layout Text", 0, REG_SZ, (LPBYTE)szTitle, lstrlen(szTitle)+1);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpGetLayoutString
---------------------------------------------------------------------------*/
void HKLHelpGetLayoutString(HKL hKL, LPSTR szLayoutString, DWORD *pcbSize)
{
    CHAR szRegPath[MAX_PATH];
    HKEY hKey;

    wsprintf(szRegPath, "System\\CurrentControlSet\\Control\\Keyboard Layouts\\%08x", hKL);

    if(ERROR_SUCCESS==RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ, &hKey))
    	{
        RegQueryValueEx(hKey, "Layout Text", NULL, NULL, (LPBYTE)szLayoutString, pcbSize);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpSetDefaultKeyboardLayout
---------------------------------------------------------------------------*/
void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault)
{
	char szKL[20];
	BYTE Data[MAX_PATH];
	DWORD cbData;
	char szSubKey[MAX_PATH];
	HKEY hKey,hSubKey;
	DWORD NumKL;

	wsprintf(szKL, "%08x", hKL);

	if (IsNT())
		{
		RegOpenKeyEx(hKeyHKCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
		if (hKey != NULL)
			{
			RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumKL, NULL, NULL, NULL, NULL);
			
			for (DWORD i=0; i<NumKL; i++)
				{
				wsprintf(szSubKey, "%d", i+1);
				cbData = MAX_PATH;
				RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

				if (lstrcmpi((const char *)Data, szKL) == 0)
					break;
				}

			// if hKL is not exist create it.
			if (NumKL == i)
				{
				wsprintf(szSubKey,"%d",i+1);
				RegSetValueEx(hKey, szSubKey, 0, REG_SZ, (const unsigned char *)szKL, lstrlen(szKL)+1);
				NumKL++;
				}

			// Set hKL as first, Shift down other.
	        if(fSetToDefault)
	        	{
				for(int j=i; j>0; j--)
					{
					wsprintf(szSubKey,"%d",j);

					cbData = MAX_PATH;
					RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

					wsprintf(szSubKey,"%d",j+1);
					RegSetValueEx(hKey, szSubKey, 0, REG_SZ, Data, cbData);
					}
				RegSetValueEx(hKey, "1", 0, REG_SZ, (const unsigned char *)szKL, lstrlen(szKL)+1);
				}
			RegCloseKey(hKey);
			}
		}
	else
		{
		RegOpenKeyEx(hKeyHKCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
		if (hKey != NULL)
			{
			RegQueryInfoKey(hKey, NULL, NULL, NULL, &NumKL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			
			for (DWORD i=0; i<NumKL; i++)
				{
				wsprintf(szSubKey, "%d", i+1);
				RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

				cbData = MAX_PATH;
				RegQueryValueEx(hSubKey, "", NULL, NULL, Data, &cbData);

				if (lstrcmpi((const char *)Data, szKL) == 0)
					break;

				RegCloseKey(hSubKey);
				}

			if (NumKL == i)
				{
				wsprintf(szSubKey,"%d",i+1);
				RegCreateKeyEx(hKey,szSubKey,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hSubKey,NULL);
				RegSetValueEx(hSubKey,"",0,REG_SZ,(const unsigned char *)szKL,lstrlen(szKL)+1);
				RegCloseKey(hSubKey);
				NumKL++;
				}

	        if(fSetToDefault)
	        	{
				for (int j=i; j>0; j--)
					{
					wsprintf(szSubKey, "%d", j);
					RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

					cbData = MAX_PATH;
					RegQueryValueEx(hSubKey, "", NULL, NULL, Data, &cbData);
					RegCloseKey(hSubKey);

					wsprintf(szSubKey,"%d",j+1);
					RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

					cbData = MAX_PATH;
					RegSetValueEx(hSubKey, "", 0, REG_SZ, Data, cbData);
					RegCloseKey(hSubKey);
					}
				
				RegOpenKeyEx(hKey, "1", 0, KEY_ALL_ACCESS, &hSubKey);
				RegSetValueEx(hSubKey, "", 0, REG_SZ, (const LPBYTE)szKL, lstrlen(szKL)+1);
				RegCloseKey(hSubKey);
				}
			RegCloseKey(hKey);
			}
	}

	(void)LoadKeyboardLayout(szKL, KLF_ACTIVATE | KLF_SETFORPROCESS);
	// To activate IME2002 right now without reboot.
	if(fSetToDefault)
	    {
		(void)SystemParametersInfo(SPI_SETDEFAULTINPUTLANG, 0, (HKL*)&hKL, SPIF_SENDCHANGE);
		SwitcHKLtoIME61();
	    }
}

/*---------------------------------------------------------------------------
	SetDefaultKeyboardLayout
---------------------------------------------------------------------------*/
void SetDefaultKeyboardLayoutForDefaultUser(const HKL hKL)
{
    char szKL[20];
    HKEY hKey, hSubKey;

    wsprintf(szKL,"%08x",hKL);

    if (!IsNT())
    	{
    	// Win9x has only one preload.
        RegOpenKeyEx(HKEY_USERS, ".Default\\Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
        RegOpenKeyEx(hKey, "1", 0, KEY_ALL_ACCESS, &hSubKey);
        RegSetValueEx(hSubKey, "", 0, REG_SZ, (const LPBYTE)szKL, lstrlen(szKL)+1);
        RegCloseKey(hSubKey);
        RegCloseKey(hKey);
    	}
}


/*---------------------------------------------------------------------------
	AddPreload
	
	Add IME2002 to preload in given HKCU tree. 
	If there's other old MS-IMEs, remove them from preload. 
	If Korean keyboard layout was the default keyboard layout, 
									set IME2002 as default keyboard layout. 

	Given HKCU usually can be HKEY_CURRENT_USER or HKEY_USERS\.Default.
---------------------------------------------------------------------------*/
BOOL AddPreload(HKEY hKeyCU, HKL hKL)
{
	BOOL fKoreanWasDefault = fFalse;
	HKL  hDefaultKL, hKLOldMSIME;

	// If there is no Kor IME exist in preload, we shouldn't add Kor IME.
	if (!HKLHelp412ExistInPreload(hKeyCU))
		return FALSE;

	hDefaultKL = GetDefaultIMEFromHKCU(hKeyCU);
	
	if (LOWORD(hDefaultKL) == 0x0412)
		fKoreanWasDefault = fTrue;

	// Win95 IME
	hKLOldMSIME = GetHKLfromHKLM("msime95.ime");
	if (hKLOldMSIME)
		{
		HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
		RegFlushKey(hKeyCU);
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	// NT4 IME
	hKLOldMSIME = GetHKLfromHKLM("msime95k.ime");
	if(NULL != hKLOldMSIME)
		{
		HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
		RegFlushKey(hKeyCU);
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	// Win98, ME, NT4 SP6 & W2K IME
	hKLOldMSIME = GetHKLfromHKLM("imekr98u.ime");
	if(NULL != hKLOldMSIME)
		{
		HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
		RegFlushKey(hKeyCU);
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	// Office 10 IME(6.0)
	hKLOldMSIME = GetHKLfromHKLM("imekr.ime");
	if(NULL != hKLOldMSIME)
		{
		HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
		RegFlushKey(hKeyCU);
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	if (hKL && hKL != hDefaultKL)
		HKLHelpSetDefaultKeyboardLayout(hKeyCU, hKL, fKoreanWasDefault);

	return (fKoreanWasDefault);
}

//////////////////////////////////////////////////////////////////////////////
// Private functions
void SortRegKeys(KeyNameType *hKLKeyList, KeyNameType *hKLList, INT Num)
{
    KeyNameType hKeyTmp;
    INT PhaseCur, PhaseEnd;

    for (PhaseEnd=0; PhaseEnd < Num-1; PhaseEnd++)
    	{
        for (PhaseCur = Num-1; PhaseCur > PhaseEnd; PhaseCur--)
        	{
            if(atoi(hKLKeyList[PhaseCur]) < atoi(hKLKeyList[PhaseCur-1]))
            	{
                lstrcpy(hKeyTmp, hKLKeyList[PhaseCur-1]);
                lstrcpy(hKLKeyList[PhaseCur-1], hKLKeyList[PhaseCur]);
                lstrcpy(hKLKeyList[PhaseCur], hKeyTmp);
                lstrcpy(hKeyTmp, hKLList[PhaseCur-1]);
                lstrcpy(hKLList[PhaseCur-1], hKLList[PhaseCur]);
                lstrcpy(hKLList[PhaseCur], hKeyTmp);
            	}
        	}
    	}
}

void RenumberPreload(HKEY hKeyCU)
{
    int i, j, k;
    DWORD cbName,cbData;
    char Name[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;
    HKEY hKey,hSubKey;
    char szNum[10];
    DWORD dwDisposition,MaxValue;
    KeyNameType *hKLKeyList,*hKLList;

    if(IsNT())
    	{
        RegOpenKeyEx(hKeyCU,"keyboard layout\\preload",0,KEY_ALL_ACCESS,&hKey);

        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &MaxValue, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
        	{
            RegCloseKey(hKey);
            return;
        	}

        hKLKeyList = (KeyNameType *)GlobalAllocPtr(GHND, sizeof(KeyNameType)*MaxValue);
        if (hKLKeyList == NULL)
        	return;
        hKLList = (KeyNameType *)GlobalAllocPtr(GHND, sizeof(KeyNameType)*MaxValue);
        if (hKLList == NULL)
        	{
        	GlobalFreePtr(hKLKeyList);
            return;
        	}

        for (j=0; ;j++)
        	{
        	cbName = MAX_NAME;
        	cbData = MAX_NAME;
        	if (RegEnumValue(hKey, j, Name, &cbName, NULL, NULL, Data, &cbData) == ERROR_NO_MORE_ITEMS)
        		break;
        	
            lstrcpy(hKLList[j], (const char *)Data);
            lstrcpy(hKLKeyList[j], Name);
        	}
        	
        for (k=0; k<j; k++)
            RegDeleteValue(hKey, hKLKeyList[k]);
        	
        SortRegKeys(hKLKeyList, hKLList, j);

        for (k=0; k<j; k++)
        	{
            wsprintf(szNum,"%d",k+1);
            RegSetValueEx(hKey, szNum, 0, REG_SZ, (const unsigned char *)hKLList[k], lstrlen(hKLList[k])+1);
        	}

        RegCloseKey(hKey);
        GlobalFreePtr(hKLList);
        GlobalFreePtr(hKLKeyList);
    	}
    else
    	{
        RegOpenKeyEx(hKeyCU,"keyboard layout\\preload",0,KEY_ALL_ACCESS,&hKey);

        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, &MaxValue, NULL, NULL,NULL,NULL,NULL,NULL,NULL) != ERROR_SUCCESS)
        	{
            RegCloseKey(hKey);
            return;
        	}

        hKLKeyList = (KeyNameType *)GlobalAllocPtr(GHND,sizeof(KeyNameType)*MaxValue);
        hKLList = (KeyNameType *)GlobalAllocPtr(GHND,sizeof(KeyNameType)*MaxValue);

        if (hKLKeyList == NULL || hKLList == NULL)
            return;

        for (i=0; ;i++)
        	{
        	cbName = MAX_NAME;
        	if (RegEnumKeyEx(hKey, i, Name, &cbName, 0, NULL, NULL, &ftLastWriteTime) == ERROR_NO_MORE_ITEMS)
        		break;
        	
            RegOpenKeyEx(hKey, Name, 0, KEY_ALL_ACCESS, &hSubKey);
            
            cbData = MAX_NAME;
            RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
            RegCloseKey(hSubKey);

            lstrcpy(hKLList[i], (const char *)Data);
            lstrcpy(hKLKeyList[i], Name);
        	}
        
        for(k=0; k<i; k++)
	        RegDeleteKey(hKey, hKLKeyList[k]);
    
        SortRegKeys(hKLKeyList, hKLList, i);

        for(k=0; k<i; k++)
        	{
            wsprintf(szNum,"%d",k+1);
            RegCreateKeyEx(hKey, szNum, 0, "",REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisposition);
            RegSetValueEx(hSubKey, "", 0, REG_SZ, (const unsigned char *)hKLList[k], lstrlen(hKLList[k])+1);
            RegCloseKey(hSubKey);
        	}
        	
        RegCloseKey(hKey);
        GlobalFreePtr(hKLList);
        GlobalFreePtr(hKLKeyList);
    }
}

BOOL CALLBACK EnumChildProcForSwitchKL(HWND hWnd, LPARAM lParam)
{
    if (TRUE/*IsWindowVisible( hWnd )*/)
        {
        HKL hKL = (HKL)lParam;
        PostMessage(hWnd, WM_INPUTLANGCHANGEREQUEST, 1/*INPUTLANGCHANGE_SYSCHARSET*/, (LPARAM)hKL);   // change kl to IME8.1
        }
    return TRUE;
}

BOOL CALLBACK EnumProcForSwitchKL(HWND hWnd, LPARAM lParam)
{
    if (TRUE/*IsWindowVisible( hWnd )*/)
        {
        HKL hKL = (HKL)lParam;
        PostMessage(hWnd, WM_INPUTLANGCHANGEREQUEST, 1/*INPUTLANGCHANGE_SYSCHARSET*/, (LPARAM)hKL);

        // try child windows
        EnumChildWindows(hWnd, EnumChildProcForSwitchKL, lParam);
        }
    return TRUE;
}


void SwitcHKLtoIME61()
{
    HKL hKL = NULL;
    HWND hWnd = NULL;
    
    //
    // switch hKL to IME6.1
    //
    hKL = GetHKLfromHKLM(TEXT("imekr61.ime"));   // find IME6.1 kl

    if (hKL != NULL)
        {
        //
        // desktop (special)
        //
        hWnd = FindWindow("Progman", NULL);       // find desktop window

        if (hWnd!= NULL)
            PostMessage(hWnd, WM_INPUTLANGCHANGEREQUEST, 1/*INPUTLANGCHANGE_SYSCHARSET*/, (LPARAM)hKL);

        //
        // generic enum
        //
        EnumWindows(EnumProcForSwitchKL, (LPARAM)hKL);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\ntmigexe\winmain.cpp ===
/****************************************************************************
   WINMAIN.CPP : Per-user migration and reg install

   History:
      22-SEP-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include <shlobj.h>
#include "hklhelp.h"
#include "msctf.h"

#include <initguid.h>
#include "common.h"

// Current Major version. Whistler has IME 6.1
#define MAJORVER "6.1"

// IME 6.1 main module
#define SZMODULENAME_MAIN              "imekr61.ime"
#define IME_REGISTRY_MIGRATION          "IMEKRMIG6.1"
extern BOOL WINAPI IsNT();

// Private functions
static void MigrateUserData(HKEY hKeyCurrentUser);
static void WriteHKCUData(HKEY hKeyCurrentUser);
static BOOL IsNewerAppsIMEExist();
static VOID EnableTIPByDefault(GUID clsidTIP, GUID guidProfile, BOOL fEnable);
static VOID EnableTIP(GUID clsidTIP, GUID guidProfile, BOOL fEnable);
static VOID DisableTIP61();
static VOID DisableTIP60();
static PSID KYGetCurrentSID();
static BOOL GetTextualSid(PSID pSid, LPSTR TextualSid, LPDWORD dwBufferLen);
static void GetSIDString(LPSTR tszBuffer, SIZE_T cbBuffLen);
static POSVERSIONINFO GetVersionInfo();
static void CheckForDeleteRunReg();
static DWORD OpenUserKeyForWin9xUpgrade(LPSTR pszUserKeyA, HKEY *phKey);
static void RestoreMajorVersionRegistry();

    
/*---------------------------------------------------------------------------
    WinMain
---------------------------------------------------------------------------*/
INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
    HKEY  hKeyCurrentUser = NULL, hKey = NULL;
    TCHAR szMigrateUserKey[MAX_PATH];
    TCHAR szBuffer[500];
    HKL   hKL;
    BOOL  fMigrationAlreadyDone = FALSE;
    BOOL  fWin9xMig = FALSE;

    if (lpCmdLine)
        {
        LPSTR sz_Arg1 = NULL;
		LPSTR sz_Arg2 = NULL;

		sz_Arg1 = strtok(lpCmdLine, " \t");
		sz_Arg2 = strtok(NULL, " \t");
		if (lstrcmpi(sz_Arg1, "Win9xMig") == 0)
		    {
		    OpenUserKeyForWin9xUpgrade(sz_Arg2, &hKeyCurrentUser);
    		if (hKeyCurrentUser != NULL)
	    	    fWin9xMig = TRUE;
		    }
        }

    if (hKeyCurrentUser == NULL)
        hKeyCurrentUser = HKEY_CURRENT_USER;
    
    lstrcpy(szMigrateUserKey, g_szIMERootKey);
    lstrcat(szMigrateUserKey, "\\MigrateUser");

    // Check Migrated flag
    if (RegOpenKeyEx(hKeyCurrentUser, g_szIMERootKey, 0, KEY_ALL_ACCESS, &hKey)== ERROR_SUCCESS )
        {
        if (RegQueryValueEx(hKey, "Migrated", NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            fMigrationAlreadyDone = TRUE;
        else
            fMigrationAlreadyDone = FALSE;

        RegCloseKey(hKey);
    }
    
    // if sid exists under HKLM\Software\Microsoft\IMEKR\6.1\MigrateUser migrate and delete sid from reg
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMigrateUserKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        GetSIDString(szBuffer, sizeof(szBuffer)); // get the sid of the current user

        if (RegQueryValueEx(hKey, szBuffer, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
            HKEY  hKeyRW;
            // Get R/W access again.
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMigrateUserKey, 0, KEY_ALL_ACCESS, &hKeyRW) == ERROR_SUCCESS)
                {
                BYTE pSD[1000];
                // Delete current user's sid
                RegDeleteValue(hKeyRW, szBuffer);
                // !!! WORKAROUND !!!
                // Change MigrateUser List security settings. Only administrator will succeed this.
                InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
                SetSecurityDescriptorDacl(pSD, FALSE, NULL, FALSE);
                RegSetKeySecurity(hKeyRW, DACL_SECURITY_INFORMATION, pSD);       
                // !!! End of WORKAROUND CODE !!!
                RegCloseKey(hKeyRW);
                }
            }
        else
            fMigrationAlreadyDone = TRUE;
        RegCloseKey(hKey);
        }

    // If no more user list for migration, delete run reg.
    if (!fWin9xMig)
        CheckForDeleteRunReg();

    // in, Lab06 2643 build Profilelist NULL when IMKRINST.EXE run.
    //if (fMigrationAlreadyDone)
    //    return (0);

    if (!IsNewerAppsIMEExist())
        {
        if (!fMigrationAlreadyDone || fWin9xMig)
            {
            // 1. Do migrate
            MigrateUserData(hKeyCurrentUser);

            // 2. Write any HKCU data
            WriteHKCUData(hKeyCurrentUser);

            // 3. Clean up HKCU preload reg. (Remove old IME)
            hKL = GetHKLfromHKLM(SZMODULENAME_MAIN);
            if (hKL && HKLHelp412ExistInPreload(hKeyCurrentUser))
                {
                AddPreload(hKeyCurrentUser, hKL);
                // Enable TIP
                EnableTIP(CLSID_KorIMX, GUID_Profile, fTrue);
                }

            // Set migrated reg
            if (RegOpenKeyEx(hKeyCurrentUser, g_szIMERootKey, 0, KEY_ALL_ACCESS, &hKey)== ERROR_SUCCESS )
                {
                DWORD dwMigrated = 1;
                RegSetValueEx(hKey, "Migrated", 0, REG_DWORD, (BYTE *)&dwMigrated, sizeof(DWORD));
                RegCloseKey(hKey);
                }
            }
        
        // !!! WORKAROUND CODE !!!
        // Check if IME HKL exist in HKU\.Default, then enable the TIP by default.
        // In US Whistler, IME HKL added to "HKU\.Default\KeyboarLayout\Preload" after IMKRINST.EXE run
        // But IMKRINST disable KOR TIP if there is no Kor IME in the preload.
        // So this code reenable the default setting. Only work when admin right user first logon.
        if (RegOpenKeyEx(HKEY_USERS, TEXT(".DEFAULT"), 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
            {
            if (HKLHelp412ExistInPreload(hKey))
                EnableTIPByDefault(CLSID_KorIMX, GUID_Profile, fTrue);
            RegCloseKey(hKey);
            }
        // !!! End of WORKAROUND CODE !!!
    
        // If IME 6.0 TIP(Office 10 IME) exist in system, Disable it.
        DisableTIP60();
        }
    else
        {
        // Remove IME 6.1 from Preload
        hKL = GetHKLfromHKLM(SZMODULENAME_MAIN);
        HKLHelpRemoveFromPreload(hKeyCurrentUser, hKL);
        DisableTIP61();
        }

    if (hKeyCurrentUser != HKEY_CURRENT_USER)
        RegCloseKey(hKeyCurrentUser);

    return(0);
}


//////////////////////////////////////////////////////////////////////////////
// Private functions
//////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    MigrateUserData

    This function migrate BeolSik and K1 Hanja setting
    Search IME98, Win95 IME, NT4 IME and AIME reg.
---------------------------------------------------------------------------*/
void MigrateUserData(HKEY hKeyCurrentUser)
{
    const INT iMaxIMERegKeys = 5;
    static LPSTR rgszOldIMERegKeys[iMaxIMERegKeys] = 
            {
            // IME 2002(6.0)
            "Software\\Microsoft\\IMEKR\\6.0",
            // IME98
            "Software\\Microsoft\\Windows\\CurrentVersion\\IME\\Korea\\IMEKR98U",
            // Win95 IME
            "Software\\Microsoft\\Windows\\CurrentVersion\\MSIME95",
            // Kor NT4 IME
            "Software\\Microsoft\\Windows\\CurrentVersion\\MSIME95K",
            // Korean AIME
            "Software\\Microsoft\\Windows\\CurrentVersion\\Wansung"
            };

    // Beolsik value
    static CHAR szBeolsik[]    = "InputMethod";
    // K1 Hanja enable(IME98 only)
    static CHAR szEnableK1Hanja[] = "KSC5657";

    HKEY    hKey;
    DWORD    dwCb, dwIMEKL, dwKSC5657;

    // Set default values
    dwIMEKL = dwKSC5657 = 0;

    for (INT i=0; i<iMaxIMERegKeys; i++)
        {
        if (RegOpenKeyEx(hKeyCurrentUser, rgszOldIMERegKeys[i], 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
            {
            ///////////////////////////////////////////////////////////////////
            // Get Beolsik
            dwCb = sizeof(dwIMEKL);
            if (RegQueryValueEx(hKey, szBeolsik, NULL, NULL, (LPBYTE)&dwIMEKL, &dwCb) != ERROR_SUCCESS) 
                {
                dwIMEKL = 0;
                }

            ///////////////////////////////////////////////////////////////////
            // Get K1 Hanja Setting
            dwCb = sizeof(dwKSC5657);
            if (RegQueryValueEx(hKey, szEnableK1Hanja, NULL, NULL, (LPBYTE)&dwKSC5657, &dwCb) != ERROR_SUCCESS) 
                {
                dwKSC5657 = 0;
                }

            RegCloseKey(hKey);
            // Break for loop
            break;
            }
        }

    // Set values to IME2002 reg
    if (RegCreateKey(hKeyCurrentUser, g_szIMERootKey, &hKey) == ERROR_SUCCESS) 
        {
        // 1. BeolSik
        dwCb = sizeof(dwIMEKL);
        if (dwIMEKL >= 100 && dwIMEKL <= 102)
            dwIMEKL -= 100;
        else
        if (dwIMEKL > 2) // Only accept 0, 1, 2
            dwIMEKL = 0;
        RegSetValueEx(hKey, szBeolsik, 0, REG_DWORD, (LPBYTE)&dwIMEKL, dwCb);

        // K1 Hanja flag
        if (dwKSC5657 != 0 && dwKSC5657 != 1) // Only accept 0 or 1
            dwKSC5657 = 0;
        RegSetValueEx(hKey, szEnableK1Hanja, 0, REG_DWORD, (LPBYTE)&dwKSC5657, dwCb);

        RegCloseKey(hKey);
        }
}

/*---------------------------------------------------------------------------
    WriteHKCUData
---------------------------------------------------------------------------*/
void WriteHKCUData(HKEY hKeyCurrentUser)
{
    HKEY hKey;
    
    // Set default Tip as for Cicero.
    CoInitialize(NULL);

    ITfInputProcessorProfiles *pProfile;
    HRESULT hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (SUCCEEDED(hr)) 
        {
        pProfile->SetDefaultLanguageProfile(MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), 
                                            CLSID_KorIMX, GUID_Profile);
        pProfile->Release();
        }

    CoUninitialize();

    // Reset Show Status
    if (RegOpenKeyEx(hKeyCurrentUser, "Control Panel\\Input Method", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        LPSTR szStatus = "1";
        
           RegSetValueEx(hKey, "Show Status", 0, REG_SZ, (BYTE *)szStatus, (sizeof(CHAR)*lstrlen(szStatus)));
        RegCloseKey(hKey);
        }
}
    
/*---------------------------------------------------------------------------
    IsNewerAppsIMEExist
---------------------------------------------------------------------------*/
BOOL IsNewerAppsIMEExist()
{
    HKEY  hKey;
    float flInstalledVersion, flVersion;
    CHAR  szVersion[MAX_PATH];
    DWORD cbVersion = MAX_PATH;
    BOOL  fNewer = FALSE;

    RestoreMajorVersionRegistry();
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        if (RegQueryValueEx(hKey, "version", NULL, NULL, (BYTE *)szVersion, &cbVersion) == ERROR_SUCCESS)
            {
            flInstalledVersion = (float)atof(szVersion);
            flVersion = (float)atof(MAJORVER);
            
            if (flVersion < flInstalledVersion)
                fNewer = TRUE;
            }
        RegCloseKey(hKey);
        }
    
    return fNewer;
}

/*---------------------------------------------------------------------------
    DisableTIP60ByDefault
---------------------------------------------------------------------------*/
VOID EnableTIPByDefault(GUID clsidTIP, GUID guidProfile, BOOL fEnable)
{
    // Set default Tip as for Cicero.
    CoInitialize(NULL);

    ITfInputProcessorProfiles *pProfile;
    HRESULT hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (SUCCEEDED(hr)) 
        {
        pProfile->EnableLanguageProfileByDefault(clsidTIP, 
                                        MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), guidProfile, fEnable);
                                        
        pProfile->Release();
        }

    CoUninitialize();
}

/*---------------------------------------------------------------------------
    EnableTip
---------------------------------------------------------------------------*/
VOID EnableTIP(GUID clsidTIP, GUID guidProfile, BOOL fEnable)
{
    // Set default Tip as for Cicero.
    CoInitialize(NULL);

    ITfInputProcessorProfiles *pProfile;
    HRESULT hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (SUCCEEDED(hr)) 
        {
        BOOL fCurEnabled = FALSE;
        pProfile->IsEnabledLanguageProfile(clsidTIP, 
                                        MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), guidProfile, &fCurEnabled);
        if (fCurEnabled != fEnable)
            pProfile->EnableLanguageProfile(clsidTIP, 
                                        MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), guidProfile, fEnable);
                                        
        pProfile->Release();
        }

    CoUninitialize();
}

/*---------------------------------------------------------------------------
    DisableTip61
---------------------------------------------------------------------------*/
VOID DisableTIP61()
{
    // Disable from HKLM
    EnableTIPByDefault(CLSID_KorIMX, GUID_Profile, fFalse);   // Actually mig exe was not registered by IMKRINST.EXE if newer apps IME exist.
    // Dsiable from HKCU to make sure
    EnableTIP(CLSID_KorIMX, GUID_Profile, fFalse);
}

/*---------------------------------------------------------------------------
    DisableTip60
---------------------------------------------------------------------------*/
VOID DisableTIP60()
{
    // KorIMX CLSID
    // {766A2C14-B226-4fd6-B52A-867B3EBF38D2}
    const static CLSID CLSID_KorTIP60  =  
    {
        0x766A2C14,
        0xB226,
        0x4FD6,
        {0xb5, 0x2a, 0x86, 0x7b, 0x3e, 0xbf, 0x38, 0xd2}
      };

      const static GUID g_guidProfile60 = 
    // {E47ABB1E-46AC-45f3-8A89-34F9D706DA83}
    {    0xe47abb1e,
        0x46ac,
        0x45f3,
        {0x8a, 0x89, 0x34, 0xf9, 0xd7, 0x6, 0xda, 0x83}
    };
    // Disable from HKLM
    EnableTIPByDefault(CLSID_KorTIP60, g_guidProfile60, fFalse);  // Actually already done by IMKRINST.EXE
    // Dsiable from HKCU to make sure
    EnableTIP(CLSID_KorTIP60, g_guidProfile60, fFalse);
}

/*---------------------------------------------------------------------------
    GetTextualSid
---------------------------------------------------------------------------*/
BOOL GetTextualSid(PSID pSid, LPSTR TextualSid, LPDWORD dwBufferLen)
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;

    if (!IsValidSid(pSid)) 
        return FALSE;

    // SidIdentifierAuthority ???
    psia=GetSidIdentifierAuthority(pSid);

    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    if (*dwBufferLen < dwSidSize)
        {
        *dwBufferLen = dwSidSize;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
        }

    // S-SID_REVISION
    dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

    // SidIdentifierAuthority
    if ((psia->Value[0] != 0) || (psia->Value[1] != 0))
        {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                        TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                        (USHORT)psia->Value[0],
                        (USHORT)psia->Value[1],
                        (USHORT)psia->Value[2],
                        (USHORT)psia->Value[3],
                        (USHORT)psia->Value[4],
                        (USHORT)psia->Value[5]);
        }
    else
        {
        dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                        TEXT("%lu"),
                        (ULONG)(psia->Value[5]      )   +
                        (ULONG)(psia->Value[4] <<  8)   +
                        (ULONG)(psia->Value[3] << 16)   +
                        (ULONG)(psia->Value[2] << 24)   );
        }

    // SidSubAuthorities
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
        {
        dwSidSize += wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                            *GetSidSubAuthority(pSid, dwCounter) );
        }

    return fTrue;
}


/*---------------------------------------------------------------------------
    KYGetCurrentSID
---------------------------------------------------------------------------*/
PSID KYGetCurrentSID()
{
    HANDLE hToken = NULL;
    BOOL bSuccess;
    #define MY_BUFSIZE 512  // highly unlikely to exceed 512 bytes
    static UCHAR InfoBuffer[MY_BUFSIZE];
    DWORD cbInfoBuffer = MY_BUFSIZE;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) 
            return(NULL);
    
    bSuccess = GetTokenInformation(
                        hToken,
                        TokenUser,
                        InfoBuffer,
                        cbInfoBuffer,
                        &cbInfoBuffer
                        );

    if (!bSuccess)
        {
        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
            //
            // alloc buffer and try GetTokenInformation() again
            //

            CloseHandle(hToken);
            return(NULL);
            }
        else
            {
            //
            // error getting token info
            //

            CloseHandle(hToken);
            return(NULL);
            }
        }

    CloseHandle(hToken);

    return(((PTOKEN_USER)InfoBuffer)->User.Sid);
}


/*---------------------------------------------------------------------------
    GetSIDString
---------------------------------------------------------------------------*/
void GetSIDString(LPSTR tszBuffer, SIZE_T cbBuffLen)
{
    DWORD cbBuffer = (DWORD)cbBuffLen;
    
    if (!GetTextualSid(KYGetCurrentSID(), tszBuffer, &cbBuffer))
        tszBuffer[0] = 0;
}

/*---------------------------------------------------------------------------
    GetVersionInfo
---------------------------------------------------------------------------*/
POSVERSIONINFO GetVersionInfo()
{
    static BOOL fFirstCall = fTrue;
    static OSVERSIONINFO os;

    if (fFirstCall)
        {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&os))
            fFirstCall = fFalse;
        }

    return &os;
}

/*---------------------------------------------------------------------------
    IsNT
---------------------------------------------------------------------------*/
BOOL WINAPI IsNT()
{ 
    BOOL fResult;
    fResult = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT);

    return fResult;
}

/*---------------------------------------------------------------------------
    CheckForDeleteRunReg
---------------------------------------------------------------------------*/
void CheckForDeleteRunReg()
{
    HKEY   hKey, hRunKey;
    TCHAR  szValueName[MAX_PATH];
    TCHAR  szMigUserKey[MAX_PATH];
    DWORD cbValueName   = MAX_PATH;
    BOOL   fRemoveRunKey = FALSE;

    lstrcpy(szMigUserKey, g_szIMERootKey);
    lstrcat(szMigUserKey, TEXT("\\MigrateUser"));
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMigUserKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        if (RegEnumValue(hKey, 0, szValueName, &cbValueName, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
            fRemoveRunKey = TRUE;
        
        RegCloseKey(hKey);
        }
    else
        fRemoveRunKey = TRUE;


    if (fRemoveRunKey && 
        (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_ALL_ACCESS, &hRunKey)) == ERROR_SUCCESS)
        {
        RegDeleteValue(hRunKey, IME_REGISTRY_MIGRATION);
        RegCloseKey(hRunKey);
        }
}

//
// On upgrades from Win9x we are passed a string value representing the 
// key under which we'll find the user's Control Panel\Appearance subkey.
// The string is in the form "HKCU\$$$".  We first translate the root key
// descriptor into a true root key then pass that root and the "$$$" 
// part onto RegOpenKeyEx.  This function takes that string and opens
// the associated hive key.
//
DWORD OpenUserKeyForWin9xUpgrade(LPSTR pszUserKeyA, HKEY *phKey)
{
    DWORD dwResult = ERROR_INVALID_PARAMETER;

    if (NULL != pszUserKeyA && NULL != phKey)
    {
        typedef struct {
            char *pszRootA;
            HKEY hKeyRoot;

        } REGISTRY_ROOTS, *PREGISTRY_ROOTS;

        static REGISTRY_ROOTS rgRoots[] = {
            { "HKLM",                 HKEY_LOCAL_MACHINE   },
            { "HKEY_LOCAL_MACHINE",   HKEY_LOCAL_MACHINE   },
            { "HKCC",                 HKEY_CURRENT_CONFIG  },
            { "HKEY_CURRENT_CONFIG",  HKEY_CURRENT_CONFIG  },
            { "HKU",                  HKEY_USERS           },
            { "HKEY_USERS",           HKEY_USERS           },
            { "HKCU",                 HKEY_CURRENT_USER    },
            { "HKEY_CURRENT_USER",    HKEY_CURRENT_USER    },
            { "HKCR",                 HKEY_CLASSES_ROOT    },
            { "HKEY_CLASSES_ROOT",    HKEY_CLASSES_ROOT    }
          };

        char szUserKeyA[MAX_PATH];      // For a local copy.
        LPSTR pszSubKeyA = szUserKeyA;

        //
        // Make a local copy that we can modify.
        //
        lstrcpynA(szUserKeyA, pszUserKeyA, ARRAYSIZE(szUserKeyA));

        *phKey = NULL;
        //
        // Find the backslash.
        //
        while(*pszSubKeyA && '\\' != *pszSubKeyA)
            pszSubKeyA++;

        if ('\\' == *pszSubKeyA)
        {
            HKEY hkeyRoot = NULL;
            int i;
            //
            // Replace backslash with nul to separate the root key and
            // sub key strings in our local copy of the original argument 
            // string.
            //
            *pszSubKeyA++ = '\0';
            //
            // Now find the true root key in rgRoots[].
            //
            for (i = 0; i < ARRAYSIZE(rgRoots); i++)
            {
                if (0 == lstrcmpiA(rgRoots[i].pszRootA, szUserKeyA))
                {
                    hkeyRoot = rgRoots[i].hKeyRoot;
                    break;
                }
            }
            if (NULL != hkeyRoot)
            {
                //
                // Open the key.
                //
                dwResult = RegOpenKeyExA(hkeyRoot,
                                         pszSubKeyA,
                                         0,
                                         KEY_ALL_ACCESS,
                                         phKey);
            }
        }
    }
    return dwResult;
}

/*---------------------------------------------------------------------------
    RestoreMajorVersionRegistry

    Restore IME major version reg value. 
    It could be overwritten during Win9x to NT upgrade.
---------------------------------------------------------------------------*/
void RestoreMajorVersionRegistry()
{
    HKEY  hKey;
    
    ///////////////////////////////////////////////////////////////////////////
    // Restore IME major version reg value. 
    // It could be overwritten during Win9x to NT upgrading.
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szVersionKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        CHAR  szVersion[MAX_PATH];
        DWORD cbVersion = MAX_PATH;
    	CHAR szMaxVesrion[MAX_PATH];
		FILETIME time;
		float flVersion, flMaxVersion;

        lstrcpy(szMaxVesrion, "0");
 		for (int i=0; cbVersion = MAX_PATH, RegEnumKeyEx(hKey, i, szVersion, &cbVersion, NULL, NULL, NULL, &time) != ERROR_NO_MORE_ITEMS; i++)
            {
            if (lstrcmp(szVersion, szMaxVesrion) > 0)
                lstrcpy(szMaxVesrion, szVersion);
            }

        lstrcpy(szVersion, "0");
        RegQueryValueEx(hKey, g_szVersion, NULL, NULL, (BYTE *)szVersion, &cbVersion);
        flVersion = (float)atof(szVersion);
        flMaxVersion = (float)atof(szMaxVesrion);

        if (flVersion < flMaxVersion)
            RegSetValueEx(hKey, g_szVersion, 0, REG_SZ, (BYTE *)szMaxVesrion, (sizeof(CHAR)*lstrlen(szMaxVesrion)));

        RegCloseKey(hKey);
	}
    ///////////////////////////////////////////////////////////////////////////
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\setup\custdllm\dllmain.cpp ===
#include "private.h"
#include <stdio.h>
#include <stdlib.h>
#include "hklhelp.h"

// Forward decl.
POSVERSIONINFO GetVersionInfo();
BOOL WINAPI IsMemphisOrME();
BOOL WINAPI IsWin95();
BOOL WINAPI IsNT();
BOOL WINAPI IsNT4();
BOOL WINAPI IsNT5orUpper();
BOOL IsHydra();
#if 0
BOOL SetRegKeyAccessRight(HKEY hKey);
#endif
PSID MyCreateSid(DWORD dwSubAuthority);
VOID FreeSecurityAttributes(PSECURITY_ATTRIBUTES psa);

// IME 2002 main module
#define SZMODULENAME_MAIN		"imekr.ime"

// IME Main HKLM Reg
#define SZIMEREG_MAIN_ROOT   	"Software\\Microsoft\\IMEKR\\6.0"
#define SZIMEREG_MAIN_ROOT_MIG 	SZIMEREG_MAIN_ROOT"\\MigrateUser"


// Kor TIP profile reg
#define SZTIPREG_LANGPROFILE 	"SOFTWARE\\Microsoft\\CTF\\TIP\\{766A2C14-B226-4fd6-B52A-867B3EBF38D2}\\LanguageProfile\\0x00000412"

#define MAJORVER "6.0"
#define IME_REGISTRY_LATEST_VERSION  "Software\\Microsoft\\IMEKR"  //The latest version of IME installed in the system 
								   	//will always be stored at HKLM\Software\Microsoft\IMEKR
								    //even if it's system IME. 

// Preperty names
#define PROPERTYNAME_QueryPreInstallStatus 	"QueryPreInstallStatus.CC794FB4_4D43_40AA_A417_4A8D938D3D69"
#define PROPERTYNAME_CheckOnlyOneIME 		"CheckOnlyOneIME.CC794FB4_4D43_40AA_A417_4A8D938D3D69"
#define PROPERTYNAME_RemoveFromPreload 		"CustomActionData"
#define PROPERTYNAME_ImmUninstallIME		"CustomActionData"
#define PROPERTYNAME_RBImmInstallIME		"CustomActionData"
#define PROPERTYNAME_RBSetDefaultIME		"CustomActionData"
#define PROPERTYNAME_ImmInstallIME			"CustomActionData"
#define PROPERTYNAME_SetDefaultIME			"CustomActionData"


// Private helper functions
static HKL GenerateProperFreeHKL();
static BOOL IsPerUser9x();

/*---------------------------------------------------------------------------
	QueryPreInstallStatus
---------------------------------------------------------------------------*/
HRESULT WINAPI QueryPreInstallStatus(MSIHANDLE hSession)
{
    CHAR szBuffer[100];
    DWORD dwBuffer = sizeof(szBuffer);

    if (MsiGetProperty(hSession, PROPERTYNAME_QueryPreInstallStatus, szBuffer, &dwBuffer) == ERROR_SUCCESS)
    	{
        HKL hKL;
        HKL hCurrentDefaultHKL;
        CHAR szCurrentDefaultHKL[10];
        DWORD dwKorKL  = 0x00000412;
		DWORD dwKLMask = 0x0000FFFF;
		DWORD dwCurHKL, dwKL;
		
        hKL = GetHKLfromHKLM(szBuffer);

		// If imekr.ime exist
        if (hKL)
        	{
			MsiSetProperty(hSession, "IMEAlreadyInstalled.CC794FB4_4D43_40AA_A417_4A8D938D3D69", "1");
            MsiSetProperty(hSession, "RBImmInstallIME.CC794FB4_4D43_40AA_A417_4A8D938D3D69", "");
#ifdef SETUP_DBG
            MessageBox(NULL,"IME2002 has already been registerd.","DEBUG",MB_OK);
#endif
        	}
        else
        	{
            MsiSetProperty(hSession, "RBImmInstallIME.CC794FB4_4D43_40AA_A417_4A8D938D3D69", szBuffer);
#ifdef SETUP_DBG
            MessageBox(NULL,"IME2002 has not been registerd. Should be removed in RollBack.","DEBUG",MB_OK);
#endif
        	}

        SystemParametersInfo(SPI_GETDEFAULTINPUTLANG, 0, &hCurrentDefaultHKL, 0);
        wsprintf(szCurrentDefaultHKL,"%08x",hCurrentDefaultHKL);
#ifdef SETUP_DBG
        MessageBox(NULL,szCurrentDefaultHKL,"Current Default HKL",MB_OK);
#endif


		dwCurHKL = *((DWORD *) &hCurrentDefaultHKL);
		dwKL = (dwCurHKL & dwKLMask);

		// only set as default when the current hKL is Korean.
		if (dwKorKL != dwKL)
			{
			MsiSetProperty(hSession, "NotSetDefault.CC794FB4_4D43_40AA_A417_4A8D938D3D69","1");
#ifdef SETUP_DBG
			MessageBox(NULL, "Default KBL was not Korean","QueryPreInstallStatus",MB_OK);
#endif
			}
			
        MsiSetProperty(hSession, "RBSetDefaultIME.CC794FB4_4D43_40AA_A417_4A8D938D3D69", szCurrentDefaultHKL);
    	}

    return(ERROR_SUCCESS);
}


/*---------------------------------------------------------------------------
	CheckOnlyOneIME
---------------------------------------------------------------------------*/
HRESULT WINAPI CheckOnlyOneIME(MSIHANDLE hSession)
{
    CHAR  szBuffer[100];
    DWORD dwBuffer=sizeof(szBuffer);

    if (MsiGetProperty(hSession, PROPERTYNAME_CheckOnlyOneIME, szBuffer, &dwBuffer) == ERROR_SUCCESS)
    	{
        if (GetKeyboardLayoutList(0,NULL) == 1)
        	{
        	HKL TheHKL;
        	
            if (GetKeyboardLayoutList(1,&TheHKL) == 1)
            	{
            	if (GetHKLfromHKLM(szBuffer) == TheHKL)
                    MsiSetProperty(hSession, "OnlyOneIME.CC794FB4_4D43_40AA_A417_4A8D938D3D69", "1");
            	}
        	}
    	}

    return(ERROR_SUCCESS);
}


/*---------------------------------------------------------------------------
	CheckIMM
---------------------------------------------------------------------------*/
HRESULT WINAPI CheckIMM(MSIHANDLE hSession)
{
	// If non Korean Win9x platform, we couldn't install system IMM32 IME since there is no IMM support.
	if (!IsNT5orUpper() && PRIMARYLANGID(GetSystemDefaultLCID()) != LANG_KOREAN)
		{
        MsiSetProperty(hSession, "INSTALLIME.CC794FB4_4D43_40AA_A417_4A8D938D3D69", "0");
		}
	else
		{
		MsiSetProperty(hSession, "INSTALLIME.CC794FB4_4D43_40AA_A417_4A8D938D3D69", "1");
		}

    return(ERROR_SUCCESS);
}


/*---------------------------------------------------------------------------
	IsPerUser9x
---------------------------------------------------------------------------*/
static BOOL IsPerUser9x()
{
	BOOL fResult = fFalse;
	HKEY hKey;
	DWORD dwMultiUser;
	DWORD dwBufferSize = sizeof(dwMultiUser);
	
	if (IsNT())
		return(fFalse);
	
	if (ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, "Network\\Logon", &hKey))
		{
		// Fail to open network reg.  That means single environment immeriately.
		if (ERROR_SUCCESS == RegQueryValueEx( hKey, "UserProfiles", NULL, NULL, (unsigned char *)&dwMultiUser, &dwBufferSize)) 
			{
			// Fail to open UserProfiles. That means single environment immeriately.
			if(1 == dwMultiUser)
				{
				// HKEY_LOCAL_MACHINE\Network\Logon\UserProfiles = 1 means multiuser
				fResult = fTrue;
				}
			}
		RegCloseKey(hKey);
		}
	
	return(fResult);
}

/*---------------------------------------------------------------------------
	CheckPerUserWin9x

	Check if multiuser using Win9x platform.
---------------------------------------------------------------------------*/
HRESULT WINAPI CheckPerUserWin9x(MSIHANDLE hSession)
{
    HKEY hKey;
    DWORD dwMultiUser, dwAllowRemove;
    DWORD dwBufferSize = sizeof(dwMultiUser);
    BOOL fAllowRemove  = fTrue;

    if (!IsNT())
    	{
		if(IsPerUser9x())
			{
			fAllowRemove = fFalse;
			}
		}

	if (fAllowRemove)
		MsiSetProperty(hSession, "PerUserWin9x.CC794FB4_4D43_40AA_A417_4A8D938D3D69", "0");
	else
		MsiSetProperty(hSession, "PerUserWin9x.CC794FB4_4D43_40AA_A417_4A8D938D3D69", "1");
		
    return(ERROR_SUCCESS);
}


/*---------------------------------------------------------------------------
	RemoveFromPreload
---------------------------------------------------------------------------*/
HRESULT WINAPI RemoveFromPreload(MSIHANDLE hSession)
{
    CHAR  szBuffer[100];
    DWORD dwBuffer = sizeof(szBuffer);

    if (MsiGetProperty(hSession, PROPERTYNAME_RemoveFromPreload, szBuffer, &dwBuffer) == ERROR_SUCCESS)
    	{
        HKL hKL = GetHKLfromHKLM(szBuffer);
        
        if (hKL)
        	{
            HKLHelpRemoveFromPreload(HKEY_CURRENT_USER, hKL);
            RegFlushKey(HKEY_CURRENT_USER);
            
            hKL = GetDefaultIMEFromHKCU(HKEY_CURRENT_USER);
            SystemParametersInfo(SPI_SETDEFAULTINPUTLANG, 0, (HKL*)&hKL, SPIF_SENDCHANGE);
        	}
    	}

    return(ERROR_SUCCESS);
}


//
// C l e a n U p P r e l o a d
//
// - Remove given IME2002 HKL from preload under given hKeyCU. hKeyCU is usually HKEY_CURRENT_USER or HKEY_USERS\.Default.
// - Remove all old MS-IME, too. This is for clean up. Practically we don't expect such HKL exist in preload.
// - If default keyboard layout was Satori, add latest (but older than Satori) MS-IME and make it default keyboard layout.
//
static void CleanUpPreload(HKEY hKeyCU, HKL hKLIme2002)
{
	BOOL fMSIMEWasDefault = fFalse;
	HKL hKLOldMSIME = NULL;
	HKL hKLLatestMSIME = NULL;
	HKL hklDefault;
	
	hklDefault = GetDefaultIMEFromHKCU(hKeyCU);

	if (hKLIme2002 == hklDefault)
		fMSIMEWasDefault = TRUE;
	
	HKLHelpRemoveFromPreload(hKeyCU, hKLIme2002);

	// Win95 IME
	hKLOldMSIME = GetHKLfromHKLM("msime95.ime");
	hKLLatestMSIME = hKLOldMSIME;
	if (hKLOldMSIME)
		{
		if (hklDefault == hKLOldMSIME)
			fMSIMEWasDefault = fTrue;
			
		if (HKLHelpExistInPreload(hKeyCU, hKLOldMSIME))
			{
			HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
			UnloadKeyboardLayout(hKLOldMSIME);
			}
		}

	// NT4 IME
	hKLOldMSIME = GetHKLfromHKLM("msime95k.ime");
	if (hKLOldMSIME)
		{
		if (hklDefault == hKLOldMSIME)
			fMSIMEWasDefault = fTrue;

		if (HKLHelpExistInPreload(hKeyCU, hKLOldMSIME))
			{
			HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
			UnloadKeyboardLayout(hKLOldMSIME);
			}
		hKLLatestMSIME = hKLOldMSIME;
		}

	// Win98, ME, NT4 SP6 & W2K IME
	hKLOldMSIME = GetHKLfromHKLM("imekr98u.ime");
	if (hKLOldMSIME)
		{
		if (hklDefault == hKLOldMSIME)
			fMSIMEWasDefault = fTrue;

		if (HKLHelpExistInPreload(hKeyCU, hKLOldMSIME))
			{
			HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
			UnloadKeyboardLayout(hKLOldMSIME);
			}
		hKLLatestMSIME = hKLOldMSIME;
		}

	// If IME2002 was default, we should enable latest Kor IME.
	if (fMSIMEWasDefault && hKLLatestMSIME)
		HKLHelpSetDefaultKeyboardLayout(hKeyCU, hKLLatestMSIME, TRUE/*fSetDefault*/);
}

// !!! TEMPORARY SOLUTION START !!!
static 
BOOL KYFileExist(LPCSTR szFilePath)
{
    HANDLE hFile;

    if(INVALID_HANDLE_VALUE != (hFile = CreateFileA(szFilePath, GENERIC_READ,
                                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))){
        CloseHandle(hFile);
        return(TRUE);
    }
    return(FALSE);
}

static
void CatBackslashIfNeededA(LPSTR szPath)
{
    if('\\'!=szPath[lstrlenA(szPath)-1]){
        lstrcatA(szPath, "\\");
    }
}
// !!! TEMPORARY SOLUTION END !!!

/*---------------------------------------------------------------------------
	ImmUninstallIME
---------------------------------------------------------------------------*/
HRESULT WINAPI ImmUninstallIME(MSIHANDLE hSession)
{
    CHAR    szBuffer[100];
    DWORD   dwBuffer = sizeof(szBuffer);
	HKEY 	hKLOldMSIME;
	HKEY 	hKey;

#ifdef SETUP_DBG
    MessageBox(NULL, "ImmUninstallIME", "Enter", MB_OK);
#endif

    if (MsiGetProperty(hSession, PROPERTYNAME_ImmUninstallIME, szBuffer, &dwBuffer) == ERROR_SUCCESS)
    	{
        HKL hKL = GetHKLfromHKLM(szBuffer);

        if (hKL)
        	{
            CleanUpPreload(HKEY_CURRENT_USER, hKL);
			
            // In single user Win9x, HKCU also changes HKU\.Default
		    if (IsPerUser9x())
		    	{
				HKEY hKey;
				// Remove from HKU\.default for default setting
				if (RegOpenKeyEx(HKEY_USERS, TEXT(".Default"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
					{
	    	        CleanUpPreload(hKey, hKL);
					RegCloseKey(hKey);
					}
				}

			// Remove from HKLM
            HKLHelpRemoveFromControlSet(hKL);

			// Remove Substitute HKL value
			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZTIPREG_LANGPROFILE, 0, KEY_ALL_ACCESS, &hKey))
				{
				CHAR szSubKeyName[MAX_PATH];
				DWORD dwIndex;
				HKEY hSubKey;
#ifdef SETUP_DBG 
				MessageBox(NULL, "Removing Substitute HKL value", "ImmUninstallIME",MB_OK);
#endif
				dwIndex = 0;
				while (ERROR_NO_MORE_ITEMS != RegEnumKey(hKey, dwIndex, szSubKeyName, MAX_PATH))
					{
#ifdef SETUP_DBG
				MessageBox(NULL, szSubKeyName, "ImmUninstallIME - enumerating subkeys", MB_OK);
#endif
					if (ERROR_SUCCESS == RegOpenKeyEx(hKey,szSubKeyName,0,KEY_ALL_ACCESS, &hSubKey))
						{
						RegDeleteValue(hSubKey,"SubstituteLayout");
						RegCloseKey(hSubKey);
						}
					dwIndex++;
					}
				RegCloseKey(hKey);
				}
			
#ifdef SETUP_DBG
            MessageBox(NULL, "ImmUninstallIME", "Success", MB_OK);
#endif
        	}
    	}
    	
    return(ERROR_SUCCESS);
}


/*---------------------------------------------------------------------------
	RBImmInstallIME
---------------------------------------------------------------------------*/
HRESULT WINAPI RBImmInstallIME(MSIHANDLE hSession)
{
    CHAR  szBuffer[100];
    DWORD dwBuffer = sizeof(szBuffer);

#ifdef SETUP_DBG
    MessageBox(NULL,"RBImmInstallIME","Enter",MB_OK);
#endif

    if (MsiGetProperty(hSession, PROPERTYNAME_RBImmInstallIME, szBuffer, &dwBuffer) == ERROR_SUCCESS)
    	{
        if (dwBuffer)
        	{
#ifdef SETUP_DBG
            MessageBox(NULL,szBuffer,"RollBack: Remove HKL from ControlSet",MB_OK);
#endif
            HKL hKL = GetHKLfromHKLM(szBuffer);
            if (hKL)
            	{
                HKLHelpRemoveFromPreload(HKEY_CURRENT_USER, hKL);
                HKLHelpRemoveFromControlSet(hKL);
#ifdef SETUP_DBG
                MessageBox(NULL,"RBImmInstallIME","Success",MB_OK);
#endif
            	}
        	}
    	}

    return(ERROR_SUCCESS);
}


/*---------------------------------------------------------------------------
	RBSetDefaultIME
---------------------------------------------------------------------------*/
HRESULT WINAPI RBSetDefaultIME(MSIHANDLE hSession)
{
    CHAR  szBuffer[100];
    DWORD dwBuffer = sizeof(szBuffer);

#ifdef SETUP_DBG
    MessageBox(NULL, "RBSetDefault", "Enter", MB_OK);
#endif

    if (MsiGetProperty(hSession, PROPERTYNAME_RBSetDefaultIME, szBuffer, &dwBuffer) == ERROR_SUCCESS)
    	{
        HKL hKL;
#ifdef SETUP_DBG
        MessageBox(NULL, szBuffer, "RollBack: Set Default IME to...", MB_OK);
#endif
        sscanf(szBuffer, "%08x", &hKL);
        if (hKL)
        	{
            HKLHelpSetDefaultKeyboardLayout(HKEY_CURRENT_USER, hKL, TRUE/*fSetDefault*/);
            RegFlushKey(HKEY_CURRENT_USER);
            SetDefaultKeyboardLayoutForDefaultUser(hKL);
        	}
		}
    
    return(ERROR_SUCCESS);
}

	

//
// G e n e r a t e P r o p e r t F r e e H K L
//
// Search e0xx0412 HKL in HKLM\...\Keyboard Layouts where xx >= 20.
// Returns first free HKL
//
// Stolen from Satori code.
HKL GenerateProperFreeHKL(void)
{
	HKL  hKLCandidate = 0;
	CHAR  szLayoutString[100];
	DWORD dwLayoutString;
	
	for (UINT i=0x20; i<0x100; i++)
		{
		
		hKLCandidate = (HKL)(DWORD)((DWORD)0xe0 << 24 | i << 16 | 0x0412);
		
		dwLayoutString = sizeof(szLayoutString);
		szLayoutString[0] = 0;
		// Get "Layout Text"
		HKLHelpGetLayoutString(hKLCandidate, szLayoutString, &dwLayoutString);
		
		if (szLayoutString[0] == 0)
			{
			// HKL not used is found.
			break;
			}
		}

	return(hKLCandidate);
}

/*---------------------------------------------------------------------------
	ImmInstallIME
---------------------------------------------------------------------------*/
HRESULT WINAPI CSImmInstallIME(MSIHANDLE hSession)
{
    TCHAR szBuffer[100], szIMEFullPath[MAX_PATH];
    DWORD dwBuffer=sizeof(szBuffer);
    HKEY hKey;
    HKL hKLIME2002;
	CHAR  szSubKeyName[MAX_PATH], szHKL[MAX_PATH];
	DWORD dwIndex;
	HKEY  hHKCU;

    if (!IsNT5orUpper() && (PRIMARYLANGID(GetSystemDefaultLCID()) != LANG_KOREAN))
        return(ERROR_SUCCESS);

    if (MsiGetProperty(hSession, PROPERTYNAME_ImmInstallIME, szBuffer, &dwBuffer) == ERROR_SUCCESS)
    	{
    	for (LPSTR CurPtr = szBuffer; 0!=*CurPtr; CurPtr=CharNext(CurPtr))
    		{
            if (*CurPtr == ',')
            	{
                *CurPtr=0;
                break;
            	}
        	}

        if (GetSystemDirectory(szIMEFullPath, sizeof(szIMEFullPath)))
        	{
            lstrcat(szIMEFullPath, "\\");
            lstrcat(szIMEFullPath, szBuffer);

            hKLIME2002 = GetHKLfromHKLM(SZMODULENAME_MAIN);
            
            if (hKLIME2002 == NULL)
	            hKLIME2002 = GenerateProperFreeHKL();

			// Workaround for NT5 #155950
            HKLHelpRegisterIMEwithForcedHKL(hKLIME2002, szBuffer, CurPtr + 1);
            
            if (ImmInstallIME(szIMEFullPath, CurPtr+1))
            	{
#ifdef SETUP_DBG
                TCHAR hoge[100];
                wsprintf(hoge,"%x", ImmInstallIME(szIMEFullPath, CurPtr+1));
                MessageBox(NULL, hoge, "ImmInstallIME", MB_OK);
#endif
				}
			else
				{
#ifdef SETUP_DBG
                MessageBox(NULL, "ImmInstallIME failed", "DEBUG", MB_OK);
#endif
            	}
        	}
    	}

   	// Add Substitute HKL value to the registry
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZTIPREG_LANGPROFILE, 0, KEY_ALL_ACCESS, &hKey))
		{
		HKEY hSubKey;
		HKL hkl;
		
#ifdef SETUP_DBG 
		MessageBox(NULL, "Adding Substitute HKL value", "ImmInstallIME",MB_OK);
#endif

		hkl = GetHKLfromHKLM(SZMODULENAME_MAIN);
		
		wsprintf(szHKL, "0x%x", hkl);					
		dwIndex = 0;

		while (ERROR_NO_MORE_ITEMS != RegEnumKey(hKey, dwIndex, szSubKeyName, MAX_PATH))
			{
#ifdef SETUP_DBG
			MessageBox(NULL, szSubKeyName, "ImmInstallIME - enumerating subkeys", MB_OK);
#endif 
			if (ERROR_SUCCESS == RegOpenKeyEx(hKey,szSubKeyName,0,KEY_ALL_ACCESS, &hSubKey))
				{
				RegSetValueEx(hSubKey, "SubstituteLayout", 0, REG_SZ, (BYTE *)szHKL, (sizeof(CHAR)*lstrlen(szHKL)));
				RegCloseKey(hSubKey);
				}
			dwIndex++;
			}

		RegCloseKey(hKey);
		}

	// Remove from preload if IME2000 is not latest ime.
	BOOL fLatest = TRUE;
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, IME_REGISTRY_LATEST_VERSION, 0, KEY_READ, &hKey)==ERROR_SUCCESS)
		{
		if(ERROR_SUCCESS == RegQueryValueEx(hKey, "version", NULL, NULL, (BYTE *)szBuffer, &dwBuffer))
			{
			if(0!=lstrcmpi(szBuffer, MAJORVER))
				//version different.
				fLatest = FALSE;
			}
		else
			fLatest = FALSE; //version reg didn't exist
		RegCloseKey(hKey);
    		}
	else
		fLatest = FALSE; //version reg didn't exist

#ifdef SETUP_DBG 
		TCHAR szLog[100];
		wsprintf(szLog,"fLatest == %x, szBuffer = %s", fLatest, szBuffer);

		MessageBox(NULL, "CSImmInstallIME", szLog, MB_OK);
#endif

	if (!fLatest)
		{
		HKL hKL=GetHKLfromHKLM(SZMODULENAME_MAIN);
		if (hKL != 0)
			{
			if(HKLHelpExistInPreload(HKEY_CURRENT_USER, hKL))
				HKLHelpRemoveFromPreload(HKEY_CURRENT_USER, hKL);
			}
		}

#if 0 
	// This seems not working for all users.
	// Do it imekrmig.exe instead.
	// Reset "Show Status" value of every user's "HKEY_CURRENT_USER\Control Panel\Input Method"
    for (dwIndex=0; cbSubKeyName=MAX_PATH, RegEnumKeyEx(HKEY_USERS, dwIndex, szSubKeyName, &cbSubKeyName, NULL, NULL, NULL, NULL) == ERROR_SUCCESS; dwIndex++)
    	{
    	lstrcat(szSubKeyName, "\\Control Panel\\Input Method");
    	lstrcpy(szHKL, "1");
    	
        if (RegOpenKeyEx(HKEY_USERS, szSubKeyName, 0, KEY_ALL_ACCESS, &hHKCU) == ERROR_SUCCESS)
        	{
           	RegSetValueEx(hHKCU, "Show Status", 0, REG_SZ, (BYTE *)szHKL, (sizeof(CHAR)*lstrlen(szHKL)));
            RegCloseKey(hHKCU);
        	}
    	}
#endif
    return(ERROR_SUCCESS);
}

/*---------------------------------------------------------------------------
	SetDefaultIME
---------------------------------------------------------------------------*/
HRESULT WINAPI SetDefaultIME(MSIHANDLE hSession)
{
    CHAR  szBuffer[100];
    DWORD dwBuffer = sizeof(szBuffer);
    HKEY  hKey;
    BOOL  fNewerVerExist = TRUE;

    // only set this ime to default if its the latest ime in the system.
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, IME_REGISTRY_LATEST_VERSION, 0, KEY_READ, &hKey))
    	{
		if (RegQueryValueEx(hKey, "version", NULL, NULL, (BYTE *)szBuffer, &dwBuffer) == ERROR_SUCCESS)
			{
			if (lstrcmpi(szBuffer, MAJORVER) != 0)
				fNewerVerExist = FALSE;
			}
		else
			fNewerVerExist = FALSE; //version reg didn't exist

		RegCloseKey(hKey);
    	}
    else
		fNewerVerExist = FALSE; //version reg didn't exist

#ifdef SETUP_DBG 
		TCHAR szLog[100];
		wsprintf(szLog,"fNewerVerExist = %d", fNewerVerExist);

		MessageBox(NULL, "SetDefaultIME", szLog, MB_OK);
#endif

    if (MsiGetProperty(hSession, PROPERTYNAME_SetDefaultIME, szBuffer, &dwBuffer) == ERROR_SUCCESS)
    	{
        HKL hKL = GetHKLfromHKLM(szBuffer);

		// If newer version exist and 
		if (!fNewerVerExist)
			{
			if(HKLHelpExistInPreload(HKEY_CURRENT_USER, hKL))
				HKLHelpRemoveFromPreload(HKEY_CURRENT_USER, hKL);

			return (ERROR_SUCCESS);
			}
			
        if (hKL)
        	{
            HKLHelpSetDefaultKeyboardLayout(HKEY_CURRENT_USER, hKL, TRUE/*fSetDefault*/);
            RegFlushKey(HKEY_CURRENT_USER);
            SetDefaultKeyboardLayoutForDefaultUser(hKL);
        	}
    	}

    return(ERROR_SUCCESS);
}

/*---------------------------------------------------------------------------
	GetSIDList
	Gets all users' SID and list that in the reg for migration
---------------------------------------------------------------------------*/
HRESULT WINAPI GetSIDList(MSIHANDLE hSession)
{
	HKEY  hKey, hUserList;
	DWORD i, cbName;
	BOOL  fNoMoreSID = FALSE;
	CHAR  szName[500];

	if(IsNT())
		{
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
		
			if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZIMEREG_MAIN_ROOT_MIG, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hUserList, NULL) == ERROR_SUCCESS)
				{
				for (i=0; !fNoMoreSID; i++)
					{
					cbName = 500;

					if (RegEnumKeyEx(hKey, i, szName, &cbName, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
						fNoMoreSID = TRUE;
					else
						{
						// Write this user profile to HKLM SZIMEREG_MAIN_ROOT MigrateUser
						RegSetValueEx(hUserList, szName, 0, REG_SZ, NULL, 0);
						}
					}

		#if 0   // We set this at lock permission table in MSM instead.
				// Give full access to all users for migrate key. IMEKRMIG.EXE will remove SID entry for each user when they logon.
				SetRegKeyAccessRight(hUserList);
   		#endif
				RegCloseKey(hUserList);
				}
			RegCloseKey(hKey);
			}
		}
	else
		{
		// Check whether this is a per-user or per-machine installation
		// (Win9x profile on-start menu not shared, Win98 single user env.)
		TCHAR szAllUsers[MAX_PATH]; 
		DWORD dwBuffer = MAX_PATH;
		if (ERROR_SUCCESS == MsiGetProperty(hSession, TEXT("ALLUSERS"), szAllUsers, &dwBuffer))
			{
			if((szAllUsers[0] == '0')||(dwBuffer == 0)) // if ALLUSERS == 0, (i.e. per-user installation)
				return (ERROR_SUCCESS);
			}
		
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProfileList",0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
			if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZIMEREG_MAIN_ROOT_MIG, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hUserList, NULL) == ERROR_SUCCESS)
				{
				for (i=0; !fNoMoreSID; i++)
					{
					cbName = 500;
					
					if (RegEnumKeyEx(hKey, i, szName, &cbName, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
						fNoMoreSID = TRUE;
					else
						RegSetValueEx(hUserList, szName, 0, REG_SZ, NULL, 0);
					}
				RegCloseKey(hUserList);
				}
			RegCloseKey(hKey);
			}
		
		}
	
	return (ERROR_SUCCESS);
}


HRESULT WINAPI CAScheduleReboot(MSIHANDLE hSession)
{
	MsiDoAction(hSession, TEXT("ScheduleReboot"));
	
    return(ERROR_SUCCESS);
}

/*---------------------------------------------------------------------------
	IMESetLatestVersion
  	Sets the latest version reg (HKLM\Software\Microsoft\IMEKR)
---------------------------------------------------------------------------*/
HRESULT WINAPI IMESetLatestVersion(MSIHANDLE hSession)
{
	HKEY hKey;
	float flInstalledVersion, flVersion;
	CHAR szVersion[MAX_PATH];
	DWORD cbVersion = MAX_PATH;
	
	if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, IME_REGISTRY_LATEST_VERSION, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL))
		{
		if(ERROR_SUCCESS == RegQueryValueEx(hKey, "version", NULL, NULL, (BYTE *)szVersion, &cbVersion))
			{
			flInstalledVersion = (float)atof(szVersion);
			flVersion = (float)atof(MAJORVER);
			
			if(flVersion < flInstalledVersion)
				return (ERROR_SUCCESS);
			}

#ifdef SETUP_DBG 
		MessageBox(NULL, "IMESetLatestVersion", MAJORVER,MB_OK);
#endif
		RegSetValueEx(hKey, "version", 0, REG_SZ, (BYTE *)MAJORVER, lstrlen(MAJORVER) * sizeof(TCHAR));
		RegCloseKey(hKey);
	}
	
	return (ERROR_SUCCESS);
}
	
/*---------------------------------------------------------------------------
	GetLatestVersionIME
---------------------------------------------------------------------------*/
void GetLatestVersionIME(HKEY hKey, LPTSTR szLatestVer, LPCTSTR szIgnoreVer)
{
	DWORD dwIndex = 0; 
	CHAR szVersion[MAX_PATH];
	DWORD cbVersion = MAX_PATH;

	if (hKey)
		{
		RegQueryValueEx(hKey, "Version", NULL, NULL, (BYTE *)szVersion, &cbVersion);
		if ((atof(szVersion) > atof(szLatestVer)) && (lstrcmpi(szVersion, szIgnoreVer) != 0))
			lstrcpy(szLatestVer, szVersion);
		}
}

/*---------------------------------------------------------------------------
	IMERestoreLatestVersion
---------------------------------------------------------------------------*/
HRESULT WINAPI IMERestoreLatestVersion(MSIHANDLE hSession)
{
	HKEY hKey;
	CHAR szLatestVer[MAX_PATH];
	BOOL fLatest = TRUE;
	DWORD cbLatestVer = MAX_PATH;

	//No need to anything if current version < version in the reg.
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\IMEKR", 0, KEY_READ, &hKey))
		{
		if(ERROR_SUCCESS == RegQueryValueEx(hKey, "version", NULL, NULL, (BYTE *)szLatestVer, &cbLatestVer))
			{
			if(atof(szLatestVer) > atof(MAJORVER))
 				fLatest = FALSE;
			}
		RegCloseKey(hKey);
		}
		
	if (!fLatest)
		return ERROR_SUCCESS;

	// init szLatestVer
	lstrcpy(szLatestVer, "0.0");
	
	// Get latest system IME version
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\IME\\IMEKR",0, KEY_READ, &hKey))
		{
		GetLatestVersionIME(hKey, szLatestVer, MAJORVER);
		RegCloseKey(hKey);
		}
	
	// Get latest app IME version
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, IME_REGISTRY_LATEST_VERSION, 0, KEY_READ, &hKey))
		{
		GetLatestVersionIME(hKey, szLatestVer, MAJORVER);
		RegCloseKey(hKey);
		}

#ifdef SETUP_DBG 
	MessageBox(NULL, "IMERestoreLatestVersion", szLatestVer, MB_OK);
#endif

	// if ime version other than MAJORVER was found, write that value to the registry.
	if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, IME_REGISTRY_LATEST_VERSION, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL))
		{
		if (lstrcmpi(szLatestVer, "0.0") == 0)
			RegDeleteValue(hKey, "version");
		else
			RegSetValueEx(hKey, "version", 0, REG_SZ, (BYTE *)szLatestVer, ((lstrlen(szLatestVer)+1) * sizeof(TCHAR)));
		RegCloseKey(hKey);
		}
	
	return (ERROR_SUCCESS);
}

/////////////////////////////////////////////////////////////////////////////
// Private utility functions
//

POSVERSIONINFO GetVersionInfo()
{
    static BOOL fFirstCall = TRUE;
    static OSVERSIONINFO os;

    if ( fFirstCall ) {
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &os ) ) {
            fFirstCall = FALSE;
        }
    }
    return &os;
}

BOOL WINAPI IsMemphisOrME()
{ 
    BOOL fResult;
    fResult = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
        (GetVersionInfo()->dwMajorVersion >= 4) &&
        (GetVersionInfo()->dwMinorVersion  >= 10);

    return fResult;
}

BOOL WINAPI IsWin95()
{ 
    BOOL fResult;
    fResult = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
        (GetVersionInfo()->dwMajorVersion == 4) &&
        (GetVersionInfo()->dwMinorVersion  < 10);

    return fResult;
}

BOOL WINAPI IsNT()
{ 
    BOOL fResult;
    fResult = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT);

    return fResult;
}

BOOL WINAPI IsNT4()
{ 
    BOOL fResult;
    fResult = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
        (GetVersionInfo()->dwMajorVersion == 4);

    return fResult;
}

BOOL WINAPI IsNT5orUpper()
{ 
    BOOL fResult;
    fResult = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
        (GetVersionInfo()->dwMajorVersion >= 5);

    return fResult;
}

BOOL IsHydra()
{
    static DWORD fTested = fFalse, fHydra = fFalse;
    HKEY hKey;

    if (!fTested) 
    	{
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\ProductOptions", 0, KEY_READ ,&hKey))
        	{
            DWORD cbData;

            if (ERROR_SUCCESS == RegQueryValueEx(hKey, "ProductSuite", NULL, NULL, NULL, &cbData))
            	{
                CHAR *mszBuffer, *szCurPtr;

                if (NULL != (mszBuffer = (CHAR *)GlobalAllocPtr(GHND, cbData)))
                	{
                    RegQueryValueEx(hKey, "ProductSuite", NULL, NULL, (LPBYTE)mszBuffer, &cbData);
                    for(szCurPtr = mszBuffer; 0 != *szCurPtr; szCurPtr += lstrlen(szCurPtr)+1)
                    	{
                        if(0 == lstrcmpi(szCurPtr, "Terminal Server"))
                        	{
                            fHydra = TRUE;
                            break;
                        	}
                    	}
                    GlobalFreePtr(mszBuffer);
                	}
            	}
            RegCloseKey(hKey);
        	}
        fTested = TRUE;
    	}
    	
    return(fHydra);
}

#if 0

#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

//
BOOL SetRegKeyAccessRight(HKEY hKey)
{
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    DWORD                cbacl;

    PSID                 psid, psid2;
    BOOL                 fResult = FALSE;

    psid = MyCreateSid(SECURITY_INTERACTIVE_RID);
    if (psid == NULL)
        return NULL;

    psid2 = MyCreateSid(SECURITY_LOCAL_SYSTEM_RID);
    if (psid2 == NULL)
    	{
    	FreeSid (psid);
        return NULL;
        }

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SIDs we've just created.
    //
    cbacl =  sizeof(ACL) + 
             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) * 2 + 
             GetLengthSid(psid);

    pacl = (PACL)MEMALLOC(cbacl);
    if (pacl == NULL)
    	{
        FreeSid(psid);
        FreeSid(psid2);
        return FALSE;
    	}

    fResult = InitializeAcl(pacl, cbacl, ACL_REVISION);
    if (!fResult)
		goto ExitError;

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                   ACL_REVISION,
                                   KEY_ALL_ACCESS,
                                   psid);

    if (!fResult)
		goto ExitError;

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce(pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid2);

    if (!fResult)
		goto ExitError;

    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid(psid);
    FreeSid(psid2);
    
    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl))
    	{
        //WARNOUT( TEXT("CreateSecurityAttributes:IsValidAcl returns fFalse!"));
        MEMFREE(pacl);
        return FALSE;
    	}

    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH );
    if (psd == NULL)
    	{
        //ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psd failed") );
        MEMFREE(pacl);
        return FALSE;
    	}

    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
		goto Exit;

    fResult = SetSecurityDescriptorDacl( psd,
                                         TRUE,
                                         pacl,
                                         FALSE );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if (!fResult)
		goto Exit;
			
    if (!IsValidSecurityDescriptor(psd))
		goto Exit;
		
	fResult = (RegSetKeySecurity(hKey, (SECURITY_INFORMATION)DACL_SECURITY_INFORMATION, psd) == ERROR_SUCCESS);

Exit:
    MEMFREE(pacl);
    FreeSid(psd);

	return fResult;

ExitError:
    FreeSid(psid);
    FreeSid(psid2);
    MEMFREE(pacl);
    return FALSE;
}

// Create SID for all users
PSID MyCreateSid(DWORD dwSubAuthority)
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid(&SidAuthority,
                                        1,
                                        dwSubAuthority,
                                        0,0,0,0,0,0,0,
                                        &psid );
    if (!fResult)
    	{
        //ERROROUT( TEXT("MyCreateSid:AllocateAndInitializeSid failed") );
        return NULL;
    	}

    if (!IsValidSid(psid))
    	{
        //WARNOUT(TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid(psid);
        return NULL;
    	}

    return psid;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\setup\custdllm\hklhelp.cpp ===
#include "private.h"
#include <stdio.h>
#include <stdlib.h>
#include "HKLHelp.h"

extern BOOL WINAPI IsNT();

typedef char KeyNameType[MAX_NAME];

// Forward decls.
static void SortRegKeys(KeyNameType *hKLKeyList, KeyNameType *hKLList, INT Num);
static void RenumberPreload(HKEY hKeyCU);

/*---------------------------------------------------------------------------
	GetHKLfromHKLM
---------------------------------------------------------------------------*/
HKL GetHKLfromHKLM(LPSTR argszIMEFile)
{
    HKL  hklAnswer = 0;
    HKEY hKey, hSubKey;
    DWORD i, cbSubKey, cbIMEFile;
    TCHAR szSubKey[MAX_PATH], szIMEFile[MAX_PATH];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\Keyboard Layouts", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    	{
        for (i=0; ;i++)
        	{
        	cbSubKey = MAX_PATH;
			if (RegEnumKeyEx(hKey, i, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
				break;
        	
            RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey);

            cbIMEFile=MAX_PATH;
            if (RegQueryValueEx(hSubKey,"IME File",NULL,NULL,(LPBYTE)szIMEFile, &cbIMEFile) == ERROR_SUCCESS)
            	{
                if (lstrcmpi(argszIMEFile, szIMEFile) == 0)
                	{
                    RegCloseKey(hSubKey);
                    sscanf(szSubKey, "%08x", &hklAnswer);
                    break;
                	}
            	}
            RegCloseKey(hSubKey);
        	}
        	
        RegCloseKey(hKey);
    	}
    	
    return(hklAnswer);
}

/*---------------------------------------------------------------------------
	GetDefaultIMEFromHKCU
---------------------------------------------------------------------------*/
HKL GetDefaultIMEFromHKCU(HKEY hKeyCU)
{
    HKEY hKey;
    DWORD cbData;
    BYTE Data[MAX_NAME];
    HKL hKL = 0;

    cbData=sizeof(Data);
    
    if (IsNT())
    	{
        RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_READ, &hKey);
        RegQueryValueEx(hKey, "1", 0, NULL, Data, &cbData);
        RegCloseKey(hKey);
    	}
    else
    	{          // Case of non-NT
        RegOpenKeyEx(hKeyCU, "keyboard layout\\preload\\1", 0, KEY_READ, &hKey);
        RegQueryValueEx(hKey, "", 0, NULL, Data, &cbData);
        RegCloseKey(hKey);
    	}

    sscanf((const char *)Data,"%08x",&hKL);
    return(hKL);
}


/*---------------------------------------------------------------------------
	HKLHelpExistInPreload
---------------------------------------------------------------------------*/
BOOL HKLHelpExistInPreload(HKEY hKeyCU, HKL hKL)
{
    HKEY hKey,hSubKey;
    CHAR szKL[20];
    int i,j;
    DWORD cbName,cbData;
    CHAR Name[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;
    BOOL fResult = FALSE;

    wsprintf(szKL,"%08x",hKL);
    if (IsNT())
    	{
		if (RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
			for (j=0; cbName=MAX_NAME, cbData=MAX_NAME, RegEnumValue(hKey, j, Name, &cbName, NULL, NULL, Data, &cbData) != ERROR_NO_MORE_ITEMS; j++)
				{
				if (lstrcmpi((LPCSTR)Data, szKL) == 0)
					{
					fResult = TRUE;
					break;
					}
				}
	        RegCloseKey(hKey);
	        }
    	}
    else
    	{          // Case of non-NT
        if (RegOpenKeyEx(hKeyCU, "keyboard layout\\preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        	{
			for (i=0; cbName=MAX_NAME, RegEnumKeyEx(hKey, i, Name, &cbName, 0, NULL, NULL, &ftLastWriteTime) != ERROR_NO_MORE_ITEMS; i++)
				{
				RegOpenKeyEx(hKey, Name, 0, KEY_ALL_ACCESS, &hSubKey);
				cbData=MAX_NAME;
				RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
				RegCloseKey(hSubKey);
				
				if (lstrcmpi((LPCSTR)Data, szKL) == 0)
					{
					fResult = TRUE;
					break;
					}
				}
        	RegCloseKey(hKey);
			}
    	}

    return(fResult);
}

/*---------------------------------------------------------------------------
	HKLHelpRemoveFromPreload
---------------------------------------------------------------------------*/
void HKLHelpRemoveFromPreload(HKEY hKeyCU, HKL hKL)
{
    HKEY hKey,hSubKey;
    char szKL[20];
    int  i, j;
    DWORD cbName,cbData;
    CHAR szName[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;

    wsprintf(szKL, "%08x", hKL);
    
    if (IsNT())
    	{
        if (RegOpenKeyEx(hKeyCU,"Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
	        for (j=0; ; j++)
	        	{
	        	cbName = MAX_NAME;
	        	cbData = MAX_NAME;
	        	if (RegEnumValue(hKey, j, szName, &cbName, NULL, NULL, Data, &cbData) == ERROR_NO_MORE_ITEMS )
	        		break;
	        	
	            if (lstrcmpi((const char *)Data,szKL) == 0)
	            	{
	                RegDeleteValue(hKey, szName);
	                break;
	            	}
	        	}
	        RegCloseKey(hKey);
	        }
    	}
    else
    	{
    	if (RegOpenKeyEx(hKeyCU,"keyboard layout\\preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    		{
	        for (i=0; ; i++)
	        	{
	        	cbName = MAX_NAME;
	        	if (RegEnumKeyEx(hKey, i, szName, &cbName, 0, NULL, NULL, &ftLastWriteTime) == ERROR_NO_MORE_ITEMS)
	        		break;
	        	
	            RegOpenKeyEx(hKey, szName, 0, KEY_ALL_ACCESS, &hSubKey);
	            cbData = MAX_NAME;
	            RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
	            RegCloseKey(hSubKey);
	            
	            if (lstrcmpi((const char *)Data,szKL) == 0)
	            	{
	                RegDeleteKey(hKey, szName);
	                break;
	            	}
	        	}
	        	
	        RegCloseKey(hKey);
	        }
    	}

    RenumberPreload(hKeyCU);
}

/*---------------------------------------------------------------------------
	HKLHelpRemoveFromControlSet
---------------------------------------------------------------------------*/
void HKLHelpRemoveFromControlSet(HKL hKL)
{
    HKEY hKey;
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,"System\\CurrentControlSet\\control\\keyboard layouts",0,KEY_ALL_ACCESS,&hKey) == ERROR_SUCCESS)
    	{
        CHAR szKeyName[10];
        wsprintf(szKeyName, "%08x", hKL);
        RegDeleteKey(hKey, szKeyName);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpRegisterIMEwithForcedHKL
---------------------------------------------------------------------------*/
void HKLHelpRegisterIMEwithForcedHKL(HKL hKL, LPSTR szIMEFile, LPSTR szTitle)
{
    CHAR szRegPath[MAX_PATH];
    DWORD dwDisposition;
    HKEY hKey;
    CHAR szIMEFileUpper[MAX_PATH];
    
    for (INT i = 0; szIMEFile[i] != 0; i++)
        szIMEFileUpper[i] = (CHAR)toupper(szIMEFile[i]);

    szIMEFileUpper[i] = 0;
    
    wsprintf(szRegPath, "System\\CurrentControlSet\\Control\\Keyboard Layouts\\%08x", hKL);
    
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
    	{
        RegSetValueEx(hKey, "Ime File", 0, REG_SZ, (LPBYTE)szIMEFileUpper, lstrlen(szIMEFile)+1);
        RegSetValueEx(hKey, "Layout Text", 0, REG_SZ, (LPBYTE)szTitle, lstrlen(szTitle)+1);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpGetLayoutString
---------------------------------------------------------------------------*/
void HKLHelpGetLayoutString(HKL hKL, LPSTR szLayoutString, DWORD *pcbSize)
{
    CHAR szRegPath[MAX_PATH];
    HKEY hKey;

    wsprintf(szRegPath, "System\\CurrentControlSet\\Control\\Keyboard Layouts\\%08x", hKL);

    if(ERROR_SUCCESS==RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ, &hKey))
    	{
        RegQueryValueEx(hKey, "Layout Text", NULL, NULL, (LPBYTE)szLayoutString, pcbSize);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpSetDefaultKeyboardLayout
---------------------------------------------------------------------------*/
void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault)
{
	char szKL[20];
	BYTE Data[MAX_PATH];
	DWORD cbData;
	char szSubKey[MAX_PATH];
	HKEY hKey,hSubKey;
	DWORD NumKL;

	wsprintf(szKL, "%08x", hKL);

	if (IsNT())
		{
		RegOpenKeyEx(hKeyHKCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
		RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumKL, NULL, NULL, NULL, NULL);
		
		for (DWORD i=0; i<NumKL; i++)
			{
			wsprintf(szSubKey, "%d", i+1);
			cbData = MAX_PATH;
			RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

			if (lstrcmpi((const char *)Data, szKL) == 0)
				break;
			}

		// if hKL is not exist create it.
		if (NumKL == i)
			{
			wsprintf(szSubKey,"%d",i+1);
			RegSetValueEx(hKey, szSubKey, 0, REG_SZ, (const unsigned char *)szKL, lstrlen(szKL)+1);
			NumKL++;
			}

		// Set hKL as first, Shift down other.
        if(fSetToDefault)
        	{
			for(int j=i; j>0; j--)
				{
				wsprintf(szSubKey,"%d",j);

				cbData = MAX_PATH;
				RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

				wsprintf(szSubKey,"%d",j+1);
				RegSetValueEx(hKey, szSubKey, 0, REG_SZ, Data, cbData);
				}
			RegSetValueEx(hKey, "1", 0, REG_SZ, (const unsigned char *)szKL, lstrlen(szKL)+1);
			}
		RegCloseKey(hKey);
		}
	else
		{
		RegOpenKeyEx(hKeyHKCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
		RegQueryInfoKey(hKey, NULL, NULL, NULL, &NumKL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
		
		for (DWORD i=0; i<NumKL; i++)
			{
			wsprintf(szSubKey, "%d", i+1);
			RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

			cbData = MAX_PATH;
			RegQueryValueEx(hSubKey, "", NULL, NULL, Data, &cbData);

			if (lstrcmpi((const char *)Data, szKL) == 0)
				break;

			RegCloseKey(hSubKey);
			}

		if (NumKL == i)
			{
			wsprintf(szSubKey,"%d",i+1);
			RegCreateKeyEx(hKey,szSubKey,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hSubKey,NULL);
			RegSetValueEx(hSubKey,"",0,REG_SZ,(const unsigned char *)szKL,lstrlen(szKL)+1);
			RegCloseKey(hSubKey);
			NumKL++;
			}

        if(fSetToDefault)
        	{
			for (int j=i; j>0; j--)
				{
				wsprintf(szSubKey, "%d", j);
				RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

				cbData = MAX_PATH;
				RegQueryValueEx(hSubKey, "", NULL, NULL, Data, &cbData);
				RegCloseKey(hSubKey);

				wsprintf(szSubKey,"%d",j+1);
				RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

				cbData = MAX_PATH;
				RegSetValueEx(hSubKey, "", 0, REG_SZ, Data, cbData);
				RegCloseKey(hSubKey);
				}
			
			RegOpenKeyEx(hKey, "1", 0, KEY_ALL_ACCESS, &hSubKey);
			RegSetValueEx(hSubKey, "", 0, REG_SZ, (const LPBYTE)szKL, lstrlen(szKL)+1);
			RegCloseKey(hSubKey);
			}
		RegCloseKey(hKey);
	}

	(void)LoadKeyboardLayout(szKL, KLF_ACTIVATE);
	// To activate IME2002 right now without reboot.
	if(fSetToDefault)
		(void)SystemParametersInfo(SPI_SETDEFAULTINPUTLANG, 0, (HKL*)&hKL, SPIF_SENDCHANGE);
}

/*---------------------------------------------------------------------------
	SetDefaultKeyboardLayout
---------------------------------------------------------------------------*/
void SetDefaultKeyboardLayoutForDefaultUser(const HKL hKL)
{
    char szKL[20];
    HKEY hKey, hSubKey;

    wsprintf(szKL,"%08x",hKL);

    if (!IsNT())
    	{
    	// Win9x has only one preload.
        RegOpenKeyEx(HKEY_USERS, ".Default\\Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
        RegOpenKeyEx(hKey, "1", 0, KEY_ALL_ACCESS, &hSubKey);
        RegSetValueEx(hSubKey, "", 0, REG_SZ, (const LPBYTE)szKL, lstrlen(szKL)+1);
        RegCloseKey(hSubKey);
        RegCloseKey(hKey);
    	}
}


/*---------------------------------------------------------------------------
	AddPreload
	
	Add IME2002 to preload in given HKCU tree. 
	If there's other old MS-IMEs, remove them from preload. 
	If Korean keyboard layout was the default keyboard layout, 
									set IME2002 as default keyboard layout. 

	Given HKCU usually can be HKEY_CURRENT_USER or HKEY_USERS\.Default.
---------------------------------------------------------------------------*/
void AddPreload(HKEY hKeyCU, HKL hKL)
{
	BOOL fKoreanWasDefault = fFalse;
	HKL  hDefaultKL, hKLOldMSIME;

	hDefaultKL = GetDefaultIMEFromHKCU(hKeyCU);

	if (LOWORD(hDefaultKL) == 0x0412)
		fKoreanWasDefault = fTrue;

	// Win95 IME
	hKLOldMSIME = GetHKLfromHKLM("msime95.ime");
	if (hKLOldMSIME != NULL)
		{
		while (HKLHelpExistInPreload(hKeyCU, hKLOldMSIME))
			{
			HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
			RegFlushKey(hKeyCU);
			}
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	// NT4 IME
	hKLOldMSIME = GetHKLfromHKLM("msime95k.ime");
	if (hKLOldMSIME != NULL)
		{
		while (HKLHelpExistInPreload(hKeyCU, hKLOldMSIME))
			{
			HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
			RegFlushKey(hKeyCU);
			}
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	// Win98, ME, NT4 SP6 & W2K IME
	hKLOldMSIME = GetHKLfromHKLM("imekr98u.ime");
	if (hKLOldMSIME != NULL)
		{
		while (HKLHelpExistInPreload(hKeyCU, hKLOldMSIME))
			{
			HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
			RegFlushKey(hKeyCU);
			}
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	if (hKL)
		HKLHelpSetDefaultKeyboardLayout(hKeyCU, hKL, fKoreanWasDefault);
}

//////////////////////////////////////////////////////////////////////////////
// Private functions
void SortRegKeys(KeyNameType *hKLKeyList, KeyNameType *hKLList, INT Num)
{
    KeyNameType hKeyTmp;
    INT PhaseCur, PhaseEnd;

    for (PhaseEnd=0; PhaseEnd < Num-1; PhaseEnd++)
    	{
        for (PhaseCur = Num-1; PhaseCur > PhaseEnd; PhaseCur--)
        	{
            if(atoi(hKLKeyList[PhaseCur]) < atoi(hKLKeyList[PhaseCur-1]))
            	{
                lstrcpy(hKeyTmp, hKLKeyList[PhaseCur-1]);
                lstrcpy(hKLKeyList[PhaseCur-1], hKLKeyList[PhaseCur]);
                lstrcpy(hKLKeyList[PhaseCur], hKeyTmp);
                lstrcpy(hKeyTmp, hKLList[PhaseCur-1]);
                lstrcpy(hKLList[PhaseCur-1], hKLList[PhaseCur]);
                lstrcpy(hKLList[PhaseCur], hKeyTmp);
            	}
        	}
    	}
}

void RenumberPreload(HKEY hKeyCU)
{
    int i, j, k;
    DWORD cbName,cbData;
    char Name[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;
    HKEY hKey,hSubKey;
    char szNum[10];
    DWORD dwDisposition,MaxValue;
    KeyNameType *hKLKeyList,*hKLList;

    if(IsNT())
    	{
        RegOpenKeyEx(hKeyCU,"keyboard layout\\preload",0,KEY_ALL_ACCESS,&hKey);

        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &MaxValue, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
        	{
            RegCloseKey(hKey);
            return;
        	}

        hKLKeyList = (KeyNameType *)GlobalAllocPtr(GHND, sizeof(KeyNameType)*MaxValue);
        hKLList = (KeyNameType *)GlobalAllocPtr(GHND, sizeof(KeyNameType)*MaxValue);
        
        if (hKLKeyList == NULL || hKLList == NULL)
            return;

        for (j=0; ;j++)
        	{
        	cbName = MAX_NAME;
        	cbData = MAX_NAME;
        	if (RegEnumValue(hKey, j, Name, &cbName, NULL, NULL, Data, &cbData) == ERROR_NO_MORE_ITEMS)
        		break;
        	
            lstrcpy(hKLList[j], (const char *)Data);
            lstrcpy(hKLKeyList[j], Name);
        	}
        	
        for (k=0; k<j; k++)
            RegDeleteValue(hKey, hKLKeyList[k]);
        	
        SortRegKeys(hKLKeyList, hKLList, j);

        for (k=0; k<j; k++)
        	{
            wsprintf(szNum,"%d",k+1);
            RegSetValueEx(hKey, szNum, 0, REG_SZ, (const unsigned char *)hKLList[k], lstrlen(hKLList[k])+1);
        	}

        RegCloseKey(hKey);
        GlobalFreePtr(hKLList);
        GlobalFreePtr(hKLKeyList);
    	}
    else
    	{
        RegOpenKeyEx(hKeyCU,"keyboard layout\\preload",0,KEY_ALL_ACCESS,&hKey);

        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, &MaxValue, NULL, NULL,NULL,NULL,NULL,NULL,NULL) != ERROR_SUCCESS)
        	{
            RegCloseKey(hKey);
            return;
        	}

        hKLKeyList = (KeyNameType *)GlobalAllocPtr(GHND,sizeof(KeyNameType)*MaxValue);
        hKLList = (KeyNameType *)GlobalAllocPtr(GHND,sizeof(KeyNameType)*MaxValue);

        if (hKLKeyList == NULL || hKLList == NULL)
            return;

        for (i=0; ;i++)
        	{
        	cbName = MAX_NAME;
        	if (RegEnumKeyEx(hKey, i, Name, &cbName, 0, NULL, NULL, &ftLastWriteTime) == ERROR_NO_MORE_ITEMS)
        		break;
        	
            RegOpenKeyEx(hKey, Name, 0, KEY_ALL_ACCESS, &hSubKey);
            
            cbData = MAX_NAME;
            RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
            RegCloseKey(hSubKey);

            lstrcpy(hKLList[i], (const char *)Data);
            lstrcpy(hKLKeyList[i], Name);
        	}
        
        for(k=0; k<i; k++)
	        RegDeleteKey(hKey, hKLKeyList[k]);
    
        SortRegKeys(hKLKeyList, hKLList, i);

        for(k=0; k<i; k++)
        	{
            wsprintf(szNum,"%d",k+1);
            RegCreateKeyEx(hKey, szNum, 0, "",REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisposition);
            RegSetValueEx(hSubKey, "", 0, REG_SZ, (const unsigned char *)hKLList[k], lstrlen(hKLList[k])+1);
            RegCloseKey(hSubKey);
        	}
        	
        RegCloseKey(hKey);
        GlobalFreePtr(hKLList);
        GlobalFreePtr(hKLKeyList);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\setup\migexe\private.h ===
//
//  Private.h
//
//  Contents:   Private header for korimx project.
//

#if !defined (__PRIVATE_H__INCLUDED_)
#define __PRIVATE_H__INCLUDED_

#include <windows.h>
#include <windowsx.h>
#include <msi.h>
#include <msiquery.h>

#define fTrue   1
#define fFalse  0

#endif  // __PRIVATE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\setup\custdllm\hklhelp.h ===
#define MAX_NAME 100

#ifdef __cplusplus
extern "C" {
#endif

HKL  GetHKLfromHKLM(LPSTR argszIMEFile);
HKL  GetDefaultIMEFromHKCU(HKEY hKeyCU);
BOOL HKLHelpExistInPreload(HKEY hKeyCU, HKL hKL);
void HKLHelpRemoveFromPreload(HKEY hKeyCU, HKL hKL);
void HKLHelpRemoveFromControlSet(HKL hKL);
void HKLHelpRegisterIMEwithForcedHKL(HKL hKL, LPSTR szIMEFile, LPSTR szTitle);
void HKLHelpGetLayoutString(HKL hKL, LPSTR szLayoutString, DWORD *pcbSize);
void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault);
void SetDefaultKeyboardLayoutForDefaultUser(const HKL hKL);
void AddPreload(HKEY hKeyCU, HKL hKL);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\setup\migexe\hklhelp.h ===
#define MAX_NAME 100

#ifdef __cplusplus
extern "C" {
#endif

HKL  GetHKLfromHKLM(LPSTR argszIMEFile);
HKL  GetDefaultIMEFromHKCU(HKEY hKeyCU);
BOOL HKLHelpExistInPreload(HKEY hKeyCU, HKL hKL);
void HKLHelpRemoveFromPreload(HKEY hKeyCU, HKL hKL);
void HKLHelpRemoveFromControlSet(HKL hKL);
void HKLHelpRegisterIMEwithForcedHKL(HKL hKL, LPSTR szIMEFile, LPSTR szTitle);
void HKLHelpGetLayoutString(HKL hKL, LPSTR szLayoutString, DWORD *pcbSize);
void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault);
void SetDefaultKeyboardLayoutForDefaultUser(const HKL hKL);
void AddPreload(HKEY hKeyCU, HKL hKL);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\setup\migexe\makefile.inc ===
CUSTDLL_INCLUDE = ..\CustDllM
hklhelp.h : $(CUSTDLL_INCLUDE)\hklhelp.h
    COPY $** $@
hklhelp.cpp : $(CUSTDLL_INCLUDE)\hklhelp.cpp
    COPY $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\setup\migexe\hklhelp.cpp ===
#include "private.h"
#include <stdio.h>
#include <stdlib.h>
#include "HKLHelp.h"

extern BOOL WINAPI IsNT();

typedef char KeyNameType[MAX_NAME];

// Forward decls.
static void SortRegKeys(KeyNameType *hKLKeyList, KeyNameType *hKLList, INT Num);
static void RenumberPreload(HKEY hKeyCU);

/*---------------------------------------------------------------------------
	GetHKLfromHKLM
---------------------------------------------------------------------------*/
HKL GetHKLfromHKLM(LPSTR argszIMEFile)
{
    HKL  hklAnswer = 0;
    HKEY hKey, hSubKey;
    DWORD i, cbSubKey, cbIMEFile;
    TCHAR szSubKey[MAX_PATH], szIMEFile[MAX_PATH];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\Keyboard Layouts", 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    	{
        for (i=0; ;i++)
        	{
        	cbSubKey = MAX_PATH;
			if (RegEnumKeyEx(hKey, i, szSubKey, &cbSubKey, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
				break;
        	
            RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey);

            cbIMEFile=MAX_PATH;
            if (RegQueryValueEx(hSubKey,"IME File",NULL,NULL,(LPBYTE)szIMEFile, &cbIMEFile) == ERROR_SUCCESS)
            	{
                if (lstrcmpi(argszIMEFile, szIMEFile) == 0)
                	{
                    RegCloseKey(hSubKey);
                    sscanf(szSubKey, "%08x", &hklAnswer);
                    break;
                	}
            	}
            RegCloseKey(hSubKey);
        	}
        	
        RegCloseKey(hKey);
    	}
    	
    return(hklAnswer);
}

/*---------------------------------------------------------------------------
	GetDefaultIMEFromHKCU
---------------------------------------------------------------------------*/
HKL GetDefaultIMEFromHKCU(HKEY hKeyCU)
{
    HKEY hKey;
    DWORD cbData;
    BYTE Data[MAX_NAME];
    HKL hKL = 0;

    cbData=sizeof(Data);
    
    if (IsNT())
    	{
        RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_READ, &hKey);
        RegQueryValueEx(hKey, "1", 0, NULL, Data, &cbData);
        RegCloseKey(hKey);
    	}
    else
    	{          // Case of non-NT
        RegOpenKeyEx(hKeyCU, "keyboard layout\\preload\\1", 0, KEY_READ, &hKey);
        RegQueryValueEx(hKey, "", 0, NULL, Data, &cbData);
        RegCloseKey(hKey);
    	}

    sscanf((const char *)Data,"%08x",&hKL);
    return(hKL);
}


/*---------------------------------------------------------------------------
	HKLHelpExistInPreload
---------------------------------------------------------------------------*/
BOOL HKLHelpExistInPreload(HKEY hKeyCU, HKL hKL)
{
    HKEY hKey,hSubKey;
    CHAR szKL[20];
    int i,j;
    DWORD cbName,cbData;
    CHAR Name[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;
    BOOL fResult = FALSE;

    wsprintf(szKL,"%08x",hKL);
    if (IsNT())
    	{
		if (RegOpenKeyEx(hKeyCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
			for (j=0; cbName=MAX_NAME, cbData=MAX_NAME, RegEnumValue(hKey, j, Name, &cbName, NULL, NULL, Data, &cbData) != ERROR_NO_MORE_ITEMS; j++)
				{
				if (lstrcmpi((LPCSTR)Data, szKL) == 0)
					{
					fResult = TRUE;
					break;
					}
				}
	        RegCloseKey(hKey);
	        }
    	}
    else
    	{          // Case of non-NT
        if (RegOpenKeyEx(hKeyCU, "keyboard layout\\preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        	{
			for (i=0; cbName=MAX_NAME, RegEnumKeyEx(hKey, i, Name, &cbName, 0, NULL, NULL, &ftLastWriteTime) != ERROR_NO_MORE_ITEMS; i++)
				{
				RegOpenKeyEx(hKey, Name, 0, KEY_ALL_ACCESS, &hSubKey);
				cbData=MAX_NAME;
				RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
				RegCloseKey(hSubKey);
				
				if (lstrcmpi((LPCSTR)Data, szKL) == 0)
					{
					fResult = TRUE;
					break;
					}
				}
        	RegCloseKey(hKey);
			}
    	}

    return(fResult);
}

/*---------------------------------------------------------------------------
	HKLHelpRemoveFromPreload
---------------------------------------------------------------------------*/
void HKLHelpRemoveFromPreload(HKEY hKeyCU, HKL hKL)
{
    HKEY hKey,hSubKey;
    char szKL[20];
    int  i, j;
    DWORD cbName,cbData;
    CHAR szName[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;

    wsprintf(szKL, "%08x", hKL);
    
    if (IsNT())
    	{
        if (RegOpenKeyEx(hKeyCU,"Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
	        for (j=0; ; j++)
	        	{
	        	cbName = MAX_NAME;
	        	cbData = MAX_NAME;
	        	if (RegEnumValue(hKey, j, szName, &cbName, NULL, NULL, Data, &cbData) == ERROR_NO_MORE_ITEMS )
	        		break;
	        	
	            if (lstrcmpi((const char *)Data,szKL) == 0)
	            	{
	                RegDeleteValue(hKey, szName);
	                break;
	            	}
	        	}
	        RegCloseKey(hKey);
	        }
    	}
    else
    	{
    	if (RegOpenKeyEx(hKeyCU,"keyboard layout\\preload", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    		{
	        for (i=0; ; i++)
	        	{
	        	cbName = MAX_NAME;
	        	if (RegEnumKeyEx(hKey, i, szName, &cbName, 0, NULL, NULL, &ftLastWriteTime) == ERROR_NO_MORE_ITEMS)
	        		break;
	        	
	            RegOpenKeyEx(hKey, szName, 0, KEY_ALL_ACCESS, &hSubKey);
	            cbData = MAX_NAME;
	            RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
	            RegCloseKey(hSubKey);
	            
	            if (lstrcmpi((const char *)Data,szKL) == 0)
	            	{
	                RegDeleteKey(hKey, szName);
	                break;
	            	}
	        	}
	        	
	        RegCloseKey(hKey);
	        }
    	}

    RenumberPreload(hKeyCU);
}

/*---------------------------------------------------------------------------
	HKLHelpRemoveFromControlSet
---------------------------------------------------------------------------*/
void HKLHelpRemoveFromControlSet(HKL hKL)
{
    HKEY hKey;
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,"System\\CurrentControlSet\\control\\keyboard layouts",0,KEY_ALL_ACCESS,&hKey) == ERROR_SUCCESS)
    	{
        CHAR szKeyName[10];
        wsprintf(szKeyName, "%08x", hKL);
        RegDeleteKey(hKey, szKeyName);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpRegisterIMEwithForcedHKL
---------------------------------------------------------------------------*/
void HKLHelpRegisterIMEwithForcedHKL(HKL hKL, LPSTR szIMEFile, LPSTR szTitle)
{
    CHAR szRegPath[MAX_PATH];
    DWORD dwDisposition;
    HKEY hKey;
    CHAR szIMEFileUpper[MAX_PATH];
    
    for (INT i = 0; szIMEFile[i] != 0; i++)
        szIMEFileUpper[i] = (CHAR)toupper(szIMEFile[i]);

    szIMEFileUpper[i] = 0;
    
    wsprintf(szRegPath, "System\\CurrentControlSet\\Control\\Keyboard Layouts\\%08x", hKL);
    
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
    	{
        RegSetValueEx(hKey, "Ime File", 0, REG_SZ, (LPBYTE)szIMEFileUpper, lstrlen(szIMEFile)+1);
        RegSetValueEx(hKey, "Layout Text", 0, REG_SZ, (LPBYTE)szTitle, lstrlen(szTitle)+1);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpGetLayoutString
---------------------------------------------------------------------------*/
void HKLHelpGetLayoutString(HKL hKL, LPSTR szLayoutString, DWORD *pcbSize)
{
    CHAR szRegPath[MAX_PATH];
    HKEY hKey;

    wsprintf(szRegPath, "System\\CurrentControlSet\\Control\\Keyboard Layouts\\%08x", hKL);

    if(ERROR_SUCCESS==RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ, &hKey))
    	{
        RegQueryValueEx(hKey, "Layout Text", NULL, NULL, (LPBYTE)szLayoutString, pcbSize);
        RegCloseKey(hKey);
    	}
}

/*---------------------------------------------------------------------------
	HKLHelpSetDefaultKeyboardLayout
---------------------------------------------------------------------------*/
void HKLHelpSetDefaultKeyboardLayout(HKEY hKeyHKCU, HKL hKL, BOOL fSetToDefault)
{
	char szKL[20];
	BYTE Data[MAX_PATH];
	DWORD cbData;
	char szSubKey[MAX_PATH];
	HKEY hKey,hSubKey;
	DWORD NumKL;

	wsprintf(szKL, "%08x", hKL);

	if (IsNT())
		{
		RegOpenKeyEx(hKeyHKCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
		RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumKL, NULL, NULL, NULL, NULL);
		
		for (DWORD i=0; i<NumKL; i++)
			{
			wsprintf(szSubKey, "%d", i+1);
			cbData = MAX_PATH;
			RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

			if (lstrcmpi((const char *)Data, szKL) == 0)
				break;
			}

		// if hKL is not exist create it.
		if (NumKL == i)
			{
			wsprintf(szSubKey,"%d",i+1);
			RegSetValueEx(hKey, szSubKey, 0, REG_SZ, (const unsigned char *)szKL, lstrlen(szKL)+1);
			NumKL++;
			}

		// Set hKL as first, Shift down other.
        if(fSetToDefault)
        	{
			for(int j=i; j>0; j--)
				{
				wsprintf(szSubKey,"%d",j);

				cbData = MAX_PATH;
				RegQueryValueEx(hKey, szSubKey, NULL, NULL, Data, &cbData);

				wsprintf(szSubKey,"%d",j+1);
				RegSetValueEx(hKey, szSubKey, 0, REG_SZ, Data, cbData);
				}
			RegSetValueEx(hKey, "1", 0, REG_SZ, (const unsigned char *)szKL, lstrlen(szKL)+1);
			}
		RegCloseKey(hKey);
		}
	else
		{
		RegOpenKeyEx(hKeyHKCU, "Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
		RegQueryInfoKey(hKey, NULL, NULL, NULL, &NumKL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
		
		for (DWORD i=0; i<NumKL; i++)
			{
			wsprintf(szSubKey, "%d", i+1);
			RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

			cbData = MAX_PATH;
			RegQueryValueEx(hSubKey, "", NULL, NULL, Data, &cbData);

			if (lstrcmpi((const char *)Data, szKL) == 0)
				break;

			RegCloseKey(hSubKey);
			}

		if (NumKL == i)
			{
			wsprintf(szSubKey,"%d",i+1);
			RegCreateKeyEx(hKey,szSubKey,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hSubKey,NULL);
			RegSetValueEx(hSubKey,"",0,REG_SZ,(const unsigned char *)szKL,lstrlen(szKL)+1);
			RegCloseKey(hSubKey);
			NumKL++;
			}

        if(fSetToDefault)
        	{
			for (int j=i; j>0; j--)
				{
				wsprintf(szSubKey, "%d", j);
				RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

				cbData = MAX_PATH;
				RegQueryValueEx(hSubKey, "", NULL, NULL, Data, &cbData);
				RegCloseKey(hSubKey);

				wsprintf(szSubKey,"%d",j+1);
				RegOpenKeyEx(hKey, szSubKey, 0, KEY_ALL_ACCESS, &hSubKey);

				cbData = MAX_PATH;
				RegSetValueEx(hSubKey, "", 0, REG_SZ, Data, cbData);
				RegCloseKey(hSubKey);
				}
			
			RegOpenKeyEx(hKey, "1", 0, KEY_ALL_ACCESS, &hSubKey);
			RegSetValueEx(hSubKey, "", 0, REG_SZ, (const LPBYTE)szKL, lstrlen(szKL)+1);
			RegCloseKey(hSubKey);
			}
		RegCloseKey(hKey);
	}

	(void)LoadKeyboardLayout(szKL, KLF_ACTIVATE);
	// To activate IME2002 right now without reboot.
	if(fSetToDefault)
		(void)SystemParametersInfo(SPI_SETDEFAULTINPUTLANG, 0, (HKL*)&hKL, SPIF_SENDCHANGE);
}

/*---------------------------------------------------------------------------
	SetDefaultKeyboardLayout
---------------------------------------------------------------------------*/
void SetDefaultKeyboardLayoutForDefaultUser(const HKL hKL)
{
    char szKL[20];
    HKEY hKey, hSubKey;

    wsprintf(szKL,"%08x",hKL);

    if (!IsNT())
    	{
    	// Win9x has only one preload.
        RegOpenKeyEx(HKEY_USERS, ".Default\\Keyboard Layout\\Preload", 0, KEY_ALL_ACCESS, &hKey);
        RegOpenKeyEx(hKey, "1", 0, KEY_ALL_ACCESS, &hSubKey);
        RegSetValueEx(hSubKey, "", 0, REG_SZ, (const LPBYTE)szKL, lstrlen(szKL)+1);
        RegCloseKey(hSubKey);
        RegCloseKey(hKey);
    	}
}


/*---------------------------------------------------------------------------
	AddPreload
	
	Add IME2002 to preload in given HKCU tree. 
	If there's other old MS-IMEs, remove them from preload. 
	If Korean keyboard layout was the default keyboard layout, 
									set IME2002 as default keyboard layout. 

	Given HKCU usually can be HKEY_CURRENT_USER or HKEY_USERS\.Default.
---------------------------------------------------------------------------*/
void AddPreload(HKEY hKeyCU, HKL hKL)
{
	BOOL fKoreanWasDefault = fFalse;
	HKL  hDefaultKL, hKLOldMSIME;

	hDefaultKL = GetDefaultIMEFromHKCU(hKeyCU);

	if (LOWORD(hDefaultKL) == 0x0412)
		fKoreanWasDefault = fTrue;

	// Win95 IME
	hKLOldMSIME = GetHKLfromHKLM("msime95.ime");
	if (hKLOldMSIME != NULL)
		{
		while (HKLHelpExistInPreload(hKeyCU, hKLOldMSIME))
			{
			HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
			RegFlushKey(hKeyCU);
			}
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	// NT4 IME
	hKLOldMSIME = GetHKLfromHKLM("msime95k.ime");
	if (hKLOldMSIME != NULL)
		{
		while (HKLHelpExistInPreload(hKeyCU, hKLOldMSIME))
			{
			HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
			RegFlushKey(hKeyCU);
			}
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	// Win98, ME, NT4 SP6 & W2K IME
	hKLOldMSIME = GetHKLfromHKLM("imekr98u.ime");
	if (hKLOldMSIME != NULL)
		{
		while (HKLHelpExistInPreload(hKeyCU, hKLOldMSIME))
			{
			HKLHelpRemoveFromPreload(hKeyCU, hKLOldMSIME);
			RegFlushKey(hKeyCU);
			}
		UnloadKeyboardLayout(hKLOldMSIME);
		}

	if (hKL)
		HKLHelpSetDefaultKeyboardLayout(hKeyCU, hKL, fKoreanWasDefault);
}

//////////////////////////////////////////////////////////////////////////////
// Private functions
void SortRegKeys(KeyNameType *hKLKeyList, KeyNameType *hKLList, INT Num)
{
    KeyNameType hKeyTmp;
    INT PhaseCur, PhaseEnd;

    for (PhaseEnd=0; PhaseEnd < Num-1; PhaseEnd++)
    	{
        for (PhaseCur = Num-1; PhaseCur > PhaseEnd; PhaseCur--)
        	{
            if(atoi(hKLKeyList[PhaseCur]) < atoi(hKLKeyList[PhaseCur-1]))
            	{
                lstrcpy(hKeyTmp, hKLKeyList[PhaseCur-1]);
                lstrcpy(hKLKeyList[PhaseCur-1], hKLKeyList[PhaseCur]);
                lstrcpy(hKLKeyList[PhaseCur], hKeyTmp);
                lstrcpy(hKeyTmp, hKLList[PhaseCur-1]);
                lstrcpy(hKLList[PhaseCur-1], hKLList[PhaseCur]);
                lstrcpy(hKLList[PhaseCur], hKeyTmp);
            	}
        	}
    	}
}

void RenumberPreload(HKEY hKeyCU)
{
    int i, j, k;
    DWORD cbName,cbData;
    char Name[MAX_NAME];
    BYTE Data[MAX_NAME];
    FILETIME ftLastWriteTime;
    HKEY hKey,hSubKey;
    char szNum[10];
    DWORD dwDisposition,MaxValue;
    KeyNameType *hKLKeyList,*hKLList;

    if(IsNT())
    	{
        RegOpenKeyEx(hKeyCU,"keyboard layout\\preload",0,KEY_ALL_ACCESS,&hKey);

        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &MaxValue, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
        	{
            RegCloseKey(hKey);
            return;
        	}

        hKLKeyList = (KeyNameType *)GlobalAllocPtr(GHND, sizeof(KeyNameType)*MaxValue);
        hKLList = (KeyNameType *)GlobalAllocPtr(GHND, sizeof(KeyNameType)*MaxValue);
        
        if (hKLKeyList == NULL || hKLList == NULL)
            return;

        for (j=0; ;j++)
        	{
        	cbName = MAX_NAME;
        	cbData = MAX_NAME;
        	if (RegEnumValue(hKey, j, Name, &cbName, NULL, NULL, Data, &cbData) == ERROR_NO_MORE_ITEMS)
        		break;
        	
            lstrcpy(hKLList[j], (const char *)Data);
            lstrcpy(hKLKeyList[j], Name);
        	}
        	
        for (k=0; k<j; k++)
            RegDeleteValue(hKey, hKLKeyList[k]);
        	
        SortRegKeys(hKLKeyList, hKLList, j);

        for (k=0; k<j; k++)
        	{
            wsprintf(szNum,"%d",k+1);
            RegSetValueEx(hKey, szNum, 0, REG_SZ, (const unsigned char *)hKLList[k], lstrlen(hKLList[k])+1);
        	}

        RegCloseKey(hKey);
        GlobalFreePtr(hKLList);
        GlobalFreePtr(hKLKeyList);
    	}
    else
    	{
        RegOpenKeyEx(hKeyCU,"keyboard layout\\preload",0,KEY_ALL_ACCESS,&hKey);

        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, &MaxValue, NULL, NULL,NULL,NULL,NULL,NULL,NULL) != ERROR_SUCCESS)
        	{
            RegCloseKey(hKey);
            return;
        	}

        hKLKeyList = (KeyNameType *)GlobalAllocPtr(GHND,sizeof(KeyNameType)*MaxValue);
        hKLList = (KeyNameType *)GlobalAllocPtr(GHND,sizeof(KeyNameType)*MaxValue);

        if (hKLKeyList == NULL || hKLList == NULL)
            return;

        for (i=0; ;i++)
        	{
        	cbName = MAX_NAME;
        	if (RegEnumKeyEx(hKey, i, Name, &cbName, 0, NULL, NULL, &ftLastWriteTime) == ERROR_NO_MORE_ITEMS)
        		break;
        	
            RegOpenKeyEx(hKey, Name, 0, KEY_ALL_ACCESS, &hSubKey);
            
            cbData = MAX_NAME;
            RegQueryValueEx(hSubKey, "", 0, NULL, Data, &cbData);
            RegCloseKey(hSubKey);

            lstrcpy(hKLList[i], (const char *)Data);
            lstrcpy(hKLKeyList[i], Name);
        	}
        
        for(k=0; k<i; k++)
	        RegDeleteKey(hKey, hKLKeyList[k]);
    
        SortRegKeys(hKLKeyList, hKLList, i);

        for(k=0; k<i; k++)
        	{
            wsprintf(szNum,"%d",k+1);
            RegCreateKeyEx(hKey, szNum, 0, "",REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisposition);
            RegSetValueEx(hSubKey, "", 0, REG_SZ, (const unsigned char *)hKLList[k], lstrlen(hKLList[k])+1);
            RegCloseKey(hSubKey);
        	}
        	
        RegCloseKey(hKey);
        GlobalFreePtr(hKLList);
        GlobalFreePtr(hKLKeyList);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\setup\clsid.h ===
/************************************************************

     Collection of CLSIDs/GUIDs to be registered by the setup
     
     <GUID_NAME><tab><GUID in string>

     !!! Should have <tab> between name and GUID !!!
     
************************************************************/

// IMEKRCIC.dll
CLSID_KOREANKBDTIP	{766A2C14-B226-4FD6-B52A-867B3EBF38D2}

// Input profile
CLSID_INPUTPROFILE	{E47ABB1E-46AC-45F3-8A89-34F9D706DA83}

// defined in cicero\lib\release\uimuid.lib
GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER	{046B8C80-1647-40F7-9B21-B93B81AABC1B}
GUID_TFCAT_TIP_KEYBOARD	{34745C63-B2F0-4784-8B67-5E12C8701A31}
GUID_TFCAT_TIP_MASTERLM	{FE7C68F6-DED1-4787-9AB5-AF15E8B91A0F}
GUID_MASTERLM_FUNCTIONPROVIDER	{FF341C48-DB92-46E5-8830-18B8015BAF49}
GUID_TFCAT_PROPSTYLE_CUSTOM	{24AF3031-852D-40A2-BC09-8992898CE722}
GUID_PROP_OVERTYPE	{EE894895-2709-420D-927C-AB861EC88805}

// IMEPADSV.EXE
CLSID_IIMEPADSERVERCOMPONENT	{EDC298C1-038D-11D4-8464-00C04F7A06E5}

// IMEPADSM.DLL
IID_IIMEPADSERVERSHM	{A0444C10-36D6-11D4-8473-00C04F7A06E5}

// IMLANG.DLL (IFELANG3.DLL)
CLSID_FELANGUAGE3	{258941B3-9E27-11D3-B6D0-00C04F7A02AD}

// IMJPLM.DLL (IMESTLM.DLL)
CLSID_MAKELATTICEFORCHAR	{258941B5-9E27-11D3-B6D0-00C04F7A02AD}
CLSID_ATTACHNGRAM	{258941B6-9E27-11D3-B6D0-00C04F7A02AD}
CLSID_SEARCHBESTPATH	{258941B7-9E27-11D3-B6D0-00C04F7A02AD}

// IMEPAD CATEGORY GUID  (DEFINED IN FECMMON\INCLUDE\IMEPAD.H)
CATID_MSIME_IIMEPADAPPLET	{56F7A792-FEF1-11D3-8463-00C04F7A06E5}

// MULTIBOX.DLL  (DEFINED IN FECOMMON\IMEMBX\GUIDS.H)
CLSID_IMEPADAPPLET_MULTIBOX	{35CC8480-4FB1-11D3-A5DA-00C04F88249B}
IID_IMEPADAPPLET_MULTIBOX	{35CC8481-4FB1-11D3-A5DA-00C04F88249B}
// IHJDict 
CLSID_IHJDICT	{0631B62B-67EA-46D5-B5C9-E632E0D1493D}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\candkey.cpp ===
//
// candkey.cpp
//

#include "private.h"
#include "candkey.h"

/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  K E Y  T A B L E                                        */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIKeyTable::CCandUIKeyTable( int nDataMax )
{
    m_cRef = 1;

    m_pData    = new CANDUIKEYDATA[ nDataMax ];
    m_nData    = 0;
    m_nDataMax = nDataMax;
}


/*   ~  C  C A N D  U I  K E Y  T A B L E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandUIKeyTable::~CCandUIKeyTable( void )
{
    delete m_pData;
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    Query interface
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIKeyTable::QueryInterface( REFIID riid, void **ppvObj )
{
    if (ppvObj == NULL) {
        return E_POINTER;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_ITfCandUIKeyTable )) {
        *ppvObj = SAFECAST( this, ITfCandUIKeyTable* );
    }


    if (*ppvObj == NULL) {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Increment reference count
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIKeyTable::AddRef( void )
{
    m_cRef++;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Decrement reference count and release object
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIKeyTable::Release( void )
{
    m_cRef--;
    if (0 < m_cRef) {
        return m_cRef;
    }

    delete this;
    return 0;    
}


/*   G E T  K E Y  D A T A  N U M   */
/*------------------------------------------------------------------------------

    Get count of key data
    (ITfCandUIKeyTable method)

------------------------------------------------------------------------------*/
HRESULT CCandUIKeyTable::GetKeyDataNum( int *piNum )
{
    if (piNum == NULL) {
        return E_INVALIDARG;
    }

    *piNum = m_nData;
    return S_OK;
}


/*   G E T  K E Y  D A T A   */
/*------------------------------------------------------------------------------

    Get key data
    (ITfCandUIKeyTable method)

------------------------------------------------------------------------------*/
HRESULT CCandUIKeyTable::GetKeyData( int iData, CANDUIKEYDATA *pData )
{
    *pData = m_pData[iData];
    return S_OK;
}


/*   A D D  K E Y  D A T A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandUIKeyTable::AddKeyData(const CANDUIKEYDATA *pData)
{
    if (m_nDataMax <= m_nData) {
        return E_FAIL;
    }

    if (pData == NULL) {
        Assert(FALSE);
        return E_INVALIDARG;
    }

    m_pData[ m_nData ] = *pData;
    m_nData++;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\callbacks.cpp ===
#include "private.h"
#include "korimx.h"
#include "timsink.h"
#include "immxutil.h"
#include "fnrecon.h"
#include "helpers.h"
#include "skbdmode.h"
#include "osver.h"

// REVIEW
/*---------------------------------------------------------------------------
    CKorIMX::_EditSessionCallback
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_EditSessionCallback2(TfEditCookie ec, CEditSession2 *pes)
{
    ITfContext*    pic     = pes->GetContext();
    CKorIMX*    pKorTip = pes->GetTIP();
    ESSTRUCT*    pess    = pes->GetStruct();
    ITfRange*    pRange;
    CHangulAutomata*    pAutomata;
    LPWSTR     pszCand  = NULL;

    Assert(pic != NULL);
    Assert(pKorTip != NULL);

    
    if ((pKorTip == NULL) || (pic == NULL))
        return E_FAIL;

    switch (pess->id)
    {
    case ESCB_FINALIZECONVERSION:
        {
        CCandidateListEx   *pCandList;
        CCandidateStringEx *pCandItem;

        pCandList = pess->pCandList;
        pCandItem = pess->pCandStr;
        pRange    = pess->pRange;
        
        pszCand   = pCandItem->m_psz;
        
        if (pszCand)
            {
            // Set Reading text
            SetTextAndReading(pKorTip->_GetLibTLS(), ec, pic, pRange,
                      pszCand, 
                      wcslen(pszCand),
                      pCandItem->m_langid, pCandItem->m_pszRead);
            }

        pCandList->Release();

        // First complete current comp string
        if (pAutomata = pKorTip->GetAutomata(pic))
            pAutomata->MakeComplete();

        pKorTip->MakeResultString(ec, pic, pRange);

        pKorTip->CloseCandidateUIProc();
        break;
        }

    case ESCB_COMPLETE:
        {
        BOOL fReleaseRange = fFalse;
        
        // If No composition exist, nothing to complete
        if (pKorTip->GetIPComposition(pic) == NULL)
            break;

        pRange    = pess->pRange;
        pAutomata = pKorTip->GetAutomata(pic);

        // Close cand UI if exist.
        pKorTip->CloseCandidateUIProc();

        if (pRange == NULL)
            {
            GetSelectionSimple(ec, pic, &pRange);
            fReleaseRange = fTrue;
            }

        if (pRange)
            {
            if (pAutomata)
                pAutomata->MakeComplete();
            pKorTip->MakeResultString(ec, pic, pRange);
            }
            
        if (fReleaseRange)
            {
            SafeRelease(pRange);
            }

        //return pKorTip->_MultiRangeConversion(ec, pes->_state.u, pic, pRange);
        break;
        }

    case ESCB_INSERT_PAD_STRING:
        {
        WCHAR szText[2];

        GetSelectionSimple(ec, pic, &pRange);
        szText[0] = (WCHAR)pess->wParam;
        szText[1] = L'\0';

        if (FAILED(pKorTip->SetInputString(ec, pic, pRange, szText, CKorIMX::GetLangID())))
            break;

        pKorTip->MakeResultString(ec, pic, pRange);
        
        SafeRelease(pRange);
        break;
        }
    
    case ESCB_KEYSTROKE:
        {
        WPARAM wParam = pess->wParam;
        LPARAM lParam = pess->lParam;
        return pKorTip->_Keystroke(ec, pic, wParam, lParam, (const BYTE *)pess->pv1);
        break;
        }

    // Complete and Selection range changed
    case ESCB_TEXTEVENT: 
        if (pKorTip->IsKeyFocus() && (GetSelectionSimple(ec, pic, &pRange) == S_OK)) 
            {
            ITfComposition  *pComposition;
            ITfRange        *pRangeOldComp;
            //IEnumTfRanges   *pEnumText = pess->pEnumRange;
            BOOL            fChanged = fFalse;
            BOOL            fEmpty;
            
            // Check modebias here
            if (pess->fBool)
                fChanged = pKorTip->CheckModeBias(ec, pic, pRange);
            
            //////////////////////////////////////////////////////////////////
            // To complete on mouse click we using Range change notification.
            // In future version, we could remove this code and use custom property
            // or reading string. Cutom property can hold Hangul Automata object.
            //
            // Office apps explicitly call complete but this for unknown Cicero apps.
            //////////////////////////////////////////////////////////////////
            pComposition = pKorTip->GetIPComposition(pic);
            if (pComposition == NULL)
                goto ExitTextEvent;

            // Office apps are not going through here.
            pComposition->GetRange(&pRangeOldComp);
            if (pRangeOldComp == NULL)
                goto ExitTextEvent;

            pRange->IsEmpty(ec, &fEmpty);
            if (fEmpty && (CR_EQUAL != CompareRanges(ec, pRange, pRangeOldComp)))
                {
                ITfProperty *pPropAttr;
                TfGuidAtom   attr;

                // Clear attrib
                if (SUCCEEDED(pic->GetProperty(GUID_PROP_ATTRIBUTE, &pPropAttr)))
                    {
                    if (SUCCEEDED(GetAttrPropertyData(ec, pPropAttr, pRangeOldComp, &attr)))
                        {
                        if (pKorTip->IsKorIMX_GUID_ATOM(attr))
                            {
                            pPropAttr->Clear(ec, pRangeOldComp);
                            }
                        }
                    pPropAttr->Release();
                    }
                    
                pAutomata = pKorTip->GetAutomata(pic);
                if (pAutomata)
                    pAutomata->MakeComplete();
                pKorTip->EndIPComposition(ec, pic); 
                // pKorTip->MakeResultString(ec, pic, pRangeOldComp);

                fChanged = fTrue;
                }

            SafeRelease(pRangeOldComp);

ExitTextEvent:
            pRange->Release();

            // Close cand UI if exist.
            if (fChanged)
                   pKorTip->CloseCandidateUIProc();
            }
        break;

//    case ESCB_RANGEBROKEN:
//        pKorTip->FlushIPRange(ec, pic);
//        break;

    case ESCB_CANDUI_CLOSECANDUI: 
        // u      : ESCB_CANDUI_CLOSECANDUI
        // pv     : this
        // hwnd   : - (not used)
        // wParam : - (not used)
        // lParam : - (not used)
        // pv1    : - (not used)
        // pv2    : - (not used)
        // pic    : - (not used)
        // pRange : - (not used)
        // fBool  : - (not used)
        pKorTip->CloseCandidateUIProc();
        break;

    // Hanja conv button up
    case ESCB_HANJA_CONV:
        // u      : ESCB_HANJA_CONV
        // pv     : this
        // hwnd   : - (not used)
        // wParam : - (not used)
        // lParam : - (not used)
        // pv1    : - (not used)
        // pv2    : - (not used)
        // pic    : - pic
        // pRange : - (not used)
        // fBool  : - (not used)

        // O10 #220177: Simulate VK_HANJA key to invoke HHC
        if (GetAIMM(pic) && (IsOnNT5() || PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) != LANG_JAPANESE))
            {
            keybd_event(VK_HANJA, 0, 0, 0);
            keybd_event(VK_HANJA, 0, KEYEVENTF_KEYUP, 0);
            }
        else
        if (GetSelectionSimple(ec, pic, &pRange) == S_OK)
            {
            if (pKorTip->GetIPComposition(pic))
                pKorTip->DoHanjaConversion(ec, pic, pRange);
            else
                pKorTip->Reconvert(pRange);

            SafeRelease(pRange);
            }
        // Update Hanja button
        pKorTip->m_pToolBar->Update(UPDTTB_HJMODE);
        break;

    ///////////////////////////////////////////////////////////////////////////
    // Reconversion Callbacks
    case ESCB_FINALIZERECONVERSION:
        {
        CCandidateListEx   *pCandList = pess->pCandList;
        CCandidateStringEx *pCandItem = pess->pCandStr;

        pRange       = pess->pRange;
        pszCand   = pCandItem->m_psz;

        Assert(pRange != NULL);

        pKorTip->CloseCandidateUI(pic);
        
        if (GetAIMM(pic) == fFalse)
            {
            if (pszCand)
                {
                //ITfRange *pRangeTmp;
                SetTextAndReading(pKorTip->_GetLibTLS(), ec, pic, pRange,
                          pszCand, 
                          wcslen(pszCand),
                          pCandItem->m_langid, pCandItem->m_pszRead);
                }

            // To clear current selection and composition
            pKorTip->MakeResultString(ec, pic, pRange);
            }
        else
            {
            if (pszCand)
                {
                pRange->SetText(ec, 0, pszCand, 1/* wcslen(pszCand)*/);
                SetSelectionSimple(ec, pic, pRange);
                }
            pKorTip->EndIPComposition(ec, pic); 
            }
            
        // if hit reconversion on composition string, we need to clear automata.
        pAutomata = pKorTip->GetAutomata(pic);
        if (pRange && pAutomata && pAutomata->GetCompositionChar())
            pAutomata->MakeComplete();

        SafeRelease(pRange);
        break;
        }
        
    case ESCB_ONSELECTRECONVERSION:
        break;

    case ESCB_ONCANCELRECONVERSION:
        pRange     = pess->pRange;

        pKorTip->CancelCandidate(ec, pic);

        if (GetAIMM(pic) == fFalse)
            {
            // To clear current selection and composition
            pKorTip->MakeResultString(ec, pic, pRange);
            }
        else
            pKorTip->EndIPComposition(ec, pic); 

        // if hit reconversion on composition string, we need to clear automata.
        pAutomata = pKorTip->GetAutomata(pic);
        if (pRange && pAutomata && pAutomata->GetCompositionChar())
            pAutomata->MakeComplete();

        SafeRelease(pRange);
        break;
        
    case ESCB_RECONV_QUERYRECONV:
        {
        CFnReconversion    *pReconv   = (CFnReconversion *)pess->pv1;
        if (pKorTip->IsCandUIOpen())
            return E_FAIL;
        return pReconv->_QueryRange(ec, pic, pess->pRange, (ITfRange **)pess->pv2);
        }

    case ESCB_RECONV_GETRECONV:
        {
        CFnReconversion    *pReconv   = (CFnReconversion *)pess->pv1;
        if (pKorTip->IsCandUIOpen())
            return E_FAIL;
        return pReconv->_GetReconversion(ec, pic, pess->pRange, (CCandidateListEx **)pess->pv2, pess->fBool);
        }

    case ESCB_RECONV_SHOWCAND:
        {
        ITfComposition* pComposition;
        GUID attr;
        ITfProperty*    pProp = NULL;

        pRange     = pess->pRange;

        pComposition = pKorTip->GetIPComposition(pic);
        if (/*GetAIMM(pic) == fFalse && */ pComposition == NULL)
            {
            pKorTip->CreateIPComposition(ec, pic, pRange);

            // Set input attr and composing state.
            if (SUCCEEDED(pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp)))
                {
                attr = GUID_ATTR_KORIMX_INPUT;
                SetAttrPropertyData(pKorTip->_GetLibTLS(), ec, pProp, pRange, attr);
                pProp->Release();
                }
            }

        pKorTip->OpenCandidateUI(ec, pic, pess->pRange, pess->pCandList);

        break;
        }

    case ESCB_INIT_MODEBIAS:
        // Check mode bias
        //
        //  id         : ESCB_INIT_MODEBIAS
        //  ptip       : this
        //  pic        : pic
        pKorTip->InitializeModeBias(ec, pic);
        break;
    }

    return S_OK;
}

/*---------------------------------------------------------------------------
    CKorIMX::_DIMCallback
---------------------------------------------------------------------------*/
/* static */
HRESULT CKorIMX::_DIMCallback(UINT uCode, ITfDocumentMgr *pdimNew, ITfDocumentMgr *pdimPrev, void *pv)
{
    ITfContext    *pic = NULL;
    CKorIMX       *pKorImx = (CKorIMX *)pv;

    Assert(pKorImx != NULL);
    
    switch (uCode)
        {
    case TIM_CODE_SETFOCUS: 
        if (pdimPrev)
            {
            TraceMsg(DM_TRACE, TEXT("TIM_CODE_SETFOCUS: pdimPrev"));

            pdimPrev->GetTop(&pic);
            pKorImx->OnFocusChange(pic, fFalse);
            
            SafeRelease(pic);
            SafeReleaseClear(pKorImx->m_pCurrentDim);
            }

        if (pdimNew)
            {
            TraceMsg(DM_TRACE, TEXT("TIM_CODE_SETFOCUS: pdimNew"));

            SafeReleaseClear(pKorImx->m_pCurrentDim);

            // Set New dim
            pKorImx->m_pCurrentDim = pdimNew;
            pKorImx->m_pCurrentDim->AddRef();

            pdimNew->GetTop(&pic);
            pKorImx->OnFocusChange(pic, fTrue);

            if (pic)
                pic->Release();
            }
        break;
        }

    return S_OK;
}


/*---------------------------------------------------------------------------
    CKorIMX::_ICCallback

    Document Input Manager callback. ITfThreadMgrEventSink
---------------------------------------------------------------------------*/
/* static */
HRESULT CKorIMX::_ICCallback(UINT uCode, ITfContext *pic, void *pv)
{
    CKorIMX  *_this = (CKorIMX *)pv;

    switch (uCode)
        {
    case TIM_CODE_INITIC:
        if (!_this->IsPendingCleanup())  // ignore new ic's if we're being shutdown.
            {
            _this->_InitICPriv(pic);
            }
        break;

    case TIM_CODE_UNINITIC:
        _this->_DeleteICPriv(pic);
        break;
        }

    return S_OK;
}



/*---------------------------------------------------------------------------
    CKorIMX::_CompEventSinkCallback
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_CompEventSinkCallback(void *pv, REFGUID rguid)
{
    CICPriv* picp = (CICPriv*)pv;
    ITfContext* pic;
    CKorIMX *_this;
    
    if (picp == NULL)
        return S_OK;    // error

    pic = picp->GetIC();

    if (pic == NULL)
        return S_OK;    // error
    
    _this = picp->GetIMX();
    
    if (_this == NULL)
        return S_OK;    // do nothinig

    // if Open/Close compartment
    if (IsEqualGUID(rguid, GUID_COMPARTMENT_KEYBOARD_OPENCLOSE))
        {
        _this->m_pToolBar->Update(UPDTTB_CMODE|UPDTTB_FHMODE);
        }
    else
    // if conversion mode compartment
    if (IsEqualGUID(rguid, GUID_COMPARTMENT_KORIMX_CONVMODE))
        {
        DWORD dwConvMode = _this->GetConvMode(pic);
        BOOL fIsOn = _this->IsOn(pic);

        // We just open for Hangul mode do not close for Alphanumeric mode for Cicero full aware apps.
        // This will prevent redundant Open/Close compartment call.
        if (dwConvMode == TIP_ALPHANUMERIC_MODE && fIsOn)
            _this->SetOnOff(pic, fFalse);
        else
        if (dwConvMode != TIP_ALPHANUMERIC_MODE && fIsOn == fFalse)
            _this->SetOnOff(pic, fTrue);
            
        // SoftKeyboard
        if (_this->IsSoftKbdEnabled())
            {
            if (dwConvMode & TIP_HANGUL_MODE)
                _this->SetSoftKBDLayout(_this->m_KbdHangul.dwSoftKbdLayout);
            else
                _this->SetSoftKBDLayout(_this->m_KbdStandard.dwSoftKbdLayout);
            }
        _this->m_pToolBar->Update(UPDTTB_CMODE|UPDTTB_FHMODE);
        }
    else
    // if SoftKeyboard compartmemnt
    if (IsEqualGUID(rguid, GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE))
        {
        BOOL fSkbdOn = _this->GetSoftKBDOnOff();

        _this->ShowSoftKBDWindow(fSkbdOn);
        if (_this->m_pToolBar && _this->m_pToolBar->GetSkbdMode())
            _this->m_pToolBar->GetSkbdMode()->UpdateToggle();
        }
    else
    // if SoftKeyboard compartmemnt
    if (IsEqualGUID(rguid, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT))
        {
        DWORD   dwSoftLayout, dwCurLabel;
        HRESULT hr;
        
        if (_this->m_pSoftKbd == NULL)
            return E_FAIL;

        dwSoftLayout = _this->GetSoftKBDLayout();
        dwCurLabel   = _this->GetHangulSKbd()->dwCurLabel;
           
           hr = _this->m_pSoftKbd->SelectSoftKeyboard(dwSoftLayout);
           if (FAILED(hr))
               return hr;

        if (dwSoftLayout == _this->m_KbdStandard.dwSoftKbdLayout)
            hr = _this->m_pSoftKbd->SetKeyboardLabelText(GetKeyboardLayout(0));
        else
            hr = _this->m_pSoftKbd->SetKeyboardLabelTextCombination(dwCurLabel);
           if (FAILED(hr))
               return hr;

        if (_this->GetSoftKBDOnOff()) 
            {
            hr = _this->m_pSoftKbd->ShowSoftKeyboard(fTrue);
            return hr;
            }
        }

    return S_OK;
}


/*---------------------------------------------------------------------------
    CKorIMX::_PreKeyCallback
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_PreKeyCallback(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv)
{
    CKorIMX *_this = (CKorIMX *)pv;

    if (_this == NULL)
        return S_OK;
        
    if (IsEqualGUID(rguid, GUID_KOREAN_HANGULSIMULATE))
        {
        DWORD dwConvMode;

        // Toggle Hangul mode
        dwConvMode = _this->GetConvMode(pic);
        dwConvMode ^= TIP_HANGUL_MODE;
        _this->SetConvMode(pic, dwConvMode);

        *pfEaten = fTrue;
        }
    else if (IsEqualGUID(rguid, GUID_KOREAN_HANJASIMULATE))
        {
        // O10 #317983
        if (PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) != LANG_JAPANESE)
            {
            keybd_event(VK_HANJA, 0, 0, 0);
            keybd_event(VK_HANJA, 0, KEYEVENTF_KEYUP, 0);
            *pfEaten = fTrue;
            }
        else
            *pfEaten = fFalse;
        }
        
    return S_OK;
}


/*   O N  E N D  E D I T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CKorIMX::OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    UNREFERENCED_PARAMETER(ecReadOnly);
    static const GUID *rgModeBiasProperties[] =
        {
        &GUID_PROP_MODEBIAS 
        };

    static const GUID *rgAttrProperties[] =
        {
        &GUID_PROP_ATTRIBUTE, 
        };

    CEditSession2 *pes;
    ESSTRUCT ess;
    HRESULT  hr;
    BOOL fInWriteSession;
    CICPriv *picp;
    IEnumTfRanges *pEnumText = NULL;
    ITfRange *pRange = NULL;
    ULONG     ulFetched = 0;
    BOOL      fCallES = fFalse;
    BOOL      fSelChanged = fFalse;

    Assert(pic != NULL);
    if (pic == NULL)
        return S_OK;    // error


    pic->InWriteSession(GetTID(), &fInWriteSession);
    if (fInWriteSession)
        return S_OK;                // own change.

    picp = GetInputContextPriv(pic);
    if (picp == NULL)
        return S_OK;    // error

    if (picp->GetfTransaction())
        return S_OK;                // skip in transaction.

    //////////////////////////////////////////////////////////////////////////
    // Init to call ESCB_TEXTEVENT
    ESStructInit(&ess, ESCB_TEXTEVENT);

    // Call ESCB_TEXTEVENT callback only if GUID_PROP_MODEBIAS changed.
    hr = pEditRecord->GetTextAndPropertyUpdates(0/*TF_GTP_INCL_TEXT*/, rgModeBiasProperties, ARRAYSIZE(rgModeBiasProperties), &pEnumText);
    if (FAILED(hr) || pEnumText == NULL)
        return S_OK;
    if (pEnumText->Next(1, &pRange, &ulFetched) == S_OK)
        {
        SafeRelease(pRange);
        // ModeBias changed.
        ess.fBool = fTrue;
        }
    pEnumText->Release();

    // Selection changed?
    pEditRecord->GetSelectionStatus(&fSelChanged);

    // If Attribute changed, set selection change true.
    if (fSelChanged == fFalse)
        {
        hr = pEditRecord->GetTextAndPropertyUpdates(0/*TF_GTP_INCL_TEXT*/, rgAttrProperties, ARRAYSIZE(rgAttrProperties), &pEnumText);
        if (FAILED(hr) || pEnumText == NULL)
            return S_OK;
        if (pEnumText->Next(1, &pRange, &ulFetched) == S_OK)
            {
            SafeRelease(pRange);
            fSelChanged = fTrue;
            }
        pEnumText->Release();
        }
    
    // Perf: Call ES only if (ModeBias change) or (Selection changed and comp object exist)
    //       I guess calling ES is pretty much costing since sel change occurs for ever cursor move.
    if (fSelChanged)
        fSelChanged = (GetIPComposition(pic) != NULL) ? fTrue : fFalse;

    // If ModeBias changed or Selection changed, then call ESCB_TEXTEVENT sink
    if (ess.fBool || fSelChanged)
        {
        if ((pes = new CEditSession2( pic, this, &ess, _EditSessionCallback2 )) != NULL)
            {
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        }

    return S_OK;
}


/*   O N  S T A R T  E D I T  T R A N S A C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CKorIMX::OnStartEditTransaction(ITfContext *pic)
{
    CICPriv *picp;

    if (pic == NULL)
        return S_OK;    // error

    picp = GetInputContextPriv(pic);
    if (picp)
        picp->SetfTransaction(fTrue);

    return S_OK;
}


/*   O N  E N D  E D I T  T R A N S A C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CKorIMX::OnEndEditTransaction(ITfContext *pic)
{
    BOOL ftran;
    CICPriv *picp;

    if (pic == NULL)
        return S_OK;    // error

    picp = GetInputContextPriv(pic);
    if (picp)
        {
        ftran = picp->GetfTransaction();
        if (ftran)
            {
            CEditSession2    *pes;
            ESSTRUCT        ess;
            HRESULT            hr;

            picp->SetfTransaction(fFalse);

            ESStructInit(&ess, ESCB_TEXTEVENT);
            ess.pEnumRange = NULL;

            if ((pes = new CEditSession2( pic, this, &ess, _EditSessionCallback2 )) != NULL)
                {
                pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
                pes->Release();
                }
            }
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\activate.cpp ===
/****************************************************************************
   ACTIVATE.CPP : Init/Uninit Cicero services on the thread

   History:
      24-JAN-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "immxutil.h"
#include "globals.h"
#include "kes.h"
#include "timsink.h"
#include "funcprv.h"
#include "insert.h"
#include "pad.h"
#include "helpers.h"
#include "osver.h"


// Hangul and Hanja key simulation for Non-Korean Win9x and NT4
static const KESPRESERVEDKEY g_prekeyList[] = 
{
       { &GUID_KOREAN_HANGULSIMULATE, { VK_MENU,     TF_MOD_RALT },       L"Hangul" },
       { &GUID_KOREAN_HANJASIMULATE,  { VK_CONTROL,  TF_MOD_RCONTROL },   L"Hanja"  },
       { NULL,  { 0,    0}, NULL }
};

/*---------------------------------------------------------------------------
    CKorIMX::Activate
    
    Initialize Cicero services on the thread
---------------------------------------------------------------------------*/
STDAPI CKorIMX::Activate(ITfThreadMgr *ptim, TfClientId tid)
{
    ITfKeystrokeMgr   *pIksm = NULL;
    ITfSource         *pISource;
    ITfSourceSingle      *pISourceSingle;
    BOOL              fThreadFocus;    
    HRESULT           hr = E_FAIL;

    // Keep current Thread ID
    m_tid = tid;

    // Get ITfThreadMgr and ITfDocumentMgr
    Assert(GetTIM() == NULL);
    m_ptim = ptim;
    m_ptim->AddRef();

    //////////////////////////////////////////////////////////////////////////
    // Get key stroke manager(ITfKeystrokeMgr) in current TIM
    if (FAILED(hr = GetService(GetTIM(), IID_ITfKeystrokeMgr, (IUnknown **)&pIksm)))
        goto Exit;

    //////////////////////////////////////////////////////////////////////////
    // Create ITfThreadMgrEventSink and set Call back function as _DocInputMgrCallback
    if ((m_ptimEventSink = new CThreadMgrEventSink(_DIMCallback, _ICCallback, this)) == NULL)
        {
        Assert(0); // bugbug
        hr = E_OUTOFMEMORY;
        goto Exit;
        }
    m_ptimEventSink->_Advise(GetTIM());
    
    //////////////////////////////////////////////////////////////////////////
    // Get IID_ITfThreadFocusSink cookie
    if (GetTIM()->QueryInterface(IID_ITfSource, (void **)&pISource) == S_OK)
        {
        pISource->AdviseSink(IID_ITfThreadFocusSink, (ITfThreadFocusSink *)this, &m_dwThreadFocusCookie);
        pISource->AdviseSink(IID_ITfActiveLanguageProfileNotifySink, (ITfActiveLanguageProfileNotifySink *)this, &m_dwProfileNotifyCookie);
        pISource->Release();
        }

    // ITfCleanupContextDurationSink
    if (GetTIM()->QueryInterface(IID_ITfSourceSingle, (void **)&pISourceSingle) == S_OK)
        {
        pISourceSingle->AdviseSingleSink(m_tid, IID_ITfCleanupContextDurationSink, (ITfCleanupContextDurationSink *)this);
        pISourceSingle->Release();
        }

    // Set conversion mode compartment to null status.
    SetCompartmentDWORD(m_tid, m_ptim, GUID_COMPARTMENT_KORIMX_CONVMODE, TIP_NULL_CONV_MODE, fFalse);
        
    // Korean Kbd driver does not exist in system(Non Korean NT4, Non Korean WIN9X)
    m_fNoKorKbd = (g_uACP != 949) && (IsOn95() || IsOn98() || (IsOnNT() && !IsOnNT5()));

    //////////////////////////////////////////////////////////////////////////
    // Create Keyboard Sink(ITfKeyEventSink)
    // From Cicero Doc: Keyboard TIP must provide this KeyEventSink interface to get the key event.
    //                  Using this sink, TIPs can get the notification of getting or losing keyboard focus
    if (m_fNoKorKbd)
        m_pkes = new CKeyEventSink(_KeyEventCallback, _PreKeyCallback, this);
    else
        m_pkes = new CKeyEventSink(_KeyEventCallback, this);
    
    if (m_pkes == NULL)
        {    
        hr = E_OUTOFMEMORY;
        goto Exit;
        }

    hr = pIksm->AdviseKeyEventSink(GetTID(), m_pkes, fTrue);
    if (FAILED(hr))
        goto Exit;

    if (m_fNoKorKbd)
        {
           hr = m_pkes->_Register(GetTIM(), GetTID(), g_prekeyList);
        if (FAILED(hr))
        goto Exit;
        }

    //////////////////////////////////////////////////////////////////////////
    // Create status window
    m_hOwnerWnd = CreateWindowEx(0, c_szOwnerWndClass, TEXT(""), WS_DISABLED, 0, 0, 0, 0, NULL, 0, g_hInst, this);

    //////////////////////////////////////////////////////////////////////////
    // Register Function Provider. Reconversion etc.
    m_pFuncPrv = new CFunctionProvider(this);
    m_pFuncPrv->_Advise(GetTIM());

    // Create Pad Core
	m_pPadCore = new CPadCore(this);
	if (m_pPadCore == NULL)
	    {
		goto Exit;
	    }
    //////////////////////////////////////////////////////////////////////////
    // Create Toolbar
    m_pToolBar = new CToolBar(this);
    if (m_pToolBar == NULL)
        goto Exit;

    if (!m_pToolBar->Initialize())
        goto Exit;

    m_ptimEventSink->_InitDIMs(fTrue);

    //////////////////////////////////////////////////////////////////////////
    // Init UI
    if (GetTIM()->IsThreadFocus(&fThreadFocus) == S_OK && fThreadFocus)
        {
        // init any UI
        OnSetThreadFocus();
        }

    if (m_pInsertHelper = new CCompositionInsertHelper)
        {
        // optional, default is DEF_MAX_OVERTYPE_CCH in insert.h
        // use 0 to avoid allocating any memory
        // set the limit on number of overtype chars that
        // the helper will backup
        m_pInsertHelper->Configure(0);
        }

    m_pToolBar->CheckEnable();                // update toolbar

    // Clear SoftKbd On/Off status backup
    // m_fSoftKbdOnOffSave = fFalse;
    // Clear SoftKbd On/Off status backup
    // m_fSoftKbdOnOffSave = GetSoftKBDOnOff();
    if (m_fSoftKbdOnOffSave)
        {
        SetSoftKBDOnOff(fTrue);
        }

    hr = S_OK;

Exit:
    SafeRelease(pIksm);

    return hr;
}

/*---------------------------------------------------------------------------
    CKorIMX::Deactivate
    
    Uninitialize Cicero services on the thread
---------------------------------------------------------------------------*/
STDAPI CKorIMX::Deactivate()
{
    ITfKeystrokeMgr   *pksm = NULL;
    ITfSource         *pISource;
    ITfSourceSingle      *pISourceSingle = NULL;    
    BOOL              fThreadFocus;
    HRESULT           hr = E_FAIL;

    // close candidate UI
    if (m_pCandUI != NULL) 
        {
        CloseCandidateUIProc();
        m_pCandUI->Release();
        m_pCandUI = NULL;
        }

    // pad core
	if (m_pPadCore)
	    {
		delete m_pPadCore;
		m_pPadCore = NULL;
	    }

    // toolbar
    if (m_pToolBar) 
        {
        m_pToolBar->Terminate();
        delete m_pToolBar;
        m_pToolBar = NULL;
        }
    
    if (GetTIM()->IsThreadFocus(&fThreadFocus) == S_OK && fThreadFocus)
        {
        // shutdown any UI
        OnKillThreadFocus();
        }

    ///////////////////////////////////////////////////////////////////////////
    // Unadvise IID_ITfThreadFocusSink cookie
    if (GetTIM()->QueryInterface(IID_ITfSource, (void **)&pISource) == S_OK)
        {
        pISource->UnadviseSink(m_dwThreadFocusCookie);
        pISource->UnadviseSink(m_dwProfileNotifyCookie);
        pISource->Release();
        }

    if (GetTIM()->QueryInterface(IID_ITfSourceSingle, (void **)&pISourceSingle) == S_OK)
        {
        pISourceSingle->UnadviseSingleSink(m_tid, IID_ITfCleanupContextDurationSink);
        pISourceSingle->Release();
        }
        
    if (FAILED(hr = GetService(GetTIM(), IID_ITfKeystrokeMgr, (IUnknown **)&pksm)))
        goto Exit;

    // Release TIM event sink
    if (m_ptimEventSink != NULL)
        {
        m_ptimEventSink->_InitDIMs(fFalse);        
        m_ptimEventSink->_Unadvise();
        SafeReleaseClear(m_ptimEventSink);
        }

    // Release Key event sink
    if (m_pkes)
        {
        if (m_fNoKorKbd)
            m_pkes->_Unregister(GetTIM(), GetTID(), g_prekeyList);
        SafeReleaseClear(m_pkes);
        }

    // Delete SoftKbd
    if (IsSoftKbdEnabled())
        TerminateSoftKbd();
    
    // Release Key Event Sink
    pksm->UnadviseKeyEventSink(GetTID());
    DestroyWindow(m_hOwnerWnd);

    m_pFuncPrv->_Unadvise(GetTIM());

    SafeReleaseClear(m_pFuncPrv);
    SafeReleaseClear(m_ptim);

    //
    // Free per-thread object that lib uses.
    //
    TFUninitLib_Thread(&m_libTLS);

    SafeReleaseClear(m_pInsertHelper);
    
    hr = S_OK;

Exit:
    SafeRelease(pksm);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\candkey.h ===
//
// candkey.h
//

#if !defined (__CANDKEY_H__INCLUDED_)
#define __CANDKEY_H__INCLUDED_

#include "private.h"
#include "mscandui.h"

//
// CCandUIKeyTable
//

class CCandUIKeyTable : public ITfCandUIKeyTable
{
public:
	CCandUIKeyTable(int nData);
	~CCandUIKeyTable();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//
	// ITfCandUIKeyTable
	//
	STDMETHODIMP GetKeyDataNum(int *piNum);
	STDMETHODIMP GetKeyData(int iData, CANDUIKEYDATA *pData);

	//
	//
	//
	HRESULT AddKeyData(const CANDUIKEYDATA *pData);

protected:
	long          m_cRef;
	CANDUIKEYDATA *m_pData;
	int           m_nData;
	int           m_nDataMax;
};

#endif // __CANDKEY_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\setup\migexe\winmain.cpp ===
/****************************************************************************
   WINMAIN.CPP : Per-user migration and reg install

   History:
      22-SEP-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include <shlobj.h>
#include "hklhelp.h"
#include "msctf.h"
#include "shlwapi.h"

// IME 2002 main module
#define SZMODULENAME_MAIN		"imekr.ime"

// IME Main HKLM Reg
#define SZIMEREG_MAIN_ROOT   	"Software\\Microsoft\\IMEKR\\6.0"
#define SZIMEREG_MAIN_ROOT_MIG 	SZIMEREG_MAIN_ROOT"\\MigrateUser"

#define MAJORVER "6.0"
#define IME_REGISTRY_LATEST_VERSION  "Software\\Microsoft\\IMEKR"  //The latest version of IME installed in the system 
								   	//will always be stored at HKLM\Software\Microsoft\IMEKR 
								   //even if it's system IME. 

extern BOOL WINAPI IsNT();

// Private functions
static void CheckForOtherUsers();
static void MigrateUserData();
static void WriteHKCUData();
static void DisableTip();
static void GetSIDString(LPSTR tszBuffer, SIZE_T cbBuffLen);
static BOOL GetTextualSid(PSID pSid, LPSTR TextualSid, LPDWORD dwBufferLen);
static PSID KYGetCurrentSID();
static POSVERSIONINFO GetVersionInfo();

/*---------------------------------------------------------------------------
	WinMain
---------------------------------------------------------------------------*/
INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
	HKEY hKey;
	BOOL fMigrated = fFalse;
	BOOL fRunAlreadyForThisUser = fFalse;
	CHAR szBuffer[500];
	BOOL fSetDefault = fFalse;
	
	// Check if this user already migrated
	if (RegOpenKeyEx(HKEY_CURRENT_USER, SZIMEREG_MAIN_ROOT, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
		{
		if (RegQueryValueEx(hKey, "Migrated", NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
			fMigrated = fTrue;	// Already migrated
		RegCloseKey(hKey);
		}

	// In case no HKCU IME main root key or "Migrated" is not exist
	if (fMigrated == fFalse)
		{
		DWORD dwMigrated = 1;

		// It could possibe there is no HKCU\SZIMEREG_MAIN_ROOT, so we create it here.
		if (RegCreateKey(HKEY_CURRENT_USER, SZIMEREG_MAIN_ROOT, &hKey) == ERROR_SUCCESS) 
			{
			// Set migrated reg.
			RegSetValueEx(hKey, "Migrated", 0, REG_DWORD, (BYTE *)&dwMigrated, sizeof(DWORD));
			RegCloseKey(hKey);
			}
		}

	if (IsNT())
		GetSIDString(szBuffer, sizeof(szBuffer)); // get the sid of the current user
	else
		{
		DWORD cbBuffer = sizeof(szBuffer);
		GetUserName(szBuffer, &cbBuffer);
		}

	// if sid exists under HKLM\Software\Microsoft\IMEKR\6.0\MigrateUser migrate and delete sid from reg
	// if sid does not exist == this user didn't exist when ime was installed?
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZIMEREG_MAIN_ROOT_MIG, 0, KEY_ALL_ACCESS, &hKey))
		{
		if (ERROR_SUCCESS == RegQueryValueEx(hKey, szBuffer, NULL, NULL, NULL, NULL))
			{
			RegDeleteValue(hKey, szBuffer);
			fRunAlreadyForThisUser = fFalse;
			}
		else
			fRunAlreadyForThisUser = fTrue;

		RegCloseKey(hKey);
		}


	CheckForOtherUsers();

	// O10 #316759 
	// For per-user install. If this is per-user install(non-admin), SID list won't be created.
	// Darwin custom action set parameter "/Force" to we force to set preload.
	if (lpCmdLine && StrStrI(lpCmdLine, "/Force"))
		fRunAlreadyForThisUser = fFalse;
	
	// 1. Do migrate
	if (fMigrated == fFalse)
		MigrateUserData();

	if (fRunAlreadyForThisUser == fFalse)
		{
		HKEY hKey;
		CHAR szVersion[MAX_PATH];
		DWORD cbVersion = MAX_PATH;

		// 2. Reset Show Status
		if (RegOpenKeyEx(HKEY_CURRENT_USER, "Control Panel\\Input Method", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
			LPSTR szStatus = "1";
			
		   	RegSetValueEx(hKey, "Show Status", 0, REG_SZ, (BYTE *)szStatus, (sizeof(CHAR)*lstrlen(szStatus)));
		    RegCloseKey(hKey);
			}

		// Add IME to preload only when it is the latest IME existing in the system
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, IME_REGISTRY_LATEST_VERSION, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
			{
			if (RegQueryValueEx(hKey, "version", NULL, NULL, (BYTE *)szVersion, &cbVersion) == ERROR_SUCCESS)
				{
				if (lstrcmpi(szVersion, MAJORVER) == 0)
					fSetDefault = fTrue;
				}
			RegCloseKey(hKey);
			}

		// 3. Write any HKCU data (Set IME2002 as default TIP and Set preload)
		if (fSetDefault)
			WriteHKCUData();
		else
			DisableTip();
		}
		
	return(0);
}

//////////////////////////////////////////////////////////////////////////////
// Private functions
//////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
	MigrateUserData

	This function migrate BeolSik and K1 Hanja setting
	Search IME98, Win95 IME, NT4 IME and AIME reg.
---------------------------------------------------------------------------*/
void MigrateUserData()
{
	const INT iMaxIMERegKeys = 4;
	static LPSTR rgszIME98RegKeys[iMaxIMERegKeys] = 
			{
			// IME98
			"Software\\Microsoft\\Windows\\CurrentVersion\\IME\\Korea\\IMEKR98U",
			// Win95 IME
			"Software\\Microsoft\\Windows\\CurrentVersion\\MSIME95",
			// Kor NT4 IME
			"Software\\Microsoft\\Windows\\CurrentVersion\\MSIME95K",
			// Korean AIME
			"Software\\Microsoft\\Windows\\CurrentVersion\\Wansung"
			};

	// Beolsik value
	static CHAR szBeolsik[]	= "InputMethod";
	// K1 Hanja enable(IME98 only)
	static CHAR szEnableK1Hanja[] = "KSC5657";

	HKEY	hKey;
    DWORD	dwCb, dwIMEKL, dwKSC5657;

	// Set default values
	dwIMEKL = dwKSC5657 = 0;

	for (INT i=0; i<iMaxIMERegKeys; i++)
		{
		if (RegOpenKeyEx(HKEY_CURRENT_USER, rgszIME98RegKeys[i], 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
			{
			///////////////////////////////////////////////////////////////////
			// Get Beolsik
			dwCb = sizeof(dwIMEKL);
			if (RegQueryValueEx(hKey, szBeolsik, NULL, NULL, (LPBYTE)&dwIMEKL, &dwCb) != ERROR_SUCCESS) 
				{
				dwIMEKL = 0;
				}

			///////////////////////////////////////////////////////////////////
			// Get K1 Hanja Setting
			dwCb = sizeof(dwKSC5657);
			if (RegQueryValueEx(hKey, szEnableK1Hanja, NULL, NULL, (LPBYTE)&dwKSC5657, &dwCb) != ERROR_SUCCESS) 
				{
				dwKSC5657 = 0;
				}

			RegCloseKey(hKey);
			// Break for loop
			break;
			}
		}

	// Set values to IME2002 reg
	if (RegCreateKey(HKEY_CURRENT_USER, SZIMEREG_MAIN_ROOT, &hKey) == ERROR_SUCCESS) 
		{
		// 1. BeolSik
		dwCb = sizeof(dwIMEKL);
		if (dwIMEKL >= 100 && dwIMEKL <= 102)
			dwIMEKL -= 100;
		else
		if (dwIMEKL > 2) // Only accept 0, 1, 2
			dwIMEKL = 0;
		RegSetValueEx(hKey, szBeolsik, 0, REG_DWORD, (LPBYTE)&dwIMEKL, dwCb);

		// K1 Hanja flag
		if (dwKSC5657 != 0 && dwKSC5657 != 1) // Only accept 0 or 1
			dwKSC5657 = 0;
		RegSetValueEx(hKey, szEnableK1Hanja, 0, REG_DWORD, (LPBYTE)&dwKSC5657, dwCb);

		RegCloseKey(hKey);
		}
}

// KorIMX CLSID
// {766A2C14-B226-4fd6-B52A-867B3EBF38D2}
extern const CLSID CLSID_KoreanKbdTip  =  {
    0x766A2C14,
    0xB226,
    0x4FD6,
    {0xb5, 0x2a, 0x86, 0x7b, 0x3e, 0xbf, 0x38, 0xd2}
  };

const GUID g_guidKorProfile = 
// {E47ABB1E-46AC-45f3-8A89-34F9D706DA83}
{	0xe47abb1e,
	0x46ac,
	0x45f3,
	{0x8a, 0x89, 0x34, 0xf9, 0xd7, 0x6, 0xda, 0x83}
};

/*---------------------------------------------------------------------------
	WriteHKCUData
---------------------------------------------------------------------------*/
void WriteHKCUData()
{
	// Set default Tip as for Cicero.
	CoInitialize(NULL);

	ITfInputProcessorProfiles *pProfile;
	HRESULT hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, 
									IID_ITfInputProcessorProfiles, (void **) &pProfile);
	if (SUCCEEDED(hr)) 
		{
		pProfile->SetDefaultLanguageProfile(MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), 
											CLSID_KoreanKbdTip, g_guidKorProfile);
	    pProfile->Release();
		}

	CoUninitialize();

	// Clean up HKCU preload reg. (Remove old IME)
	AddPreload(HKEY_CURRENT_USER, GetHKLfromHKLM("imekr.ime"));

}
/*---------------------------------------------------------------------------
	DisableTip
	Hide IME 2002 tip from Toolbar
---------------------------------------------------------------------------*/
void DisableTip()
{
	// Set default Tip as for Cicero.
	CoInitialize(NULL);

	ITfInputProcessorProfiles *pProfile;
	HRESULT hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, 
									IID_ITfInputProcessorProfiles, (void **) &pProfile);
	if (SUCCEEDED(hr)) 
		{
		pProfile->EnableLanguageProfile(CLSID_KoreanKbdTip, 
										MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), g_guidKorProfile, fFalse);
										
	    pProfile->Release();
		}

	CoUninitialize();
}

/*---------------------------------------------------------------------------
	CheckForOtherUsers
---------------------------------------------------------------------------*/
void CheckForOtherUsers(void)
{
	HKEY hKey, hRunKey;
	CHAR szValueName[MAX_PATH];
	DWORD cbValueName = MAX_PATH;

	BOOL fRemoveRunKey = fFalse;

	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZIMEREG_MAIN_ROOT_MIG, 0, KEY_READ, &hKey))
		{
		// if no more users left for migration, remove HKLM "run" reg
		if (ERROR_NO_MORE_ITEMS == RegEnumValue(hKey, 0, szValueName, &cbValueName, NULL, NULL, NULL, NULL))
			fRemoveRunKey = fTrue;
		RegCloseKey(hKey);
		}
	else
		fRemoveRunKey = fTrue;

	if (fRemoveRunKey && (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_ALL_ACCESS, &hRunKey)))
		{
		RegDeleteValue(hRunKey, "imekrmig");
		RegCloseKey(hRunKey);
		}
}


/*---------------------------------------------------------------------------
	GetTextualSid
---------------------------------------------------------------------------*/
BOOL GetTextualSid(PSID pSid, LPSTR TextualSid, LPDWORD dwBufferLen)
{
	PSID_IDENTIFIER_AUTHORITY psia;
	DWORD dwSubAuthorities;
	DWORD dwSidRev=SID_REVISION;
	DWORD dwCounter;
	DWORD dwSidSize;

	if (!IsValidSid(pSid)) 
		return FALSE;

	// SidIdentifierAuthority ???
	psia=GetSidIdentifierAuthority(pSid);

	dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

	// S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
	dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

	if (*dwBufferLen < dwSidSize)
		{
		*dwBufferLen = dwSidSize;
		SetLastError(ERROR_INSUFFICIENT_BUFFER);
		return FALSE;
		}

	// S-SID_REVISION
	dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );

	// SidIdentifierAuthority
	if ((psia->Value[0] != 0) || (psia->Value[1] != 0))
		{
		dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
						TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
						(USHORT)psia->Value[0],
						(USHORT)psia->Value[1],
						(USHORT)psia->Value[2],
						(USHORT)psia->Value[3],
						(USHORT)psia->Value[4],
						(USHORT)psia->Value[5]);
		}
	else
		{
		dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
						TEXT("%lu"),
						(ULONG)(psia->Value[5]      )   +
						(ULONG)(psia->Value[4] <<  8)   +
						(ULONG)(psia->Value[3] << 16)   +
						(ULONG)(psia->Value[2] << 24)   );
		}

	// SidSubAuthorities
	for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
		{
		dwSidSize += wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
							*GetSidSubAuthority(pSid, dwCounter) );
		}

	return fTrue;
}

/*---------------------------------------------------------------------------
	KYGetCurrentSID
---------------------------------------------------------------------------*/
PSID KYGetCurrentSID()
{
   HANDLE hToken = NULL;
   BOOL bSuccess;
   #define MY_BUFSIZE 512  // highly unlikely to exceed 512 bytes
   static UCHAR InfoBuffer[MY_BUFSIZE];
   DWORD cbInfoBuffer = MY_BUFSIZE;

/*   
   if(!OpenThreadToken(                             // Don't try to get thread owner. Just get process owner.
       GetCurrentThread(),                          // This is to fix Satori:#1265.
                                                    //
       TOKEN_QUERY,                                 // Winlogon.exe has something special characteristics that
       TRUE,                                        // it has many threads and some of them is owned by different
       &hToken                                      // user from owner of the process.
       )) {
                                                    // More concrete, winlogon's process owner is SYSTEM, but
                                                    // some certain thread of the process is owned by logon user.
                                                    // If KYGetCurrentSID runs on such special thread, this 
                                                    // function will return SID for logon user. But actually this
                                                    // process runs on SYSTEM user context, this results .Default
                                                    // user's Registry data loaded on shared memory for logon user.
                                                    // Even on such thread, HKCU is mapped to HKU\.Default, so we
                                                    // have to abondon to let the thread loads logon user's registry
                                                    // on logon user's shared memory. Instead, we just refer proces
                                                    // owner (not thread owner) which doesn't conflict with HKCU.
                                                    // As a result, winlogon always get SID for SYSTEM, regardless
                                                    // on which thread we're running, resulting winlogon loads
                                                    // SYSTEM's registry to SYSTEM's shared memory.
                                                    
                                                    // This change may affect on other process that has multiple
                                                    // threads owned by different user from process's owner. But
                                                    // practically we can assume there're almost no chance for IME
                                                    // to run on such threads.            4/27/2000 [KotaroY]

       if(GetLastError() == ERROR_NO_TOKEN) {

           //
           // attempt to open the process token, since no thread token
           // exists
           //
*/
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) 
			return(NULL);
/*
       } else {

           //
           // error trying to get thread token
           //

           return(NULL);
       }
   }
*/
	bSuccess = GetTokenInformation(
						hToken,
						TokenUser,
						InfoBuffer,
						cbInfoBuffer,
						&cbInfoBuffer
						);

	if (!bSuccess)
		{
		if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
			{
			//
			// alloc buffer and try GetTokenInformation() again
			//

			CloseHandle(hToken);
			return(NULL);
			}
		else
			{
			//
			// error getting token info
			//

			CloseHandle(hToken);
			return(NULL);
			}
		}

	CloseHandle(hToken);

	return(((PTOKEN_USER)InfoBuffer)->User.Sid);
}

/*---------------------------------------------------------------------------
	GetSIDString
---------------------------------------------------------------------------*/
void GetSIDString(LPSTR tszBuffer, SIZE_T cbBuffLen)
{
    DWORD cbBuffer = cbBuffLen;
    
    if (!GetTextualSid(KYGetCurrentSID(), tszBuffer, &cbBuffer))
        tszBuffer[0] = 0;
}

/*---------------------------------------------------------------------------
	GetVersionInfo
---------------------------------------------------------------------------*/
POSVERSIONINFO GetVersionInfo()
{
    static BOOL fFirstCall = fTrue;
    static OSVERSIONINFO os;

    if (fFirstCall)
    	{
        os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&os))
            fFirstCall = fFalse;
	    }

    return &os;
}

/*---------------------------------------------------------------------------
	IsNT
---------------------------------------------------------------------------*/
BOOL WINAPI IsNT()
{ 
    BOOL fResult;
    fResult = (GetVersionInfo()->dwPlatformId == VER_PLATFORM_WIN32_NT);

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\candlstx.h ===
//
// candlst.h
//

#ifndef CANDLST_H
#define CANDLST_H

#include "private.h"
#include "mscandui.h"
#include "ptrary.h"

#define IEXTRACANDIDATE		(UINT)(-2)

class CCandidateStringEx;
class CCandidateListEx;

typedef HRESULT (*CANDLISTCALLBACKEX)(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandLst, CCandidateStringEx *pCand, TfCandidateResult imcr);

//
// CCandidateStringEx
//

class CCandidateStringEx : public ITfCandidateString,
						   public ITfCandidateStringInlineComment,
						   public ITfCandidateStringColor
{
public:
	CCandidateStringEx(int nIndex, LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk);
	~CCandidateStringEx();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	//
	// ITfCandidateString
	//
	STDMETHODIMP GetString(BSTR *pbstr);
	STDMETHODIMP GetIndex(ULONG *pnIndex);

	//
	// ITfCandidateStringInlineComment
	//
	STDMETHODIMP GetInlineCommentString(BSTR *pbstr);

	//
	// ITfCandidateStringColor
	//
	STDMETHODIMP GetColor(CANDUICOLOR *pcol);

#if 0
	//
	// ITfCandidateStringPopupComment
	//
	STDMETHODIMP GetPopupCommentString( BSTR *pbstr );
	STDMETHODIMP GetPopupCommentGroupID( DWORD *pdwGroupID );

	//
	// ITfCandidateStringFixture
	//
	STDMETHODIMP GetPrefixString( BSTR *pbstr );
	STDMETHODIMP GetSuffixString( BSTR *pbstr );

	// 
	// ITfCandidateStringIcon
	//
	STDMETHODIMP GetIcon( HICON *phIcon );
#endif

	//
	// internal
	//
	HRESULT SetReadingString(LPCWSTR psz);
	HRESULT SetInlineComment(LPCWSTR psz);
#if 0
	HRESULT SetPopupComment(LPCWSTR psz, DWORD dwGroupID);
	HRESULT SetPrefixString(LPCWSTR psz);
	HRESULT SetSuffixString(LPCWSTR psz);
#endif

	void 		*m_pv;
	IUnknown 	*m_punk;
	LPWSTR 		m_psz;
	LPWSTR 		m_pszRead;
	LANGID 		m_langid;
	WORD  		m_bHanjaCat;

protected:
	int 		m_cRef;
	int 		m_nIndex;
	LPWSTR		m_pszInlineComment;
#if 0
	LPWSTR		m_pszPopupComment;
	DWORD		m_dwPopupCommentGroupID;
	LPWSTR		m_pszPrefix;
	LPWSTR		m_pszSuffix;
#endif
};


//
// CCandidateListEx
//

class CCandidateListEx : public ITfCandidateList,
						 public ITfCandidateListExtraCandidate
{
public:
	CCandidateListEx(CANDLISTCALLBACKEX pfnCallback, ITfContext *pic, ITfRange *pRange);
	~CCandidateListEx();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	//
	// ITfCandidateList
	//
	STDMETHODIMP EnumCandidates(IEnumTfCandidates **ppEnum);
	STDMETHODIMP GetCandidate(ULONG nIndex, ITfCandidateString **ppCand);
	STDMETHODIMP GetCandidateNum(ULONG *pnCnt);
	STDMETHODIMP SetResult(ULONG nIndex, TfCandidateResult imcr);

	//
	// ITfCandidateListExtraCandidate
	//
	STDMETHODIMP GetExtraCandidate(ITfCandidateString **ppCand);

  	//
	// internal
	//
	HRESULT AddString(LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk, CCandidateStringEx **ppCandStr);
	HRESULT SetInitialSelection(ULONG iSelection);
	HRESULT GetInitialSelection(ULONG *piSelection);
	HRESULT AddExtraString( LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk, CCandidateStringEx **ppCandStr );

	CPtrArray<CCandidateStringEx> 	m_rgCandStr;

protected:
	int 				m_cRef;
	ITfContext 			*m_pic;
	ITfRange 			*m_pRange;
	ITfFnReconversion 	*m_pReconv;
	CANDLISTCALLBACKEX 	m_pfnCallback;
	int					m_iInitialSelection;
	CCandidateStringEx	*m_pExtraCand;
};


//
// CEnumCandidatesEx
//

class CEnumCandidatesEx : public IEnumTfCandidates
{
public:
	CEnumCandidatesEx(CCandidateListEx *pList);
	~CEnumCandidatesEx();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	//
	// ITfEnumCandidates
	//
	STDMETHODIMP Clone(IEnumTfCandidates **ppEnum);
	STDMETHODIMP Next(ULONG ulCount, ITfCandidateString **ppCand, ULONG *pcFetched);
	STDMETHODIMP Reset();
	STDMETHODIMP Skip(ULONG ulCount);

private:
	int 			 m_cRef;
	CCandidateListEx *m_pList;
	int 			 m_nCur;
};

#endif // CCANDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\canduies.h ===
//
// canduies.h
//

#ifndef CANDUIES_H
#define CANDUIES_H

#include "private.h"
#include "korimx.h"
#include "globals.h"
#include "mscandui.h"


//
// Callback functions
//

typedef HRESULT (*PFNONBUTTONPRESSED)(LONG id, ITfContext *pic, void *pVoid);
typedef HRESULT (*PFNONFILTEREVENT)(CANDUIFILTEREVENT ev, ITfContext *pic, void *pVoid);
typedef HRESULT (*PFNINITMENU)(ITfMenu *pMenu, ITfContext *pic, void *pVoid);
typedef HRESULT (*PFNONCANDUIMENUCOMMAND)( UINT uiCmd, ITfContext *pic, void *pVoid);


//
// CCandUIExtButtonEventSink
//

class CCandUIExtButtonEventSink : public ITfCandUIExtButtonEventSink
{
public:
	CCandUIExtButtonEventSink(PFNONBUTTONPRESSED pfnOnButtonPressed, ITfContext *pic, void *pVoid);
	~CCandUIExtButtonEventSink();
	
	//
	// IUnknown
	//
	STDMETHODIMP QueryInterface( REFIID riid, void **ppvObj );
	STDMETHODIMP_(ULONG) AddRef( void );
	STDMETHODIMP_(ULONG) Release( void );

	//
	// ITfCandUIExtButtonEventSink
	//
	STDMETHODIMP OnButtonPressed(LONG id);

protected:
	long 				m_cRef;
	ITfContext			*m_pic;
	void				*m_pv;
	PFNONBUTTONPRESSED	m_pfnOnButtonPressed;
};


//
// CCandUIAutoFilterEventSink
//

class CCandUIAutoFilterEventSink : public ITfCandUIAutoFilterEventSink
{
public:
	CCandUIAutoFilterEventSink(PFNONFILTEREVENT pfnOnFilterEvent, ITfContext *pic, void *pVoid);
	~CCandUIAutoFilterEventSink();
	
	//
	// IUnknown
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//
	// ITfCandUIAutoFilterEventSink
	//
	STDMETHODIMP OnFilterEvent(CANDUIFILTEREVENT ev);

protected:
	long		m_cRef;
	ITfContext	*m_pic;
	void		*m_pv;
	PFNONFILTEREVENT m_pfnOnFilterEvent;
};


//
// CCandUIMenuEventSink
//

class CCandUIMenuEventSink : public ITfCandUIMenuEventSink
{
public:
	CCandUIMenuEventSink(PFNINITMENU pfnInitMenu, PFNONCANDUIMENUCOMMAND pfnOnCandUIMenuCommand, ITfContext *pic, void *pVoid);
	~CCandUIMenuEventSink();

	//
	// IUnknown
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//
	// ITfCandUIMenuEventSink
	//
	STDMETHODIMP InitMenu(ITfMenu *pMenu);
	STDMETHODIMP OnMenuCommand(UINT uiCmd);

protected:
	long		m_cRef;
	ITfContext	*m_pic;
	void		*m_pv;
	PFNINITMENU				m_pfnInitMenu;
	PFNONCANDUIMENUCOMMAND	m_pfnOnCandUIMenuCommand;
};

#endif // CANDUIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\candlstx.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       candlst.cpp
//
//  Contents:   candidate list classes
//
//----------------------------------------------------------------------------

#include "private.h"
#include "candlstx.h"
#include "hanja.h"

//
// CCandidateStringEx
//

/*   C  C A N D I D A T E  S T R I N G  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandidateStringEx::CCandidateStringEx(int nIndex, LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk)
{
    m_psz = new WCHAR[wcslen(psz) + 1];
    if (m_psz)
        wcscpy(m_psz, psz);
    m_langid = langid;
    m_pv = pv;

    m_punk = punk;
    if (m_punk)
       m_punk->AddRef();
    m_pszRead = NULL;
    m_pszInlineComment = NULL;
#if 0
    m_pszPopupComment = NULL;
    m_dwPopupCommentGroupID = 0;
    m_pszPrefix = NULL;
    m_pszSuffix = NULL;
#endif
    m_nIndex = nIndex;
    m_cRef = 1;
}


/*   ~  C  C A N D I D A T E  S T R I N G  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandidateStringEx::~CCandidateStringEx()
{
    if (m_punk)
       m_punk->Release();
    delete m_psz;
    delete m_pszRead;
    if (m_pszInlineComment != NULL) {
        delete m_pszInlineComment;
    }
    
#if 0
    if (m_pszPopupComment != NULL) {
        delete m_pszPopupComment;
    }

    if (m_pszPrefix != NULL) {
        delete m_pszPrefix;
    }

    if (m_pszSuffix != NULL) {
        delete m_pszSuffix;
    }
#endif
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandidateStringEx::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfCandidateString))
        *ppvObj = SAFECAST(this, ITfCandidateString*);
    else 
        if (IsEqualGUID(riid, IID_ITfCandidateStringInlineComment))
            *ppvObj = SAFECAST(this, ITfCandidateStringInlineComment*);
    else 
        if (IsEqualGUID( riid, IID_ITfCandidateStringColor))
            *ppvObj = SAFECAST(this, ITfCandidateStringColor*);
#if 0
    else 
        if (IsEqualGUID( riid, IID_ITfCandidateStringPopupComment))
            *ppvObj = SAFECAST(this, ITfCandidateStringPopupComment*);
    else 
        if (IsEqualGUID( riid, IID_ITfCandidateStringFixture))
            *ppvObj = SAFECAST( this, ITfCandidateStringFixture*);
    else 
        if (IsEqualGUID( riid, IID_ITfCandidateStringIcon))
            *ppvObj = SAFECAST( this, ITfCandidateStringIcon*);
#endif

    if (*ppvObj == NULL)
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandidateStringEx::AddRef()
{
    m_cRef++;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandidateStringEx::Release()
{
    m_cRef--;
    if (0 < m_cRef) {
        return m_cRef;
    }

    delete this;
    return 0;    
}


/*   G E T  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetString(BSTR *pbstr)
{
    *pbstr = SysAllocString(m_psz);
    return S_OK;
}


/*   G E T  I N D E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetIndex(ULONG *pnIndex)
{
    *pnIndex = m_nIndex;
    return S_OK;
}


/*   G E T  I N L I N E  C O M M E N T  S T R I N G  */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetInlineCommentString(BSTR *pbstr)
{
    if (m_pszInlineComment == NULL) {
        return S_FALSE;
    }

    *pbstr = SysAllocString(m_pszInlineComment);
    return S_OK;
}

#if 0
/*   G E T  P O P U P  C O M M E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetPopupCommentString(BSTR *pbstr)
{
    if (m_pszPopupComment == NULL) {
        return S_FALSE;
    }

    *pbstr = SysAllocString(m_pszPopupComment);
    return S_OK;
}


/*   G E T  P O P U P  C O M M E N T  G R O U P  I  D   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetPopupCommentGroupID(DWORD *pdwGroupID)
{
    *pdwGroupID = m_dwPopupCommentGroupID;
    return S_OK;
}

#endif

/*   G E T  C O L O R   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetColor(CANDUICOLOR *pcol)
{
    // TODO: Set diferent color according to the Hanja category
    if (m_bHanjaCat == HANJA_K0)
        {
        pcol->type = CANDUICOL_SYSTEM;
        pcol->cr = COLOR_MENUTEXT;
        }
    else
        {
        pcol->type = CANDUICOL_COLORREF;

        // If button face is black
        if (GetSysColor(COLOR_3DFACE) == RGB(0,0,0)) 
            pcol->cr = RGB(0, 128, 255);
        else
            pcol->cr = RGB(0, 0, 255);
        }
    return S_OK;
}

#if 0
/*   G E T  P R E F I X  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetPrefixString(BSTR *pbstr)
{
    if (m_pszPrefix == NULL) {
        return S_FALSE;
    }

    *pbstr = SysAllocString(m_pszPrefix);
    return S_OK;
}


/*   G E T  S U F F I X  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetSuffixString(BSTR *pbstr)
{
    if (m_pszSuffix == NULL) {
        return S_FALSE;
    }

    *pbstr = SysAllocString(m_pszSuffix);
    return S_OK;
}

/*   G E T  I C O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::GetIcon( HICON *phIcon )
{
    if (m_hIcon == NULL) {
        return S_FALSE;
    }

    *phIcon = m_hIcon;
    return S_OK;
}

#endif

/*   S E T  R E A D I N G  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetReadingString(LPCWSTR psz)
{
    if (m_pszRead != NULL) {
        delete m_pszRead;
    }

    m_pszRead = new WCHAR[wcslen(psz) + 1];
    if (m_pszRead)
        wcscpy(m_pszRead, psz);
    return S_OK;
}

/*   S E T  I N L I N E  C O M M E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetInlineComment(LPCWSTR psz)
{
    if (m_pszInlineComment != NULL)
        delete m_pszInlineComment;

    if (psz != NULL)
        {
        m_pszInlineComment = new WCHAR[wcslen(psz) + 1];
        if (m_pszInlineComment != NULL)
            wcscpy(m_pszInlineComment, psz);
        } 
    else 
        m_pszInlineComment = NULL;

    return S_OK;
}

#if 0
/*   S E T  P O P U P  C O M M E N T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetPopupComment( LPCWSTR psz, DWORD dwGroupID )
{
    if (m_pszPopupComment != NULL) {
        delete m_pszPopupComment;
    }

    if (psz != NULL) {
        m_pszPopupComment = new WCHAR[wcslen(psz) + 1];
        wcscpy(m_pszPopupComment, psz);
        m_dwPopupCommentGroupID = dwGroupID;
    } 
    else {
        m_pszPopupComment = NULL;
        m_dwPopupCommentGroupID = 0;
    }
    return S_OK;
}


/*   S E T  P R E F I X  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetPrefixString( LPCWSTR psz )
{
    if (m_pszPrefix != NULL) {
        delete m_pszPrefix;
    }

    if (psz != NULL) {
        m_pszPrefix = new WCHAR[wcslen(psz) + 1];
        wcscpy(m_pszPrefix, psz);
    } 
    else {
        m_pszPrefix = NULL;
    }
    return S_OK;
}


/*   S E T  S U F F I X  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetSuffixString( LPCWSTR psz )
{
    if (m_pszSuffix != NULL) {
        delete m_pszSuffix;
    }

    if (psz != NULL) {
        m_pszSuffix = new WCHAR[wcslen(psz) + 1];
        wcscpy(m_pszSuffix, psz);
    } 
    else {
        m_pszSuffix = NULL;
    }
    return S_OK;
}

/*   S E T  I C O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateStringEx::SetIcon( HICON hIcon )
{
    m_hIcon = hIcon;
    return S_OK;
}

#endif

//
// CCandidateListEx
//

/*   C  C A N D I D A T E  L I S T  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandidateListEx::CCandidateListEx(CANDLISTCALLBACKEX pfnCallback, ITfContext *pic, ITfRange *pRange)
{
    m_pfnCallback = pfnCallback;
    m_pic = pic;
    m_pic->AddRef();
    m_pRange = pRange;
    m_pRange->AddRef();
    m_cRef = 1;
    m_iInitialSelection = 0;
    m_pExtraCand = NULL;
}


/*   ~  C  C A N D I D A T E  L I S T  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CCandidateListEx::~CCandidateListEx()
{
    m_pic->Release();
    m_pRange->Release();

    while(m_rgCandStr.Count())
        {
        CCandidateStringEx *pCandStringEx;
        
        pCandStringEx = m_rgCandStr.Get(0);
        pCandStringEx->Release();
        
        m_rgCandStr.Remove(0, 1);
        }

    if (m_pExtraCand != NULL)
        m_pExtraCand->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CCandidateListEx::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfCandidateList))
        *ppvObj = SAFECAST(this, ITfCandidateList *);
    else 
    if (IsEqualIID(riid, IID_ITfCandidateListExtraCandidate))
        *ppvObj = SAFECAST(this, ITfCandidateListExtraCandidate *);


    if (*ppvObj == NULL) {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandidateListEx::AddRef()
{
    m_cRef++;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandidateListEx::Release()
{
    m_cRef--;
    if (0 < m_cRef) {
        return m_cRef;
    }

    delete this;
    return 0;    
}


/*   E N U M  C A N D I D A T E S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::EnumCandidates(IEnumTfCandidates **ppEnum)
{
    HRESULT hr = S_OK;

    if (!(*ppEnum = new CEnumCandidatesEx(this))) {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


/*   G E T  C A N D I D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::GetCandidate(ULONG nIndex, ITfCandidateString **ppCand)
{
    CCandidateStringEx *pCandString;
    UINT nCnt = m_rgCandStr.Count();
    if (nIndex >= nCnt)
        return E_FAIL;

    pCandString = m_rgCandStr.Get(nIndex);
    return pCandString->QueryInterface(IID_ITfCandidateString, (void **)ppCand
);
}


/*   G E T  C A N D I D A T E  N U M   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::GetCandidateNum(ULONG *pnCnt)
{
    *pnCnt = m_rgCandStr.Count();
    return S_OK;
}


/*   S E T  R E S U L T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::SetResult(ULONG nIndex, TfCandidateResult imcr)
{
    if (m_pExtraCand && (nIndex == IEXTRACANDIDATE))
        {
        if (m_pfnCallback == NULL)
            return S_OK;

        return (m_pfnCallback)(m_pic, m_pRange, this, m_pExtraCand, imcr);
        }

    if (nIndex >= (UINT)m_rgCandStr.Count())
        return E_FAIL;

    if (m_pfnCallback == NULL)
        return S_OK;

    return (m_pfnCallback)(m_pic, m_pRange, this, m_rgCandStr.Get(nIndex), imcr);
}

/*   G E T  E X T R A  C A N D I D A T E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::GetExtraCandidate(ITfCandidateString **ppCand)
{
    if (ppCand == NULL)
        return E_POINTER;

    if (m_pExtraCand != NULL)
        return m_pExtraCand->QueryInterface(IID_ITfCandidateString, (void **)ppCand);

    return S_FALSE;
}


/*   A D D  S T R I N G   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::AddString( LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk, CCandidateStringEx **ppCandStr )
{
    int nCnt = m_rgCandStr.Count();
    CCandidateStringEx *pCand = new CCandidateStringEx(nCnt, psz, langid, pv, punk);

    if (!pCand)
        return E_OUTOFMEMORY;

    m_rgCandStr.Insert(nCnt, 1);
    m_rgCandStr.Set(nCnt, pCand);

    if (ppCandStr) {
        *ppCandStr = pCand;
        (*ppCandStr)->AddRef();
    }
    return S_OK;
}



/*   S E T  I N I T I A L  S E L E C T I O N   */
/*------------------------------------------------------------------------------

    Set initial selection to open candidate UI
    (internal use method)

------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::SetInitialSelection(ULONG iSelection)
{
    m_iInitialSelection = iSelection;
    return S_OK;
}



/*   G E T  I N I T I A L  S E L E C T I O N   */
/*------------------------------------------------------------------------------

    Get initial selection to open candidate UI
    (internal use method)

------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::GetInitialSelection(ULONG *piSelection)
{
    if (piSelection == NULL) {
        return E_POINTER;
    }

    *piSelection = m_iInitialSelection;
    return S_OK;
}

/*   A D D  E X T R A  S T R I N G   */
/*------------------------------------------------------------------------------

    Create extra candidate string ("0-Ban Kouho")
    (internal use method)

------------------------------------------------------------------------------*/
HRESULT CCandidateListEx::AddExtraString(LPCWSTR psz, LANGID langid, void *pv, IUnknown *punk, CCandidateStringEx **ppCandStr)
{
    if (m_pExtraCand != NULL)
        return E_FAIL;

    m_pExtraCand = new CCandidateStringEx(IEXTRACANDIDATE, psz, langid, pv, punk);

    if (!m_pExtraCand)
        return E_OUTOFMEMORY;

    if (ppCandStr)
        {
        *ppCandStr = m_pExtraCand;
        (*ppCandStr)->AddRef();
        }
        
    return S_OK;
}

//
// CEnumCandidateEx
//

/*   C  E N U M  C A N D I D A T E S  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CEnumCandidatesEx::CEnumCandidatesEx(CCandidateListEx *pList)
{
    m_pList = pList;
    m_pList->AddRef();
    m_nCur = 0;

    m_cRef = 1;
}


/*   ~  C  E N U M  C A N D I D A T E S  E X   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CEnumCandidatesEx::~CEnumCandidatesEx()
{
    m_pList->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI CEnumCandidatesEx::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumTfCandidates)) {
        *ppvObj = SAFECAST(this, IEnumTfCandidates *);
    }

    if (*ppvObj == NULL) {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

/*   A D D  R E F   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CEnumCandidatesEx::AddRef()
{
    m_cRef++;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
STDAPI_(ULONG) CEnumCandidatesEx::Release()
{
    m_cRef--;
    if (0 < m_cRef) {
        return m_cRef;
    }

    delete this;
    return 0;    
}


/*   C L O N E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CEnumCandidatesEx::Clone(IEnumTfCandidates **ppEnum)
{
    return E_NOTIMPL;
}


/*   N E X T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CEnumCandidatesEx::Next(ULONG ulCount, ITfCandidateString **ppCand, ULONG *pcFetched)
{
    ULONG cFetched = 0;

    while (cFetched < ulCount) {
        CCandidateStringEx *pCand;

        if (m_nCur >= m_pList->m_rgCandStr.Count())
            break;

        pCand = m_pList->m_rgCandStr.Get(m_nCur);
        if (FAILED(pCand->QueryInterface(IID_ITfCandidateString, (void **)ppCand)))
            break;

        ppCand++;
        cFetched++;
        m_nCur++;
    }

    if (pcFetched)
        *pcFetched = cFetched;

    return (cFetched == ulCount) ? S_OK : S_FALSE;
}


/*   R E S E T   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CEnumCandidatesEx::Reset()
{
    m_nCur = 0;
    return S_OK;
}


/*   S K I P   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CEnumCandidatesEx::Skip(ULONG ulCount)
{
    while (ulCount) {
        if (m_nCur >= m_pList->m_rgCandStr.Count())
            break;

        m_nCur++;
        ulCount--;
    }

    return ulCount ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\cicbtn.h ===
//
// cicbtn.h
//

#ifndef _CICBTN_H_
#define _CICBTN_H_

#include <initguid.h>
#include "slbarid.h"

#define CICBTN_TOOLTIP_MAX	256
#define CICBTN_TEXT_MAX	256

class __declspec(novtable) CCicButton : public ITfSource, public ITfLangBarItemButton
{
public:
    CCicButton()
    {
		m_uid       = (UINT)-1;
		m_dwStatus  = 0;
		m_fShown    = FALSE;
		m_fEnable   = TRUE;
		m_szText[0] = L'\0';
		m_cRef      = 1;
	}
    ~CCicButton();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
	//virtual STDMETHODIMP_(ULONG) Release(void);

    void InitInfo(REFCLSID clsid, REFGUID rguid, DWORD dwStyle, ULONG ulSort, LPWSTR pszDesc);
    virtual STDMETHODIMP GetInfo(TF_LANGBARITEMINFO *pInfo);
    virtual STDMETHODIMP GetStatus(DWORD *pdwStatus);
    virtual STDMETHODIMP Show(BOOL fShow);
    virtual STDMETHODIMP GetTooltipString(BSTR *pbstrToolTip);
    virtual STDMETHODIMP AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie);
    virtual STDMETHODIMP UnadviseSink(DWORD dwCookie);
	virtual STDMETHODIMP OnClick( /* [in] */ TfLBIClick click, /* [in] */ POINT pt, /* [in] */ const RECT __RPC_FAR *prcArea);
	virtual STDMETHODIMP InitMenu( /* [in] */ ITfMenu __RPC_FAR *pMenu);
	virtual STDMETHODIMP OnMenuSelect( /* [in] */ UINT wID);
	virtual STDMETHODIMP GetIcon( /* [out] */ HICON __RPC_FAR *phIcon);
	virtual STDMETHODIMP GetText( /* [out] */ BSTR __RPC_FAR *pbstrText);

    virtual HRESULT OnLButtonUp(const POINT pt, const RECT *prcArea);
    virtual HRESULT OnRButtonUp(const POINT pt, const RECT *prcArea);

    DWORD GetStyle() {return m_lbiInfo.dwStyle;}
    void SetStyle(DWORD dwStyle) {m_lbiInfo.dwStyle = dwStyle;}

    GUID* GetGuidItem() {return &m_lbiInfo.guidItem;}

    DWORD GetStatusInternal() {return m_dwStatus;}
    void SetStatusInternal(DWORD dw) {m_dwStatus = dw;}
    HRESULT ShowInternal(BOOL fShow, BOOL fNotify = FALSE);

    void SetOrClearStatus(DWORD dw, BOOL fSet);

    ITfLangBarItemSink *GetSink() { return m_plbiSink; }

    void SetText(WCHAR *psz);
    void SetToolTip(WCHAR *psz);
	void SetStatus(DWORD dwStatus);
	void Enable(BOOL fEnable);
	BOOL IsEnable() { return m_fEnable;	}
	void ShowDefault(BOOL fShowDefault);

	void SetID(UINT uid) { m_uid = uid;  }
	UINT GetID()	     { return m_uid; }


protected:
    //DWORD _dwStatus;
    TF_LANGBARITEMINFO m_lbiInfo;
    WCHAR m_szToolTip[CICBTN_TOOLTIP_MAX];
    long m_cRef;
    ITfLangBarItemSink *m_plbiSink;

private:
    DWORD m_dwCookie;
	DWORD m_dwStatus;
	BOOL m_fShown;
	BOOL m_fEnable;
	UINT m_uid;
    WCHAR m_szText[CICBTN_TEXT_MAX];
};

inline
void CCicButton::SetOrClearStatus(DWORD dw, BOOL fSet)
{
    if (fSet)
        m_dwStatus |= dw;
    else
        m_dwStatus &= ~dw;
}

inline
void CCicButton::SetToolTip(WCHAR *psz)
{
    wcsncpy(m_szToolTip, psz, CICBTN_TOOLTIP_MAX);
}


inline
void CCicButton::SetStatus(DWORD dwStatus)
{
	BOOL fShown = m_fShown;
	m_dwStatus = dwStatus;
	ShowInternal(fShown);
}

inline
void CCicButton::Enable(BOOL fEnable)
{
	m_fEnable = fEnable;
	if(fEnable) {	// enable?
		m_dwStatus &= ~TF_LBI_STATUS_DISABLED;
	} else {
		m_dwStatus |= TF_LBI_STATUS_DISABLED;
	}
}

inline
void CCicButton::ShowDefault(BOOL fShowDefault)
{
	if( fShowDefault == FALSE ) {
		m_lbiInfo.dwStyle |= TF_LBI_STYLE_HIDDENBYDEFAULT;
	} else {
		m_lbiInfo.dwStyle &= ~TF_LBI_STYLE_HIDDENBYDEFAULT;
	}
}

inline
void CCicButton::SetText(WCHAR *psz)
{
	wcsncpy(m_szText, psz, CICBTN_TEXT_MAX);
}

#endif // _CICBTN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\cicbtn.cpp ===
//
// cicbtn.cpp
//
// base code: nuibase sample
//

#include "private.h"
#include "globals.h"
#include "cicbtn.h"
#include "helpers.h"

#define CICBTN_ITEMSINK_COOKIE 0x80000003

//////////////////////////////////////////////////////////////////////////////
//
// CCicButton
//
//////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CCicButton::~CCicButton()
{
    SafeRelease(m_plbiSink);
}

//+---------------------------------------------------------------------------
//
// InitInfo
//
//----------------------------------------------------------------------------

void CCicButton::InitInfo(REFCLSID rclsid, 
                                REFGUID rguid, 
                                DWORD dwStyle, 
                                ULONG ulSort,
                                LPWSTR pszDesc)
{
    // init nuiInfo.
    m_lbiInfo.clsidService = rclsid;
    m_lbiInfo.guidItem = rguid;
    m_lbiInfo.dwStyle = dwStyle;
    m_lbiInfo.ulSort = ulSort;
    wcscpy(m_lbiInfo.szDescription, pszDesc);
}

//+---------------------------------------------------------------------------
//
// GetType
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetInfo(TF_LANGBARITEMINFO *pInfo)
{
    *pInfo = m_lbiInfo;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// GetStatus
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetStatus(DWORD *pdwStatus)
{
    *pdwStatus = m_dwStatus;
    
    if (m_fEnable)    // enable?
        {
        // do nothing
        }
    else
        *pdwStatus |= TF_LBI_STATUS_DISABLED;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CCicButton::Show(BOOL fShow)
{
    ITfLangBarItemSink* pSink;

    ShowInternal(fShow);
    pSink = GetSink();
    if (pSink)
        pSink->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// AdviseSink
//
//----------------------------------------------------------------------------

HRESULT CCicButton::AdviseSink(REFIID riid, IUnknown *punk, DWORD *pdwCookie)
{
    HRESULT hr;

    if (IsEqualIID(IID_ITfLangBarItemSink, riid))
        {
        if (m_plbiSink)
            hr = CONNECT_E_CANNOTCONNECT;
        else
            {
            hr = punk->QueryInterface(IID_ITfLangBarItemSink, (void **)&m_plbiSink);
            if (SUCCEEDED(hr))
                *pdwCookie = CICBTN_ITEMSINK_COOKIE;
            }
        }
    else
        hr = CONNECT_E_CANNOTCONNECT;
    
    return hr;
}

//+---------------------------------------------------------------------------
//
// UnadviseSink
//
//----------------------------------------------------------------------------

HRESULT CCicButton::UnadviseSink(DWORD dwCookie)
{
    if (CICBTN_ITEMSINK_COOKIE  != dwCookie)
        return E_FAIL;

    if (!m_plbiSink)
        return E_UNEXPECTED;

    m_plbiSink->Release();
    m_plbiSink = NULL;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

HRESULT CCicButton::ShowInternal(BOOL fShow, BOOL fNotify)
{
    m_fShown = fShow;
    DWORD dwOldStatus = m_dwStatus;

    if (fShow)
        m_dwStatus &= ~TF_LBI_STATUS_HIDDEN;
    else
        m_dwStatus |= TF_LBI_STATUS_HIDDEN;

    if (fNotify && (dwOldStatus != m_dwStatus) && m_plbiSink)
         m_plbiSink->OnUpdate(TF_LBI_STATUS);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLBarItemButtonBase
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CCicButton::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfLangBarItem))
        {
        *ppvObj = SAFECAST(this, ITfLangBarItem *);
        }
    else if (IsEqualIID(riid, IID_ITfLangBarItemButton))
        {
        *ppvObj = SAFECAST(this, ITfLangBarItemButton *);
        }
    else if (IsEqualIID(riid, IID_ITfSource))
        {
        *ppvObj = SAFECAST(this, ITfSource *);
        }

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CCicButton::AddRef()
{
    return ++m_cRef;
}

#ifdef NEVER // each button object has this
STDAPI_(ULONG) CCicButton::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}
#endif // NEVER


//+---------------------------------------------------------------------------
//
// OnClick
//
//----------------------------------------------------------------------------

STDAPI CCicButton::OnClick(TfLBIClick click, POINT pt, const RECT *prcArea)
{
    switch (click)
        {
        case TF_LBI_CLK_RIGHT:
            return OnRButtonUp(pt, prcArea);
        case TF_LBI_CLK_LEFT:
            return OnLButtonUp(pt, prcArea);
        }
        
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CCicButton::OnLButtonUp(const POINT pt, const RECT *prcArea)
{
    pt, prcArea; // no ref
   return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CCicButton::OnRButtonUp(const POINT pt, const RECT *prcArea)
{
    pt, prcArea; // no ref
   return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// InitMenu
//
//----------------------------------------------------------------------------

STDAPI CCicButton::InitMenu(ITfMenu *pMenu)
{
    pMenu; // no ref
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// OnMenuSelect
//
//----------------------------------------------------------------------------

STDAPI CCicButton::OnMenuSelect(UINT uID)
{
    uID; // no ref
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// GetIcon
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetIcon(HICON *phIcon)
{
    phIcon; // no ref
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
// GetText
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetText(BSTR *pbstrText)
{
    if (!pbstrText)
        return E_INVALIDARG;

    *pbstrText = SysAllocString(m_szText);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
// GetTooltipString
//
//----------------------------------------------------------------------------

STDAPI CCicButton::GetTooltipString(BSTR *pbstrToolTip)
{
    if (!pbstrToolTip)
        return E_INVALIDARG;

    *pbstrToolTip = SysAllocString(m_szToolTip);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\canduies.cpp ===
//
// canduies.cpp
//

#include "private.h"
#include "canduies.h"


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  E X T  B U T T O N  E V E N T  S I N K                  */
/*                                                                            */
/*============================================================================*
/

/*   C  C A N D  U I  E X T  B U T T O N  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Constructor of CCandUIExtButtonEventSink

------------------------------------------------------------------------------*/
CCandUIExtButtonEventSink::CCandUIExtButtonEventSink(PFNONBUTTONPRESSED pfnOnButtonPressed, ITfContext *pic, void *pVoid)
{
    m_cRef = 1;
    m_pic  = pic;
    m_pic->AddRef();
    m_pv   = pVoid;
    m_pfnOnButtonPressed = pfnOnButtonPressed;
}


/*   ~  C  C A N D  U I  E X T  B U T T O N  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Destructor of CCandUIExtButtonEventSink

------------------------------------------------------------------------------*/
CCandUIExtButtonEventSink::~CCandUIExtButtonEventSink()
{
    m_pic->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    QueryInterface
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtButtonEventSink::QueryInterface( REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfCandUIExtButtonEventSink))
        *ppvObj = SAFECAST(this, ITfCandUIExtButtonEventSink*);

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Increment reference count
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtButtonEventSink::AddRef()
{
    ++m_cRef;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Decrement reference count and release
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIExtButtonEventSink::Release()
{
    --m_cRef;

    if (0 < m_cRef)
        return m_cRef;

    delete this;
    return 0;
}


/*   O N  B U T T O N  P R E S S E D   */
/*------------------------------------------------------------------------------

    Callback function of CandUI button event
    (ITfCandUIExtButtonEventSink method)

------------------------------------------------------------------------------*/
STDAPI CCandUIExtButtonEventSink::OnButtonPressed(LONG id)
{
    return (*m_pfnOnButtonPressed)(id, m_pic, m_pv);
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  A U T O  F I L T E R  E V E N T  S I N K                */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  A U T O  F I L T E R  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Constructor of CCandUIFilterEventSink

------------------------------------------------------------------------------*/
CCandUIAutoFilterEventSink::CCandUIAutoFilterEventSink(PFNONFILTEREVENT pfnOnFilterEvent, ITfContext *pic, void *pVoid)
{
    m_cRef = 1;
    m_pic  = pic;
    m_pic->AddRef();
    m_pv   = pVoid;
    m_pfnOnFilterEvent = pfnOnFilterEvent;
}


/*   ~  C  C A N D  U I  A U T O  F I L T E R  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Destructor of CCandUIFilterEventSink

------------------------------------------------------------------------------*/
CCandUIAutoFilterEventSink::~CCandUIAutoFilterEventSink()
{
    m_pic->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    QueryInterface
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIAutoFilterEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfCandUIAutoFilterEventSink))
        *ppvObj = SAFECAST(this, ITfCandUIAutoFilterEventSink*);

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Increment reference count
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIAutoFilterEventSink::AddRef()
{
    ++m_cRef;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Decrement reference count and release
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIAutoFilterEventSink::Release()
{
    --m_cRef;

    if (0 < m_cRef)
        return m_cRef;

    delete this;
    return 0;
}


/*   O N  F I L T E R  E V E N T   */
/*------------------------------------------------------------------------------

    Callback function of CandUI filtering event
    (ITfCandUIAutoFilterEventSink method)

------------------------------------------------------------------------------*/
STDAPI CCandUIAutoFilterEventSink::OnFilterEvent(CANDUIFILTEREVENT ev)
{
    return (*m_pfnOnFilterEvent)(ev, m_pic, m_pv);
}


/*============================================================================*/
/*                                                                            */
/*   C  C A N D  U I  M E N U  E V E N T  S I N K                             */
/*                                                                            */
/*============================================================================*/

/*   C  C A N D  U I  M E N U  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Constructor of CCandUIMenuEventSink

------------------------------------------------------------------------------*/
CCandUIMenuEventSink::CCandUIMenuEventSink(PFNINITMENU pfnInitMenu, PFNONCANDUIMENUCOMMAND pfnOnCandUIMenuCommand, ITfContext *pic, void *pVoid)
{
    m_cRef = 1;
    m_pic  = pic;
    m_pic->AddRef();
    m_pv   = pVoid;
    m_pfnInitMenu            = pfnInitMenu;
    m_pfnOnCandUIMenuCommand = pfnOnCandUIMenuCommand;
}


/*   ~  C  C A N D  U I  M E N U  E V E N T  S I N K   */
/*------------------------------------------------------------------------------

    Destructor of CCandUIMenuEventSink

------------------------------------------------------------------------------*/
CCandUIMenuEventSink::~CCandUIMenuEventSink( void )
{
    m_pic->Release();
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    QueryInterface
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfCandUIMenuEventSink))
        *ppvObj = SAFECAST(this, CCandUIMenuEventSink*);

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Increment reference count
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIMenuEventSink::AddRef()
{
    ++m_cRef;
    return m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Decrement reference count and release
    (IUknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CCandUIMenuEventSink::Release()
{
    --m_cRef;

    if (0 < m_cRef)
        return m_cRef;

    delete this;
    return 0;
}


/*   I N I T  C A N D I D A T E  M E N U   */
/*------------------------------------------------------------------------------

    Callback function to initialize candidate menu
    (ITfCandUIMenuEventSink method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuEventSink::InitMenu(ITfMenu *pMenu)
{
    return (*m_pfnInitMenu)(pMenu, m_pic, m_pv);
}


/*   O N  C A N D  U I  M E N U  C O M M A N D   */
/*------------------------------------------------------------------------------

    Callback function of candidate menu event
    (ITfCandUIMenuEventSink method)

------------------------------------------------------------------------------*/
STDAPI CCandUIMenuEventSink::OnMenuCommand(UINT uiCmd)
{
    return (*m_pfnOnCandUIMenuCommand)(uiCmd, m_pic, m_pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\cmode.h ===
//
// CMODE.H
//

#if !defined (__CMODE_H__INCLUDED_)
#define __CMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class CMode : public CCicButton
{
public:
    CMode(CToolBar *ptb);
    ~CMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    //HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:

	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __CMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\cmode.cpp ===
/****************************************************************************
   CMODE.CPP : CMode class implementation which manage conversion mode button
                  on the Cicero Toolbar

   History:
      10-JAN-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "cmode.h"
#include "userex.h"
#include "resource.h"

// {951549C6-9752-4b7d-9B0E-35AEBFF9E446}
const GUID GUID_LBI_KORIMX_CMODE = 
{   
    0x951549c6, 
    0x9752, 
    0x4b7d, 
    { 0x9b, 0xe, 0x35, 0xae, 0xbf, 0xf9, 0xe4, 0x46 }
};

/*---------------------------------------------------------------------------
    CMode::CMode
---------------------------------------------------------------------------*/
CMode::CMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    // Set Add/Remove and tootip text
    LoadStringExW(g_hInst, IDS_TT_HAN_ENG, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_KorIMX, 
                GUID_LBI_KORIMX_CMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_SHOWNINTRAY | TF_LBI_STYLE_TEXTCOLORICON,
                100, 
                szText);
    SetToolTip(szText);

    // Set button text
    LoadStringExW(g_hInst, IDS_BUTTON_HAN_ENG, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}

/*---------------------------------------------------------------------------
    CMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CMode::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    CMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI CMode::GetIcon(HICON *phIcon)
{
    UINT uiIcon = 0;
    static const UINT uidIcons[2][2] = 
    {
        { IDI_CMODE_ENGLISH, IDI_CMODE_ENGLISHW },
        { IDI_CMODE_HANGUL,  IDI_CMODE_HANGULW }
    };

    
    if (m_pTb->IsOn() && (m_pTb->GetConversionMode() & TIP_HANGUL_MODE))
        uiIcon = 1;

    if (IsHighContrastBlack())
        uiIcon = uidIcons[uiIcon][1];
    else
        uiIcon = uidIcons[uiIcon][0];
    
    *phIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);;
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    CMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    CMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT CMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    DWORD dwConvMode;

    dwConvMode = m_pTb->GetConversionMode();

    // Toggle Hangul mode
    dwConvMode ^= TIP_HANGUL_MODE;
    
    SetCMode(dwConvMode);
    
    return S_OK;
}

#if 0
//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT CMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    HMENU hMenu;
    DWORD dwConvMode;
    CHAR  szText[256];
    UINT  uiId;
    int   nRet;
    
    hMenu = CreatePopupMenu();
    
    dwConvMode = GetCMode();
    if (dwConvMode & TIP_HANGUL_MODE)
        uiId = IDS_ENGLISH_MODE;
    else
        uiId = IDS_HANGUL_MODE;

    // Add Hangul/English mode menu
    LoadStringExA(g_hInst, uiId, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, szText);

    // Add Cancel menu
    LoadStringExA(g_hInst, IDS_CANCEL, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 0, szText);

    nRet = TrackPopupMenuEx(hMenu, 
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, m_pTb->GetOwnerWnd(), NULL);
    switch (nRet)
        {
    case 1: 
        dwConvMode = GetCMode();

        // Toggle Hangul mode
        if (dwConvMode & TIP_HANGUL_MODE)
            dwConvMode &= ~TIP_HANGUL_MODE;
        else
            dwConvMode |= TIP_HANGUL_MODE;

        SetCMode(dwConvMode);
        break;
        }

    DestroyMenu(hMenu);

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\config.cpp ===
/****************************************************************************
    CONFIG.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IME Configuration DLG and registry access functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "gdata.h"
#include "debug.h"
#include "config.h"
#include "prsht.h"
#include "osver.h"
#include "userex.h"
#include "resource.h"

// Config DLG Help ID
#define IDH_GRP_STATUSWIN               1001
#define IDH_JUNBAN_TOGGLE               1002
#define IDH_HANJA_CONV                  1003
#define IDH_GRP_KEYLAYOUT               1004
#define IDH_2BEOLSIK                    1005
#define IDH_3BEOLSIK_390                1006
#define IDH_3BEOLSIK_FINAL              1007
#define IDH_DELJASO                     1008
#define IDH_K1HANJA                        1009

// Private functions
static void PASCAL AddPage(LPPROPSHEETHEADERW ppsh, UINT id, DLGPROC pfn);
static INT_PTR CALLBACK ConfigDLGProc1(HWND hDlg, UINT message, 
                                   WPARAM wParam, LPARAM lParam);
static int *GetContextHelpList();
static BOOL IsValidCtrlIdForHelp(INT *helpList, INT ctrlId);
static void GetHelpFileName();

int *GetContextHelpList()
{
    // Context Help Ids of PropertySheet
    static int ProDlgCtxHelpList[] = 
        {
        IDC_GRP_KEYLAYOUT,  IDH_GRP_KEYLAYOUT,
        IDC_2BEOLSIK,       IDH_2BEOLSIK,   
        IDC_3BEOLSIK_390,   IDH_3BEOLSIK_390,
        IDC_3BEOLSIK_FINAL, IDH_3BEOLSIK_FINAL,
        IDC_DELJASO,        IDH_DELJASO,
        IDC_K1HANJA,        IDH_K1HANJA,
        0,      0
        };
    return ProDlgCtxHelpList;
}

BOOL IsValidCtrlIdForHelp(INT *helpList, INT ctrlId)
{
    INT *p;
    for(p = helpList; *p != 0;  p+=2) 
        {
        if(ctrlId == *p)
            return fTrue;
        }
    return fFalse;
}

void GetHelpFileName(LPTSTR szHelpFileNameFull, int cchszHelpFileNameFull)
{
    // WARNING: This only will work for NT or Win98. For Win95 need to check system locale
    LoadStringExA(g_hInst, IDS_CONTEXTHELP_FILENAME, szHelpFileNameFull, MAX_PATH);
}

static HWND hwndPropSheet = (HWND)0;
static BOOL g_fDestroyPropNow = FALSE;

BOOL ConfigDLG(HWND hwndParent)
{
    static HPROPSHEETPAGE  rPages[1];
    static PROPSHEETHEADERW psh;
       static WCHAR szCaption[64];
    MSG    msg = {0};
    BOOL   fRet = fFalse;

    // If config DLG already created
    if (IsWindow(hwndPropSheet))
        {
        SetForegroundWindow(hwndPropSheet);
        return fTrue;
        }

    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_NOAPPLYNOW | PSH_USEICONID | PSH_MODELESS | PSH_USEPAGELANG;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hInst;
    if (IsOnNT())
        LoadStringExW(g_hInst, IDS_PROGRAM, szCaption, sizeof(szCaption)/sizeof(WCHAR));
       else
        LoadStringExA(g_hInst, IDS_PROGRAM, (LPSTR)szCaption, sizeof(szCaption));
    psh.pszCaption = szCaption;
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = rPages;

    AddPage(&psh, IDD_CONFIG_PAGE1, ConfigDLGProc1);

    if (IsOnNT())
        hwndPropSheet = (HWND)PropertySheetW(&psh);
    else
        hwndPropSheet = (HWND)PropertySheetA((PROPSHEETHEADERA*)&psh);

    while (IsWindow(hwndPropSheet) && OurGetMessage(&msg, NULL, 0x00, 0x00))
        {
        // If the modeless guy is up and is ready to be destroyed
        // (PropSheet_GetCurrentPageHwnd returns NULL) then destroy the dialog.
        
        // PropSheet_GetCurrentPageHwnd will return NULL after the OK or Cancel 
        // button has been pressed and all of the pages have been notified. The 
        // Apply button doesn't cause this to happen.
        if(/*g_fDestroyPropNow == fTrue || */(hwndPropSheet && (NULL == PropSheet_GetCurrentPageHwnd(hwndPropSheet)))) 
            {
            //enable the parent first to prevent another window from becoming the foreground window
            //EnableWindow(hwndParent, TRUE);
            DestroyWindow(hwndPropSheet);
            //break;
        }

        //use PropSheet_IsDialogMessage instead of IsDialogMessage
        if(!PropSheet_IsDialogMessage(hwndPropSheet, &msg))
            {
            TranslateMessage(&msg);
            if (IsOnNT())
                DispatchMessageW(&msg);
            else
                DispatchMessageA(&msg);
            }
        }
    
    hwndPropSheet = (HWND)0;
    
    return fTrue;
}

void PASCAL AddPage(LPPROPSHEETHEADERW ppsh, UINT idDlg, DLGPROC pfn)
{
    //if (ppsh->nPages < 3)
    //{
    PROPSHEETPAGE psp;
    ZeroMemory(&psp, sizeof(psp));

    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DLGINDIRECT;
    psp.hInstance = g_hInst;
    psp.pResource = LoadDialogTemplateEx(GetSystemDefaultLangID(), g_hInst, MAKEINTRESOURCE(idDlg));
    psp.pfnDlgProc = pfn;
    psp.lParam = 0;

    ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);
    if (ppsh->phpage[ppsh->nPages])
      ppsh->nPages++;
   //}
}

INT_PTR CALLBACK ConfigDLGProc1(HWND hDlg, UINT message , WPARAM wParam, LPARAM lParam)
{
    static UINT    uPrevKeyboardType;
    static BOOL    fPrevJasoDel;
    static BOOL fK1Hanja;
    BOOL fFound = fFalse;
    TCHAR  szHelpFileNameFull[MAX_PATH];
    CIMEData    ImeData(CIMEData::SMReadWrite);

    DebugMsg(DM_TRACE, TEXT("ConfigDLGProc"));

    // If Properties DLG invoked from Setting in Toolbar and no Tip instance exist in the system,
    // IMEData is not init. So make sure we load reg values here.
    ImeData.InitImeData();

    switch(message)
        {
        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
                {
            case PSN_APPLY:
                ImeData.SetCurrentBeolsik(uPrevKeyboardType);
                ImeData.SetJasoDel(fPrevJasoDel);
                ImeData.SetKSC5657Hanja(fK1Hanja);
                SetRegValues(GETSET_REG_STATUS_BUTTONS|GETSET_REG_IMEKL|GETSET_REG_JASODEL|GETSET_REG_KSC5657);
                break;
                    
            default:
                return fFalse;
                }
            break;

        case WM_INITDIALOG:
            uPrevKeyboardType = ImeData.GetCurrentBeolsik();
            CheckRadioButton(hDlg, IDC_2BEOLSIK, IDC_3BEOLSIK_FINAL, IDC_2BEOLSIK+uPrevKeyboardType);
            fPrevJasoDel = ImeData.GetJasoDel();
            if (fPrevJasoDel)
                CheckDlgButton(hDlg, IDC_DELJASO, BST_CHECKED);
            else
                CheckDlgButton(hDlg, IDC_DELJASO, BST_UNCHECKED);

            // KSC-5657 Hanja
            fK1Hanja = ImeData.GetKSC5657Hanja() && !IsOn95();
            if (fK1Hanja)
                CheckDlgButton(hDlg, IDC_K1HANJA, BST_CHECKED);
            else
                CheckDlgButton(hDlg, IDC_K1HANJA, BST_UNCHECKED);

            // If Win95, disable K1 Hanja
            if (IsOn95())
                EnableWindow(GetDlgItem(hDlg, IDC_K1HANJA), fFalse);
            return fTrue;

        case WM_COMMAND:
            switch (wParam)
               {
            case IDC_2BEOLSIK:
                //if (IsDlgButtonChecked(hDlg, IDC_2BEOLSIK)) {
                    uPrevKeyboardType = KL_2BEOLSIK;
                //}
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_3BEOLSIK_390:
                uPrevKeyboardType = KL_3BEOLSIK_390;
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_3BEOLSIK_FINAL:
                uPrevKeyboardType = KL_3BEOLSIK_FINAL;
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;
                
            case IDC_DELJASO:
                if (IsDlgButtonChecked(hDlg, IDC_DELJASO))
                    fPrevJasoDel = fTrue;
                else
                    fPrevJasoDel = fFalse;

                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            case IDC_K1HANJA:
                if (IsDlgButtonChecked(hDlg, IDC_K1HANJA))
                    fK1Hanja = fTrue;
                else
                    fK1Hanja = fFalse;
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                break;

            default:
                return fFalse;
               }
            break;

        case WM_CONTEXTMENU:
            GetHelpFileName(szHelpFileNameFull, MAX_PATH);
            WinHelp((HWND)wParam, 
                    szHelpFileNameFull, 
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)(LPVOID)GetContextHelpList());
            return 0;

        case WM_HELP:
            INT *pHelpList;
            pHelpList = GetContextHelpList();
            if(IsValidCtrlIdForHelp(pHelpList, ((LPHELPINFO)lParam)->iCtrlId)) 
                {
                GetHelpFileName(szHelpFileNameFull, MAX_PATH);
                WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                        szHelpFileNameFull,
                        HELP_WM_HELP,
                        (ULONG_PTR)pHelpList);
                }
            return 0;

        default:
            return fFalse;
        }
    return fTrue;
}

#ifdef NEVER
BOOL GetStatusWinPosReg(POINT *pptStatusWinPosReg)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb;
    BOOL    fSuccess = fFalse;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, g_szIMERootKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        dwCb = sizeof(dwBuf);
        if (RegQueryValueEx(hKey, g_szStatusPos, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS)
            {
            pptStatusWinPosReg->x = HIWORD(dwBuf);
            pptStatusWinPosReg->y = LOWORD(dwBuf);
            fSuccess = fTrue;
            }
            
        RegCloseKey(hKey);
        }

    return fSuccess;
}
#endif
///////////////////////////////////////////////////////////////////////////////
//
BOOL GetRegValues(UINT uGetBits)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb, dwType;
    CIMEData    ImeData(CIMEData::SMReadWrite);
    BOOL    fSuccess = fTrue;

    DebugMsg(DM_TRACE, "GetRegValues()");

    if (RegOpenKeyEx(HKEY_CURRENT_USER, g_szIMERootKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
        {
        ///////////////////////////////////////////////////////////////////
        // IME Keyboard Layout
        if (uGetBits & GETSET_REG_IMEKL) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szIMEKL, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS) 
                {
                if (/*dwBuf >= KL_2BEOLSIK &&*/ dwBuf <= KL_3BEOLSIK_FINAL)
                    ImeData.SetCurrentBeolsik(dwBuf);
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Status window pos
        if (uGetBits & GETSET_REG_STATUSPOS) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szStatusPos, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS)
                {
                ImeData->ptStatusPos.x = HIWORD(dwBuf);
                ImeData->ptStatusPos.y = LOWORD(dwBuf);
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Status window button setting
        if (uGetBits & GETSET_REG_STATUS_BUTTONS) 
            {
            BYTE ButtonReg[MAX_NUM_OF_STATUS_BUTTONS+1];
            int        nButton;

            dwCb = sizeof(ButtonReg);
            dwType = REG_BINARY;
            if (RegQueryValueEx(hKey, g_szStatusButtons, NULL, &dwType, (LPBYTE)&ButtonReg, &dwCb) == ERROR_SUCCESS)
                {
                if (ButtonReg[0] == 0)
                    ButtonReg[0] = 1;
                    
                if (ButtonReg[0]<=MAX_NUM_OF_STATUS_BUTTONS) 
                    {
                    for (nButton=0; nButton<ButtonReg[0]; nButton++) 
                        {
                        // button data validity check
                        if (ButtonReg[nButton+1] <= IME_PAD_BUTTON && ButtonReg[nButton+1] != NULL_BUTTON)
                            ImeData->StatusButtons[nButton].m_ButtonType = (StatusButtonTypes)ButtonReg[nButton+1];
                        else
                            break;
                        }
                    ImeData->uNumOfButtons = nButton;
                    }
                }
            else
                fSuccess = fFalse;
            }

        ///////////////////////////////////////////////////////////////////
        // Deletion by Jaso
        if (uGetBits & GETSET_REG_JASODEL) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szCompDel, NULL, NULL, (LPBYTE)&dwBuf, &dwCb)    == ERROR_SUCCESS)
                ImeData.SetJasoDel(dwBuf);
            }

#if 0
            // REVIEW: Do we still need for TIP?

        if (uGetBits & GETSET_REG_ISO10646) 
            {
            dwCb = sizeof(dwBuf);
            if (RegQueryValueEx(hKey, g_szXWEnable, NULL, NULL, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS)
                vpInstData->fISO10646 = dwBuf;
            else
                fSuccess = fFalse;

            // For Win95 and Win98 lookup INI file for ISO10646 setting.
            // ISO10646.EXE set registry
            if (!IsWinNT())
                vpInstData->fISO10646 = GetProfileInt(g_szXWEnable, 
                                                OurGetModuleFileName(fFalse), 
                                                vpInstData->fISO10646);
            }
#endif

        // Get KSC5657 K1 Hanja flag
        if (uGetBits & GETSET_REG_KSC5657) 
            {
            dwCb = sizeof(dwBuf);
            dwType = REG_DWORD;
            if (RegQueryValueEx(hKey, g_szEnableK1Hanja, NULL, &dwType, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS) 
                ImeData->fKSC5657Hanja = dwBuf;
            else
                ImeData->fKSC5657Hanja = fFalse;
            }

        // Get Unicode Tooltip Cand window flag
        // Currently this has no UI part which means hidden spec so no need SetReg now.
        if (uGetBits & GETSET_REG_CANDUNICODETT) 
            {
            dwCb = sizeof(dwBuf);
            dwType = REG_DWORD;
            if (RegQueryValueEx(hKey, g_szEnableCandUnicodeTT, NULL, &dwType, (LPBYTE)&dwBuf, &dwCb) == ERROR_SUCCESS) 
                ImeData->fCandUnicodeTT = dwBuf;
            else
                ImeData->fCandUnicodeTT = fFalse;
            }

        RegCloseKey(hKey);
        }
    else
        {
        fSuccess = fFalse;
        Assert(0);
        }

    return fSuccess;
}

BOOL SetRegValues(UINT uSetBits)
{
    HKEY    hKey;
    DWORD    dwBuf, dwCb;
    int        nButton;
    CIMEData    ImeData;

    ///////////////////////////////////////////////////////////////////////////
    // Set status pos
    if (RegCreateKey(HKEY_CURRENT_USER, g_szIMERootKey, &hKey) == ERROR_SUCCESS) 
        {
        if (uSetBits & GETSET_REG_STATUSPOS) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = (ImeData->ptStatusPos.x << 16) | (ImeData->ptStatusPos.y & 0xFFFF);  // HIWORD : X, LOWORD : Y
            RegSetValueEx(hKey, g_szStatusPos, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);

            }

        if (uSetBits & GETSET_REG_STATUS_BUTTONS) 
            {
            BYTE ButtonReg[MAX_NUM_OF_STATUS_BUTTONS+1];
            dwCb = sizeof(ButtonReg);

            Assert(ImeData->uNumOfButtons <= MAX_NUM_OF_STATUS_BUTTONS);
            // set number of button as the first element of array
            if (ImeData->uNumOfButtons<=MAX_NUM_OF_STATUS_BUTTONS)
                ButtonReg[0] = (BYTE)ImeData->uNumOfButtons;

            for (nButton=0; nButton < (INT)ImeData->uNumOfButtons; nButton++) 
                ButtonReg[nButton+1] = ImeData->StatusButtons[nButton].m_ButtonType;
                
            // clear
            for (; nButton<MAX_NUM_OF_STATUS_BUTTONS; nButton++)
                ButtonReg[nButton+1] = NULL_BUTTON;

            RegSetValueEx(hKey, g_szStatusButtons, 0, REG_BINARY, (LPBYTE)&ButtonReg, dwCb);
            }


        if (uSetBits & GETSET_REG_IMEKL) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetCurrentBeolsik();
            RegSetValueEx(hKey, g_szIMEKL, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }
        
        if (uSetBits & GETSET_REG_JASODEL) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetJasoDel();
            RegSetValueEx(hKey, g_szCompDel, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }

        // Get KSC5657 K1 Hanja flag
        if (uSetBits & GETSET_REG_KSC5657) 
            {
            dwCb = sizeof(dwBuf);
            dwBuf = ImeData.GetKSC5657Hanja();
            RegSetValueEx(hKey, g_szEnableK1Hanja, 0, REG_DWORD, (LPBYTE)&dwBuf, dwCb);
            }

        RegCloseKey(hKey);
        }
    else 
        return fFalse;
        
    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\crtfree.h ===
//
//   CrtFree.h
//
//   History:
//      18-NOV-1999 CSLim Created

#if !defined (__CRTFREE_H__INCLUDED_) && defined(NOCLIB)
#define __CRTFREE_H__INCLUDED_

extern LPWSTR ImeRtl_StrCopyW(LPWSTR pwDest, LPCWSTR pwSrc);
extern LPWSTR ImeRtl_StrnCopyW(LPWSTR pwDest, LPCWSTR pwSrc, UINT uiCount);
extern INT ImeRtl_StrCmpW(LPCWSTR pwSz1, LPCWSTR pwSz2);
extern INT ImeRtl_StrnCmpW(LPCWSTR wszFirst, LPCWSTR wszLast, UINT uiCount);

// Since immxlib.lib call memmove internaly, we should define this function
// specifically ptrary.cpp, strary.cpp and fontlink.cpp
extern void * __cdecl memmove(void * dst, const void * src, size_t count);

#endif // __CRTFREE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "private.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI     "cicero.ini"
#define SZ_DEBUGSECTION "IMEKRCIC"
#define SZ_MODULE       "IMEKRCIC"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\config.h ===
/****************************************************************************
	CONFIG.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IME Configuration DLG and registry access functions

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_CONFIG_H__INCLUDED_)
#define _CONFIG_H__INCLUDED_

//////////////////////////////////////////////////////////////////////////////
// Bit const for SetRegValues
#define GETSET_REG_STATUSPOS		0x0001
#define GETSET_REG_IMEKL			0x0002
#define GETSET_REG_JASODEL			0x0004
#define GETSET_REG_ISO10646			0x0008
#define GETSET_REG_STATUS_BUTTONS	0x0010
#define GETSET_REG_KSC5657			0x0020
#define GETSET_REG_CANDUNICODETT	0x0040
#define GETSET_REG_ALL				0xFFFF

extern BOOL ConfigDLG(HWND hWnd);
extern BOOL GetRegValues(UINT uGetBits);	// get configuration info from reg. and set it to pImeData
extern BOOL GetStatusWinPosReg(POINT *pptStatusWinPosReg);
extern BOOL SetRegValues(UINT uSetBits); // set configuration info to reg.


#endif //!defined (_CONFIG_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\crtfree.cpp ===
#include "private.h"

// Thi is not working since ATL uses CRT dll. we should not use ATL to remove CRT bondage
#define CPP_FUNCTIONS
#include "icrtfree.h" // Code to help free modules from the bondage and tyranny of CRT libraries

#ifdef NOCLIB

#if defined(_M_IX86)

extern "C" int _fltused = 1;

/*----------------------------------------------------------------------------
    _ftol - convert a float value to an __int64.  The argument is on the top of
    the stack, the result is returned in EAX (low) and EDX (high).  Note that
    this is used for all float to integral convertion and deals with both
    signed and unsigned values - the compiler just ignores the EDX value.  The
    LongFromDouble and UlongFromDouble functions check the range, so this
    cavlier bitwise truncation doesn't matter.
------------------------------------------------------------------- JohnBo -*/
extern "C" __declspec(naked) void __cdecl _ftol(void)
{
   // A simple FISTP is all that is required (so why is this out of line?
    // possible the CRT version handles overflow differently?)
    __asm PUSH EDX;              // Just to make room on the stack
    __asm PUSH EAX;
    __asm FISTP QWORD PTR [ESP]; // Pop long off top of FP stack
    __asm POP EAX;               // And put back into EDX/EAX - tedious eh?
    __asm POP EDX;               // Stack grows downwards, so EDX is high.
    __asm RET;
}

#endif

/*
 *    memmove
 */
void * __cdecl memmove(void * dst, const void * src, size_t count)
{
    void * ret = dst;

    if (dst <= src || (char *)dst >= ((char *)src + count)) {
        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        // memcpy is intrinsic
        memcpy(dst, src, count);
    } else {
        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        dst = (char *)dst + count - 1;
        src = (char *)src + count - 1;
        while (count--) {
            *(char *)dst = *(char *)src;
            dst = (char *)dst - 1;
            src = (char *)src - 1;
        }
    }
    return(ret);
}

/*---------------------------------------------------------------------------
    StrCopyW
    Unicode String copy
---------------------------------------------------------------------------*/
LPWSTR ImeRtl_StrCopyW(LPWSTR pwDest, LPCWSTR pwSrc)
{
    LPWSTR pwStart = pwDest;

    while (*pwDest++ = *pwSrc++)
            ;
            
    return (pwStart);
}

/*---------------------------------------------------------------------------
    StrnCopyW
    Unicode String copy
---------------------------------------------------------------------------*/
LPWSTR ImeRtl_StrnCopyW(LPWSTR pwDest, LPCWSTR pwSrc, UINT uiCount)
{
    LPWSTR pwStart = pwDest;

    while (uiCount && (*pwDest++ = *pwSrc++))    // copy string 
        uiCount--;

    if (uiCount)                                // pad out with zeroes
        while (--uiCount)
            *pwDest++ = 0;

    return (pwStart);
}


/*---------------------------------------------------------------------------
    StrCmpW
    Unicode String compare
---------------------------------------------------------------------------*/
INT ImeRtl_StrCmpW(LPCWSTR pwSz1, LPCWSTR pwSz2)
{
    INT cch1 = lstrlenW(pwSz1);
    INT cch2 = lstrlenW(pwSz2);

    if (cch1 != cch2)
        return cch2 - cch1;

    for (INT i=0; i<cch1; i++)
        {
        if (pwSz1[i] != pwSz2[i])
            return i+1;
        }

    return 0;
}

/*---------------------------------------------------------------------------
    StrnCmpW
    Unicode String compare
---------------------------------------------------------------------------*/
INT ImeRtl_StrnCmpW(LPCWSTR wszFirst, LPCWSTR wszLast, UINT uiCount)
{
    if (!uiCount)
        return(0);

    while (--uiCount && *wszFirst && *wszFirst == *wszLast) 
        {
        wszFirst++;
        wszLast++;
        }
    return (*wszFirst - *wszLast);
}

/*---------------------------------------------------------------------------
    StrnCatW
    Unicode String concatenation
---------------------------------------------------------------------------*/
WCHAR * __cdecl Imertl_StrCatW(WCHAR *wszDest, const WCHAR *wszSource)
{
    WCHAR *wszStart = wszDest;
    WCHAR *pwch;

    for (pwch = wszDest; *pwch; pwch++);
    while (*pwch++ = *wszSource++);

    return(wszStart);
}

wchar_t * __cdecl wcscpy(wchar_t *a, const wchar_t *b)
{
    return ImeRtl_StrCopyW(a,b);
}

wchar_t * __cdecl wcsncpy(wchar_t *a, const wchar_t *b, size_t c)
{
    return ImeRtl_StrnCopyW(a,b,c);
}

size_t __cdecl wcslen(const wchar_t *a)
{
    return lstrlenW(a);
}

int __cdecl wcscmp(const wchar_t *a, const wchar_t *b)
{
    return ImeRtl_StrCmpW(a, b);
}

int __cdecl wcsncmp(const wchar_t *a, const wchar_t *b, size_t c)
{
    return ImeRtl_StrnCmpW(a, b, c);
}

wchar_t * __cdecl wcscat(wchar_t *pwSz1, const wchar_t *pwSz2)
{
    return Imertl_StrCatW(pwSz1, pwSz2);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\editssn.cpp ===
//
// editssn.cpp
//
// CEditSession2
//
#include "private.h"
#include "korimx.h"
#include "editssn.h"
#include "helpers.h"

#define SafeAddRef(x)        { if ((x)) { (x)->AddRef(); } }


/*   C  E D I T  S E S S I O N 2   */
/*------------------------------------------------------------------------------

    Constructor

------------------------------------------------------------------------------*/
CEditSession2::CEditSession2(ITfContext *pic, CKorIMX *ptip, ESSTRUCT *pess, PFNESCALLBACK pfnCallback)
{
    Assert(pic  != NULL);
    Assert(ptip != NULL);
    Assert(pess != NULL);

    m_cRef        = 1;
    m_pic         = pic;
    m_ptip        = ptip;
    m_ess         = *pess;
    m_pfnCallback = pfnCallback;

    // add reference count in the struct
    SafeAddRef(m_pic);
    SafeAddRef(m_ptip);
    SafeAddRef(m_ess.ptim);
    SafeAddRef(m_ess.pRange);
    SafeAddRef(m_ess.pEnumRange);
    SafeAddRef(m_ess.pCandList);
    SafeAddRef(m_ess.pCandStr);
}


/*   ~  C  E D I T  S E S S I O N 2   */
/*------------------------------------------------------------------------------

    Destructor

------------------------------------------------------------------------------*/
CEditSession2::~CEditSession2( void )
{
    SafeRelease(m_pic);
    SafeRelease(m_ptip);
    SafeRelease(m_ess.ptim);
    SafeRelease(m_ess.pRange);
    SafeRelease(m_ess.pEnumRange);
    SafeRelease(m_ess.pCandList);
    SafeRelease(m_ess.pCandStr);
}


/*   Q U E R Y  I N T E R F A C E   */
/*------------------------------------------------------------------------------

    Query interface of object
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI CEditSession2::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown ) || IsEqualIID(riid, IID_ITfEditSession)) 
        *ppvObj = SAFECAST(this, ITfEditSession*);

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}


/*   A D D  R E F   */
/*------------------------------------------------------------------------------

    Add reference count
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CEditSession2::AddRef()
{
    return ++m_cRef;
}


/*   R E L E A S E   */
/*------------------------------------------------------------------------------

    Release object
    (IUnknown method)

------------------------------------------------------------------------------*/
STDAPI_(ULONG) CEditSession2::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
        delete this;

    return cr;
}


/*   E D I T  S E S S I O N   */
/*------------------------------------------------------------------------------

    Callback function of edit session
    (ITfEditSession method)

------------------------------------------------------------------------------*/
STDAPI CEditSession2::DoEditSession(TfEditCookie ec)
{
    return m_pfnCallback(ec, this);
}


/*   I N V O K E   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
HRESULT CEditSession2::Invoke(DWORD dwFlag, HRESULT *phrSession)
{
    HRESULT hr;
    DWORD dwFlagES = 0;

    if ((m_pic == NULL) || (m_ptip == NULL))
        return E_FAIL;

    // read/readwrite flag

    switch (dwFlag & ES2_READWRITEMASK)
        {
    default:
    case ES2_READONLY: 
        dwFlagES |= TF_ES_READ;
        break;

    case ES2_READWRITE:
        dwFlagES |= TF_ES_READWRITE;
        break;
        }

    // sync/async flag

    switch (dwFlag & ES2_SYNCMASK)
        {
    default:
        Assert(fFalse);
    // fall through

    case ES2_ASYNC:
        dwFlagES |= TF_ES_ASYNC;
        break;

    case ES2_SYNC:
        dwFlagES |= TF_ES_SYNC;
        break;

    case ES2_SYNCASYNC:
        dwFlagES |= TF_ES_ASYNCDONTCARE;
        break;
        }

    // invoke

    m_fProcessed = FALSE;
    hr = m_pic->RequestEditSession(m_ptip->GetTID(), this, dwFlagES, phrSession);

    // try ASYNC session when SYNC session failed

    // NOTE: KOJIW:
    // How can we know if the edit session has been processed synchronously?

    // Satori#2409 - do not invoke callback twice
    //    if (!m_fProcessed && ((dwFlag & ES2_SYNCMASK) == ES2_SYNCASYNC)) { 
    //        hr = m_pic->EditSession( m_ptip->GetTID(), this, (dwFlagES & ~TF_ES_SYNC), phrSession );
    //    }

return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\fmode.h ===
//
// FMODE.H
//

#if !defined (__FMODE_H__INCLUDED_)
#define __FMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class FMode : public CCicButton
{
public:
    FMode(CToolBar *ptb);
    ~FMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
//    HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);

private:
    
	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __FMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\fnconfig.h ===
//
// config.h
//

#ifndef FNCONFIG_H
#define FNCONFIG_H

#include "private.h"
#include "ctffunc.h"

class CFunctionProvider;

//////////////////////////////////////////////////////////////////////////////
//
// CFnConfigure
//
//////////////////////////////////////////////////////////////////////////////

class CFnConfigure : public ITfFnConfigure,
                     public ITfFnConfigureRegisterWord
{
public:
    CFnConfigure(CFunctionProvider *pFuncPrv);
    ~CFnConfigure();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnConfigure
    //
    STDMETHODIMP Show(HWND hwnd, LANGID langid, REFGUID rguidProfile);

    //
    // ITfFnConfigureRegisterWord
    //
    STDMETHODIMP Show(HWND hwnd, LANGID langid, REFGUID rguidProfile, BSTR bstrRegistered);
    
private:
    CFunctionProvider *m_pFuncPrv;

    LONG m_cRef;
};

//////////////////////////////////////////////////////////////////////////////
//
// CFnShowHelp
//
//////////////////////////////////////////////////////////////////////////////

class CFnShowHelp : public ITfFnShowHelp
{
public:
    CFnShowHelp(CFunctionProvider *pFuncPrv);
    ~CFnShowHelp();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);

    //
    // ITfFnShowHelp
    //
    STDMETHODIMP Show(HWND hwnd);

private:
    CFunctionProvider *m_pFuncPrv;

    LONG m_cRef;
};


#endif // FNCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\fnconfig.cpp ===
//
// fnconfig.cpp
//

#include "private.h"
#include "fnconfig.h"
#include "funcprv.h"
#include "config.h"
#include "globals.h"
#include "helpers.h"
#include "userex.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////////
//
// CFnConfigure
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnConfigure::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ITfFnConfigure))
        *ppvObj = SAFECAST(this, CFnConfigure *);

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnConfigure::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDAPI_(ULONG) CFnConfigure::Release()
{
    long cr;

    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);

    if (cr == 0)
        delete this;

    return cr;
}


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnConfigure::CFnConfigure(CFunctionProvider *pFuncPrv)
{
    m_pFuncPrv = pFuncPrv;
    m_pFuncPrv->AddRef();
    m_cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnConfigure::~CFnConfigure()
{
    SafeRelease(m_pFuncPrv);
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnConfigure::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Microsoft Korean Keyboard Input Configure");
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CFnConfigure::Show(HWND hwnd, LANGID langid, REFGUID rguidProfile)
{
    if (ConfigDLG(hwnd))
        return S_OK;
    else
        return E_FAIL;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CFnConfigure::Show(HWND hwnd, LANGID langid, REFGUID rguidProfile, BSTR bstrRegistered)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnShowHelp
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnShowHelp::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnShowHelp))
    {
        *ppvObj = SAFECAST(this, CFnShowHelp *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnShowHelp::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDAPI_(ULONG) CFnShowHelp::Release()
{
    long cr;

    cr = InterlockedDecrement(&m_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}


//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnShowHelp::CFnShowHelp(CFunctionProvider *pFuncPrv)
{
    m_pFuncPrv = pFuncPrv;
    m_pFuncPrv->AddRef();
    m_cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnShowHelp::~CFnShowHelp()
{
    SafeRelease(m_pFuncPrv);
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnShowHelp::GetDisplayName(BSTR *pbstrName)
{
    WCHAR  szText[MAX_PATH];

    // Load Help display name
    LoadStringExW(g_hInst, IDS_HELP_DISPLAYNAME, szText, sizeof(szText)/sizeof(WCHAR));

    *pbstrName = SysAllocString(szText);
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CFnShowHelp::Show(HWND hwnd)
{
    CHAR szHelpFileName[MAX_PATH];
    CHAR szHelpCmd[MAX_PATH];

    // Load Help display name
    LoadStringExA(g_hInst, IDS_HELP_FILENAME, szHelpFileName, sizeof(szHelpFileName)/sizeof(CHAR));

    wsprintf(szHelpCmd, "hh.exe %s", szHelpFileName);
    WinExec(szHelpCmd, SW_NORMAL);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\fnrecon.cpp ===
//
// reconv.cpp
//

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "candlstx.h"
#include "fnrecon.h"
#include "funcprv.h"
#include "helpers.h"
#include "immxutil.h"
#include "editcb.h"
#include "hanja.h"
#include "ucutil.h"

//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFunction::CFunction(CFunctionProvider *pFuncPrv)
{
    _pFuncPrv = pFuncPrv;
    _pFuncPrv->AddRef();
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFunction::~CFunction()
{
    SafeRelease(_pFuncPrv);
}

#if 1

//+---------------------------------------------------------------------------
//
// CFunction::GetTarget
//
//----------------------------------------------------------------------------

HRESULT CFunction::GetTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp, WCHAR **ppszText, ULONG *pcch)
{
    ITfProperty*    pProp;
    ITfRange*       pRangeTmp = NULL;

    // init
    *pcch = 0;
    
    // AIMM?
    if (CKorIMX::GetAIMM(pic))
        {
        // Allocate just one char string buffer
        *ppszText = new WCHAR[2];
        Assert(*ppszText != NULL);
        if (*ppszText == NULL)
            return E_OUTOFMEMORY;

        pRange->Clone(&pRangeTmp);

        *pcch = 1;
        pRangeTmp->GetText(ec, 0, *ppszText, sizeof(WCHAR), pcch);
        *((*ppszText) + 1) = L'\0';

        *ppRangeTmp = pRangeTmp;
        return S_OK;
        }

    // if reading prop exist.
    if (SUCCEEDED(pic->GetProperty(GUID_PROP_READING, &pProp)))
        {
        ITfRange *pPropRange;
        HRESULT hr = pProp->FindRange(ec, pRange, &pPropRange, TF_ANCHOR_START);
        
        if (SUCCEEDED(hr) && pPropRange)
            {
            BSTR bstr;

            if (SUCCEEDED(GetBSTRPropertyData(ec, pProp, pPropRange, &bstr)))
                {
                pPropRange->Clone(&pRangeTmp);
                if (bAdjust || CompareRanges(ec, pRange, pRangeTmp) == CR_EQUAL)
                    {
                    *pcch = SysStringLen(bstr);
                    *ppszText = new WCHAR[*pcch + 1];
                    wcscpy(*ppszText, bstr);
                    }
                }
            SysFreeString(bstr);
            pPropRange->Release();
            }
        pProp->Release();
        }

    // If no reading property
    if (!(*ppszText))
        {
        LONG cch;
        BOOL fEmpty;

        pRange->IsEmpty(ec, &fEmpty);
        
        pRange->Clone(&pRangeTmp);
        // Select only one char
        if (!fEmpty)
            {
            pRangeTmp->Collapse(ec, TF_ANCHOR_START);
            pRangeTmp->ShiftEnd(ec, 1, &cch, NULL);
            }
        else
            {
            pRangeTmp->ShiftEnd(ec, 1, &cch, NULL);
            if (cch==0)
                pRangeTmp->ShiftStart(ec, -1, &cch, NULL);
            }
            
        Assert(cch != 0);
        
        if (cch)
            {
            // Allocate just one char string buffer
            *ppszText = new WCHAR[2];
            Assert(*ppszText != NULL);
            if (*ppszText == NULL)
                return E_OUTOFMEMORY;
            
            *pcch = 1;
            pRangeTmp->GetText(ec, 0, *ppszText, sizeof(WCHAR), pcch);
            *((*ppszText) + 1) = L'\0';

            // Office #154974
            // If there is any embedded char exist, skip it forward.
            while (**ppszText == TS_CHAR_EMBEDDED)
                {
                pRangeTmp->ShiftStart(ec, 1, &cch, NULL);
                if (cch == 0)
                    break;
                pRangeTmp->ShiftEnd(ec, 1, &cch, NULL);
                if (cch == 0)
                    break;

                *pcch = 1;
                pRangeTmp->GetText(ec, 0, *ppszText, sizeof(WCHAR), pcch);
                *((*ppszText) + 1) = L'\0';
                }
            }

        }

    *ppRangeTmp = pRangeTmp;

    return S_OK;
}
#else
//+---------------------------------------------------------------------------
//
// CFunction::GetTarget
//
//----------------------------------------------------------------------------

HRESULT CFunction::GetTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp, WCHAR **ppszText, ULONG *pcch)
{
    ITfRange *pRangeTmp = NULL;
    LONG  cch;
    BOOL fEmpty;

    *pcch = 0;
    pRange->IsEmpty(ec, &fEmpty);
    
    if (!fEmpty)
        {
        pRange->Clone(&pRangeTmp);
        pRangeTmp->Collapse(ec, TF_ANCHOR_START);
        pRangeTmp->ShiftEnd(ec, 1, &cch, NULL);
        if (cch)
            {
            *ppszText = new WCHAR[2];
            *pcch = 1;
            pRangeTmp->GetText(ec, 0, *ppszText, sizeof(WCHAR), pcch);
            *((*ppszText) + 1) = L'\0';
            }
        }
    else
        {
        pRange->Clone(&pRangeTmp);
        pRangeTmp->ShiftEnd(ec, 1, &cch, NULL);
        if (cch)
            {
            *ppszText = new WCHAR[2];
            *pcch = 1;
            pRangeTmp->GetText(ec, 0, *ppszText, sizeof(WCHAR), pcch);
            *((*ppszText) + 1) = L'\0';
            }
        }
        
    *ppRangeTmp = pRangeTmp;
    
    return S_OK;
}
#endif

//+---------------------------------------------------------------------------
//
// CFunction::GetFocusedTarget
//
//----------------------------------------------------------------------------

BOOL CFunction::GetFocusedTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp)
{
    ITfRange *pRangeTmp = NULL;
    ITfRange *pRangeTmp2 = NULL;
    IEnumTfRanges *pEnumTrack = NULL;
    ITfRange *pPropRange;
    ITfReadOnlyProperty *pProp = NULL;
    BOOL bRet = FALSE;
    BOOL fWholeDoc = FALSE;

    if (!pRange)
    {
        fWholeDoc = TRUE;

        if (FAILED(GetRangeForWholeDoc(ec, pic, &pRange)))
            return FALSE;
    }

    if (bAdjust)
    {
        //
        // multi owner and PF_FOCUS range support.
        //

        if (FAILED(AdjustRangeByTextOwner(ec, pic,
                                          pRange, 
                                          &pRangeTmp2,
                                          CLSID_KorIMX))) 
            goto Exit;

        GUID rgGuid[1]; 
        rgGuid[0] = GUID_ATTR_KORIMX_INPUT;

        if (FAILED(AdjustRangeByAttribute(_pFuncPrv->_pime->_GetLibTLS(), 
                                          ec, pic,
                                          pRangeTmp2, 
                                          &pRangeTmp,
                                          rgGuid, 1))) 
            goto Exit;
    }
    else
    {
        pRange->Clone(&pRangeTmp);
    }

    //
    // check if there is an intersection of PF_FOCUS range and owned range.
    // if there is no such range, we return FALSE.
    //
    if (FAILED(EnumTrackTextAndFocus(ec, pic, pRangeTmp, &pProp, &pEnumTrack)))
        goto Exit;

    while(pEnumTrack->Next(1, &pPropRange,  0) == S_OK)
    {
        if (IsOwnerAndFocus(_pFuncPrv->_pime->_GetLibTLS(), ec, CLSID_KorIMX, pProp, pPropRange))
            bRet = TRUE;

        pPropRange->Release();
    }
    pProp->Release();

    if (bRet)
    {
        *ppRangeTmp = pRangeTmp;
        (*ppRangeTmp)->AddRef();
    }

Exit:
    SafeRelease(pEnumTrack);
    SafeRelease(pRangeTmp);
    SafeRelease(pRangeTmp2);
    if (fWholeDoc)
        pRange->Release();
    return bRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// CFnReconversion
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::QueryInterface(REFIID riid, void **ppvObj)
{
#if NEVER
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfFnReconversion))
    {
        *ppvObj = SAFECAST(this, CFnReconversion *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }
#endif 
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CFnReconversion::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDAPI_(ULONG) CFnReconversion::Release()
{
    long cr;

    cr = InterlockedDecrement(&_cRef);
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CFnReconversion::CFnReconversion(CKorIMX *pKorImx, CFunctionProvider *pFuncPrv) : CFunction(pFuncPrv)
{
    m_pKorImx = pKorImx;
    _cRef = 1;
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CFnReconversion::~CFnReconversion()
{
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Hanja Conv");
    return S_OK;
}
//+---------------------------------------------------------------------------
//
// CFnReconversion::IsEnabled
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::IsEnabled(BOOL *pfEnable)
{
    *pfEnable = TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::QueryRange
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfConvertable)
{
    CEditSession2 *pes;
    ITfContext    *pic;
    ESSTRUCT       ess;
    HRESULT       hr = E_OUTOFMEMORY;

    if (!pRange || !ppNewRange || !pfConvertable)
        return E_INVALIDARG;

    if (FAILED(pRange->GetContext(&pic)))
        goto Exit;

    ESStructInit(&ess, ESCB_RECONV_QUERYRECONV);
    
    ess.pRange = pRange;
    ess.pv1    = this;
    ess.pv2    = ppNewRange;

    if ((pes = new CEditSession2(pic, m_pKorImx, &ess, CKorIMX::_EditSessionCallback2)) != NULL)
        {
        pes->Invoke(ES2_READONLY | ES2_SYNC, &hr);
        pes->Release();
        }

    *pfConvertable = (hr == S_OK);
    if (hr == S_FALSE)
        hr = S_OK;
 
    pic->Release();

Exit:

    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::_QueryRange
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::_QueryRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppNewRange)
{
    ULONG cch = 0;
    WCHAR *pszText = NULL;
    HRESULT hr = E_FAIL;
    ITfRange *pRangeTmp = NULL;

    //
    // KIMX doesn't support entire document reconversion.
    //
    if (!pRange)
        return hr;

    GetTarget(ec, pic, pRange, ppNewRange ? TRUE : FALSE, &pRangeTmp, &pszText, &cch);

    if (cch)
    {
        if (ppNewRange)
            pRangeTmp->Clone(ppNewRange);

        hr = S_OK;

        // In case of AIMM we should return error if the input char can't be coverted.
        if (CKorIMX::GetAIMM(pic))
            {
            HANJA_CAND_STRING_LIST     CandStrList;
            if (GetConversionList(*pszText, &CandStrList))
                {
                // free buffer and return
                cicMemFree(CandStrList.pwsz);
                cicMemFree(CandStrList.pHanjaString);
                }
            else
                hr = S_FALSE;
            }
    }
    else
        hr = S_FALSE;
    
    if (pszText)
        delete pszText;

    SafeRelease(pRangeTmp);
    return hr;
}


//+---------------------------------------------------------------------------
//
// CFnReconversion::GetReconversion
//
//----------------------------------------------------------------------------

STDAPI CFnReconversion::GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList)
{
    ITfContext *pic;
    CCandidateListEx *pCandList;
    HRESULT hr;

    if (!pRange || !ppCandList)
        return E_INVALIDARG;

    if (FAILED(pRange->GetContext(&pic)))
        return E_FAIL;

    hr = GetReconversionProc(pic, pRange, &pCandList, fFalse);
    
    if (pCandList != NULL)
        {
        pCandList->QueryInterface( IID_ITfCandidateList, (void**)ppCandList );
        pCandList->Release();
        }
    
    pic->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::_GetReconversion
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::_GetReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, CCandidateListEx **ppCandList, BOOL fSelection)
{
    ULONG cch = 0;
    WCHAR *pszReading = NULL;
    HRESULT hr = E_FAIL;
    ITfRange *pRangeTmp = NULL;
    CCandidateStringEx *pCandExtraStr;
    
    GetTarget(ec, pic, pRange, TRUE, &pRangeTmp, &pszReading, &cch);

    if (cch)
        {
        CCandidateListEx          *pCandList;
        HANJA_CAND_STRING_LIST     CandStrList;
        WCHAR                       szCand[2];
        WCHAR                    wch = 0;
        ULONG                    cch;
        
        // build candidate list
        pCandList = new CCandidateListEx(SetResult, pic, pRangeTmp);
        Assert(pCandList != NULL);
        if (pCandList == NULL)
            return E_OUTOFMEMORY;

        // Copy reading string
        wcscpy(_szReading, pszReading);

        // Get conv list from Hanja dict
        if (GetConversionList(*pszReading, &CandStrList))
            {
            // If AIMM, don't select coversion char.
            if (!CKorIMX::GetAIMM(pic))
                {
                // If there candidate exist, Set selection converting char
                if (fSelection)
                    SetSelectionSimple(ec, pic, pRangeTmp);

                // if it is Hanja already converted, Add Hangul pronoun as extra cand str.
                pRangeTmp->GetText(ec, 0, &wch, sizeof(WCHAR), &cch);

                if (cch && !fIsHangul(wch))
                    {
                    pCandList->AddExtraString(pszReading, MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), NULL, this, &pCandExtraStr);
                    pCandExtraStr->Release();
                    }
                }

            for (UINT i=0; i<CandStrList.csz; i++)
                {
                //LANGID langid = GetLangIdFromCand(pszReading, pchCand);
                CCandidateStringEx *pCandStr;
                 
                szCand[0] = CandStrList.pHanjaString[i].wchHanja;
                szCand[1] = L'\0';
                pCandList->AddString(szCand,
                                       MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), 
                                       NULL, this, &pCandStr);

                pCandStr->SetInlineComment(CandStrList.pHanjaString[i].wzMeaning);
                pCandStr->m_bHanjaCat = CandStrList.pHanjaString[i].bHanjaCat;
                pCandStr->SetReadingString(_szReading);

                pCandStr->Release();
                }
            // free buffer and return
            cicMemFree(CandStrList.pwsz);
            cicMemFree(CandStrList.pHanjaString);
            *ppCandList = pCandList;

            hr = S_OK;
            }
        }

    if (pszReading)
        delete pszReading;

    SafeRelease(pRangeTmp);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::Reconvert
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::Reconvert(ITfRange *pRange)
{
    CCandidateListEx *pCandList = NULL;
    ITfRange   *pRangeTmp = NULL;
    ITfContext *pic;
    HRESULT hr;

    if (!pRange)
        return E_INVALIDARG;

    hr = E_FAIL;

    if (FAILED(pRange->Clone(&pRangeTmp)))
        goto Exit;

    if (FAILED(pRange->GetContext(&pic)))
        goto Exit;

    if (SUCCEEDED(hr = GetReconversionProc(pic, pRange, &pCandList, fTrue))) 
        {
        hr = ShowCandidateList(pic, pRange, pCandList);
        SafeRelease(pCandList);
        }

    SafeRelease(pRangeTmp);
    SafeRelease(pic);

Exit:
    return hr;
}




/*   G E T  R E C O N V E R S I O N  P R O C   */
/*------------------------------------------------------------------------------

    Get candidate list of reconversion 

------------------------------------------------------------------------------*/
HRESULT CFnReconversion::GetReconversionProc(ITfContext *pic, ITfRange *pRange, CCandidateListEx **ppCandList, BOOL fSelection)
{
    CEditSession2 *pes;
    ESSTRUCT        ess;
    HRESULT        hr;

    if (!ppCandList)
        return E_INVALIDARG;

    *ppCandList = NULL;

    ESStructInit(&ess, ESCB_RECONV_GETRECONV);
    ess.pRange    = pRange;
    ess.pv1       = this;
    ess.pv2       = ppCandList;
    ess.fBool      = fSelection;

    hr = E_OUTOFMEMORY;
    
    if ((pes = new CEditSession2(pic, m_pKorImx, &ess, CKorIMX::_EditSessionCallback2)))
        {
        if (fSelection)
            pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
        else
            pes->Invoke(ES2_READONLY | ES2_SYNC, &hr);
        
        pes->Release();
        }

    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::ShowCandidateList
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::ShowCandidateList(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList)
{
    CEditSession2 *pes;
    ESSTRUCT        ess;
    HRESULT        hr;

    hr = E_OUTOFMEMORY;

    ESStructInit(&ess, ESCB_RECONV_SHOWCAND);
    ess.pRange    = pRange;
    ess.pv1       = this;
    ess.pCandList = pCandList;

    if ((pes = new CEditSession2(pic, m_pKorImx, &ess, CKorIMX::_EditSessionCallback2)))
        {
        pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
        pes->Release();
        }
        
    return hr;
}

//+---------------------------------------------------------------------------
//
// CFnReconversion::SetResult 
// (Static function)
//
//----------------------------------------------------------------------------

HRESULT CFnReconversion::SetResult(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList, CCandidateStringEx *pCand, TfCandidateResult imcr)
{
    CEditSession2   *pes;
    ESSTRUCT         ess;
    CFnReconversion *pReconv = (CFnReconversion *)(pCand->m_punk);
    ITfRange        *pRangeTmp;
    HRESULT         hr;

    hr = E_OUTOFMEMORY;
    
    if (SUCCEEDED(pRange->Clone(&pRangeTmp)))
        {
        if (imcr == CAND_FINALIZED)
            {
            ESStructInit(&ess, ESCB_FINALIZERECONVERSION);
            ess.pCandList = pCandList;
            ess.pCandStr  = pCand;
            //pCandList->AddRef();        // be released in edit session callback
            //pCand->AddRef();
            }
        else
        if (imcr == CAND_SELECTED)
            ESStructInit(&ess, ESCB_ONSELECTRECONVERSION);
        else 
        if (imcr == CAND_CANCELED)
            ESStructInit(&ess, ESCB_ONCANCELRECONVERSION);

        // Save useful parameters
        ess.pv1       = pReconv;
        ess.lParam       = pReconv->_pFuncPrv->_pime->GetTID();
        ess.pRange       = pRangeTmp;

        if ((pes = new CEditSession2(pic, pReconv->m_pKorImx, &ess, CKorIMX::_EditSessionCallback2)))
            {
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        // Call back function must release pRangeTmp
        // pRangeTmp->Release();
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\editssn.h ===
//
// editssn.h
//
// CEditSession2
//

#ifndef EDITSES_H
#define EDITSES_H

class CKorIMX;
class CEditSession2;


//
// structure
//

typedef struct _ESSTRUCT
{
	DWORD				id;
	ITfThreadMgr		*ptim;
	ITfRange			*pRange;
	IEnumTfRanges		*pEnumRange;
	CCandidateListEx	*pCandList;
	CCandidateStringEx	*pCandStr;
	VOID				*pv1;
	VOID				*pv2;
	WPARAM				wParam;
	LPARAM				lParam;
	BOOL				fBool;
} ESSTRUCT;


//
// flags
//

/* read/readwrite flag */
#define ES2_READONLY			0x00000000
#define ES2_READWRITE			0x00000001

/* sync/async flag */
#define ES2_ASYNC				0x00000010
#define ES2_SYNC				0x00000020
#define ES2_SYNCASYNC			0x00000030

/* mask bits */
#define ES2_READWRITEMASK		0x0000000F
#define ES2_SYNCMASK			0x000000F0


//
// callback function
// 

typedef HRESULT (*PFNESCALLBACK)( TfEditCookie ec, CEditSession2 *pes );


//
// misc function
//

__inline void ESStructInit( ESSTRUCT *pess, DWORD id )
{
	ZeroMemory(pess, sizeof(ESSTRUCT));
	pess->id = id;
}


//
// CEditSession2
//

class CEditSession2 : public ITfEditSession
{
public:
	CEditSession2(ITfContext *pic, CKorIMX *ptip, ESSTRUCT *pess, PFNESCALLBACK pfnCallback);
	virtual ~CEditSession2();

	//
	// IUnknown methods
	//
	STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//
	// ITfEditSession
	//
	STDMETHODIMP DoEditSession(TfEditCookie ec);

	//
	//
	//
	HRESULT Invoke(DWORD dwFlag, HRESULT *phrSession);

	__inline ITfContext *GetContext()
	{
		return m_pic;
	}

	__inline CKorIMX *GetTIP()
	{
		return m_ptip;
	}

	__inline ESSTRUCT *GetStruct()
	{
		return &m_ess;
	}

	__inline void Processed() 
	{ 
		m_fProcessed = TRUE; 
	}

private:
	ULONG			m_cRef;
	ITfContext		*m_pic;
	CKorIMX			*m_ptip;
	ESSTRUCT		m_ess;
	PFNESCALLBACK	m_pfnCallback;

	BOOL			m_fProcessed;
};

#endif // EDITSES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\fmode.cpp ===
/****************************************************************************
   FMODE.CPP : FMode class implementation which manage Full/Half shape mode 
                   button on the Cicero Toolbar

   History:
      23-FEB-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "fmode.h"
#include "userex.h"
#include "resource.h"

// {D96498AF-0E46-446e-8F00-E113236FD22D}
const GUID GUID_LBI_KORIMX_FMODE = 
{   
    0xd96498af, 
    0x0e46, 
    0x446e, 
    { 0x8f, 0x0, 0xe1, 0x13, 0x23, 0x6f, 0xd2, 0x2d }
};

/*---------------------------------------------------------------------------
    FMode::FMode
---------------------------------------------------------------------------*/
FMode::FMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    // Set Add/Remove and tootip text
    LoadStringExW(g_hInst, IDS_TT_JUN_BAN, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_KorIMX, 
                GUID_LBI_KORIMX_FMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_HIDDENBYDEFAULT | TF_LBI_STYLE_TEXTCOLORICON,
                110, 
                szText);
    SetToolTip(szText);

    // Set button text
    LoadStringExW(g_hInst, IDS_BUTTON_JUN_BAN, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}

/*---------------------------------------------------------------------------
    FMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) FMode::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    FMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI FMode::GetIcon(HICON *phIcon)
{
    DWORD dwCM = GetCMode();
    UINT uiIcon = 0;
    static const UINT uidIcons[2][2] = 
    {
        { IDI_CMODE_BANJA, IDI_CMODE_BANJAW },
        { IDI_CMODE_JUNJA,  IDI_CMODE_JUNJAW }
    };

    if (m_pTb->IsOn() && (m_pTb->GetConversionMode() & TIP_JUNJA_MODE))
        uiIcon = 1;

    if (IsHighContrastBlack())
        uiIcon = uidIcons[uiIcon][1];
    else
        uiIcon = uidIcons[uiIcon][0];

    *phIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    FMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI FMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    FMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI FMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
// OnLButtonUp
//
//----------------------------------------------------------------------------

HRESULT FMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    DWORD dwConvMode;

    dwConvMode = GetCMode();

    // Toggle Full/Half mode
    if (dwConvMode & TIP_JUNJA_MODE)
        dwConvMode &= ~TIP_JUNJA_MODE;
    else
        dwConvMode |= TIP_JUNJA_MODE;

    SetCMode(dwConvMode);
    
    return S_OK;
}


#if 0
//+---------------------------------------------------------------------------
//
// OnRButtonUp
//
//----------------------------------------------------------------------------

HRESULT FMode::OnRButtonUp(const POINT pt, const RECT* prcArea)
{
    HMENU hMenu;
    DWORD dwConvMode;
    CHAR  szText[256];
    UINT  uiId;
    int   nRet;

    hMenu = CreatePopupMenu();

    dwConvMode = GetCMode();
    if (dwConvMode & TIP_JUNJA_MODE)
        uiId = IDS_BANJA_MODE;
    else
        uiId = IDS_JUNJA_MODE;

    // Add Hangul/English mode menu
    LoadStringExA(g_hInst, uiId, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 1, szText);

    // Add Cancel menu
    LoadStringExA(g_hInst, IDS_CANCEL, szText, sizeof(szText)/sizeof(CHAR));
    InsertMenu(hMenu, -1, MF_BYPOSITION | MF_STRING, 0, szText);

    nRet = TrackPopupMenuEx(hMenu, 
                         TPM_LEFTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                         pt.x, pt.y, m_pTb->GetOwnerWnd(), NULL);

    switch (nRet)
        {
    case 1: 
        dwConvMode = GetCMode();

        // Toggle Full/Half mode
        if (dwConvMode & TIP_JUNJA_MODE)
            dwConvMode &= ~TIP_JUNJA_MODE;
        else
            dwConvMode |= TIP_JUNJA_MODE;

        SetCMode(dwConvMode);
        break;
        }

    DestroyMenu(hMenu);

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\fnrecon.h ===
//
// fnrecon.h
//

#ifndef FNRECON_H
#define FNRECON_H

#include "private.h"
#include "candlstx.h"

class CFunctionProvider;

//////////////////////////////////////////////////////////////////////////////
//
// CFunction
//
//////////////////////////////////////////////////////////////////////////////

class CFunction
{
public:
    CFunction(CFunctionProvider *pFuncPrv);
    ~CFunction();

protected:
    HRESULT GetTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp, WCHAR **ppszText, ULONG *pcch);
    BOOL GetFocusedTarget(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, BOOL bAdjust, ITfRange **ppRangeTmp);

friend CKorIMX;
    CFunctionProvider *_pFuncPrv;
};


//////////////////////////////////////////////////////////////////////////////
//
// CFnRecovnersion
//
//////////////////////////////////////////////////////////////////////////////

// !!! WARNING !!! 
// This is temp code should be removed in the future
#define MAXREADING 256

class CFnReconversion : public ITfFnReconversion,
                        public CFunction
{
public:
    CFnReconversion(CKorIMX* pKorImx, CFunctionProvider *pFuncPrv);
    ~CFnReconversion();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfFunction
    //
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP IsEnabled(BOOL *pfEnable);

    //
    // ITfFnReconversion
    //
    STDMETHODIMP QueryRange(ITfRange *pRange, ITfRange **ppNewRange, BOOL *pfConvertable);
	STDMETHODIMP GetReconversion(ITfRange *pRange, ITfCandidateList **ppCandList);
    STDMETHODIMP Reconvert(ITfRange *pRange);

    static HRESULT SetResult(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList, CCandidateStringEx *pCand, TfCandidateResult imcr);

	HRESULT _QueryRange(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, ITfRange **ppNewRange);
	HRESULT _GetReconversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, CCandidateListEx **ppCandList, BOOL fSelection);

private:
	HRESULT GetReconversionProc( ITfContext *pic, ITfRange *pRange, CCandidateListEx **ppCandList, BOOL fSelection);
    HRESULT ShowCandidateList(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList);
//    static HRESULT _EditSessionCallback2(TfEditCookie ec, CEditSession2 *pes);

    WCHAR _szReading[MAXREADING];
    CKorIMX* m_pKorImx;
    long _cRef;
};

#endif // FNRECON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\focus.cpp ===
/****************************************************************************
   FOCUS.CPP : CKorIMX's Candidate UI member functions implementation
   
   History:
      08-FEB-2000 CSLim Created
****************************************************************************/
#include "private.h"
#include "korimx.h"
#include "immxutil.h"
#include "globals.h"

/*---------------------------------------------------------------------------
    CKorIMX::OnSetThreadFocus    (Called from Activate)
    
    This methods is called when the user switches focus between threads.  
    TIP should restore its ui (status windows, etc.) in this case.
---------------------------------------------------------------------------*/
STDAPI CKorIMX::OnSetThreadFocus()
{
    TraceMsg(TF_GENERAL, "ActivateUI: (%x) fActivate = %x, wnd thread = %x",
                GetCurrentThreadId(), TRUE, GetWindowThreadProcessId(GetOwnerWnd(), NULL));

    if (m_pCandUI != NULL)
        {
        ITfCandUICandWindow *pCandWindow;
        
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUICandWindow, (IUnknown**)&pCandWindow)))
            {
            pCandWindow->Show(fTrue);
            pCandWindow->Release();
            }
        }

    if (m_pToolBar)
        m_pToolBar->SetUIFocus(fTrue);

    if (IsSoftKbdEnabled())
        SoftKbdOnThreadFocusChange(fTrue);
        
    return S_OK;
}


/*---------------------------------------------------------------------------
    CKorIMX::OnKillThreadFocus   (Called from Deactivate)

    This methods is called when the user switches focus between threads.  
    TIP should hide its ui (status windows, etc.) in this case.
---------------------------------------------------------------------------*/
STDAPI CKorIMX::OnKillThreadFocus()
{
    TraceMsg(TF_GENERAL, "DeactivateUI: (%x) wnd thread = %x",
             GetCurrentThreadId(), GetWindowThreadProcessId(GetOwnerWnd(), NULL));

    if (m_pCandUI != NULL)
        {
        ITfCandUICandWindow *pCandWindow;
        
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUICandWindow, (IUnknown**)&pCandWindow)))
            {
            pCandWindow->Show(fFalse);
            pCandWindow->Release();
            }
        }

#if 0
    m_pStatusWnd->Show(FALSE);
#endif

    if (m_pToolBar)
        m_pToolBar->SetUIFocus(fFalse);

    if (IsSoftKbdEnabled())
        SoftKbdOnThreadFocusChange(fFalse);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\globals.h ===
//
//   Globals.h : Global variable declarations.
//
//   History:
//      15-NOV-1999 CSLim Created

#if !defined (__GLOBALS_H__INCLUDED_)
#define __GLOBALS_H__INCLUDED_


///////////////////////////////////////////////////////////////////////////////
// Global variables
extern HINSTANCE g_hInst;
extern LONG g_cRefDll;

extern const GUID GUID_ATTR_KORIMX_INPUT;
extern const GUID GUID_IC_PRIVATE;
extern const GUID GUID_COMPARTMENT_KORIMX_CONVMODE;
extern const GUID GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE;

extern const GUID GUID_KOREAN_HANGULSIMULATE;
extern const GUID GUID_KOREAN_HANJASIMULATE;

// SoftKbd
extern const GUID GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE;
extern const GUID GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT;
extern const GUID GUID_COMPARTMENT_SOFTKBD_WNDPOSITION;

extern CRITICAL_SECTION g_cs;

///////////////////////////////////////////////////////////////////////////////
// Window class names
const TCHAR c_szOwnerWndClass[]  = TEXT("KorIMX OwnerWndClass");

///////////////////////////////////////////////////////////////////////////////
// Inline functions

// Shift and Ctrl key check helper functions
inline
BOOL IsShiftKeyPushed(const BYTE lpbKeyState[256])
{
	return ((lpbKeyState[VK_SHIFT] & 0x80) != 0);
}

inline 
BOOL IsControlKeyPushed(const BYTE lpbKeyState[256])
{
	return ((lpbKeyState[VK_CONTROL] & 0x80) != 0);
}

inline 
BOOL IsAltKeyPushed(const BYTE lpbKeyState[256])
{
	return ((lpbKeyState[VK_MENU] & 0x80) != 0);
}

#endif // __GLOBALS_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\gdata.cpp ===
/****************************************************************************
    GDATA.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Instance data and Shared memory data management functions

    History:
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "private.h"
#include "hanja.h"
#include "immsec.h"
#include "debug.h"
#include "config.h"
#include "gdata.h"
#include "lexheader.h"

// CIMEData static variables
HANDLE       CIMEData::m_vhSharedData = 0;

static const CHAR IMEKR_IME_SHAREDDATA_MUTEX_NAME[] =  "ImeKr61ImeData.Mutex";
static const CHAR IMEKR_IME_SHAREDDATA_NAME[] = "ImeKr61ImeData.SharedMemory";

__inline BOOL DoEnterCriticalSection(HANDLE hMutex)
{
    if(WAIT_FAILED==WaitForSingleObject(hMutex, 3000))    // Wait 3 seconds
        return(FALSE);
    return(TRUE);
}

BOOL CIMEData::InitSharedData()
{
    HANDLE hMutex;
    BOOL fRet = fFalse;
    LPIMEDATA pImedata;

    DebugMsg(DM_TRACE, TEXT("InitSharedData"));

       hMutex = CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_IME_SHAREDDATA_MUTEX_NAME);
       if (hMutex != NULL)
           {
           // *** Begin Critical Section ***
           DoEnterCriticalSection(hMutex);

        if((m_vhSharedData = OpenFileMapping(FILE_MAP_READ|FILE_MAP_WRITE, fTrue, IMEKR_IME_SHAREDDATA_NAME)))
            {
            DebugMsg(DM_TRACE, TEXT("InitSharedData - IME shared data already exist"));
            fRet = fTrue;
            }
        else    // if shared memory does not exist
            {
            m_vhSharedData = CreateFileMapping(INVALID_HANDLE_VALUE, GetIMESecurityAttributes(), PAGE_READWRITE, 
                                0, sizeof(IMEDATA),
                                IMEKR_IME_SHAREDDATA_NAME);
            Assert(m_vhSharedData != 0);
            // if shared memory not exist create it
            if (m_vhSharedData) 
                {
                  DebugMsg(DM_TRACE, TEXT("InitSharedData::InitSharedData() - File mapping Created"));
                pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);

                if (!pImedata)
                    {
                    Assert(0);
                    goto ExitCreateSharedData;
                    }

                // initialize the data to zero
                ZeroMemory(pImedata, sizeof(IMEDATA));
                // Unint value of status and comp window position
                pImedata->ptStatusPos.x = pImedata->ptStatusPos.y = -1;
                pImedata->ptCompPos.x = pImedata->ptCompPos.y = -1;

                // Unmap memory
                UnmapViewOfFile(pImedata);
                DebugMsg(DM_TRACE, TEXT("IME shared data handle created successfully"));
                fRet = fTrue;
                }
            }
            
    ExitCreateSharedData:
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
           // *** End Critical Section ***
           }
       
    FreeIMESecurityAttributes();

    return fRet;
}

// Close shared memory handle. This called when process detach time.
BOOL CIMEData::CloseSharedMemory()
{
    HANDLE hMutex;
    BOOL fRet = fTrue;

    DebugMsg(DM_TRACE, TEXT("CloseSharedMemory"));

    hMutex = CreateMutex(GetIMESecurityAttributes(), fFalse, IMEKR_IME_SHAREDDATA_MUTEX_NAME);
       // *** Begin Critical Section ***
       DoEnterCriticalSection(hMutex);
    if (m_vhSharedData)
        {
        if (fRet = CloseHandle(m_vhSharedData))
            m_vhSharedData = 0;
        Assert(fRet);
        }
    ReleaseMutex(hMutex);
    CloseHandle(hMutex);
       // *** End Critical Section ***
       FreeIMESecurityAttributes();

    return fTrue;
}

///////////////////////////////////////////////////////////////////////////////
void CIMEData::InitImeData()
{
    // Get Work Area
    SystemParametersInfo(SPI_GETWORKAREA, 0, &(m_pImedata->rcWorkArea), 0);

    // If IMEDATA is not initialized ever, fill it with default value first,
    // and then try to read from registry.
    // If IMEDATA overwritten by any reason, it will recover to initial data.
    if (m_pImedata->ulMagic != IMEDATA_MAGIC_NUMBER)
        {
        m_pImedata->ulMagic = IMEDATA_MAGIC_NUMBER;

        // Default option setting. It can be changed according to registry in ImeSelect
        SetCurrentBeolsik(KL_2BEOLSIK);
        m_pImedata->fJasoDel = fTrue;
        m_pImedata->fKSC5657Hanja = fFalse;

        // Default status Buttons
#if !defined(_M_IA64)
        m_pImedata->uNumOfButtons = 3;
#else
        m_pImedata->uNumOfButtons = 2;
#endif
        m_pImedata->iCurButtonSize = BTN_MIDDLE;
        m_pImedata->StatusButtons[0].m_ButtonType = HAN_ENG_TOGGLE_BUTTON;
        m_pImedata->StatusButtons[1].m_ButtonType = HANJA_CONV_BUTTON;
#if !defined(_M_IA64)
        m_pImedata->StatusButtons[2].m_ButtonType = IME_PAD_BUTTON;
        m_pImedata->StatusButtons[3].m_ButtonType = NULL_BUTTON;
#else
        m_pImedata->StatusButtons[2].m_ButtonType = NULL_BUTTON;
#endif

        // Get all regstry info
        GetRegValues(GETSET_REG_ALL);

        //
        m_pImedata->xCandWi = 320;
        m_pImedata->yCandHi = 30;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\funcprv.cpp ===
/****************************************************************************
   funcprv.cpp : CFunctionProvider class implementation

   History:
      15-NOV-1999 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "funcprv.h"
#include "fnrecon.h"
#include "fnconfig.h"
#include "helpers.h"
#include "immxutil.h"


//////////////////////////////////////////////////////////////////////////////
//
// CFunctionProvider
//
//////////////////////////////////////////////////////////////////////////////


/*---------------------------------------------------------------------------
    CFunctionProvider::CFunctionProvider
    
    Ctor
---------------------------------------------------------------------------*/
CFunctionProvider::CFunctionProvider(CKorIMX *pime) : CFunctionProviderBase(pime->GetTID())
{
    Init(CLSID_KorIMX, L"Kor TFX");
    _pime = pime;
}

/*---------------------------------------------------------------------------
    CFunctionProvider::GetFunction
    
    Get Fuction object
---------------------------------------------------------------------------*/
STDAPI CFunctionProvider::GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk)
{
    *ppunk = NULL;

    if (!IsEqualIID(rguid, GUID_NULL))
        return E_NOINTERFACE;

    if (IsEqualIID(riid, IID_ITfFnReconversion))
    {
        // ITfFnReconversion is used for correction. Through this function, the 
        // applications can get the simple alternative lists or ask the function to show 
        // the alternative list UI.
        *ppunk = new CFnReconversion(_pime, this);
    }
    else if (IsEqualIID(riid, IID_ITfFnConfigure))
    {
        CFnConfigure *pconfig = new CFnConfigure(this);
        *ppunk = SAFECAST(pconfig, ITfFnConfigure *);
    }
    else if (IsEqualIID(riid, IID_ITfFnConfigureRegisterWord))
    {
        CFnConfigure *pconfig = new CFnConfigure(this);
        *ppunk = SAFECAST(pconfig, ITfFnConfigureRegisterWord *);
    }
    else if (IsEqualIID(riid, IID_ITfFnShowHelp))
    {
        CFnShowHelp *phelp = new CFnShowHelp(this);
        *ppunk = SAFECAST(phelp, ITfFnShowHelp *);
    }
    
    if (*ppunk)
        return S_OK;

    return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\funcprv.h ===
//
//   funcprv.h : CFunctionProvider class declaration
//
//   History:
//      15-NOV-1999 CSLim Created

#if !defined (__FUNCPRV_H__INCLUDED_)
#define __FUNCPRV_H__INCLUDED_

#include "private.h"
#include "fnprbase.h"

class CKorIMX;

class CFunctionProvider :  public CFunctionProviderBase
{
public:
    CFunctionProvider(CKorIMX *pime);

    STDMETHODIMP GetFunction(REFGUID rguid, REFIID riid, IUnknown **ppunk);

    CKorIMX *_pime;
};

#endif // __FUNCPRV_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\globals.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       globals.cpp
//
//  Contents:   Global variables.
//
//----------------------------------------------------------------------------

#include "private.h"

HINSTANCE g_hInst = NULL;

CRITICAL_SECTION g_cs;

// {12E86EF3-4A16-46d6-A56C-3B887DB16E22}
extern const GUID GUID_ATTR_KORIMX_INPUT = 
{
    0x12e86ef3, 
    0x4a16, 
    0x46d6, 
    { 0xa5, 0x6c, 0x3b, 0x88, 0x7d, 0xb1, 0x6e, 0x22 } 
};

// {12A9B212-9463-49bb-85E0-D6CBF9A85F99}
extern const GUID GUID_IC_PRIVATE = 
{
    0x12a9b212, 
    0x9463, 
    0x49bb, 
    { 0x85, 0xe0, 0xd6, 0xcb, 0xf9, 0xa8, 0x5f, 0x99 } 
};

// {91656349-4BA9-4143-A1AE-7FBC20B631BC}
extern const GUID GUID_COMPARTMENT_KORIMX_CONVMODE = 
{ 
    0x91656349, 
    0x4ba9, 
    0x4143, 
    { 0xa1, 0xae, 0x7f, 0xbc, 0x20, 0xb6, 0x31, 0xbc } 
};

// {91656350-4BA9-4143-A1AE-7FBC20B631BC}
extern const GUID GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE = 
{ 
    0x91656350, 
    0x4ba9, 
    0x4143, 
    { 0xa1, 0xae, 0x7f, 0xbc, 0x20, 0xb6, 0x31, 0xbc } 
};

// {2232E454-03BA-482E-A0D4-5DCDD99DFF68}
extern const GUID GUID_KOREAN_HANGULSIMULATE =
{
    0x2232E454,
    0x03BA,
    0x482E,
    { 0xA0, 0xD4, 0x5D, 0xCD, 0xD9, 0x9D, 0xFF, 0x68 }
};

// {2232E455-03BA-482E-A0D4-5DCDD99DFF68}
extern const GUID GUID_KOREAN_HANJASIMULATE =
{
    0x2232E455,
    0x03BA,
    0x482E,
    { 0xA0, 0xD4, 0x5D, 0xCD, 0xD9, 0x9D, 0xFF, 0x68 }
};

// ac72b67f-d965-4b78-99fc-6547c2f62064 
extern const GUID GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT = 
{
    0xac72b67f,
    0xd965,
    0x4b78,
    {0x99, 0xfc, 0x65, 0x47, 0xc2, 0xf6, 0x20, 0x64}
};

// ac72b680-d965-4b78-99fc-6547c2f62064
extern const GUID GUID_COMPARTMENT_SOFTKBD_WNDPOSITION = 
{
    0xac72b680,
    0xd965,
    0x4b78,
    {0x99, 0xfc, 0x65, 0x47, 0xc2, 0xf6, 0x20, 0x64}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\gdata.h ===
/****************************************************************************
	GDATA.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Instance data and Shared memory data management functions

	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_GDATA_H__INCLUDED_)
#define _GDATA_H__INCLUDED_


class CIMEData;

extern BOOL InitSharedData();
VOID InitImeData(CIMEData& ImeData);
extern BOOL CloseSharedMemory();

#define IMEDATA_MAGIC_NUMBER 		0x12345678	// This will repesent whether IMEDATA initialized or not

// Type of IME Hangul keyboard layout
enum _KeyBoardType 
{ 
	KL_2BEOLSIK = 0, KL_3BEOLSIK_390 = 1, KL_3BEOLSIK_FINAL = 2
};

#define NUM_OF_IME_KL			3



///////////////////////////////////////////////////////////////////////////////
// UI Decls
enum StatusButtonTypes 
{ 
	HAN_ENG_TOGGLE_BUTTON, 
	JUNJA_BANJA_TOGGLE_BUTTON, 
	HANJA_CONV_BUTTON,
	IME_PAD_BUTTON,
	NULL_BUTTON = 0xFF
};

#define MAX_NUM_OF_STATUS_BUTTONS	4

// Button status
#define BTNSTATE_NORMAL		0	// normal
#define BTNSTATE_ONMOUSE	1	// mouse cursor on the button
#define BTNSTATE_PUSHED		2	// pushed
#define BTNSTATE_DOWN		4	// pushed
#define BTNSTATE_HANJACONV  8	// If hanja conv mode, button always pushed

// Button size
#define BTN_SMALL			0
#define BTN_MIDDLE			1
#define BTN_LARGE			2

struct StatusButton 
{
	StatusButtonTypes m_ButtonType;
	WORD	m_BmpNormalID, m_BmpOnMouseID, m_BmpPushedID, m_BmpDownOnMouseID;
	WORD	m_ToolTipStrID;
	INT		m_uiButtonState;
	BOOL	m_fEnable;

	StatusButton() 
		{
		m_ButtonType = NULL_BUTTON;
		m_BmpNormalID = m_BmpPushedID = m_ToolTipStrID = 0;
		m_fEnable = fTrue;
		m_uiButtonState = BTNSTATE_NORMAL;
		}
};


///////////////////////////////////////////////////////////////////////////////
// Global data  S H A R E D  to all IME instance
struct IMEDATA 
    {
    ULONG		ulMagic;

	// Workarea
	RECT		rcWorkArea;
	
	// Configuration of the IME: TIP uses following data to share user setting.
	UINT		uiCurrentKeylayout;
	BOOL		fJasoDel;		// Backspace : delete per jaso or char
								// which means All ISO-10646 hangul.
	BOOL		fKSC5657Hanja;	// K1(KSC-5657) Hanja enable
	BOOL		fCandUnicodeTT;

	// Status window data: Not used by TIP
	UINT		uNumOfButtons;
	INT			iCurButtonSize;

    INT         xStatusWi;      // width of status window
    INT         yStatusHi;      // high of status window

	LONG		xStatusRel, yStatusRel;

	INT			xButtonWi;
	INT			yButtonHi;
	INT			cxStatLeftMargin, cxStatRightMargin,
				cyStatMargin, cyStatButton;
	RECT		rcButtonArea;
	POINT       ptStatusPos;

	// Candidate window
    INT         xCandWi;
    INT         yCandHi;

	// Comp window pos
	POINT       ptCompPos;

	// This should be last - ia64 alignment issue
	StatusButton StatusButtons[MAX_NUM_OF_STATUS_BUTTONS];
};

typedef IMEDATA	*LPIMEDATA;

/////////////////////////////////////////////////////////////////////////////
// Class CIMEData
//
// Purpose : Shared memory handling across process boundary.
//           This use MapViewOfFile() to mapping local process memory and Unlock 
//           automatically when reference count become zero
// Note    : Currently Read only flag behaves same as R/W flag.
class CIMEData
    {
    public:
        enum LockType { SMReadOnly, SMReadWrite };
       
        CIMEData(LockType lockType=SMReadWrite);
        ~CIMEData() { UnlockSharedMemory(); }

        static BOOL InitSharedData();
        static BOOL CloseSharedMemory();

		void InitImeData();

        LPIMEDATA LockROSharedData();
        LPIMEDATA LockRWSharedData();
        BOOL UnlockSharedMemory();
        LPIMEDATA operator->() { Assert(m_pImedata != 0); return m_pImedata; }
        LPIMEDATA GetGDataRaw() { Assert(m_pImedata != 0); return m_pImedata; }
        UINT GetCurrentBeolsik() { return m_pImedata->uiCurrentKeylayout; }
		VOID SetCurrentBeolsik(UINT icurBeolsik);		
		BOOL GetJasoDel() { return m_pImedata->fJasoDel; }
		VOID SetJasoDel(BOOL fJasoDel) { m_pImedata->fJasoDel = fJasoDel; }
		BOOL GetKSC5657Hanja() { return m_pImedata->fKSC5657Hanja; }
		VOID SetKSC5657Hanja(BOOL f5657) { m_pImedata->fKSC5657Hanja = f5657; }

		
    private:
        LPIMEDATA m_pImedata;
        static HANDLE m_vhSharedData;
    };

inline
CIMEData::CIMEData(LockType lockType)
    {
    Assert(m_vhSharedData != 0);
    DebugMsg(DM_TRACE, TEXT("CIMEData(): Const"));
    m_pImedata = 0;
    LockRWSharedData();
    }

inline
LPIMEDATA CIMEData::LockROSharedData()
    {
    Assert(m_vhSharedData != 0);
    DebugMsg(DM_TRACE, TEXT("CIMEData::LockROSharedData()"));

    if (m_vhSharedData)
	    m_pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ, 0, 0, 0);
    Assert(m_pImedata != 0);
    return m_pImedata;
    }

inline    
LPIMEDATA CIMEData::LockRWSharedData()
    {
    Assert(m_vhSharedData != 0);
    DebugMsg(DM_TRACE, TEXT("CIMEData::LockRWSharedData()"));
    
    if (m_vhSharedData)
    	{
		DebugMsg(DM_TRACE, TEXT("CIMEData::LockRWSharedData(): m_vhSharedData is null call MapViewOfFile"));
	    m_pImedata = (LPIMEDATA)MapViewOfFile(m_vhSharedData, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
	    }
    Assert(m_pImedata != 0);
	return m_pImedata;
    }

// For unlocking shared memory
inline
BOOL CIMEData::UnlockSharedMemory()
    {
    DebugMsg(DM_TRACE, TEXT("CIMEData::UnlockSharedMemory(): Lock count zero UnmapViewOfFile"));
    UnmapViewOfFile(m_pImedata);
    m_pImedata = 0;
    return fTrue;
    }

inline
VOID CIMEData::SetCurrentBeolsik(UINT uicurBeolsik) 
{ 
	Assert(uicurBeolsik<=KL_3BEOLSIK_FINAL);

	m_pImedata->uiCurrentKeylayout = uicurBeolsik; 
}

#endif // _GDATA_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\hanja.h ===
/****************************************************************************
	HANJA.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	Hanja conversion and dictionary lookup functions. Dictionary index is 
	stored as globally shared memory.
	
	History:
	14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#if !defined (_HANJA_H__INCLUDED_)
#define _HANJA_H__INCLUDED_

#include "LexHeader.h"

enum HANJA_CAT { HANJA_K0, HANJA_K1, HANJA_K2 };

typedef
struct tagHANJA_CAND_STRING
{
	WCHAR   wchHanja;   // Hanja char
	LPWSTR  wzMeaning;  // Hanja meaning
	BYTE	bHanjaCat;  // Hanja category
} HANJA_CAND_STRING;


typedef
struct tagHANJA_CAND_STRING_LIST
{
	LPWSTR				pwsz;	// Null terminated string list (Allocated by GetConversionList)
	HANJA_CAND_STRING	*pHanjaString;  // (Allocated by GetConversionList)

	DWORD		csz;			// Count of wsz's in pwsz 
	DWORD       cszAlloc;       // Number of entries allocated in pHanjaString (set by GetConversionList) 
	DWORD       cchMac;			// Current chars used in pwsz (incl all trailing nulls) 
	DWORD		cchAlloc;		// Size in chars of pwsz (Set by GetConversionList) 
} HANJA_CAND_STRING_LIST;

extern BOOL EnsureHanjaLexLoaded();
extern BOOL CloseLex();
extern BOOL GetMeaningAndProunc(WCHAR wch, LPWSTR lpwstrTip, INT cchMax);
extern BOOL GetConversionList(WCHAR wcReading, HANJA_CAND_STRING_LIST *pCandList);



#endif // !defined (_HANJA_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\hanja.cpp ===
/****************************************************************************
    HANJA.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    Hanja conversion and dictionary lookup functions. Dictionary index is 
    stored as globally shared memory.
    
    History:
    26-APR-1999 cslim       Modified for Multibox Applet Tooltip display
    14-JUL-1999 cslim       Copied from IME98 source tree
*****************************************************************************/

#include "private.h"
#include "common.h"
#include "lexheader.h"
#include "hanja.h"
#include "gdata.h"
#include "immsec.h"
#include "osver.h"
#include "debug.h"

// NT5 Globally shared memory. 
// If NT5 or upper append "Global\" to object name to make it global to all session.
// We don't need to consider NT4 Terminal Server since we don't have Kor TS NT4
const TCHAR IMEKR_SHAREDDATA_MUTEX[]            = TEXT("ImeKrLex.Mutex");
const TCHAR IMEKR_SHAREDDATA_MUTEX_GLOBAL[]     = TEXT("Global\\ImeKrLex.Mutex");
const TCHAR IMEKR_LEX_HANGUL2HANJA[]             = TEXT("ImeKrLexHangul2Hanja.SharedMemory");
const TCHAR IMEKR_LEX_HANGUL2HANJA_GLOBAL[]     = TEXT("Global\\ImeKrLexHangul2Hanja.SharedMemory");
const TCHAR IMEKR_LEX_HANJA2HANGUL[]             = TEXT("ImeKrLexHanjaToHangul.SharedMemory");
const TCHAR IMEKR_LEX_HANJA2HANGUL_GLOBAL[]     = TEXT("Global\\ImeKrLexHanjaToHangul.SharedMemory");


// Initial and grow clump size of HANJA_CAND_STRING_LIST's pointers
#define HANJA_LIST_PWSZ_INITIAL_SIZE        512
#define HANJA_LIST_PWSZ_CLUMP_SIZE            256

UINT   vuNumofK0=0, vuNumofK1=0;
WCHAR  vwcHangul=0;

// Private data
static BOOL   vfLexOpen = FALSE;
static HANDLE vhLex=0;
static HANDLE vhHangul2Hanja_IndexTbl=0;
static HANDLE vhHanja2Hangul_IndexTbl=0;
static DWORD  viBufferStart=0;    // seek point
static _DictHeader *vpLexHeader;

// Private functions
static BOOL OpenLex();
static INT SearchHanjaIndex(WCHAR wHChar, _LexIndex *pLexIndexTbl);
static INT SearchHanjaIndex(WCHAR wHChar, HanjaToHangulIndex *pLexIndexTbl);

BOOL EnsureHanjaLexLoaded()
{
    HKEY        hKey;
    DWORD         dwReadBytes;
    CHAR         szLexFileName[MAX_PATH], szLexPathExpanded[MAX_PATH];
    DWORD        dwCb, dwType;
    
    if (vfLexOpen)
        return TRUE;

    // Get Lex file path
    szLexFileName[0] = 0;
    szLexPathExpanded[0] = 0;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szIMERootKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
        dwCb = sizeof(szLexFileName);
        dwType = REG_SZ;

        if (RegQueryValueEx(hKey, g_szDictionary, NULL, &dwType, (LPBYTE)szLexFileName, &dwCb) == ERROR_SUCCESS)
            ExpandEnvironmentStrings(szLexFileName, szLexPathExpanded, sizeof(szLexPathExpanded));
        RegCloseKey(hKey);
        }

    Assert(szLexPathExpanded[0] != 0);
    if (szLexPathExpanded[0] == 0)
        return fFalse;

    vhLex = CreateFile(szLexPathExpanded, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
    if (vhLex==INVALID_HANDLE_VALUE) 
        {
        Assert(0);
        return FALSE;
        }

    vpLexHeader = new _DictHeader;
    Assert(vpLexHeader);
    if (!vpLexHeader)
        return FALSE;

    if (ReadFile(vhLex, vpLexHeader, sizeof(_DictHeader), &dwReadBytes, 0) == 0 
        || (dwReadBytes != sizeof(_DictHeader)))
        {
        Assert(0);
        return FALSE;
        }

    // Set member vars
    //vuNumOfHangulEntry = pLexHeader->NumOfHangulEntry;
    //vuNumOfHanjaEntry  = pLexHeader->uiNumofHanja;
    //viBufferStart      = pLexHeader->iBufferStart;

    if (vpLexHeader->Version < LEX_VERSION || vpLexHeader->Version > LEX_COMPATIBLE_VERSION_LIMIT ) 
        {
        delete vpLexHeader;
        vpLexHeader = 0;
        Assert(0);
        return FALSE;
        }
        
    if (lstrcmpA(vpLexHeader->COPYRIGHT_HEADER, COPYRIGHT_STR)) 
        {
        delete vpLexHeader;
        vpLexHeader = 0;
        Assert(0);
        return FALSE;
        }

    return OpenLex();
}

__inline BOOL DoEnterCriticalSection(HANDLE hMutex)
{
    if(WAIT_FAILED==WaitForSingleObject(hMutex, 3000))    // Wait 3 seconds
        return(FALSE);
    return(TRUE);
}

BOOL OpenLex()
{
    BOOL                  fRet = FALSE;
    HANDLE                 hMutex;
    DWORD                 dwReadBytes;
    
    ///////////////////////////////////////////////////////////////////////////
    // Mapping Lex file
    // The dictionary index is shared data between all IME instance
    if (IsOnNT5())
        hMutex=CreateMutex(GetIMESecurityAttributes(), FALSE, IMEKR_SHAREDDATA_MUTEX_GLOBAL);
    else
        hMutex=CreateMutex(GetIMESecurityAttributes(), FALSE, IMEKR_SHAREDDATA_MUTEX);

    if (hMutex != NULL)
        {
        if (DoEnterCriticalSection(hMutex) == FALSE)
            goto ExitOpenLexCritSection;

        if (IsOnNT5())
            {
            vhHangul2Hanja_IndexTbl = OpenFileMapping(FILE_MAP_READ, TRUE, IMEKR_LEX_HANGUL2HANJA_GLOBAL);
            vhHanja2Hangul_IndexTbl = OpenFileMapping(FILE_MAP_READ, TRUE, IMEKR_LEX_HANJA2HANGUL_GLOBAL);
            }
        else
            {
            vhHangul2Hanja_IndexTbl = OpenFileMapping(FILE_MAP_READ, TRUE, IMEKR_LEX_HANGUL2HANJA);
            vhHanja2Hangul_IndexTbl = OpenFileMapping(FILE_MAP_READ, TRUE, IMEKR_LEX_HANJA2HANGUL);
            }

        if (vhHangul2Hanja_IndexTbl && vhHanja2Hangul_IndexTbl)
            {
            TraceMsg(TF_GENERAL, "CHanja::OpenLex() - File mapping already exists");
            fRet = TRUE;
            }
        else
            {
            // if no file mapping exist
            if (IsOnNT5())
                {
                vhHangul2Hanja_IndexTbl = CreateFileMapping(INVALID_HANDLE_VALUE, 
                                                    GetIMESecurityAttributes(), 
                                                    PAGE_READWRITE, 
                                                    0,
                                                    sizeof(_LexIndex)*(vpLexHeader->NumOfHangulEntry),
                                                    IMEKR_LEX_HANGUL2HANJA_GLOBAL);
                                                    
                vhHanja2Hangul_IndexTbl = CreateFileMapping(INVALID_HANDLE_VALUE, 
                                                    GetIMESecurityAttributes(), 
                                                    PAGE_READWRITE, 
                                                    0, 
                                                    sizeof(HanjaToHangulIndex)*(vpLexHeader->uiNumofHanja),
                                                    IMEKR_LEX_HANJA2HANGUL_GLOBAL);
                }
            else
                {
                vhHangul2Hanja_IndexTbl = CreateFileMapping(INVALID_HANDLE_VALUE, 
                                                    GetIMESecurityAttributes(), 
                                                    PAGE_READWRITE, 
                                                    0,
                                                    sizeof(_LexIndex)*(vpLexHeader->NumOfHangulEntry),
                                                    IMEKR_LEX_HANGUL2HANJA);
                                                    
                vhHanja2Hangul_IndexTbl = CreateFileMapping(INVALID_HANDLE_VALUE, 
                                                    GetIMESecurityAttributes(), 
                                                    PAGE_READWRITE, 
                                                    0, 
                                                    sizeof(HanjaToHangulIndex)*(vpLexHeader->uiNumofHanja),
                                                    IMEKR_LEX_HANJA2HANGUL);
                }
                
            if (vhHangul2Hanja_IndexTbl && vhHanja2Hangul_IndexTbl) 
                {
                _LexIndex     *pLexIndexTbl;
                HanjaToHangulIndex* pHanjaToHangulIndex;

                TraceMsg(TF_GENERAL, "CHanja::OpenLex() - File mapping Created");

                // Copy Hangul to Hanja index
                pLexIndexTbl = (_LexIndex*)MapViewOfFile(vhHangul2Hanja_IndexTbl, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
                if (!pLexIndexTbl)
                    goto ExitOpenLexCritSection;

                // Read Index table
                SetFilePointer(vhLex, vpLexHeader->Headersize, 0, FILE_BEGIN);    
                if (ReadFile(vhLex, pLexIndexTbl, vpLexHeader->NumOfHangulEntry*sizeof(_LexIndex), &dwReadBytes, 0) == 0
                    || dwReadBytes != vpLexHeader->NumOfHangulEntry*sizeof(_LexIndex))
                    {
                    UnmapViewOfFile(pLexIndexTbl);
                    goto ExitOpenLexCritSection;
                    }

                UnmapViewOfFile(pLexIndexTbl);

                // Copy Hanja to Hangul index
                pHanjaToHangulIndex = (HanjaToHangulIndex*)MapViewOfFile(vhHanja2Hangul_IndexTbl, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
                if (!pHanjaToHangulIndex)
                    goto ExitOpenLexCritSection;

                // Read Hanja to Hangul Index table
                SetFilePointer(vhLex, vpLexHeader->iHanjaToHangulIndex, 0, FILE_BEGIN);    
                if (ReadFile(vhLex, pHanjaToHangulIndex, sizeof(HanjaToHangulIndex)*(vpLexHeader->uiNumofHanja), &dwReadBytes, 0) == 0
                    || dwReadBytes != sizeof(HanjaToHangulIndex)*(vpLexHeader->uiNumofHanja))
                    {
                    UnmapViewOfFile(pLexIndexTbl);
                    goto ExitOpenLexCritSection;
                    }
                
                UnmapViewOfFile(pHanjaToHangulIndex);
                fRet = TRUE;
                }
                
        #ifdef DEBUG
            else
                Assert(0);
        #endif
            }
            
    ExitOpenLexCritSection:
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
        }
    
    FreeIMESecurityAttributes();

    vfLexOpen = fRet;
    return fRet;
}

BOOL CloseLex()
{
    //ClearHanjaSenseArray();
    
    if (vhHangul2Hanja_IndexTbl) 
        {
        CloseHandle(vhHangul2Hanja_IndexTbl);
        vhHangul2Hanja_IndexTbl = 0;
        }

    if (vhHanja2Hangul_IndexTbl) 
        {
        CloseHandle(vhHanja2Hangul_IndexTbl);
        vhHanja2Hangul_IndexTbl = 0;
        }

    if (vhLex) 
        {
        CloseHandle(vhLex);
        vhLex = 0;
        }

    if (vpLexHeader)
        {
        delete vpLexHeader;
        vpLexHeader = 0;
        }

    vfLexOpen =  FALSE;
    return TRUE;
}

/*---------------------------------------------------------------------------
    fInitHanjaStringList

    Allocate nested pointer of HANJA_CAND_STRING_LIST and initialize it.
------------------------------------------------------------------ CSLim -*/
BOOL fInitHanjaList(HANJA_CAND_STRING_LIST *pHanjaList, UINT uiNumofHanjaStr)
{
    Assert(pHanjaList != NULL);
    if ((pHanjaList->pwsz = (LPWSTR)cicMemAlloc(HANJA_LIST_PWSZ_INITIAL_SIZE*sizeof(WCHAR))) == 0)
        return fFalse;

    if ((pHanjaList->pHanjaString = (HANJA_CAND_STRING*)cicMemAlloc(
                                sizeof(HANJA_CAND_STRING)*uiNumofHanjaStr)) == 0)
        {
        cicMemFree(pHanjaList->pwsz);
        return fFalse;
        }

    pHanjaList->cchMac = 0; // Current chars used in pwsz (incl all trailing nulls) 
    pHanjaList->cchAlloc = HANJA_LIST_PWSZ_INITIAL_SIZE; // WCHAR size

    pHanjaList->csz = 0;
    pHanjaList->cszAlloc = uiNumofHanjaStr;
    
    return fTrue;
}

/*---------------------------------------------------------------------------
    fGrowHanjaList

    Reallocate nested pointer of HANJA_CAND_STRING_LIST after increasing the size
------------------------------------------------------------------ CSLim -*/
BOOL fGrowHanjaList(HANJA_CAND_STRING_LIST *pHanjaList)
{
    LPWSTR pwsz;
    
    TBOOL(pHanjaList != NULL);
    pwsz = (LPWSTR)cicMemReAlloc(pHanjaList->pwsz, 
                                (pHanjaList->cchAlloc+HANJA_LIST_PWSZ_CLUMP_SIZE)*sizeof(WCHAR));
    if (pwsz == NULL)
        return fFalse;

    if (pHanjaList->pwsz != pwsz)
        {
        INT_PTR offset = pwsz - pHanjaList->pwsz;
        for (UINT i=0; i<pHanjaList->csz; i++)
            pHanjaList->pHanjaString[i].wzMeaning += offset;
        }

    pHanjaList->pwsz = pwsz;
    pHanjaList->cchAlloc += HANJA_LIST_PWSZ_CLUMP_SIZE;

    return fTrue;
}


BOOL GetMeaningAndProunc(WCHAR wch, LPWSTR lpwstrTip, INT cchMax)
{
    HanjaToHangulIndex* pHanjaToHangulIndex;
    INT                 iMapHanjaInfo;
    WCHAR               wcHanja = 0;
    BYTE                cchMeaning = 0;
    WCHAR                wszMeaning[MAX_SENSE_LENGTH+1];
    DWORD                dwReadBytes;
    BOOL                   fRet = FALSE;

    TraceMsg(TF_GENERAL, "GetMeaningAndProunc");

    if (!EnsureHanjaLexLoaded()) 
        return FALSE;

    pHanjaToHangulIndex = (HanjaToHangulIndex*)MapViewOfFile(vhHanja2Hangul_IndexTbl, FILE_MAP_READ, 0, 0, 0);
    if (!pHanjaToHangulIndex) 
        {
        Assert(0);    
        return FALSE;
        }

    // Search index
    if ((iMapHanjaInfo = SearchHanjaIndex(wch, pHanjaToHangulIndex)) >= 0)
        {
        // Seek to mapping Hanja
        SetFilePointer(vhLex, vpLexHeader->iBufferStart + pHanjaToHangulIndex[iMapHanjaInfo].iOffset, 0, FILE_BEGIN);    

        // Read Hanja Info
        ReadFile(vhLex, &wcHanja, sizeof(WCHAR), &dwReadBytes, 0);
        Assert(wch == wcHanja);
        ReadFile(vhLex, &cchMeaning, sizeof(BYTE), &dwReadBytes, 0);
        if (wcHanja && (cchMeaning < MAX_SENSE_LENGTH*sizeof(WCHAR)))
            {
            if (cchMeaning)
                ReadFile(vhLex, wszMeaning, cchMeaning, &dwReadBytes, 0);
            wszMeaning[cchMeaning>>1] = L'\0';
            wsprintfW(lpwstrTip, L"%s %c\nU+%04X", wszMeaning, pHanjaToHangulIndex[iMapHanjaInfo].wchHangul, wch);
        
            fRet = TRUE;
            }
        else
            fRet = FALSE;
        }

    UnmapViewOfFile(pHanjaToHangulIndex);

    return fRet;
}


// For ImeConversionList.
BOOL GetConversionList(WCHAR wcReading, HANJA_CAND_STRING_LIST *pCandList)
    {
    _LexIndex   *pLexIndexTbl = NULL;
    INT         iMapCandStr;
    UINT        uNumOfCandStr;
    DWORD       cwch, readBytes;
    BYTE        senseLen;
    WCHAR       szSense[MAX_SENSE_LENGTH] = L"";
    CIMEData    ImeData;
    BOOL        fRet = fFalse;
    
    // Chcek validity of params
    Assert(wcReading != 0);
    Assert(pCandList != NULL);
    
    if (pCandList == NULL)
        goto ConversionExit1;

    if (!EnsureHanjaLexLoaded())
        return (0L);


    pLexIndexTbl = (_LexIndex*)MapViewOfFile(vhHangul2Hanja_IndexTbl, FILE_MAP_READ, 0, 0, 0);
    if (!pLexIndexTbl) 
        {
        Assert(0);    
        return (0L);
        }

    cwch = 0;

    if ((iMapCandStr = SearchHanjaIndex(wcReading, pLexIndexTbl)) < 0) 
        goto ConversionExit1;
    else
        {
        vuNumofK0 = pLexIndexTbl[iMapCandStr].wNumOfK0;

        if (ImeData->fKSC5657Hanja && !IsOn95())
            vuNumofK1 = pLexIndexTbl[iMapCandStr].wNumOfK1;
        else
            vuNumofK1 = 0;

        uNumOfCandStr = vuNumofK0 + vuNumofK1;
        if (uNumOfCandStr == 0)    // if no Hanja found
            goto ConversionExit1;

        if (!fInitHanjaList(pCandList, uNumOfCandStr))
            goto ConversionExit1;
        
        //cwch = uNumOfCandStr*2; // including NULL
                    
        //
        SetFilePointer(vhLex, vpLexHeader->iBufferStart + pLexIndexTbl[iMapCandStr].iOffset, 0, FILE_BEGIN);    

        for (UINT i = 0; i < uNumOfCandStr; i++)
            {
            WCHAR    wchHanja;

            if (ReadFile(vhLex, &wchHanja, sizeof(WCHAR), &readBytes, 0) == 0)
                goto ConversionExit1;

            //*lpwchCand++ = wchHanja;
            //*lpwchCand++ = L'\0';

            // Skip meaning
            if (ReadFile(vhLex, &senseLen, sizeof(BYTE), &readBytes, 0) == 0)
                goto ConversionExit1;
            if (senseLen && senseLen < MAX_SENSE_LENGTH*sizeof(WCHAR))
                {
                if (ReadFile(vhLex, szSense, senseLen, &readBytes, 0) == 0)
                    goto ConversionExit1;
                szSense[senseLen/2] = L' ';
                szSense[senseLen/2 + 1] = wcReading;
                szSense[senseLen/2 + 2] = L'\0';
                senseLen += 2*sizeof(WCHAR);
                }
            ///////////////////////////////////////////////////////////////////
            // Fill Hanja String List struct

            // Grow memory if neccessary
            if (pCandList->cchAlloc <= pCandList->cchMac + (senseLen/2))
                {
                TraceMsg(TF_GENERAL, "Try to grow pCandList");
                if (fGrowHanjaList(pCandList) == fFalse)
                    {
                    Assert(0);
                    goto ConversionExit1;
                    }
                }
                
            pCandList->pHanjaString[pCandList->csz].wchHanja = wchHanja;
            if (i < vuNumofK0)
                pCandList->pHanjaString[pCandList->csz].bHanjaCat = HANJA_K0;
            else
                pCandList->pHanjaString[pCandList->csz].bHanjaCat = HANJA_K1;

            if (senseLen)
                {
                pCandList->pHanjaString[pCandList->csz].wzMeaning = pCandList->pwsz + pCandList->cchMac;
                wcscpy(pCandList->pwsz + pCandList->cchMac, szSense);
                }
            else
                pCandList->pHanjaString[pCandList->csz].wzMeaning = L"";
                
            pCandList->csz++;
            pCandList->cchMac += (senseLen/2)+1;
            }
           fRet = fTrue;
        }


ConversionExit1:
    UnmapViewOfFile(pLexIndexTbl);

    return fRet;
}


INT SearchHanjaIndex(WCHAR wHChar, _LexIndex *pLexIndexTbl)
{
    int iHead = 0, iTail = vpLexHeader->NumOfHangulEntry-1, iMid;

    while (iHead <= iTail)
        {
        iMid = (iHead + iTail) >> 1;

        if (pLexIndexTbl[iMid].wcHangul > wHChar)
            iTail = iMid - 1;
        else 
            if (pLexIndexTbl[iMid].wcHangul < wHChar)
                iHead = iMid + 1;
            else 
                return (iMid);
        }

    return (-1);
}

INT SearchHanjaIndex(WCHAR wHChar, HanjaToHangulIndex *pLexIndexTbl)
{
    int iHead = 0, iTail = vpLexHeader->uiNumofHanja-1, iMid;

    while (iHead <= iTail)
        {
        iMid = (iHead + iTail) >> 1;

        TraceMsg(TF_GENERAL, "SearchHanjaIndex iMid=%d, pLexIndexTbl[iMid].wchHanja = 0x%04X", iMid, pLexIndexTbl[iMid].wchHanja);

        if (pLexIndexTbl[iMid].wchHanja > wHChar)
            iTail = iMid - 1;
        else 
            if (pLexIndexTbl[iMid].wchHanja < wHChar)
                iHead = iMid + 1;
            else 
                return (iMid);
        }

    return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\hauto.h ===
///////////////////////////////////////////////////////////////////////////////
// Hangul automata Class
//
// Author: cslim@microsoft.com

#if !defined (__HAUTOMATA_H__)
#define __HAUTOMATA_H__

// Number of each component
#define NUM_OF_CHOSUNG  19
#define NUM_OF_JUNGSUNG 21
#define NUM_OF_JONGSUNG 28

#define NUM_OF_DOUBLE_CHOSUNG   5
#define NUM_OF_DOUBLE_JUNGSUNG  7
#define NUM_OF_DOUBLE_JONGSUNG_2BEOL 11
#define NUM_OF_DOUBLE_JONGSUNG_3BEOL 13

#define UNICODE_HANGUL_BASE					0xAC00
#define UNICODE_HANGUL_END					0xD7A3
#define UNICODE_HANGUL_COMP_JAMO_START		0x3131
#define UNICODE_HANGUL_COMP_JAMO_VOWEL_START		0x314F
#define UNICODE_HANGUL_COMP_JAMO_END		0x3163
#define UNICODE_HANGUL_COMP_JAMO_START_FILL	0x3130
#define UNICODE_HANGUL_COMP_JAMO_SIOT		0x3145

///////////////////////////////////////////
// HANGUL Jaso inernal difinitions
// ChoSung
#define _KIYEOK_			1		// ''	
#define _SSANGKIYEOK_		2		// ''
#define _NIEUN_				3		// ''
#define _TIKEUT_			4		// ''
#define _SSANGTIKEUT_		5		// ''
#define _RIEUL_				6		// ''
#define _MIEUM_				7		// ''
#define _PIEUP_				8		// ''
#define _SSANGPIEUP_		9		// ''
#define _SIOS_				10		// ''
#define _SSANGSIOS_			11		// ''
#define _IEUNG_				12		// ''
#define _CIEUC_				13		// ''
#define _SSANGCIEUC_		14		// ''
#define _CHIEUCH_			15		// ''
#define _KHIEUKH_			16		// ''
#define _THIEUTH_			17		// ''
#define _PHIEUPH_			18		// ''
#define _HIEUH_				19		// ''

// JungSung
#define _A_					1		// ''
#define _AE_				2		// ''
#define _YA_				3		// ''
#define _YAE_				4		// ''
#define _EO_				5		// ''
#define _E_					6		// ''
#define _YEO_				7		// ''
#define _YE_				8		// ''
#define _O_					9		// ''
#define _WA_				10		// ''
#define _WAE_				11		// ''
#define _OE_				12		// ''
#define _YO_				13		// ''
#define _U_					14		// ''
#define _WEO_				15		// ''
#define _WE_				16		// ''
#define _WI_				17		// ''
#define _YU_				18		// ''
#define _EU_				19		// ''
#define _YI_				20		// ''
#define _I_					21		// ''
////////////////////////////////////////

// JongSung
#define _JONG_KIYEOK_			1		// ''	
#define _JONG_SSANGKIYEOK_		2		// ''
#define _JONG_KIYEOK_SIOS		3
#define _JONG_NIEUN_			4		// ''
#define _JONG_NIEUN_CHIEUCH_	5		// ''
#define _JONG_NIEUN_HIEUH_		6		// ''
#define _JONG_TIKEUT_			7		// ''
#define _JONG_RIEUL_			8		// ''
#define _JONG_RIEUL_KIYEOK_		9		// ''
#define _JONG_RIEUL_MIUM_		10		// ''
#define _JONG_RIEUL_PIEUP_		11		// ''
#define _JONG_RIEUL_SIOS_		12		// ''
#define _JONG_RIEUL_THIEUTH_	13		// ''
#define _JONG_RIEUL_PHIEUPH_	14		// ''
#define _JONG_RIEUL_HIEUH_		15		// ''
#define _JONG_MIEUM_			16		// ''
#define _JONG_PIEUP_			17		// ''
#define _JONG_PIEUP_SIOS		18		// ''
#define _JONG_SIOS_				19		// ''
#define _JONG_SSANGSIOS_		20		// ''
#define _JONG_IEUNG_			21		// ''
#define _JONG_CIEUC_			22		// ''
#define _JONG_CHIEUCH_			23		// ''
#define _JONG_KHIEUKH_			24		// ''
#define _JONG_THIEUTH_			25		// ''
#define _JONG_PHIEUPH_			26		// ''
#define _JONG_HIEUH_			27		// ''
//
const int MaxInterimStackSize = 6;		// Maximum stack size is 6.
										// At most 6 key input
										// to complete one Hangul Char.
										// ex) (3 beolsik)
enum HAutomataReturnState 
	{ 
	  HAUTO_NONHANGULKEY,
	  HAUTO_COMPOSITION,	// Hagul still in interim state.
	  HAUTO_COMPLETE,		// One hangul char completed and have chars 
							// will takeover as next input.
	  HAUTO_IMPOSSIBLE
	};

const WORD H_HANGUL = 0x8000;

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata Abstract Class
//
class CHangulAutomata
	{
public:
	CHangulAutomata() {	InitState(); }

// Attributes
public:

// Operations
public:
	void InitState() 
		{ 
		m_CurState = m_NextState = 0;
		m_wInternalCode = 0;
		m_Chosung = m_Jungsung = m_Jongsung = 0;
		m_wcComposition = m_wcComplete = L'\0';
		InterimStack.Init();
		}
	virtual HAutomataReturnState Machine(UINT KeyCode, int iShift) = 0;
	virtual BOOL IsInputKey(UINT KeyCode, int iShift) = 0;
	virtual BOOL IsHangulKey(UINT KeyCode, int iShift) = 0;
	virtual WORD GetKeyMap(UINT KeyCode, int iShift) = 0;
	virtual BOOL SetCompositionChar(WCHAR wcComp) = 0;
	
	static WORD GetEnglishKeyMap(UINT KeyCode, int iShift) { return bETable[KeyCode][iShift]; }
	BOOL BackSpace();
	BOOL MakeComplete();
	WCHAR GetCompositionChar() { return m_wcComposition; }
	WCHAR GetCompleteChar() { return m_wcComplete; }

// Implementation
public:
	virtual ~CHangulAutomata() {}

protected:
	void MakeComposition();
	BOOL MakeComplete(WORD wcComplete);
	WORD FindChosungComb(WORD wPrevCode);
	WORD FindJunsungComb(WORD wPrevCode);
	virtual WORD FindJonsungComb(WORD wPrevCode) = 0;
	void SeparateDJung(LPWORD pJungSung);
	void SeparateDJong(LPWORD pJongSung);

	virtual HAutomataReturnState Input(WORD InternalCode) = 0;
	//
	struct InterimStackEntry 
		{
		WORD	m_wInternalCode;
		WORD	m_CurState;
		WORD	m_Chosung, m_Jungsung, m_Jongsung;
		WCHAR	m_wcCode;
		};

	///////////////////////////////////////////////////////////////////////////
	//
	class CInterimStack 
		{
	protected:
		InterimStackEntry	m_StackBuffer[MaxInterimStackSize];	
		int	m_sp;		// Stack pointer

	public:
		CInterimStack() { m_sp = 0; }
		~CInterimStack() {}
		void Init() { m_sp = 0; }
		void Push(InterimStackEntry& InterimEntry);
		void Push(WORD wInternalCode, WORD CurState, 
				  WORD Chosung, WORD Jungsung, WORD Jongsung, WCHAR wcCode);

		InterimStackEntry* CInterimStack::Pop() 
			{
			Assert(m_sp > 0);
			return &m_StackBuffer[--m_sp];
			}

		InterimStackEntry* CInterimStack::GetTop() 
			{
			Assert(m_sp > 0);
			return &m_StackBuffer[m_sp-1];
			}

		BOOL IsEmpty() { return m_sp == 0; }
		};
	///////////////////////////////////////////////////////////////////////////
	CInterimStack InterimStack;

protected:
	WORD	m_CurState, m_NextState;
	WORD	m_wInternalCode, m_Chosung, m_Jungsung, m_Jongsung;
	WCHAR	m_wcComposition;
	WCHAR	m_wcComplete;
	//
	const static BYTE  bETable[256][2];
	const static BYTE  Cho2Jong[NUM_OF_CHOSUNG+1];
	const static BYTE  Jong2Cho[NUM_OF_JONGSUNG];
	};

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata2 Keyboard layout #1 (2 beolsik)
//
class CHangulAutomata2 : public CHangulAutomata
{
public:
	CHangulAutomata2() { }

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift);
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift);
	WORD GetKeyMap(UINT KeyCode, int iShift);
	BOOL SetCompositionChar(WCHAR wcComp);
	
// Implementation
public:
	~CHangulAutomata2() { }

protected:
	WORD FindJonsungComb(WORD wPrevCode);
	HAutomataReturnState Input(WORD InternalCode);
		
protected:
	// This enum should be matched with m_NextState
	// DO NOT change without changing _Transistion_state !
	enum _Transistion_state { FINAL=8, TAKEOVER=9, FIND=10 };
	static const WORD m_NextStateTbl[8][5];
	static const WORD H_CONSONANT, H_VOWEL, H_DOUBLE, H_ONLYCHO;
	static WORD wHTable[256][2];
	static BYTE  rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_2BEOL+1][3];
};


/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata3 Keyboard layout #2 (3 beolsik)
class CHangulAutomata3 : public CHangulAutomata
{
public:
	CHangulAutomata3() {}

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift);
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift);
	WORD GetKeyMap(UINT KeyCode, int iShift);
	BOOL SetCompositionChar(WCHAR wcComp);

// Implementation
public:
	~CHangulAutomata3() { }

protected:
	WORD FindJonsungComb(WORD wPrevCode);
	HAutomataReturnState Input(WORD InternalCode);
	
protected:
	enum _Transistion_state { FINAL=11, FIND=12 };
	static const WORD m_NextStateTbl[11][6];
	static const WORD H_CHOSUNG, H_JUNGSUNG, H_JONGSUNG, H_DOUBLE;
	static WORD wHTable[256][2];
	static BYTE  rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_3BEOL+1][3];
};

/////////////////////////////////////////////////////////////////////////////
// CHangulAutomata3 Keyboard layout #3 (3 beolsik final)
class CHangulAutomata3Final : public CHangulAutomata3
{
public:
	CHangulAutomata3Final() {}

// Attributes
public:

// Operations
public:
	HAutomataReturnState Machine(UINT KeyCode, int iShift) ;
	BOOL IsInputKey(UINT KeyCode, int iShift);
	BOOL IsHangulKey(UINT KeyCode, int iShift); 
	WORD GetKeyMap(UINT KeyCode, int iShift);

// Implementation
public:
	~CHangulAutomata3Final() { }

protected:
	static WORD wHTable[256][2];
};

///////////////////////////////////////////////////////////////////////////////
// Inline functions

inline
void CHangulAutomata::CInterimStack::Push(InterimStackEntry& InterimEntry) 
	{
	Assert(m_sp<MaxInterimStackSize);
	m_StackBuffer[m_sp++] =  InterimEntry;
	}

inline
void CHangulAutomata::CInterimStack::Push(WORD wInternalCode, WORD CurState, 
				  WORD Chosung, WORD Jungsung, WORD Jongsung, WCHAR wcCode) 
	{
	Assert(m_sp<=5);
	m_StackBuffer[m_sp].m_wInternalCode =  wInternalCode;
	m_StackBuffer[m_sp].m_CurState =  CurState;
	m_StackBuffer[m_sp].m_Chosung =  Chosung;
	m_StackBuffer[m_sp].m_Jungsung =  Jungsung;
	m_StackBuffer[m_sp].m_Jongsung =  Jongsung;
	m_StackBuffer[m_sp++].m_wcCode =  wcCode;
	}

// CHangulAutomata2
inline
HAutomataReturnState CHangulAutomata2::Machine(UINT KeyCode, int iShift) 
	{
	return (Input(wHTable[KeyCode][iShift]));
	}

inline
BOOL CHangulAutomata2::IsInputKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata2::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata2::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}


// CHangulAutomata3
inline
HAutomataReturnState CHangulAutomata3::Machine(UINT KeyCode, int iShift) 
	{
	Assert(KeyCode<256);
	return (Input(wHTable[KeyCode][iShift]));
	}

inline
BOOL CHangulAutomata3::IsInputKey(UINT KeyCode, int iShift)
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata3::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata3::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return 0;
	}

// CHangulAutomata3Final
inline 
HAutomataReturnState CHangulAutomata3Final::Machine(UINT KeyCode, int iShift) 
	{
	Assert(KeyCode<256);
	return (Input(wHTable[KeyCode][iShift]));
	}

inline 
BOOL CHangulAutomata3Final::IsInputKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return fFalse;
	}

inline
BOOL CHangulAutomata3Final::IsHangulKey(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]) & H_HANGUL;
	else
		return fFalse;
	}

inline
WORD CHangulAutomata3Final::GetKeyMap(UINT KeyCode, int iShift) 
	{
	if (KeyCode<256)
		return (wHTable[KeyCode][iShift]);
	else
		return 0;
	}

#endif // !defined (__HAUTOMATA_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\hauto.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Hangul automata Class definition
//
// Author: cslim@microsoft.com
// 
// Copyright 1997 Microsoft Corporation.

#include "private.h"
#include "HAuto.h"

// Code conversion table from Chosung to Jongsung.
const 
BYTE  CHangulAutomata::Cho2Jong[NUM_OF_CHOSUNG+1] = //(+ 1 means including fill code at 0)
    { 0, 
      1,  2,  4,  7,  0,  8, 16, 17,  0, 19,
     20, 21, 22,  0, 23, 24, 25, 26, 27
    };

// Code conversion table from Jongsung to Chosung.
const 
BYTE  CHangulAutomata::Jong2Cho[NUM_OF_JONGSUNG] = // Jongsung has inherent fill code
    {  0, 
        1,  2,  0,  3,  0,  0,  4,  6,  0,  0,
        0,  0,  0,  0,  0,  7,  8,  0, 10, 11,
       12, 13, 15, 16, 17, 18, 19  
    };

// Combination table for double jongsung.
BYTE  CHangulAutomata2::rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_2BEOL+1][3] = 
    {
        {  1, 19,  3 }, {  4, 22,  5 }, 
        {  4, 27,  6 },    {  8,  1,  9 }, 
        {  8, 16, 10 },    {  8, 17, 11 }, 
        {  8, 19, 12 },    {  8, 25, 13 }, 
        {  8, 26, 14 }, {  8, 27, 15 }, 
        { 17, 19, 18 },
        { 0,   0,  0 }
    };

BYTE  CHangulAutomata3::rgbDJongTbl[NUM_OF_DOUBLE_JONGSUNG_3BEOL+1][3] = 
    {
        // 3Beolsik has two more Double Jongsung conditions.
        {  1,  1,  2 },    // KiYeok+KiYeok = Double KiYeok
        {  1, 19,  3 }, {  4, 22,  5 }, 
        {  4, 27,  6 },    {  8,  1,  9 }, 
        {  8, 16, 10 },    {  8, 17, 11 }, 
        {  8, 19, 12 },    {  8, 25, 13 }, 
        {  8, 26, 14 }, {  8, 27, 15 }, 
        { 17, 19, 18 },    
        { 19, 19, 20 },  // Sios+Sios = Double Sios
        { 0,   0,  0 }
    };


#if (NOT_USED)
static
WORD CHangulAutomata::DblJong2Cho(WORD DblJong)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    int i = NUM_OF_DOUBLE_JONGSUNG;
    
    for (; i>0; i--, pDbl--)
        if ( (*pDbl)[2] == DblJong ) 
            return Jong2Cho[(*pDbl)[1]];

    return 0;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// 2 beolsik input state category
const WORD CHangulAutomata2::H_CONSONANT = 0x0000 | H_HANGUL;    // Consonant
const WORD CHangulAutomata2::H_VOWEL     = 0x0100 | H_HANGUL;    // Vowel
const WORD CHangulAutomata2::H_DOUBLE    = 0x0200 | H_HANGUL;    // Double combination possible
const WORD CHangulAutomata2::H_ONLYCHO   = 0x0400 | H_HANGUL;    // Chosung only

// 3 beolsik input state category
const WORD CHangulAutomata3::H_CHOSUNG   = 0x0000 | H_HANGUL;    // ChoSung
const WORD CHangulAutomata3::H_JUNGSUNG  = 0x0200 | H_HANGUL;   // JungSung
const WORD CHangulAutomata3::H_JONGSUNG  = 0x0400 | H_HANGUL;   // JongSung
const WORD CHangulAutomata3::H_DOUBLE    = 0x0100 | H_HANGUL;    // Double combination possible

///////////////////////////////////////////////////////////////////////////////
// bHTable[] structure
//
// 2 Beolsik
//     H I G H  B Y T E  L O W  B Y T E
//    7 6 5 4 3 2 1 0  7 6 5 4 3 2 1 0          
//   +-+-------+-----+---------------+
//   | |       |     |               |
//   +-+-------+-----+---------------+
//     High 8   : Hangul or English
//   High 2-0 : used for input state category field.
//   Low  4-0 : Hangul component code (internal code)
//

// ====-- SHARED SECTION START --====
#pragma data_seg(".MSIMESHR")
WORD  CHangulAutomata2::wHTable[256][2] =
{
//  { Hangul normal, Hangul shift, English normal, English shift }
    // 2 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 0x30, 0x29 }, //  48, 0x30: VK_0
    { 0x31, 0x21 }, //  49, 0x31: VK_1
    { 0x32, 0x40 }, //  50, 0x32: VK_2
    { 0x33, 0x23 }, //  51, 0x33: VK_3
    { 0x34, 0x24 }, //  52, 0x34: VK_4
    { 0x35, 0x25 }, //  53, 0x35: VK_5
    { 0x36, 0x5E }, //  54, 0x36: VK_6
    { 0x37, 0x26 }, //  55, 0x37: VK_7
    { 0x38, 0x2A }, //  56, 0x38: VK_8
    { 0x39, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    {  7 | H_CONSONANT,  7 | H_CONSONANT },                            //  65, 0x41: VK_A        
    { 18 | H_VOWEL, 18 | H_VOWEL },                                    //  66, 0x42: VK_B        
    { 15 | H_CONSONANT, 15 | H_CONSONANT },                            //  67, 0x43: VK_C        
    { 12 | H_CONSONANT, 12 | H_CONSONANT },                            //  68, 0x44: VK_D        
    {  4 | H_CONSONANT,  5 | H_ONLYCHO},                            //  69, 0x45: VK_E        
    {  6 | H_CONSONANT | H_DOUBLE,  6 | H_CONSONANT | H_DOUBLE },    //  70, 0x46: VK_F        
    { 19 | H_CONSONANT, 19 | H_CONSONANT },                            //  71, 0x47: VK_G        
    {  9 | H_VOWEL | H_DOUBLE,  9 | H_VOWEL | H_DOUBLE },            //  72, 0x48: VK_H        
    {  3 | H_VOWEL,  3 | H_VOWEL },                                    //  73, 0x49: VK_I        
    {  5 | H_VOWEL,  5 | H_VOWEL },                                    //  74, 0x4A: VK_J        
    {  1 | H_VOWEL,  1 | H_VOWEL },                                    //  75, 0x4B: VK_K        
    { 21 | H_VOWEL, 21 | H_VOWEL },                                    //  76, 0x4C: VK_L        
    { 19 | H_VOWEL | H_DOUBLE, 19 | H_VOWEL | H_DOUBLE },            //  77, 0x4D: VK_M        
    { 14 | H_VOWEL | H_DOUBLE, 14 | H_VOWEL | H_DOUBLE },            //  78, 0x4E: VK_N        
    {  2 | H_VOWEL,  4 | H_VOWEL },                                    //  79, 0x4F: VK_O        
    {  6 | H_VOWEL,  8 | H_VOWEL },                                    //  80, 0x50: VK_P        
    {  8 | H_CONSONANT | H_DOUBLE,  9 | H_ONLYCHO },                //  81, 0x51: VK_Q        
    {  1 | H_CONSONANT | H_DOUBLE,  2 | H_CONSONANT },                //  82, 0x52: VK_R        
    {  3 | H_CONSONANT | H_DOUBLE,  3 | H_CONSONANT | H_DOUBLE },    //  83, 0x53: VK_S        
    { 10 | H_CONSONANT, 11 | H_CONSONANT },                            //  84, 0x54: VK_T        
    {  7 | H_VOWEL, 7 | H_VOWEL },                                    //  85, 0x55: VK_U        
    { 18 | H_CONSONANT, 18 | H_CONSONANT },                            //  86, 0x56: VK_V        
    { 13 | H_CONSONANT, 14 | H_ONLYCHO },                            //  87, 0x57: VK_W        
    { 17 | H_CONSONANT, 17 | H_CONSONANT },                            //  88, 0x58: VK_X        
    { 13 | H_VOWEL, 13 | H_VOWEL },                                    //  89, 0x59: VK_Y        
    { 16 | H_CONSONANT, 16 | H_CONSONANT },                            //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    { 0x3B, 0x3A }, // 186, 0xBA:    ;    :
    { 0x3D, 0x2B }, // 187, 0xBB:    =    +
    { 0x2C, 0x3C }, // 188, 0xBC:    ,    <
    { 0x2D, 0x5F }, // 189, 0xBD:    -    _
    { 0x2E, 0x3E }, // 190, 0xBE:    .    >
    { 0x2F, 0x3F }, // 191, 0xBF:    /    ?
    { 0x60, 0x7E }, // 192, 0xC0:    `    ~
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:    [    {
    { 0x5C, 0x7C }, // 220, 0xDC:    \    |
    { 0x5D, 0x7D }, // 221, 0xDD:    ]    }
    { 0x27, 0x22 }, // 222, 0xDE:    '    "
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

WORD  CHangulAutomata3::wHTable[256][2] =
{
    // 3 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 16 | H_CHOSUNG, 0x29 },                    //  48, 0x30: VK_0        )
    { 27 | H_JONGSUNG, 22 | H_JONGSUNG },        //  49, 0x31: VK_1        
    { 20 | H_JONGSUNG, 0x40 },                    //  50, 0x32: VK_2        @
    { 17 | H_JONGSUNG | H_DOUBLE, 0x23 },        //  51, 0x33: VK_3        #
    { 13 | H_JUNGSUNG, 0x24 },                    //  52, 0x34: VK_4        $
    { 18 | H_JUNGSUNG, 0x25 },                    //  53, 0x35: VK_5        %
    {  3 | H_JUNGSUNG, 0x5E },                    //  54, 0x36: VK_6        ^
    {  8 | H_JUNGSUNG, 0x26 },                    //  55, 0x37: VK_7        &
    { 20 | H_JUNGSUNG, 0x2A },                    //  56, 0x38: VK_8        *
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 21 | H_JONGSUNG,  7 | H_JONGSUNG},    //  65, 0x41: VK_A        
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x21 },    //  66, 0x42: VK_B        !
    {  6 | H_JUNGSUNG, 10 | H_JONGSUNG},    //  67, 0x43: VK_C        
    { 21 | H_JUNGSUNG,  9 | H_JONGSUNG},    //  68, 0x44: VK_D        
    {  7 | H_JUNGSUNG, 24 | H_JONGSUNG},    //  69, 0x45: VK_E        
    {  1 | H_JUNGSUNG,  2 | H_JONGSUNG},    //  70, 0x46: VK_F        
    { 19 | H_JUNGSUNG | H_DOUBLE, 0x2F },    //  71, 0x47: VK_G        /
    {  3 | H_CHOSUNG, 0x27 },                //  72, 0x48: VK_H        ,
    {  7 | H_CHOSUNG, 0x38 },                //  73, 0x49: VK_I        8
    { 12 | H_CHOSUNG, 0x34 },                //  74, 0x4A: VK_J        4
    {  1 | H_CHOSUNG | H_DOUBLE, 0x35 },    //  75, 0x4B: VK_K        5
    { 13 | H_CHOSUNG | H_DOUBLE, 0x36 },    //  76, 0x4C: VK_L        6
    { 19 | H_CHOSUNG, 0x31 },        //  77, 0x4D: VK_M        1
    { 10 | H_CHOSUNG | H_DOUBLE, 0x30 },    //  78, 0x4E: VK_N        0
    { 15 | H_CHOSUNG, 0x39 },                //  79, 0x4F: VK_O        9
    { 18 | H_CHOSUNG, 0x3E },                //  80, 0x50: VK_P        >
    { 19 | H_JONGSUNG | H_DOUBLE,  26 | H_JONGSUNG},    //  81, 0x51: VK_Q        
    {  2 | H_JUNGSUNG, 4 | H_JUNGSUNG},                    //  82, 0x52: VK_R        
    {  4 | H_JONGSUNG | H_DOUBLE,  6 | H_JONGSUNG},        //  83, 0x53: VK_S        
    {  5 | H_JUNGSUNG, 0x3B },                            //  84, 0x54: VK_T        ;
    {  4 | H_CHOSUNG | H_DOUBLE, 0x37 },                //  85, 0x55: VK_U        7
    {  9 | H_JUNGSUNG | H_DOUBLE, 15 | H_JONGSUNG },    //  86, 0x56: VK_V        
    {  8 | H_JONGSUNG | H_DOUBLE, 25 | H_JONGSUNG},        //  87, 0x57: VK_W        
    {  1 | H_JONGSUNG | H_DOUBLE, 18 | H_JONGSUNG },    //  88, 0x58: VK_X        
    {  6 | H_CHOSUNG, 0x3C },                            //  89, 0x59: VK_Y        <
    { 16 | H_JONGSUNG,  23 | H_JONGSUNG },                //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    {  8 | H_CHOSUNG | H_DOUBLE, 0x3A },    // 186, 0xBA:        :
    { 0x3D, 0x2B },                            // 187, 0xBB:
    { 0x2C, 0x32 },                            // 188, 0xBC:    ,    2
    { 0x2D, 0x5F },                            // 189, 0xBD:
    { 0x2E, 0x33 },                            // 190, 0xBE:    .    3
    {  9 | H_JUNGSUNG | H_DOUBLE, 0x3F },    // 191, 0xBF:        ?
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:    [    {
    { 0x5C, 0x7C }, // 220, 0xDC:    \    |
    { 0x5D, 0x7D }, // 221, 0xDD:    ]    }
    { 17 | H_CHOSUNG, 0x22 }, // 222, 0xDE:        "
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

WORD  CHangulAutomata3Final::wHTable[256][2] =
{
    // 3 BeolSik
    { 0x00, 0x00 }, //   0, 0x00:
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 16 | H_CHOSUNG, 0x7E },                    //  48, 0x30: VK_0        ~
    { 27 | H_JONGSUNG,  2 | H_JONGSUNG },        //  49, 0x31: VK_1        
    { 20 | H_JONGSUNG,  9 | H_JONGSUNG },        //  50, 0x32: VK_2         
    { 17 | H_JONGSUNG|H_DOUBLE, 22 | H_JONGSUNG },    //  51, 0x33: VK_3        
    { 13 | H_JUNGSUNG, 14 | H_JONGSUNG },            //  52, 0x34: VK_4        
    { 18 | H_JUNGSUNG, 13 | H_JONGSUNG },            //  53, 0x35: VK_5        
    {  3 | H_JUNGSUNG, 0x3D },                    //  54, 0x36: VK_6        =
    {  8 | H_JUNGSUNG, 0x22 },                    //  55, 0x37: VK_7        "
    { 20 | H_JUNGSUNG, 0x22 },                    //  56, 0x38: VK_8        "
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x27 },        //  57, 0x39: VK_9  '
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 21 | H_JONGSUNG,  7 | H_JONGSUNG},    //  65, 0x41: VK_A        
    { 14 | H_JUNGSUNG | H_DOUBLE, 0x3F },    //  66, 0x42: VK_B        ?
    {  6 | H_JUNGSUNG, 24 | H_JONGSUNG},    //  67, 0x43: VK_C        
    { 21 | H_JUNGSUNG, 11 | H_JONGSUNG},    //  68, 0x44: VK_D        
    {  7 | H_JUNGSUNG,  5 | H_JONGSUNG},    //  69, 0x45: VK_E        
    {  1 | H_JUNGSUNG, 10 | H_JONGSUNG},    //  70, 0x46: VK_F        
    { 19 | H_JUNGSUNG | H_DOUBLE, 4 | H_JUNGSUNG },    //  71, 0x47: VK_G        
    {  3 | H_CHOSUNG, 0x30 },                //  72, 0x48: VK_H        0
    {  7 | H_CHOSUNG, 0x37 },                //  73, 0x49: VK_I        7
    { 12 | H_CHOSUNG, 0x31 },                //  74, 0x4A: VK_J        1
    {  1 | H_CHOSUNG | H_DOUBLE, 0x32 },    //  75, 0x4B: VK_K        2
    { 13 | H_CHOSUNG | H_DOUBLE, 0x33 },    //  76, 0x4C: VK_L        3
    { 19 | H_CHOSUNG, 0x22},                //  77, 0x4D: VK_M        "
    { 10 | H_CHOSUNG | H_DOUBLE, 0x2D },    //  78, 0x4E: VK_N        -
    { 15 | H_CHOSUNG, 0x38 },                //  79, 0x4F: VK_O        8
    { 18 | H_CHOSUNG, 0x39 },                //  80, 0x50: VK_P        9
    { 19 | H_JONGSUNG | H_DOUBLE,  26 | H_JONGSUNG},    //  81, 0x51: VK_Q        
    {  2 | H_JUNGSUNG, 15 | H_JONGSUNG},                //  82, 0x52: VK_R        
    {  4 | H_JONGSUNG | H_DOUBLE,  6 | H_JONGSUNG},        //  83, 0x53: VK_S        
    {  5 | H_JUNGSUNG, 12 | H_JONGSUNG },                            //  84, 0x54: VK_T        
    {  4 | H_CHOSUNG | H_DOUBLE, 0x36 },                //  85, 0x55: VK_U        6
    {  9 | H_JUNGSUNG | H_DOUBLE,  3 | H_JONGSUNG },    //  86, 0x56: VK_V        
    {  8 | H_JONGSUNG | H_DOUBLE, 25 | H_JONGSUNG},        //  87, 0x57: VK_W        
    {  1 | H_JONGSUNG | H_DOUBLE, 18 | H_JONGSUNG },    //  88, 0x58: VK_X        
    {  6 | H_CHOSUNG, 0x35 },                            //  89, 0x59: VK_Y        5
    { 16 | H_JONGSUNG,  23 | H_JONGSUNG },                //  90, 0x5A: VK_Z        
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    {  8 | H_CHOSUNG | H_DOUBLE, 0x34 },    // 186, 0xBA:        4
    { 0x3E, 0x2B },                            // 187, 0xBB:    >    +
    { 0x2C, 0x2C },                            // 188, 0xBC:    ,    ,
    { 0x29, 0x3B },                            // 189, 0xBD:    )    ;
    { 0x2E, 0x2E },                            // 190, 0xBE:    .    .
    {  9 | H_JUNGSUNG | H_DOUBLE, 0x21 },    // 191, 0xBF:        !
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x28, 0x25 }, // 219, 0xDB:    (    %
    { 0x3A, 0x5C }, // 220, 0xDC:    :    '\'
    { 0x3C, 0x2F }, // 221, 0xDD:    <    /
    { 17 | H_CHOSUNG, 0x00 }, // 222, 0xDE:    
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};

const 
BYTE  CHangulAutomata::bETable[256][2] =
{
    // English normal, English shift for Junja(Full shape) mode
    { 0x00, 0x00 }, //   0, 0x00: 
    { 0x00, 0x00 }, //   1, 0x01: VK_LBUTTON
    { 0x00, 0x00 }, //   2, 0x02: VK_RBUTTON
    { 0x00, 0x00 }, //   3, 0x03: VK_CANCEL
    { 0x00, 0x00 }, //   4, 0x04: VK_MBUTTON
    { 0x00, 0x00 }, //   5, 0x05:
    { 0x00, 0x00 }, //   6, 0x06:
    { 0x00, 0x00 }, //   7, 0x07:
    { 0x00, 0x00 }, //   8, 0x08: VK_BACK
    { 0x00, 0x00 }, //   9, 0x09: VK_TAB
    { 0x00, 0x00 }, //  10, 0x0A:
    { 0x00, 0x00 }, //  11, 0x0B:
    { 0x00, 0x00 }, //  12, 0x0C: VK_CLEAR
    { 0x00, 0x00 }, //  13, 0x0D: VK_RETURN
    { 0x00, 0x00 }, //  14, 0x0E:
    { 0x00, 0x00 }, //  15, 0x0F:
    { 0x00, 0x00 }, //  16, 0x10: VK_SHIFT
    { 0x00, 0x00 }, //  17, 0x11: VK_CONTROL
    { 0x00, 0x00 }, //  18, 0x12: VK_MENU
    { 0x00, 0x00 }, //  19, 0x13: VK_PAUSE
    { 0x00, 0x00 }, //  20, 0x14: VK_CAPITAL
    { 0x00, 0x00 }, //  21, 0x15: VK_HANGUL
    { 0x00, 0x00 }, //  22, 0x16:
    { 0x00, 0x00 }, //  23, 0x17: VK_JUNJA
    { 0x00, 0x00 }, //  24, 0x18:
    { 0x00, 0x00 }, //  25, 0x19: VK_HANJA
    { 0x00, 0x00 }, //  26, 0x1A:
    { 0x00, 0x00 }, //  27, 0x1B: VK_ESCAPE
    { 0x00, 0x00 }, //  28, 0x1C:
    { 0x00, 0x00 }, //  29, 0x1D:
    { 0x00, 0x00 }, //  30, 0x1E:
    { 0x00, 0x00 }, //  31, 0x1F:
    { 0x20, 0x20 }, //  32, 0x20: VK_SPACE
    { 0x00, 0x00 }, //  33, 0x21: VK_PRIOR
    { 0x00, 0x00 }, //  34, 0x22: VK_NEXT
    { 0x00, 0x00 }, //  35, 0x23: VK_END
    { 0x00, 0x00 }, //  36, 0x24: VK_HOME
    { 0x00, 0x00 }, //  37, 0x25: VK_LEFT
    { 0x00, 0x00 }, //  38, 0x26: VK_UP
    { 0x00, 0x00 }, //  39, 0x27: VK_RIGHT
    { 0x00, 0x00 }, //  40, 0x28: VK_DOWN
    { 0x00, 0x00 }, //  41, 0x29: VK_SELECT
    { 0x00, 0x00 }, //  42, 0x2A: VK_PRINT
    { 0x00, 0x00 }, //  43, 0x2B: VK_EXECUTE
    { 0x00, 0x00 }, //  44, 0x2C: VK_SNAPSHOT
    { 0x00, 0x00 }, //  45, 0x2D: VK_INSERT
    { 0x00, 0x00 }, //  46, 0x2E: VK_DELETE
    { 0x00, 0x00 }, //  47, 0x2F: VK_HELP
    { 0x30, 0x29 }, //  48, 0x30: VK_0
    { 0x31, 0x21 }, //  49, 0x31: VK_1
    { 0x32, 0x40 }, //  50, 0x32: VK_2
    { 0x33, 0x23 }, //  51, 0x33: VK_3
    { 0x34, 0x24 }, //  52, 0x34: VK_4
    { 0x35, 0x25 }, //  53, 0x35: VK_5
    { 0x36, 0x5E }, //  54, 0x36: VK_6
    { 0x37, 0x26 }, //  55, 0x37: VK_7
    { 0x38, 0x2A }, //  56, 0x38: VK_8
    { 0x39, 0x28 }, //  57, 0x39: VK_9
    { 0x00, 0x00 }, //  58, 0x3A:
    { 0x00, 0x00 }, //  59, 0x3B:
    { 0x00, 0x00 }, //  60, 0x3C:
    { 0x00, 0x00 }, //  61, 0x3D:
    { 0x00, 0x00 }, //  62, 0x3E:
    { 0x00, 0x00 }, //  63, 0x3F:
    { 0x00, 0x00 }, //  64, 0x40:
    { 0x61, 0x41 }, //  65, 0x41: VK_A
    { 0x62, 0x42 }, //  66, 0x42: VK_B
    { 0x63, 0x43 }, //  67, 0x43: VK_C
    { 0x64, 0x44 }, //  68, 0x44: VK_D
    { 0x65, 0x45 }, //  69, 0x45: VK_E
    { 0x66, 0x46 }, //  70, 0x46: VK_F
    { 0x67, 0x47 }, //  71, 0x47: VK_G
    { 0x68, 0x48 }, //  72, 0x48: VK_H
    { 0x69, 0x49 }, //  73, 0x49: VK_I
    { 0x6A, 0x4A }, //  74, 0x4A: VK_J
    { 0x6B, 0x4B }, //  75, 0x4B: VK_K
    { 0x6C, 0x4C }, //  76, 0x4C: VK_L
    { 0x6D, 0x4D }, //  77, 0x4D: VK_M
    { 0x6E, 0x4E }, //  78, 0x4E: VK_N
    { 0x6F, 0x4F }, //  79, 0x4F: VK_O
    { 0x70, 0x50 }, //  80, 0x50: VK_P
    { 0x71, 0x51 }, //  81, 0x51: VK_Q
    { 0x72, 0x52 }, //  82, 0x52: VK_R
    { 0x73, 0x53 }, //  83, 0x53: VK_S
    { 0x74, 0x54 }, //  84, 0x54: VK_T
    { 0x75, 0x55 }, //  85, 0x55: VK_U
    { 0x76, 0x56 }, //  86, 0x56: VK_V
    { 0x77, 0x57 }, //  87, 0x57: VK_W
    { 0x78, 0x58 }, //  88, 0x58: VK_X
    { 0x79, 0x59 }, //  89, 0x59: VK_Y
    { 0x7A, 0x5A }, //  90, 0x5A: VK_Z
    { 0x00, 0x00 }, //  91, 0x5B:
    { 0x00, 0x00 }, //  92, 0x5C:
    { 0x00, 0x00 }, //  93, 0x5D:
    { 0x00, 0x00 }, //  94, 0x5E:
    { 0x00, 0x00 }, //  95, 0x5F:
    { 0x30, 0x00 }, //  96, 0x60: VK_NUMPAD0
    { 0x31, 0x00 }, //  97, 0x61: VK_NUMPAD1
    { 0x32, 0x00 }, //  98, 0x62: VK_NUMPAD2
    { 0x33, 0x00 }, //  99, 0x63: VK_NUMPAD3
    { 0x34, 0x00 }, // 100, 0x64: VK_NUMPAD4
    { 0x35, 0x00 }, // 101, 0x65: VK_NUMPAD5
    { 0x36, 0x00 }, // 102, 0x66: VK_NUMPAD6
    { 0x37, 0x00 }, // 103, 0x67: VK_NUMPAD7
    { 0x38, 0x00 }, // 104, 0x68: VK_NUMPAD8
    { 0x39, 0x00 }, // 105, 0x69: VK_NUMPAD9
    { 0x2A, 0x2A }, // 106, 0x6A: VK_MULTIPLY
    { 0x2B, 0x2B }, // 107, 0x6B: VK_ADD
    { 0x00, 0x00 }, // 108, 0x6C: VK_SEPARATOR
    { 0x2D, 0x2D }, // 109, 0x6D: VK_SUBTRACT
    { 0x2E, 0x00 }, // 110, 0x6E: VK_DECIMAL
    { 0x2F, 0x2F }, // 111, 0x6F: VK_DIVIDE
    { 0x00, 0x00 }, // 112, 0x70: VK_F1
    { 0x00, 0x00 }, // 113, 0x71: VK_F2
    { 0x00, 0x00 }, // 114, 0x72: VK_F3
    { 0x00, 0x00 }, // 115, 0x73: VK_F4
    { 0x00, 0x00 }, // 116, 0x74: VK_F5
    { 0x00, 0x00 }, // 117, 0x75: VK_F6
    { 0x00, 0x00 }, // 118, 0x76: VK_F7
    { 0x00, 0x00 }, // 119, 0x77: VK_F8
    { 0x00, 0x00 }, // 120, 0x78: VK_F9
    { 0x00, 0x00 }, // 121, 0x79: VK_F10
    { 0x00, 0x00 }, // 122, 0x7A: VK_F11
    { 0x00, 0x00 }, // 123, 0x7B: VK_F12
    { 0x00, 0x00 }, // 124, 0x7C: VK_F13
    { 0x00, 0x00 }, // 125, 0x7D: VK_F14
    { 0x00, 0x00 }, // 126, 0x7E: VK_F15
    { 0x00, 0x00 }, // 127, 0x7F: VK_F16
    { 0x00, 0x00 }, // 128, 0x80: VK_F17
    { 0x00, 0x00 }, // 129, 0x81: VK_F18
    { 0x00, 0x00 }, // 130, 0x82: VK_F19
    { 0x00, 0x00 }, // 131, 0x83: VK_F20
    { 0x00, 0x00 }, // 132, 0x84: VK_F21
    { 0x00, 0x00 }, // 133, 0x85: VK_F22
    { 0x00, 0x00 }, // 134, 0x86: VK_F23
    { 0x00, 0x00 }, // 135, 0x87: VK_F24
    { 0x00, 0x00 }, // 136, 0x88:
    { 0x00, 0x00 }, // 137, 0x89:
    { 0x00, 0x00 }, // 138, 0x8A:
    { 0x00, 0x00 }, // 139, 0x8B:
    { 0x00, 0x00 }, // 140, 0x8C:
    { 0x00, 0x00 }, // 141, 0x8D:
    { 0x00, 0x00 }, // 142, 0x8E:
    { 0x00, 0x00 }, // 143, 0x8F:
    { 0x00, 0x00 }, // 144, 0x90: VK_NUMLOCK
    { 0x00, 0x00 }, // 145, 0x91: VK_SCROLL
    { 0x00, 0x00 }, // 146, 0x92:
    { 0x00, 0x00 }, // 147, 0x93:
    { 0x00, 0x00 }, // 148, 0x94:
    { 0x00, 0x00 }, // 149, 0x95:
    { 0x00, 0x00 }, // 150, 0x96:
    { 0x00, 0x00 }, // 151, 0x97:
    { 0x00, 0x00 }, // 152, 0x98:
    { 0x00, 0x00 }, // 153, 0x99:
    { 0x00, 0x00 }, // 154, 0x9A:
    { 0x00, 0x00 }, // 155, 0x9B:
    { 0x00, 0x00 }, // 156, 0x9C:
    { 0x00, 0x00 }, // 157, 0x9D:
    { 0x00, 0x00 }, // 158, 0x9E:
    { 0x00, 0x00 }, // 159, 0x9F:
    { 0x00, 0x00 }, // 160, 0xA0:
    { 0x00, 0x00 }, // 161, 0xA1:
    { 0x00, 0x00 }, // 162, 0xA2:
    { 0x00, 0x00 }, // 163, 0xA3:
    { 0x00, 0x00 }, // 164, 0xA4:
    { 0x00, 0x00 }, // 165, 0xA5:
    { 0x00, 0x00 }, // 166, 0xA6:
    { 0x00, 0x00 }, // 167, 0xA7:
    { 0x00, 0x00 }, // 168, 0xA8:
    { 0x00, 0x00 }, // 169, 0xA9:
    { 0x00, 0x00 }, // 170, 0xAA:
    { 0x00, 0x00 }, // 171, 0xAB:
    { 0x00, 0x00 }, // 172, 0xAC:
    { 0x00, 0x00 }, // 173, 0xAD:
    { 0x00, 0x00 }, // 174, 0xAE:
    { 0x00, 0x00 }, // 175, 0xAF:
    { 0x00, 0x00 }, // 176, 0xB0:
    { 0x00, 0x00 }, // 177, 0xB1:
    { 0x00, 0x00 }, // 178, 0xB2:
    { 0x00, 0x00 }, // 179, 0xB3:
    { 0x00, 0x00 }, // 180, 0xB4:
    { 0x00, 0x00 }, // 181, 0xB5:
    { 0x00, 0x00 }, // 182, 0xB6:
    { 0x00, 0x00 }, // 183, 0xB7:
    { 0x00, 0x00 }, // 184, 0xB8:
    { 0x00, 0x00 }, // 185, 0xB9:
    { 0x3B, 0x3A }, // 186, 0xBA:
    { 0x3D, 0x2B }, // 187, 0xBB:
    { 0x2C, 0x3C }, // 188, 0xBC:
    { 0x2D, 0x5F }, // 189, 0xBD:
    { 0x2E, 0x3E }, // 190, 0xBE:
    { 0x2F, 0x3F }, // 191, 0xBF:
    { 0x60, 0x7E }, // 192, 0xC0:
    { 0x00, 0x00 }, // 193, 0xC1:
    { 0x00, 0x00 }, // 194, 0xC2:
    { 0x00, 0x00 }, // 195, 0xC3:
    { 0x00, 0x00 }, // 196, 0xC4:
    { 0x00, 0x00 }, // 197, 0xC5:
    { 0x00, 0x00 }, // 198, 0xC6:
    { 0x00, 0x00 }, // 199, 0xC7:
    { 0x00, 0x00 }, // 200, 0xC8:
    { 0x00, 0x00 }, // 201, 0xC9:
    { 0x00, 0x00 }, // 202, 0xCA:
    { 0x00, 0x00 }, // 203, 0xCB:
    { 0x00, 0x00 }, // 204, 0xCC:
    { 0x00, 0x00 }, // 205, 0xCD:
    { 0x00, 0x00 }, // 206, 0xCE:
    { 0x00, 0x00 }, // 207, 0xCF:
    { 0x00, 0x00 }, // 208, 0xD0:
    { 0x00, 0x00 }, // 209, 0xD1:
    { 0x00, 0x00 }, // 210, 0xD2:
    { 0x00, 0x00 }, // 211, 0xD3:
    { 0x00, 0x00 }, // 212, 0xD4:
    { 0x00, 0x00 }, // 213, 0xD5:
    { 0x00, 0x00 }, // 214, 0xD6:
    { 0x00, 0x00 }, // 215, 0xD7:
    { 0x00, 0x00 }, // 216, 0xD8:
    { 0x00, 0x00 }, // 217, 0xD9:
    { 0x00, 0x00 }, // 218, 0xDA:
    { 0x5B, 0x7B }, // 219, 0xDB:
    { 0x5C, 0x7C }, // 220, 0xDC:
    { 0x5D, 0x7D }, // 221, 0xDD:
    { 0x27, 0x22 }, // 222, 0xDE:
    { 0x00, 0x00 }, // 223, 0xDF:
    { 0x00, 0x00 }, // 224, 0xE0:
    { 0x00, 0x00 }, // 225, 0xE1:
    { 0x00, 0x00 }, // 226, 0xE2:
    { 0x00, 0x00 }, // 227, 0xE3:
    { 0x00, 0x00 }, // 228, 0xE4:
    { 0x00, 0x00 }, // 229, 0xE5:
    { 0x00, 0x00 }, // 230, 0xE6:
    { 0x00, 0x00 }, // 231, 0xE7:
    { 0x00, 0x00 }, // 232, 0xE8:
    { 0x00, 0x00 }, // 233, 0xE9:
    { 0x00, 0x00 }, // 234, 0xEA:
    { 0x00, 0x00 }, // 235, 0xEB:
    { 0x00, 0x00 }, // 236, 0xEC:
    { 0x00, 0x00 }, // 237, 0xED:
    { 0x00, 0x00 }, // 238, 0xEE:
    { 0x00, 0x00 }, // 239, 0xEF:
    { 0x00, 0x00 }, // 240, 0xF0:
    { 0x00, 0x00 }, // 241, 0xF1:
    { 0x00, 0x00 }, // 242, 0xF2:
    { 0x00, 0x00 }, // 243, 0xF3:
    { 0x00, 0x00 }, // 244, 0xF4:
    { 0x00, 0x00 }, // 245, 0xF5:
    { 0x00, 0x00 }, // 246, 0xF6:
    { 0x00, 0x00 }, // 247, 0xF7:
    { 0x00, 0x00 }, // 248, 0xF8:
    { 0x00, 0x00 }, // 249, 0xF9:
    { 0x00, 0x00 }, // 250, 0xFA:
    { 0x00, 0x00 }, // 251, 0xFB:
    { 0x00, 0x00 }, // 252, 0xFC:
    { 0x00, 0x00 }, // 253, 0xFD:
    { 0x00, 0x00 }, // 254, 0xFE:
    { 0x00, 0x00 }  // 255, 0xFF:
};


static 
WORD Int2UniCho[NUM_OF_CHOSUNG+1] = 
    {
    0,    // fill [0]
    UNICODE_HANGUL_COMP_JAMO_START + 0,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 1,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 3,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 6,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 7,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 8,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 16,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 17,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 18,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 20,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 21,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 22,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 23,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 24,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 25,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 26,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 27,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 28,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 29,    // 
    };

static 
WORD Int2UniJong[NUM_OF_JONGSUNG] = 
    {
    0,    // fill [0]
    UNICODE_HANGUL_COMP_JAMO_START + 0,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 1,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 2,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 3,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 4,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 5,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 6,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 8,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 9,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 10,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 11,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 12,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 13,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 14,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 15,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 16,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 17,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 19,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 20,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 21,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 22,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 23,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 25,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 26,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 27,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 28,    // 
    UNICODE_HANGUL_COMP_JAMO_START + 29,    // 
    };

// Compatibility Jamo Consonant map
static
BYTE CompJamoMapTable[30][2] =
    {
        // Jamo code , Jongsung Flag : Only if it can't be chosung then make it jongsung
        { _KIYEOK_,                0 },
        { _SSANGKIYEOK_,        0 },
        { _JONG_KIYEOK_SIOS,    1 },
        { _NIEUN_,                0 },
        { _JONG_NIEUN_CHIEUCH_, 1 },
        { _JONG_NIEUN_HIEUH_,    1 },
        { _TIKEUT_,                0 },    
        { _SSANGTIKEUT_,        0 },
        { _RIEUL_,                0 },
        { _JONG_RIEUL_KIYEOK_,    1 },
        { _JONG_RIEUL_MIUM_,    1 },
        { _JONG_RIEUL_PIEUP_,    1 },
        { _JONG_RIEUL_SIOS_,    1 },
        { _JONG_RIEUL_THIEUTH_,    1 },
        { _JONG_RIEUL_PHIEUPH_,    1 },
        { _JONG_RIEUL_HIEUH_,    1 },
        { _MIEUM_,                0 },
        { _PIEUP_,                0 },
        { _SSANGPIEUP_,            0 },
        { _JONG_PIEUP_SIOS,        1 },
        { _SIOS_,                0 }, 
        { _SSANGSIOS_,            0 }, 
        { _IEUNG_,                0 },    
        { _CIEUC_,                0 },
        { _SSANGCIEUC_,            0 },
        { _CHIEUCH_,            0 },
        { _KHIEUKH_,            0 },
        { _THIEUTH_,            0 },
        { _PHIEUPH_,            0 },
        { _HIEUH_,                0 },
    };


static
BYTE JongSungSep[NUM_OF_JONGSUNG][2] =
    {
        {    0,    0    },
        { _JONG_KIYEOK_,            0        },    //_JONG_KIYEOK_        
        { _JONG_SSANGKIYEOK_,        0        },    //_JONG_SSANGKIYEOK_    
        { _JONG_KIYEOK_,    _JONG_SIOS_        },    //_JONG_KIYEOK_SIOS    
        { _JONG_NIEUN_,                0        },    //_JONG_NIEUN_        
        { _JONG_NIEUN_,        _JONG_CIEUC_    },    //_JONG_NIEUN_CIEUC_
        { _JONG_NIEUN_,        _JONG_HIEUH_    },    //_JONG_NIEUN_HIEUH_    
        { _JONG_TIKEUT_,            0        },    //_JONG_TIKEUT_        
        { _JONG_RIEUL_,                0        },    //_JONG_RIEUL_        
        { _JONG_RIEUL_,        _JONG_KIYEOK_    },    //_JONG_RIEUL_KIYEOK_
        { _JONG_RIEUL_,        _JONG_MIEUM_    },    //_JONG_RIEUL_MIUM_        
        { _JONG_RIEUL_,        _JONG_PIEUP_    },    //_JONG_RIEUL_PIEUP_
        { _JONG_RIEUL_,        _JONG_SIOS_        },    //_JONG_RIEUL_SIOS_    
        { _JONG_RIEUL_,        _JONG_THIEUTH_    },    //_JONG_RIEUL_THIEUTH_
        { _JONG_RIEUL_,        _JONG_PHIEUPH_    },    //_JONG_RIEUL_PHIEUPH_    
        { _JONG_RIEUL_,        _JONG_HIEUH_    },    //_JONG_RIEUL_HIEUH_
        { _JONG_MIEUM_,                0        },    //_JONG_MIEUM_        
        { _JONG_PIEUP_,                0        },    //_JONG_PIEUP_        
        { _JONG_PIEUP_,        _JONG_SIOS_        },    //_JONG_PIEUP_SIOS
        { _JONG_SIOS_,                0        },    //_JONG_SIOS_        
        { _JONG_SSANGSIOS_,            0        },    //_JONG_SSANGSIOS_    
        { _JONG_IEUNG_,                0        },    //_JONG_IEUNG_            
        { _JONG_CIEUC_,                0        },    //_JONG_CIEUC_            
        { _JONG_CHIEUCH_,            0        },    //_JONG_CHIEUCH_
        { _JONG_KHIEUKH_,            0        },    //_JONG_KHIEUKH_    
        { _JONG_THIEUTH_,            0        },    //_JONG_THIEUTH_    
        { _JONG_PHIEUPH_,            0        },    //_JONG_PHIEUPH_
        { _JONG_HIEUH_,                0        }    //_JONG_HIEUH_    
    };

static
BYTE JungSungSep[NUM_OF_JUNGSUNG+1][2] =
    {
        {    0,    0    },
        { _A_,                    0    },    // _A_,    
        { _AE_,                    0    },    //_AE_,    
        { _YA_,                    0    },    //_YA_,    
        { _YAE_,                0    },    //_YAE_,
        { _EO_,                    0    },    //_EO_,    
        { _E_,                    0    },    //_E_,    
        { _YEO_,                0    },    //_YEO_,
        { _YE_,                    0    },    //_YE_,    
        { _O_,                    0    },    //_O_,    
        { _O_,                _A_        },    //_WA_,    
        { _O_,                _AE_    },    //_WAE_,
        { _O_,                _I_        },    //_OE_,    
        { _YO_,                    0    },    //_YO_,    
        { _U_,                    0    },    //_U_,    
        { _U_,                _EO_    },    //_WEO_,
        { _U_,                _E_        },    //_WE_,    
        { _U_,                _I_        },    //_WI_,    
        { _YU_,                    0    },    //_YU_,    
        { _EU_,                    0    },    //_EU_,    
        { _EU_,                _I_        },    //_YI_,    
        { _I_,                    0    }    //_I_,    
    };
#pragma data_seg()
// ====-- SHARED SECTION END --====

///////////////////////////////////////////////////////////////////////////////
// CHangulAutomata class member function
BOOL CHangulAutomata::MakeComplete()
{
    if (m_wcComposition) 
        {
        m_wcComplete = m_wcComposition;
        
        // clear composition char
        m_wcComposition = 0;
        
        // Init interim stack
        InterimStack.Init();
        m_Chosung = m_Jungsung = m_Jongsung = 0;
        
        // Init state
        m_CurState = 0;
        return fTrue;
        }
    else
        return fFalse;
}

// Complete used when takeover occurs
BOOL CHangulAutomata::MakeComplete(WORD wcComplete)
{
    if (wcComplete) 
        {
        m_wcComplete = wcComplete;
        // clear composition char
        m_wcComposition = 0;
        // Init interim stack
        InterimStack.Init();
        m_Jungsung = m_Jongsung = 0;
        return fTrue;
        }
    else
        return fFalse;
}

void CHangulAutomata::MakeComposition()
{
    Assert(m_Chosung || m_Jungsung || m_Jongsung);
    // if Hangul
    if (m_Chosung && m_Jungsung) 
        {
        m_wcComposition = UNICODE_HANGUL_BASE 
                            + (m_Chosung-1) * NUM_OF_JUNGSUNG * (NUM_OF_JONGSUNG)    // +1 : jongsung fill
                            + (m_Jungsung-1) * (NUM_OF_JONGSUNG)
                            + m_Jongsung;
        }
    else // Hangul jamo
         // Currently map to compatiblity area. This should be changed if jamo glyphs available.
        {
            if (m_Chosung)
                m_wcComposition = Int2UniCho[m_Chosung];
            else
                if (m_Jungsung)
                    m_wcComposition = UNICODE_HANGUL_COMP_JAMO_START + 30 + m_Jungsung-1;
                    else 
                    if (m_Jongsung)
                        m_wcComposition = Int2UniJong[m_Jongsung];
        }
    // Push to interim stack
    InterimStack.Push(m_wInternalCode, m_CurState, m_Chosung, m_Jungsung, m_Jongsung, 
                      m_wcComposition);
    // Dbg(DBGID_Automata, _T("CHangulAutomata::MakeComposition(), m_CurState=%d, m_Chosung=%d, m_Jungsung=%d, m_Jongsung=%d, m_wcComposition = 0x%04X"), m_CurState,  m_Chosung, m_Jungsung, m_Jongsung, m_wcComposition);
    //
}

WORD CHangulAutomata::FindChosungComb(WORD wPrevCode)
{
    // Combination table for double chosung. (only for 3beolsik)
    static BYTE  rgbDChoTbl[NUM_OF_DOUBLE_CHOSUNG][3] = 
        {
            {  1,  1,  2 }, {  4,  4,  5 },        //   -> ,   -> 
            {  8,  8,  9 }, { 10, 10, 11 },        //   -> ,   -> 
            { 13, 13, 14 }                        //   -> 
        };

    BYTE (*pDbl)[3] = rgbDChoTbl;    // pointer a little bit faster than array access.
    int i = NUM_OF_DOUBLE_CHOSUNG;
    WORD wCurCode = m_wInternalCode & 0xFF;

    for (; i>0; i--, pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] == wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

WORD CHangulAutomata::FindJunsungComb(WORD wPrevCode)
{
    // Combination table for double jungsung.
    static BYTE  rgbDJungTbl[NUM_OF_DOUBLE_JUNGSUNG][3] = 
        {
            {  9,  1, 10 }, {  9,  2, 11 },        //   -> ,   -> 
            {  9, 21, 12 }, { 14,  5, 15 },        //   -> ,   -> 
            { 14,  6, 16 }, { 14, 21, 17 },        //   -> ,   -> 
            { 19, 21, 20 }                        //   -> 
        };
    BYTE (*pDbl)[3] = rgbDJungTbl;
    int i = NUM_OF_DOUBLE_JUNGSUNG;
    WORD wCurCode = m_wInternalCode & 0xFF;
    
    for (; i>0; i--, pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] == wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}


WORD CHangulAutomata2::FindJonsungComb(WORD wPrevCode)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    wPrevCode = Cho2Jong[wPrevCode];
    WORD wCurCode = Cho2Jong[m_wInternalCode & 0xFF];
    
    for (; (*pDbl)[0]; pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] ==  wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

WORD CHangulAutomata3::FindJonsungComb(WORD wPrevCode)
{
    BYTE (*pDbl)[3] = rgbDJongTbl;
    // 3BeolSik internal code have Jongsung code
    WORD wCurCode = m_wInternalCode & 0xFF;
    
    for (; (*pDbl)[0]; pDbl++)
        {
        if ( ((*pDbl)[0] == wPrevCode) && ((*pDbl)[1] ==  wCurCode) )
            return (*pDbl)[2];
        }
    return 0;
}

BOOL CHangulAutomata::BackSpace()
{
    InterimStackEntry*    pInterimEntry;

    if (InterimStack.IsEmpty())
        return fFalse;
    else 
        {
        InterimStack.Pop();
        if (!InterimStack.IsEmpty()) 
            {
            pInterimEntry = InterimStack.GetTop();
            m_wcComposition = pInterimEntry->m_wcCode;
            m_CurState = pInterimEntry->m_CurState;
            m_Chosung = pInterimEntry->m_Chosung;
            m_Jungsung = pInterimEntry->m_Jungsung;
            m_Jongsung = pInterimEntry->m_Jongsung;
            }
        else
            InitState();
        return fTrue;
        }    
}

void CHangulAutomata::SeparateDJung(LPWORD pJungSung)
{
    WORD wJungSung = pJungSung[0];
    pJungSung[0] = JungSungSep[wJungSung][0];
    pJungSung[1] = JungSungSep[wJungSung][1];
}

void CHangulAutomata::SeparateDJong(LPWORD pJongSung)
{
    WORD wJongSung = pJongSung[0];
    pJongSung[0] = JongSungSep[wJongSung][0];
    pJongSung[1] = JongSungSep[wJongSung][1];
}


///////////////////////////////////////////////////////////////////////////////
//
// Assume : Input wcComp has valid Unicode Hangul value
// (wcComp>0x3130 && wcComp<0x3164) || (wcComp>=0xAC00 && wcComp<0xD7A4)) 
//
BOOL CHangulAutomata2::SetCompositionChar(WCHAR wcComp)
{
    WORD wUnicodeHangulOffset;
    WORD wChosung;
    WORD wJungsung[2], wJongsung[2];

    // Dbg(DBGID_SetComp, _T("CHangulAutomata2::SetCompositionChar: wcComp = %c(0x%X)"), wcComp, wcComp), 

    InitState();

    wChosung = wJungsung[0] = wJungsung[1] = wJongsung[0] = wJongsung[1] = 0;

    if (wcComp <= UNICODE_HANGUL_COMP_JAMO_END && wcComp >= UNICODE_HANGUL_COMP_JAMO_START) 
        {
        // Dbg(DBGID_SetComp, _T("COMP_JAMO"));
        // Consonant or vowel ?
        if (wcComp < UNICODE_HANGUL_COMP_JAMO_VOWEL_START) 
            {
            wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_COMP_JAMO_START);
            // Jongsung or Chosung ?
            if (CompJamoMapTable[wUnicodeHangulOffset][1]) 
                {
                wJongsung[0] = CompJamoMapTable[wUnicodeHangulOffset][0];
                SeparateDJong(wJongsung);
                // Dbg(DBGID_Automata, _T("SetCompositionChar() : wJongsung[0]=%04x, wJongsung[1]=%04x"), wJongsung[0], wJongsung[1]);
                }
            else 
                wChosung = CompJamoMapTable[wUnicodeHangulOffset][0];

            }
        else 
            {
            wJungsung[0] = wcComp - UNICODE_HANGUL_COMP_JAMO_VOWEL_START + 1;
            SeparateDJung(wJungsung);
            }
        } 
    else 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_BASE);
        wChosung = (WORD)( wUnicodeHangulOffset / 
                                    (NUM_OF_JONGSUNG*NUM_OF_JUNGSUNG)) + 1;    // +1 to skip fill code

        wJungsung[0] = (WORD)(wUnicodeHangulOffset / NUM_OF_JONGSUNG
                                                        % NUM_OF_JUNGSUNG) + 1;
        SeparateDJung(wJungsung);

        wJongsung[0] = (WORD)(wUnicodeHangulOffset % NUM_OF_JONGSUNG);    // jongsung already has fill code
        SeparateDJong(wJongsung);
        }

    ///////////////////////////////////////////////////////////////////////////
    // Push process
    if (wChosung) 
        {
        m_Chosung = m_wInternalCode = wChosung;
        m_CurState = 1; // Chosung state
        MakeComposition();
        }

    if (wJungsung[0]) 
        {
        m_Jungsung = m_wInternalCode  = wJungsung[0];
        if (m_Jungsung == _O_ || m_Jungsung == _U_ || m_Jungsung == _EU_) 
            m_CurState = 3; // Double Jungsung possible state
        else
            m_CurState = 2; // Single Jungsung state
        MakeComposition();
        }

    if (wJungsung[1]) 
        {
        Assert(wJungsung[0] == _O_ || wJungsung[0] == _U_ || wJungsung[0] == _EU_);
        m_wInternalCode = wJungsung[1];
        m_Jungsung = FindJunsungComb(wJungsung[0]);
        Assert(m_Jungsung);
        m_CurState = 2; // Jungsung state
        MakeComposition();
        }

    //
    if (wJongsung[0]) 
        {
        m_wInternalCode  = Jong2Cho[wJongsung[0]];
        m_Jongsung = wJongsung[0];

        // KiYeok, Nieun, Rieul and Pieup: Double jongsong possible chars.
        if (m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_)
            m_CurState = 5; // Double Jongsung possible state
        else
            m_CurState = 4; // Single Jongsung state
        MakeComposition();
        }

    if (wJongsung[1]) 
        {
        Assert(m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
                || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_);
        m_wInternalCode = Jong2Cho[wJongsung[1]];
        m_Jongsung = FindJonsungComb(Jong2Cho[wJongsung[0]]);

        Assert(m_Jongsung);
        m_CurState = 4; // Jongsung state
        MakeComposition();
        }
    return fTrue;
}



///////////////////////////////////////////////////////////////////////////////
//    Transition table of 2beolsik hangul automata
const WORD CHangulAutomata2::m_NextStateTbl[8][5] = 
    {
        /////////////////////////////////////////////////////
        //    Sa        Va            Sb        Vb            Sc            State
        {     1,         6,             1,         7,            1        },    // 0 : Start
        {    FIND,     2,            FIND,     3,            FINAL    },    // 1 : Chosung
        {     4,        FINAL,         5,        FINAL,        FINAL    },    // 2 : Single Jungsung
        {     4,        FIND,         5,        FINAL,        FINAL    },    // 3 : Double Jungsung possible
        {    FINAL,    TAKEOVER,    FINAL,    TAKEOVER,    FINAL    },    // 4 : Single Jongsung
        {    FIND,    TAKEOVER,    FIND,    TAKEOVER,    FINAL    },    // 5 : Double Jongsung possible
        {    FINAL,    FINAL,        FINAL,    FINAL,        FINAL    },    // 6 : Single Jungsung(without chosung)
        {    FINAL,    FIND,        FINAL,    FINAL,        FINAL    }    // 7 : Double Jungsung possible(without chosung)
    };
///////////////////////////////////////////////////////////////////////////////

HAutomataReturnState CHangulAutomata2::Input(WORD InternalCode)
{
    WORD wSymbol, wFind;
    InterimStackEntry*    pPrevInterim;

    // Check if hangul key
    if ( !(InternalCode & H_HANGUL) )
        return HAUTO_NONHANGULKEY;    // This keycode need not handled in automata.
                                    // Calling function should handle it properly.

    // Copy internal code to member data
    m_wInternalCode = InternalCode;
    wSymbol = (m_wInternalCode >> 8) & 0x7F;
    m_NextState = m_NextStateTbl[m_CurState][wSymbol];

    switch (m_NextState) 
        {
        // Chosung
        case 1 :    m_Chosung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jungsung
        case 2 : case 3 : case 6 : case 7 :
                    m_Jungsung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jongsung
        case 4 : case 5 :
                    m_Jongsung = Cho2Jong[m_wInternalCode & 0xFF];
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;

        case FINAL :
                    MakeComplete();
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case TAKEOVER :
                    pPrevInterim = InterimStack.Pop();
                    m_Chosung = pPrevInterim->m_wInternalCode & 0xFF;
                    pPrevInterim = InterimStack.Pop();
                    MakeComplete(pPrevInterim->m_wcCode);
                    m_CurState = 1;
                    // FIXED : should call MakeComposition() to push interim state
                    MakeComposition();    
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case FIND :
            switch (m_CurState) 
            {
            case 7 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jungsung = wFind;
                        m_CurState = 6;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else 
                        { 
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            
            case 3 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jungsung = wFind;
                        m_CurState = 2;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else 
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            
            case 5 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Jongsung = wFind;
                        m_CurState = 4;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else  
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;

            // Only DJongsung case. same as case 5 except clearing chosung
            case 1: 
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                        {
                        m_Chosung = 0;
                        m_Jongsung = wFind;
                        m_CurState = 4;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                        }
                    else  
                        {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                        }
                    break;
            }
        }
    // impossible
    Assert(0);
    return HAUTO_IMPOSSIBLE;
}


///////////////////////////////////////////////////////////////////////////////
//    Transition table of 3 beolsik 390 hangul automata
const WORD CHangulAutomata3::m_NextStateTbl[11][6] = 
    {
        ////////////////////////////////////////////////////////////
        //    Sa        Sb        Va            Vb            Sc        Sd            State
        {     1,         2,        7,             8,             9,         10        },    // 0 : Start
        {    FINAL,    FINAL,    3,             4,            FINAL,    FINAL    },    // 1 : Chosung
        {    FINAL,    FIND,    3,             4,            FINAL,    FINAL    },    // 2 : Double Chosung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,         5,         6        },    // 3 : Jungsung
        {    FINAL,    FINAL,    FIND,        FINAL,         5,         6        },    // 4 : Double Jungsung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 5 : Jongsung
        {    FINAL,    FINAL,    FINAL,        FINAL,        FIND,    FIND    },    // 6 : Double Jongsung possible
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 7 : Single Jungsung (without chosung)
        {    FINAL,    FINAL,    FIND,        FINAL,        FINAL,    FINAL    },    // 8 : Double Jungsung possible(without chosung)
        {    FINAL,    FINAL,    FINAL,        FINAL,        FINAL,    FINAL    },    // 9 : Single Jongsung(without chosung)
        {    FINAL,    FINAL,    FINAL,        FINAL,        FIND,    FIND    }    // 10 : Double Jongsung possible(without chosung)

    };
///////////////////////////////////////////////////////////////////////////////

HAutomataReturnState CHangulAutomata3::Input(WORD InternalCode)
{
    WORD wSymbol, wFind;
    InterimStackEntry*    pPrevInterim;

    // Check if hangul key
    if (!(InternalCode & H_HANGUL))
        return HAUTO_NONHANGULKEY;    // This keycode need not handled in automata.
                                    // Calling function should handle it properly.

    // Get internal code from keycode
    m_wInternalCode = InternalCode;
    wSymbol = (m_wInternalCode >> 8) & 0x7F;
    m_NextState = m_NextStateTbl[m_CurState][wSymbol];

    switch (m_NextState) 
        {
        // Chosung
        case 1 : case 2 :    
                    m_Chosung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jungsung
        case 3 : case 4 : case 7 : case 8 :
                    m_Jungsung = m_wInternalCode & 0xFF;    
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        // Jongsung
        case 5 : case 6 : case 9 : case 10 :
                    m_Jongsung = m_wInternalCode & 0xFF;
                    m_CurState = m_NextState;
                    MakeComposition();
                    return HAUTO_COMPOSITION;
                    break;
        case FINAL :
                    MakeComplete();
                    Input(m_wInternalCode);
                    return HAUTO_COMPLETE;
                    break;

        case FIND :
            switch (m_CurState) 
            {
            case 8 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jungsung = wFind;
                        m_CurState = 7;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else 
                    { 
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 4 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJunsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jungsung = wFind;
                        m_CurState = 3;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else 
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 6 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jongsung = wFind;
                        m_CurState = 5;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            case 10 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindJonsungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Jongsung = wFind;
                        m_CurState = 7;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;

            case 2 :
                    pPrevInterim = InterimStack.GetTop();
                    if (wFind = FindChosungComb(pPrevInterim->m_wInternalCode & 0xFF)) 
                    {
                        m_Chosung = wFind;
                        m_CurState = 1;
                        MakeComposition();
                        return HAUTO_COMPOSITION;
                    }
                    else  
                    {
                        MakeComplete();
                        Input(m_wInternalCode);
                        return HAUTO_COMPLETE;
                    }
                    break;
            }
        }

    // impossible
    Assert(0);
    return HAUTO_IMPOSSIBLE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Assume : Input wcComp has valid Unicode Hangul value
// (wcComp>0x3130 && wcComp<0x3164) || (wcComp>=0xAC00 && wcComp<0xD7A4)) 
//
BOOL CHangulAutomata3::SetCompositionChar(WCHAR wcComp)
{
    WORD wUnicodeHangulOffset;
    WORD wChosung;
    WORD wJungsung[2], wJongsung[2];

    wChosung = wJungsung[0] = wJungsung[1] = wJongsung[0] = wJongsung[1] = 0;
    InitState();

    if (wcComp <= UNICODE_HANGUL_COMP_JAMO_END && wcComp >= UNICODE_HANGUL_COMP_JAMO_START) 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_COMP_JAMO_START);
        
        // Consonant or vowel ?
        if (wcComp < UNICODE_HANGUL_COMP_JAMO_VOWEL_START) 
            {
            // Jongsung or Chosung ?
            if (CompJamoMapTable[wUnicodeHangulOffset][1]) 
                {
                wJongsung[0] = CompJamoMapTable[wUnicodeHangulOffset][0];
                SeparateDJong(wJongsung);
                }
            else 
                wChosung = CompJamoMapTable[wUnicodeHangulOffset][0];

            }
        else 
            {
            wJungsung[0] = wcComp - UNICODE_HANGUL_COMP_JAMO_VOWEL_START + 1;
            SeparateDJung(wJungsung);
            }
        } 
    else 
        {
        wUnicodeHangulOffset = (wcComp-UNICODE_HANGUL_BASE);
        wChosung = (WORD)( wUnicodeHangulOffset / 
                                    (NUM_OF_JONGSUNG*NUM_OF_JUNGSUNG)) + 1;

        wJungsung[0] = (WORD)(wUnicodeHangulOffset / NUM_OF_JONGSUNG
                                                        % NUM_OF_JUNGSUNG) + 1;
        SeparateDJung(wJungsung);

        wJongsung[0] = (WORD)(wUnicodeHangulOffset % NUM_OF_JONGSUNG);
        SeparateDJong(wJongsung);
        }

    ///////////////////////////////////////////////////////////////////////////
    // Push process
    if (wChosung) 
        {
        m_Chosung = m_wInternalCode = wChosung;
        // KiYeok, TiKeut, Pieup, Sios, Cieuc
        if (m_Chosung == _KIYEOK_ || m_Chosung == _TIKEUT_ 
           || m_Chosung == _PIEUP_|| m_Chosung == _SIOS_ || m_Chosung == _CIEUC_)
            m_CurState = 2; // Double Chosung possible state
        else
            m_CurState = 1; // Chosung state
        MakeComposition();
        }

    if (wJungsung[0]) 
        {
        m_Jungsung = m_wInternalCode  = wJungsung[0];
        if (m_Jungsung == _O_ || m_Jungsung == _U_ || m_Jungsung == _EU_) 
            m_CurState = 4; // Double Jungsung possible state
        else
            m_CurState = 3; // Single Jungsung state
        MakeComposition();
        }

    if (wJungsung[1]) 
        {
        Assert(wJungsung[0] == _O_|| wJungsung[0] == _U_ || wJungsung[0] == _EU_);
        m_wInternalCode = wJungsung[1];
        m_Jungsung = FindJunsungComb(wJungsung[0]);
        Assert(m_Jungsung);
        m_CurState = 3; // Jungsung state
        MakeComposition();
        }

    //
    if (wJongsung[0]) 
        {
        m_wInternalCode  = wJongsung[0];
        m_Jongsung = wJongsung[0];
        // KiYeok, Nieun, Rieul, Pieup and Sios: Double jongsong possible chars.
        if (m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_ || m_Jongsung == _JONG_SIOS_)
            m_CurState = 6; // Double Jongsung possible state
        else
            m_CurState = 5; // Single Jongsung state
        MakeComposition();
        }

    if (wJongsung[1]) 
        {
        Assert(m_Jongsung == _JONG_KIYEOK_ || m_Jongsung == _JONG_NIEUN_ 
            || m_Jongsung == _JONG_RIEUL_ || m_Jongsung == _JONG_PIEUP_ || m_Jongsung == _JONG_SIOS_);

        m_wInternalCode = wJongsung[1];
        m_Jongsung = FindJonsungComb(wJongsung[0]);

        Assert(m_Jongsung);
        m_CurState = 5; // Jongsung state
        MakeComposition();
        }
    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\immsec.h ===
#if !defined (_IMMSEC_H__INCLUDED_)
#define _IMMSEC_H__INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif
PSECURITY_ATTRIBUTES CreateSecurityAttributes(VOID);
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa);
BOOL IsNT(VOID);
PSECURITY_ATTRIBUTES GetIMESecurityAttributes(VOID);
PSECURITY_ATTRIBUTES GetIMESecurityAttributesEx(VOID);
VOID FreeIMESecurityAttributes(VOID);
PSECURITY_ATTRIBUTES CreateSecurityAttributesEx(VOID);
PSID MyCreateSidEx(VOID);
#ifdef __cplusplus
}
#endif

#endif // !_IMMSEC_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\hjmode.h ===
//
// HJMODE.H
//

#if !defined (__HJMODE_H__INCLUDED_)
#define __HJMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class HJMode : public CCicButton
{
public:
    HJMode(CToolBar *ptb);
    ~HJMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    //HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);
    
private:

	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __HJMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\icpriv.cpp ===
//
// icpriv.cpp
//

#include "private.h"
#include "korimx.h"
#include "gdata.h"
#include "icpriv.h"
#include "helpers.h"
#include "funcprv.h"
#include "editcb.h"

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CICPriv::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CICPriv::AddRef()
{
    return ++m_cRef;
}

STDAPI_(ULONG) CICPriv::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CICPriv::CICPriv()
{
    m_fInitialized       = fFalse;
    m_pimx               = NULL;
    m_pic                = NULL;
    m_pActiveCompositon  = NULL;
#if 0
    m_pActiveRange       = NULL;
    m_pBackupRange       = NULL;
#endif
    m_pCompartmentSink   = NULL;
    m_guidMBias          = NULL;
    m_fTransaction       = fFalse;
    m_pMouseSink         = NULL;
    m_pIP                = NULL;
    m_fInitializedIPoint = fFalse;
    m_cRef               = 1;

    // initialize Shared memory. If this is only IME in the system
    // Shared memory will be created as file mapping object.
    //////////////////////////////////////////////////////////////////////
    m_pCIMEData = new CIMEData;
    Assert(m_pCIMEData != 0);
    if (m_pCIMEData)
        m_pCIMEData->InitImeData();

    //////////////////////////////////////////////////////////////////////////
    // Create All three IME Automata instances
    m_rgpHangulAutomata[KL_2BEOLSIK]        = new CHangulAutomata2;
    Assert(m_rgpHangulAutomata[KL_2BEOLSIK] != NULL);
    m_rgpHangulAutomata[KL_3BEOLSIK_390]   = new CHangulAutomata3;
    Assert(m_rgpHangulAutomata[KL_3BEOLSIK_390] != NULL);
    m_rgpHangulAutomata[KL_3BEOLSIK_FINAL] = new CHangulAutomata3Final;
    Assert(m_rgpHangulAutomata[KL_3BEOLSIK_FINAL] != NULL);
}

//+---------------------------------------------------------------------------
//
// dtor
//
//----------------------------------------------------------------------------

CICPriv::~CICPriv()
{
    if (m_pCIMEData)
        {
        delete m_pCIMEData;
        m_pCIMEData =  NULL;
        }

    // Delete Automata array
    for (INT i=0; i<NUM_OF_IME_KL; i++)
        {
        if (m_rgpHangulAutomata[i])
            delete m_rgpHangulAutomata[i];
        }
}

#if 0
/*---------------------------------------------------------------------------
    CKorIMX::_TextEventCallback
---------------------------------------------------------------------------*/
HRESULT CICPriv::_TextEventCallback(UINT uCode, VOID *pv, VOID *pvData)
{
    CICPriv            *picp = (CICPriv*)pv;
    CKorIMX            *pKorIMX;
    CEditSession2    *pes;
    ESSTRUCT          ess;
    ITfContext        *pic;
    BOOL             fInWriteSession;
    TESENDEDIT *pTESEndEdit = (TESENDEDIT*)pvData;
    IEnumTfRanges *pEnumText = NULL;
    HRESULT         hr;
    static const GUID *rgProperties[] = {     &GUID_PROP_TEXTOWNER, &GUID_PROP_LANGID,
                                            &GUID_PROP_ATTRIBUTE, /* &GUID_PROP_READING,*/
                                            &GUID_PROP_MODEBIAS };

    if (picp == NULL)
        return S_OK;

    pKorIMX = picp->GetIMX();
    if (pKorIMX == NULL) 
        return S_OK;

    if (uCode != ICF_TEXTDELTA)
        return S_OK;

    pic = picp->GetIC();

    pic->InWriteSession(pKorIMX->GetTID(), &fInWriteSession);
    if (fInWriteSession)
        return S_OK;                // own change.


    hr = pTESEndEdit->pEditRecord->GetTextAndPropertyUpdates(0 /*TF_GTP_INCL_TEXT*/, rgProperties, ARRAYSIZE(rgProperties), &pEnumText );

    if (FAILED(hr))
        return hr;
        
    if (pEnumText == NULL)
        return S_OK;

    ESStructInit(&ess, ESCB_TEXTEVENT);
    ess.pEnumRange = pEnumText;

    hr = E_OUTOFMEMORY;

    if (pes = new CEditSession2(pic, pKorIMX, &ess, CKorIMX::_EditSessionCallback2)) 
        {
         pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
        pes->Release();
        }

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\ic.cpp ===
//
// ic.cpp
//

#include "private.h"
#include "common.h"
#include "korimx.h"
#include "icpriv.h"
#include "ipointcic.h"
#include "cleanup.h"
#include "helpers.h"

//+---------------------------------------------------------------------------
//
// OnStartCleanupContext
//
//----------------------------------------------------------------------------

HRESULT CKorIMX::OnStartCleanupContext()
{
    // nb: a real tip, for performace, should skip input contexts it knows
    // it doesn't need a lock and callback on.  For instance, kimx only
    // cares about ic's with ongoing compositions.  We could remember which ic's
    // have compositions, then return FALSE for all but the ic's with compositions.
    // It is really bad perf to have the library make a lock request for every
    // ic!
    m_fPendingCleanup = fTrue;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnEndCleanupContext
//
// Called after all ic's with cleanup sinks have been called.
//----------------------------------------------------------------------------

HRESULT CKorIMX::OnEndCleanupContext()
{
    // our profile just changed or we are about to be deactivated
    // in either case we don't have to worry about anything interrupting ic cleanup
    // callbacks anymore
    m_fPendingCleanup = fFalse;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// OnCleanupContext
//
// This method is a callback for the library helper CleanupAllContexts.
// We have to be very careful here because we may be called _after_ this tip
// has been deactivated, if the app couldn't grant a lock right away.
//----------------------------------------------------------------------------

HRESULT CKorIMX::OnCleanupContext(TfEditCookie ecWrite, ITfContext *pic)
{
    // all kimx cares about is finalizing compositions
    CleanupAllCompositions(ecWrite, pic, CLSID_KorIMX, _CleanupCompositionsCallback, this);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// ITfActiveLanguageProfileNotifySink::OnActivated
//
//----------------------------------------------------------------------------
STDAPI CKorIMX::OnActivated(REFCLSID clsid, REFGUID guidProfile, BOOL bActivated)
{
    // our profile just changed or we are about to be deactivated
    // in either case we don't have to worry about anything interrupting ic cleanup
    // callbacks anymore
    m_fPendingCleanup = fFalse;

    //if (IsSoftKbdEnabled())
    //    OnActivatedSoftKbd(bActivated);
        
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// _CleanupCompositionsCallback
//
//----------------------------------------------------------------------------

/* static */
void CKorIMX::_CleanupCompositionsCallback(TfEditCookie ecWrite, ITfRange *rangeComposition, void *pvPrivate)
{
    CKorIMX* pKorTip = (CKorIMX*)pvPrivate;
    ITfContext *pic;

    if (rangeComposition->GetContext(&pic) != S_OK)
        return;
        
    if (pKorTip)
        pKorTip->MakeResultString(ecWrite, pic, rangeComposition);
    // _FinalizeRange(ecWrite, pic, rangeComposition);

    pic->Release();
}

/*---------------------------------------------------------------------------
    CKorIMX::_InitICPriv

    Init IC private data
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_InitICPriv(ITfContext *pic)
{
    CICPriv *picp;
    CCompartmentEventSink* pCompartmentSink;
    ITfSourceSingle *pSourceSingle;
    TF_STATUS dcs;

    // Check pic
    if (pic == NULL)
        return E_FAIL;
    //
    // check enable/disable (Candidate stack)
    //
    if (IsDisabledIC(pic) || IsEmptyIC(pic))
        return S_OK;

    // Initialize Private data members
    if ((picp = GetInputContextPriv(pic)) == NULL)
        {
        IUnknown *punk;

        if ((picp = new CICPriv) == NULL)
               return E_OUTOFMEMORY;

        // IC
        picp->RegisterIC(pic);
        // IMX
        picp->RegisterIMX(this);

    	if (picp->IsInitializedIPoint() == FALSE)
    	    {
    		//struct _GUID RefID={0}; // dummy id
    		IImeIPoint1 *pIP;
            LPCIPointCic pCIPointCic = NULL;

            //////////////////////////////////////////////////////////////////////
            // Create IImeIPoint1 instance
            //////////////////////////////////////////////////////////////////////
            if ((pCIPointCic = new CIPointCic(this)) == NULL)
                {
                return E_OUTOFMEMORY;
                }

            // This increments the reference count
            if (FAILED(pCIPointCic->QueryInterface(IID_IImeIPoint1, (VOID **)&pIP)))
                {
                delete pCIPointCic;
                return E_OUTOFMEMORY;
                }

    		// initialize kernel
    		pCIPointCic->Initialize(pic);

    		// register ic depended objects.
    		picp->RegisterIPoint(pIP);
    		picp->InitializedIPoint(fTrue);
    	    }
    	
        //
        // text edit sink/edit transaction sink
        //
        ITfSource *pSource;
        DWORD dwCookieForTextEditSink = 0;
        //DWORD dwCookieForTransactionSink = 0;
        if (pic->QueryInterface(IID_ITfSource, (void **)&pSource ) == S_OK)
            {
            pSource->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &dwCookieForTextEditSink);
            //pSource->AdviseSink(IID_ITfEditTransactionSink, (ITfEditTransactionSink *)this, &dwCookieForTransactionSink);

            pSource->Release();

            picp->RegisterCookieForTextEditSink(dwCookieForTextEditSink);
            //picp->RegisterCookieForTransactionSink(dwCookieForTransactionSink);
            }

        // compartment event sink
        if ((pCompartmentSink = new CCompartmentEventSink(_CompEventSinkCallback, picp)) != NULL )
            {
            picp->RegisterCompartmentEventSink(pCompartmentSink);

            // On/Off - compartment
            pCompartmentSink->_Advise(GetTIM(), GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, FALSE);
            
            // Conversion mode - compartment
            pCompartmentSink->_Advise(GetTIM(), GUID_COMPARTMENT_KORIMX_CONVMODE, FALSE);

            // SoftKeyboard Open/Close
            pCompartmentSink->_Advise(GetTIM(), GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE, FALSE);

            // Soft Keyboard layout change
            pCompartmentSink->_Advise(GetTIM(), GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, FALSE);
            }

        Assert(pCompartmentSink != NULL);

        if (pic->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
            {
            // setup a cleanup callback
            // nb: a real tip doesn't need to be this aggressive, for instance
                // kimx probably only needs this sink on the focus ic.
            pSourceSingle->AdviseSingleSink(GetTID(), IID_ITfCleanupContextSink, (ITfCleanupContextSink *)this);
            pSourceSingle->Release();
            }

        // Initialized kernel
        picp->Initialized(fTrue);

        // Set to compartment GUID
        GetCompartmentUnknown(pic, GUID_IC_PRIVATE, &punk);
        if (!punk)
            {
            SetCompartmentUnknown(GetTID(), pic, GUID_IC_PRIVATE, picp);
            picp->Release();
            }
        else
            {
            // Praive data already exist.
            punk->Release();
            return E_FAIL;
            }

        }

        // Set AIMM1.2
        picp->SetAIMM(fFalse);
        pic->GetStatus(&dcs);

        if (dcs.dwStaticFlags & TF_SS_TRANSITORY)
            picp->SetAIMM(fTrue);

    return S_OK;
}


/*---------------------------------------------------------------------------
    CKorIMX::_DeleteICPriv

    Delete IC private data
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_DeleteICPriv(ITfContext *pic)
{
    CICPriv        *picp;
    IUnknown        *punk;
    CCompartmentEventSink* pCompartmentSink;
    ITfSource         *pSource;
    ITfSourceSingle *pSourceSingle;
    
    if (pic == NULL)
        return E_FAIL;

    picp = GetInputContextPriv(pic);

#ifdef DBG
    Assert(IsDisabledIC(pic) || picp != NULL );
#endif
    
    if (picp == NULL)
         return S_FALSE;

    //
    // Compartment event sink
    //
    pCompartmentSink = picp->GetCompartmentEventSink();
    if (pCompartmentSink)
        {
        pCompartmentSink->_Unadvise();
        pCompartmentSink->Release();
        }

    //
    // text edit sink
    //
    if (pic->QueryInterface( IID_ITfSource, (void **)&pSource) == S_OK)
        {
        pSource->UnadviseSink(picp->GetCookieForTextEditSink());
        //pSource->UnadviseSink(picp->GetCookieForTransactionSink());
        pSource->Release();
        }
    picp->RegisterCookieForTextEditSink(0);

    // Clear ITfCleanupContextSink
    if (pic->QueryInterface(IID_ITfSourceSingle, (void **)&pSourceSingle) == S_OK)
        {
        pSourceSingle->UnadviseSingleSink(GetTID(), IID_ITfCleanupContextSink);
        pSourceSingle->Release();
        }

	// UnInitialize IPoint
	IImeIPoint1 *pIP = GetIPoint(pic);
	// IImeIPoint
	if (pIP)
	    {
		pIP->Release();
	    }
	picp->RegisterIPoint(NULL);
	picp->InitializedIPoint(fFalse);	// reset
	
    // Reset init flag
    picp->Initialized(fFalse);

    // We MUST clear out the private data before cicero is free 
    // to release the ic
    GetCompartmentUnknown(pic, GUID_IC_PRIVATE, &punk);
    if (punk)
        punk->Release();
    ClearCompartment(GetTID(), pic, GUID_IC_PRIVATE, fFalse);

    return S_OK;
}

/*---------------------------------------------------------------------------
    CKorIMX::GetInputContextPriv

    Get IC private data
---------------------------------------------------------------------------*/
CICPriv *CKorIMX::GetInputContextPriv(ITfContext *pic)
{
    IUnknown *punk;

    if (pic == NULL)
        return NULL;
        
    GetCompartmentUnknown(pic, GUID_IC_PRIVATE, &punk);

    if (punk)
        punk->Release();

    return (CICPriv *)punk;
}


/*---------------------------------------------------------------------------
    CKorIMX::OnICChange
---------------------------------------------------------------------------*/
void CKorIMX::OnFocusChange(ITfContext *pic, BOOL fActivate)
{
    BOOL fReleaseIC     = fFalse;
    BOOL fDisabledIC     = IsDisabledIC(pic);
    BOOL fEmptyIC         = IsEmptyIC(pic);
    BOOL fCandidateIC     = IsCandidateIC(pic);

    BOOL fInEditSession;
    HRESULT hr;

    if (fEmptyIC)
        {
        if (m_pToolBar)
            m_pToolBar->SetCurrentIC(NULL);

        if (IsSoftKbdEnabled())
            SoftKbdOnThreadFocusChange(fFalse);
        return;    // do nothing
        }
        
    if (fDisabledIC == fTrue && fCandidateIC == fFalse )
        {
        if (m_pToolBar)
            m_pToolBar->SetCurrentIC(NULL);

        if (IsSoftKbdEnabled())
            SoftKbdOnThreadFocusChange(fFalse);
        return;    // do nothing
        }

    // O10 #278261: Restore Soft Keyboard winfow after switched from Empty Context to normal IC.
    if (IsSoftKbdEnabled())
        SoftKbdOnThreadFocusChange(fActivate);

    // Notify focus change to IME Pad svr
	if (m_pPadCore)
	    {
		m_pPadCore->SetFocus(fActivate);
	    }

    // Terminate
    if (fActivate == fFalse)
        {
        if (!fDisabledIC && pic && GetIPComposition(pic))
            {
            if (SUCCEEDED(pic->InWriteSession(GetTID(), &fInEditSession)) && !fInEditSession)
                {
                CEditSession2 *pes;
                ESSTRUCT ess;

                ESStructInit(&ess, ESCB_COMPLETE);
                
                if ((pes = new CEditSession2(pic, this, &ess, _EditSessionCallback2)))
                       {
                    pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
                    pes->Release();
                    }
                }
            }

        // Close cand UI if opened.
        if (m_fCandUIOpen)
            CloseCandidateUIProc();
            
        return;
        }

    // fActivate == TRUE
    if (fDisabledIC)
        {
        pic = GetRootIC();
        fReleaseIC = fTrue;
        }

    if (m_pToolBar)
        m_pToolBar->SetCurrentIC(pic);

	if (m_pPadCore)
	    {
		IImeIPoint1* pIP = GetIPoint(pic);
		m_pPadCore->SetIPoint(pIP);
	    }

    if (pic && !fDisabledIC)
        {
        CICPriv *picp;

        // Sync GUID_COMPARTMENT_KEYBOARD_OPENCLOSE with GUID_COMPARTMENT_KORIMX_CONVMODE
        // This for Word now but looks not good since we don't sync On/Off status with conv mode.
        // In future Apps should set GUID_MODEBIAS_HANGUL on boot and should be Korean specific code. 
        if (GetConvMode(pic) == TIP_NULL_CONV_MODE) // if this is first boot.
            {
            if (IsOn(pic))
                SetCompartmentDWORD(GetTID(), GetTIM(), GUID_COMPARTMENT_KORIMX_CONVMODE, TIP_HANGUL_MODE, fFalse);
            else
                SetCompartmentDWORD(GetTID(), GetTIM(), GUID_COMPARTMENT_KORIMX_CONVMODE, TIP_ALPHANUMERIC_MODE, fFalse);
            }
        else
            {
            // Reset ModeBias
            picp = GetInputContextPriv(pic);
            if (picp)
                picp->SetModeBias(NULL);
            }

        // Modebias check here
        CheckModeBias(pic);
        }

    if (fReleaseIC)
        SafeRelease(pic);
}


// REVIEW::
// tmp solution
ITfContext* CKorIMX::GetRootIC(ITfDocumentMgr* pDim)
{
    if (pDim == NULL)
        {
        pDim = m_pCurrentDim;
        if( pDim == NULL )
            return NULL;
        }

    IEnumTfContexts *pEnumIc = NULL;
    if (SUCCEEDED(pDim->EnumContexts(&pEnumIc)))
        {
        ITfContext *pic = NULL;
        while (pEnumIc->Next(1, &pic, NULL) == S_OK)
            break;
        pEnumIc->Release();

        return pic;
        }
        
    return NULL;    // error case
}

IImeIPoint1* CKorIMX::GetIPoint(ITfContext *pic)
{
    CICPriv *picp;
    
    if (pic == NULL)
        {
        return NULL;
        }
    
    picp = GetInputContextPriv(pic);

    if (picp)
        {
        return picp->GetIPoint();
        }
    
    return NULL;
}
BOOL CKorIMX::IsDisabledIC(ITfContext *pic)
{
    DWORD dwFlag;

    if (pic == NULL)
        return fFalse;
           
    GetCompartmentDWORD(pic, GUID_COMPARTMENT_KEYBOARD_DISABLED, &dwFlag, fFalse);

    if (dwFlag)
        return fTrue;    // do not create any kernel related info into ic.
    else
        return fFalse;
}

/*   I S  E M P T Y   I  C   */
BOOL CKorIMX::IsEmptyIC(ITfContext *pic)
{
    DWORD dwFlag;
    
    if (pic == NULL)
        return fFalse;
    
    GetCompartmentDWORD(pic, GUID_COMPARTMENT_EMPTYCONTEXT, &dwFlag, fFalse);

    if (dwFlag)
        return fTrue;    // do not create any kernel related info into ic.

    return fFalse;
}

/*   I S  C A N D I D A T E  I  C   */
/*------------------------------------------------------------------------------

    Check if the input context is one of candidate UI

------------------------------------------------------------------------------*/
BOOL CKorIMX::IsCandidateIC(ITfContext *pic)
{
    DWORD dwFlag;
    
    if (pic == NULL) 
        return fFalse;
    
    GetCompartmentDWORD( pic, GUID_COMPARTMENT_KEYBOARD_DISABLED, &dwFlag, fFalse);

    if (dwFlag)
        return fTrue;    // do not create any kernel related info into ic.

    return fFalse;
}


HWND CKorIMX::GetAppWnd(ITfContext *pic)
{
    ITfContextView* pView;
    HWND hwndApp = 0;

    if (pic == NULL)
        return 0;

    pic->GetActiveView(&pView);
    if (pView == NULL)
        return 0;

    pView->GetWnd(&hwndApp);
    pView->Release();
    
    return hwndApp;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\icpriv.h ===
//
// ICPRIV.H  CICPriv class (TIP private data handling class)
//
//   History:
//      20-DEC-1999 CSLim Created


#ifndef __ICPRIV_H__INCLUDED_
#define __ICPRIV_H__INCLUDED_

#include "korimx.h"
#include "hauto.h"
#include "tes.h"
#include "gdata.h"

class CMouseSink;

class CICPriv : public IUnknown
{
public:
    CICPriv();
    ~CICPriv();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

// Operations
public:
	// Initialize
	void Initialized(BOOL fInit) { m_fInitialized = fInit; }
	BOOL IsInitialized()	     { return m_fInitialized;  }

	// CKorIMX
	void RegisterIMX(CKorIMX* pIMX)	 { m_pimx = pIMX; }
	CKorIMX* GetIMX()                { return m_pimx; }

	// IC
	void RegisterIC(ITfContext* pic) { m_pic = pic;   }
	ITfContext* GetIC(VOID)          { return m_pic;  }

	// Active composition
	void SetActiveComposition(ITfComposition *pComposition) { m_pActiveCompositon = pComposition; }
    ITfComposition* GetActiveComposition() { return m_pActiveCompositon; }

    //
    // Text edit sink cookie
    //
    VOID RegisterCookieForTextEditSink(DWORD dwCookie)  { m_dwCookieForTextEditSink = dwCookie; }
    DWORD GetCookieForTextEditSink()	 				{ return m_dwCookieForTextEditSink; }

    //
    // transaction sink cookie
    //
    VOID RegisterCookieForTransactionSink(DWORD dwCookie) 	{ m_dwCookieForTransactionSink = dwCookie; }
    DWORD GetCookieForTransactionSink()						{ return m_dwCookieForTransactionSink;     }

	// Text event sink
	void RegisterCompartmentEventSink(CCompartmentEventSink* pCompartmentSink) { m_pCompartmentSink = pCompartmentSink; }
	CCompartmentEventSink* GetCompartmentEventSink() 		   { return m_pCompartmentSink; }
	static HRESULT _TextEventCallback(UINT uCode, VOID *pv, VOID *pvData);

	// Set AIMM
	void SetAIMM(BOOL fAIMM)		{ m_fAIMM = fAIMM; }
	BOOL GetAIMM()					{ return m_fAIMM; }
	
	// Hangul Automata
    // void RegisterAutomata(CHangulAutomata *pHangulMachine) { m_pHangulMachine = pHangulMachine; }
	CHangulAutomata *GetAutomata();
	BOOL fGetK1HanjaOn();

	// Modebias
	TfGuidAtom GetModeBias() 				{ return m_guidMBias; }
    void SetModeBias(TfGuidAtom guidMBias) 	{ m_guidMBias = guidMBias; }

	BOOL GetfTransaction()			 { return m_fTransaction; }
	void SetfTransaction(BOOL ftran) { m_fTransaction = ftran; }

	// Mouse Sink
	void SetMouseSink(CMouseSink *pMouseSink) { m_pMouseSink = pMouseSink; }
	CMouseSink* GetMouseSink() 				  { return m_pMouseSink; }
	static HRESULT _MouseCallback(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten, void *pv);

    // IImePoint
    void RegisterIPoint(IImeIPoint1* pIP) { m_pIP = pIP; }
    IImeIPoint1* GetIPoint() { return m_pIP; }
	void InitializedIPoint(BOOL fInit)	{ m_fInitializedIPoint = fInit;	}
	BOOL IsInitializedIPoint()	{ return m_fInitializedIPoint; }
	
// Internal data
protected:
	BOOL m_fInitialized;
	// CKorIMX
	CKorIMX*  m_pimx;
	// Context
	ITfContext* m_pic;
	// Active composition
	ITfComposition* m_pActiveCompositon;
    // On/Off Compartment
    CCompartmentEventSink* m_pCompartmentSink;
	// AIMM
	BOOL m_fAIMM;
	// Hangul Automata object
	CHangulAutomata* m_rgpHangulAutomata[NUM_OF_IME_KL];

	// Shared memory for user setting.
	CIMEData* 	m_pCIMEData;

	// Modebias Atom
    TfGuidAtom m_guidMBias;

	DWORD m_dwCookieForTextEditSink;
	DWORD m_dwCookieForTransactionSink;

	// If in transaction
	BOOL m_fTransaction;

	// Mouse Sink
	CMouseSink *m_pMouseSink;

    // IImePoint for IME PAD
	IImeIPoint1 *m_pIP;
	BOOL m_fInitializedIPoint;
	
	// ref count
	LONG m_cRef;
};

//////////////////////////////////////////////////////////////////////////////
// Inline functions
inline
CHangulAutomata *CICPriv::GetAutomata()
{
	Assert(m_pCIMEData != NULL);
	if (m_pCIMEData && m_rgpHangulAutomata[m_pCIMEData->GetCurrentBeolsik()])
		return m_rgpHangulAutomata[m_pCIMEData->GetCurrentBeolsik()];
	else
		return NULL;
}

inline
BOOL CICPriv::fGetK1HanjaOn()
{
	if (m_pCIMEData && m_pCIMEData->GetKSC5657Hanja())
		return fTrue;
	else
		return fFalse;
}
#endif // __ICPRIV_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\hjmode.cpp ===
/****************************************************************************
   HJMODE.CPP : HJMode class managing Hanja button on the Cicero Toolbar

   History:
      25-FEB-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "hjmode.h"
#include "userex.h"
#include "editcb.h"
#include "immxutil.h"
#include "helpers.h"
#include "resource.h"

// {61F9F0AA-3D61-4077-B177-43E1422D8348}
const GUID GUID_LBI_KORIMX_HJMODE = 
{
    0x61f9f0aa, 
    0x3d61, 
    0x4077, 
    { 0xb1, 0x77, 0x43, 0xe1, 0x42, 0x2d, 0x83, 0x48 }
};

/*---------------------------------------------------------------------------
    HJMode::HJMode
---------------------------------------------------------------------------*/
HJMode::HJMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    // Set Add/Remove text and tootip text
    LoadStringExW(g_hInst, IDS_TT_HANJA_CONV, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_KorIMX, 
                GUID_LBI_KORIMX_HJMODE,
                TF_LBI_STYLE_BTN_BUTTON | TF_LBI_STYLE_TEXTCOLORICON, 
                120, 
                szText);
    SetToolTip(szText);

    // Set button text
    LoadStringExW(g_hInst, IDS_BUTTON_HANJA_CONV, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);
}


/*---------------------------------------------------------------------------
    HJMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) HJMode::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    HJMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI HJMode::GetIcon(HICON *phIcon)
{
    UINT uiIcon;
    
    if (IsHighContrastBlack())
        uiIcon = IDI_CMODE_HANJAW;
    else
        uiIcon = IDI_CMODE_HANJA;

    *phIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);

    return S_OK;
}

/*---------------------------------------------------------------------------
    HJMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI HJMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    HJMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI HJMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
    HJMode::OnLButtonUp
---------------------------------------------------------------------------*/
HRESULT HJMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    CEditSession2*    pes;
    ESSTRUCT         ess;
    ITfDocumentMgr* pdim;
    ITfContext*        pic;
    HRESULT           hr;

    ESStructInit(&ess, ESCB_HANJA_CONV);
    
    pdim = m_pTb->m_pimx->GetDIM();
    if (pdim == NULL)
        m_pTb->m_pimx->GetFocusDIM(&pdim);

    Assert(pdim != NULL);

    if (pdim == NULL)
        return S_FALSE;
        
    GetTopIC(pdim, &pic);
    
    Assert(pic != NULL);
    
    hr = E_OUTOFMEMORY;

    if (pic && (pes = new CEditSession2(pic, m_pTb->m_pimx, &ess, CKorIMX::_EditSessionCallback2)))
        {
         pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
        pes->Release();
        }

    SafeRelease(pic);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\immsec.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    immsec.c

Abstract:

    security code called by IMEs 

Author:

    Chae Seong Lim [cslim] 23-Dec-1997
    Takao Kitano [takaok] 01-May-1996

Revision History:
    Chae Seong Lim [cslim] 971223 Korean IME version
    Hiroaki Kanokogi [hiroakik] 960624  Modified for MSIME96
    Hiroaki Kanokogi [hiroakik] 960911  NT #11911

--*/

#include "private.h"

#define _USEINIME_
//#ifndef _USEINIME_    // .IME does not need
//#include <dbgmgr.h>
//#include <misc/memalloc.h>
//#endif // _USEINIME_
#include "immsec.h"
#include "osver.h"

#define MEMALLOC(x)      LocalAlloc(LMEM_FIXED, x)
#define MEMFREE(x)       LocalFree(x)

//
// internal functions
//
PSID MyCreateSid( DWORD dwSubAuthority );
#ifndef _USEINIME_
POSVERSIONINFO GetVersionInfo(VOID);
#endif // _USEINIME_

//
// debug functions
//
#ifdef DEBUG
#define ERROROUT(x)      ErrorOut( x )
#define WARNOUT(x)       WarnOut( x )
#else
#define ERROROUT(x) 
#define WARNOUT(x)       
#endif

#ifdef DEBUG
VOID WarnOut( PTSTR pStr )
{
    OutputDebugString( pStr );
}

VOID ErrorOut( PTSTR pStr )
{
    DWORD dwError;
    DWORD dwResult;
    static TCHAR buf1[512];
    static TCHAR buf2[512];

    dwError = GetLastError();
    dwResult = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwError,
                              MAKELANGID( LANG_ENGLISH, LANG_NEUTRAL ),
                              buf1,
                              512,
                              NULL );                                   
    
    if ( dwResult > 0 ) {
        wsprintfA(buf2, "%s:%s(0x%x)", pStr, buf1, dwError);
    } else {
        wsprintfA(buf2, "%s:(0x%x)", pStr, dwError);
    }
    OutputDebugString( buf2 );
}
#endif


//
// GetIMESecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeIMESecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//

static PSECURITY_ATTRIBUTES pSAIME = NULL;
//static PSECURITY_ATTRIBUTES pSAIME_UserDic = NULL;

PSECURITY_ATTRIBUTES GetIMESecurityAttributes(VOID)
{
    if (IsOnNT())
        return (pSAIME==NULL) ? (pSAIME=CreateSecurityAttributes()) : pSAIME;
    else
        return NULL;
}

#if NOT_USED
PSECURITY_ATTRIBUTES GetIMESecurityAttributesEx(VOID)
{
    if (IsOnNT())
        return (pSAIME_UserDic==NULL) ? (pSAIME_UserDic=CreateSecurityAttributesEx()) : pSAIME_UserDic;
    else
        return NULL;
}
#endif
//
// FreeIMESecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      GetIMESecurityAttributes() call.
//

VOID FreeIMESecurityAttributes()
{
    if (pSAIME!=NULL)
        FreeSecurityAttributes(pSAIME);
//    if (pSAIME_UserDic!=NULL)
//        FreeSecurityAttributes(pSAIME_UserDic);

    pSAIME = NULL;
//    pSAIME_UserDic = NULL;
}

//
// CreateSecurityAttributes()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access to the following users:
//      
//          o Users who log on for interactive operation
//          o The user account used by the operating system
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributes()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    DWORD                cbacl;

    PSID                 psid1, psid2;
    BOOL                 fResult;

    psid1 = MyCreateSid( SECURITY_INTERACTIVE_RID );
    if ( psid1 == NULL ) {
        return NULL;
    } 

    psid2 = MyCreateSid( SECURITY_LOCAL_SYSTEM_RID );
    if ( psid2 == NULL ) {
        FreeSid ( psid1 );
        return NULL;
    } 

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SIDs we've just created.
    //
    cbacl =  sizeof(ACL) + 
             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) * 2 + 
             GetLengthSid(psid1) + GetLengthSid(psid2);

    pacl = (PACL)MEMALLOC( cbacl );
    if ( pacl == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed") );
        FreeSid ( psid1 );
        FreeSid ( psid2 );
        return NULL;
    }

    fResult = InitializeAcl( pacl, cbacl, ACL_REVISION );
    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeAcl failed") );
        FreeSid ( psid1 );
        FreeSid ( psid2 );
        MEMFREE( pacl );
        return NULL;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid1 );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        MEMFREE( pacl );
        FreeSid ( psid1 );
        FreeSid ( psid2 );
        return NULL;
    }

    //
    // adds an access-allowed ACE for operating system to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid2 );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        MEMFREE( pacl );
        FreeSid ( psid1 );
        FreeSid ( psid2 );
        return NULL;
    }

    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid ( psid1 );
    FreeSid ( psid2 );

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidAcl returns fFalse!"));
        MEMFREE( pacl );
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC( sizeof( SECURITY_ATTRIBUTES ) );
    if ( psa == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psa failed") );
        MEMFREE( pacl );
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC( SECURITY_DESCRIPTOR_MIN_LENGTH );
    if ( psd == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psd failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        return NULL;
    }

    if ( ! InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION ) ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl( psd,
                                         TRUE,
                                         pacl,
                                         FALSE );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    } 

    if (!IsValidSecurityDescriptor(psd)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = FALSE;

    return psa;
}

PSID MyCreateSid( DWORD dwSubAuthority )
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid( &SidAuthority,
                                        1,
                                        dwSubAuthority,
                                        0,0,0,0,0,0,0,
                                        &psid );
    if ( ! fResult ) {
        ERROROUT( TEXT("MyCreateSid:AllocateAndInitializeSid failed") );
        return NULL;
    }

    if ( ! IsValidSid( psid ) ) {
        WARNOUT( TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid( psid );
        return NULL;
    }

    return psid;
}

//
// FreeSecurityAttributes()
//
// The purpose of this function:
//
//      Frees the memory objects allocated by previous
//      CreateSecurityAttributes() call.
//
VOID FreeSecurityAttributes( PSECURITY_ATTRIBUTES psa )
{
    BOOL fResult;
    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    PACL pacl;

    fResult = GetSecurityDescriptorDacl( psa->lpSecurityDescriptor,
                                         &fDaclPresent,
                                         &pacl,
                                         &fDaclDefaulted );                  
    if ( fResult ) {
        if ( pacl != NULL )
            MEMFREE( pacl );
    } else {
        ERROROUT( TEXT("FreeSecurityAttributes:GetSecurityDescriptorDacl failed") );
    }

    MEMFREE( psa->lpSecurityDescriptor );
    MEMFREE( psa );
}


#if NOT_USED
//
// Function Below is added to give GENERIC_ALL to everyone for UserDictionary
// which is accessed from network (not interactive).
// 960911 HiroakiK NT #11911
//

//
// CreateSecurityAttributesEx()
//
// The purpose of this function:
//
//      Allocate and set the security attributes that is 
//      appropriate for named objects created by an IME.
//      The security attributes will give GENERIC_ALL
//      access for everyone
//                 ^^^^^^^^
//
// Return value:
//
//      If the function succeeds, the return value is a 
//      pointer to SECURITY_ATTRIBUTES. If the function fails,
//      the return value is NULL. To get extended error 
//      information, call GetLastError().
//
// Remarks:
//
//      FreeSecurityAttributes() should be called to free up the
//      SECURITY_ATTRIBUTES allocated by this function.
//
PSECURITY_ATTRIBUTES CreateSecurityAttributesEx()
{
    PSECURITY_ATTRIBUTES psa;
    PSECURITY_DESCRIPTOR psd;
    PACL                 pacl;
    DWORD                cbacl;

    PSID                 psid;
    BOOL                 fResult;

    //
    // create a sid for everyone access
    //
    psid = MyCreateSidEx();
    if ( psid == NULL ) {
        return NULL;
    } 

    //
    // allocate and initialize an access control list (ACL) that will 
    // contain the SID we've just created.
    //
    cbacl =  sizeof(ACL) + 
             (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) + 
             GetLengthSid(psid);

    pacl = (PACL)MEMALLOC( cbacl );
    if ( pacl == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for ACL failed") );
        FreeSid ( psid );
        return NULL;
    }

    fResult = InitializeAcl( pacl, cbacl, ACL_REVISION );
    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeAcl failed") );
        FreeSid ( psid );
        MEMFREE( pacl );
        return NULL;
    }

    //
    // adds an access-allowed ACE for interactive users to the ACL
    // 
    fResult = AddAccessAllowedAce( pacl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   psid );

    if ( !fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:AddAccessAllowedAce failed") );
        MEMFREE( pacl );
        FreeSid ( psid );
        return NULL;
    }


    //
    // Those SIDs have been copied into the ACL. We don't need'em any more.
    //
    FreeSid ( psid );

    //
    // Let's make sure that our ACL is valid.
    //
    if (!IsValidAcl(pacl)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidAcl returns fFalse!"));
        MEMFREE( pacl );
        return NULL;
    }

    //
    // allocate security attribute
    //
    psa = (PSECURITY_ATTRIBUTES)MEMALLOC( sizeof( SECURITY_ATTRIBUTES ) );
    if ( psa == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psa failed") );
        MEMFREE( pacl );
        return NULL;
    }
    
    //
    // allocate and initialize a new security descriptor
    //
    psd = MEMALLOC( SECURITY_DESCRIPTOR_MIN_LENGTH );
    if ( psd == NULL ) {
        ERROROUT( TEXT("CreateSecurityAttributes:LocalAlloc for psd failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        return NULL;
    }

    if ( ! InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION ) ) {
        ERROROUT( TEXT("CreateSecurityAttributes:InitializeSecurityDescriptor failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }


    fResult = SetSecurityDescriptorDacl( psd,
                                         TRUE,
                                         pacl,
                                         FALSE );

    // The discretionary ACL is referenced by, not copied 
    // into, the security descriptor. We shouldn't free up ACL
    // after the SetSecurityDescriptorDacl call. 

    if ( ! fResult ) {
        ERROROUT( TEXT("CreateSecurityAttributes:SetSecurityDescriptorDacl failed") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    } 


    if (!IsValidSecurityDescriptor(psd)) {
        WARNOUT( TEXT("CreateSecurityAttributes:IsValidSecurityDescriptor failed!") );
        MEMFREE( pacl );
        MEMFREE( psa );
        MEMFREE( psd );
        return NULL;
    }

    //
    // everything is done
    //
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->lpSecurityDescriptor = (PVOID)psd;
    psa->bInheritHandle = FALSE;

    return psa;
}

PSID MyCreateSidEx(VOID)
{
    PSID        psid;
    BOOL        fResult;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // allocate and initialize an SID
    // 
    fResult = AllocateAndInitializeSid( &SidAuthority,
                                        1,
                                        SECURITY_WORLD_RID,
                                        0,0,0,0,0,0,0,
                                        &psid );
    if ( ! fResult ) {
        ERROROUT( TEXT("MyCreateSid:AllocateAndInitializeSid failed") );
        return NULL;
    }

    if ( ! IsValidSid( psid ) ) {
        WARNOUT( TEXT("MyCreateSid:AllocateAndInitializeSid returns bogus sid"));
        FreeSid( psid );
        return NULL;
    }

    return psid;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\init.h ===
//
// init.h
//

#ifndef INIT_H
#define INIT_H

#include "private.h"

BOOL DllInit(void);
void DllUninit(void);

#endif // INIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\kimxatl.h ===
#ifndef _KIMXATL_H_
#define _KIMXATL_H_

#define _ATL_FREE_THREADED
#define _ATL_STATIC_REGISTRY
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "atlsub.h"

#endif //_KIMXATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\ipointcic.h ===
/****************************************************************************
	IPOINT.H

	Owner: cslim
	Copyright (c) 1997-1999 Microsoft Corporation

	IImeIPoint1 interface
	
	History:
	20-JUL-1999 cslim       Created
*****************************************************************************/

#if !defined(_IPOINT_H__INCLUDED_)
#define _IPOINT_H__INCLUDED_

class CKorIMX;

class CIPointCic : public IImeIPoint1
{
// Ctor and Dtor
public:
	CIPointCic(CKorIMX *pImx);
	~CIPointCic();

// IImePoint1 Methods
public:
	STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID * ppvObj);
	STDMETHODIMP_(ULONG) AddRef(VOID);
	STDMETHODIMP_(ULONG) Release(VOID);
	
	STDMETHODIMP InsertImeItem		(IPCANDIDATE* pImeItem, INT iPos, DWORD *lpdwCharId);
	STDMETHODIMP ReplaceImeItem		(INT iPos, INT iTargetLen, IPCANDIDATE* pImeItem, DWORD *lpdwCharId);
	STDMETHODIMP InsertStringEx		(WCHAR* pwSzInsert, INT cchSzInsert, DWORD *lpdwCharId);
	STDMETHODIMP DeleteCompString	(INT	iPos, INT cchSzDel);
	STDMETHODIMP ReplaceCompString	(INT	iPos,
									 INT	iTargetLen, 
									 WCHAR	*pwSzInsert, 
									 INT	cchSzInsert,
									 DWORD	*lpdwCharId);
	STDMETHODIMP ControlIME			(DWORD dwIMEFuncID, LPARAM lpara);
	STDMETHODIMP GetAllCompositionInfo(WCHAR	**ppwSzCompStr,
										DWORD	**ppdwCharID,
										INT		*pcchCompStr,
										INT		*piIPPos,
										INT		*piStartUndetStrPos,
										INT		*pcchUndetStr,
										INT		*piEditStart,
										INT		*piEditLen);
	STDMETHODIMP GetIpCandidate		(DWORD dwCharId,
										IPCANDIDATE **ppImeItem,
										INT *piColumn,
										INT *piCount);
	STDMETHODIMP SelectIpCandidate	(DWORD dwCharId, INT iselno);
	STDMETHODIMP UpdateContext		(BOOL fGenerateMessage);

// Helper functions
public:
	HRESULT Initialize(ITfContext *pic);

// Internal data
protected:
	CKorIMX    *m_pImx;
    ITfContext *m_pic;
	ULONG		m_cRef;			// Ref count

	// char serial number
	DWORD		m_dwCharNo;
};
typedef CIPointCic* LPCIPointCic;

#endif // _IPOINT_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\init.cpp ===
//
// init.cpp
//

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "osver.h"

DECLARE_OSVER();


//+---------------------------------------------------------------------------
//
// DllInit
//
// Called on our first CoCreate.  Use this function to do initialization that
// would be unsafe during process attach, like anything requiring a LoadLibrary.
//
//----------------------------------------------------------------------------
BOOL DllInit(void)
{
    BOOL fRet = TRUE;

    EnterCriticalSection(&g_cs);

    if (g_cRefDll != 1)
        goto Exit;
        
    fRet = TFInitLib();

    InitOSVer();    

Exit:
    LeaveCriticalSection(&g_cs);

    return fRet;
}

//+---------------------------------------------------------------------------
//
// DllUninit
//
// Called after the dll ref count drops to zero.  Use this function to do
// uninitialization that would be unsafe during process deattach, like
// FreeLibrary calls.
//
//----------------------------------------------------------------------------

void DllUninit(void)
{
    EnterCriticalSection(&g_cs);

    if (g_cRefDll != 0)
        goto Exit;
        
    TFUninitLib();

Exit:
    LeaveCriticalSection(&g_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\korimx.cpp ===
/****************************************************************************
   KORIMX.CPP : CKorIMX class implementation(TIP Main functions)

   History:
      15-NOV-1999 CSLim Created
****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "hanja.h"
#include "globals.h"
#include "immxutil.h"
#include "proputil.h"
#include "kes.h"
#include "helpers.h"
#include "editcb.h"
#include "timsink.h"
#include "icpriv.h"
#include "funcprv.h"
#include "fnrecon.h"
#include "dispattr.h"
#include "insert.h"
#include "statsink.h"
#include "mes.h"
#include "config.h"
#include "osver.h"

/*---------------------------------------------------------------------------
    CKorIMX::CKorIMX
    
    Ctor
---------------------------------------------------------------------------*/
CKorIMX::CKorIMX()
{
    extern void DllAddRef(void);

    // Init member vars
    m_pToolBar = NULL;
    m_pPadCore = NULL;
    
    m_pCurrentDim = NULL;
    m_ptim = NULL;
    m_tid = 0;
    m_ptimEventSink = NULL;
    m_pkes = NULL;
    
    m_hOwnerWnd  = 0;
    m_fKeyFocus  = fFalse;

    m_fPendingCleanup = fFalse;
    m_pFuncPrv        = NULL;
    m_pInsertHelper   = NULL;
    
    // Init Cand UI member vars
    m_pCandUI = NULL;
    m_fCandUIOpen = fFalse;

    // SoftKbd
    m_psftkbdwndes = NULL;
    m_pSoftKbd = NULL;
    m_fSoftKbdEnabled = fFalse;

    ZeroMemory(&m_libTLS, sizeof(m_libTLS));

    // Korean Kbd driver does not exist in system(Non Korean NT4, Non Korean WIN9X)
    m_fNoKorKbd = fFalse;

    m_fSoftKbdOnOffSave = fFalse;
    
    // Increase dll ref count
    DllAddRef();
    m_cRef = 1;
    
    ///////////////////////////////////////////////////////////////////////////
    // init CDisplayAttributeProvider
    //
    // Tip can add one or more TF_DISPLAYATTRIBUTE info here.
    //
    TF_DISPLAYATTRIBUTE dattr;
    wcscpy(szProviderName, L"Korean Keyboard TIP");
    
    // Input string attr
       dattr.crText.type = TF_CT_NONE;
    dattr.crText.nIndex = 0;
    dattr.crBk.type = TF_CT_NONE;
    dattr.crBk.nIndex = 0;
    dattr.lsStyle = TF_LS_NONE;
    dattr.fBoldLine = fFalse;
    ClearAttributeColor(&dattr.crLine);
    dattr.bAttr = TF_ATTR_INPUT;
    Add(GUID_ATTR_KORIMX_INPUT, L"Korean TIP Input String", &dattr);
}

/*---------------------------------------------------------------------------
    CKorIMX::~CKorIMX
    
    Dtor
---------------------------------------------------------------------------*/
CKorIMX::~CKorIMX()
{
    extern void DllRelease(void);

    if (IsSoftKbdEnabled())
        TerminateSoftKbd();

    DllRelease();
}


/*---------------------------------------------------------------------------
    CKorIMX::CreateInstance
    
    Class Factory's CreateInstance
---------------------------------------------------------------------------*/
/* static */
HRESULT CKorIMX::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    HRESULT hr;
    CKorIMX *pimx;

    TraceMsg(DM_TRACE, TEXT("CKorIMX_CreateInstance called."));

    *ppvObj = NULL;

    if (NULL != pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pimx = new CKorIMX;

    if (pimx == NULL)
        return E_OUTOFMEMORY;

    hr = pimx->QueryInterface(riid, ppvObj);
    pimx->Release();

    return hr;
}

/*---------------------------------------------------------------------------
    CKorIMX::QueryInterface
---------------------------------------------------------------------------*/
STDAPI CKorIMX::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextInputProcessor))
        {
        *ppvObj = SAFECAST(this, ITfTextInputProcessor *);
        }
    else if (IsEqualIID(riid, IID_ITfDisplayAttributeProvider))
        {
        *ppvObj = SAFECAST(this, ITfDisplayAttributeProvider *);
        }
    else if (IsEqualIID(riid, IID_ITfThreadFocusSink))
        {
        *ppvObj = SAFECAST(this, ITfThreadFocusSink *);
        }
    else if(IsEqualIID(riid, IID_ITfFnConfigure))
        {
        *ppvObj = SAFECAST(this, ITfFnConfigure *);
        }
    else if(IsEqualIID(riid, IID_ITfCleanupContextSink))
        {
        *ppvObj = SAFECAST(this, ITfCleanupContextSink *);
        }
    else if(IsEqualIID(riid, IID_ITfActiveLanguageProfileNotifySink))
        {
        *ppvObj = SAFECAST(this, ITfActiveLanguageProfileNotifySink *);
        }
    else if(IsEqualIID(riid, IID_ITfTextEditSink))
        {
        *ppvObj = SAFECAST(this, ITfTextEditSink *);
        }
    else if( IsEqualIID(riid, IID_ITfEditTransactionSink ))
        {
		*ppvObj = SAFECAST(this, ITfEditTransactionSink* );
        }
    
    if (*ppvObj == NULL)
        {
        return E_NOINTERFACE;
        }

    AddRef();
    return S_OK;
}

/*---------------------------------------------------------------------------
    CKorIMX::AddRef
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CKorIMX::AddRef()
{
    m_cRef++;
    return m_cRef;
}

/*---------------------------------------------------------------------------
    CKorIMX::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CKorIMX::Release()
{
    m_cRef--;

    if (0 < m_cRef)
        return m_cRef;

    delete this;
    return 0;    
}

/*---------------------------------------------------------------------------
    CKorIMX::_KeyEventCallback
    
    ITfKeyEventSink call this function back whenever keyboard event occurs
    or test key down and up.
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_KeyEventCallback(UINT uCode, ITfContext *pic, 
                                   WPARAM wParam, LPARAM lParam, BOOL *pfEaten, void *pv)
{
    CKorIMX             *pimx;
    CEditSession2         *pes;
    ESSTRUCT             ess;
    BYTE                 abKeyState[256];
    UINT                 uVKey = (UINT)LOWORD(wParam);
    HRESULT             hr;

    Assert(pv != NULL);
    
    pimx = (CKorIMX *)pv;

    // !!! IME or Tip switched !!!
    // if ITfKeyEventSink->OnSetFocus called
    if (uCode == KES_CODE_FOCUS)
        {
        // wParam: fForeground
        if (!wParam && pic && pimx->GetIPComposition(pic))
            {
            ESStructInit(&ess, ESCB_COMPLETE);

            // clear display attribute only if current composition exits
            if (pes = new CEditSession2(pic, pimx, &ess, CKorIMX::_EditSessionCallback2))
                {
                pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
                pes->Release();
                }
                
            pimx->m_pToolBar->Update(UPDTTB_ALL);
            }

        pimx->m_fKeyFocus = (BOOL)wParam;

        return S_OK;
        }

    // Set default return values
    *pfEaten = fFalse;     // Default is not eaten
    hr = S_OK;

    if (pic == NULL)
        goto ExitKesCallback;

    // Do not process shift and ctrl key
    if (uVKey == VK_SHIFT || uVKey == VK_CONTROL)
        goto ExitKesCallback;

    // Off 10 #127987
    // NT4 workaround: NT4 IMM does not send WM_KEYDOWN::VK_HANGUL to application message queue.
    // Unfortunately VK_JUNJA sent as WM_SYSKEYDOWN/UP, so it's useless check here.
    if (IsOnNT() && !IsOnNT5())
        {
        if ((UINT)LOWORD(wParam) == VK_HANGUL /* || (UINT)LOWORD(wParam) == VK_JUNJA*/)
            goto AcceptThisKey;
        }

    // Ignore all Key up message
    if ((uCode & KES_CODE_KEYDOWN) == 0)
        goto ExitKesCallback;

AcceptThisKey:
    GetKeyboardState(abKeyState);
    
    // Ignore all key events while candidate UI is opening except cand keys.
    // Added Alt check: Bug #525842 - If Alt key pressed, always complete current interim.
    //                                This will be handled in the _IsKeyEaten function.
    if (pimx->IsDisabledIC(pic) && !IsAltKeyPushed(abKeyState))
        {
        if (!IsCandKey(wParam, abKeyState))
            *pfEaten = fTrue;
        goto ExitKesCallback;
        }

    // Check if we need to handle this key
    if (pimx->_IsKeyEaten(pic, pimx, wParam, lParam, abKeyState) == fFalse)
        goto ExitKesCallback;

    // if key is eaten
    // ITfKeyEventSink->TestKeyDown sets (KES_CODE_KEYDOWN | KES_CODE_TEST)
    // ITfKeyEventSink->TestKeyUp   sets (KES_CODE_KEYUP   | KES_CODE_TEST)
    // Response only for OnKeyDown and OnKeyUp
    if ((uCode & KES_CODE_TEST) == 0)
        {
        ESStructInit(&ess, ESCB_KEYSTROKE);

        ess.wParam = wParam;
        ess.lParam = lParam;
        ess.pv1 = abKeyState;
            
        if (pes = new CEditSession2(pic, pimx, &ess, CKorIMX::_EditSessionCallback2))
            {
            pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
            pes->Release();
            }
        }

    if (hr == S_OK)
        *pfEaten = fTrue;

ExitKesCallback:
    return hr;
}

/*---------------------------------------------------------------------------
    CKorIMX::GetIC
    
    Get the input context at the top of the stack
---------------------------------------------------------------------------*/
ITfContext *CKorIMX::GetIC()
{
    ITfContext     *pic = NULL;
    ITfDocumentMgr *pdim = NULL;

    if (m_ptim == 0)
        {
        Assert(0);
        return NULL;
        }
        
    if (SUCCEEDED(m_ptim->GetFocus(&pdim)) && pdim)
        {
        pdim->GetTop(&pic);
        pdim->Release();
        }

    return pic;
}


/*---------------------------------------------------------------------------
    CKorIMX::SetConvMode
---------------------------------------------------------------------------*/
DWORD CKorIMX::SetConvMode(ITfContext *pic, DWORD dwConvMode)
{
    DWORD dwCurConvMode = GetConvMode(pic);

    if (dwConvMode == dwCurConvMode)
        return dwConvMode;
        
    SetCompartmentDWORD(m_tid, GetTIM(), GUID_COMPARTMENT_KORIMX_CONVMODE, dwConvMode, fFalse);
    
    // if Comp string exist, finalize it.
    if (GetIPComposition(pic))
        {
        CEditSession2 *pes;
        ESSTRUCT        ess;
        HRESULT        hr;

        hr = E_OUTOFMEMORY;

        ESStructInit(&ess, ESCB_COMPLETE);

        if (pes = new CEditSession2(pic, this, &ess, CKorIMX::_EditSessionCallback2))
            {
            // Word will not allow synchronous lock at this point.
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        }

    return dwConvMode;
}

/*---------------------------------------------------------------------------
    CKorIMX::_IsKeyEaten
    
    Return fTrue if this key need to be eaten
---------------------------------------------------------------------------*/
BOOL CKorIMX::_IsKeyEaten(ITfContext *pic, CKorIMX *pimx, WPARAM wParam, LPARAM lParam, const BYTE abKeyState[256])
{
    CHangulAutomata    *pAutomata;
    BOOL fCompStr     = fFalse;
    UINT uVKey         = (UINT)LOWORD(wParam);
    CEditSession2     *pes;
    ESSTRUCT         ess;

    // Hangul and Junja key
    if (uVKey == VK_HANGUL || uVKey == VK_JUNJA)
        return fTrue;

    // Hanja key
    if (uVKey == VK_HANJA)
        {
        CICPriv *picp;
        
        if ((picp = GetInputContextPriv(pic)) == NULL)
            {
            Assert(0);
            return fTrue;
            }

        // Do not eat VK_HANJA for AIMM 1.2 IME_HANJAMODE .
        if (picp->GetAIMM() && GetIPComposition(pic) == NULL)
            return fFalse;
        else
            return fTrue;
        }
    
    // if Tip is off do nothing
    if (IsOn(pic) == fFalse || GetConvMode(pic) == TIP_ALPHANUMERIC_MODE)
        return fFalse;

    // Should handle Backspace in interim state
    if (uVKey == VK_BACK)
        {
        if (GetIPComposition(pic))
            return fTrue;
        else
            return fFalse;
        }

    // Get Hangul Automata
    if ((pAutomata = GetAutomata(pic)) == NULL)
        return fFalse;

    // Alt+xx or Ctrl+xx processing. TIP should not eat.
    // Ctrl or Alt pushed with other key and comp str exist we should eat and complete the comp str.
    if (IsAltKeyPushed(abKeyState) || IsControlKeyPushed(abKeyState))
        {
        pAutomata->MakeComplete();
        }
    else
        {
        DWORD dwConvMode = GetConvMode(pic);

        // If Hangul mode
        if (dwConvMode & TIP_HANGUL_MODE) 
            {    // Start of hangul composition
            WORD     wcCur;
            CIMEData ImeData;

            wcCur = pAutomata->GetKeyMap(uVKey, IsShiftKeyPushed(abKeyState) ? 1 : 0 );
            // 2beolsik Alphanumeric keys have same layout as English key
            // So we don't need process when user pressed Alphanumeric key under 2beolsik
            if ((wcCur && ImeData.GetCurrentBeolsik() != KL_2BEOLSIK) || (wcCur & H_HANGUL) )
                return fTrue;
            }

        // if IME_CMODE_FULLSHAPE
        if (dwConvMode & TIP_JUNJA_MODE) 
            {
            if (CHangulAutomata::GetEnglishKeyMap(uVKey, IsShiftKeyPushed(abKeyState) ? 1 : 0))
                return fTrue;
            }        
        }

    //
    // Skipped all key matching condition mean this is no handle key.
    // We just complete current composition if exist.
    //
    if (GetIPComposition(pic) != NULL)
        {
        // No need to handle this key for current Automata.
        // Complete composition, if exist.
        ESStructInit(&ess, ESCB_COMPLETE);
        HRESULT hr;
        
           // Complete current comp char if exist
        if ((pes = new CEditSession2(pic, pimx, &ess, CKorIMX::_EditSessionCallback2)) == NULL)
            return fFalse;

        pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
        pes->Release();
        }

    return fFalse;
}


/*----------------------------------------------------------------------------
    Banja2Junja

    Convert Ascii Half shape to Full shape character
----------------------------------------------------------------------------*/
/* static */
WCHAR CKorIMX::Banja2Junja(WCHAR bChar) 
{
    WCHAR wcJunja;

    if (bChar == L' ')
        wcJunja = 0x3000;    // FullWidth space
    else 
        if (bChar == L'~')
            wcJunja = 0xFF5E;
        else
            if (bChar == L'\\')
                wcJunja = 0xFFE6;   // FullWidth WON sign
            else
                   wcJunja = 0xFF00 + (WORD)(bChar - (BYTE)0x20);

    return wcJunja;
}

/*---------------------------------------------------------------------------
    CKorIMX::_Keystroke
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_Keystroke(TfEditCookie ec, ITfContext *pic, WPARAM wParam, LPARAM lParam, 
                        const BYTE abKeyState[256])
{
    ITfRange *pSelection = NULL;
    WORD  wVKey = LOWORD(wParam) & 0x00FF;
    DWORD dwConvMode;
    HRESULT hResult = S_OK;
    
    // find the extent of the comp string
    if (GetSelectionSimple(ec, pic, &pSelection) != S_OK)
        {
        hResult = S_FALSE;
        goto Exit;
        }

    dwConvMode = GetConvMode(pic);
    
    switch (wVKey)
        {
    case VK_HANGUL:
        dwConvMode ^= TIP_HANGUL_MODE;
        SetConvMode(pic, dwConvMode);
        break;
        
    case VK_JUNJA:
        dwConvMode ^= TIP_JUNJA_MODE;
        SetConvMode(pic, dwConvMode);
        break;

    case VK_HANJA:
        if (GetIPComposition(pic))
            DoHanjaConversion(ec, pic, pSelection);
        else
            Reconvert(pSelection);
        // Update Hanja button
        m_pToolBar->Update(UPDTTB_HJMODE);
        break;
        
    default:
        ///////////////////////////////////////////////////////////////////////////
        // Run Hangul Automata
        if (dwConvMode & TIP_HANGUL_MODE)
            {
            HAutoMata(ec, pic, pSelection, (LPBYTE)abKeyState, wVKey);
            }
        else
        if (dwConvMode & TIP_JUNJA_MODE) // Junja handling
            {
            WCHAR pwchKeyCode[2];

            // Numeric or English key?
            if (pwchKeyCode[0] = CHangulAutomata::GetEnglishKeyMap(wVKey, (abKeyState[VK_SHIFT] & 0x80) ? 1:0))
                {
                if (wVKey >= 'A' && wVKey <= 'Z') 
                    {
                    pwchKeyCode[0] = CHangulAutomata::GetEnglishKeyMap(wVKey, (abKeyState[VK_SHIFT] & 0x80) ? 1:0 ^ ((abKeyState[VK_CAPITAL] & 0x01) ? 1:0));
                    }

                // Get Junja code
                pwchKeyCode[0] = Banja2Junja(pwchKeyCode[0]);
                pwchKeyCode[1] = L'\0';

                // Finalize a Junja char
                if (SUCCEEDED(SetInputString(ec, pic, pSelection, pwchKeyCode, GetLangID())))
                    MakeResultString(ec, pic, pSelection);
                }
            }
        break;        
        }

Exit:
    if (pSelection)
        pSelection->Release();

    return hResult;
}


/*---------------------------------------------------------------------------
    CKorIMX::HAutoMata
    
    Run Hangul Automata
---------------------------------------------------------------------------*/
void CKorIMX::HAutoMata(TfEditCookie ec, ITfContext    *pic, ITfRange *pIRange, 
                         LPBYTE lpbKeyState, WORD wVKey)
{
    WORD              wcCur;
    ULONG              cch;
    LPWSTR           pwstr;
    CHangulAutomata    *pAutomata;
    WCHAR            pwchText[256];

    if ((pAutomata = GetAutomata(pic)) == NULL)
        return;
    
    cch = ARRAYSIZE(pwchText);
    pIRange->GetText(ec, 0, pwchText, ARRAYSIZE(pwchText) - 1, &cch);

    pwstr = pwchText;

    switch (wVKey) 
        {
    ///////////////////////////////////////////////////////////
    // Back space processing
    case VK_BACK :
        if (pAutomata->BackSpace()) 
            {
            CIMEData ImeData;

            if (ImeData.GetJasoDel()) 
                {
                *pwstr++ = pAutomata->GetCompositionChar();
                *pwstr = L'\0';
                SetInputString(ec, pic, pIRange, pwchText, GetLangID());
                }
            else
                {
                pAutomata->InitState();
                *pwstr = L'\0';
                SetInputString(ec, pic, pIRange, pwchText, GetLangID());
                }

            // All composition deleted.
            if (pAutomata->GetCompositionChar() == 0)
                {
                EndIPComposition(ec, pic); 

                // Collapse current selection to end and reset block cursor
                pIRange->Collapse(ec, TF_ANCHOR_END);
                SetSelectionSimple(ec, pic, pIRange);
                }
            }
        else 
            {
            // BUG : impossible
            Assert(0);
            }
        break;

    default :
        WCHAR wchPrev = pAutomata->GetCompositionChar();
        switch (pAutomata->Machine(wVKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 ) ) 
            {
        case HAUTO_COMPOSITION:
            // 
            pwchText[0] = pAutomata->GetCompositionChar();
            pwchText[1] = L'\0';

            SetInputString(ec, pic, pIRange, pwchText, GetLangID());
            break;

        case HAUTO_COMPLETE:
            pwchText[0] = pAutomata->GetCompleteChar();
            pwchText[1] = L'\0';
            if (FAILED(SetInputString(ec, pic, pIRange, pwchText, GetLangID())))
                break;

            MakeResultString(ec, pic, pIRange);
            //
            pwchText[0] = pAutomata->GetCompositionChar();
            pwchText[1] = L'\0';
            SetInputString(ec, pic, pIRange, pwchText, GetLangID());
            break;

        ////////////////////////////////////////////////////////
        // User pressed Alphanumeric key.
        // When user type alphanumeric char in interim state.
        // ImeProcessKey should guarantee return fTrue only if 
        // hangul key pressed or alphanumeric key(including special keys) 
        // pressed in interim state or Fullshape mode.
        case HAUTO_NONHANGULKEY:
            wcCur = pAutomata->GetKeyMap(wVKey, IsShiftKeyPushed(lpbKeyState) ? 1 : 0 );

            if (GetConvMode(pic) & TIP_JUNJA_MODE)
                wcCur = Banja2Junja(wcCur);

            if (pAutomata->GetCompositionChar())
                {
                pAutomata->MakeComplete();
                MakeResultString(ec, pic, pIRange);
                }

            if (wcCur)
                {
                pwchText[0] = wcCur;
                pwchText[1] = 0;

                if (SUCCEEDED(SetInputString(ec, pic, pIRange, pwchText, GetLangID())))
                    MakeResultString(ec, pic, pIRange);
                }
            break;

        default :
        Assert(0);
            } // switch (pInstData->pMachine->Machine(uVirKey, (lpbKeyState[VK_SHIFT] & 0x80) ? 1 : 0 ) ) 
        } // switch (uVirKey) 

}


/*---------------------------------------------------------------------------
    CKorIMX::DoHanjaConversion
---------------------------------------------------------------------------*/
HRESULT CKorIMX::DoHanjaConversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    ULONG cch;
    CCandidateListEx *pCandList;
    WCHAR pwchText[256];

    Assert(pic != NULL);
    Assert(pRange != NULL);

    cch = ARRAYSIZE(pwchText);
    pRange->GetText(ec, 0, pwchText, ARRAYSIZE(pwchText) - 1, &cch);
    // REVIEW: Assume composition string is one char
    Assert(cch == 1);
    pwchText[1] = 0;

    if ((pCandList = CreateCandidateList(pic, pRange, pwchText)) == NULL)
        return E_FAIL;

    OpenCandidateUI(ec, pic, pRange, pCandList);
    pCandList->Release();
        
    return S_OK;
}

/*---------------------------------------------------------------------------
    CKorIMX::Reconvert
---------------------------------------------------------------------------*/
HRESULT CKorIMX::Reconvert(ITfRange *pSelection)
{
    ITfFnReconversion *pReconv = NULL;
    ITfRange           *pRangeReconv = NULL;

    BOOL fConvertable;
    
    if (FAILED(GetFunctionProvider()->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)&pReconv)))
        return E_FAIL;

    if (pReconv->QueryRange(pSelection, &pRangeReconv, &fConvertable) != S_OK)
        goto Exit;

    if (fConvertable)
        pReconv->Reconvert(pRangeReconv);

Exit:
    SafeRelease(pReconv);
    return S_OK;
}

// REVIEW
/*---------------------------------------------------------------------------
    CKorIMX::SetInputString
---------------------------------------------------------------------------*/
HRESULT CKorIMX::SetInputString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, 
                                WCHAR *psz, LANGID langid)
{
    GUID              attr;
       ITfComposition     *pComposition;
       ITfRange         *ppCompRange = NULL;
       LONG             cch;
//    BOOL              fInsertOK;

    cch = wcslen(psz);
    pComposition = GetIPComposition(pic);

    // If start composition
    if (pComposition == NULL)
        {
        // if new selection, Set overtype.
        Assert(m_pInsertHelper != NULL);
        if (m_pInsertHelper)
            {
            HRESULT hr;
            CHangulAutomata    *pAutomata;

            hr = m_pInsertHelper->InsertAtSelection(ec, pic, psz, cch, &ppCompRange);
            if (FAILED(hr))
                {
                if ((pAutomata = GetAutomata(pic)) != NULL)
                    pAutomata->InitState();
                return hr;
                }
            
            /* InsertOK = (pRange != NULL);*/
            if (ppCompRange == NULL)
                {
                Assert(0);
                return S_FALSE;
                }
            cch = -1; // flag to avoid a SetText call below
            pRange = ppCompRange;
            }

        CreateIPComposition(ec, pic, pRange);
        }

    // Set Korean input property
    attr = GUID_ATTR_KORIMX_INPUT;
    // Use MySetText instead of SetTextAndProperty
    // if cch == -1, set only attribute
    MySetText(ec, pic, pRange, psz , cch, langid, &attr);
    
    // Always call SetSelection for block cursor
    SetSelectionBlock(ec, pic, pRange);

    SafeRelease(ppCompRange);

    return S_OK;
}

// REVIEW
/*---------------------------------------------------------------------------
    CKorIMX::MakeResultString
---------------------------------------------------------------------------*/
HRESULT CKorIMX::MakeResultString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    ITfRange    *pRangeTmp;
    ITfProperty *pPropAttr;
#if 0
    ITfProperty *pProp;
#endif
    TfGuidAtom   attr;

    // Clone Range
    pRange->Clone(&pRangeTmp);

    // Collapse current selection to end and reset block cursor
    pRange->Collapse(ec, TF_ANCHOR_END);
    SetSelectionSimple(ec, pic, pRange);

#if 0
    // Flush IP Range
    FlushIPRange(ec, pic);
#endif

    if (SUCCEEDED(pic->GetProperty(GUID_PROP_ATTRIBUTE, &pPropAttr)))
        {
        if (SUCCEEDED(GetAttrPropertyData(ec, pPropAttr, pRangeTmp, &attr)))
            {
            if (IsKorIMX_GUID_ATOM(attr))
                {
                pPropAttr->Clear(ec, pRangeTmp);
                }
            }
        pPropAttr->Release();

#if 1
        EndIPComposition(ec, pic); 
#else
        // clear the composition property
        if (SUCCEEDED(pic->GetProperty(GUID_PROP_COMPOSING, &pProp)))
            {
            pProp->Clear(ec, pRangeTmp);
            pProp->Release();
            }
#endif
        // clear any overtype
        if (m_pInsertHelper != NULL)
            {
            m_pInsertHelper->ReleaseBlobs(ec, pic, NULL);
            }
        }

    pRangeTmp->Release();

    return S_OK;
}

#if 0
/*---------------------------------------------------------------------------
    CKorIMX::_MultiRangeConversion
---------------------------------------------------------------------------*/
HRESULT CKorIMX::_MultiRangeConversion(TfEditCookie ec, UINT_PTR u, ITfContext *pic, ITfRange *pRange)
{
    IEnumTfRanges *pEnumTrack = NULL;
    ITfReadOnlyProperty *pProp = NULL;
    ITfRange *pPropRange = NULL;
    HRESULT hr = E_FAIL;

    if (FAILED(EnumTrackTextAndFocus(ec, pic, pRange, &pProp, &pEnumTrack)))
        goto Exit;

    while(pEnumTrack->Next(1, &pPropRange,  0) == S_OK)
        {
        ITfRange *pRangeTmp = NULL;

        if (!IsOwnerAndFocus(ec, CLSID_KorIMX, pProp, pPropRange))
            goto Next;

        if (FAILED(pPropRange->Clone(&pRangeTmp)))
            goto Next;

        switch (u)
            {
        case ESCB_COMPLETE:
            MakeResultString(ec, pic, pRangeTmp);
            break;
            }
        SafeRelease(pRangeTmp);
    Next:
        SafeRelease(pPropRange);
        }


Exit:
    SafeRelease(pEnumTrack);
    SafeRelease(pProp);
    
    return hr;
}
#endif

/*---------------------------------------------------------------------------
    CKorIMX::_OwnerWndProc
---------------------------------------------------------------------------*/
LRESULT CALLBACK CKorIMX::_OwnerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
#if 0
    switch (uMsg)
        {
    case WM_CREATE:
        SetThis(hWnd, lParam);
        return 0;

    case (WM_USER+WM_COMMAND):    // local commands
        return GetThis(hWnd)->OnCommand((UINT)wParam, lParam);

    case WM_DRAWITEM: 
        {
        CKorIMX* pThis = GetThis(hWnd);
        if( pThis )
            return pThis->OnDrawItem( wParam, lParam );
        break;
        }
        
    case WM_MEASUREITEM: 
        {
        CKBDTip* pThis = GetThis(hWnd);
        if( pThis )
            return pThis->OnMeasureItem( wParam, lParam );
        break;
        }
        }
#endif

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
// GetDisplayName
//
//----------------------------------------------------------------------------

STDAPI CKorIMX::GetDisplayName(BSTR *pbstrName)
{
    *pbstrName = SysAllocString(L"Korean Keyboard TIP Configure");
    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Show
//
//----------------------------------------------------------------------------

STDAPI CKorIMX::Show(HWND hwnd, LANGID langid, REFGUID rguidProfile)
{
    if (ConfigDLG(hwnd))
        return S_OK;
    else
        return E_FAIL;
}

/*---------------------------------------------------------------------------
    CKorIMX::GetAIMM
---------------------------------------------------------------------------*/
BOOL CKorIMX::GetAIMM(ITfContext *pic)
{
       CICPriv*        picp;

    if ((picp = GetInputContextPriv(pic)) == NULL)
        {
        Assert(0);
        return fFalse;
        }

    // AIMM?
    return picp->GetAIMM();
}


/*---------------------------------------------------------------------------
    CKorIMX::MySetText
---------------------------------------------------------------------------*/
BOOL CKorIMX::MySetText(TfEditCookie ec, ITfContext *pic, ITfRange *pRange,
                        const WCHAR *psz, LONG cchText, LANGID langid, GUID *pattr)
{
    // bugbug: sometimes we want to set TFST_CORRECTION
    if (cchText != -1) // sometimes we just want to set a property value
        pRange->SetText(ec, 0, psz, cchText);

    if (cchText != 0)
        {
        HRESULT hr;
        ITfProperty *pProp = NULL;

        // set langid 
        if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_LANGID, &pProp)))
            {
            SetLangIdPropertyData(ec, pProp, pRange, langid);
            pProp->Release();
            }
  
        if (pattr)
            {
            // set attr 
            if (SUCCEEDED(hr = pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp)))
                {
                hr = SetAttrPropertyData(&m_libTLS, ec, pProp, pRange, *pattr);
                pProp->Release();
                }
            }
        }

    return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\korimx.h ===
//
//   KORIMX.H : CKorIMX class declaration
//
//   History:
//      15-NOV-1999 CSLim Created

#if !defined (__KORIMX_H__INCLUDED_)
#define __KORIMX_H__INCLUDED_

#include "globals.h"
#include "proputil.h"
#include "computil.h"
#include "dap.h"
#include "tes.h"
#include "kes.h"
#include "hauto.h"
#include "candlstx.h"
#include "mscandui.h"
#include "toolbar.h"
#include "editssn.h"
#include "immxutil.h"
#include "softkbd.h"
#include "skbdkor.h"
#include "pad.h"
#include "resource.h"

///////////////////////////////////////////////////////////////////////////////
// Class forward declarations
class CEditSession;
class CICPriv;
class CThreadMgrEventSink;
class CFunctionProvider;
class CHanja;
class CCompositionInsertHelper;

///////////////////////////////////////////////////////////////////////////////
// Edit callback state values
#define ESCB_FINALIZECONVERSION         1
#define ESCB_COMPLETE                   2
#define ESCB_INSERT_PAD_STRING          3
#define ESCB_KEYSTROKE                  4
#define ESCB_TEXTEVENT                  5
//#define ESCB_RANGEBROKEN              6
#define ESCB_CANDUI_CLOSECANDUI         6
#define ESCB_HANJA_CONV                 7
#define ESCB_FINALIZERECONVERSION       8
#define ESCB_ONSELECTRECONVERSION       9
#define ESCB_ONCANCELRECONVERSION       10
#define ESCB_RECONV_QUERYRECONV         11
#define ESCB_RECONV_GETRECONV           12
#define ESCB_RECONV_SHOWCAND            13
#define ESCB_INIT_MODEBIAS              14

// Conversion modes(bit field for bit op)
#define TIP_ALPHANUMERIC_MODE        0
#define TIP_HANGUL_MODE              1
#define TIP_JUNJA_MODE               2
#define TIP_NULL_CONV_MODE           0x8000

//
// Text Direction
//
typedef enum 
{
    TEXTDIRECTION_TOPTOBOTTOM = 1,
    TEXTDIRECTION_RIGHTTOLEFT,
    TEXTDIRECTION_BOTTOMTOTOP,
    TEXTDIRECTION_LEFTTORIGHT,
} TEXTDIRECTION;

    
///////////////////////////////////////////////////////////////////////////////
// CKorIMX class
class CKorIMX :  public ITfTextInputProcessor,
                 public ITfFnConfigure,
                 public ITfThreadFocusSink,
                 public ITfCompositionSink,
                 public ITfCleanupContextSink,
                 public ITfCleanupContextDurationSink,
                 public ITfActiveLanguageProfileNotifySink,
                 public ITfTextEditSink,
                 public ITfEditTransactionSink,
                 public CDisplayAttributeProvider
{
public:
    CKorIMX();
    ~CKorIMX();

    static HRESULT CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    
    //
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

private:
    long m_cRef;

public:
    //
    // ITfX methods
    //
    STDMETHODIMP Activate(ITfThreadMgr *ptim, TfClientId tid);
    STDMETHODIMP Deactivate();

    // ITfThreadFocusSink
    STDMETHODIMP OnSetThreadFocus();
    STDMETHODIMP OnKillThreadFocus();

    // ITfCompositionSink
    STDMETHODIMP OnCompositionTerminated(TfEditCookie ecWrite, ITfComposition *pComposition);

    // ITfCleanupContextDurationSink
    STDMETHODIMP OnStartCleanupContext();
    STDMETHODIMP OnEndCleanupContext();

    // ITfCleanupContextSink
    STDMETHODIMP OnCleanupContext(TfEditCookie ecWrite, ITfContext *pic);

    // ITfActiveLanguageProfileNotifySink
    STDMETHODIMP OnActivated(REFCLSID clsid, REFGUID guidProfile, BOOL fActivated);

    // ITFFnConfigure
    STDMETHODIMP GetDisplayName(BSTR *pbstrCand);
    STDMETHODIMP Show(HWND hwnd, LANGID langid, REFGUID rguidProfile);

      // ITfTextEditSink
    STDMETHODIMP OnEndEdit(ITfContext *pic, TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    // ITfEditTransactionSink
    STDMETHODIMP OnStartEditTransaction(ITfContext *pic);
    STDMETHODIMP OnEndEditTransaction(ITfContext *pic);

// Operations
public:
    // Get/Set On off status
    BOOL IsOn(ITfContext *pic);
    void SetOnOff(ITfContext *pic, BOOL fOn);

    static HRESULT _EditSessionCallback2(TfEditCookie ec, CEditSession2 *pes);
    HRESULT MakeResultString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);

    // REVIEW: IC related functions
    ITfContext* GetRootIC(ITfDocumentMgr* pDim = NULL);
    static BOOL IsDisabledIC(ITfContext *pic);
    static BOOL IsEmptyIC(ITfContext *pic);
    static BOOL IsCandidateIC(ITfContext *pic);

    static HWND GetAppWnd(ITfContext *pic);
    BOOL IsPendingCleanup();

    // Get AIMM or not?
    static BOOL GetAIMM(ITfContext *pic);

    // Get/Set conversion mode
    DWORD GetConvMode(ITfContext *pic);
    DWORD SetConvMode(ITfContext *pic, DWORD dwConvMode);

    // Retun current Automata object
    CHangulAutomata* GetAutomata(ITfContext *pic);

    // Cand UI functions
    void OpenCandidateUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList);
    void CloseCandidateUI(ITfContext *pic);
    void CancelCandidate(TfEditCookie ec, ITfContext *pic);

    // Soft Kbd functions
    HRESULT InitializeSoftKbd();
    BOOL IsSoftKbdEnabled()    { return m_fSoftKbdEnabled; }
    void  TerminateSoftKbd();
    BOOL GetSoftKBDOnOff();
    void SetSoftKBDOnOff(BOOL fOn);
    DWORD GetSoftKBDLayout();
    void SetSoftKBDLayout(DWORD  dwKbdLayout);
    HRESULT GetSoftKBDPosition(int *xWnd, int *yWnd);
    void SetSoftKBDPosition(int  xWnd, int yWnd);
    SOFTLAYOUT* GetHangulSKbd() { return &m_KbdHangul; }
    
    // Data access functins
    ITfDocumentMgr* GetDIM() { return m_pCurrentDim; }
    HRESULT         GetFocusDIM(ITfDocumentMgr **ppdim);
    ITfThreadMgr*    GetTIM() { return m_ptim; }
    TfClientId        GetTID() { return m_tid;  }
    ITfContext*        GetIC();
    CThreadMgrEventSink* GetTIMEventSink() { return m_ptimEventSink; }
    static CICPriv*    GetInputContextPriv(ITfContext *pic);
    void             OnFocusChange(ITfContext *pic, BOOL fActivate);

    // Window object member access functions
    HWND GetOwnerWnd()          { return m_hOwnerWnd; }

    // Get IImeIPoint
    IImeIPoint1* GetIPoint              (ITfContext *pic);

    // KES_CODE_FOCUS set fForeground?
    BOOL IsKeyFocus()            { return m_fKeyFocus; }

    // Get Pad Core
    CPadCore* GetPadCore()      { return m_pPadCore; }


    // Update Toolbar button
    void UpdateToolbar(DWORD dwUpdate)  { m_pToolBar->Update(dwUpdate); }
    static LRESULT CALLBACK _OwnerWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    CFunctionProvider*     GetFunctionProvider() { return m_pFuncPrv; }

    // Cand UI helper
    BOOL IsCandUIOpen() { return m_fCandUIOpen; }

    // Get TLS
    LIBTHREAD *_GetLibTLS() { return &m_libTLS; }

// Implementation
protected:
// Helper functions
    HRESULT SetInputString(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, WCHAR *psz, LANGID langid);
    static LANGID GetLangID();
    static WCHAR Banja2Junja(WCHAR bChar);

    // Cand UI function
    void GetCandidateFontInternal(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LOGFONTW *plf, LONG lFontPoint, BOOL fCandList);

//////////////////////////////////////////////////////////////////////////////
// Internal functions
private:
    // Callbacks
    static HRESULT _KeyEventCallback(UINT uCode, ITfContext *pic, WPARAM wParam, LPARAM lParam, BOOL *pfEaten, void *pv);
    static HRESULT _PreKeyCallback(ITfContext *pic, REFGUID rguid, BOOL *pfEaten, void *pv);
    static HRESULT _DIMCallback(UINT uCode, ITfDocumentMgr *pdimNew, ITfDocumentMgr *pdimPrev, void *pv);
    static HRESULT _ICCallback(UINT uCode, ITfContext *pic, void *pv);
    static HRESULT _CompEventSinkCallback(void *pv, REFGUID rguid);
    static void _CleanupCompositionsCallback(TfEditCookie ecWrite, ITfRange *rangeComposition, void *pvPrivate);

    void HAutoMata(TfEditCookie ec, ITfContext    *pIIC, ITfRange *pIRange, LPBYTE lpbKeyState, WORD wVKey);
    BOOL _IsKeyEaten(ITfContext *pic, CKorIMX *pimx, WPARAM wParam, LPARAM lParam, const BYTE abKeyState[256]);
    HRESULT _Keystroke(TfEditCookie ec, ITfContext *pic, WPARAM wParam, LPARAM lParam, const BYTE abKeyState[256]);

    // IC helpers
    HRESULT _InitICPriv(ITfContext *pic);
    HRESULT _DeleteICPriv(ITfContext *pic);

    // Hanja conversion
    HRESULT DoHanjaConversion(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);
    HRESULT Reconvert(ITfRange *pSelection);

    // Composition
    ITfComposition *GetIPComposition(ITfContext *pic);
    ITfComposition *CreateIPComposition(TfEditCookie ec, ITfContext *pic, ITfRange* pRangeComp);
    void SetIPComposition(ITfContext *pic, ITfComposition *pComposition);
    BOOL EndIPComposition(TfEditCookie ec, ITfContext *pic);

    // Candidate list
    CCandidateListEx *CreateCandidateList(ITfContext *pic, ITfRange *pRange, LPWSTR wchHangul);
    TEXTDIRECTION GetTextDirection(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);
    CANDUIUIDIRECTION GetCandUIDirection(TfEditCookie ec, ITfContext *pic, ITfRange *pRange);
    void CloseCandidateUIProc();
    void SelectCandidate(TfEditCookie ec, ITfContext *pic, INT idxCand, BOOL fFinalize);
    HMENU CreateCandidateMenu(ITfContext *pic);
    static HRESULT CandidateUICallBack(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList, CCandidateStringEx *pCand, TfCandidateResult imcr);

    // Cand key
    void SetCandidateKeyTable(ITfContext *pic, CANDUIUIDIRECTION dir);
    static BOOL IsCandKey(WPARAM wParam, const BYTE abKeyState[256]);

#if 0
    // Range functions
    void BackupRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRange );
    void RestoreRange(TfEditCookie ec, ITfContext *pic );
    ITfRange* CreateIPRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRangeOrg);
    void SetIPRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRange);
    ITfRange* GetIPRange(TfEditCookie ec, ITfContext *pic);
    BOOL FlushIPRange(TfEditCookie ec, ITfContext *pic);
#endif

    // Modebias(ImmSetConversionStatus() API AIMM compatebility)
    BOOL InitializeModeBias(TfEditCookie ec, ITfContext *pic);
    void CheckModeBias(ITfContext* pic);
    BOOL CheckModeBias(TfEditCookie ec, ITfContext *pic, ITfRange *pSelection);

    // SoftKeyboard 
    //void OnActivatedSoftKbd(BOOl bActivated);
    HRESULT ShowSoftKBDWindow(BOOL fShow);
    void SoftKbdOnThreadFocusChange(BOOL fSet);
    
    // Helpers
    BOOL MySetText(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, const WCHAR *psz, LONG cchText, LANGID langid, GUID *pattr);

    BOOL IsKorIMX_GUID_ATOM(TfGuidAtom attr);

///////////////////////////////////////////////////////////////////////////////
// Internal data
private:
    ITfDocumentMgr           *m_pCurrentDim;
    ITfThreadMgr             *m_ptim;
    TfClientId                m_tid;
    CThreadMgrEventSink      *m_ptimEventSink;
    CKeyEventSink            *m_pkes;
    
    HWND                      m_hOwnerWnd;
    BOOL                      m_fKeyFocus;  
    CPadCore                 *m_pPadCore;
    CToolBar                 *m_pToolBar;

    DWORD                     m_dwThreadFocusCookie;
    DWORD                     m_dwProfileNotifyCookie;
    BOOL                      m_fPendingCleanup;

    CFunctionProvider*        m_pFuncPrv;

    // For overtyping
    CCompositionInsertHelper *m_pInsertHelper;

    // Candidate UI
    ITfCandidateUI*           m_pCandUI;
    BOOL                      m_fCandUIOpen;

    // SoftKbd
    BOOL                      m_fSoftKbdEnabled;
    ISoftKbd                 *m_pSoftKbd;
    SOFTLAYOUT                m_KbdStandard;
    SOFTLAYOUT                m_KbdHangul;
    CSoftKbdWindowEventSink  *m_psftkbdwndes;
    DWORD                     m_dwSftKbdwndesCookie;
    BOOL                      m_fSoftKbdOnOffSave;
    
    // Tls for our helper library, we're apt threaded so tls can live in this object
    LIBTHREAD                 m_libTLS; 

    BOOL                      m_fNoKorKbd;
};

/*---------------------------------------------------------------------------
    CKorIMX::IsPendingCleanup
---------------------------------------------------------------------------*/
inline
BOOL CKorIMX::IsPendingCleanup()
{
    return m_fPendingCleanup;
}

/*---------------------------------------------------------------------------
    CKorIMX::GetFocusDIM
---------------------------------------------------------------------------*/
inline
HRESULT CKorIMX::GetFocusDIM(ITfDocumentMgr **ppdim)
{
    Assert(ppdim);
    *ppdim = NULL;
    if (m_ptim != NULL)
        m_ptim->GetFocus(ppdim);

    return *ppdim ? S_OK : E_FAIL;
}

#include "icpriv.h"
/*---------------------------------------------------------------------------
    CKorIMX::GetAutomata
---------------------------------------------------------------------------*/
inline
CHangulAutomata* CKorIMX::GetAutomata(ITfContext *pic)
{
    CICPriv* picp = GetInputContextPriv(pic);
    return (picp) ?    GetInputContextPriv(pic)->GetAutomata() : NULL;
}

/*---------------------------------------------------------------------------
    CKorIMX::IsOn
---------------------------------------------------------------------------*/
inline
BOOL  CKorIMX::IsOn(ITfContext *pic)
{
    DWORD dw = 0;
    
    if (pic == NULL)
        return fFalse;

    GetCompartmentDWORD(GetTIM(), GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, &dw, fFalse);

    return dw ? fTrue : fFalse;
}

/*---------------------------------------------------------------------------
    CKorIMX::GetConvMode
---------------------------------------------------------------------------*/
inline
DWORD CKorIMX::GetConvMode(ITfContext *pic)
{
    DWORD dw = 0;

    if (pic == NULL)
        return TIP_ALPHANUMERIC_MODE;

    GetCompartmentDWORD(GetTIM(), GUID_COMPARTMENT_KORIMX_CONVMODE, &dw, fFalse);
        
    return dw;
}



/*---------------------------------------------------------------------------
    CKorIMX::SetOnOff
---------------------------------------------------------------------------*/
inline
void CKorIMX::SetOnOff(ITfContext *pic, BOOL fOn)
{
    if (pic)
        SetCompartmentDWORD(m_tid, GetTIM(), GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, fOn ? 0x01 : 0x00, fFalse);
}

/*---------------------------------------------------------------------------
    CKorIMX::GetLangID
---------------------------------------------------------------------------*/
inline 
LANGID CKorIMX::GetLangID()
{
    return MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT);
}

/*---------------------------------------------------------------------------
    CKorIMX::IsKorIMX_GUID_ATOM
---------------------------------------------------------------------------*/
inline
BOOL CKorIMX::IsKorIMX_GUID_ATOM(TfGuidAtom attr)
{
    if (IsEqualTFGUIDATOM(&m_libTLS, attr, GUID_ATTR_KORIMX_INPUT))
        return fTrue;

    return fFalse;
}

/////////////////////////////////////////////////////////////////////////////
// S O F T  K E Y B O A R D  F U N C T I O N S
/////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    CKorIMX::GetSoftKBDOnOff
---------------------------------------------------------------------------*/
inline
BOOL CKorIMX::GetSoftKBDOnOff()
{

     DWORD dw;

    if (GetTIM() == NULL)
       return fFalse;

    GetCompartmentDWORD(GetTIM(), GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE , &dw, fFalse);
    return dw ? TRUE : fFalse;
}

/*---------------------------------------------------------------------------
    CKorIMX::SetSoftKBDOnOff
---------------------------------------------------------------------------*/
inline
void CKorIMX::SetSoftKBDOnOff(BOOL fOn)
{

    // check to see if the m_pSoftKbd and soft keyboard related members are initialized.
    if (m_fSoftKbdEnabled == fFalse)
        InitializeSoftKbd();

    if (m_pSoftKbd == NULL || GetTIM() == NULL)
        return;

    if (fOn == GetSoftKBDOnOff())
       return;

    SetCompartmentDWORD(GetTID(), GetTIM(), GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE, 
                        fOn ? 0x01 : 0x00 , fFalse);
}

/*---------------------------------------------------------------------------
    CKorIMX::GetSoftKBDLayout
---------------------------------------------------------------------------*/
inline
DWORD  CKorIMX::GetSoftKBDLayout( )
{

   DWORD dw;

    if (m_pSoftKbd == NULL || GetTIM() == NULL)
       return NON_LAYOUT;

   GetCompartmentDWORD(GetTIM(), GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, &dw, fFalse);

   return dw;

}


/*---------------------------------------------------------------------------
    CKorIMX::SetSoftKBDLayout
---------------------------------------------------------------------------*/
inline
void  CKorIMX::SetSoftKBDLayout(DWORD  dwKbdLayout)
{
    // check to see if the _SoftKbd and soft keyboard related members are initialized.
    if (m_fSoftKbdEnabled == fFalse )
        InitializeSoftKbd();

    if ((m_pSoftKbd == NULL) || (GetTIM() == NULL))
        return;

    SetCompartmentDWORD(GetTID(), GetTIM(), GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, 
                        dwKbdLayout , fFalse);
}

/*---------------------------------------------------------------------------
    CKorIMX::GetSoftKBDPosition
---------------------------------------------------------------------------*/
inline
HRESULT CKorIMX::GetSoftKBDPosition(int *xWnd, int *yWnd)
{
    DWORD    dwPos;
    HRESULT  hr = S_OK;

    if ((m_pSoftKbd == NULL) || (GetTIM() == NULL))
        return E_FAIL;

    if (!xWnd  || !yWnd)
        return E_FAIL;

   hr = GetCompartmentDWORD(GetTIM(), GUID_COMPARTMENT_SOFTKBD_WNDPOSITION, &dwPos, TRUE);

   if (hr == S_OK)
        {
        *xWnd = dwPos & 0x0000ffff;
        *yWnd = (dwPos >> 16) & 0x0000ffff;
        hr = S_OK;
        }
   else
        {
        *xWnd = 0;
        *yWnd = 0;
        hr = E_FAIL;
        }

   return hr;
}

/*---------------------------------------------------------------------------
    CKorIMX::SetSoftKBDPosition
---------------------------------------------------------------------------*/
inline
void CKorIMX::SetSoftKBDPosition(int  xWnd, int yWnd )
{
    DWORD  dwPos;
    DWORD  left, top;

    if ((m_pSoftKbd == NULL) || (GetTIM() == NULL))
        return;

    if (xWnd < 0)
        left = 0;
    else
        left = (WORD)xWnd;

    if (yWnd < 0)
        top = 0;
    else
        top = (WORD)yWnd;

    dwPos = ((DWORD)top << 16) + left;

    SetCompartmentDWORD(GetTID(), GetTIM(), GUID_COMPARTMENT_SOFTKBD_WNDPOSITION, 
                        dwPos, TRUE);
}
    

/////////////////////////////////////////////////////////////////////////////
// H E L P E R  F U N C T I O N S
/////////////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
    SetSelectionBlock

    Wrapper for SetSelection that takes only a single range and sets default style values.
---------------------------------------------------------------------------*/
inline 
HRESULT SetSelectionBlock(TfEditCookie ec, ITfContext *pic, ITfRange *range)
{
    TF_SELECTION sel;

    sel.range = range;
    sel.style.ase = TF_AE_NONE;
    sel.style.fInterimChar = fTrue;

    return pic->SetSelection(ec, 1, &sel);
}

/*---------------------------------------------------------------------------
    SetThis
---------------------------------------------------------------------------*/
inline
void SetThis(HWND hWnd, LPARAM lParam)
{
    SetWindowLongPtr(hWnd, GWLP_USERDATA, 
                (LONG_PTR)((CREATESTRUCT *)lParam)->lpCreateParams);
}

/*---------------------------------------------------------------------------
    GetThis
---------------------------------------------------------------------------*/
inline
CKorIMX *GetThis(HWND hWnd)
{
    CKorIMX *p = (CKorIMX *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    Assert(p != NULL);
    return p;
}

#endif // __KORIMX_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\ipointcic.cpp ===
/****************************************************************************
    IPOINT.CPP

    Owner: cslim
    Copyright (c) 1997-1999 Microsoft Corporation

    IImeIPoint1 interface
    
    History:
    24-OCT-2001 cslim       Branched for Cicero TIP PAD support
    20-JUL-1999 cslim       Created
*****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "ipointcic.h"
#include "editssn.h"
#include "imepad.h"    // IImeIPoint
#include "debug.h"

/*----------------------------------------------------------------------------
    CImeIPoint::CImeIPoint

    Ctor
----------------------------------------------------------------------------*/
CIPointCic::CIPointCic(CKorIMX *pImx)
{
    Assert(m_pImx != NULL);
    
    m_cRef          = 0;
    m_pImx          = pImx;
    m_pic           = NULL;
    m_dwCharNo      = 1;
}

/*----------------------------------------------------------------------------
    CImeIPoint::~CIPointCic

    Dtor
----------------------------------------------------------------------------*/
CIPointCic::~CIPointCic()
{
    SafeReleaseClear(m_pic);
}

/*----------------------------------------------------------------------------
    CImeIPoint::QueryInterface
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::QueryInterface(REFIID riid, LPVOID * ppv)
{
    if(riid == IID_IUnknown) 
        {
        TraceMsg(DM_TRACE, TEXT("IID_IUnknown\n"));
        *ppv = static_cast<IImeIPoint1 *>(this);
        }
    else 
    if(riid == IID_IImeIPoint1) 
        {
        TraceMsg(DM_TRACE, TEXT("IID_IImeIPoint1\n"));
        *ppv = static_cast<IImeIPoint1 *>(this);
        }
    else 
        {
        TraceMsg(DM_TRACE, TEXT("Unknown Interface ID\n"));
        *ppv = NULL;
        return E_NOINTERFACE;
        }

    // Increase ref counter
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();

    return S_OK;
}

/*----------------------------------------------------------------------------
    CImeIPoint::AddRef
----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CIPointCic::AddRef(VOID)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/*----------------------------------------------------------------------------
    CImeIPoint::Release
----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CIPointCic::Release(VOID)
{
    ULONG res = InterlockedDecrement((LPLONG)&m_cRef);
    if (res == 0L)
        delete this;
    return res;
}

/*----------------------------------------------------------------------------
    CImeIPoint::Initialize
----------------------------------------------------------------------------*/
HRESULT CIPointCic::Initialize(ITfContext *pic)
{
    SafeReleaseClear(m_pic);
    
	m_pic = pic;
	if (m_pic)
	    {
        m_pic->AddRef();
	    }

    return (S_OK);
}

#ifndef DEBUG
    #define DumpFEInfo    /##/
#else
/*----------------------------------------------------------------------------
    DumpFEInfo

    Dump LPIMEFAREASTINFO. Debug only
----------------------------------------------------------------------------*/
VOID DumpFEInfo(LPIMEFAREASTINFO lpInfo, INT count)
{
    TraceMsg(DM_TRACE, TEXT("DumpFEInfo Start\n"));
    TraceMsg(DM_TRACE, TEXT("lpInfo [0x%08x]\n"), lpInfo);
    TraceMsg(DM_TRACE, TEXT("lpInfo->dwSize [%d]\n"),     lpInfo->dwSize);
    TraceMsg(DM_TRACE, TEXT("lpInfo->dwType [0x%08x]\n"), lpInfo->dwType);

    LPWSTR lpwstr;

    switch(lpInfo->dwType) 
        {
    case IMEFAREASTINFO_TYPE_COMMENT:
        TraceMsg(DM_TRACE, TEXT("-->dwType is IMEFAREASTINFO_TYPE_COMMENT\n"));
        lpwstr = (LPWSTR)lpInfo->dwData;
        for(int i=0;i < count; i++) 
            {
            //DbgW(DBGID_IMEPAD, L"%d [%s]\n", i, lpwstr);
            lpwstr = lpwstr + lstrlenW(lpwstr)+1;
            }
        break;
        }


    TraceMsg(DM_TRACE, TEXT("DumpFEInfo End\n"));
}
#endif // _DEBUG

/*----------------------------------------------------------------------------
    CImeIPoint::InsertImeItem

    Multibox input call this method
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::InsertImeItem(IPCANDIDATE* pImeItem, INT iPos, DWORD *lpdwCharId)
{
    DWORD dwCharId;
    CEditSession2 *pes;
    ESSTRUCT ess;
    HRESULT hr;

    // Check Parameters
    Assert(pImeItem != NULL && pImeItem->dwSize > 0);
    
    if (pImeItem == NULL || pImeItem->dwSize <= 0 || m_pImx == NULL || m_pic == NULL)
        return S_FALSE;

    TraceMsg(DM_TRACE, TEXT("CImeIPoint::InsertImeItem\n"));
    TraceMsg(DM_TRACE, TEXT("pImeItem [0x%08x]\n"), pImeItem);
    TraceMsg(DM_TRACE, TEXT("pImeItem->dwSize    [%d]\n"), pImeItem->dwSize);
    TraceMsg(DM_TRACE, TEXT("pImeItem->iSelIndex [%d]\n"), pImeItem->iSelIndex);
    TraceMsg(DM_TRACE, TEXT("pImeItem->nCandidate[%d]\n"), pImeItem->nCandidate);
    TraceMsg(DM_TRACE, TEXT("pImeItem->dwPrivateDataOffset[%d]\n"), pImeItem->dwPrivateDataOffset);
    TraceMsg(DM_TRACE, TEXT("pImeItem->dwPrivateDataSize  [%d]\n"), pImeItem->dwPrivateDataSize);
    DumpFEInfo((LPIMEFAREASTINFO)((LPBYTE)pImeItem + pImeItem->dwPrivateDataOffset), pImeItem->nCandidate);

    TraceMsg(DM_TRACE, TEXT("lpdwCharId [0x%08x] [%d]\n"), lpdwCharId, lpdwCharId ? *lpdwCharId : 0xFFFFF);

    // Finalize current comp string
    ESStructInit(&ess, ESCB_COMPLETE);

    if ((pes = new CEditSession2(m_pic, m_pImx, &ess, CKorIMX::_EditSessionCallback2)))
        {
        pes->Invoke(ES2_READWRITE | ES2_SYNCASYNC, &hr);
        pes->Release();
        }

    ESStructInit(&ess, ESCB_INSERT_PAD_STRING);
    ess.wParam = *(LPWSTR)((PBYTE)pImeItem + pImeItem->dwOffset[0]);
           
    if ((pes = new CEditSession2(m_pic, m_pImx, &ess, CKorIMX::_EditSessionCallback2)))
        {
        pes->Invoke(ES2_READWRITE | ES2_SYNCASYNC, &hr);
        pes->Release();
        }

    // Increase Char serial number
    m_dwCharNo++;
    dwCharId = m_dwCharNo;
    if (lpdwCharId)
        {
        dwCharId |= ((*lpdwCharId) & (~ IPCHARID_CHARNO_MASK));
        *lpdwCharId = dwCharId;
        }

    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ReplaceImeItem
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::ReplaceImeItem(
    INT             iPos,       // = IPINS_CURRENT:use current IP position and 
                           //                  set IP to the end of insert chars.
                           // = 0-n: The offset of all composition string to set 
                           //         IP position, before insert chars. 
                           //         and IP back to original position.
    INT             iTargetLen, 
    IPCANDIDATE* pImeItem,
    DWORD         *lpdwCharId)
{
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::InsertStringEx
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::InsertStringEx(WCHAR* pwSzInsert, INT cchSzInsert, DWORD *lpdwCharId)
{
    DWORD dwCharId;
    CEditSession2 *pes;
    ESSTRUCT ess;
    HRESULT hr;
    
    TraceMsg(DM_TRACE, TEXT("CIPointCic::InsertStringEx : *pwSzInsert=0x%04X, cchSzInsert=%d, *lpdwCharId = 0x%04X"), *pwSzInsert, cchSzInsert, *lpdwCharId);

    // Check Parameters
    Assert(pwSzInsert != NULL && cchSzInsert > 0);
    
    if (pwSzInsert == NULL || cchSzInsert <= 0 || m_pImx == NULL || m_pic == NULL)
        return S_FALSE;

    // Finalize current comp string
    ESStructInit(&ess, ESCB_COMPLETE);

    if ((pes = new CEditSession2(m_pic, m_pImx, &ess, CKorIMX::_EditSessionCallback2)))
        {
        pes->Invoke(ES2_READWRITE | ES2_SYNCASYNC, &hr);
        pes->Release();
        }

    // Add all chars in string as finalized string
    for (INT i=0; i<cchSzInsert; i++)
        {
        ESStructInit(&ess, ESCB_INSERT_PAD_STRING);
        ess.wParam = *(pwSzInsert + i);
           
        if ((pes = new CEditSession2(m_pic, m_pImx, &ess, CKorIMX::_EditSessionCallback2)))
            {
            pes->Invoke(ES2_READWRITE | ES2_SYNCASYNC, &hr);
            pes->Release();
            }
    
        // Increase Char serial number
        m_dwCharNo++;
        dwCharId = m_dwCharNo;
        if (lpdwCharId)
            {
            dwCharId |= ((*lpdwCharId) & (~ IPCHARID_CHARNO_MASK));
            *lpdwCharId = dwCharId;
            }
        }


    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::DeleteCompString
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::DeleteCompString(INT    iPos,
                             INT    cchSzDel)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::DeleteCompString\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ReplaceCompString
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::ReplaceCompString(INT     iPos,
                                              INT        iTargetLen, 
                                              WCHAR    *pwSzInsert,
                                              INT        cchSzInsert,
                                              DWORD    *lpdwCharId)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::ReplaceCompString\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::ControlIME
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::ControlIME(DWORD dwIMEFuncID, LPARAM lpara)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::ControlIME, dwIMEFuncID=0x%04X, lpara=0x%08lX\n"), dwIMEFuncID, lpara);

    // TODO:
    
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::GetAllCompositionInfo
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::GetAllCompositionInfo(WCHAR**    ppwSzCompStr,
                                  DWORD**    ppdwCharID,
                                  INT        *pcchCompStr,
                                  INT        *piIPPos,
                                  INT        *piStartUndetStrPos,
                                  INT        *pcchUndetStr,
                                  INT        *piEditStart,
                                  INT        *piEditLen)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::GetAllCompositionInfo START\n"));

    // Return nothing for now.
    if(ppwSzCompStr) 
        {
        *ppwSzCompStr = NULL;
        }
        
    if(ppdwCharID) 
        {
        *ppdwCharID = NULL;
        }
        
    *pcchCompStr = 0;
    *piIPPos     = 0;
    *piStartUndetStrPos = 0;
    *pcchUndetStr =0;
    *piEditStart = 0;
    *piEditLen = 0;
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::GetAllCompositionInfo END\n"));

    return (S_OK);
}

/*----------------------------------------------------------------------------
    CImeIPoint::GetIpCandidate
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::GetIpCandidate(DWORD        dwCharId,
                           IPCANDIDATE **ppImeItem,
                           INT *        piColumn,
                           INT *        piCount)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::GetIpCandidate\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::SelectIpCandidate
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::SelectIpCandidate(DWORD dwCharId, INT iselno)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::SetIpCandidate\n"));
    return (E_NOTIMPL);
}

/*----------------------------------------------------------------------------
    CImeIPoint::UpdateContext

    Update IME context and send it to the application
----------------------------------------------------------------------------*/
STDMETHODIMP CIPointCic::UpdateContext(BOOL fGenerateMessage)
{
    TraceMsg(DM_TRACE, TEXT("CImeIPoint::UpdateContext\n"));

    // TODO:
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\lexheader.h ===
#if !defined(_LEXHEADER_H__INCLUDED_)
#define _LEXHEADER_H__INCLUDED_

#define DEFAULT_LEX_FILE_NAME "IMEKR.LEX"	// if no reg found will use this name
#define DICT_HEADER_SIZE 512
#define COPYRIGHT_STR "(C) 1997 Hangul Engineering Team. Microsoft Corp. All rights reserved.\n"
#define LEX_VERSION					0x1100
#define LEX_COMPATIBLE_VERSION_LIMIT	0x2000
#define LEX_FILE_NAME TEXT("IMEKR.LEX")

#define TOTAL_NUMBER_OF_HANGUL_MAPPING	(484 + 18) // K0+K1 + # of symbols( - )
#define TOTAL_NUMBER_OF_HANJA			7744
#define MAX_NUMBER_OF_HANJA_SAME_PRONUNC 103
#define MAX_SENSE_LENGTH	50

struct  _DictHeader {
	char	COPYRIGHT_HEADER[150];
	WORD	Version;
	UINT	NumOfHangulEntry;
	UINT	MaxNumOfHanja;
	DWORD	Headersize;
	DWORD	iBufferStart;	      // seek point of HnagulToHanja Index
	UINT	uiNumofHanja;
	DWORD   iHanjaToHangulIndex;  // seek point of HanjaToHangul Index
	DWORD	reserved[10];
	_DictHeader() { 
		Version = 0;
		iBufferStart = Headersize= 0;

		ZeroMemory(reserved, sizeof(reserved));
		ZeroMemory(COPYRIGHT_HEADER, sizeof(COPYRIGHT_HEADER));
		lstrcpy(COPYRIGHT_HEADER, COPYRIGHT_STR);
		COPYRIGHT_HEADER[lstrlen(COPYRIGHT_HEADER)+1] = '\032';
	}
};

struct _LexIndex {
	WCHAR	wcHangul;
	WORD	wNumOfK0, wNumOfK1;
	UINT	iOffset;

	_LexIndex() {
		wcHangul = 0;
		wNumOfK0 = wNumOfK1 = 0;
		iOffset = 0;
	}
};

struct HanjaToHangulIndex 
{
	WCHAR	wchHanja;
	WCHAR	wchHangul;
	UINT	iOffset;

	HanjaToHangulIndex() 
	{
		wchHanja = wchHangul = 0;
		iOffset = 0;
	}
};


#endif // !defined(_LEXHEADER_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\pad.h ===
//
//	%%Title: UI IMEPad Button
//	%%Unit: UI
//	%%Contact: TakeshiF
//	%%Date: 97/04/14
//	%%File: pad.h
//
//	UI IMEPad Button support
//

#ifndef __PAD_H__
#define __PAD_H__

#include "cicbtn.h"
#include "toolbar.h"
#include "padcb.h"

#include "../fecommon/srcuim/cpadsvu.h"

class CKorIMX;
class CImePadSvrUIM;

class CPadCore
{
public:
	BOOL m_fShown;
	BOOL m_fCurrentlyShown;
	CPadCore(CKorIMX *pTip);
	~CPadCore();

	void PadBoot(IImeIPoint1* pIP, IID* piid);
#if 0
	void PadBoot( IImeIPoint* pIP, UINT uiType );
#endif
	BOOL InitializePad();
	void SetIPoint(IImeIPoint1* pIP);
	void IMEPadNotify(BOOL fShown);
	void SetFocus(BOOL fFocus);
	void ShowPad(BOOL fShow);
	BOOL IsShown()
	{
		return m_fShown;
	}
	BOOL IsCurrentlyShown(void)
	{
		return m_fCurrentlyShown;
	}
    UINT MakeAppletMenu(UINT uidStart, UINT uidEnd, ITfMenu *pMenu, LPIMEPADAPPLETCONFIG *ppCfg);

#if 0
	BOOL GetHWInfo( BSTR* pbsz, HICON* phIcon );
	BOOL InvokeHWTIP(void);
	BOOL IsHWTIP(void);
#endif

	CPadCB* m_pPadCB;
	CImePadSvrUIM* m_pPadSvr;

private:
	CKorIMX *m_pImx;
};

class CPad : public CCicButton
{
public:

	CPad(CToolBar *ptb, CPadCore* pPadCore);
	~CPad();

	void Reset(void);

	STDMETHODIMP GetIcon(HICON *phIcon);
	STDMETHODIMP InitMenu(ITfMenu *pMenu);
	STDMETHODIMP OnMenuSelect(UINT uID);
    STDMETHODIMP_(ULONG) Release(void);

#if 0
    static BOOL __declspec(dllexport) HWDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
	static BOOL OnProcessAttach(HINSTANCE hInst);
	static BOOL OnProcessDetach(void);
	static BOOL OnThreadAttach(void);
	static BOOL OnThreadDetach(void);

	void UnloadImePad(void);
	void LoadImePad(HWND hWndUI);
#endif
	void ShowItem(BOOL fShow);
	UINT MakeAppletMenu( void** ppcmh );
	void CleanAppletCfg(void);

private:

	UINT m_ciApplets;
	CToolBar *m_pTb;
	CPadCore *m_pPadCore;
	IMEPADAPPLETCONFIG *m_pCfg;

};

#endif // __PAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\pad.cpp ===
/****************************************************************************
    PAD.CPP

    Owner: cslim
    Copyright (c) 1997-2001 Microsoft Corporation

    IME PAD button and helper functions

    History:
    24-OCT-2001 CSLim       Ported for Korean TIP
    05-OCT-1999 TakeshiF    Created
*****************************************************************************///
#include "private.h"
#include "pad.h"
#include "padcb.h"
#include "globals.h"
#include "nuibase.h"
#include "userex.h"
#include "resource.h"

#define	MemAlloc(a)	GlobalAllocPtr(GMEM_FIXED, a)
#define MemFree(a)	GlobalFreePtr(a)

//
// menu id range
//
#define PADMENUSTART  IDR_PAD_FIRST
#define PADMENUEND    IDR_PAD_END


// {02D7474B-2EEA-4ebb-927A-779D9A201D02}
static const GUID GUID_LBI_KORIMX_CPAD = 
{
    0x2d7474b, 
    0x2eea, 
    0x4ebb, 
    { 0x92, 0x7a, 0x77, 0x9d, 0x9a, 0x20, 0x1d, 0x2 } 
};


/*---------------------------------------------------------------------------
    CPad::CPad
---------------------------------------------------------------------------*/
CPad::CPad(CToolBar *ptb, CPadCore* pPadCore)
{
    WCHAR  szText[256];
    
    m_pTb = ptb;

    // Set button tooltip
    LoadStringExW(g_hInst, IDS_TT_IME_PAD, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_KorIMX, 
                GUID_LBI_KORIMX_CPAD,
                TF_LBI_STYLE_BTN_MENU | TF_LBI_STYLE_SHOWNINTRAY,
                140, 
                szText);
    SetToolTip(szText);

    // Set button text
    LoadStringExW(g_hInst, IDS_BUTTON_IME_PAD, szText, sizeof(szText)/sizeof(WCHAR));
    SetText(szText);

    m_pPadCore = pPadCore;
    m_ciApplets = 0;

    m_pCfg = NULL;    // applet list
}

/*---------------------------------------------------------------------------
    CPad::~CPad
---------------------------------------------------------------------------*/
CPad::~CPad()
{
    CleanAppletCfg();
}

/*---------------------------------------------------------------------------
    CPad::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CPad::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
        {
        delete this;
        }

    return cr;
}

/*---------------------------------------------------------------------------
    CPad::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI CPad::GetIcon(HICON *phIcon)
{
    UINT uiIcon = IDI_PAD;
    
    *phIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(uiIcon), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);
    return S_OK;
}


/*---------------------------------------------------------------------------
    CPad::InitMenu
---------------------------------------------------------------------------*/
STDAPI CPad::InitMenu(ITfMenu *pMenu)
{
    CleanAppletCfg();
    if (m_pPadCore == NULL)
        {
        return E_FAIL;
        }
    
    m_ciApplets = m_pPadCore->MakeAppletMenu(PADMENUSTART, PADMENUEND, pMenu, &m_pCfg);

    if (m_pCfg == NULL || m_ciApplets == 0)
        {
        return E_FAIL;
        }

    return S_OK;
}
 
/*---------------------------------------------------------------------------
    CPad::OnMenuSelect
---------------------------------------------------------------------------*/
STDAPI CPad::OnMenuSelect(UINT uiCmd)
{
    ITfContext  *pic;
    IImeIPoint1 *pIP;
    IID iidApplet;
    BOOL fLaunch;
    
    if (m_pTb == NULL)
        {
        return E_FAIL;
        }
    
    pic = m_pTb->GetIC();
    if (pic == NULL)
        {
        return S_OK;
        }
    
    pIP = m_pTb->GetIPoint(pic);

    fLaunch = FALSE;
    if (uiCmd >= PADMENUSTART && uiCmd <= PADMENUEND)
        {
        fLaunch = TRUE;
        INT iidIndex = uiCmd - PADMENUSTART;
        Assert(m_pCfg != NULL);
        CopyMemory(&iidApplet, &(m_pCfg+iidIndex)->iid, sizeof(IID));    // make a copy
        }

    //
    // launch IMEPad with GUID
    //
    if (fLaunch)
        {
        m_pPadCore->PadBoot(pIP, &iidApplet);
        ShowItem(TRUE);
        }

    CleanAppletCfg();

#if 0
    //
    // HW TIP navigation
    //
    if (uiCmd == IDC_PAD_HW)
        {
        //
        // Invoke HW TIP
        //
        m_pPadCore->InvokeHWTIP();

        //
        // show HW TIP
        //
        SetCompartmentDWORD(m_pTb->GetTIP()->GetTID(), m_pTb->GetTIP()->GetTIM(), GUID_COMPARTMENT_HANDWRITING_OPENCLOSE, 0x01, FALSE);
        }
#endif
    return S_OK;
}

/*---------------------------------------------------------------------------
    CPad::ShowItem
---------------------------------------------------------------------------*/
void CPad::ShowItem(BOOL fShow)
{
    m_pPadCore->ShowPad(fShow);

    if (GetSink())
        {
        GetSink()->OnUpdate(TF_LBI_BTNALL);
        }
}

/*---------------------------------------------------------------------------
    CPad::Reset
---------------------------------------------------------------------------*/
void CPad::Reset()
{
    CleanAppletCfg();
    m_pTb = NULL;
    m_pPadCore = NULL;
}

/*---------------------------------------------------------------------------
    CPad::CleanAppletCfg
---------------------------------------------------------------------------*/
void CPad::CleanAppletCfg()
{
    if (m_pCfg)
        {
        //
        // release resouced that created by Pad server
        //
        UINT i;
        for (i = 0; i < m_ciApplets; i++)
            {
            if((m_pCfg+i)->hIcon)
                {
                ::DestroyIcon((HICON)(m_pCfg+i)->hIcon);
                }
            }


        MemFree(m_pCfg);
        m_pCfg = NULL;
        }
    
    m_ciApplets = 0;    // reset
}

#if 0
//
// HW TIP navigation dialog
//
BOOL __declspec(dllexport) CPad::HWDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (message){
        case WM_INITDIALOG: {
            SetMyClass( hDlg, 0, lParam );    // register this

            CPad* pPad = (CPad*)lParam;
            //
            // special menu item for HW TIP
            //
            HICON hIcon;
            BSTR bsz;
            if( pPad->m_pPadCore->GetHWInfo( &bsz, &hIcon ) ) {

                SysFreeString( bsz );

                OurSendMessage( GetDlgItem(hDlg, IDC_PAD_HW), STM_SETICON, (WPARAM)hIcon, (LPARAM)0 );

                DestroyIcon( hIcon );
            }



            return(TRUE);
        }

        case WM_COMMAND: {
            WORD wID = LOWORD(wParam);
            if (wID == IDOK || wID == IDCANCEL) {
                EndDialog(hDlg,0);
            }
            return(TRUE);
        }
    }
    return(FALSE);
}
#endif

/*---------------------------------------------------------------------------
    CPadCore::CPadCore
---------------------------------------------------------------------------*/
CPadCore::CPadCore(CKorIMX* pTip)
{
    m_pImx = pTip;

    //
    // Pad callback
    //
    m_pPadCB = new CPadCB;
    if (m_pPadCB)
        {
        m_pPadCB->Initialize((void *)this);
        }
    Assert(m_pPadCB != 0);
    
    //
    // Pad server
    //
    HRESULT hr;
    hr = CImePadSvrUIM::CreateInstance(g_hInst,    //Your IME module's instance handle.
                                       &m_pPadSvr,        //CImePadSvrUIM's pointer's pointer
                                       0,                        //Reserved. must be zero.
                                       0);                        //Reserved. must be zero.
    Assert(SUCCEEDED(hr));

    m_fShown = FALSE;

}

/*---------------------------------------------------------------------------
    CPadCore::~CPadCore
---------------------------------------------------------------------------*/
CPadCore::~CPadCore()
{
    if (m_pPadSvr)
        {
        m_pPadSvr->Terminate(NULL);
        CImePadSvrUIM::DeleteInstance(m_pPadSvr, 0);
        m_pPadSvr = NULL;
        }
    
    if (m_pPadCB)
        {
        delete m_pPadCB;
        m_pPadCB = NULL;
        }
}

/*---------------------------------------------------------------------------
    CPadCore::SetIPoint
---------------------------------------------------------------------------*/
void CPadCore::SetIPoint(IImeIPoint1* pIP)
{
    if (m_pPadSvr == NULL)
        {
        return; // error
        }
    
    if (m_pPadSvr)
        {
        m_pPadSvr->SetIUnkIImeIPoint((IUnknown *)pIP);
        }
}

/*---------------------------------------------------------------------------
    CPadCore::InitializePad
---------------------------------------------------------------------------*/
BOOL CPadCore::InitializePad()
{
    INT iRet;
    
    if (m_pPadSvr == NULL)
        {
        return FALSE;    // do nothing
        }
    
    iRet = m_pPadSvr->Initialize(MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), 0, NULL);

    if (iRet != 0)
        {
        return FALSE;
        }
    
    //990525:ToshiaK. callback interface pointer is temporary
    m_pPadSvr->SetIUnkIImeCallback((IUnknown *)m_pPadCB);
    
    return TRUE;
}

/*---------------------------------------------------------------------------
    CPadCore::PadBoot
---------------------------------------------------------------------------*/
void CPadCore::PadBoot(IImeIPoint1* pIP, IID* piid)
{
    if (m_pPadSvr)
        {
        if (InitializePad())
            {
            SetIPoint(pIP);
            UINT_PTR uiParam = (UINT_PTR)piid;
            m_pPadSvr->ActivateApplet(IMEPADACTID_ACTIVATEBYIID, uiParam, NULL, NULL);
            }
        }
}

#if 0
void CPadCore::PadBoot(IImeIPoint* pIP, UINT uiType)
{
    HRESULT hr;
    
    if (pIP == NULL)
        {
        return;
        }
    
    if (m_pPadSvr == NULL)
        {
        return;
        }
    
    InitializePad();    // initialize PAD engine
    SetIPoint(pIP);

    switch( uiType ) {
        case JCONV_C_SKF: {
            m_pPadSvr->ShowUI(TRUE);
        }
        break;
        case JCONV_C_SYMBOLPAD: {
            m_pPadSvr->ActivateApplet(IMEPADACTID_ACTIVATEBYIID,
                                             (UINT_PTR)&IID_SymbolList,    //IPACID_SYMBOLSEARCH,
                                             NULL, 
                                             NULL);
        }
        break;
        case JCONV_C_CONVPART: {
            IImePhrase* pPhrase;
            WCHAR wszCompStr[128];
            WCHAR wszTypeStr[128];
            INT cwchComp = 127;
            INT cwchType = 127;
            //
            // type str
            //
            hr = pIP->GetPhrase( IPCURRENTPHRASE, &pPhrase, wszTypeStr, &cwchType );
            if( hr!= S_OK ) {
                cwchType = 0;
            }
            if( hr != S_OK ) {
                cwchType = 0;
            }
            wszTypeStr[cwchType] = L'\0';
            //
            // reading
            //
            if( pPhrase && cwchType != 0) {
                INT iIdx = IMEPCA_CURRENT;
                pPhrase->GetPhraseReadingString( &iIdx, wszCompStr, &cwchComp ); // get size
                wszCompStr[cwchComp] = L'\0';    // terminator
            }
            if(IsHiraString(wszCompStr)) {
                //for #2808
                //for #4824
                if(IsKigo(wszCompStr) || IsGaiji(wszCompStr)) { 
                    m_pPadSvr->ActivateApplet(IMEPADACTID_ACTIVATEBYIID,
                                                 (UINT_PTR)&IID_SymbolList,    //IPACID_SYMBOLSEARCH,
                                                 wszTypeStr,
                                                 wszCompStr);
                }
                else {
                    m_pPadSvr->ActivateApplet(IMEPADACTID_ACTIVATEBYIID,
                                                 (UINT_PTR)&IID_RadicalStrokeList,    //IPACID_RADICALSEARCH,
                                                 wszTypeStr,
                                                 wszCompStr);
                }
            }
            else {
                m_pPadSvr->ActivateApplet(IMEPADACTID_ACTIVATEBYIID,
                                             (UINT_PTR)&IID_SymbolList,    //IPACID_SYMBOLSEARCH,
                                             wszTypeStr,
                                             wszCompStr);
            }
        }
        break;
        default:
            break;
    }
}
#endif

/*---------------------------------------------------------------------------
    CPadCore::ShowPad
---------------------------------------------------------------------------*/
void CPadCore::ShowPad(BOOL fShow)
{
    if (m_pPadSvr)
        {
        m_pPadSvr->ShowUI( fShow );
        }
    m_fShown = fShow;
}


/*---------------------------------------------------------------------------
    CPadCore::IMEPadNotify
    Notification callback from IMEPad
---------------------------------------------------------------------------*/
void CPadCore::IMEPadNotify(BOOL fShown)
{
    m_fShown = fShown;
}

/*---------------------------------------------------------------------------
    CPadCore::SetFocus
---------------------------------------------------------------------------*/
void CPadCore::SetFocus(BOOL fFocus)
{
    if (m_pPadSvr)
        {
        m_pPadSvr->Notify(IMEPADNOTIFY_ACTIVATECONTEXT, fFocus, 0);
        }
}

#if 0
/*---------------------------------------------------------------------------
    CPadCore::GetHWInfo
    Get HW category icon stuff
---------------------------------------------------------------------------*/
BOOL CPadCore::GetHWInfo( BSTR* pbsz, HICON* phIcon )
{
    ITfThreadMgr         *ptim  = m_pImx->GetTIM();
    ITfLangBarItemMgr    *plbim = NULL;
    ITfLangBarItem       *pCat;
    ITfLangBarItemButton *pCatBtn;
    HRESULT hr;

    if (IsHWTIP() == FALSE)
        {
        return FALSE;
        }

    if (FAILED(hr = GetService(ptim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim)))
        {
        return FALSE;
        }
    
    hr = plbim->GetItem(GUID_TFCAT_TIP_HANDWRITING, &pCat);
    if (SUCCEEDED(hr))
        {
        hr = pCat->QueryInterface(IID_ITfLangBarItemButton, (void **)&pCatBtn);
        if (SUCCEEDED(hr))
            {
            pCatBtn->GetIcon(phIcon);
            pCatBtn->GetTooltipString(pbsz);
            pCatBtn->Release();
            }
        pCat->Release();
        }
    plbim->Release();
    
    return TRUE;
}
#endif

/*---------------------------------------------------------------------------
    CPadCore::MakeAppletMenu
---------------------------------------------------------------------------*/
UINT CPadCore::MakeAppletMenu(UINT uidStart, UINT uidEnd, ITfMenu *pMenu, LPIMEPADAPPLETCONFIG *ppCfg)
{
    LPIMEPADAPPLETCONFIG pCfgOrg, pCfgNew = NULL;
    int ci, ciApplets;
    WCHAR szText[256];
    HRESULT hr;

    if (m_pImx == NULL)
        {
        return 0;
        }
    
    if (!InitializePad())
        {
        return 0;
        }

    pCfgOrg = NULL;
   
    hr = m_pPadSvr->GetAppletConfigList(IMEPADAPPLETCFGMASK_ALL, &ci, &pCfgOrg);
    if ((S_OK != hr) || pCfgOrg == NULL)
        {
        return 0;
        }

    //
    // Copy CoTaskMemAlloced to MemAlloc version
    //
    pCfgNew = (LPIMEPADAPPLETCONFIG)MemAlloc(ci * sizeof(IMEPADAPPLETCONFIG));
    if (pCfgNew == NULL)
        {
        return 0;
        }
    CopyMemory(pCfgNew, pCfgOrg, ci*sizeof(IMEPADAPPLETCONFIG));

    //
    // release if previous data is existing
    // pCfgOrg->hIcon should be deleted by client (CPad class)
    //
    CoTaskMemFree(pCfgOrg);

    *ppCfg = pCfgNew;

#if 0
    CMenuHelperCic* pcmh = new CMenuHelperCic(g_hInst, m_pImx);

    //
    // special menu item for HW TIP
    //
    HICON hIcon;
    BSTR bsz;
    if (GetHWInfo(&bsz, &hIcon))
        {
        pcmh->AppendItem(IDC_PAD_HW, MDS_TYPE_ICONDATA|MDS_TYPE_TEXTDATA, (ULONG_PTR)bsz, (ULONG_PTR)hIcon);

        SysFreeString(bsz);
        DestroyIcon(hIcon);

        //
        // separator
        //
        pcmh->AppendItem(MDS_VID_SEPARATOR, 0, (ULONG_PTR)0, (ULONG_PTR)0);
        }
#endif

    // Add Applet menu
    ciApplets = min(ci, (INT)(uidEnd-uidStart));
    
    for (int i = 0; i < ciApplets; i++)
        {
        LangBarInsertMenu(pMenu, uidStart + i, (pCfgNew+i)->wchTitle, FALSE, (HICON)(pCfgNew+i)->hIcon);
        }

    // Insert separator
    LangBarInsertSeparator(pMenu);

    // Insert Cancel
    LoadStringExW(g_hInst, IDS_CANCEL, szText, sizeof(szText)/sizeof(WCHAR));
    LangBarInsertMenu(pMenu, IDCANCEL, szText);
    
    return ciApplets;
}

#if 0
BOOL CPadCore::IsHWTIP(void)
{
    return FALSE;
#ifdef SPEC_CHANGE
    HRESULT hr;

    CLSID clsidHWTip;
    hr = CLSIDFromProgID( TEXT(L"MS.Handwriting.TIP"), &clsidHWTip );
    if( FAILED(hr) ) {
        return FALSE;
    }

    GUID guidWritingPad;
    hr = CLSIDFromProgID( TEXT(L"MS.Handwriting.WritingPad"), &guidWritingPad );
    if( FAILED(hr) ) {
        return FALSE;
    }

    
    ITfInputProcessorProfiles *pProfile;
    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (FAILED(hr)) {
        return FALSE;
    }
    //
    // enum tips
    //
    IEnumTfLanguageProfiles* pEnum;
    hr = pProfile->EnumLanguageProfiles( CKBDTip::GetLanguage(), &pEnum );
    if (FAILED(hr)) {
        pProfile->Release();
        return S_FALSE;
    }

    TF_LANGUAGEPROFILE lp;
    ULONG ulFetched;
    BOOL fExist = FALSE;

    while (pEnum->Next(1, &lp,  &ulFetched) == S_OK) {
        if( IsEqualCLSID( lp.clsid, clsidHWTip ) && IsEqualCLSID( lp.guidProfile, guidWritingPad) ) {
            fExist = TRUE;
            break;
        }
    }

    pEnum->Release();
    pProfile->Release();

    return fExist;
#endif // SPEC_CHANGE
}

BOOL CPadCore::InvokeHWTIP(void)
{
    if (IsHWTIP() == FALSE)
        {
        return FALSE;
        }

    HRESULT hr;
    CLSID clsidHWTip;
    hr = CLSIDFromProgID( TEXT(L"MS.Handwriting.TIP"), &clsidHWTip);
    if( FAILED(hr) ) {
        return FALSE;
    }

    GUID guidWritingPad;
    hr = CLSIDFromProgID( TEXT(L"MS.Handwriting.WritingPad"), &guidWritingPad );
    if( FAILED(hr) ) {
        return FALSE;
    }


    ITfInputProcessorProfiles *pProfile;
    hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, IID_ITfInputProcessorProfiles, (void **) &pProfile);
    if (FAILED(hr)) {
        return FALSE;
    }

    hr = pProfile->ActivateLanguageProfile(clsidHWTip, CKBDTip::GetLanguage(), guidWritingPad);

    pProfile->Release();

    return (SUCCEEDED(hr) ? TRUE : FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\mouse.cpp ===
/****************************************************************************
   MOUSE.CPP : Mouse callback

   History:
      02-OCT-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "icpriv.h"
#include "mes.h"

//+---------------------------------------------------------------------------
//
// _MouseCallback
//
//----------------------------------------------------------------------------

#define IMEMOUSE_NONE       0x00    // no mouse button was pushed
#define IMEMOUSE_LDOWN      0x01
#define IMEMOUSE_RDOWN      0x02
#define IMEMOUSE_MDOWN      0x04
#define IMEMOUSE_WUP        0x10    // wheel up
#define IMEMOUSE_WDOWN      0x20    // wheel down

/* static */
HRESULT CICPriv::_MouseCallback(ULONG uEdge, ULONG uQuadrant, DWORD dwBtnStatus, BOOL *pfEaten, void *pv)
{
    CEditSession2     *pes;
    ESSTRUCT         ess;
    HRESULT            hr;
    CICPriv         *pCicPriv = (CICPriv *)pv;

    if ((dwBtnStatus & (IMEMOUSE_LDOWN |IMEMOUSE_RDOWN | IMEMOUSE_MDOWN | IMEMOUSE_WDOWN)) && pCicPriv)
        {
        ESStructInit(&ess, ESCB_COMPLETE);

        if (pes = new CEditSession2(pCicPriv->GetIC(), pCicPriv->GetIMX(), &ess, CKorIMX::_EditSessionCallback2))
            {
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        }

    *pfEaten = fFalse;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\padcb.cpp ===
#include "private.h"
#include "pad.h"
#include "padcb.h"

void CPadCB::Initialize(void *pPad)
{
    m_pPad = pPad;
}

CPadCB::CPadCB()
{
    m_cRef = 1;
    m_pPad = NULL;
}

CPadCB::~CPadCB()
{

}

HRESULT __stdcall CPadCB::QueryInterface(REFIID refiid, LPVOID* ppv)
{
    if(refiid == IID_IUnknown)
        {
        *ppv = static_cast<IUnknown *>(this);
        }
    else if(refiid == IID_IImeCallback) 
        {
        *ppv = static_cast<IImeCallback *>(this);
        }
    else
        {
        *ppv = NULL;
        return E_NOINTERFACE;
        }
    
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall CPadCB::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall CPadCB::Release()
{
    if(InterlockedDecrement(&m_cRef) == 0)
        {
        //delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT __stdcall CPadCB::GetApplicationHWND(HWND *pHwnd)
{
    //----------------------------------------------------------------
    //Get Application's Window Handle.
    //----------------------------------------------------------------
    if(pHwnd)
        {
        *pHwnd = GetFocus();    // tmp tmp UI::GetActiveAppWnd();
        return S_OK;
        }
    return S_FALSE;
}

HRESULT __stdcall CPadCB::Notify(UINT notify, WPARAM wParam, LPARAM lParam)
{
#ifdef _DEBUG
    CHAR szBuf[256];
    wsprintf(szBuf, "CPadCB::NOtify notify [%d]\n", notify);
    OutputDebugString(szBuf);
#endif
    switch(notify) 
        {
    case IMECBNOTIFY_IMEPADOPENED:
    case IMECBNOTIFY_IMEPADCLOSED:
        //----------------------------------------------------------------
        //ImePad has Closed. repaint toolbar...
        //----------------------------------------------------------------
        //CPad::IMEPadNotify();
        if (m_pPad)
            {
            CPadCore* pPad = (CPadCore*)m_pPad;
            pPad->IMEPadNotify((notify == IMECBNOTIFY_IMEPADCLOSED) ? FALSE : TRUE);
            }
        break;
        
    default:
        break;
    }
    return S_OK;
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\modebias.cpp ===
/****************************************************************************
   MODEBIAS.CPP : Handling ModeBias. Sync conversion mode with Cicero's ModeBias

   History:
      2-JUL-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "immxutil.h"
#include "helpers.h"

/*---------------------------------------------------------------------------
    CKorIMX::SyncModeBias
---------------------------------------------------------------------------*/
BOOL CKorIMX::CheckModeBias(TfEditCookie ec, ITfContext *pic, ITfRange *pSelection)
{
    BOOL fChanged = fFalse;
    ITfReadOnlyProperty *pProp = NULL;
    ITfRange* pRange = NULL;
    VARIANT var;
    CICPriv* pPriv;
    HRESULT hr;

    if (pSelection == NULL)
        return fFalse;

    if (FAILED(hr = pic->GetAppProperty(GUID_PROP_MODEBIAS, &pProp)))
        return fFalse;

    pRange = pSelection;

    QuickVariantInit(&var);
    hr = pProp->GetValue(ec, pRange, &var);
    pProp->Release();

    if (!SUCCEEDED(hr))
        goto lEnd;

    Assert(var.vt == VT_I4);
    if (var.vt != VT_I4)
        goto lEnd;

    if ((pPriv = GetInputContextPriv(pic)) == NULL)
        goto lEnd;

    // check if changed
    if (pPriv->GetModeBias() != (TfGuidAtom)var.lVal)
        {
        GUID guidModeBias;

        fChanged = TRUE;

        // Keep modebias update
        pPriv->SetModeBias(var.lVal);

        // ISSUE: !!! WARNING !!!
        // Yutakas said, Aimm should handle this.
        // Kor IME set Open status automatically when conversion mode to Hangul or Full shape.
        // GUID_COMPARTMENT_KEYBOARD_OPENCLOSE  has higher priority than modebias

        GetGUIDFromGUIDATOM(&m_libTLS, (TfGuidAtom)var.lVal, &guidModeBias);

        // Multiple bias will bot be allowed.
        // GUID_MODEBIAS_NONE == ignore modebias
        if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_NONE))
            goto lEnd;

        // Office 10 #182239
        if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_HANGUL))
            {
            Assert(IsOn(pic) == fTrue);
            SetConvMode(pic, TIP_HANGUL_MODE);
            goto lEnd;
            }

        if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_FULLWIDTHHANGUL))
            {
            Assert(IsOn(pic) == fFalse);
            SetConvMode(pic, TIP_HANGUL_MODE | TIP_JUNJA_MODE);
            goto lEnd;
            }

        if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_FULLWIDTHALPHANUMERIC))
            {
            Assert(IsOn(pic) == fTrue);
            SetConvMode(pic, TIP_JUNJA_MODE);
            goto lEnd;
            }

        if (IsEqualGUID(guidModeBias, GUID_MODEBIAS_HALFWIDTHALPHANUMERIC))
            {
            Assert(IsOn(pic) == fFalse);
            SetConvMode(pic, TIP_ALPHANUMERIC_MODE);
            goto lEnd;
            }
        
        }

lEnd:
    VariantClear(&var);
    return fChanged;
}

/*---------------------------------------------------------------------------
    CKorIMX::InitializeModeBias
---------------------------------------------------------------------------*/
BOOL CKorIMX::InitializeModeBias(TfEditCookie ec, ITfContext *pic)
{
    ITfRange* pSelection;
    
    if (pic == NULL)
        return fFalse;

    //
    // current selection is in the pRangeIP?
    //
    if (FAILED(GetSelectionSimple(ec, pic, &pSelection)))
        return fFalse;

    //
    // check mode bias
    //
    CheckModeBias(ec, pic, pSelection);

    SafeRelease(pSelection);    // release it

    return fTrue;
}

/*---------------------------------------------------------------------------
    CKorIMX::CheckModeBias

    This will submit async call of InitializeModeBias
---------------------------------------------------------------------------*/
void CKorIMX::CheckModeBias(ITfContext* pic)
{
    CEditSession2 *pes;
    ESSTRUCT ess;
    HRESULT  hr;

    ESStructInit(&ess, ESCB_INIT_MODEBIAS);
    
    if ((pes = new CEditSession2(pic, this, &ess, _EditSessionCallback2)) != NULL)
        {
        pes->Invoke(ES2_READONLY | ES2_SYNC, &hr);
        pes->Release();
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\padcb.h ===
#ifndef __PADCB_H__
#define __PADCB_H__

#include "../../fecommon/include/iimecb.h"

class CPadCB : public IImeCallback
{
public:    
    //----------------------------------------------------------------
    //IUnknown
    //----------------------------------------------------------------
    virtual HRESULT __stdcall QueryInterface(REFIID riid, LPVOID* ppvObj);
    virtual ULONG    __stdcall AddRef();
    virtual ULONG   __stdcall Release();
    //----------------------------------------------------------------
    //IImeConnectionPoint method
    //----------------------------------------------------------------
    virtual HRESULT __stdcall GetApplicationHWND(HWND *pHWND);
    virtual HRESULT __stdcall Notify(UINT notify, WPARAM wParam, LPARAM lParam);


    CPadCB();
    ~CPadCB();

    void Initialize(void* pPad);

private:    
    void *m_pPad;
    LONG  m_cRef; 
};

typedef CPadCB*  LPCPadCB;

//----------------------------------------------------------------
// IImeCallback::Notify()'s notify
// IMECBNOTIFY_IMEPADOPENED
// WPARAM wParam: not used. always 0
// LPARAM lParam: not used. always 0
//----------------------------------------------------------------
#define IMECBNOTIFY_IMEPADOPENED	0

//----------------------------------------------------------------
// IImeCallback::Notify()'s notify
// IMECBNOTIFY_IMEPADCLOSED
// WPARAM wParam: not used. always 0
// LPARAM lParam: not used. always 0
//----------------------------------------------------------------
#define IMECBNOTIFY_IMEPADCLOSED	1

#endif //__PADCB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\private.h ===
//
//  Private.h
//
//  Contents:   Private header for korimx project.
//

#if !defined (__PRIVATE_H__INCLUDED_)
#define __PRIVATE_H__INCLUDED_

#define _OLEAUT32_

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>
#include <olectl.h>
#include <debug.h>
#include <initguid.h>
#include "common.h"
#include "crtfree.h"
#include "msctf.h"
#include "ipoint1.h"

#include "mem.h" // must be last

#define fTrue   1
#define fFalse  0

#endif  // __PRIVATE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\skbdkor.h ===
//
//  SOFTKBD.H
//
//  History:
//      19-SEP-2000 CSLim Created

#if !defined (__SKBDKOR_H__INCLUDED_)
#define __SKBDKOR_H__INCLUDED_

#include "softkbd.h"
#include "softkbdes.h"

typedef  struct tagSoftLayout
{
    DWORD   dwSoftKbdLayout;
    BOOL    fStandard;
    DWORD   dwNumLabels;  // Number of Label status. 
    DWORD   dwCurLabel;
    CSoftKeyboardEventSink  *pskbdes;
    DWORD   dwSkbdESCookie;
} SOFTLAYOUT;


// SoftKbd type list
#define  NON_LAYOUT                     	0

//#define  SOFTKBD_US_STANDARD    			1
// Korean customized keyboard layouts
//#define  SOFTKBD_KOR_HANGUL_2BEOLSIK		500
//#define  SOFTKBD_KOR_HANGUL_3BEOLSIK390		501
//#define  SOFTKBD_KOR_HANGUL_3BEOLSIKFINAL	502

#define   NUM_PICTURE_KEYS    19
// Type definition for picture keys in standard soft keyboards.
typedef struct  _tagPictureKey 
{
    UINT      uScanCode;   // same as KeyId in the XML file
    UINT      uVkey;
//    LPWSTR    PictBitmap;
}  PICTUREKEY,  *LPPICTUREKEY;

extern  PICTUREKEY  gPictureKeys[NUM_PICTURE_KEYS+1];

// Key IDs
#define  KID_LWINLOGO       0xE05B
#define  KID_RWINLOGO       0xE05C
#define  KID_APPS           0xE05D

#define  KID_LEFT           0xE04B
#define  KID_RIGHT          0xE04D
#define  KID_UP             0xE048
#define  KID_DOWN           0xE050

#define  KID_ESC            0x01
#define  KID_BACK           0x0E
#define  KID_TAB            0x0F
#define  KID_CAPS           0x3A
#define  KID_ENTER          0x1C
#define  KID_LSHFT          0x2A
#define  KID_RSHFT          0x36
#define  KID_CTRL           0x1D
#define  KID_RCTRL          0xE01D
#define  KID_ALT            0x38
#define  KID_RALT           0xE038
#define  KID_SPACE          0x39

#define  KID_DELETE         0xE053

#define  KID_F1             0x3B
#define  KID_F2             0x3C
#define  KID_F3             0x3D
#define  KID_F4             0x3E
#define  KID_F5             0x3F
#define  KID_F6             0x40
#define  KID_F7             0x41
#define  KID_F8             0x42
#define  KID_F9             0x43
#define  KID_F10            0x44
#define  KID_F11            0x57
#define  KID_F12            0x58

#define  KID_CONVERT        0x79
#define  KID_NONCONVERT     0x7B
#define  KID_KANA           0x70
#define  KID_FULLHALF       0x29    // special used by Japan 106 Key

#endif // __SKBDKOR_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\skbdkor.cpp ===
/****************************************************************************
   SOFTKBD.CPP : 
   
   History:
      19-SEP-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "korimx.h"
#include "softkbd.h"
#include "skbdkor.h"
#include "softkbdes.h"
#include "gdata.h"
#include "helpers.h"

PICTUREKEY  gPictureKeys[NUM_PICTURE_KEYS+1] = 
{
    // uScanCode,    uVKey
    { KID_LWINLOGO,  VK_LWIN    },
    { KID_RWINLOGO,  VK_RWIN    },
    { KID_APPS,      VK_APPS    },

    { KID_LEFT,      VK_LEFT    },
    { KID_RIGHT,     VK_RIGHT   },
    { KID_UP,        VK_UP      },
    { KID_DOWN,      VK_DOWN    },

    { KID_ESC,       VK_ESCAPE  },

    { KID_BACK,      VK_BACK    },
    { KID_TAB,       VK_TAB     },
    { KID_CAPS,      VK_CAPITAL },
    { KID_ENTER,     VK_RETURN  },
    { KID_LSHFT,     VK_SHIFT   },
    { KID_RSHFT,     VK_SHIFT   },
    { KID_CTRL,      VK_CONTROL },
    { KID_RCTRL,     VK_CONTROL },
    { KID_ALT,       VK_MENU    },
    { KID_RALT,      VK_RMENU   },
    { KID_DELETE,    VK_DELETE  },

    { 0,0 }
};

/*---------------------------------------------------------------------------
    CKorIMX::InitializeSoftKbd
---------------------------------------------------------------------------*/
HRESULT CKorIMX::InitializeSoftKbd()
{
    DWORD    dwFileLen;
    WCHAR    wszModuleFile[MAX_PATH];
    CHAR     szModuleFile[MAX_PATH];
    INT         wScreenWidth, wScreenHeight;
    INT         left, top, width, height;  
    RECT     rcWork;
    CIMEData ImeData;
    UINT     uiCurBeolSik;
    // SKD resoulrce ID string
    static   LPWSTR rgwzKorXMLResStr[3] = { L"IDSKD_2BEOLSIK", L"IDSKD_3BEOLSIK390", L"IDSKD_3BEOLSIKFINAL" };

    HRESULT  hr;
    
    // if Already initialized
    if (m_fSoftKbdEnabled)
        return S_OK;

    // Create SoftKbd object
    hr = CoCreateInstance(CLSID_SoftKbd, NULL, CLSCTX_INPROC_SERVER, IID_ISoftKbd, (void**)&m_pSoftKbd);
    if (FAILED(hr))
        {
        // assert(0);
        return hr;
        }

    m_pSoftKbd->Initialize();

    // initialize Standard soft layout and Symbol Soft Layout.
    m_KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
    m_KbdStandard.fStandard       = TRUE;
    m_KbdStandard.dwNumLabels     = 0;   // for standard, this field is not really used.
    m_KbdStandard.dwCurLabel      = 0;
    m_KbdStandard.pskbdes         = NULL; // standard layout doesn't supply sftkbd event sink.
    m_KbdStandard.dwSkbdESCookie  = 0;

    // Get current user selection
    uiCurBeolSik = ImeData.GetCurrentBeolsik();

    // US Standard layout
    m_KbdHangul.fStandard   = fFalse;
    m_KbdHangul.dwNumLabels = 2;
    m_KbdHangul.dwCurLabel  = 0;

    // Load Keyboard layout file from resource
    dwFileLen = GetModuleFileNameA(g_hInst, szModuleFile, MAX_PATH);
    if (dwFileLen == 0)
        {
        hr = E_FAIL;
        goto Exit3;
        }

    MultiByteToWideChar(CP_ACP, 0, szModuleFile, -1, wszModuleFile, MAX_PATH);

    hr = m_pSoftKbd->CreateSoftKeyboardLayoutFromResource(wszModuleFile, L"SKDFILE", rgwzKorXMLResStr[uiCurBeolSik], 
                                                        &(m_KbdHangul.dwSoftKbdLayout));
    if (FAILED(hr))
        goto Exit3;

    // Create ISoftKeyboardEventSink for Hangul layout
    m_KbdHangul.pskbdes = new CSoftKeyboardEventSink(this, m_KbdHangul.dwSoftKbdLayout);
    if (m_KbdHangul.pskbdes == NULL )
        {
        hr = E_FAIL;
        goto Exit3;
        }

    hr = m_pSoftKbd->AdviseSoftKeyboardEventSink(m_KbdHangul.dwSoftKbdLayout,
                                                  IID_ISoftKeyboardEventSink,
                                                  m_KbdHangul.pskbdes,
                                                  &(m_KbdHangul.dwSkbdESCookie));

    if (FAILED(hr))
        goto Exit2;

    m_psftkbdwndes = new CSoftKbdWindowEventSink(this);

    if (m_psftkbdwndes == NULL)
        {
        hr = E_FAIL;
        goto Exit2;
        }

    // To handle softkbd window Open/Close event
    hr = m_pSoftKbd->AdviseSoftKeyboardEventSink(0, IID_ISoftKbdWindowEventSink, m_psftkbdwndes, &m_dwSftKbdwndesCookie);
    if (FAILED(hr))
        goto Exit1;

    width  = 400;
    height = 172;

    if (FAILED(GetSoftKBDPosition(&left, &top)))
        {
        // the compartment is not initialize.
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0 );
        wScreenWidth = (INT)(rcWork.right - rcWork.left + 1);
        wScreenHeight = (INT)(rcWork.bottom - rcWork.top + 1);
        left = wScreenWidth - width -2;
        top = wScreenHeight - height - 1;
        }
 
    hr = m_pSoftKbd->CreateSoftKeyboardWindow(m_hOwnerWnd,TITLEBAR_GRIPPER_BUTTON, left, top, width, height);
    if (FAILED(hr))
        goto Exit;

    SetSoftKBDPosition(left, top);

    m_fSoftKbdEnabled = fTrue;

    return hr;

// Error handling
Exit:
    delete m_psftkbdwndes;
    m_psftkbdwndes = 0;

Exit1:
    m_pSoftKbd->UnadviseSoftKeyboardEventSink(m_dwSftKbdwndesCookie);
Exit2:
    delete m_KbdHangul.pskbdes;
    m_KbdHangul.pskbdes = NULL;

Exit3:
       SafeReleaseClear(m_pSoftKbd);
    return hr;
}

/*---------------------------------------------------------------------------
    CKorIMX::TerminateSoftKbd
---------------------------------------------------------------------------*/
void  CKorIMX::TerminateSoftKbd()
{
    SetSoftKBDOnOff(fFalse);

    if (m_pSoftKbd)
       m_pSoftKbd->DestroySoftKeyboardWindow();

    m_fSoftKbdEnabled = fFalse;

    if (m_pSoftKbd)
        {
        if (m_KbdHangul.pskbdes)
            {
            m_pSoftKbd->UnadviseSoftKeyboardEventSink(m_KbdHangul.dwSkbdESCookie);
            delete m_KbdHangul.pskbdes;
            }

        m_pSoftKbd->UnadviseSoftKeyboardEventSink(m_dwSftKbdwndesCookie);
        
        delete m_psftkbdwndes;
        m_psftkbdwndes = 0;
        
        SafeReleaseClear(m_pSoftKbd);
        }
}

#if 0
/*---------------------------------------------------------------------------
    CKorIMX::ToggleSoftKbd
---------------------------------------------------------------------------*/
void CKorIMX::ToggleSoftKbd()
{
 if (m_fSoftKbdEnabled)
     TerminateSoftKbd();
 else
     InitializeSoftKbd();
}

/*---------------------------------------------------------------------------
    CKorIMX::OnActivatedSoftKbd
---------------------------------------------------------------------------*/
void CKorIMX::OnActivatedSoftKbd(BOOl fActivated)
{
    if (fActivated)
        {
        if (GetSoftKBDOnOff())
            m_pSoftKbd->ShowSoftKBDWindow(fTrue);
        }
    else
        {
        if (GetSoftKBDOnOff())
            m_pSoftKbd->ShowSoftKeyboard(fFalse);
        }
}
#endif



/*---------------------------------------------------------------------------
    CKorIMX::ShowSoftKBDWindow
    Show or Hide the soft keyboard window based on current setting.
---------------------------------------------------------------------------*/
HRESULT CKorIMX::ShowSoftKBDWindow(BOOL  fShow)
{
    HRESULT hr = S_OK;

       // call the initialize function to get the ISoftKbd.
    if (fShow && m_fSoftKbdEnabled == fFalse)
        InitializeSoftKbd( );

    if (m_pSoftKbd == NULL)
        return E_FAIL;

    if (fShow)
        {
        //DWORD   dwSoftLayout;

        if ((GetConvMode(GetIC()) & TIP_HANGUL_MODE) == 0)
            {
            // m_KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
            // if (FAILED(hr))
            //    return hr;
               // dwSoftLayout = m_KbdStandard.dwSoftKbdLayout;
            // _CurLayout = m_KbdStandard.dwSoftKbdLayout;

            hr = m_pSoftKbd->SelectSoftKeyboard(m_KbdStandard.dwSoftKbdLayout);
            if (FAILED(hr))
                return hr;

            m_pSoftKbd->SetKeyboardLabelText(GetKeyboardLayout(0));
            if (FAILED(hr))
                return hr;
            }
        else
            {
            hr = m_pSoftKbd->SelectSoftKeyboard(m_KbdHangul.dwSoftKbdLayout);
            if (FAILED(hr))
                return hr;
            m_pSoftKbd->SetKeyboardLabelTextCombination(m_KbdHangul.dwCurLabel);
            if (FAILED(hr))
                return hr;
            }
            
        hr = m_pSoftKbd->ShowSoftKeyboard(fTrue);
        if (FAILED(hr))
            return hr;
        }
    else
        {
        m_pSoftKbd->ShowSoftKeyboard(fFalse);
        }

#if 0
        if ( _CurKbdType  == KBDTYPE_STANDARD ) 
        {
            // Standard soft kbd was selected.
            WORD   prmlangid;

            prmlangid = PRIMARYLANGID(_langid);

            switch ( prmlangid ) {

            case LANG_JAPANESE  :
                // Lang JPN is activated.
                // select the standard layout to J 106-k.
                _KbdStandard.dwSoftKbdLayout = SOFTKBD_JPN_STANDARD;
                break;

            case LANG_AZERI   :
            case LANG_BELARUSIAN :
            case LANG_CHINESE :
            case LANG_KOREAN  :
            case LANG_RUSSIAN :
            case LANG_THAI    :
            case LANG_URDU    :
            case LANG_UZBEK   :
                _KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
                break;

            case LANG_ENGLISH :
                if ( SUBLANGID(_langid) != SUBLANG_ENGLISH_US )
                    _KbdStandard.dwSoftKbdLayout = SOFTKBD_EURO_STANDARD;
                else
                    _KbdStandard.dwSoftKbdLayout = SOFTKBD_US_STANDARD;
                break;

            default           :
                _KbdStandard.dwSoftKbdLayout = SOFTKBD_EURO_STANDARD;
                break;
            }

            // the current layout is standard layout.
            // we need to set the correct standard layout id based on current lang profile.

            dwSoftLayout = _KbdStandard.dwSoftKbdLayout;
            _CurLayout = dwSoftLayout;

            CHECKHR(_SoftKbd->SelectSoftKeyboard(dwSoftLayout));
            CHECKHR(_SoftKbd->SetKeyboardLabelText(GetKeyboardLayout(0)));
        }
        else if ( _CurKbdType  == KBDTYPE_SYMBOL)
        {
            // This is symbol soft keyboard layout
            //
            DWORD   dwCurLabel;
            dwSoftLayout = _KbdSymbol.dwSoftKbdLayout;
            dwCurLabel = _KbdSymbol.dwCurLabel;
            CHECKHR(_SoftKbd->SelectSoftKeyboard(dwSoftLayout));
            CHECKHR(_SoftKbd->SetKeyboardLabelTextCombination(dwCurLabel));

        }

        // TIP is ON, so we need to show soft keyboard.
        CHECKHR(_SoftKbd->ShowSoftKeyboard(TRUE));
    }
    else
    {
        // TIP is going to close.
        // close the soft keyboard window also.
        CHECKHR(_SoftKbd->ShowSoftKeyboard(FALSE));
    }

CleanUp:
#endif

    return  hr;

}

/*---------------------------------------------------------------------------
    CKorIMX::SoftKbdOnThreadFocusChange
---------------------------------------------------------------------------*/
void CKorIMX::SoftKbdOnThreadFocusChange(BOOL fSet)
{
    if (fSet)
        {
        // Restore the ON/OFF status before KillThreadFocus( )
        if (m_pSoftKbd)
            {
            if (m_fSoftKbdOnOffSave) 
                {
                // adjust the window position.
                int     xWnd, yWnd;
                WORD    width=0, height=0;
                POINT   OldPoint;
                HRESULT hr;

                m_pSoftKbd->GetSoftKeyboardPosSize(&OldPoint, &width, &height);
                hr = GetSoftKBDPosition(&xWnd, &yWnd);

                if (hr == S_OK)
                    {
                    if ((xWnd != OldPoint.x) || (yWnd != OldPoint.y))
                        {
                        POINT  NewPoint;

                        NewPoint.x = xWnd;
                        NewPoint.y = yWnd;
                        m_pSoftKbd->SetSoftKeyboardPosSize(NewPoint, width, height);
                        }
                    }

                ShowSoftKBDWindow(fTrue);
                }
            else
                m_pSoftKbd->ShowSoftKeyboard(fFalse);
            }
        }
    else
        {
        // keep the ON/OFF status so that OnSetThreadFocus( ) can restore it later
        m_fSoftKbdOnOffSave = GetSoftKBDOnOff();

        if (m_pSoftKbd)
            m_pSoftKbd->ShowSoftKeyboard(fFalse);

        // release all the modifier keys  except lock keys.  that is , Shift, Alt, Ctrl, 
        keybd_event((BYTE)VK_SHIFT, (BYTE)KID_LSHFT, (DWORD)KEYEVENTF_KEYUP, 0);
        keybd_event((BYTE)VK_MENU,  (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);
        keybd_event((BYTE)VK_LMENU, (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);
        keybd_event((BYTE)VK_RMENU, (BYTE)KID_RALT, (DWORD)KEYEVENTF_KEYUP, 0);
        keybd_event((BYTE)VK_CONTROL, (BYTE)KID_CTRL, (DWORD)KEYEVENTF_KEYUP, 0);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\server.cpp ===
/****************************************************************************
   SERVER.CPP : COM server functionality

   History:
      15-NOV-1999 CSLim Created
****************************************************************************/

#include "private.h"
#include "korimx.h"
#include "regsvr.h"
#include "regimx.h"
#include "init.h"
#include "gdata.h"
#include "catutil.h"
#include "insert.h"
#include "immxutil.h"
#include "hanja.h"

#if !defined(NOCLIB) && defined(_M_IX86)
extern "C" BOOL WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);
#endif


#ifdef DEBUG
DWORD g_dwThreadDllMain = 0;
#endif

void DllAddRef(void);
void DllRelease(void);

LONG g_cRefDll = 0;

//
//  CClassFactory declaration with IClassFactory Interface
//
class CClassFactory : public IClassFactory
{
public:
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory methods
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
    virtual STDMETHODIMP LockServer(BOOL fLock);

    // Constructor & Destructor
    CClassFactory(REFCLSID rclsid, HRESULT (*pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj));
    ~CClassFactory();

public:
    REFCLSID _rclsid;
    HRESULT (*_pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj);
};

CClassFactory::CClassFactory(REFCLSID rclsid, HRESULT (*pfnCreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppvObj))
    : _rclsid( rclsid ), _pfnCreateInstance( pfnCreateInstance )
{
    DebugMsg(DM_TRACE, TEXT("constructor of CClassFactory 0x%08x"), this);
}

CClassFactory::~CClassFactory()
{
    DebugMsg(DM_TRACE, TEXT("destructor of CClassFactory 0x%08x"), this);
}

STDAPI CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("CClassFactory::QueryInterface called."));
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IClassFactory*);
        DllAddRef();
        return NOERROR;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDAPI_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    DebugMsg(DM_TRACE, TEXT("CClassFactory::AddRef called. g_cRefDll=%d"), g_cRefDll);
    return g_cRefDll;
}

STDAPI_(ULONG) CClassFactory::Release()
{
    DllRelease();
    DebugMsg(DM_TRACE, TEXT("CClassFactory::Release called. g_cRefDll=%d"), g_cRefDll);
    return g_cRefDll;
}

STDAPI CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("CClassFactory::CreateInstance called."));
    return this->_pfnCreateInstance(pUnkOuter, riid, ppvObj);
}

STDAPI CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    DebugMsg(DM_TRACE, TEXT("CClassFactory::LockServer(%s) to %d"), fLock ? TEXT("LOCK") : TEXT("UNLOCK"), g_cRefDll);
    return S_OK;
}

//
//  Build Global Objects
//

CClassFactory *g_ObjectInfo[1] = { NULL };

void BuildGlobalObjects(void)
{
    DebugMsg(DM_TRACE, TEXT("BuildGlobalObjects called."));

    // Build CClassFactory Objects
    g_ObjectInfo[0] = new CClassFactory(CLSID_KorIMX, CKorIMX::CreateInstance);

    // You can add more object info here.
    // Don't forget to increase number of item for g_ObjectInfo[],
    // and add function prototype to private.h
}

void FreeGlobalObjects(void)
{
    DebugMsg(DM_TRACE, TEXT("FreeGlobalObjects called."));
    // Free CClassFactory Objects
    for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
    {
        if (NULL != g_ObjectInfo[i])
        {
            delete g_ObjectInfo[i];
            g_ObjectInfo[i] = NULL;
        }
    }
}

/*---------------------------------------------------------------------------
    DllMain
---------------------------------------------------------------------------*/
STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    WNDCLASSEX  wndclass;

#if DEBUG
    g_dwThreadDllMain = GetCurrentThreadId();
#endif
    
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
#if !defined(NOCLIB) && defined(_M_IX86)
            _CRT_INIT(hInstance, dwReason, pvReserved);
#endif
            CcshellGetDebugFlags();
            Dbg_MemInit(TEXT("KORIMX"), NULL);
           
            g_hInst = hInstance;

            InitializeCriticalSection(&g_cs);

            ZeroMemory(&wndclass, sizeof(wndclass));
            wndclass.cbSize        = sizeof(wndclass);
            wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
            wndclass.hInstance     = hInstance;
            wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);

            wndclass.lpfnWndProc   = CKorIMX::_OwnerWndProc;
            wndclass.lpszClassName = c_szOwnerWndClass;
            RegisterClassEx(&wndclass);

            // Initialize Shared memory
            CIMEData::InitSharedData();

            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            UnregisterClass(c_szOwnerWndClass, g_hInst);

            DeleteCriticalSection(&g_cs);

#if !defined(NOCLIB) && defined(_M_IX86)
            _CRT_INIT(hInstance, dwReason, pvReserved);
#endif
            // Close lex file if has opened ever.
            CloseLex();
            
            // Close shared memory
            CIMEData::CloseSharedMemory();

            // This should be last.
            Dbg_MemUninit();
            break;

        case DLL_THREAD_DETACH:
            break;
    }

#if DEBUG
    g_dwThreadDllMain = 0;
#endif

    return TRUE;
}

/*---------------------------------------------------------------------------
    DllAddRef
---------------------------------------------------------------------------*/
void DllAddRef(void)
{
    InterlockedIncrement(&g_cRefDll);
    ASSERT(1000 > g_cRefDll);   // reasonable upper limit
    DllInit();
}

/*---------------------------------------------------------------------------
    DllRelease
---------------------------------------------------------------------------*/
void DllRelease(void)
{
    InterlockedDecrement(&g_cRefDll);
    if (0 == g_cRefDll)
        FreeGlobalObjects();
    ASSERT(0 <= g_cRefDll);     // don't underflow
    DllUninit();
}

/*---------------------------------------------------------------------------
    DllGetClassObject
---------------------------------------------------------------------------*/
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppvObj)
{
    DebugMsg(DM_TRACE, TEXT("DllGetClassObject called."));
    if (0 == g_cRefDll)
        BuildGlobalObjects();

    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (int i = 0; i < ARRAYSIZE(g_ObjectInfo); i++)
        {
            if (NULL != g_ObjectInfo[i] && IsEqualGUID(rclsid, g_ObjectInfo[i]->_rclsid))
            {
                *ppvObj = (void *)g_ObjectInfo[i];
                DllAddRef();    // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }
    *ppvObj = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

/*---------------------------------------------------------------------------
    DllCanUnloadNow
---------------------------------------------------------------------------*/
STDAPI DllCanUnloadNow(void)
{
    if (0 < g_cRefDll)
        return S_FALSE;
    DebugMsg(DM_TRACE, TEXT("DllCanUnloadNow returning S_OK"));
    return S_OK;
}

// TIP Categories to be added
const REGISTERCAT c_rgRegCat[] =
{
    {&GUID_TFCAT_DISPLAYATTRIBUTEPROVIDER,     &CLSID_KorIMX},
    {&GUID_TFCAT_TIP_KEYBOARD,                 &CLSID_KorIMX},
    {&GUID_TFCAT_PROPSTYLE_CUSTOM,             &GUID_PROP_OVERTYPE},
    {NULL, NULL}
};


// TIP Profile name
const REGTIPLANGPROFILE c_rgProf[] =
{
    { MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT), &GUID_Profile, SZ_TIPDISPNAME, SZ_TIPMODULENAME, (IDI_UNIKOR-IDI_ICONBASE), IDS_PROFILEDESC },
    {0, &GUID_NULL, L"", L"", 0, 0}
};

BOOL FIsAvailable( REFCLSID refclsid, BOOL fLocalSvr );

/*---------------------------------------------------------------------------
    DllRegisterServer
---------------------------------------------------------------------------*/
STDAPI DllRegisterServer(void)
{
    TCHAR achPath[MAX_PATH+1];
    HRESULT hr = E_FAIL;

    TFInitLib();
    
    if (GetModuleFileName(g_hInst, achPath, ARRAYSIZE(achPath)) == 0)
        goto Exit;

    if (!RegisterServer(CLSID_KorIMX, SZ_TIPSERVERNAME, achPath, TEXT("Apartment"), NULL))
        goto Exit;

    if (!RegisterTIP(g_hInst, CLSID_KorIMX, SZ_TIPNAME, c_rgProf))
        goto Exit;

    if (FAILED(RegisterCategories(CLSID_KorIMX, c_rgRegCat)))
        goto Exit;

    hr = S_OK;

Exit:
    TFUninitLib();
    return hr;
}

/*---------------------------------------------------------------------------
    DllUnregisterServer
---------------------------------------------------------------------------*/
STDAPI DllUnregisterServer(void)
{
    HRESULT hr = E_FAIL;

    TFInitLib();

    if (FAILED(hr = RegisterServer(CLSID_KorIMX, NULL, NULL, NULL, NULL) ? S_OK : E_FAIL))
        goto Exit;

    if (FAILED(UnregisterCategories(CLSID_KorIMX, c_rgRegCat)))
        goto Exit;

    if (!UnregisterTIP(CLSID_KorIMX))
        goto Exit;

    hr = S_OK;

Exit:
    TFUninitLib();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\range.cpp ===
//
// range.cpp
//

#include "private.h"
#include "globals.h"
#include "korimx.h"
#include "xstring.h"
#include "immxutil.h"
#include "helpers.h"
#include "kes.h"
#include "mes.h"
#include "editcb.h"

#if 0
void CKorIMX::BackupRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRange)
{
    CICPriv *picp = GetICPriv(pic);
    
    if (pic && picp && pRange) 
        {
        ITfRangeBackup* pBackupRange = NULL;

        //
        // release previuos
        //
        pBackupRange = picp->GetBackupRange();
        if (pBackupRange) 
            SafeReleaseClear(pBackupRange);

        //
        // create new backup range
        //
        pic->CreateRangeBackup(ec, pRange, &pBackupRange);
        picp->SetBackupRange(pBackupRange);

        if (pBackupRange == NULL)
            return;
        }
}

VOID CKorIMX::RestoreRange(TfEditCookie ec, ITfContext *pic)
{
    CICPriv *picp = GetICPriv(pic);

    if (pic && picp) 
        {
        ITfRangeBackup *pBackupRange = picp->GetBackupRange();
        ITfRange       *pRange;

        if (pBackupRange == NULL)
            return; // no backup is exist

        pBackupRange->GetRange(&pRange);
        pBackupRange->Restore(ec, pRange);        // restore to original
        pRange->Release();
        }
}

VOID CKorIMX::SetIPRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRange)
{
    CICPriv *picp = GetInputContextPriv(pic);
    
    if (picp)
        {
        ITfRange* pClone = NULL;
        // delete previous IPRange
        SafeRelease(picp->GetActiveRange());

        if (pRange)
            {
            Assert(m_ptim != NULL);
            pRange->Clone(&pClone);
            pClone->SetGravity(ec, TF_GRAVITY_FORWARD, TF_GRAVITY_BACKWARD);
            } 
        else 
            {
            // delete property store
            // ResetDiscard();
            }

        picp->SetActiveRange(pClone);
        }
}


ITfRange* CKorIMX::GetIPRange(TfEditCookie ec, ITfContext *pic)
{
    CICPriv *picp = GetInputContextPriv(pic);
    
    if (picp) 
        {
        ITfRange* pRange;
        ITfRange* pClone = NULL;

        pRange = picp->GetActiveRange();

        if (pRange)
            {
            pRange->Clone(&pClone);
            pClone->SetGravity(ec, TF_GRAVITY_BACKWARD, TF_GRAVITY_FORWARD);
            }

        return pClone;
        }

    return NULL;
}

ITfRange* CKorIMX::CreateIPRange(TfEditCookie ec, ITfContext *pic, ITfRange* pRangeOrg)
{
    ITfRange* pRangeIP;

    if (pRangeOrg == NULL)
        return NULL;

    Assert(m_ptim != NULL);

    pRangeOrg->Clone(&pRangeIP);

    SetIPRange(ec, pic, pRangeIP);    // register
    pRangeIP->SetGravity(ec, TF_GRAVITY_BACKWARD, TF_GRAVITY_FORWARD);
    
    return pRangeIP;
}

BOOL CKorIMX::FlushIPRange(TfEditCookie ec, ITfContext *pic)
{
    // reset range
    SetIPRange(ec, pic, NULL);    // reset

    // clear attribute range
    // ClearAttr(ec, pic, pIPRange);

    return FALSE;
}
#endif


//+---------------------------------------------------------------------------
//
// OnCompositionTerminated
//
// Cicero calls this method when one of our compositions is terminated.
//----------------------------------------------------------------------------
STDAPI CKorIMX::OnCompositionTerminated(TfEditCookie ec, ITfComposition *pComposition)
{
    ITfRange         *pRange;
    ITfContext         *pic;
    CEditSession2     *pes;
    ESSTRUCT            ess;
    HRESULT            hr;

    // finalize the covered text.
    // nb:  there are no rules about what a tip has to do when it recevies this
    // callback.  We will clear out the display attributes arbirarily and because
    // it provides visual feedback for testing.

    pComposition->GetRange(&pRange);
    pRange->GetContext(&pic);


    hr = E_OUTOFMEMORY;

    ESStructInit(&ess, ESCB_COMPLETE);

    ess.pRange = pRange;
    
    if (pes = new CEditSession2(pic, this, &ess, CKorIMX::_EditSessionCallback2))
        {
        // Word will not allow synchronous lock at this point.
        pes->Invoke(ES2_READWRITE | ES2_SYNC, &hr);
        pes->Release();
        }

    pRange->Release();
    pic->Release();

    return S_OK;
}

ITfComposition * CKorIMX::GetIPComposition(ITfContext *pic)
{
    CICPriv *picp = GetInputContextPriv(pic);
    
    if (picp)
        return picp->GetActiveComposition();

    return NULL;
}

ITfComposition * CKorIMX::CreateIPComposition(TfEditCookie ec, ITfContext *pic, ITfRange* pRangeComp)
{
    ITfContextComposition *picc;
    ITfComposition     *pComposition;
    CICPriv          *pICPriv;    
    HRESULT hr;

    if (pRangeComp == NULL)
        return NULL;
    
    hr = pic->QueryInterface(IID_ITfContextComposition, (void **)&picc);
    Assert(hr == S_OK);

    if (picc->StartComposition(ec, pRangeComp, this, &pComposition) == S_OK)
        {
        if (pComposition != NULL) // NULL if the app rejects the composition
            {
            CICPriv *picp = GetInputContextPriv(pic);

            if (picp)
                SetIPComposition(pic, pComposition);
            else 
                {
                pComposition->Release();
                pComposition = NULL;
                }
            }
        }
    picc->Release();

    // Create Mouse sink only for AIMM
       if (GetAIMM(pic) && (pICPriv = GetInputContextPriv(pic)) != NULL)
        {
        CMouseSink *pMouseSink;

        // Create Mouse sink
        if ((pMouseSink = pICPriv->GetMouseSink()) != NULL)
            {
            pMouseSink->_Unadvise();
            pMouseSink->Release();
            pICPriv->SetMouseSink(NULL);
            }
            
        if (pMouseSink = new CMouseSink(CICPriv::_MouseCallback, pICPriv))
            {
            pICPriv->SetMouseSink(pMouseSink);
            // set inward gravity to hug the text
            pRangeComp->SetGravity(ec, TF_GRAVITY_FORWARD, TF_GRAVITY_BACKWARD);
            pMouseSink->_Advise(pRangeComp, pic);
            }
        }

    return pComposition;
}


void CKorIMX::SetIPComposition(ITfContext *pic, ITfComposition *pComposition)
{
    CICPriv *picp = GetInputContextPriv(pic);
    
    if (picp)
        picp->SetActiveComposition(pComposition);
}


BOOL CKorIMX::EndIPComposition(TfEditCookie ec, ITfContext *pic)
{
    ITfComposition *pComposition;
    
    pComposition = GetIPComposition(pic);
    
    if (pComposition)
        {
        CICPriv  *pICPriv;
        
        SetIPComposition(pic, NULL);
        pComposition->EndComposition(ec);
        pComposition->Release();

        // kill any mouse sinks
        if (GetAIMM(pic) && (pICPriv = GetInputContextPriv(pic)) != NULL)
            {
            CMouseSink *pMouseSink;

            if ((pMouseSink = pICPriv->GetMouseSink()) != NULL)
                {
                pMouseSink->_Unadvise();
                pMouseSink->Release();
                pICPriv->SetMouseSink(NULL);
                }
            }
        
        return TRUE;
        }
    return FALSE;
}


#if 0
VOID CKorIMX::RestoreRangeRequest(ITfContext* pic)
{
    CEditSession *pes;
    HRESULT hr;

    if (pic == NULL)
        return;

    if (pes = new CEditSession(_EditSessionCallback))
        {
        pes->_state.u = ESCB_RESTORERANGE;
        pes->_state.pv = (VOID*)this;
        pes->_state.wParam = (WPARAM)0;
        pes->_state.pRange = NULL;
        pes->_state.pic = pic;

        pic->EditSession( m_tid, pes, TF_ES_READWRITE | TF_ES_SYNC, &hr);

        SafeRelease(pes);
        }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by korimx.rc
//
#define IDS_PROGRAM                     1
#define IDS_DELBYJASO					2
#define IDS_2BEOL						3
#define IDS_3BEOL390					4
#define IDS_3BEOLFINAL					5
#define IDS_BUTTON_HAN_ENG          	6
#define IDS_BUTTON_JUN_BAN           	7
#define IDS_BUTTON_HANJA_CONV        	8
#define IDS_BUTTON_IME_PAD           	9
#define IDS_BUTTON_SOFTKBD				10
#define IDS_TT_HAN_ENG					11
#define IDS_TT_JUN_BAN					12
#define IDS_TT_HANJA_CONV				13
#define IDS_TT_IME_PAD                  14
#define IDS_HELP_DISPLAYNAME			15
#define IDS_HELP_FILENAME				16
/*
#define IDS_HANGUL_MODE					13
#define IDS_ENGLISH_MODE				14
#define IDS_JUNJA_MODE					15
#define IDS_BANJA_MODE					16
*/
#define IDS_CANCEL						20
#define IDS_CONTEXTHELP_FILENAME        21
#define IDS_PROFILEDESC                  22

#define IDI_ICONBASE                    100
#define IDI_UNIKOR                      100
#define IDI_ICON_OPEN                   101
#define IDI_ICON_CLOSE                  102
#define IDI_ICON_CANDMENU               103
#define IDI_CMODE_HANGUL				104
#define IDI_CMODE_HANGULW				105
#define IDI_CMODE_ENGLISH				106
#define IDI_CMODE_ENGLISHW				107
#define IDI_CMODE_BANJA					108
#define IDI_CMODE_BANJAW				109
#define IDI_CMODE_JUNJA					110
#define IDI_CMODE_JUNJAW				111
#define IDI_CMODE_HANJA					112
#define IDI_CMODE_HANJAW				113
#define IDI_SOFTKBD						114
#define IDI_PAD                         115

#define IDD_CONFIG_PAGE1                200

#define IDC_GRP_KEYLAYOUT               1001
#define IDC_2BEOLSIK                    1005
#define IDC_3BEOLSIK_390                1006
#define IDC_3BEOLSIK_FINAL              1007
#define IDC_DELJASO                     1008
#define IDC_IMEPAD                      1010
#define IDC_IME_ICON                    1011
#define IDC_K1HANJA                     1012

// For IME Pad Applet menu list. Max 100 applets
#define IDR_PAD_FIRST                   2200
#define IDR_PAD_END                     2299
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\skbdmode.cpp ===
/****************************************************************************
   SKBDMODE.CPP : CSoftKbdMode class implementation which manage Soft Keyboard 
                     button on the Cicero Toolbar

   History:
      19-SEP-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "common.h"
#include "korimx.h"
#include "skbdmode.h"
#include "userex.h"
#include "immxutil.h"
#include "resource.h"

// {C7BAA1A7-5403-4596-8fe6-DC50C96B2FDD}
const GUID GUID_LBI_KORIMX_SKBDMODE = 
{   
    0xC7BAA1A7, 
    0x5403, 
    0x4596, 
    { 0x8f, 0xe6, 0xdc, 0x50, 0xc9, 0x6b, 0x2f, 0xdd }
};

/*---------------------------------------------------------------------------
    CSoftKbdMode::CSoftKbdMode
---------------------------------------------------------------------------*/
CSoftKbdMode::CSoftKbdMode(CToolBar *ptb)
{
    WCHAR  szText[256];

    m_pTb = ptb;

    // Set Add/Remove and tootip text
    LoadStringExW(g_hInst, IDS_BUTTON_SOFTKBD, szText, sizeof(szText)/sizeof(WCHAR));
    InitInfo(CLSID_KorIMX,
                GUID_LBI_KORIMX_SKBDMODE,
                TF_LBI_STYLE_BTN_TOGGLE | TF_LBI_STYLE_HIDDENBYDEFAULT,
                130,
                szText);
    SetToolTip(szText);
    SetText(szText);
}

/*---------------------------------------------------------------------------
    CSoftKbdMode::Release
---------------------------------------------------------------------------*/
STDAPI_(ULONG) CSoftKbdMode::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*---------------------------------------------------------------------------
    CSoftKbdMode::GetIcon

    Get Button face Icon
---------------------------------------------------------------------------*/
STDAPI CSoftKbdMode::GetIcon(HICON *phIcon)
{
    *phIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_SOFTKBD), IMAGE_ICON, 16, 16, LR_LOADMAP3DCOLORS);;
    
    return S_OK;
}

/*---------------------------------------------------------------------------
    CSoftKbdMode::InitMenu

    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CSoftKbdMode::InitMenu(ITfMenu *pMenu)
{    
    return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
    CSoftKbdMode::OnMenuSelect
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
STDAPI CSoftKbdMode::OnMenuSelect(UINT wID)
{
    return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
    CSoftKbdMode::OnLButtonUp
---------------------------------------------------------------------------*/
HRESULT CSoftKbdMode::OnLButtonUp(const POINT pt, const RECT* prcArea)
{
    return ToggleCompartmentDWORD(m_pTb->m_pimx->GetTID(), 
                                   m_pTb->m_pimx->GetTIM(), 
                                   GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE, 
                                   FALSE);

}


/*---------------------------------------------------------------------------
    CSoftKbdMode::UpdateToggle
    
    No need, this is just toggle button
---------------------------------------------------------------------------*/
void CSoftKbdMode::UpdateToggle()
{
    DWORD dwState = 0;

    GetCompartmentDWORD(m_pTb->m_pimx->GetTIM(), 
                        GUID_COMPARTMENT_KOR_SOFTKBD_OPENCLOSE, 
                        &dwState,
                        FALSE);

    SetOrClearStatus(TF_LBI_STATUS_BTN_TOGGLED, dwState);
    if (m_plbiSink)
        m_plbiSink->OnUpdate(TF_LBI_STATUS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\skbdmode.h ===
//
// SKBDMODE.H
//

#if !defined (__SKBDMODE_H__INCLUDED_)
#define __SKBDMODE_H__INCLUDED_

#include "cicbtn.h"
#include "toolbar.h"

class CSoftKbdMode : public CCicButton
{
public:
    CSoftKbdMode(CToolBar *ptb);
    ~CSoftKbdMode() {}

    STDMETHODIMP GetIcon(HICON *phIcon);
    HRESULT OnLButtonUp(const POINT pt, const RECT* prcArea);
    //HRESULT OnRButtonUp(const POINT pt, const RECT* prcArea);
    STDMETHODIMP InitMenu(ITfMenu *pMenu);
    STDMETHODIMP OnMenuSelect(UINT wID);
    STDMETHODIMP_(ULONG) Release(void);
    void UpdateToggle();

private:

	DWORD GetCMode() 				 { return m_pTb->GetConversionMode(); }
	DWORD SetCMode(DWORD dwConvMode) { return m_pTb->SetConversionMode(dwConvMode); }

	CToolBar *m_pTb;
};

#endif // __SKBDMODE_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\softkbdes.cpp ===
/**************************************************************************\
* Module Name: softkbdes.cpp
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* Soft Keyboard Event Sink for the Symbol layout 
*
* History:
*         28-March-2000  weibz     Created
\**************************************************************************/

#include "private.h"
#include "globals.h"
#include "immxutil.h"
#include "proputil.h"
#include "kes.h"
#include "helpers.h"
#include "editcb.h"
#include "dispattr.h"
#include "computil.h"
#include "regsvr.h"

#include "korimx.h"
#include "SoftKbdES.h"
#include "osver.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftKeyboardEventSink::CSoftKeyboardEventSink(CKorIMX *pKorIMX, DWORD dwSoftLayout)
{
     m_pKorIMX     = pKorIMX;
     _dwSoftLayout = dwSoftLayout;

     _fCaps  = fFalse;
     _fShift = fFalse;
     _fAlt   = fFalse;
     _fCtrl  = fFalse;
     
     _tid = pKorIMX->GetTID();
     _tim = pKorIMX->GetTIM();

     _tim->AddRef( );
    
     _cRef = 1;
}

CSoftKeyboardEventSink::~CSoftKeyboardEventSink()
{
    SafeReleaseClear(_tim);
}


//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CSoftKeyboardEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ISoftKeyboardEventSink))
    {
        *ppvObj = SAFECAST(this, CSoftKeyboardEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSoftKeyboardEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSoftKeyboardEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
//  ISoftKeyboardEventSink
//


STDAPI CSoftKeyboardEventSink::OnKeySelection(KEYID KeySelected, WCHAR  *lpszLabel)
{
    KEYID       keyId;
    BYTE        bVk, bScan;
    BOOL        fModifierSpecial = fFalse;
    HKL            hKL;
    INT_PTR        iHKL;
    HRESULT     hr;

    hr = S_OK;

    bScan = (BYTE)KeySelected;

    hKL = GetKeyboardLayout(0);

    if (!IsOnNT())
        {
        // We have to handle IME hkl specially on Win9x.
        // For some reason, Win9x cannot receive IME HKL as parameter in MapVirtualKeyEx and ToAsciiEx.
        iHKL = (INT_PTR)hKL;

        if ((iHKL & 0xF0000000) == 0xE0000000)
            {
            // this is FE IME HKL.
            iHKL = iHKL & 0x0000FFFF;
            hKL = (HKL)iHKL;
            }
        }
        
    bVk = (BYTE)MapVirtualKeyEx((UINT)bScan, 1, hKL);

    switch (KeySelected)
        {
    case  KID_CTRL  :
        _fCtrl = !_fCtrl;
        
        // Generate proper key msg
        if (_fCtrl)
            keybd_event(bVk, bScan, 0, 0);
        else
            keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
        break;
        
    case  KID_ALT   :
        _fAlt = !_fAlt;

        // Generate proper key msg
        if (_fAlt)
            keybd_event(bVk, bScan, 0, 0);
        else
            keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
        break;

    case  KID_CAPS  :
        if (m_pKorIMX->GetConvMode(m_pKorIMX->GetIC()) == TIP_ALPHANUMERIC_MODE)
            {
            _fCaps = !_fCaps;
            if (_fCaps == _fShift)
                // use state 0
                m_pKorIMX->GetHangulSKbd()->dwCurLabel = 0; 
            else
                // use state 1
                m_pKorIMX->GetHangulSKbd()->dwCurLabel = 1;

            hr = SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, _dwSoftLayout, fFalse);
            }
            
        // specially handle Caps Lock
        // this is a togglable key
        keybd_event(bVk, bScan, 0, 0);
        keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
        break;

    case  KID_LSHFT :
    case  KID_RSHFT :
        _fShift = !_fShift;
        if (_fCaps == _fShift)
            // use state 0
            m_pKorIMX->GetHangulSKbd()->dwCurLabel = 0;
        else
            // use state 1
            m_pKorIMX->GetHangulSKbd()->dwCurLabel = 1;

        hr = SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, _dwSoftLayout, fFalse);

        // Generate proper key msg
        if (_fShift)
            keybd_event(bVk, bScan, 0, 0);
        else
            keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
        break;

/*
    case  KID_F1  :
    case  KID_F2  :
    case  KID_F3  :
    case  KID_F4  :
    case  KID_F5  :
    case  KID_F6  :
    case  KID_F7  :
    case  KID_F8  :
    case  KID_F9  :
    case  KID_F10 :
    case  KID_F11 :
    case  KID_F12 :
    case  KID_TAB :

                  // simulate a key event and send to system.

    case  KID_ENTER :
    case  KID_ESC   :
    case  KID_SPACE :
    case  KID_BACK  :
    case  KID_UP    :
    case  KID_DOWN  :
    case  KID_LEFT  :
    case  KID_RIGHT :
*/
    default:
        {
        int         j, jIndex;
        BOOL        fExtendKey, fPictureKey;

        keyId = KeySelected;
        fPictureKey = fFalse;

        // Check picture key
        for (j=0; j < NUM_PICTURE_KEYS; j++)
            {
            if (gPictureKeys[j].uScanCode == keyId)
                {
                // This is a picture key.
                // it may be a extended key.
                jIndex = j;
                fPictureKey = fTrue;
                break;
                  }

            if (gPictureKeys[j].uScanCode == 0)
                {
                 // This is the last item in gPictureKeys.
                 break;
                }
            }

        fExtendKey = fFalse;

        // Picture key handling
        if (fPictureKey)
            {
              if ((keyId & 0xFF00) == 0xE000)
                  {
                  fExtendKey = fTrue;
                  bScan = (BYTE)(keyId & 0x000000ff);
                  }
              else
                bScan = (BYTE)keyId;

            // Get virtual key code
            bVk = (BYTE)(gPictureKeys[jIndex].uVkey);
            }

        // Generate Keyboard event
        if (fExtendKey)
            {
            keybd_event(bVk, bScan, (DWORD)KEYEVENTF_EXTENDEDKEY, 0);
            keybd_event(bVk, bScan, (DWORD)(KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP), 0);
            }
        else
            {
            keybd_event(bVk, bScan, 0, 0);
            keybd_event(bVk, bScan, (DWORD)KEYEVENTF_KEYUP, 0);
            }
#if 0
        // if the Shift Key is pressed, we need to release this key.
        if (GetKeyState(VK_SHIFT) & 0x80)
            {
            fModifierSpecial = fTrue;
            _fShift = !_fShift;
              // simulate the SHIFT-UP key event.
              keybd_event((BYTE)VK_SHIFT, (BYTE)KID_LSHFT, (DWORD)KEYEVENTF_KEYUP, 0);
            }
            
        // if the Ctrl Key is pressed, we need to release this key.
        if (GetKeyState(VK_CONTROL) & 0x80)
            {
            fModifierSpecial = fTrue;
            // simulate the Ctrl-UP key event.
            keybd_event((BYTE)VK_CONTROL, (BYTE)KID_CTRL, (DWORD)KEYEVENTF_KEYUP, 0);
            }
#endif
            
#if 0
        // if the Alt Key is pressed, we need to release this key.
        if (lpCurKbdLayout->ModifierStatus & MODIFIER_ALT)
            {
            fModifierSpecial = TRUE;
            lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_ALT);

            // simulate the SHIFT-UP key event.
            keybd_event((BYTE)VK_MENU, (BYTE)KID_ALT, (DWORD)KEYEVENTF_KEYUP, 0);
            }

        // if the Right Alt Key is pressed, we need to release this key.
        if (lpCurKbdLayout->ModifierStatus & MODIFIER_ALTGR)
            {
            fModifierSpecial = TRUE;
            lpCurKbdLayout->ModifierStatus &= ~((WORD)MODIFIER_ALTGR);

            // simulate the SHIFT-UP key event.
            keybd_event((BYTE)VK_RMENU, (BYTE)KID_RALT, (DWORD)KEYEVENTF_KEYUP, 0);
            }
#endif

        if (fModifierSpecial)
            {
            if (_fCaps == _fShift)
                // use state 0
                m_pKorIMX->GetHangulSKbd()->dwCurLabel = 0;
            else
                // use state 1
                m_pKorIMX->GetHangulSKbd()->dwCurLabel = 1;
                hr = SetCompartmentDWORD(_tid, _tim, GUID_COMPARTMENT_SOFTKBD_KBDLAYOUT, _dwSoftLayout, fFalse);            
            }
            
        break;
        }

/*
      default         :


              if ( lpszLabel == NULL )
              {
                 hr = E_FAIL;

                 return hr;
              }

              pic = m_pKorIMX->GetIC( );

              if ( pic == NULL )
              {
                  return hr;
              }

              if (pes = new CEditSession(CKorIMX::_EditSessionCallback))
              {

                 WCHAR   *lpLabel;
                 int     i, iLen;

                 iLen = (int) wcslen(lpszLabel);
                 lpLabel = (WCHAR *)cicMemAllocClear((iLen+1)*sizeof(WCHAR));
                
                 if ( lpLabel == NULL )
                 {
                    // not enough memory.

                    hr = E_OUTOFMEMORY;
                    return hr;
                 }

                 for ( i=0; i<iLen; i++)
                     lpLabel[i] = lpszLabel[i];

                 lpLabel[iLen] = L'\0';

                 pes->_state.u = ESCB_KEYLABEL;
                 pes->_state.pv = m_pKorIMX;
                 pes->_state.wParam = (WPARAM)KeySelected;
                 pes->_state.lParam = (LPARAM)lpLabel;
                 pes->_state.pic = pic;
                 pes->_state.pv1 = NULL;

                 pic->EditSession(m_pKorIMX->_tid, 
                                  pes, 
                                  TF_ES_READWRITE, 
                                  &hr);

                 if ( FAILED(hr) )
                 {
                     SafeFreePointer(lpLabel);
                 }

                 SafeRelease(pes);

              }
              else
                 hr = E_FAIL;

              SafeRelease(pic);

              break;
    */
    }
 
    return hr;
}


CSoftKbdWindowEventSink::CSoftKbdWindowEventSink(CKorIMX *pKorIMX) 
{
                                               
     m_pKorIMX = pKorIMX;
   
     _cRef = 1;
}

CSoftKbdWindowEventSink::~CSoftKbdWindowEventSink()
{

}


//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CSoftKbdWindowEventSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ISoftKbdWindowEventSink))
    {
        *ppvObj = SAFECAST(this, CSoftKbdWindowEventSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CSoftKbdWindowEventSink::AddRef()
{
    return ++_cRef;
}

STDAPI_(ULONG) CSoftKbdWindowEventSink::Release()
{
    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//
//  ISoftKbdWindowEventSink
//


STDAPI CSoftKbdWindowEventSink::OnWindowClose( )
{

    HRESULT hr = S_OK;

    if (m_pKorIMX)
        m_pKorIMX->SetSoftKBDOnOff(FALSE);

    return hr;
}

STDAPI CSoftKbdWindowEventSink::OnWindowMove(int xWnd, int yWnd, int width, int height)
{

    HRESULT hr = S_OK;

    if (m_pKorIMX)
        m_pKorIMX->SetSoftKBDPosition(xWnd, yWnd);

// support size change later.
    UNREFERENCED_PARAMETER(width);
    UNREFERENCED_PARAMETER(height);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\textsink.cpp ===
//
// tes.cpp
//

#include "private.h"
#include "korimx.h"
#include "textsink.h"
#include "editcb.h"
#include "helpers.h"

//////////////////////////////////////////////////////////////////////////////
//
// CTextEventSink
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// IUnknown
//
//----------------------------------------------------------------------------

STDAPI CTextEditSink::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextEditSink))
    {
        *ppvObj = SAFECAST(this, ITfTextEditSink *);
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDAPI_(ULONG) CTextEditSink::AddRef()
{
    return ++m_cRef;
}

STDAPI_(ULONG) CTextEditSink::Release()
{
    long cr;

    cr = --m_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

//+---------------------------------------------------------------------------
//
// ctor
//
//----------------------------------------------------------------------------

CTextEditSink::CTextEditSink(void *pv)
{
    Dbg_MemSetThisName(TEXT("CTextEditSink"));

    m_cRef = 1;
    m_dwEditCookie = TES_INVALID_COOKIE;
    m_pv = pv;
    Assert(m_pv != NULL);

    //m_dwLayoutCookie = TES_INVALID_COOKIE;
}

//+---------------------------------------------------------------------------
//
// EndEdit
//
//----------------------------------------------------------------------------

STDAPI CTextEditSink::OnEndEdit(TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord)
{
    CKorIMX 	    *pKorImx;
    CHangulAutomata	*pAutomata;
	CEditSession    *pes;
	BOOL		     fChanged = fFalse;
	HRESULT          hr = S_OK;
	
	pKorImx = (CKorIMX *)m_pv;
	Assert(pKorImx);
	
#if 0
	pEditRecord->GetSelectionStatus(&fChanged);

	if (fChanged)
		{
		BOOL fInWriteSession;

        if (SUCCEEDED(m_pic->InWriteSession(pKorImx->GetTID(), &fInWriteSession)))
        	{
            if (!fInWriteSession)
				if (pes = new CEditSession(CKorIMX::_EditSessionCallback))
					{
					// Complete the current composition here.
					// But you have to use async edit session here.
					// because this TextEditSink notification is inside of
					// another edit session. You can not have recursive 
					// edit session.
					pes->_state.u 		= ESCB_COMP_COMPLETE;
					pes->_state.pv 		= pKorImx;
					pes->_state.pRange 	= NULL;
					pes->_state.pic 	= m_pic;

					m_pic->EditSession(pKorImx->GetTID(), pes, TF_ES_READWRITE, &hr);

					pes->Release();
					}
			}
		}
#else
	pEditRecord->GetSelectionStatus(&fChanged);

	if (fChanged)
		{
		BOOL fInWriteSession;

        if (SUCCEEDED(m_pic->InWriteSession(pKorImx->GetTID(), &fInWriteSession)))
        	{
            if (!fInWriteSession)
            	{
				pAutomata = pKorImx->GetAutomata(m_pic);
				Assert(pAutomata);
				//pAutomata->MakeComplete();
				}
			}
		}
#endif

	return hr;
}

//+---------------------------------------------------------------------------
//
// CTextEditSink::Advise
//
//----------------------------------------------------------------------------

HRESULT CTextEditSink::_Advise(ITfContext *pic)
{
    HRESULT hr = E_FAIL;
    ITfSource *source = NULL;

    m_pic = NULL;

    if (FAILED(pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (FAILED(source->AdviseSink(IID_ITfTextEditSink, (ITfTextEditSink *)this, &m_dwEditCookie)))
		goto Exit;
		
    m_pic = pic;
    m_pic->AddRef();

    hr = S_OK;

Exit:
    SafeRelease(source);
    return hr;
}

//+---------------------------------------------------------------------------
//
// CTextEditSink::Unadvise
//
//----------------------------------------------------------------------------

HRESULT CTextEditSink::_Unadvise()
{
    HRESULT hr = E_FAIL;
    ITfSource *source = NULL;

    if (m_pic == NULL)
        goto Exit;

    if (FAILED(m_pic->QueryInterface(IID_ITfSource, (void **)&source)))
        goto Exit;

    if (SUCCEEDED(source->UnadviseSink(m_dwEditCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    SafeRelease(source);
    SafeReleaseClear(m_pic);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\toolbar.h ===
//
//  TOOLBAR.H
//
//  History:
//      24-JAN-2000 CSLim Created

#if !defined (__TOOLBAR_H__INCLUDED_)
#define __TOOLBAR_H__INCLUDED_

#include "globals.h"

class CKorIMX;
class CMode;
class FMode;
class HJMode;
class CPad;
class CSoftKbdMode;

#define UPDTTB_NONE		0x00000000
#define UPDTTB_CMODE	0x00000001
#define UPDTTB_FHMODE	0x00000002  // Full/Half shape mode
#define UPDTTB_HJMODE	0x00000004  // Hanja mode
#define UPDTTB_SKDMODE	0x00000008  // Soft keyboard mode
#define UPDTTB_ALL (UPDTTB_CMODE|UPDTTB_FHMODE|UPDTTB_HJMODE|UPDTTB_SKDMODE)


class CToolBar
{
public:
	CKorIMX* m_pimx;
	ITfContext* m_pic;

	CToolBar(CKorIMX* pImx);
	~CToolBar();

	void CheckEnable();
	void SetCurrentIC(ITfContext* pic);
	void SetUIFocus(BOOL fFocus);

	BOOL Initialize();
	VOID Terminate();
	DWORD SetConversionMode(DWORD dwConvMod);
	UINT  GetConversionMode(ITfContext *pic = NULL);
	UINT  GetConversionModeIDI(ITfContext *pic = NULL);

	BOOL Update(DWORD dwUpdate = UPDTTB_NONE, BOOL fRefresh = fFalse);

	BOOL IsOn(ITfContext *pic = NULL);
	BOOL SetOnOff(BOOL fOn);

	ITfContext* GetIC()		{ return m_pic;	}
	HWND GetOwnerWnd(ITfContext *pic = NULL);
	CSoftKbdMode *GetSkbdMode()		{ return m_pSkbdMode; }

    IImeIPoint1* GetIPoint(ITfContext *pic = NULL);

private:
	BOOL    m_fFocus;
	CMode  *m_pCMode;
	FMode  *m_pFMode;
	HJMode *m_pHJMode;
	CPad   *m_pPad;
	CSoftKbdMode *m_pSkbdMode;

	CMode *GetCMode()		{ return m_pCMode; }
	FMode *GetFMode()		{ return m_pFMode; }
	HJMode *GetHJMode()		{ return m_pHJMode; }
};

#endif	// __TOOLBAR_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\toolbar.cpp ===
/****************************************************************************
   TOOLBAR.CPP : Cicero Toolbar button management class

   History:
      24-JAN-2000 CSLim Created
****************************************************************************/

#include "private.h"
#include "globals.h"
#include "korimx.h"
#include "cmode.h"
#include "fmode.h"
#include "hjmode.h"
#include "skbdmode.h"
#include "pad.h"
#include "immxutil.h"
#include "helpers.h"
#include "toolbar.h"

/*---------------------------------------------------------------------------
	CToolBar::CToolBar
	Ctor
---------------------------------------------------------------------------*/
CToolBar::CToolBar(CKorIMX* pImx)
{
	m_pimx      = pImx;
	m_pic       = NULL;
	m_pCMode    = NULL;
	m_pFMode    = NULL;
	m_pHJMode   = NULL;
	m_pSkbdMode = NULL;
	m_pPad      = NULL;
	m_fFocus    = fFalse;
}

/*---------------------------------------------------------------------------
	CToolBar::~CToolBar
	Dtor
---------------------------------------------------------------------------*/
CToolBar::~CToolBar()
{
	m_pimx = NULL;
    SafeReleaseClear(m_pic);
}

/*---------------------------------------------------------------------------
	CToolBar::Initialize
	
	Initialize Toolbar buttons. Add to Cic main toolbar.
---------------------------------------------------------------------------*/
BOOL CToolBar::Initialize()
{
	ITfThreadMgr		*ptim;
	ITfLangBarItemMgr 	*plbim;
	HRESULT 			 hr;
	
	if (m_pimx == NULL)
		return fFalse;

	ptim  = m_pimx->GetTIM();
	plbim = NULL;

	//////////////////////////////////////////////////////////////////////////
	// Get Notify UI mananger(IID_ITfLangBarItemMgr) in current TIM
	if (FAILED(hr = GetService(ptim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim)))
		return fFalse;

	//////////////////////////////////////////////////////////////////////////
	// Create Han/Eng toggle button
	if (!(m_pCMode = new CMode(this))) 
		{
		hr = E_OUTOFMEMORY;
		return fFalse;
		}
	plbim->AddItem(m_pCMode);

	//////////////////////////////////////////////////////////////////////////
	// Create Full/Half shape toggle button
	if (!(m_pFMode = new FMode(this))) 
		{
		hr = E_OUTOFMEMORY;
		return fFalse;
		}
	plbim->AddItem(m_pFMode);

	//////////////////////////////////////////////////////////////////////////
	// Create Hanja Conv button
	if (!(m_pHJMode = new HJMode(this))) 
		{
		hr = E_OUTOFMEMORY;
		return fFalse;
		}
	plbim->AddItem(m_pHJMode);

	//////////////////////////////////////////////////////////////////////////
	// Create Soft Keyboard button
	if (!(m_pSkbdMode = new CSoftKbdMode(this))) 
		{
		hr = E_OUTOFMEMORY;
		return fFalse;
		}
	plbim->AddItem(m_pSkbdMode);

	//////////////////////////////////////////////////////////////////////////
	// Create Soft Keyboard button
	if (!(m_pPad = new CPad(this, m_pimx->GetPadCore()))) 
		{
		hr = E_OUTOFMEMORY;
		return fFalse;
		}
	plbim->AddItem(m_pPad);

	SafeRelease(plbim);
	return fTrue;
}

/*---------------------------------------------------------------------------
	CToolBar::Terminate
	
	Delete toolbar buttonsfrom Cic main toolbar.
---------------------------------------------------------------------------*/
void CToolBar::Terminate()
{
	ITfThreadMgr		*ptim;
	ITfLangBarItemMgr 	*plbim;
	HRESULT 			hr;
	
	if (m_pimx == NULL) 
		return;
		
	ptim  = m_pimx->GetTIM();
	plbim = NULL;

	if (FAILED(hr = GetService(ptim, IID_ITfLangBarItemMgr, (IUnknown **)&plbim)))
		return;

	if (m_pCMode) 
		{
		plbim->RemoveItem(m_pCMode);
		SafeReleaseClear(m_pCMode);
		}

	if (m_pFMode) 
		{
		plbim->RemoveItem(m_pFMode);
		SafeReleaseClear(m_pFMode);
		}

	if (m_pHJMode) 
		{
		plbim->RemoveItem(m_pHJMode);
		SafeReleaseClear(m_pHJMode);
		}

	if (m_pSkbdMode) 
		{
		plbim->RemoveItem(m_pSkbdMode);
		SafeReleaseClear(m_pSkbdMode);
		}
	
	if (m_pPad) 
		{
		plbim->RemoveItem(m_pPad);
		SafeReleaseClear(m_pPad);
		}

	SafeRelease(plbim);
}

/*---------------------------------------------------------------------------
	CToolBar::SetConversionMode
	
	Foward the call to CKorIMX
---------------------------------------------------------------------------*/
DWORD CToolBar::SetConversionMode(DWORD dwConvMode)
{
	if (m_pimx && m_pic)
		return m_pimx->SetConvMode(m_pic, dwConvMode);

	return 0;
}

/*---------------------------------------------------------------------------
	CToolBar::GetConversionMode

	Foward the call to CKorIMX
---------------------------------------------------------------------------*/
UINT CToolBar::GetConversionMode(ITfContext *pic)
{
	if (pic == NULL)
		pic = m_pic;

	if (m_pimx && pic)
		return m_pimx->GetConvMode(pic);

	return 0;
}

/*---------------------------------------------------------------------------
	CToolBar::IsOn

	Foward the call to CKorIMX
---------------------------------------------------------------------------*/
BOOL CToolBar::IsOn(ITfContext *pic)
{
	if (pic == NULL)
		pic = m_pic;

	if (m_pimx && pic)
		return m_pimx->IsOn(pic);

	return fFalse;
}

/*---------------------------------------------------------------------------
	CToolBar::CheckEnable
---------------------------------------------------------------------------*/
void CToolBar::CheckEnable()
{
	if (m_pic == NULL) // empty or disabled(exclude cand ui)
		{
		m_pCMode->Enable(fFalse);
		m_pFMode->Enable(fFalse);
		m_pHJMode->Enable(fFalse);
		m_pSkbdMode->Enable(fFalse);
		m_pPad->Enable(fFalse);
		}
	else
		{
		m_pCMode->Enable(fTrue);
		m_pFMode->Enable(fTrue);
		m_pHJMode->Enable(fTrue);
		m_pSkbdMode->Enable(fTrue);
		m_pPad->Enable(fTrue);
		}
}

/*---------------------------------------------------------------------------
	CToolBar::SetUIFocus
---------------------------------------------------------------------------*/
void CToolBar::SetUIFocus(BOOL fFocus)
{
	if (m_fFocus == fFocus) // same as previous state
		return;

	m_fFocus = fFocus;

	// notify the latest focus to IMEPad
	if (m_pimx && m_pimx->GetPadCore())
	    {
		m_pimx->GetPadCore()->SetFocus(fFocus);
	    }

	if (fFocus)
		Update(UPDTTB_ALL, fTrue);
}

/*---------------------------------------------------------------------------
	CToolBar::SetCurrentIC
---------------------------------------------------------------------------*/
void CToolBar::SetCurrentIC(ITfContext* pic)
{
    SafeReleaseClear(m_pic);
    
	m_pic = pic;
	if (m_pic)
	    {
        m_pic->AddRef();
	    }
    
	if (m_pimx == NULL)
		return;

	CheckEnable();	// enable or disable context

	// changed context - update all toolbar buttons
	Update(UPDTTB_ALL, fTrue);
}


/*---------------------------------------------------------------------------
	CToolBar::SetOnOff

	Foward the call to CKorIMX
---------------------------------------------------------------------------*/
BOOL CToolBar::SetOnOff(BOOL fOn)
{
	if (m_pimx && m_pic) 
		{
		m_pimx->SetOnOff(m_pic, fOn);
		return fOn;
		}
		
	return fFalse;
}

/*---------------------------------------------------------------------------
	CToolBar::GetOwnerWnd

	Foward the call to CKorIMX
---------------------------------------------------------------------------*/
HWND CToolBar::GetOwnerWnd(ITfContext *pic)
{
	if (pic == NULL)
	    {
		pic = m_pic;
	    }

	if (m_pimx && pic)
		return m_pimx->GetOwnerWnd();

	return 0;
}

/*---------------------------------------------------------------------------
	CToolBar::GetIPoint
---------------------------------------------------------------------------*/
IImeIPoint1* CToolBar::GetIPoint(ITfContext *pic)
{
	if (pic == NULL )
	    {
		pic = m_pic;
	    }
	
	if (m_pimx && pic)
	    {
		return m_pimx->GetIPoint(pic);
	    }
	
	return NULL;
}

/*---------------------------------------------------------------------------
	CToolBar::GetOwnerWnd

	Update buttons. dwUpdate has update bits corresponding each button.
---------------------------------------------------------------------------*/
BOOL CToolBar::Update(DWORD dwUpdate, BOOL fRefresh)
{
	DWORD dwFlag = TF_LBI_BTNALL;

	if (fRefresh)
		dwFlag |= TF_LBI_STATUS;

	if ((dwUpdate & UPDTTB_CMODE) && m_pCMode && m_pCMode->GetSink())
		m_pCMode->GetSink()->OnUpdate(dwFlag);

	if ((dwUpdate & UPDTTB_FHMODE) && m_pFMode && m_pFMode->GetSink())
		m_pFMode->GetSink()->OnUpdate(dwFlag);

	if ((dwUpdate & UPDTTB_HJMODE) && m_pHJMode && m_pHJMode->GetSink())
		m_pHJMode->GetSink()->OnUpdate(dwFlag);

	if ((dwUpdate & UPDTTB_SKDMODE) && m_pSkbdMode && m_pSkbdMode->GetSink())
		m_pSkbdMode->GetSink()->OnUpdate(dwFlag);

	if ((dwUpdate & UPDTTB_SKDMODE) && m_pPad && m_pPad->GetSink())
		m_pPad->GetSink()->OnUpdate(dwFlag);

	return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\textsink.h ===
//
// tes.h
//
// ITfTextEventSink object
//

#if !defined (__TEXTSINK_H__INCLUDED_)
#define __TEXTSINK_H__INCLUDED_

#include "private.h"

#define TES_INVALID_COOKIE  ((DWORD)(-1))

class CTextEditSink : public ITfTextEditSink
{
public:
    CTextEditSink(void *pv);

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ITfTextEditSink
    //
    STDMETHODIMP OnEndEdit(TfEditCookie ecReadOnly, ITfEditRecord *pEditRecord);

    HRESULT _Advise(ITfContext *pic);
    HRESULT _Unadvise();

private:

    long         m_cRef;
    ITfContext  *m_pic;
    DWORD        m_dwEditCookie;
//    DWORD        m_dwLayoutCookie;
//    DWORD        m_dwFlags;
	void        *m_pv;
};

#endif // __TEXTSINK_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\softkbdes.h ===
// SoftKbdES.h: interface for the SoftKeyboardEventSink class.
//
//////////////////////////////////////////////////////////////////////
#ifndef __SOFTKBDES_H__
#define __SOFTKBDES_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "softkbd.h"

class CKorIMX;


class CSoftKeyboardEventSink : public ISoftKeyboardEventSink  
{
public:
    CSoftKeyboardEventSink(CKorIMX *pKorIMX, DWORD dwSoftLayout);
    ~CSoftKeyboardEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ISoftKeyboardEventSink
    //

    STDMETHODIMP OnKeySelection(KEYID KeySelected, WCHAR  *lpszLabel);

//    void SetTidDim(TfClientId tid, ITfDocumentMgr *dim);
//    void ReleaseTidDim( );

private:

    long          _cRef;
    DWORD         _dwSoftLayout;
    CKorIMX       *m_pKorIMX;
    BOOL          _fCaps;
    BOOL          _fShift;
    BOOL		  _fAlt;
    BOOL	      _fCtrl;
    TfClientId    _tid;
    ITfThreadMgr *_tim;

};


class CSoftKbdWindowEventSink : public ISoftKbdWindowEventSink  
{
public:
    CSoftKbdWindowEventSink(CKorIMX *pKorIMX);
    ~CSoftKbdWindowEventSink();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // ISoftKbdWindowEventSink
    //

    STDMETHODIMP OnWindowClose( );
    STDMETHODIMP OnWindowMove( int xWnd,int yWnd, int width, int height);

private:

    long     _cRef;
    CKorIMX  *m_pKorIMX;
};
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\ucutil.cpp ===
//
// uctuil.cpp
//

#include    "private.h"
#include	"debug.h"
#include	"ucutil.h"


/*   C P G  F R O M  C H S   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
UINT CpgFromChs( BYTE chs )
{
	DWORD dwChs = chs;
	CHARSETINFO ChsInfo = {0};

	if (chs != SYMBOL_CHARSET && TranslateCharsetInfo( &dwChs, &ChsInfo, TCI_SRCCHARSET ))
		{
		return ChsInfo.ciACP;
		}

	return GetACP();
}


//
// conversion functions
//

/*   C O N V E R T  L O G  F O N T  W T O  A   */
/*------------------------------------------------------------------------------

	Convert LOGFONTW to LOGFONTA

------------------------------------------------------------------------------*/
void ConvertLogFontWtoA( CONST LOGFONTW *plfW, LOGFONTA *plfA )
{
	UINT cpg;

	plfA->lfHeight         = plfW->lfHeight;
	plfA->lfWidth          = plfW->lfWidth;
	plfA->lfEscapement     = plfW->lfEscapement;
	plfA->lfOrientation    = plfW->lfOrientation;
	plfA->lfWeight         = plfW->lfWeight;
	plfA->lfItalic         = plfW->lfItalic;
	plfA->lfUnderline      = plfW->lfUnderline;
	plfA->lfStrikeOut      = plfW->lfStrikeOut;
	plfA->lfCharSet        = plfW->lfCharSet;
	plfA->lfOutPrecision   = plfW->lfOutPrecision;
	plfA->lfClipPrecision  = plfW->lfClipPrecision;
	plfA->lfQuality        = plfW->lfQuality;
	plfA->lfPitchAndFamily = plfW->lfPitchAndFamily;

	cpg = CpgFromChs( plfW->lfCharSet );
	ConvertStrWtoA( plfW->lfFaceName, -1, plfA->lfFaceName, ARRAYSIZE(plfA->lfFaceName), cpg );
}


/*   C O N V E R T  L O G  F O N T  A T O  W   */
/*------------------------------------------------------------------------------

	Convert LOGFONTA to LOGFONTW

------------------------------------------------------------------------------*/
void ConvertLogFontAtoW( CONST LOGFONTA *plfA, LOGFONTW *plfW )
{
	UINT cpg;

	plfW->lfHeight         = plfA->lfHeight;
	plfW->lfWidth          = plfA->lfWidth;
	plfW->lfEscapement     = plfA->lfEscapement;
	plfW->lfOrientation    = plfA->lfOrientation;
	plfW->lfWeight         = plfA->lfWeight;
	plfW->lfItalic         = plfA->lfItalic;
	plfW->lfUnderline      = plfA->lfUnderline;
	plfW->lfStrikeOut      = plfA->lfStrikeOut;
	plfW->lfCharSet        = plfA->lfCharSet;
	plfW->lfOutPrecision   = plfA->lfOutPrecision;
	plfW->lfClipPrecision  = plfA->lfClipPrecision;
	plfW->lfQuality        = plfA->lfQuality;
	plfW->lfPitchAndFamily = plfA->lfPitchAndFamily;

	cpg = CpgFromChs( plfA->lfCharSet );
	ConvertStrAtoW( plfA->lfFaceName, -1, plfW->lfFaceName, ARRAYSIZE(plfW->lfFaceName), cpg );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\tipcand.cpp ===
/****************************************************************************
   TIPCAND.CPP : CKorIMX's Candidate UI member functions implementation
   
   History:
      16-DEC-1999 CSLim Created
****************************************************************************/

#include "private.h"
#include <initguid.h>    // For DEFINE_GUID IID_ITfCandidateUIEx and CLSID_TFCandidateUIEx
#include "mscandui.h"
#include "korimx.h"
#include "immxutil.h"
#include "dispattr.h"
#include "helpers.h"
#include "funcprv.h"
#include "kes.h"
#include "editcb.h"
#include "osver.h"
#include "ucutil.h"
#include "hanja.h"
#include "canduies.h"
#include "candkey.h"
#include "tsattrs.h"

//
// candidate list related functions
//

typedef struct _ENUMFONTFAMPARAM
{
    LPCWSTR  szFontFace;
    BYTE     chs;
    BOOL     fVertical;

    BOOL     fFound;        // output
    BOOL     fTrueType;        // output
    LOGFONTW LogFont;        // output
} ENUMFONTFAMPARAM;

static BOOL FFontExist(LPCWSTR szFontFace, LOGFONTW *pLogFont);
static BOOL CALLBACK FEnumFontFamProcA(const ENUMLOGFONTA *lpELF, const NEWTEXTMETRICA *lpNTM, DWORD dwFontType, LPARAM lParam);
static BOOL CALLBACK FEnumFontFamProcW(const ENUMLOGFONTW *lpELF, const NEWTEXTMETRICW *lpNTM, DWORD dwFontType, LPARAM lParam);
static BOOL FEnumFontFamProcMain(const LOGFONTW *pLogFont, DWORD dwFontType, ENUMFONTFAMPARAM *pParam);
static BOOL FFindFont(BYTE chs, BOOL fVertical, LOGFONTW *pLogFont);


/*---------------------------------------------------------------------------
    CKorIMX::CreateCandidateList

    Create a candidate list from input Hangul char
---------------------------------------------------------------------------*/
CCandidateListEx *CKorIMX::CreateCandidateList(ITfContext *pic, ITfRange *pRange, LPWSTR pwzRead)
{
    CCandidateListEx       *pCandList;
    HANJA_CAND_STRING_LIST CandStrList;

    Assert(pic != NULL);
    Assert(pRange != NULL);

    if (pic == NULL || pwzRead == NULL)
        return NULL;

    ZeroMemory(&CandStrList, sizeof(HANJA_CAND_STRING_LIST));
    // Get Conversion list
    if (GetConversionList(*pwzRead, &CandStrList))
        {
        // Create ITfCandidateList object and add cadn string to it.
        pCandList = new CCandidateListEx(CandidateUICallBack, pic, pRange);
        
        for (UINT i=0; i<CandStrList.csz; i++)
            {
            CCandidateStringEx *pCandStr;
            WCHAR                szCand[2];

            // Add candidate Hanja
            szCand[0] = CandStrList.pHanjaString[i].wchHanja;
            szCand[1] = L'\0';

            pCandList->AddString(szCand, GetLangID(), this, NULL, &pCandStr);
            pCandStr->SetInlineComment(CandStrList.pHanjaString[i].wzMeaning);
            pCandStr->m_bHanjaCat = CandStrList.pHanjaString[i].bHanjaCat;
            
            // Set read Hangul char
            pCandStr->SetReadingString(pwzRead);
            pCandStr->Release();
            }

        // Free temp result buffer and return
        cicMemFree(CandStrList.pwsz);
        cicMemFree(CandStrList.pHanjaString);

        return pCandList;
        }
    else
        MessageBeep(MB_ICONEXCLAMATION);

    return NULL;
}

#define FONTNAME_MSSANSSERIF        L"Microsoft Sans Serif"
#define FONTNAME_GULIM_KOR            L"\xAD74\xB9BC"      // Gulim
#define FONTNAME_GULIM_KOR_VERT        L"@\xAD74\xB9BC"      // Gulim
#define FONTNAME_GULIM_ENG            L"Gulim"              // Gulim
#define FONTNAME_GULIM_ENG_VERT        L"@Gulim"              // Gulim

static const LPCWSTR rgszCandFontList9xHoriz[] = 
{
    FONTNAME_GULIM_KOR,
    FONTNAME_GULIM_ENG,
    NULL
};

static const LPCWSTR rgszCandFontList9xVert[] = 
{
    FONTNAME_GULIM_KOR_VERT,
    FONTNAME_GULIM_ENG_VERT,
    NULL
};

static const LPCWSTR rgszCandFontListNT5Horiz[] = 
{
    FONTNAME_MSSANSSERIF,
    FONTNAME_GULIM_KOR,
    FONTNAME_GULIM_ENG,
    NULL
};

static const LPCWSTR rgszCandFontListNT5Vert[] = 
{
    FONTNAME_GULIM_KOR_VERT,
    FONTNAME_GULIM_ENG_VERT,
    NULL
};

/*---------------------------------------------------------------------------
     CKorIMX::GetCandidateFontInternal
---------------------------------------------------------------------------*/
void CKorIMX::GetCandidateFontInternal(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, LOGFONTW *plf, LONG lFontPoint, BOOL fCandList)
{
    HDC  hDC;
    LOGFONTW lfMenu;
    LOGFONTW lfFont;
    LONG lfHeightMin;
    BOOL fVertFont = fFalse;
    const LPCWSTR *ppFontFace = rgszCandFontList9xHoriz;
    BOOL fFound;

    //
    // get menu font
    //
    if (!IsOnNT()) 
        {
        NONCLIENTMETRICSA ncmA = {0};

        ncmA.cbSize = sizeof(ncmA);
        SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncmA), &ncmA, 0);

        ConvertLogFontAtoW( &ncmA.lfMenuFont, &lfMenu );
        }
    else
        {
        NONCLIENTMETRICSW ncmW = {0};

        ncmW.cbSize = sizeof(ncmW);
        SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, sizeof(ncmW), &ncmW, 0);

        lfMenu = ncmW.lfMenuFont;
        }

    // check font direction of main doc
    if (fCandList)
        {
        ITfReadOnlyProperty *pProp = NULL;
        VARIANT var;

        if ((pic != NULL) && (pic->GetAppProperty(TSATTRID_Text_VerticalWriting, &pProp) == S_OK))
            {
            QuickVariantInit(&var);

            if (pProp->GetValue(ec, pRange, &var) == S_OK)
                {
                Assert( var.vt == VT_BOOL );
                fVertFont = var.boolVal;
                VariantClear( &var );
                }

            SafeRelease( pProp );
            }
        }
    
    // set face name
    if (IsOnNT5())
        ppFontFace = fVertFont ? rgszCandFontListNT5Vert : rgszCandFontListNT5Horiz; 
    else
        ppFontFace = fVertFont ? rgszCandFontList9xVert :  rgszCandFontList9xHoriz; 


    // find font from font list (expected font)
    fFound = FFontExist(*(ppFontFace++), &lfFont);
    while (!fFound && (*ppFontFace != NULL))
        fFound = FFontExist(*(ppFontFace++), &lfFont);

    // find another Korean font if no expected font is found
    if (!fFound)
        fFound = FFindFont(HANGEUL_CHARSET, fVertFont, &lfFont);

    // use menu font when no Korean font found
    if (!fFound)
        lfFont = lfMenu;

    //
    // store font
    //

    *plf = lfMenu;

    plf->lfCharSet        = lfFont.lfCharSet;
    plf->lfOutPrecision   = lfFont.lfOutPrecision;
    plf->lfQuality        = lfFont.lfQuality;
    plf->lfPitchAndFamily = lfFont.lfPitchAndFamily;
    wcscpy(plf->lfFaceName, lfFont.lfFaceName);

    //
    // font size
    //
    
    // check minimum size
    hDC = GetDC(NULL);
    // Cand font size 12pt
    lfHeightMin = -MulDiv(lFontPoint, GetDeviceCaps(hDC, LOGPIXELSY), 72);    // minimum size
    ReleaseDC(NULL, hDC);

    plf->lfHeight = min(lfHeightMin, plf->lfHeight);
}



/*   G E T  T E X T   D I R E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
TEXTDIRECTION CKorIMX::GetTextDirection(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    TEXTDIRECTION dir = TEXTDIRECTION_LEFTTORIGHT;
    ITfReadOnlyProperty *pProp = NULL;
    VARIANT var;
    LONG lOrientation;

    QuickVariantInit(&var);

    if (pic == NULL)
        goto LError;

    if (pic->GetAppProperty(TSATTRID_Text_Orientation, &pProp) != S_OK)
        goto LError;

    if (pProp->GetValue(ec, pRange, &var) != S_OK)
        goto LError;

    Assert(var.vt == VT_I4);

    lOrientation = var.lVal;
    Assert((0 <= lOrientation) && (lOrientation < 3600));

    if (lOrientation < 450)
        dir = TEXTDIRECTION_LEFTTORIGHT;
    else 
    if (lOrientation < 900 + 450)
        dir = TEXTDIRECTION_BOTTOMTOTOP;
    else
    if (lOrientation < 1800 + 450)
        dir = TEXTDIRECTION_RIGHTTOLEFT;
    else
    if (lOrientation < 2700 + 450)
        dir = TEXTDIRECTION_TOPTOBOTTOM;
    else
        dir = TEXTDIRECTION_LEFTTORIGHT;

LError:
    SafeRelease(pProp);
    VariantClear(&var);

    return dir;
}



/*   G E T  C A N D  U I  D I R E C T I O N   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
CANDUIUIDIRECTION CKorIMX::GetCandUIDirection(TfEditCookie ec, ITfContext *pic, ITfRange *pRange)
{
    TEXTDIRECTION DirText = GetTextDirection(ec, pic, pRange);
    CANDUIUIDIRECTION DirCand = CANDUIDIR_LEFTTORIGHT;
    
    switch(DirText) 
        {
    case TEXTDIRECTION_TOPTOBOTTOM:
        DirCand = CANDUIDIR_RIGHTTOLEFT;
        break;
    case TEXTDIRECTION_RIGHTTOLEFT:
        DirCand = CANDUIDIR_BOTTOMTOTOP;
        break;
    case TEXTDIRECTION_BOTTOMTOTOP:
        DirCand = CANDUIDIR_LEFTTORIGHT;
        break;
    case TEXTDIRECTION_LEFTTORIGHT:
        DirCand = CANDUIDIR_TOPTOBOTTOM;
        break;
        }

    return DirCand;
}

/*---------------------------------------------------------------------------
    CKorIMX::OpenCandidateUI

    Open candidate UI
     - Open candidate UI window at the specified range
     - This function never release the range nor candidate list object. 
       They must be released in caller side.
---------------------------------------------------------------------------*/
void CKorIMX::OpenCandidateUI(TfEditCookie ec, ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList )
{
    ITfDocumentMgr     *pdim;

    Assert(pic != NULL);
    Assert(pRange != NULL);
    Assert(pCandList != NULL);

    if (pic == NULL || pRange == NULL || pCandList == NULL)
        return;

    // Create and initialize candidate UI
    if (m_pCandUI == NULL) 
        {
        if (SUCCEEDED(CoCreateInstance(CLSID_TFCandidateUI, 
                         NULL, 
                         CLSCTX_INPROC_SERVER, 
                         IID_ITfCandidateUI, 
                         (LPVOID*)&m_pCandUI)))
            {
            // Set client ID
            m_pCandUI->SetClientId(GetTID());
            }
        }
    
    Assert(m_pCandUI != NULL);

    if (m_pCandUI != NULL && SUCCEEDED(GetFocusDIM(&pdim)))
        {
        LOGFONTW lf;
        ULONG    iSelection;
        ITfCandUICandString    *pCandString;
        ITfCandUICandIndex     *pCandIndex;
        ITfCandUIInlineComment *pCandInlineComment;
        CANDUIUIDIRECTION       dir;
        ITfCandUICandWindow    *pCandWindow;

        // Set Cand string and Cand index font
        GetCandidateFontInternal(ec, pic, pRange, &lf, 12, fTrue);
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUICandString, (IUnknown**)&pCandString))) 
            {
            pCandString->SetFont(&lf);
            pCandString->Release();
            }

        // Set Inline Comment font
        // GetCandidateFontInternal(ec, pic, pRange, plf, 9, fTrue);
        lf.lfHeight = (lf.lfHeight * 3) / 4;
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUIInlineComment, (IUnknown**)&pCandInlineComment)))
            {
            pCandInlineComment->SetFont(&lf);
            pCandInlineComment->Release();
            }

        GetCandidateFontInternal(ec, pic, pRange, &lf, 12, fFalse);
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUICandIndex, (IUnknown**)&pCandIndex))) 
            {
            pCandIndex->SetFont(&lf);
            pCandIndex->Release();
            }


        // Set UI direction
        dir = GetCandUIDirection(ec, pic, pRange);
        if (SUCCEEDED(m_pCandUI->GetUIObject(IID_ITfCandUICandWindow, (IUnknown**)&pCandWindow)))
            {
            pCandWindow->SetUIDirection(dir);
            pCandWindow->Release();
            }

        // set key table
        SetCandidateKeyTable(pic, dir);

        // set and open candidate list 
        if (m_pCandUI->SetCandidateList(pCandList) == S_OK) 
            {

            m_fCandUIOpen = fTrue;
            
            pCandList->GetInitialSelection(&iSelection);
            m_pCandUI->SetSelection(iSelection);

            m_pCandUI->OpenCandidateUI(GetForegroundWindow(), pdim, ec, pRange);
            }
        }
}




/*   C L O S E  C A N D I D A T E  U I  P R O C   */
/*------------------------------------------------------------------------------

    Main procedure of closing CandidateUI

------------------------------------------------------------------------------*/
void CKorIMX::CloseCandidateUIProc()
{
    if (m_pCandUI != NULL) 
        {
        m_pCandUI->CloseCandidateUI();

        // BUGBUG: Candidate UI module never free candidatelist until 
        // set next candidate list.  set NULL candidate list then
        // it frees the previous one.
        m_pCandUI->SetCandidateList(NULL);

        m_fCandUIOpen = fFalse;
        }
}

/*---------------------------------------------------------------------------
    CKorIMX::CloseCandidateUI

    Close CandidateUI in EditSession
---------------------------------------------------------------------------*/
void CKorIMX::CloseCandidateUI(ITfContext *pic)
{
    CEditSession2 *pes;
    ESSTRUCT ess;
    HRESULT hr;
    
    ESStructInit(&ess, ESCB_CANDUI_CLOSECANDUI);

    if ((pes = new CEditSession2(pic, this, &ess, _EditSessionCallback2 )))
        {
        pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
        pes->Release();
        }
}

// REVIEW : NOT USED
void CKorIMX::SelectCandidate( TfEditCookie ec, ITfContext *pic, INT idxCand, BOOL fFinalize )
{
//    IImeIPoint* pIp = GetIPoint( pic );
//    CIImeIPointCallBackCIC* pIPCB = GetIPCB( pic );

//    if (( pIp == NULL ) || (pIPCB == NULL)) {
//        return;
//    }

//    UINT uiType = pIPCB->GetCandidateInfo();


/*
    CONTROLIDS* pControl = NULL;
    INT nControl = 0;


    INT idx;
    idx = idxCand;
    if (uiType == CANDINFO_RECOMMEND) {
        idx |= MAKE_PCACATEGLY(IMEPCA_CATEGLY_RECOMMEND);
    }

    HRESULT hRes = pIp->GetCandidateInfo( idx, &nControl, (VOID**)&pControl );
    if( pControl == NULL || hRes == S_FALSE ) {
        return;
    }


    INT i;

    CONTROLIDS* pCtrl = NULL;
    // generate control IDs
    for( i=0; i<nControl; i++ ) {
        pCtrl = pControl + i;
        pIp->Control( (WORD)pCtrl->dwControl, (LPARAM)pCtrl->lpVoid );
    }

    if (fFinalize) { // select with candidate close
        pIp->Control( (WORD)JCONV_C_CANDCURRENT, (LPARAM)CTRLID_DEFAULT );
    }
    else {
        if (uiType == CANDINFO_RECOMMEND) {
            pIp->Control( (WORD)JCONV_C_RECOMMENDCAND, (LPARAM)CTRLID_DEFAULT );
        }
    }


    pIp->UpdateContext( FALSE ); // generate composition string message
    _UpdateContext( ec, GetDIM(), pic, NULL);
    */
}


void CKorIMX::CancelCandidate(TfEditCookie ec, ITfContext *pic)
{
    /*
    IImeIPoint* pIp = GetIPoint( pic );

    if( pIp == NULL ) 
        {
        return;
        }

    // close candidate

    pIp->Control( (WORD)JCONV_C_CANDCURRENT, (LPARAM)CTRLID_DEFAULT );
    _UpdateContext( ec, GetDIM(), pic, NULL);    //  REVIEW: KOJIW: unneeded???
    */
    CloseCandidateUIProc();
}

//////////////////////////////////////////////////////////////////////////////
// Candlist key code behavior definition tables
CANDUIKEYDATA rgCandKeyDef[] = 
{
    /* 
    { flag,                                keydata,        command,                    paramater }
    */
    { CANDUIKEY_CHAR,                    L'1',            CANDUICMD_SELECTLINE,        1 },
    { CANDUIKEY_CHAR,                    L'2',            CANDUICMD_SELECTLINE,        2 },
    { CANDUIKEY_CHAR,                    L'3',            CANDUICMD_SELECTLINE,        3 },
    { CANDUIKEY_CHAR,                    L'4',            CANDUICMD_SELECTLINE,        4 },
    { CANDUIKEY_CHAR,                    L'5',            CANDUICMD_SELECTLINE,        5 },
    { CANDUIKEY_CHAR,                    L'6',            CANDUICMD_SELECTLINE,        6 },
    { CANDUIKEY_CHAR,                    L'7',            CANDUICMD_SELECTLINE,        7 },
    { CANDUIKEY_CHAR,                    L'8',            CANDUICMD_SELECTLINE,        8 },
    { CANDUIKEY_CHAR,                    L'9',            CANDUICMD_SELECTLINE,        9 },
    { CANDUIKEY_CHAR,                    L'0',            CANDUICMD_SELECTEXTRACAND,    0 },
    { CANDUIKEY_VKEY,                    VK_HANJA,        CANDUICMD_CANCEL,            0 },
    { CANDUIKEY_VKEY,                    VK_RETURN,        CANDUICMD_COMPLETE,            0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR, VK_SPACE,    CANDUICMD_MOVESELNEXT,        0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR, VK_DOWN,    CANDUICMD_MOVESELNEXT,        0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR,    VK_UP,        CANDUICMD_MOVESELPREV,        0 },
    { CANDUIKEY_VKEY,                    VK_HOME,        CANDUICMD_MOVESELFIRST,        0 },
    { CANDUIKEY_VKEY,                    VK_END,            CANDUICMD_MOVESELLAST,        0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR,    VK_PRIOR,    CANDUICMD_MOVESELPREVPG,    0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR,    VK_NEXT,    CANDUICMD_MOVESELNEXTPG,    0 },    
    { CANDUIKEY_VKEY,                    VK_ESCAPE,        CANDUICMD_CANCEL,            0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR,    VK_RIGHT,    CANDUICMD_MOVESELNEXT,        0 },
    { CANDUIKEY_VKEY|CANDUIKEY_RELATIVEDIR, VK_LEFT,      CANDUICMD_MOVESELPREV,       0 },
    { CANDUIKEY_VKEY,                       VK_LWIN,      CANDUICMD_CANCEL,            0 },
    { CANDUIKEY_VKEY,                       VK_RWIN,      CANDUICMD_CANCEL,            0 },
    { CANDUIKEY_VKEY,                       VK_APPS,      CANDUICMD_CANCEL,            0 }
};

#define irgCandKeyDefMax    (sizeof(rgCandKeyDef) / sizeof(rgCandKeyDef[0]))

/*---------------------------------------------------------------------------
    CKorIMX::SetCandidateKeyTable
---------------------------------------------------------------------------*/
void CKorIMX::SetCandidateKeyTable(ITfContext *pic, CANDUIUIDIRECTION dir)
{
    CCandUIKeyTable      *pCandUIKeyTable;
    ITfCandUIFnKeyConfig *pCandUIFnKeyConfig;
    
    if (m_pCandUI == NULL)
        return;

    if (FAILED(m_pCandUI->GetFunction(IID_ITfCandUIFnKeyConfig, (IUnknown**)&pCandUIFnKeyConfig)))
        return;

    if ((pCandUIKeyTable = new CCandUIKeyTable(irgCandKeyDefMax)) == NULL)
        return;

    for (int i = 0; i < irgCandKeyDefMax; i++)
        pCandUIKeyTable->AddKeyData(&rgCandKeyDef[i]);

    pCandUIFnKeyConfig->SetKeyTable(pic, pCandUIKeyTable);
    pCandUIKeyTable->Release();
    pCandUIFnKeyConfig->Release();
}

/*---------------------------------------------------------------------------
    CKorIMX::CandidateUICallBack
---------------------------------------------------------------------------*/
HRESULT CKorIMX::CandidateUICallBack(ITfContext *pic, ITfRange *pRange, CCandidateListEx *pCandList, CCandidateStringEx *pCand, TfCandidateResult imcr)
{
    CKorIMX *pSIMX = (CKorIMX *)(pCand->m_pv);
    CEditSession2 *pes;
    ESSTRUCT        ess;
    HRESULT hr;

    Assert(pic != NULL);
    Assert(pRange != NULL);
    
    // Only handle CAND_FINALIZED and CAND_CANCELED
    if (imcr == CAND_FINALIZED)
        {
        ESStructInit(&ess, ESCB_FINALIZECONVERSION);

        ess.pRange    = pRange;
        ess.pCandList = pCandList;
        ess.pCandStr  = pCand;


        if (pes = new CEditSession2(pic, pSIMX, &ess, CKorIMX::_EditSessionCallback2))
            {
            pCandList->AddRef(); ;        // be released in edit session callback
            pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
            pes->Release();
            }
        }

    // If user hit ESC or arrow keys..
    if (imcr == CAND_CANCELED)
        {
           // Complete current comp char if exist
           // This will reset Automata also.
        ESStructInit(&ess, ESCB_COMPLETE);
        
        ess.pRange    = pRange;
        
        if ((pes = new CEditSession2(pic, pSIMX, &ess, CKorIMX::_EditSessionCallback2)) == NULL)
            return fFalse;

        pes->Invoke(ES2_READWRITE | ES2_ASYNC, &hr);
        pes->Release();
        }

    return S_OK;
}

/*---------------------------------------------------------------------------
    CKorIMX::IsCandKey
---------------------------------------------------------------------------*/
BOOL CKorIMX::IsCandKey(WPARAM wParam, const BYTE abKeyState[256])
{
    if (IsShiftKeyPushed(abKeyState) || IsControlKeyPushed(abKeyState))
        return fFalse;

    if (wParam == VK_HANGUL || wParam == VK_HANJA || wParam == VK_JUNJA)
        return fTrue;
    
    for (int i=0; i<irgCandKeyDefMax; i++)
        {
        if (rgCandKeyDef[i].uiKey == wParam)
            return fTrue;
        }
        
    if (wParam >= VK_NUMPAD0 && wParam <= VK_NUMPAD9)
        return fTrue;
    else
        return fFalse;
}

/////////////////////////////////////////////////////////////////////////////
// Private Functions


/*   F  F O N T  E X I S T   */
/*------------------------------------------------------------------------------

    Check if the font is installed

------------------------------------------------------------------------------*/
BOOL FFontExist(LPCWSTR szFontFace, LOGFONTW *pLogFont)
{
    ENUMFONTFAMPARAM param = {0};
    HDC hDC;

    param.szFontFace = szFontFace;
    param.fFound     = FALSE;

    hDC = GetDC(NULL);
    if (!IsOnNT5()) 
        {
        CHAR szFontFaceA[LF_FACESIZE];

        ConvertStrWtoA(szFontFace, -1, szFontFaceA, LF_FACESIZE);
        EnumFontFamiliesA(hDC, szFontFaceA, (FONTENUMPROCA)FEnumFontFamProcA, (LPARAM)&param);
        }
    else
        EnumFontFamiliesW(hDC, szFontFace, (FONTENUMPROCW)FEnumFontFamProcW, (LPARAM)&param);
    
    ReleaseDC(NULL, hDC);

    if (param.fFound)
        *pLogFont = param.LogFont;

    return param.fFound;
}



/*   F  E N U M  F O N T  F A M  P R O C  A   */
/*------------------------------------------------------------------------------

    Callback funtion in enumeration font (ANSI version)

------------------------------------------------------------------------------*/
BOOL CALLBACK FEnumFontFamProcA(const ENUMLOGFONTA *lpELF, const NEWTEXTMETRICA *lpNTM, DWORD dwFontType, LPARAM lParam)
{
    LOGFONTW lfW;

    UNREFERENCED_PARAMETER(lpNTM);
    UNREFERENCED_PARAMETER(dwFontType);

    ConvertLogFontAtoW(&lpELF->elfLogFont, &lfW);

    return FEnumFontFamProcMain(&lfW, dwFontType, (ENUMFONTFAMPARAM *)lParam);
}



/*   F  E N U M  F O N T  F A M  P R O C  W   */
/*------------------------------------------------------------------------------

    Callback funtion in enumeration font (Unicode version)

------------------------------------------------------------------------------*/
BOOL CALLBACK FEnumFontFamProcW(const ENUMLOGFONTW *lpELF, const NEWTEXTMETRICW *lpNTM, DWORD dwFontType, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lpNTM);

    return FEnumFontFamProcMain(&lpELF->elfLogFont, dwFontType, (ENUMFONTFAMPARAM *)lParam);
}


/*   F  E N U M  F O N T  F A M  P R O C  M A I N   */
/*------------------------------------------------------------------------------

    Main procedure of enumeration font (find fonts)

------------------------------------------------------------------------------*/
BOOL FEnumFontFamProcMain( const LOGFONTW *pLogFont, DWORD dwFontType, ENUMFONTFAMPARAM *pParam )
{
    if (pParam->szFontFace != NULL)
        {
        if (pParam->fFound)
            goto Exit;

        // check font face
        if (wcscmp( pParam->szFontFace, pLogFont->lfFaceName ) == 0)
            {
            pParam->fFound    = TRUE;
            pParam->fTrueType = (dwFontType == TRUETYPE_FONTTYPE);
            pParam->LogFont   = *pLogFont;
            }
        }
    else
        {
        // check character set

        if (pLogFont->lfCharSet != pParam->chs)
            goto Exit;

        // check font direction

        if (pParam->fVertical && (pLogFont->lfFaceName[0] != L'@'))
            goto Exit;
        else 
            if (!pParam->fVertical && (pLogFont->lfFaceName[0] == L'@'))
            goto Exit;

        // store first found font anyway
        if (!pParam->fFound)
            {
            pParam->fFound    = TRUE;
            pParam->fTrueType = (dwFontType == TRUETYPE_FONTTYPE);
            pParam->LogFont   = *pLogFont;
            goto Exit;
            }

        // check if the font is better than previous

        // font type (truetype font has priority)
        if (pParam->fTrueType && (dwFontType != TRUETYPE_FONTTYPE))
            goto Exit;
        else 
        if (!pParam->fTrueType && (dwFontType == TRUETYPE_FONTTYPE))
            {
            pParam->fTrueType = (dwFontType == TRUETYPE_FONTTYPE);
            pParam->LogFont   = *pLogFont;
            goto Exit;
            }

        // font family (swiss font has priority)
        if (((pParam->LogFont.lfPitchAndFamily & (0x0f<<4)) == FF_SWISS) && ((pLogFont->lfPitchAndFamily & (0x0f<<4)) != FF_SWISS))
            goto Exit;
        else 
        if (((pParam->LogFont.lfPitchAndFamily & (0x0f<<4)) != FF_SWISS) && ((pLogFont->lfPitchAndFamily & (0x0f<<4)) == FF_SWISS))
            {
            pParam->fTrueType = (dwFontType == TRUETYPE_FONTTYPE);
            pParam->LogFont   = *pLogFont;
            goto Exit;
            }

        // pitch (variable pitch font has priority)
        if (((pParam->LogFont.lfPitchAndFamily & (0x03)) == VARIABLE_PITCH) && ((pLogFont->lfPitchAndFamily & (0x03)) != VARIABLE_PITCH))
            goto Exit;
        else
        if (((pParam->LogFont.lfPitchAndFamily & (0x03)) != VARIABLE_PITCH) && ((pLogFont->lfPitchAndFamily & (0x03)) == VARIABLE_PITCH))
            {
            pParam->fTrueType = (dwFontType == TRUETYPE_FONTTYPE);
            pParam->LogFont   = *pLogFont;
            goto Exit;
            }
        }

Exit:
    return TRUE;
}


/*   F  F I N D  F O N T   */
/*------------------------------------------------------------------------------

    Find the font that matches about following specified in the parameter
        * character set
        * font direction (vertical/horizontal)

    The priorities of finding are as belloow
        * TrueType font
        * Swiss (w/o serif) font
        * variable pitch font

------------------------------------------------------------------------------*/
BOOL FFindFont(BYTE chs, BOOL fVertical, LOGFONTW *pLogFont)
{
    ENUMFONTFAMPARAM param = {0};
    HDC hDC;

    param.szFontFace = NULL;
    param.chs        = chs;
    param.fVertical  = fVertical;
    param.fFound     = FALSE;

    hDC = GetDC(NULL);
    if (!IsOnNT5())
        EnumFontFamiliesA(hDC, NULL, (FONTENUMPROCA)FEnumFontFamProcA, (LPARAM)&param);
    else
        EnumFontFamiliesW(hDC, NULL, (FONTENUMPROCW)FEnumFontFamProcW, (LPARAM)&param);

    ReleaseDC(NULL, hDC);

    if (param.fFound)
        *pLogFont = param.LogFont;

    return param.fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\ucutil.h ===
//
// ucutil.h
//

#ifndef UCUTIL_H
#define UCUTIL_H

/*   C O N V E R T  S T R  W T O  A   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
__inline int ConvertStrWtoA( LPCWSTR pwch, int cwch, LPSTR pch, int cch, UINT cpg = CP_ACP )
{
	return WideCharToMultiByte( cpg, 0, pwch, cwch, pch, cch, NULL, NULL );
}


/*   C O N V E R T  S T R  A T O  W   */
/*------------------------------------------------------------------------------



------------------------------------------------------------------------------*/
__inline int ConvertStrAtoW( LPCSTR pch, int cch, LPWSTR pwch, int cwch, UINT cpg = CP_ACP )
{
	return MultiByteToWideChar( cpg, 0, pch, cch, pwch, cwch );
}

UINT CpgFromChs( BYTE chs );
void ConvertLogFontWtoA( CONST LOGFONTW *plfW, LOGFONTA *plfA );
void ConvertLogFontAtoW( CONST LOGFONTA *plfA, LOGFONTW *plfW );


// Unicode Character Block Description
#define UNICODE_C0_CONTROL_START							0x0000
#define UNICODE_C0_CONTROL_END								0x001f
#define UNICODE_BASIC_LATIN_START							0x0020
#define UNICODE_BASIC_LATIN_END								0x007f
#define UNICODE_LATIN1_SUPPLEMENT_START						0x0080
#define UNICODE_LATIN1_SUPPLEMENT_END						0x00FF
#define UNICODE_LATIN_EXTENDED_A_START						0x0100
#define UNICODE_LATIN_EXTENDED_A_END						0x017F
#define UNICODE_LATIN_EXTENDED_B_START						0x0180
#define UNICODE_LATIN_EXTENDED_B_END						0x024F
#define UNICODE_IPA_EXTENSIONS_START						0x0250
#define UNICODE_IPA_EXTENSIONS_END							0x02AF
#define UNICODE_SPACING_MODIFIER_LETTERS_START				0x02B0
#define UNICODE_SPACING_MODIFIER_LETTERS_END				0x02FF
#define UNICODE_COMBINING_DIACRITICAL_MARKS_START			0x0300
#define UNICODE_COMBINING_DIACRITICAL_MARKS_END				0x036F
#define UNICODE_GREEK_START									0x0370
#define UNICODE_GREEK_END									0x03FF
#define UNICODE_CYRILLIC_START								0x0400
#define UNICODE_CYRILLIC_END								0x04FF
#define UNICODE_ARMENIAN_START								0x0530
#define UNICODE_ARMENIAN_END								0x058F
#define UNICODE_HEBREW_START								0x0590
#define UNICODE_HEBREW_END									0x05FF
#define UNICODE_ARABIC_START								0x0600
#define UNICODE_ARABIC_END									0x06FF
#define UNICODE_DEVANAGARI_START							0x0900
#define UNICODE_DEVANAGARI_END								0x097F
#define UNICODE_BENGALI_START								0x0980
#define UNICODE_BENGALI_END									0x09FF
#define UNICODE_THAI_START									0x0E00
#define UNICODE_THAI_END									0x0E7F
#define UNICODE_TIBETAN_START								0x0F00
#define UNICODE_TIBETAN_END									0x0FBF
#define UNICODE_HANGUL_JAMO_START							0x1100
#define UNICODE_HANGUL_JAMO_END								0x11FF
#define UNICODE_GENERAL_PUNCTUATION_START					0x2000
#define UNICODE_GENERAL_PUNCTUATION_END						0x206F
#define UNICODE_SUPERSCRIPTS_AND_SUBSCRIPTS_START			0x2070
#define UNICODE_SUPERSCRIPTS_AND_SUBSCRIPTS_END				0x209F
#define UNICODE_CURRENCY_SYMBOLS_START						0x20A0
#define UNICODE_CURRENCY_SYMBOLS_END						0x20CF
#define UNICODE_LETTERLIKE_SYMBOLS_START					0x2100
#define UNICODE_LETTERLIKE_SYMBOLS_END						0x214F
#define UNICODE_NUMBER_FORMS_START							0x2150
#define UNICODE_NUMBER_FORMS_END							0x218F
#define UNICODE_ARROWS_START								0x2190
#define UNICODE_ARROWS_END									0x21FF
#define UNICODE_MATH_OPERATORS_START						0x2200
#define UNICODE_MATH_OPERATORS_END							0x22FF
#define UNICODE_MISC_TECHNICAL_START						0x2300
#define UNICODE_MISC_TECHNICAL_END							0x23FF
#define UNICODE_CONTROL_PICTURES_START						0x2400
#define UNICODE_CONTROL_PICTURES_END						0x243F
#define UNICODE_OCR_START									0x2440
#define UNICODE_OCR_END										0x245F
#define UNICODE_ENCLOSED_ALPHANUMERICS_START				0x2460
#define UNICODE_ENCLOSED_ALPHANUMERICS_END					0x24FF
#define UNICODE_BOX_DRAWING_START							0x2500
#define UNICODE_BOX_DRAWING_END								0x257F
#define UNICODE_BLOCK_ELEMENTS_START						0x2580
#define UNICODE_BLOCK_ELEMENT_END							0x259F
#define UNICODE_GEOMETRIC_SHAPE_START						0x25A0
#define UNICODE_GEOMETRIC_SHAPE_END							0x25FF
#define UNICODE_MISC_SYMBOLS_START							0x2600
#define UNICODE_MISC_SYMBOLD_END							0x26FF
#define UNICODE_CJK_SYMBOLS_AND_PUNCTUATIONS_START			0x3000
#define UNICODE_CJK_SYMBOLS_AND_PUNCTUATIONS_END			0x303F
#define UNICODE_HIRAGANA_START								0x3040
#define UNICODE_HIRAGANA_END								0x309F
#define UNICODE_KATAKANA_START								0x30A0
#define UNICODE_KATAKANA_END								0x30FF
#define UNICODE_BOPOMOFO_START								0x3100
#define UNICODE_BOPOMOFO_END								0x312F
#define UNICODE_HANGUL_COMPATIBILITY_JAMO_START				0x3130
#define UNICODE_HANGUL_COMPATIBILITY_JAMO_END				0x318F
#define UNICODE_KANBUN_START								0x3190
#define UNICODE_KANBUN_END									0x319F
#define UNICODE_ENCLOSED_CJK_LETTERS_AND_MONTHS_START		0x3200
#define UNICODE_NCLOSED_CJK_LETTERS_AND_MONTHS_END			0x32FF
#define UNICODE_CJK_COMPATIBILITY_START						0x3300
#define UNICODE_CJK_COMPATIBILITY_END						0x33FF
#define UNICODE_CJK_UNIFIED_IDEOGRAPHS_START				0x4E00
#define UNICODE_CJK_UNIFIED_IDEOGRAPHS_END					0x9FFF
#define UNICODE_HANGUL_SYLLABLES_START						0xAC00
#define UNICODE_HANGUL_SYLLABLES_END						0xD7A3
#define UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_START			0xF900
#define UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_END			0xFAFF
#define UNICODE_FULLWIDTH_ASCII_START						0xFF01
#define UNICODE_FULLWIDTH_ASCII_END							0xFF5E
#define UNICODE_HALFWIDTH_CJK_PUNCTUATION_START				0xFF61
#define UNICODE_HALFWIDTH_CJK_PUNCTUATION_END				0xFF64
#define UNICODE_HALFWIDTH_KATAKANA_START					0xFF65
#define UNICODE_HALFWIDTH_KATAKANA_END						0xFF9F
#define UNICODE_HALFWIDTH_HANGUL_JAMO_FILLER				0xFFA0
#define UNICODE_HALFWIDTH_HANGULE_JAMO_START				0xFFA1
#define UNICODE_HALFWIDTH_HANGULE_JAMO_END					0xFFDC
#define UNICODE_FULLWIDTH_PUNCTUATION_AND_CURRENCY_START	0xFFE0
#define UNICODE_FULLWIDTH_PUNCTUATION_AND_CURRENCY_END		0xFFE6
#define UNICODE_HALFWIDTH_FORMS_ARROWS_SHAPES_START			0xFFE8
#define UNICODE_HALFWIDTH_FORMS_ARROWS_SHAPES_END			0xFFEE

/*---------------------------------------------------------------------------
	fIsHangulSyllable
---------------------------------------------------------------------------*/
__inline
BOOL fIsHangulSyllable(WCHAR wcCh)
    {
    return (wcCh >= UNICODE_HANGUL_SYLLABLES_START && 
            wcCh <= UNICODE_HANGUL_SYLLABLES_END);
    }

/*---------------------------------------------------------------------------
	fIsHangulCompJamo
---------------------------------------------------------------------------*/
__inline
BOOL fIsHangulCompJamo(WCHAR wcCh)
    {
    return (wcCh >= UNICODE_HANGUL_COMPATIBILITY_JAMO_START && 
            wcCh <= UNICODE_HANGUL_COMPATIBILITY_JAMO_END);
    }
    
/*---------------------------------------------------------------------------
	fIsHangul
---------------------------------------------------------------------------*/
__inline 
BOOL fIsHangul(WCHAR wcCh)
    {
    return (fIsHangulSyllable(wcCh) || fIsHangulCompJamo(wcCh));
    }

/*---------------------------------------------------------------------------
	fIsHanja
	
	TODO: What about Extenstion-A ?
---------------------------------------------------------------------------*/
__inline 
BOOL fIsHanja(WCHAR wch)
{
	if ( (wch >= UNICODE_CJK_UNIFIED_IDEOGRAPHS_START       && wch <= UNICODE_CJK_UNIFIED_IDEOGRAPHS_END) ||  
		 (wch >= UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_START && wch <= UNICODE_CJK_COMPATIBILITY_IDEOGRAPHS_END) )
		return TRUE;
	else
		return FALSE;
}

/*---------------------------------------------------------------------------
	fIsHangulOrHanja
---------------------------------------------------------------------------*/
__inline 
BOOL fIsHangulOrHanja(WCHAR wcCh)
    {
    return (fIsHangul(wcCh) || fIsHanja(wcCh));
    }

#endif /* UCUTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\userex.cpp ===
/****************************************************************************
    USEREX.CPP

    Owner: cslim
    Copyright (c) 1997-2000 Microsoft Corporation

    Windows User API extension functions
    
    History:
    01-JUN-2000 cslim       Ported from IME code
    19-JUL-1999 cslim       Created
*****************************************************************************/

#include "private.h"
#include <windowsx.h>
#include "userex.h"
#include "osver.h"

inline Min(INT a, INT b) 
{
     return ((a)<(b)?(a):(b)) ;
}

/*---------------------------------------------------------------------------
    LoadStringExW

    Wrapper of LoadStringW() API.
    Load Unicode string with specified Language in any platform.
---------------------------------------------------------------------------*/
INT WINAPI LoadStringExW(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, INT nBufferMax)
{
    INT     cchwstr = 0;
    UINT    block, num;
    HRSRC   hres;
    HGLOBAL hgbl;
    LPWSTR  lpwstr;

    if (!hInst || !lpBuffer)
        return 0;

    block = (uID >>4)+1;
    num   = uID & 0xf;

    hres = FindResourceEx(hInst,
                          RT_STRING,
                          MAKEINTRESOURCE(block),
                          GetSystemDefaultLangID());

    if (hres == NULL)
        hres = FindResourceEx(hInst,
                          RT_STRING,
                          MAKEINTRESOURCE(block),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT));

    if (!hres)
        goto Error;

    if ((hgbl = LoadResource(hInst, hres)) == NULL)
        goto Error;

    if ((lpwstr = (LPWSTR)LockResource(hgbl)) == NULL)
        goto Error;

    for(UINT i = 0; i < num; i++)
        lpwstr += *lpwstr + 1;

    cchwstr = *lpwstr;
    CopyMemory(lpBuffer, lpwstr+1, Min(cchwstr, nBufferMax-1) * sizeof(WCHAR));
    
 Error:
     lpBuffer[Min(cchwstr, nBufferMax-1)]= (WCHAR)0x0000;
    return cchwstr;
}

/*---------------------------------------------------------------------------
    LoadStringExA

    Wrapper of LoadStringA() API.
---------------------------------------------------------------------------*/
INT WINAPI LoadStringExA(HINSTANCE hInst, INT uID, LPSTR lpBuffer, INT nBufferMax)
{
    INT cchstr;
    LPWSTR lpwstr;

    if (!hInst || !lpBuffer)
        return 0;

    if ((lpwstr = (LPWSTR)GlobalAllocPtr(GHND, nBufferMax*sizeof(WCHAR))) == NULL)
        return 0;

    // Call wide version
    LoadStringExW(hInst, uID, lpwstr, nBufferMax/2);
    
    // W to A
    cchstr = WideCharToMultiByte(CP_ACP, 
                              0, 
                              lpwstr, -1,
                              lpBuffer, nBufferMax, 
                              NULL, NULL); 

    if (cchstr)
        cchstr--;    // remove NULL char

    GlobalFreePtr(lpwstr);
    return cchstr;
}

/*---------------------------------------------------------------------------
    LoadMenuTemplateEx
---------------------------------------------------------------------------*/
static MENUTEMPLATE* LoadMenuTemplateEx(LANGID lgid, HINSTANCE hInstance, LPCSTR pchTemplate)
{
    HRSRC  hResMenu;
    HANDLE hMenuTmpl;

    hResMenu = FindResourceEx(hInstance, RT_MENU, pchTemplate, lgid);

    if((hResMenu == NULL) && (lgid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)))
        hResMenu = FindResourceEx(hInstance,
                                 RT_MENU,
                                 pchTemplate,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
        
    if (hResMenu == NULL)
        return NULL; 

    hMenuTmpl = LoadResource( hInstance, hResMenu );
    if(hMenuTmpl == NULL)
        return NULL;

    return (MENUTEMPLATE *)LockResource( hMenuTmpl );
}

/*---------------------------------------------------------------------------
    LoadMenuEx
---------------------------------------------------------------------------*/
HMENU WINAPI LoadMenuEx(HINSTANCE hInstance, LPCSTR lpMenuName)
{
    MENUTEMPLATE* pMenuTmpl;
    pMenuTmpl = LoadMenuTemplateEx(GetSystemDefaultLangID(), hInstance, lpMenuName);
    if (pMenuTmpl != NULL)
        return LoadMenuIndirect(pMenuTmpl);
    else
        return HMENU(0);
}

/*---------------------------------------------------------------------------
    LoadDialogTemplateEx
---------------------------------------------------------------------------*/
DLGTEMPLATE* WINAPI LoadDialogTemplateEx(LANGID lgid, HINSTANCE hInstance, LPCSTR pchTemplate)
{
    HRSRC  hResDlg;
    HANDLE hDlgTmpl;

    hResDlg = FindResourceExA(hInstance, RT_DIALOG, pchTemplate, lgid);

    if ((hResDlg == NULL) && (lgid != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)))
        hResDlg = FindResourceExA(hInstance,
                                  RT_DIALOG,
                                  pchTemplate,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

    if (hResDlg == NULL)
        return NULL; 

    hDlgTmpl = LoadResource(hInstance, hResDlg);

    if(hDlgTmpl == NULL)
        return NULL;

    return (DLGTEMPLATE *)LockResource(hDlgTmpl);
}

/*---------------------------------------------------------------------------
    OurGetMessage
---------------------------------------------------------------------------*/
BOOL WINAPI OurGetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
{
    if (IsOnNT())
        return ::GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    else
        return ::GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\tip\userex.h ===
/****************************************************************************
	USEREX.H

	Owner: cslim
	Copyright (c) 1997-2000 Microsoft Corporation

	Windows User API extension functions
	
	History:
	01-JUN-2000 cslim       Ported from IME code
	19-JUL-1999 cslim       Created
*****************************************************************************/

#if !defined (_USEREX_H__INCLUDED_)
#define _USEREX_H__INCLUDED_

// Function declare
extern INT WINAPI LoadStringExW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, INT nBufferMax);
extern INT WINAPI LoadStringExA(HINSTANCE hInst, INT uID, LPSTR lpBuffer, INT nBufferMax);
extern HMENU WINAPI LoadMenuEx(HINSTANCE hInstance, LPCSTR lpMenuName);
extern DLGTEMPLATE* WINAPI LoadDialogTemplateEx(LANGID lgid, HINSTANCE hInstance, LPCSTR pchTemplate);
extern BOOL WINAPI OurGetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);


/*---------------------------------------------------------------------------
	IsHighContrast
---------------------------------------------------------------------------*/
inline
BOOL IsHighContrastBlack()
{
	// high contrast black
	return (GetSysColor(COLOR_3DFACE) == RGB(0,0,0));
}

#endif // _USEREX_H__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\ime2k\version\verres.h ===
/****************************************************************************
	VERRES.H

	Owner: cslim
	Copyright (c) 1997-2000 Microsoft Corporation

	History:
	18-DEC-2000 cslim       Created
*****************************************************************************/
#if !defined (_VERRES_H__INCLUDED_)
#define _VERRES_H__INCLUDED_

#include <ntverp.h>

// For Boot strapper exe (setup.exe)
// #define THIS_VERSION_STR TEXT("{6.1.2406.0}")

#ifndef VERRES_VERSION_MAJOR
#define VERRES_VERSION_MAJOR 6
#endif

#ifndef VERRES_VERSION_MINOR
#define VERRES_VERSION_MINOR 1
#endif

#ifndef VERRES_VERSION_BUILD
#define VERRES_VERSION_BUILD VER_PRODUCTBUILD
#endif

#ifndef VERRES_VERSION_REVISION
#define VERRES_VERSION_REVISION 1
#endif

#endif // !defined (_VERRES_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\kor\uhc\precomp.h ===
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <ntcsrdll.h>
//#include <ntcsrsrv.h>
//#include <stddef.h>
//#include <limits.h>
//#include <windef.h>
//#include <string.h>
//#include <stdio.h>
//#include <winerror.h>
//#include <winss.h>
//#include <excpt.h>
//#include <ntstatus.h>
//#include <user.h>
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include "hangeul.h"
#include "hatmt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\array\convert\cvthigh.c ===
//
//    C ²X X{
//
//                Ż 1998/03/15
//

#include <windows.h>
#include <stdio.h>
#include "resource.h"

#define CharSize  2       //for unicode file format

int cvthigh(char *FileName,char *OutName,DWORD *line)
{
        FILE      *fin;
        FILE      *fout;
        WORD      temp;
        int       i;
        
        *line =1;
        
        // open input file
        if((fin = fopen(FileName,"rb")) ==NULL)
            return IDS_ERROPENFILE;
        fread(&temp,CharSize,1,fin);   // for unicode header
        
        // open output file
        if((fout=fopen(OutName,"wb"))==NULL)
        {
            fclose(fin);
            return IDS_ERRCREATEFILE;
        }
        
        
        while(fread(&temp,1,CharSize,fin))
        {
           if (temp!=' ')  //CCĤ@rťզrɡAӦCYѦC
           {
              // cut not chinese char
              do {
                 if(temp>255) break;
              } while(fread(&temp,1,CharSize,fin));

              if(feof(fin)) break;  //finsh!

              // get chinese (10 characters)
              i=0;
              do {
                 if(temp<=255)
                    break;
                 if(temp==0x25a1) temp=0;  // non-character
                 fwrite (&temp,1,sizeof(temp),fout);  // write to output file
                 i++;
              } while (fread(&temp,1,CharSize,fin));

              if (i!=10)
              {
                 fclose(fin);
                 fclose(fout);
                 return IDS_ERRFORMATCODE;
              }
           }
           while(temp!=0x000a)   // goto end of line ...
              if(!fread(&temp,1,CharSize,fin))
                 break;
           (*line) ++;
        }

        fclose(fin);
        fclose(fout);
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\array\convert\arcvt.c ===
//
//    C ѸT XD{
//
//                Ż 1998/03/15
//

#include <windows.h>
#include <commdlg.h>
#include <string.h>
#include <stdlib.h>
#include <direct.h>
#include "resource.h"
#include "function.h"

char szAppName[] = "CѸTX{" ;
char *szFilterI = "r (*.TXT;*.NT)\0*.txt;*.nt\0All Files  (*.*)\0*.*\0";
char *szFilterO = " (*.TAB)\0*.tab\0All Files  (*.*)\0*.*\0";
char *szFilterH = "w (*.TBL)\0*.tbl\0All Files  (*.*)\0*.*\0";

HANDLE hInst;
//HWND   msghwnd;

char   szInWordFileName[256];
char   szOutWordFileName[256];
char   szInHighFileName[256];
char   szOutHighFileName[256];
char   szInPhrFileName[256];
char   szOutPhrFileName[256];
char   szIdxFileName[256];
char   hlpfile[256];
DWORD  line;

long FAR PASCAL CALLBACK WndProc (HWND, UINT, UINT, LONG) ;
int  cvtword   (char *,char *,DWORD *);
int  cvthigh   (char *,char *,DWORD *);
int  cvtphrase (char *,char *,char *,DWORD *);

void error(HWND hwnd,int ErrCode,int item)
{
     char Buffer[255];
     char szMsg[255];
     
     if(LoadString(hInst, ErrCode, (LPSTR)Buffer, sizeof(Buffer)))
             switch(ErrCode)
             {
                 case IDS_ERROPENFILE:
                 case IDS_ERRUNICODE:
                 case IDS_ERRFORMATROOT:
                 case IDS_ERRFORMATROOTS:
                 case IDS_ERRFORMATPHRASE:
                 case IDS_ERRFORMATCODE:
                      switch(item)
					  {
						  case IDM_WORD:
							  wsprintf((LPSTR)szMsg,(LPSTR)Buffer,(LPSTR)szInWordFileName,line);
							  break;
						  case IDM_HIGH:
							  wsprintf((LPSTR)szMsg,(LPSTR)Buffer,(LPSTR)szInHighFileName,line);
							  break;
						  case IDM_PHRASE:
							  wsprintf((LPSTR)szMsg,(LPSTR)Buffer,(LPSTR)szInPhrFileName,line);
							  break;
					  }
					  break;
                 case IDS_ERRCREATEFILE:
                      switch(item)
					  {
						  case IDM_WORD:
							  wsprintf((LPSTR)szMsg,(LPSTR)Buffer,(LPSTR)szOutWordFileName,line);
							  break;
						  case IDM_HIGH:
							  wsprintf((LPSTR)szMsg,(LPSTR)Buffer,(LPSTR)szOutHighFileName,line);
							  break;
						  case IDM_PHRASE:
							  wsprintf((LPSTR)szMsg,(LPSTR)Buffer,(LPSTR)szOutPhrFileName,line);
							  break;
					  }
					  break;
                 case IDS_ERRCREATEIDX:
                      wsprintf((LPSTR)szMsg,(LPSTR)Buffer,(LPSTR)szIdxFileName);
                      break;
                 default:
                      strcpy(szMsg,"oͤ~!");
                      break;
             }
     else
         strcpy(szMsg,"oͤ~!");
     
     MessageBox(hwnd,(LPSTR)szMsg,szAppName,MB_OK | MB_ICONHAND |MB_APPLMODAL);
}

int PASCAL WinMain (HANDLE hInstance, HANDLE hPrevInstance,
                    LPSTR lpszCmdParam, int nCmdShow)
     {
     HWND        hwnd ;
     MSG         msg ;
     WNDCLASS    wndclass ;

     if (!hPrevInstance)
          {
          wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
          wndclass.lpfnWndProc   = WndProc ;
          wndclass.cbClsExtra    = 0 ;
          wndclass.cbWndExtra    = 0 ;
          wndclass.hInstance     = hInstance ;
          wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;//LoadIcon (hInstance, "ICON") ;
          wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
          wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
          wndclass.lpszMenuName  = "MENU" ;
          wndclass.lpszClassName = szAppName ;

          RegisterClass (&wndclass) ;
          }
     hInst=hInstance;
     
     _getcwd( hlpfile, sizeof(hlpfile));
        if(hlpfile[strlen(hlpfile)-1]=='\\')
            hlpfile[strlen(hlpfile)-1]=0;
        strcat(hlpfile,"\\ARCVT.TXT");
        
     hwnd = CreateWindow (szAppName,         // window class name
                    szAppName,               // window caption
                    WS_OVERLAPPEDWINDOW,     // window style
                    CW_USEDEFAULT,           // initial x position
                    CW_USEDEFAULT,           // initial y position
                    CW_USEDEFAULT,           // initial x size
                    CW_USEDEFAULT,           // initial y size
                    NULL,                    // parent window handle
                    NULL,                    // window menu handle
                    hInstance,               // program instance handle
                    NULL) ;                  // creation parameters

     ShowWindow (hwnd, nCmdShow) ;
     UpdateWindow (hwnd) ;

     while (GetMessage (&msg, NULL, 0, 0))
          {
          TranslateMessage (&msg) ;
          DispatchMessage (&msg) ;
          }
     return msg.wParam ;
     }


long FAR PASCAL CALLBACK WndProc (HWND hwnd, UINT message, UINT wParam,
                                                          LONG lParam)
{
     static    FARPROC  dlgprc;
     static    HWND     msghwnd;
     HCURSOR   hcurSave;
     int       ErrCode;
     static    HFILE  hlp;
     NPSTR     npmem;
     WORD      Len;
     
     
     switch (message)
          {
          
          case WM_CREATE:
                strcpy(szInWordFileName,"arntall.nt");
				strcpy(szOutWordFileName,"array30.tab");
				strcpy(szInHighFileName,"arhw-nt.nt");
				strcpy(szOutHighFileName,"arrayhw.tab");
				strcpy(szInPhrFileName,"ar25000.nt");
				strcpy(szOutPhrFileName,"arphr.tbl");
				strcpy(szIdxFileName,"arptr.tbl");

			   msghwnd = CreateWindow ("edit", NULL,
                         WS_CHILD | WS_VISIBLE |  WS_VSCROLL | WS_HSCROLL |
                              WS_BORDER | ES_LEFT | ES_MULTILINE |
                              ES_AUTOHSCROLL,
                              //ES_AUTOVSCROLL, //ES_AUTOHSCROLL |
                         0, 0, 0,0,
                         hwnd, (HANDLE)1,
                         hInst, NULL) ;

			   SendMessage(msghwnd,EM_SETREADONLY,TRUE,0L);

               if((hlp=_lopen((LPSTR)hlpfile, OF_READ))>0)
               {
                       Len = (WORD) FileLen(hlp);
                       npmem = (NPSTR)LocalAlloc(LMEM_FIXED,Len+1);
                       _lread(hlp,(LPSTR)npmem,Len);
                       _lclose(hlp);
                       *(npmem+Len)=0;
                       SendMessage(msghwnd,WM_SETTEXT,0,(LPARAM)(LPSTR)npmem);
               }

               PopFileInit ();
               return 0;

          case WM_SIZE:
               MoveWindow(msghwnd,0, 0, LOWORD(lParam),HIWORD(lParam),TRUE);
	           return 0;
	                         
          case WM_COMMAND:
               switch(wParam)
               {
                    case IDM_WORD:  //r
                         if(!PopFileOpenDlg(hwnd,szInWordFileName,"пܸƨӷ",szFilterI))
                             break;
                         if((ErrCode=IsUniCode (szInWordFileName))!=0)
                         {
                             error(hwnd,ErrCode,wParam);
                             break;
                         }
                         if(!PopFileSaveDlg(hwnd,szOutWordFileName,"ЫwXɦW",szFilterO))
                             break;
                         
                         hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));
                         ErrCode=cvtword(szInWordFileName,szOutWordFileName,&line);
                         SetCursor(hcurSave);
                         
                         if(!ErrCode)
                            MessageBox(hwnd,"rѸTഫI",szAppName,0);
                         else
                            error(hwnd,ErrCode,wParam);
                         
                         break;
                    case IDM_PHRASE: //y
                         if(!PopFileOpenDlg(hwnd,szInPhrFileName,"пܸƨӷ",szFilterI))
                             break;
                         if((ErrCode=IsUniCode (szInPhrFileName))!=0)
                         {
                             error(hwnd,ErrCode,wParam);
                             break;
                         }
                         
                         if(!PopFileSaveDlg(hwnd,szOutPhrFileName,"ЫwXyɦW",szFilterH))
                             break;
                         
                         if(!PopFileSaveDlg(hwnd,szIdxFileName,"ЫwXɦW",szFilterH))
                             break;
                         
                         hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));
                         ErrCode=cvtphrase(szInPhrFileName,szOutPhrFileName,szIdxFileName,&line);
                         SetCursor(hcurSave);
                         if(!ErrCode)
                            MessageBox(hwnd,"yѸTഫI",szAppName,0);
                         else
                            error(hwnd,ErrCode,wParam);

                         break;
                    
                    case IDM_HIGH:   //²X
                         if(!PopFileOpenDlg(hwnd,szInHighFileName,"пܸƨӷ",szFilterI))
                             break;
                         if((ErrCode=IsUniCode (szInHighFileName))!=0)
                         {
                             error(hwnd,ErrCode,wParam);
                             break;
                         }
                         if(!PopFileSaveDlg(hwnd,szOutHighFileName,"ЫwXɦW",szFilterO))
                             break;
                         
                         hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));
                         ErrCode=cvthigh(szInHighFileName,szOutHighFileName,&line);
                         SetCursor(hcurSave);
                         
                         if(!ErrCode)
                            MessageBox(hwnd,"²XѸTഫI",szAppName,0);
                         else
                            error(hwnd,ErrCode,wParam);
                         
                         break;  

               }
               return 0;
               
          case WM_DESTROY:
               DestroyWindow(msghwnd);
               PostQuitMessage (0) ;
               return 0 ;
          }

     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\array\convert\function.h ===
LONG FileLen (HFILE );
int  GetFilePath (char *);
BOOL PopFileOpenDlg (HWND , char * , char * , char * );
BOOL PopFileSaveDlg (HWND , char * , char * , char * );
void PopFileInit ();
int  IsUniCode (char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\tools\array\convert\cvtphr.c ===
//
//    C y X{
//
//                Ż 1998/03/15
//

#include <windows.h>
#include <stdio.h>
#include "resource.h"

#define CharSize  2       //for unicode file format

typedef struct {
                DWORD  root;
                DWORD  position;
               } PHRINFO;

int cvtphrase(char *FileName,char *OutName, char *idxName,DWORD *line)
{
        FILE      *fin;
        FILE      *fout;
        FILE      *fidx;
        BYTE      buffer;
        WORD      temp;
        PHRINFO   code,oldcode;
        DWORD     header[4];
		BOOL      SortFlag=TRUE;
		int       i;
        
        *line =1;
        header[0]=header[1]=header[2]=header[3]=0;
        
        // open input file
        if((fin = fopen(FileName,"rb")) ==NULL)
            return IDS_ERROPENFILE;
        fread(&temp,CharSize,1,fin); // for unicode prefix character
        
        // open output file
        if((fout=fopen(OutName,"wb"))==NULL)
        {
            fclose(fin);
            return IDS_ERR