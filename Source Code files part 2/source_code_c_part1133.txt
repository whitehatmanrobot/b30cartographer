PERF_COUNTER_DEFINITION),
        306,
        0,
        307,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.SmallWriteSmbs),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->SmallWriteSmbs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        308,
        0,
        309,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.RawReadsDenied),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->RawReadsDenied
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        310,
        0,
        311,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.RawWritesDenied),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->RawWritesDenied
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        312,
        0,
        313,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (rcd.NetworkErrors),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->NetworkErrors
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        314,
        0,
        315,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.Sessions),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Sessions
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        316,
        0,
        317,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.Reconnects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Reconnects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        318,
        0,
        319,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.CoreConnects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->CoreConnects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        320,
        0,
        321,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.Lanman20Connects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Lanman20Connects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        322,
        0,
        323,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.Lanman21Connects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->Lanman21Connects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        324,
        0,
        325,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.LanmanNtConnects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->LanmanNtConnects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        326,
        0,
        327,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.ServerDisconnects),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->ServerDisconnects
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        328,
        0,
        329,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.HungSessions),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->HungSessions
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        392,
        0,
        393,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (rcd.CurrentCommands),
        (DWORD)(ULONG_PTR)&((PRDR_COUNTER_DATA)0)->CurrentCommands
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\datasrv.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datasrv.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Server Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datasrv.h"

// dummy variable for field sizing.
static SRV_COUNTER_DATA   scd;

//
//  Constant structure initializations 
//      defined in datasrv.h
//

SRV_DATA_DEFINITION SrvDataDefinition = {
    {   sizeof(SRV_DATA_DEFINITION) + sizeof(SRV_COUNTER_DATA),
        sizeof(SRV_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        SERVER_OBJECT_TITLE_INDEX,
        0,
        331,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(SRV_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        395,
        0,
        -4,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof (scd.TotalBytes),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->TotalBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        333,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (scd.TotalBytesReceived),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->TotalBytesReceived
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        276,
        0,
        335,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof (scd.TotalBytesSent),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->TotalBytesSent
    },               
    {   sizeof(PERF_COUNTER_DEFINITION),
        340,
        0,
        341,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.SessionsTimedOut),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->SessionsTimedOut
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        342,
        0,
        343,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.SessionsErroredOut),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->SessionsErroredOut
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        344,
        0,
        345,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.SessionsLoggedOff),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->SessionsLoggedOff
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        346,
        0,
        347,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.SessionsForcedLogOff),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->SessionsForcedLogOff
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        348,
        0,
        349,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.LogonErrors),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->LogonErrors
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        350,
        0,
        351,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.AccessPermissionErrors),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->AccessPermissionErrors
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        352,
        0,
        353,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.GrantedAccessErrors),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->GrantedAccessErrors
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        354,
        0,
        355,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.SystemErrors),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->SystemErrors
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        356,
        0,
        357,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (scd.BlockingSmbsRejected),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->BlockingSmbsRejected
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        358,
        0,
        359,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (scd.WorkItemShortages),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->WorkItemShortages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        360,
        0,
        361,
        0,
        -3,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.TotalFilesOpened),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->TotalFilesOpened
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        362,
        0,
        363,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.CurrentOpenFiles),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->CurrentOpenFiles
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        314,
        0,
        365,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.CurrentSessions),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->CurrentSessions
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        366,
        0,
        367,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.CurrentOpenSearches),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->CurrentOpenSearches
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        58,
        0,
        369,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.CurrentNonPagedPoolUsage),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->CurrentNonPagedPoolUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        370,
        0,
        371,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (scd.NonPagedPoolFailures),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->NonPagedPoolFailures
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        372,
        0,
        373,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.PeakNonPagedPoolUsage),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->PeakNonPagedPoolUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        56,
        0,
        375,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.CurrentPagedPoolUsage),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->CurrentPagedPoolUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        376,
        0,
        377,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.PagedPoolFailures),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->PagedPoolFailures
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        378,
        0,
        379,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.PeakPagedPoolUsage),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->PeakPagedPoolUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        404,
        0,
        405,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (scd.ContextBlockQueueRate),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->ContextBlockQueueRate
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        692,
        0,
        693,
        0,
        1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof (scd.NetLogon),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->NetLogon
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1260,
        0,
        1261,
        0,
        1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof (scd.NetLogonTotal),
        (DWORD)(ULONG_PTR)&((PSRV_COUNTER_DATA)0)->NetLogonTotal
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\datasrv.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATASRV.h

Abstract:

    Header file for the Windows NT Server Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATASRV_H_
#define _DATASRV_H_

//
//  logical disk performance definition structure
//

//
//  This is the Srv counter structure presently returned by NT.
//

typedef struct _SRV_DATA_DEFINITION {
    PERF_OBJECT_TYPE        SrvObjectType;
    PERF_COUNTER_DEFINITION cdTotalBytes;
    PERF_COUNTER_DEFINITION cdTotalBytesReceived;
    PERF_COUNTER_DEFINITION cdTotalBytesSent;
    PERF_COUNTER_DEFINITION cdSessionsTimedOut;
    PERF_COUNTER_DEFINITION cdSessionsErroredOut;
    PERF_COUNTER_DEFINITION cdSessionsLoggedOff;
    PERF_COUNTER_DEFINITION cdSessionsForcedLogOff;
    PERF_COUNTER_DEFINITION cdLogonErrors;
    PERF_COUNTER_DEFINITION cdAccessPermissionErrors;
    PERF_COUNTER_DEFINITION cdGrantedAccessErrors;
    PERF_COUNTER_DEFINITION cdSystemErrors;
    PERF_COUNTER_DEFINITION cdBlockingSmbsRejected;
    PERF_COUNTER_DEFINITION cdWorkItemShortages;
    PERF_COUNTER_DEFINITION cdTotalFilesOpened;
    PERF_COUNTER_DEFINITION cdCurrentOpenFiles;
    PERF_COUNTER_DEFINITION cdCurrentSessions;
    PERF_COUNTER_DEFINITION cdCurrentOpenSearches;
    PERF_COUNTER_DEFINITION cdCurrentNonPagedPoolUsage;
    PERF_COUNTER_DEFINITION cdNonPagedPoolFailures;
    PERF_COUNTER_DEFINITION cdPeakNonPagedPoolUsage;
    PERF_COUNTER_DEFINITION cdCurrentPagedPoolUsage;
    PERF_COUNTER_DEFINITION cdPagedPoolFailures;
    PERF_COUNTER_DEFINITION cdPeakPagedPoolUsage;
    PERF_COUNTER_DEFINITION cdContextBlockQueueRate;
    PERF_COUNTER_DEFINITION cdNetLogon;
    PERF_COUNTER_DEFINITION cdNetLogonTotal;
} SRV_DATA_DEFINITION, *PSRV_DATA_DEFINITION;

typedef struct _SRV_COUNTER_DATA{
    PERF_COUNTER_BLOCK      CounterBlock;
    LONGLONG                TotalBytes;
    LONGLONG                TotalBytesReceived;
    LONGLONG                TotalBytesSent;
    DWORD                   SessionsTimedOut;
    DWORD                   SessionsErroredOut;
    DWORD                   SessionsLoggedOff;
    DWORD                   SessionsForcedLogOff;
    DWORD                   LogonErrors;
    DWORD                   AccessPermissionErrors;
    DWORD                   GrantedAccessErrors;
    DWORD                   SystemErrors;
    DWORD                   BlockingSmbsRejected;
    DWORD                   WorkItemShortages;
    DWORD                   TotalFilesOpened;
    DWORD                   CurrentOpenFiles;
    DWORD                   CurrentSessions;
    DWORD                   CurrentOpenSearches;
    DWORD                   CurrentNonPagedPoolUsage;
    DWORD                   NonPagedPoolFailures;
    DWORD                   PeakNonPagedPoolUsage;
    DWORD                   CurrentPagedPoolUsage;
    DWORD                   PagedPoolFailures;
    DWORD                   PeakPagedPoolUsage;
    DWORD                   ContextBlockQueueRate;
    DWORD                   NetLogon;
    DWORD                   NetLogonTotal;
} SRV_COUNTER_DATA, * PSRV_COUNTER_DATA;

extern SRV_DATA_DEFINITION SrvDataDefinition;


#endif // _DATASRV_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\datasrvq.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATASRVQ.h

Abstract:

    Header file for the Windows NT Processor Server Queue counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATASRVQ_H_
#define _DATASRVQ_H_

//
//  define for Server Queue Statistics
//

typedef struct _SRVQ_DATA_DEFINITION {
    PERF_OBJECT_TYPE        SrvQueueObjectType;
    PERF_COUNTER_DEFINITION cdQueueLength;
    PERF_COUNTER_DEFINITION cdActiveThreads;
    PERF_COUNTER_DEFINITION cdAvailableThreads;
    PERF_COUNTER_DEFINITION cdAvailableWorkItems;
    PERF_COUNTER_DEFINITION cdBorrowedWorkItems;
    PERF_COUNTER_DEFINITION cdWorkItemShortages;
    PERF_COUNTER_DEFINITION cdCurrentClients;
    PERF_COUNTER_DEFINITION cdBytesReceived;
    PERF_COUNTER_DEFINITION cdBytesSent;
    PERF_COUNTER_DEFINITION cdTotalBytesTransfered;
    PERF_COUNTER_DEFINITION cdReadOperations;
    PERF_COUNTER_DEFINITION cdBytesRead;
    PERF_COUNTER_DEFINITION cdWriteOperations;
    PERF_COUNTER_DEFINITION cdBytesWritten;
    PERF_COUNTER_DEFINITION cdTotalBytes;
    PERF_COUNTER_DEFINITION cdTotalOperations;
    PERF_COUNTER_DEFINITION cdTotalContextBlocksQueued;
} SRVQ_DATA_DEFINITION, * PSRVQ_DATA_DEFINITION;


typedef struct _SRVQ_COUNTER_DATA{
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   QueueLength;
    DWORD                   ActiveThreads;
    DWORD                   AvailableThreads;
    DWORD                   AvailableWorkItems;
    DWORD                   BorrowedWorkItems;
    DWORD                   WorkItemShortages;
    DWORD                   CurrentClients;
    LONGLONG                BytesReceived;
    LONGLONG                BytesSent;
    LONGLONG                TotalBytesTransfered;
    LONGLONG                ReadOperations;
    LONGLONG                BytesRead;
    LONGLONG                WriteOperations;
    LONGLONG                BytesWritten;
    LONGLONG                TotalBytes;
    LONGLONG                TotalOperations;
    DWORD                   TotalContextBlocksQueued;
} SRVQ_COUNTER_DATA, * PSRVQ_COUNTER_DATA;

extern SRVQ_DATA_DEFINITION SrvQDataDefinition;

#endif // _DATASRVQ_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\perfnet.h ===
extern  HANDLE  hEventLog;       // handle to event log
extern  HANDLE  hLibHeap;       // handle to DLL heap            
extern  LPWSTR  wszTotal;

PM_OPEN_PROC    OpenServerObject;
PM_LOCAL_COLLECT_PROC CollectServerObjectData;
PM_CLOSE_PROC   CloseServerObject;

PM_OPEN_PROC    OpenServerQueueObject;
PM_LOCAL_COLLECT_PROC CollectServerQueueObjectData;
PM_CLOSE_PROC   CloseServerQueueObject;

PM_OPEN_PROC    OpenRedirObject;
PM_LOCAL_COLLECT_PROC CollectRedirObjectData;
PM_CLOSE_PROC   CloseRedirObject;

PM_OPEN_PROC    OpenBrowserObject;
PM_LOCAL_COLLECT_PROC CollectBrowserObjectData;
PM_CLOSE_PROC   CloseBrowserObject;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\perfbrws.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfbrws.c

Abstract:

    This file implements a Performance Object that presents
    Browser Performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History

--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmwksta.h>
#include <lmbrowsr.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfnet.h"
#include "netsvcmc.h"
#include "databrws.h"

//  BrowserStatFunction is used for collecting Browser Statistic Data
typedef NET_API_STATUS (*PBROWSERQUERYSTATISTIC) (
    IN  LPTSTR      servername OPTIONAL,
    OUT LPBROWSER_STATISTICS *statistics
    );

static  PBROWSERQUERYSTATISTIC BrowserStatFunction = NULL;
static  HANDLE dllHandle  = NULL;
static  BOOL    bInitOk = FALSE;

DWORD APIENTRY
OpenBrowserObject (
    IN  LPWSTR  lpValueName
)
/*++
    GetBrowserStatistic   -   Get the I_BrowserQueryStatistics entry point

--*/
{
    UINT    dwOldMode;
    LONG    status = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER (lpValueName);

    dwOldMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    bInitOk = TRUE;
    //
    // Dynamically link to netapi32.dll.  If it's not there just return.
    //

    dllHandle = LoadLibraryW((LPCWSTR)L"NetApi32.Dll") ;
    if ( !dllHandle || dllHandle == INVALID_HANDLE_VALUE ) {
        status = GetLastError();
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFNET_UNABLE_OPEN_NETAPI32_DLL,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);
        BrowserStatFunction = NULL;
        bInitOk = FALSE;
    } else {
        //
        // Get the address of the service's main entry point.  This
        // entry point has a well-known name.
        //

        BrowserStatFunction = (PBROWSERQUERYSTATISTIC)GetProcAddress (
            dllHandle, "I_BrowserQueryStatistics") ;

        if (BrowserStatFunction == NULL) {
            status = GetLastError();
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_UNABLE_LOCATE_BROWSER_PERF_FN,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
            bInitOk = FALSE;
        }
    }

    SetErrorMode( dwOldMode );

    return status;
}

DWORD APIENTRY
CollectBrowserObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Physical Disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD                   TotalLen;  //  Length of the total return block
    NTSTATUS                Status = ERROR_SUCCESS;

    BROWSER_DATA_DEFINITION *pBrowserDataDefinition;
    BROWSER_COUNTER_DATA    *pBCD;

    BROWSER_STATISTICS      BrowserStatistics;
    LPBROWSER_STATISTICS    pBrowserStatistics = &BrowserStatistics;

    //
    //  Check for sufficient space for browser data
    //

    if (!bInitOk) {
        // function didn't initialize so bail out here
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    TotalLen = sizeof(BROWSER_DATA_DEFINITION) +
               sizeof(BROWSER_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        // not enough room in the buffer for 1 instance
        // so bail
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define objects data block
    //

    pBrowserDataDefinition = (BROWSER_DATA_DEFINITION *) *lppData;

    memcpy (pBrowserDataDefinition,
            &BrowserDataDefinition,
            sizeof(BROWSER_DATA_DEFINITION));
    //
    //  Format and collect browser data
    //

    pBCD = (PBROWSER_COUNTER_DATA)&pBrowserDataDefinition[1];

    // test for quadword alignment of the structure
    assert  (((DWORD)(pBCD) & 0x00000007) == 0);
    

    memset (pBrowserStatistics, 0, sizeof (BrowserStatistics));

    if ( BrowserStatFunction != NULL ) {
        Status = (*BrowserStatFunction) (NULL,
                                         &pBrowserStatistics
                                        );
    } else {
        Status =  STATUS_INVALID_ADDRESS;
    }

    if (NT_SUCCESS(Status)) {
        pBCD->CounterBlock.ByteLength = sizeof(BROWSER_COUNTER_DATA);
        pBCD->TotalAnnounce  =
            pBCD->ServerAnnounce = BrowserStatistics.NumberOfServerAnnouncements.QuadPart;
        pBCD->TotalAnnounce  +=
            pBCD->DomainAnnounce = BrowserStatistics.NumberOfDomainAnnouncements.QuadPart;

        pBCD->ElectionPacket = BrowserStatistics.NumberOfElectionPackets;
        pBCD->MailslotWrite = BrowserStatistics.NumberOfMailslotWrites;
        pBCD->ServerList    = BrowserStatistics.NumberOfGetBrowserServerListRequests;
        pBCD->ServerEnum    = BrowserStatistics.NumberOfServerEnumerations;
        pBCD->DomainEnum    = BrowserStatistics.NumberOfDomainEnumerations;
        pBCD->OtherEnum     = BrowserStatistics.NumberOfOtherEnumerations;
        pBCD->TotalEnum     = BrowserStatistics.NumberOfServerEnumerations
                              + BrowserStatistics.NumberOfDomainEnumerations
                              + BrowserStatistics.NumberOfOtherEnumerations;
        pBCD->ServerAnnounceMiss    = BrowserStatistics.NumberOfMissedServerAnnouncements;
        pBCD->MailslotDatagramMiss  = BrowserStatistics.NumberOfMissedMailslotDatagrams;
        pBCD->ServerListMiss        = BrowserStatistics.NumberOfMissedGetBrowserServerListRequests;
        pBCD->ServerAnnounceAllocMiss = BrowserStatistics.NumberOfFailedServerAnnounceAllocations;
        pBCD->MailslotAllocFail     = BrowserStatistics.NumberOfFailedMailslotAllocations;
        pBCD->MailslotReceiveFail   = BrowserStatistics.NumberOfFailedMailslotReceives;
        pBCD->MailslotWriteFail     = BrowserStatistics.NumberOfFailedMailslotWrites;
        pBCD->MailslotOpenFail      = BrowserStatistics.NumberOfFailedMailslotOpens;
        pBCD->MasterAnnounceDup     = BrowserStatistics.NumberOfDuplicateMasterAnnouncements;
        pBCD->DatagramIllegal       = BrowserStatistics.NumberOfIllegalDatagrams.QuadPart;

    } else {
        if (BrowserStatFunction != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_UNABLE_LOCATE_BROWSER_PERF_FN,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&Status);
        }

        //
        // Failure to access Browser: clear counters to 0
        //
        memset(pBCD, 0, sizeof(BROWSER_COUNTER_DATA));
        pBCD->CounterBlock.ByteLength = sizeof(BROWSER_COUNTER_DATA);

    }
    *lppData = (LPVOID)&pBCD[1];
    *lpcbTotalBytes =
        (DWORD)((LPBYTE)&pBCD[1] -
        (LPBYTE)pBrowserDataDefinition);
    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}

DWORD APIENTRY
CloseBrowserObject ()
{
    if (dllHandle != NULL) {
        FreeLibrary (dllHandle);
        dllHandle = NULL;
        BrowserStatFunction = NULL;
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\perfrdr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfrdr.c

Abstract:

    This file implements a Performance Object that presents
    Redirector Performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddnfs.h>
#include <ntioapi.h>
#include <windows.h>
#include <assert.h>
#include <srvfsctl.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfnet.h"
#include "netsvcmc.h"
#include "datardr.h"

static HANDLE  hRdr = NULL;

DWORD APIENTRY
OpenRedirObject (
    IN  LPWSTR  lpValueName
)
{
    UNICODE_STRING      DeviceNameU;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            status;
    RTL_RELATIVE_NAME   RelativeName;

    UNREFERENCED_PARAMETER (lpValueName);

    // open the handle to the server for data collection
    //
    //  Now get access to the Redirector for its data
    //

    RtlInitUnicodeString(&DeviceNameU, (LPCWSTR)DD_NFS_DEVICE_NAME_U);
    RelativeName.ContainingDirectory = NULL;

    InitializeObjectAttributes(&ObjectAttributes,
                                &DeviceNameU,
                                OBJ_CASE_INSENSITIVE,
                                RelativeName.ContainingDirectory,
                                NULL
                                );

    status = NtCreateFile(&hRdr,
                            SYNCHRONIZE,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_OPEN_IF,
                            FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0
                            );

    if (!NT_SUCCESS(status)) {
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFNET_UNABLE_OPEN_REDIR,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);
    }

    return (DWORD)RtlNtStatusToDosError(status);

}

DWORD APIENTRY
CollectRedirObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Physical Disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{

    DWORD           TotalLen;          //  Length of the total return block
    NTSTATUS        Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    RDR_DATA_DEFINITION *pRdrDataDefinition;
    RDR_COUNTER_DATA    *pRCD;

    REDIR_STATISTICS RdrStatistics;

    if ( hRdr == NULL ) {
        // redir didn't get opened and it has already been logged
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }
    //
    //  Check for sufficient space for redirector data
    //

    TotalLen = sizeof(RDR_DATA_DEFINITION) +
               sizeof(RDR_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define objects data block
    //

    pRdrDataDefinition = (RDR_DATA_DEFINITION *) *lppData;

    memcpy (pRdrDataDefinition,
            &RdrDataDefinition,
            sizeof(RDR_DATA_DEFINITION));

    //
    //  Format and collect redirector data
    //

    pRCD = (PRDR_COUNTER_DATA)&pRdrDataDefinition[1];

    // test for quadword alignment of the structure
    assert  (((DWORD)(pRCD) & 0x00000007) == 0);

    pRCD->CounterBlock.ByteLength = sizeof (RDR_COUNTER_DATA);

    Status = NtFsControlFile(hRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_LMR_GET_STATISTICS,
                                NULL,
                                0,
                                &RdrStatistics,
                                sizeof(RdrStatistics)
                                );
    if (NT_SUCCESS(Status)) {
        // transfer Redir data
        pRCD->Bytes             = RdrStatistics.BytesReceived.QuadPart +
                                  RdrStatistics.BytesTransmitted.QuadPart;
        pRCD->IoOperations      = RdrStatistics.ReadOperations +
                                  RdrStatistics.WriteOperations;
        pRCD->Smbs              = RdrStatistics.SmbsReceived.QuadPart +
                                  RdrStatistics.SmbsTransmitted.QuadPart;
        pRCD->BytesReceived     = RdrStatistics.BytesReceived.QuadPart;
        pRCD->SmbsReceived      = RdrStatistics.SmbsReceived.QuadPart;
        pRCD->PagingReadBytesRequested  = RdrStatistics.PagingReadBytesRequested.QuadPart;
        pRCD->NonPagingReadBytesRequested   = RdrStatistics.NonPagingReadBytesRequested.QuadPart;
        pRCD->CacheReadBytesRequested   = RdrStatistics.CacheReadBytesRequested.QuadPart;
        pRCD->NetworkReadBytesRequested = RdrStatistics.NetworkReadBytesRequested.QuadPart;
        pRCD->BytesTransmitted  = RdrStatistics.BytesTransmitted.QuadPart;
        pRCD->SmbsTransmitted   = RdrStatistics.SmbsTransmitted.QuadPart;
        pRCD->PagingWriteBytesRequested = RdrStatistics.PagingWriteBytesRequested.QuadPart;
        pRCD->NonPagingWriteBytesRequested  = RdrStatistics.NonPagingWriteBytesRequested.QuadPart;
        pRCD->CacheWriteBytesRequested  = RdrStatistics.CacheWriteBytesRequested.QuadPart;
        pRCD->NetworkWriteBytesRequested    = RdrStatistics.NetworkWriteBytesRequested.QuadPart;
        pRCD->ReadOperations    = RdrStatistics.ReadOperations;
        pRCD->RandomReadOperations  = RdrStatistics.RandomReadOperations;
        pRCD->ReadSmbs          = RdrStatistics.ReadSmbs;
        pRCD->LargeReadSmbs     = RdrStatistics.LargeReadSmbs;
        pRCD->SmallReadSmbs     = RdrStatistics.SmallReadSmbs;
        pRCD->WriteOperations   = RdrStatistics.WriteOperations;
        pRCD->RandomWriteOperations = RdrStatistics.RandomWriteOperations;
        pRCD->WriteSmbs         = RdrStatistics.WriteSmbs;
        pRCD->LargeWriteSmbs    = RdrStatistics.LargeWriteSmbs;
        pRCD->SmallWriteSmbs    = RdrStatistics.SmallWriteSmbs;
        pRCD->RawReadsDenied    = RdrStatistics.RawReadsDenied;
        pRCD->RawWritesDenied   = RdrStatistics.RawWritesDenied;
        pRCD->NetworkErrors     = RdrStatistics.NetworkErrors;
        pRCD->Sessions          = RdrStatistics.Sessions;
        pRCD->Reconnects        = RdrStatistics.Reconnects;
        pRCD->CoreConnects      = RdrStatistics.CoreConnects;
        pRCD->Lanman20Connects  = RdrStatistics.Lanman20Connects;
        pRCD->Lanman21Connects  = RdrStatistics.Lanman21Connects;
        pRCD->LanmanNtConnects  = RdrStatistics.LanmanNtConnects;
        pRCD->ServerDisconnects = RdrStatistics.ServerDisconnects;
        pRCD->HungSessions      = RdrStatistics.HungSessions;
        pRCD->CurrentCommands   = RdrStatistics.CurrentCommands;

    } else {

        //
        // Failure to access Redirector: clear counters to 0
        //

        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFNET_UNABLE_READ_REDIR,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&Status);

        memset(pRCD, 0, sizeof(RDR_COUNTER_DATA));
        pRCD->CounterBlock.ByteLength = sizeof (RDR_COUNTER_DATA);

    }

    *lppData = (LPVOID)&pRCD[1];

    *lpcbTotalBytes = (DWORD)((LPBYTE)&pRCD[1] - (LPBYTE)pRdrDataDefinition);
    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}

DWORD APIENTRY
CloseRedirObject ()
{
    if (hRdr != NULL) {
        NtClose(hRdr);
        hRdr = NULL;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\perfsrv.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfsrv.c

Abstract:

    This file implements a Performance Object that presents
    Server Performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddnfs.h>
#include <windows.h>
#include <assert.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmwksta.h>
#include <srvfsctl.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <assert.h>
#include <perfutil.h>
#include "perfnet.h"
#include "netsvcmc.h"
#include "datasrv.h"
#include "datasrvq.h"

#define MAX_SRVQ_NAME_LENGTH    16

static  HANDLE  hSrv = NULL;

static  SRV_QUEUE_STATISTICS *pSrvQueueStatistics = NULL;
static  DWORD  dwDataBufferLength = 0L;
static  SYSTEM_BASIC_INFORMATION BasicInfo;

static  BOOL bSrvQOk = TRUE;

DWORD APIENTRY
OpenServerObject (
    IN  LPWSTR  lpValueName
)
{
    STRING              DeviceName;
    UNICODE_STRING      DeviceNameU;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (lpValueName);

    // open the handle to the server for data collection
    //
    // Get access to the Server for it's data
    //

    RtlInitString(&DeviceName, SERVER_DEVICE_NAME);
    DeviceNameU.Buffer = NULL;
    status = RtlAnsiStringToUnicodeString(&DeviceNameU, &DeviceName, TRUE);
    if (NT_SUCCESS(status)) {
        InitializeObjectAttributes(&ObjectAttributes,
                                   &DeviceNameU,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                   );

        status = NtOpenFile(&hSrv,
                            SYNCHRONIZE,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            0,
                            FILE_SYNCHRONOUS_IO_NONALERT
                            );
    }

    if (!NT_SUCCESS(status)) {
        hSrv = NULL;
        bSrvQOk = FALSE;
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFNET_UNABLE_OPEN_SERVER,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);
    }

    if (DeviceNameU.Buffer) {
        RtlFreeUnicodeString(&DeviceNameU);
    }

    return (DWORD)RtlNtStatusToDosError(status);

}

DWORD APIENTRY
OpenServerQueueObject (
    IN  LPWSTR  szValueName
)
{
    NTSTATUS    status;

    UNREFERENCED_PARAMETER (szValueName);
    //
    //  collect basic and static processor data
    //

    status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &BasicInfo,
                    sizeof(SYSTEM_BASIC_INFORMATION),
                    NULL
                    );

    assert (NT_SUCCESS(status));
    if (!NT_SUCCESS(status)) {
        // all we really want is the number of processors so
        // if we can't get that from the system, then we'll
        // substitute 32 for the number
        BasicInfo.NumberOfProcessors = 32;
        status = ERROR_SUCCESS;
    }
    // compute the various buffer sizes required

    dwDataBufferLength = sizeof(SRV_QUEUE_STATISTICS) *
        (BasicInfo.NumberOfProcessors + 1);

    pSrvQueueStatistics = (SRV_QUEUE_STATISTICS *)ALLOCMEM (
        hLibHeap, HEAP_ZERO_MEMORY, dwDataBufferLength);

    // if memory allocation failed, then no server queue stats will
    // be returned.

    assert (pSrvQueueStatistics != NULL);

    if (pSrvQueueStatistics == NULL) {
        bSrvQOk = FALSE;
    }

    return ERROR_SUCCESS;

}

DWORD APIENTRY
CollectServerObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Physical Disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD  TotalLen;            //  Length of the total return block
    NTSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    SRV_DATA_DEFINITION *pSrvDataDefinition;
    SRV_COUNTER_DATA    *pSCD;

    SRV_STATISTICS SrvStatistics;

    if (hSrv == NULL) {
        // bail out if the server didn't get opened.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    //
    //  Check for sufficient space for server data
    //

    TotalLen = sizeof(SRV_DATA_DEFINITION) +
               sizeof(SRV_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        // bail out if the data won't fit in the caller's buffer
        // or the server didn't get opened.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define objects data block
    //

    pSrvDataDefinition = (SRV_DATA_DEFINITION *) *lppData;

    memcpy (pSrvDataDefinition,
           &SrvDataDefinition,
           sizeof(SRV_DATA_DEFINITION));

    //
    //  Format and collect server data
    //

    pSCD = (PSRV_COUNTER_DATA)&pSrvDataDefinition[1];

    // test for quadword alignment of the structure
    assert  (((DWORD)(pSCD) & 0x00000007) == 0);

    pSCD->CounterBlock.ByteLength = sizeof(SRV_COUNTER_DATA);

    Status = NtFsControlFile(hSrv,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_SRV_GET_STATISTICS,
                                NULL,
                                0,
                                &SrvStatistics,
                                sizeof(SrvStatistics)
                                );

    if ( NT_SUCCESS(Status) ) {
        pSCD->TotalBytes            = SrvStatistics.TotalBytesSent.QuadPart +
                                        SrvStatistics.TotalBytesReceived.QuadPart;

        pSCD->TotalBytesReceived    = SrvStatistics.TotalBytesReceived.QuadPart;
        pSCD->TotalBytesSent        = SrvStatistics.TotalBytesSent.QuadPart;
        pSCD->SessionsTimedOut      = SrvStatistics.SessionsTimedOut;
        pSCD->SessionsErroredOut    = SrvStatistics.SessionsErroredOut;
        pSCD->SessionsLoggedOff     = SrvStatistics.SessionsLoggedOff;
        pSCD->SessionsForcedLogOff  = SrvStatistics.SessionsForcedLogOff;
        pSCD->LogonErrors           = SrvStatistics.LogonErrors;
        pSCD->AccessPermissionErrors = SrvStatistics.AccessPermissionErrors;
        pSCD->GrantedAccessErrors   = SrvStatistics.GrantedAccessErrors;
        pSCD->SystemErrors          = SrvStatistics.SystemErrors;
        pSCD->BlockingSmbsRejected  = SrvStatistics.BlockingSmbsRejected;
        pSCD->WorkItemShortages     = SrvStatistics.WorkItemShortages;
        pSCD->TotalFilesOpened      = SrvStatistics.TotalFilesOpened;
        pSCD->CurrentOpenFiles      = SrvStatistics.CurrentNumberOfOpenFiles;
        pSCD->CurrentSessions       = SrvStatistics.CurrentNumberOfSessions;
        pSCD->CurrentOpenSearches   = SrvStatistics.CurrentNumberOfOpenSearches;
        pSCD->CurrentNonPagedPoolUsage = SrvStatistics.CurrentNonPagedPoolUsage;
        pSCD->NonPagedPoolFailures  = SrvStatistics.NonPagedPoolFailures;
        pSCD->PeakNonPagedPoolUsage = SrvStatistics.PeakNonPagedPoolUsage;
        pSCD->CurrentPagedPoolUsage = SrvStatistics.CurrentPagedPoolUsage;
        pSCD->PagedPoolFailures     = SrvStatistics.PagedPoolFailures;
        pSCD->PeakPagedPoolUsage    = SrvStatistics.PeakPagedPoolUsage;
        pSCD->ContextBlockQueueRate = SrvStatistics.TotalWorkContextBlocksQueued.Count;
        pSCD->NetLogon =
            pSCD->NetLogonTotal     = SrvStatistics.SessionLogonAttempts;

    } else {

        // log an event describing the error
        DWORD   dwData[4];
        DWORD   dwDataIndex = 0;

        dwData[dwDataIndex++] = Status;
        dwData[dwDataIndex++] = IoStatusBlock.Status;
        dwData[dwDataIndex++] = (DWORD)IoStatusBlock.Information;

        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,        // error type
            0,                          // category (not used)
            PERFNET_UNABLE_READ_SERVER, // error code
            NULL,                       // SID (not used),
            0,                          // number of strings
            dwDataIndex * sizeof(DWORD),  // sizeof raw data
            NULL,                       // message text array
            (LPVOID)&dwData[0]);        // raw data
        //
        // Failure to access Server: clear counters to 0
        //

        memset(pSCD, 0, sizeof(SRV_COUNTER_DATA));
        pSCD->CounterBlock.ByteLength = sizeof(SRV_COUNTER_DATA);
    }

    *lppData = (LPVOID)&pSCD[1];
    *lpcbTotalBytes = (DWORD)((LPBYTE)&pSCD[1] - (LPBYTE)pSrvDataDefinition);
    *lpNumObjectTypes = 1;
    return ERROR_SUCCESS;
}

DWORD APIENTRY
CollectServerQueueObjectData(
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Physical Disk object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD  TotalLen;            //  Length of the total return block
    LONG  nQueue;

    NTSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;

    SRVQ_DATA_DEFINITION        *pSrvQDataDefinition;
    PERF_INSTANCE_DEFINITION    *pPerfInstanceDefinition;
    SRVQ_COUNTER_DATA           *pSQCD;


    SRV_QUEUE_STATISTICS *pThisQueueStatistics;

    UNICODE_STRING      QueueName;
    WCHAR               QueueNameBuffer[MAX_SRVQ_NAME_LENGTH];

    if (!bSrvQOk) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    //
    //  Check for sufficient space for server data
    //

    TotalLen = sizeof(SRVQ_DATA_DEFINITION) +
               sizeof(PERF_INSTANCE_DEFINITION) +
               sizeof(SRVQ_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    // assign local pointer to current position in buffer
    pSrvQDataDefinition = (SRVQ_DATA_DEFINITION *) *lppData;

    //
    //  Define perf object data block
    //

    memcpy (pSrvQDataDefinition,
            &SrvQDataDefinition,
            sizeof(SRVQ_DATA_DEFINITION));

    //
    //  Format and collect server Queue data
    //

    QueueName.Length = 0;
    QueueName.MaximumLength = sizeof(QueueNameBuffer);
    QueueName.Buffer = QueueNameBuffer;

    Status = NtFsControlFile(hSrv,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_SRV_GET_QUEUE_STATISTICS,
                                NULL,
                                0,
                                pSrvQueueStatistics,
                                dwDataBufferLength
                                );

    if (NT_SUCCESS(Status)) {
        // server data was collected successfully so...
        // process each processor queue instance.

        nQueue = 0;
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                            &pSrvQDataDefinition[1];

        TotalLen = sizeof(SRVQ_DATA_DEFINITION);

        for (nQueue = 0; nQueue < BasicInfo.NumberOfProcessors; nQueue++) {
            // see if this instance will fit
            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                        8 +     // size of 3 (unicode) digit queuelength name
                        sizeof(SRVQ_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_MORE_DATA;
            }

            RtlIntegerToUnicodeString(nQueue,
                                      10,
                                      &QueueName);

            // there should be enough room for this instance so initialize it

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                (PVOID *) &pSQCD,
                0,
                0,
                (DWORD)-1,
                QueueName.Buffer);

            pSQCD->CounterBlock.ByteLength = sizeof (SRVQ_COUNTER_DATA);

            // initialize pointers for this instance
            pThisQueueStatistics = &pSrvQueueStatistics[nQueue];

            pSQCD->QueueLength = pThisQueueStatistics->QueueLength;
            pSQCD->ActiveThreads = pThisQueueStatistics->ActiveThreads;
            pSQCD->AvailableThreads = pThisQueueStatistics->AvailableThreads;
            pSQCD->AvailableWorkItems = pThisQueueStatistics->FreeWorkItems;
            pSQCD->BorrowedWorkItems = pThisQueueStatistics->StolenWorkItems;
            pSQCD->WorkItemShortages = pThisQueueStatistics->NeedWorkItem;
            pSQCD->CurrentClients = pThisQueueStatistics->CurrentClients;
            pSQCD->TotalBytesTransfered =
                pSQCD->BytesReceived = pThisQueueStatistics->BytesReceived.QuadPart;
            pSQCD->TotalBytesTransfered +=
                pSQCD->BytesSent = pThisQueueStatistics->BytesSent.QuadPart;
            pSQCD->TotalOperations =
                pSQCD->ReadOperations = pThisQueueStatistics->ReadOperations.QuadPart;
            pSQCD->TotalBytes =
                pSQCD->BytesRead = pThisQueueStatistics->BytesRead.QuadPart;
            pSQCD->TotalOperations +=
                pSQCD->WriteOperations = pThisQueueStatistics->WriteOperations.QuadPart;
            pSQCD->TotalBytes +=
                pSQCD->BytesWritten = pThisQueueStatistics->BytesWritten.QuadPart;
            pSQCD->TotalContextBlocksQueued = pThisQueueStatistics->TotalWorkContextBlocksQueued.Count;

            // update the current pointer
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pSQCD[1];
        }

        RtlInitUnicodeString (&QueueName, (LPCWSTR)L"Blocking Queue");

        // now load the "blocking" queue data
        // see if this instance will fit
        TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                QWORD_MULTIPLE(QueueName.Length + sizeof(WCHAR)) +
                sizeof (SRVQ_COUNTER_DATA);

        if ( *lpcbTotalBytes < TotalLen ) {
            // this instance won't fit so bail out
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        // there should be enough room for this instance so initialize it

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
            (PVOID *) &pSQCD,
            0,
            0,
            (DWORD)-1,
            QueueName.Buffer);

        pSQCD->CounterBlock.ByteLength = sizeof(SRVQ_COUNTER_DATA);

        // initialize pointers for this instance
        pThisQueueStatistics = &pSrvQueueStatistics[nQueue];

        pSQCD->QueueLength = pThisQueueStatistics->QueueLength;
        pSQCD->ActiveThreads = pThisQueueStatistics->ActiveThreads;
        pSQCD->AvailableThreads = pThisQueueStatistics->AvailableThreads;
        pSQCD->AvailableWorkItems = 0;
        pSQCD->BorrowedWorkItems = 0;
        pSQCD->WorkItemShortages = 0;
        pSQCD->CurrentClients = 0;
        pSQCD->TotalBytesTransfered =
            pSQCD->BytesReceived = pThisQueueStatistics->BytesReceived.QuadPart;
        pSQCD->TotalBytesTransfered +=
            pSQCD->BytesSent = pThisQueueStatistics->BytesSent.QuadPart;
        pSQCD->ReadOperations = 0;
        pSQCD->TotalBytes =
            pSQCD->BytesRead = pThisQueueStatistics->BytesRead.QuadPart;
        pSQCD->WriteOperations = 0;
        pSQCD->TotalBytes +=
            pSQCD->BytesWritten = pThisQueueStatistics->BytesWritten.QuadPart;
        pSQCD->TotalOperations = 0;
        pSQCD->TotalContextBlocksQueued = pThisQueueStatistics->TotalWorkContextBlocksQueued.Count;

        nQueue++; // to include the Blocking Queue statistics entry

        // update the current pointer
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pSQCD[1];

        // update queue (instance) count in object data block
        pSrvQDataDefinition->SrvQueueObjectType.NumInstances = nQueue;

        // update available length
        *lpcbTotalBytes =
            pSrvQDataDefinition->SrvQueueObjectType.TotalByteLength =
                (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pSrvQDataDefinition);

#if DBG
        if (*lpcbTotalBytes > TotalLen ) {
            DbgPrint ("\nPERFNET: Server Queue Perf Ctr. Instance Size Underestimated:");
            DbgPrint ("\nPERFNET:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
        }
#endif

        *lppData = (LPVOID)pPerfInstanceDefinition;

        *lpNumObjectTypes = 1;
        return ERROR_SUCCESS;
    } else {
        // unable to read server queue data for some reason so don't return this
        // object

        // log an event describing the error
        DWORD   dwData[4];
        DWORD   dwDataIndex = 0;

        dwData[dwDataIndex++] = Status;
        dwData[dwDataIndex++] = IoStatusBlock.Status;
        dwData[dwDataIndex++] = (DWORD)IoStatusBlock.Information;

        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,        // error type
            0,                          // category (not used)
            PERFNET_UNABLE_READ_SERVER_QUEUE, // error code
            NULL,                       // SID (not used),
            0,                          // number of strings
            dwDataIndex * sizeof(DWORD),  // sizeof raw data
            NULL,                       // message text array
            (LPVOID)&dwData[0]);        // raw data

        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }
}

DWORD APIENTRY
CloseServerObject ()
{
    if (hSrv != NULL) {
        NtClose(hSrv);
        hSrv = NULL;
    }

    return ERROR_SUCCESS;
}
DWORD APIENTRY
CloseServerQueueObject ()
{
    if (hLibHeap != NULL) {
        if (pSrvQueueStatistics != NULL) {
            FREEMEM (hLibHeap, 0, pSrvQueueStatistics);
            pSrvQueueStatistics = NULL;
        }
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\datacach.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATACACH.h

Abstract:

    Header file for the Windows NT Cache Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATACACH_H_
#define _DATACACH_H_

//
// Cache Performance Object
//

typedef struct _CACHE_DATA_DEFINITION {
    PERF_OBJECT_TYPE		CacheObjectType;
    PERF_COUNTER_DEFINITION	cdDataMaps;
    PERF_COUNTER_DEFINITION	cdSyncDataMaps;
    PERF_COUNTER_DEFINITION	cdAsyncDataMaps;
    PERF_COUNTER_DEFINITION	cdDataMapHits;
    PERF_COUNTER_DEFINITION	cdDataMapHitsBase;
    PERF_COUNTER_DEFINITION	cdDataMapPins;
    PERF_COUNTER_DEFINITION	cdDataMapPinsBase;
    PERF_COUNTER_DEFINITION	cdPinReads;
    PERF_COUNTER_DEFINITION	cdSyncPinReads;
    PERF_COUNTER_DEFINITION	cdAsyncPinReads;
    PERF_COUNTER_DEFINITION	cdPinReadHits;
    PERF_COUNTER_DEFINITION	cdPinReadHitsBase;
    PERF_COUNTER_DEFINITION	cdCopyReads;
    PERF_COUNTER_DEFINITION	cdSyncCopyReads;
    PERF_COUNTER_DEFINITION	cdAsyncCopyReads;
    PERF_COUNTER_DEFINITION	cdCopyReadHits;
    PERF_COUNTER_DEFINITION	cdCopyReadHitsBase;
    PERF_COUNTER_DEFINITION	cdMdlReads;
    PERF_COUNTER_DEFINITION	cdSyncMdlReads;
    PERF_COUNTER_DEFINITION	cdAsyncMdlReads;
    PERF_COUNTER_DEFINITION	cdMdlReadHits;
    PERF_COUNTER_DEFINITION	cdMdlReadHitsBase;
    PERF_COUNTER_DEFINITION	cdReadAheads;
    PERF_COUNTER_DEFINITION	cdFastReads;
    PERF_COUNTER_DEFINITION	cdSyncFastReads;
    PERF_COUNTER_DEFINITION	cdAsyncFastReads;
    PERF_COUNTER_DEFINITION	cdFastReadResourceMiss;
    PERF_COUNTER_DEFINITION	cdFastReadNotPossibles;
    PERF_COUNTER_DEFINITION	cdLazyWriteFlushes;
    PERF_COUNTER_DEFINITION	cdLazyWritePages;
    PERF_COUNTER_DEFINITION	cdDataFlushes;
    PERF_COUNTER_DEFINITION	cdDataPages;
} CACHE_DATA_DEFINITION, * PCACHE_DATA_DEFINITION;

typedef struct _CACHE_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   DataMaps;
    DWORD                   SyncDataMaps;
    DWORD                   AsyncDataMaps;
    DWORD                   DataMapHits;
    DWORD                   DataMapHitsBase;
    DWORD                   DataMapPins;
    DWORD                   DataMapPinsBase;
    DWORD                   PinReads;
    DWORD                   SyncPinReads;
    DWORD                   AsyncPinReads;
    DWORD                   PinReadHits;
    DWORD                   PinReadHitsBase;
    DWORD                   CopyReads;
    DWORD                   SyncCopyReads;
    DWORD                   AsyncCopyReads;
    DWORD                   CopyReadHits;
    DWORD                   CopyReadHitsBase;
    DWORD                   MdlReads;
    DWORD                   SyncMdlReads;
    DWORD                   AsyncMdlReads;
    DWORD                   MdlReadHits;
    DWORD                   MdlReadHitsBase;
    DWORD                   ReadAheads;
    DWORD                   FastReads;
    DWORD                   SyncFastReads;
    DWORD                   AsyncFastReads;
    DWORD                   FastReadResourceMiss;
    DWORD                   FastReadNotPossibles;
    DWORD                   LazyWriteFlushes;
    DWORD                   LazyWritePages;
    DWORD                   DataFlushes;
    DWORD                   DataPages;
} CACHE_COUNTER_DATA, * PCACHE_COUNTER_DATA;

extern CACHE_DATA_DEFINITION CacheDataDefinition;

#endif _DATACACH_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\datacach.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datacach.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Cache performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datacach.h"

// dummy variable for field sizing.
static CACHE_COUNTER_DATA ccd;

//
//  Constant structure initializations 
//      defined in datacach.h
//

CACHE_DATA_DEFINITION CacheDataDefinition = {

    {   sizeof(CACHE_DATA_DEFINITION) + sizeof (CACHE_COUNTER_DATA),
        sizeof(CACHE_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        CACHE_OBJECT_TITLE_INDEX,
        0,
        87,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(CACHE_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        3,
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        88,
        0,
        89,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.DataMaps),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataMaps
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        90,
        0,
        91,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.SyncDataMaps),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->SyncDataMaps
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        92,
        0,
        93,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.AsyncDataMaps),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->AsyncDataMaps
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        94,
        0,
        95,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_SAMPLE_FRACTION,
        sizeof(ccd.DataMapHits),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataMapHits
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        94,
        0,
        95,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_SAMPLE_BASE,
        sizeof(ccd.DataMapHitsBase),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataMapHitsBase
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        96,
        0,
        97,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_SAMPLE_FRACTION,
        sizeof(ccd.DataMapPins),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataMapPins
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        96,
        0,
        97,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_SAMPLE_BASE,
        sizeof(ccd.DataMapPinsBase),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataMapPinsBase
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        98,
        0,
        99,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.PinReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->PinReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        100,
        0,
        101,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.SyncPinReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->SyncPinReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        102,
        0,
        103,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.AsyncPinReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->AsyncPinReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        104,
        0,
        105,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_FRACTION,
        sizeof(ccd.PinReadHits),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->PinReadHits
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        104,
        0,
        105,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_BASE,
        sizeof(ccd.PinReadHitsBase),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->PinReadHitsBase
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        106,
        0,
        107,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.CopyReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->CopyReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        108,
        0,
        109,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.SyncCopyReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->SyncCopyReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        110,
        0,
        111,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.AsyncCopyReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->AsyncCopyReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        112,
        0,
        113,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_FRACTION,
        sizeof(ccd.CopyReadHits),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->CopyReadHits
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        112,
        0,
        113,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_BASE,
        sizeof(ccd.CopyReadHitsBase),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->CopyReadHitsBase
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        114,
        0,
        115,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.MdlReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->MdlReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        116,
        0,
        117,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.SyncMdlReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->SyncMdlReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        118,
        0,
        119,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.AsyncMdlReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->AsyncMdlReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        120,
        0,
        121,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_FRACTION,
        sizeof(ccd.MdlReadHits),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->MdlReadHits
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        120,
        0,
        121,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_SAMPLE_BASE,
        sizeof(ccd.MdlReadHitsBase),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->MdlReadHitsBase
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        122,
        0,
        123,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.ReadAheads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->ReadAheads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        124,
        0,
        125,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.FastReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->FastReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        126,
        0,
        127,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.SyncFastReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->SyncFastReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        128,
        0,
        129,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.AsyncFastReads),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->AsyncFastReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        130,
        0,
        131,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.FastReadResourceMiss),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->FastReadResourceMiss
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        132,
        0,
        133,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.FastReadNotPossibles),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->FastReadNotPossibles
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        134,
        0,
        135,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.LazyWriteFlushes),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->LazyWriteFlushes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        136,
        0,
        137,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.LazyWritePages),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->LazyWritePages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        138,
        0,
        139,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.DataFlushes),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataFlushes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        140,
        0,
        141,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(ccd.DataPages),
        (DWORD)(ULONG_PTR)&((PCACHE_COUNTER_DATA)0)->DataPages
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\netsvcs\perfnet.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfnet.c

Abstract:


Author:

    Bob Watson (a-robw) Aug 95

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <assert.h>
#include <perfutil.h>
#include "perfnet.h"
#include "netsvcmc.h"

// bit field definitions for collect function flags

#define POS_COLLECT_SERVER_DATA         ((DWORD)0x00000001)
#define POS_COLLECT_SERVER_QUEUE_DATA   ((DWORD)0x00000002)
#define POS_COLLECT_REDIR_DATA          ((DWORD)0x00000004)
#define POS_COLLECT_BROWSER_DATA        ((DWORD)0x00000008)

#define POS_COLLECT_GLOBAL_DATA         ((DWORD)0x0000000F)
#define POS_COLLECT_FOREIGN_DATA        ((DWORD)0)
#define POS_COLLECT_COSTLY_DATA         ((DWORD)0)

// global variables to this DLL

HANDLE  ThisDLLHandle = NULL;
HANDLE  hEventLog     = NULL;
HANDLE  hLibHeap      = NULL;

// variables local to this module

static POS_FUNCTION_INFO    posDataFuncInfo[] = {
    {SERVER_OBJECT_TITLE_INDEX,         POS_COLLECT_SERVER_DATA,    0, CollectServerObjectData},
    {SERVER_QUEUE_OBJECT_TITLE_INDEX,   POS_COLLECT_SERVER_QUEUE_DATA,     0, CollectServerQueueObjectData},
    {REDIRECTOR_OBJECT_TITLE_INDEX,     POS_COLLECT_REDIR_DATA,     0, CollectRedirObjectData},
    {BROWSER_OBJECT_TITLE_INDEX,        POS_COLLECT_BROWSER_DATA,   0, CollectBrowserObjectData}
};

#define POS_NUM_FUNCS   (sizeof(posDataFuncInfo) / sizeof(posDataFuncInfo[1]))

static  bInitOk  = FALSE;
static  DWORD   dwOpenCount = 0;

static  BOOL    bReportedNotOpen = FALSE;

PM_OPEN_PROC    OpenNetSvcsObject;
PM_COLLECT_PROC CollecNetSvcsObjectData;
PM_CLOSE_PROC   CloseNetSvcsObject;

static
BOOL
DllProcessAttach (
    IN  HANDLE DllHandle
)
/*++

Description:

    perform any initialization function that apply to all object
    modules
   
--*/
{
    BOOL    bReturn = TRUE;

    UNREFERENCED_PARAMETER (DllHandle);

    // create heap for this library
    if (hLibHeap == NULL) hLibHeap = HeapCreate (0, 1, 0);

    assert (hLibHeap != NULL);

    if (hLibHeap == NULL) {
        return FALSE;
    }
    // open handle to the event log
    if (hEventLog == NULL) hEventLog = MonOpenEventLog((LPWSTR)L"PerfNet");
    assert (hEventLog != NULL);

    return bReturn;
}

static
BOOL
DllProcessDetach (
    IN  HANDLE DllHandle
)
{
    UNREFERENCED_PARAMETER (DllHandle);

    if (dwOpenCount != 0) {
        // make sure the object has been closed before the
        // library is deleted.
        // setting dwOpenCount to 1 insures that all
        // the objects will be closed on this call
        if (dwOpenCount > 1) dwOpenCount = 1;
        CloseNetSvcsObject();
        dwOpenCount = 0;
    }

    if (hLibHeap != NULL) {
        HeapDestroy (hLibHeap); 
        hLibHeap = NULL;
    }

    if (hEventLog != NULL) {
        MonCloseEventLog ();
        hEventLog = NULL;
    }
    return TRUE;
}

BOOL
__stdcall
DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    ReservedAndUnused;

    // this will prevent the DLL from getting
    // the DLL_THREAD_* messages
    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach (DLLHandle);

        case DLL_PROCESS_DETACH:
            return DllProcessDetach (DLLHandle);

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            return TRUE;
    }
}

DWORD APIENTRY
OpenNetSvcsObject (
    LPWSTR lpDeviceNames
    )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    DWORD   dwErrorCount = 0;

    if (dwOpenCount == 0) {

        status = OpenServerObject (lpDeviceNames);
        // if this didn't open, it's not fatal, just no 
        // server stats will be returned
        if (status != ERROR_SUCCESS) {
            dwErrorCount++;
            status = ERROR_SUCCESS;
        }

        status = OpenServerQueueObject (lpDeviceNames);
        // if this didn't open, it's not fatal, just no 
        // server queue stats will be returned
        if (status != ERROR_SUCCESS) {
            dwErrorCount++;
            status = ERROR_SUCCESS;
        }

        status = OpenRedirObject (lpDeviceNames);
        // if this didn't open, it's not fatal, just no 
        // Redir stats will be returned
        if (status != ERROR_SUCCESS) {
            dwErrorCount++;
            status = ERROR_SUCCESS;
        }

        status = OpenBrowserObject (lpDeviceNames);
        // if this didn't open, it's not fatal, just no 
        // Browser stats will be returned
        if (status != ERROR_SUCCESS) {
            dwErrorCount++;
            status = ERROR_SUCCESS;
        }

        if (dwErrorCount < POS_NUM_FUNCS) {
            // then at least one object opened OK so continue
            bInitOk = TRUE;
            dwOpenCount++;
        } else {
            // none of the objects opened, so give up.
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_UNABLE_OPEN,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }
    } else {
        // already opened so bump the refcount
        dwOpenCount++;
    }

    return  status;
}

DWORD APIENTRY
CollectNetSvcsObjectData (
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;

    // build bit mask of functions to call

    DWORD       dwQueryType;
    DWORD       FunctionCallMask = 0;
    DWORD       FunctionIndex;

    DWORD       dwNumObjectsFromFunction;
    DWORD       dwOrigBuffSize;
    DWORD       dwByteSize;

    if (!bInitOk) {
        if (!bReportedNotOpen) {
            bReportedNotOpen = ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFNET_NOT_OPEN,
                NULL,
                0,
                0,
                NULL,
                NULL);
        }
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        goto COLLECT_BAIL_OUT;
    }

    dwQueryType = GetQueryType (lpValueName);

    switch (dwQueryType) {
        case QUERY_ITEMS:
            for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                if (IsNumberInUnicodeList (
                    posDataFuncInfo[FunctionIndex].dwObjectId, lpValueName)) {
                    FunctionCallMask |=
                        posDataFuncInfo[FunctionIndex].dwCollectFunctionBit;
                }
            }
            break;

        case QUERY_GLOBAL:
            FunctionCallMask = POS_COLLECT_GLOBAL_DATA;
            break;

        case QUERY_FOREIGN:
            FunctionCallMask = POS_COLLECT_FOREIGN_DATA;
            break;

        case QUERY_COSTLY:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;

        default:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;
    }

    // collect data 
    *lpNumObjectTypes = 0;
    dwOrigBuffSize = dwByteSize = *lpcbTotalBytes;
    *lpcbTotalBytes = 0;

    for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
        if (posDataFuncInfo[FunctionIndex].dwCollectFunctionBit &
            FunctionCallMask) {
            dwNumObjectsFromFunction = 0;
            lReturn = (*posDataFuncInfo[FunctionIndex].pCollectFunction) (
                lppData,
                &dwByteSize,
                &dwNumObjectsFromFunction);

            if (lReturn == ERROR_SUCCESS) {
                *lpNumObjectTypes += dwNumObjectsFromFunction;
                *lpcbTotalBytes += dwByteSize;
                dwOrigBuffSize -= dwByteSize;
                dwByteSize = dwOrigBuffSize;
            } else {
                break;
            }
        }
    }

    // *lppData is updated by each function
    // *lpcbTotalBytes is updated after each successful function
    // *lpNumObjects is updated after each successful function

COLLECT_BAIL_OUT:
    
    return lReturn;
}

DWORD APIENTRY
CloseNetSvcsObject (
)
/*++

Routine Description:

    This routine closes the open objects for the net services counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (dwOpenCount > 0) {
        dwOpenCount--;
    }
    if (dwOpenCount == 0) {
        // close stuff here
        CloseServerQueueObject();
        CloseServerObject();
        CloseRedirObject();
        CloseBrowserObject();
    }
    return  ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\datacpu.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATACPU.h

Abstract:

    Header file for the Windows NT Processor Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATACPU_H_
#define _DATACPU_H_

//
//  Processor data object
//

typedef struct _PROCESSOR_DATA_DEFINITION {
    PERF_OBJECT_TYPE		ProcessorObjectType;
    PERF_COUNTER_DEFINITION	cdProcessorTime;
    PERF_COUNTER_DEFINITION	cdUserTime;
    PERF_COUNTER_DEFINITION	cdKernelTime;
    PERF_COUNTER_DEFINITION	cdInterrupts;
    PERF_COUNTER_DEFINITION	cdDpcTime;
    PERF_COUNTER_DEFINITION	cdInterruptTime;
    PERF_COUNTER_DEFINITION cdDpcCountRate;
    PERF_COUNTER_DEFINITION cdDpcRate;
} PROCESSOR_DATA_DEFINITION, *PPROCESSOR_DATA_DEFINITION;

typedef struct _PROCESSOR_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   dwPad1;
    LONGLONG                ProcessorTime;
    LONGLONG                UserTime;
    LONGLONG                KernelTime;
    DWORD                   Interrupts;
    DWORD                   dwPad2;
    LONGLONG                DpcTime;
    LONGLONG                InterruptTime;
    DWORD                   DpcCountRate;
    DWORD                   DpcRate;
} PROCESSOR_COUNTER_DATA, *PPROCESSOR_COUNTER_DATA;

extern PROCESSOR_DATA_DEFINITION ProcessorDataDefinition;

typedef struct _EX_PROCESSOR_DATA_DEFINITION {
    PERF_OBJECT_TYPE		ProcessorObjectType;
    PERF_COUNTER_DEFINITION	cdProcessorTime;
    PERF_COUNTER_DEFINITION	cdUserTime;
    PERF_COUNTER_DEFINITION	cdKernelTime;
    PERF_COUNTER_DEFINITION	cdInterrupts;
    PERF_COUNTER_DEFINITION	cdDpcTime;
    PERF_COUNTER_DEFINITION	cdInterruptTime;
    PERF_COUNTER_DEFINITION cdDpcCountRate;
    PERF_COUNTER_DEFINITION cdDpcRate;
// Whistler counters
    PERF_COUNTER_DEFINITION cdIdleTime;
    PERF_COUNTER_DEFINITION cdC1Time;
    PERF_COUNTER_DEFINITION cdC2Time;
    PERF_COUNTER_DEFINITION cdC3Time;
    PERF_COUNTER_DEFINITION cdC1Transitions;
    PERF_COUNTER_DEFINITION cdC2Transitions;
    PERF_COUNTER_DEFINITION cdC3Transitions;
} EX_PROCESSOR_DATA_DEFINITION, *PEX_PROCESSOR_DATA_DEFINITION;

typedef struct _EX_PROCESSOR_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   dwPad1;
    LONGLONG                ProcessorTime;
    LONGLONG                UserTime;
    LONGLONG                KernelTime;
    DWORD                   Interrupts;
    DWORD                   dwPad2;
    LONGLONG                DpcTime;
    LONGLONG                InterruptTime;
    DWORD                   DpcCountRate;
    DWORD                   DpcRate;
// Whistler counters
    LONGLONG                IdleTime;
    LONGLONG                C1Time;
    LONGLONG                C2Time;
    LONGLONG                C3Time;
    LONGLONG                C1Transitions;
    LONGLONG                C2Transitions;
    LONGLONG                C3Transitions;
} EX_PROCESSOR_COUNTER_DATA, *PEX_PROCESSOR_COUNTER_DATA;

extern EX_PROCESSOR_DATA_DEFINITION ExProcessorDataDefinition;
#endif // _DATACPU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\datacpu.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datacpu.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Processor Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datacpu.h"

// dummy variable for field sizing.
static PROCESSOR_COUNTER_DATA   pcd;
static EX_PROCESSOR_COUNTER_DATA   expcd;

//
//  Constant structure initializations 
//      defined in datacpu.h
//

PROCESSOR_DATA_DEFINITION ProcessorDataDefinition = {
    {   0,
        sizeof(PROCESSOR_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        PROCESSOR_OBJECT_TITLE_INDEX,
        0,
        239,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(PROCESSOR_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        7,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_100NSEC_TIMER_INV,
        sizeof(pcd.ProcessorTime),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->ProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        143,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(pcd.UserTime),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->UserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        145,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(pcd.KernelTime),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->KernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        148,
        0,
        149,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(pcd.Interrupts),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->Interrupts
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        696,
        0,
        339,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(pcd.DpcTime),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->DpcTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        698,
        0,
        397,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(pcd.InterruptTime),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->InterruptTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1334,
        0,
        1335,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(pcd.DpcCountRate),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->DpcCountRate
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1336,
        0,
        1337,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.DpcRate),
        (DWORD)(ULONG_PTR)&((PPROCESSOR_COUNTER_DATA)0)->DpcRate
    },
};

//
//  Constant structure initializations 
//      defined in datacpu.h
//

EX_PROCESSOR_DATA_DEFINITION ExProcessorDataDefinition = {
    {   0,
        sizeof(EX_PROCESSOR_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        PROCESSOR_OBJECT_TITLE_INDEX,
        0,
        239,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(EX_PROCESSOR_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        7,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_100NSEC_TIMER_INV,
        sizeof(expcd.ProcessorTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->ProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        143,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(expcd.UserTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->UserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        145,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(expcd.KernelTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->KernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        148,
        0,
        149,
        0,
        -2,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(expcd.Interrupts),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->Interrupts
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        696,
        0,
        339,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(expcd.DpcTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->DpcTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        698,
        0,
        397,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(expcd.InterruptTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->InterruptTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1334,
        0,
        1335,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(expcd.DpcCountRate),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->DpcCountRate
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1336,
        0,
        1337,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(expcd.DpcRate),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->DpcRate
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1746,
        0,
        1747,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_100NSEC_TIMER,
        sizeof(expcd.IdleTime),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->IdleTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1748,
        0,
        1749,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_100NSEC_TIMER,
        sizeof(expcd.C1Time),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C1Time
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1750,
        0,
        1751,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_100NSEC_TIMER,
        sizeof(expcd.C2Time),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C2Time
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1752,
        0,
        1753,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_100NSEC_TIMER,
        sizeof(expcd.C3Time),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C3Time
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1754,
        0,
        1755,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_BULK_COUNT,
        sizeof(expcd.C1Transitions),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C1Transitions
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1756,
        0,
        1757,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_BULK_COUNT,
        sizeof(expcd.C2Transitions),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C2Transitions
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1758,
        0,
        1759,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_BULK_COUNT,
        sizeof(expcd.C3Transitions),
        (DWORD)(ULONG_PTR)&((PEX_PROCESSOR_COUNTER_DATA)0)->C3Transitions
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\dataos.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAOS.h

Abstract:

    Header file for the Windows NT Operating System Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAOS_H_
#define _DATAOS_H_

#include "datasys.h"
#include "datacpu.h"
#include "datamem.h"
#include "datacach.h"
#include "dataobj.h"
#include "datapage.h"
#endif //_DATAOS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\datamem.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datamem.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Memory performance data objects

Created:

    Bob Watson  20-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datamem.h"

// dummy variable for field sizing.
static MEMORY_COUNTER_DATA  mcd;

//
//  Constant structure initializations 
//      defined in datagen.h
//
MEMORY_DATA_DEFINITION MemoryDataDefinition = {
    {   sizeof(MEMORY_DATA_DEFINITION) + sizeof(MEMORY_COUNTER_DATA),
        sizeof(MEMORY_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        MEMORY_OBJECT_TITLE_INDEX,
        0,
        5,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(MEMORY_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        8,
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        28,
        0,
        29,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(mcd.PageFaults),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PageFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        24,
        0,
        25,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.AvailablePages),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->AvailablePages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        26,
        0,
        27,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.CommittedPages),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CommittedPages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        30,
        0,
        31,
        0,
        -6,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.CommitList),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CommitList
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        32,
        0,
        33,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(mcd.WriteCopies),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->WriteCopies
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        34,
        0,
        35,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(mcd.TransitionFaults),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->TransitionFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        36,
        0,
        37,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(mcd.CacheFaults),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CacheFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        38,
        0,
        39,
        0,
        -1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(mcd.DemandZeroFaults),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->DemandZeroFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        40,
        0,
        41,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(mcd.Pages),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->Pages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
	822,
        0,
        823,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(mcd.PagesInput),
	(DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PagesInput
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        42,
        0,
        43,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(mcd.PageReads),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PageReads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        48,
        0,
        49,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(mcd.DirtyPages),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->DirtyPages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        56,
        0,
        57,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.PagedPool),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        58,
        0,
        59,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.NonPagedPool),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->NonPagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        50,
        0,
        51,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(mcd.DirtyWrites),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->DirtyWrites
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        60,
        0,
        61,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(mcd.PagedPoolAllocs),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PagedPoolAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        64,
        0,
        65,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(mcd.NonPagedPoolAllocs),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->NonPagedPoolAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        678,
        0,
        679,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(mcd.FreeSystemPtes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->FreeSystemPtes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        818,
        0,
        819,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.CacheBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CacheBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        820,
        0,
        821,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.PeakCacheBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->PeakCacheBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        66,
        0,
        63,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.ResidentPagedPoolBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->ResidentPagedPoolBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        68,
        0,
        69,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.TotalSysCodeBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->TotalSysCodeBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        70,
        0,
        71,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.ResidentSysCodeBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->ResidentSysCodeBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        72,
        0,
        73,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.TotalSysDriverBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->TotalSysDriverBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        74,
        0,
        75,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.ResidentSysDriverBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->ResidentSysDriverBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        76,
        0,
        77,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.ResidentSysCacheBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->ResidentSysCacheBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1406,
        0,
        1407,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_RAW_FRACTION,
        sizeof(mcd.CommitBytesInUse),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CommitBytesInUse
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1406,
        0,
        1407,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_RAW_BASE,
        sizeof(mcd.CommitBytesLimit),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->CommitBytesLimit
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1380,
        0,
        1381,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.AvailableKBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->AvailableKBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1382,
        0,
        1383,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.AvailableMBytes),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->AvailableMBytes
#if 0 	// these are no longer supported
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1374,
        0,
        1375,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.SystemVlmCommitCharge),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->SystemVlmCommitCharge
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1376,
        0,
        1377,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.SystemVlmPeakCommitCharge),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->SystemVlmPeakCommitCharge
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1378,
        0,
        1379,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(mcd.SystemVlmSharedCommitCharge),
        (DWORD)(ULONG_PTR)&((PMEMORY_COUNTER_DATA)0)->SystemVlmSharedCommitCharge
#endif
    }
};



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\dataobj.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAOBJ.h

Abstract:

    Header file for the Windows NT OS Objects Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

//
//  Objects Performance Data Object
//

typedef struct _OBJECTS_DATA_DEFINITION {
    PERF_OBJECT_TYPE            ObjectsObjectType;
    PERF_COUNTER_DEFINITION     cdProcesses;
    PERF_COUNTER_DEFINITION     cdThreads;
    PERF_COUNTER_DEFINITION     cdEvents;
    PERF_COUNTER_DEFINITION     cdSemaphores;
    PERF_COUNTER_DEFINITION     cdMutexes;
    PERF_COUNTER_DEFINITION     cdSections;
} OBJECTS_DATA_DEFINITION, * POBJECTS_DATA_DEFINITION;

typedef struct _OBJECTS_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                       Processes;
    DWORD                       Threads;
    DWORD                       Events;
    DWORD                       Semaphores;
    DWORD                       Mutexes;
    DWORD                       Sections;
} OBJECTS_COUNTER_DATA, * POBJECTS_COUNTER_DATA;


extern OBJECTS_DATA_DEFINITION ObjectsDataDefinition;

#endif // _DATAOBJ_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\datamem.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

      DATAMEM.h

Abstract:

    Header file for the Windows NT Memory Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAMEM_H_
#define _DATAMEM_H_

//
//  Memory Performance Counter
//

typedef struct _MEMORY_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    MemoryObjectType;
    PERF_COUNTER_DEFINITION	    cdPageFaults;
    PERF_COUNTER_DEFINITION     cdAvailablePages;
    PERF_COUNTER_DEFINITION	    cdCommittedPages;
    PERF_COUNTER_DEFINITION     cdCommitList;
    PERF_COUNTER_DEFINITION	    cdWriteCopies;
    PERF_COUNTER_DEFINITION	    cdTransitionFaults;
    PERF_COUNTER_DEFINITION     cdCacheFaults;
    PERF_COUNTER_DEFINITION	    cdDemandZeroFaults;
    PERF_COUNTER_DEFINITION     cdPages;
    PERF_COUNTER_DEFINITION	    cdPagesInput;
    PERF_COUNTER_DEFINITION     cdPageReads;
    PERF_COUNTER_DEFINITION	    cdDirtyPages;
    PERF_COUNTER_DEFINITION     cdPagedPool;
    PERF_COUNTER_DEFINITION	    cdNonPagedPool;
    PERF_COUNTER_DEFINITION	    cdDirtyWrites;
    PERF_COUNTER_DEFINITION	    cdPagedPoolAllocs;
    PERF_COUNTER_DEFINITION	    cdNonPagedPoolAllocs;
    PERF_COUNTER_DEFINITION     cdFreeSystemPtes;
    PERF_COUNTER_DEFINITION     cdCacheBytes;
    PERF_COUNTER_DEFINITION     cdPeakCacheBytes;
    PERF_COUNTER_DEFINITION     cdResidentPagedPoolBytes;
    PERF_COUNTER_DEFINITION     cdTotalSysCodeBytes;
    PERF_COUNTER_DEFINITION     cdResidentSysCodeBytes;
    PERF_COUNTER_DEFINITION     cdTotalSsysDriverBytes;
    PERF_COUNTER_DEFINITION     cdResidentSysDriverBytes;
    PERF_COUNTER_DEFINITION     cdResidentSysCacheBytes;
    PERF_COUNTER_DEFINITION     cdCommitBytesInUse;
    PERF_COUNTER_DEFINITION     cdCommitBytesLimit;
    PERF_COUNTER_DEFINITION     cdAvailableKBytes;
    PERF_COUNTER_DEFINITION     cdAvailableMBytes;
//    PERF_COUNTER_DEFINITION	    cdSystemVlmCommitCharge;
//    PERF_COUNTER_DEFINITION	    cdSystemVlmPeakCommitCharge;
//    PERF_COUNTER_DEFINITION	    cdSystemVlmSharedCommitCharge;
} MEMORY_DATA_DEFINITION, * PMEMORY_DATA_DEFINITION;

typedef struct _MEMORY_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                       PageFaults;
    LONGLONG                    AvailablePages;
    LONGLONG                    CommittedPages;
    LONGLONG                    CommitList;
    DWORD                       WriteCopies;
    DWORD                       TransitionFaults;
    DWORD                       CacheFaults;
    DWORD                       DemandZeroFaults;
    DWORD                       Pages;
    DWORD                       PagesInput;
    DWORD                       PageReads;
    DWORD                       DirtyPages;
    LONGLONG                    PagedPool;
    LONGLONG                    NonPagedPool;
    DWORD                       DirtyWrites;
    DWORD                       PagedPoolAllocs;
    DWORD                       NonPagedPoolAllocs;
    DWORD                       FreeSystemPtes;
    LONGLONG                    CacheBytes;
    LONGLONG                    PeakCacheBytes;
    LONGLONG                    ResidentPagedPoolBytes;
    LONGLONG                    TotalSysCodeBytes;
    LONGLONG                    ResidentSysCodeBytes;
    LONGLONG                    TotalSysDriverBytes;
    LONGLONG                    ResidentSysDriverBytes;
    LONGLONG                    ResidentSysCacheBytes;
    DWORD                       CommitBytesInUse;
    DWORD                       CommitBytesLimit;
    LONGLONG                    AvailableKBytes;
    LONGLONG                    AvailableMBytes;
//    LONGLONG                    SystemVlmCommitCharge;
//    LONGLONG                    SystemVlmPeakCommitCharge;
//    LONGLONG                    SystemVlmSharedCommitCharge;
} MEMORY_COUNTER_DATA, *PMEMORY_COUNTER_DATA;

extern MEMORY_DATA_DEFINITION MemoryDataDefinition;

#endif //_DATAMEM_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\dataobj.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataobj.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the OS Object performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataobj.h"

// dummy variable for field sizing.
static OBJECTS_COUNTER_DATA ocd;

//
//  Constant structure initializations 
//      defined in dataobj.h
//
OBJECTS_DATA_DEFINITION ObjectsDataDefinition = {

    {   sizeof(OBJECTS_DATA_DEFINITION) + sizeof(OBJECTS_COUNTER_DATA),
        sizeof(OBJECTS_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        OBJECT_OBJECT_TITLE_INDEX,
        0,
        261,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(OBJECTS_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        248,
        0,
        249,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(ocd.Processes),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Processes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        250,
        0,
        251,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(ocd.Threads),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Threads
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        252,
        0,
        253,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(ocd.Events),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Events
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        254,
        0,
        255,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(ocd.Semaphores),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Semaphores
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        256,
        0,
        257,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(ocd.Mutexes),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Mutexes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        258,
        0,
        259,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(ocd.Sections),
        (DWORD)(ULONG_PTR)&((POBJECTS_COUNTER_DATA)0)->Sections
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\datapage.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datapage.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Page file performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datapage.h"

// dummy variable for field sizing.
static PAGEFILE_COUNTER_DATA    pcd;

//
//  Constant structure initializations 
//      defined in datapage.h
//

PAGEFILE_DATA_DEFINITION  PagefileDataDefinition = {
    {   sizeof (PAGEFILE_DATA_DEFINITION) +  sizeof(PAGEFILE_COUNTER_DATA),
        sizeof (PAGEFILE_DATA_DEFINITION),
        sizeof (PERF_OBJECT_TYPE),
        PAGEFILE_OBJECT_TITLE_INDEX,
        0,
        701,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(PAGEFILE_DATA_DEFINITION) - sizeof (PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof (PERF_COUNTER_DEFINITION),
        702,
        0,
        703,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof (pcd.PercentInUse),
        (DWORD)(ULONG_PTR)&((PPAGEFILE_COUNTER_DATA)0)->PercentInUse
    },
    {   sizeof (PERF_COUNTER_DEFINITION),
        702,
        0,
        703,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof (pcd.PercentInUseBase),
        (DWORD)(ULONG_PTR)&((PPAGEFILE_COUNTER_DATA)0)->PercentInUseBase
    },
    {   sizeof (PERF_COUNTER_DEFINITION),
        704,
        0,
        705,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof (pcd.PeakUsage),
        (DWORD)(ULONG_PTR)&((PPAGEFILE_COUNTER_DATA)0)->PeakUsage
    },
    {   sizeof (PERF_COUNTER_DEFINITION),
        704,
        0,
        705,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof (pcd.PeakUsageBase),
        (DWORD)(ULONG_PTR)&((PPAGEFILE_COUNTER_DATA)0)->PeakUsageBase
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\datapage.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAPAGE.h

Abstract:

    Header file for the Windows NT Operating System Pagefile
    Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAPAGE_H_
#define _DATAPAGE_H_

//
//  Pagefile performance object
//

typedef struct _PAGEFILE_DATA_DEFINITION {
    PERF_OBJECT_TYPE        PagefileObjectType;
    PERF_COUNTER_DEFINITION cdPercentInUse;
    PERF_COUNTER_DEFINITION cdPercentInUseBase;
    PERF_COUNTER_DEFINITION cdPeakUsage;
    PERF_COUNTER_DEFINITION cdPeakUsageBase;
} PAGEFILE_DATA_DEFINITION, * PPAGEFILE_DATA_DEFINITION;

typedef struct _PAGEFILE_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                       PercentInUse;
    DWORD                       PercentInUseBase;
    DWORD                       PeakUsage;
    DWORD                       PeakUsageBase;
} PAGEFILE_COUNTER_DATA, *PPAGEFILE_COUNTER_DATA;

extern PAGEFILE_DATA_DEFINITION  PagefileDataDefinition;

#endif //_DATAPAGE_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\datasys.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datasys.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Operating System performance data objects

    This file contains a set of constant data structures which are
    currently defined for the Signal Generator Perf DLL.

Created:

    Bob Watson  20-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datasys.h"

// dummy variable for field sizing.
static SYSTEM_COUNTER_DATA scd;

//
//  Constant structure initializations 
//      defined in datasys.h
//

SYSTEM_DATA_DEFINITION SystemDataDefinition = {
    {   sizeof(SYSTEM_DATA_DEFINITION) + sizeof(SYSTEM_COUNTER_DATA),
        sizeof(SYSTEM_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        SYSTEM_OBJECT_TITLE_INDEX,
        0,
        3,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(SYSTEM_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
         sizeof(PERF_COUNTER_DEFINITION),
        8,       // Default: TOTAL_PROCESSOR_TIME
        -1,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        10,
        0,
        11,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(scd.ReadOperations),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ReadOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        12,
        0,
        13,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(scd.WriteOperations),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->WriteOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        14,
        0,
        15,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(scd.OtherIOOperations),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->OtherIOOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        16,
        0,
        17,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof(scd.ReadBytes),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ReadBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        18,
        0,
        19,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof(scd.WriteBytes),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->WriteBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        20,
        0,
        21,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_BULK_COUNT,
        sizeof(scd.OtherIOBytes),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->OtherIOBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        146,
        0,
        147,
        0,
        -2,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(scd.ContextSwitches),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ContextSwitches
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        150,
        0,
        151,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(scd.SystemCalls),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->SystemCalls
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        406,
        0,
        407,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(scd.TotalReadWrites),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->TotalReadWrites
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        674,
        0,
        675,
        0,
        -5,
        PERF_DETAIL_NOVICE,
        PERF_ELAPSED_TIME,
        sizeof(scd.SystemElapsedTime),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->SystemElapsedTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        44,
        0,
        45,
        0,
        1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(scd.ProcessorQueueLength),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ProcessorQueueLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        248,
        0,
        249,
        0,
        1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(scd.ProcessCount),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ProcessCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        250,
        0,
        251,
        0,
        1,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(scd.ThreadCount),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ThreadCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        686,
        0,
        687,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(scd.AlignmentFixups),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->AlignmentFixups
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        688,
        0,
        689,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(scd.ExceptionDispatches),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->ExceptionDispatches
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        690,
        0,
        691,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof(scd.FloatingPointEmulations),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->FloatingPointEmulations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1350,
        0,
        1351,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(scd.RegistryQuotaUsed),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->RegistryQuotaUsed
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1350,
        0,
        1351,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(scd.RegistryQuotaAllowed),
        (DWORD)(ULONG_PTR)&((PSYSTEM_COUNTER_DATA)0)->RegistryQuotaAllowed
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\perfcach.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfcach.c

Abstract:

    This file implements an Performance Object that presents
    File System Cache data

Created:    

    Bob Watson  22-Oct-1996

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfos.h"
#include "datacach.h"

//
//  The following special defines are used to produce numbers for
//  cache measurement counters
//

#define SYNC_ASYNC(FLD) ((SysPerfInfo.FLD##Wait) + (SysPerfInfo.FLD##NoWait))

//
// Hit Rate Macro
//
#define HITRATE(FLD) (((Changes = SysPerfInfo.FLD) == 0) ? 0 :                                         \
                      ((Changes < (Misses = SysPerfInfo.FLD##Miss)) ? 0 :                              \
                      (Changes - Misses) ))

//
// Hit Rate Macro combining Sync and Async cases
//

#define SYNC_ASYNC_HITRATE(FLD) (((Changes = SYNC_ASYNC(FLD)) == 0) ? 0 : \
                                   ((Changes < \
                                    (Misses = SysPerfInfo.FLD##WaitMiss + \
                                              SysPerfInfo.FLD##NoWaitMiss) \
                                   ) ? 0 : \
                                  (Changes - Misses) ))


DWORD APIENTRY
CollectCacheObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the XXX object

Arguments:

        IN OUT   LPVOID   *lppData
                IN: pointer to the address of the buffer to receive the completed
                    PerfDataBlock and subordinate structures. This routine will
                    append its data to the buffer starting at the point referenced
                    by *lppData.
                OUT: points to the first byte after the data structure added by this
                    routine. This routine updated the value at lppdata after appending
                    its data.

        IN OUT   LPDWORD  lpcbTotalBytes
                IN: the address of the DWORD that tells the size in bytes of the
                    buffer referenced by the lppData argument
                OUT: the number of bytes added by this routine is writted to the
                    DWORD pointed to by this argument

        IN OUT   LPDWORD  NumObjectTypes
                IN: the address of the DWORD to receive the number of objects added
                    by this routine
                OUT: the number of objects added by this routine is writted to the
                    DWORD pointed to by this argument

         Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD  TotalLen;            //  Length of the total return block
    DWORD  Changes;             //  Used by macros to compute cache
    DWORD  Misses;              //  ...statistics

    PCACHE_DATA_DEFINITION  pCacheDataDefinition;
    PCACHE_COUNTER_DATA     pCCD;

    //
    //  Check for enough space for cache data block
    //

    pCacheDataDefinition = (CACHE_DATA_DEFINITION *) *lppData;

    TotalLen = sizeof(CACHE_DATA_DEFINITION) +
                sizeof(CACHE_COUNTER_DATA);

    TotalLen = QWORD_MULTIPLE(TotalLen);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define cache data block
    //


    memcpy (pCacheDataDefinition,
        &CacheDataDefinition,
        sizeof(CACHE_DATA_DEFINITION));

    //
    //  Format and collect memory data
    //

    pCCD = (PCACHE_COUNTER_DATA)&pCacheDataDefinition[1];

    pCCD->CounterBlock.ByteLength = sizeof(CACHE_COUNTER_DATA);

    //
    //  The Data Map counter is the sum of the Wait/NoWait cases
    //

    pCCD->DataMaps = SYNC_ASYNC(CcMapData);

    pCCD->SyncDataMaps = SysPerfInfo.CcMapDataWait;
    pCCD->AsyncDataMaps = SysPerfInfo.CcMapDataNoWait;

    //
    //  The Data Map Hits is a percentage of Data Maps that hit
    //  the cache; second counter is the base (divisor)
    //

    pCCD->DataMapHits = SYNC_ASYNC_HITRATE(CcMapData);
    pCCD->DataMapHitsBase = SYNC_ASYNC(CcMapData);

    //
    //  The next pair of counters forms a percentage of
    //  Pins as a portion of Data Maps
    //

    pCCD->DataMapPins = SysPerfInfo.CcPinMappedDataCount;
    pCCD->DataMapPinsBase = SYNC_ASYNC(CcMapData);

    pCCD->PinReads = SYNC_ASYNC(CcPinRead);
    pCCD->SyncPinReads = SysPerfInfo.CcPinReadWait;
    pCCD->AsyncPinReads = SysPerfInfo.CcPinReadNoWait;

    //
    //  The Pin Read Hits is a percentage of Pin Reads that hit
    //  the cache; second counter is the base (divisor)
    //

    pCCD->PinReadHits = SYNC_ASYNC_HITRATE(CcPinRead);
    pCCD->PinReadHitsBase = SYNC_ASYNC(CcPinRead);


    pCCD->CopyReads = SYNC_ASYNC(CcCopyRead);
    pCCD->SyncCopyReads = SysPerfInfo.CcCopyReadWait;
    pCCD->AsyncCopyReads = SysPerfInfo.CcCopyReadNoWait;

    //
    //  The Copy Read Hits is a percentage of Copy Reads that hit
    //  the cache; second counter is the base (divisor)
    //

    pCCD->CopyReadHits = SYNC_ASYNC_HITRATE(CcCopyRead);
    pCCD->CopyReadHitsBase = SYNC_ASYNC(CcCopyRead);


    pCCD->MdlReads = SYNC_ASYNC(CcMdlRead);
    pCCD->SyncMdlReads = SysPerfInfo.CcMdlReadWait;
    pCCD->AsyncMdlReads = SysPerfInfo.CcMdlReadNoWait;

    //
    //  The Mdl Read Hits is a percentage of Mdl Reads that hit
    //  the cache; second counter is the base (divisor)
    //

    pCCD->MdlReadHits = SYNC_ASYNC_HITRATE(CcMdlRead);
    pCCD->MdlReadHitsBase = SYNC_ASYNC(CcMdlRead);

    pCCD->ReadAheads = SysPerfInfo.CcReadAheadIos;

    pCCD->FastReads = SYNC_ASYNC(CcFastRead);
    pCCD->SyncFastReads = SysPerfInfo.CcFastReadWait;
    pCCD->AsyncFastReads = SysPerfInfo.CcFastReadNoWait;

    pCCD->FastReadResourceMiss = SysPerfInfo.CcFastReadResourceMiss;
    pCCD->FastReadNotPossibles = SysPerfInfo.CcFastReadNotPossible;
    pCCD->LazyWriteFlushes = SysPerfInfo.CcLazyWriteIos;
    pCCD->LazyWritePages = SysPerfInfo.CcLazyWritePages;
    pCCD->DataFlushes = SysPerfInfo.CcDataFlushes;
    pCCD->DataPages = SysPerfInfo.CcDataPages;

    *lppData = (LPVOID)&pCCD[1];

    // round up buffer to the nearest QUAD WORD
    
    *lppData = ALIGN_ON_QWORD (*lppData);

    *lpcbTotalBytes =
        pCacheDataDefinition->CacheObjectType.TotalByteLength =
            (DWORD)((LPBYTE)*lppData - (LPBYTE)pCacheDataDefinition);

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\perfmem.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfmem.c

Abstract:

    This file implements an Performance Object that presents
    System Memory Performance Object

Created:    

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntmmapi.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfos.h"
#include "perfosmc.h"
#include "datamem.h"

static  DWORD   dwOpenCount = 0;        // count of "Open" threads


DWORD APIENTRY
CollectMemoryObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the XXX object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

    Returns:

        0 if successful, else Win 32 error code of failure

--*/
{
    NTSTATUS Status;
    DWORD  TotalLen;            //  Length of the total return block

    PMEMORY_DATA_DEFINITION         pMemoryDataDefinition;
    SYSTEM_FILECACHE_INFORMATION    FileCache;
    PMEMORY_COUNTER_DATA    pMCD;
    DWORD       LocalPageSize;

    pMemoryDataDefinition = (MEMORY_DATA_DEFINITION *) *lppData;

    //
    //  Check for enough space for memory data block
    //

    TotalLen = sizeof(MEMORY_DATA_DEFINITION) +
                sizeof(MEMORY_COUNTER_DATA);

    TotalLen = QWORD_MULTIPLE (TotalLen);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    Status = NtQuerySystemInformation(
                SystemFileCacheInformation,
                &FileCache,
                sizeof(FileCache),
                NULL
                );

    if (!NT_SUCCESS(Status)) {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_FILE_CACHE_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&Status);
        memset (&FileCache, 0, sizeof(FileCache));
    }

    //
    //  Define memory data block
    //

    memcpy (pMemoryDataDefinition,
        &MemoryDataDefinition,
        sizeof(MEMORY_DATA_DEFINITION));

    //
    //  Format and collect memory data
    //

    LocalPageSize = BasicInfo.PageSize;

    pMCD = (PMEMORY_COUNTER_DATA)&pMemoryDataDefinition[1];

    pMCD->CounterBlock.ByteLength = sizeof (MEMORY_COUNTER_DATA);

    pMCD->AvailablePages = SysPerfInfo.AvailablePages;
    pMCD->AvailablePages *= LocalPageSize; // display as bytes
    pMCD->AvailableKBytes = pMCD->AvailablePages / 1024;
    pMCD->AvailableMBytes = pMCD->AvailableKBytes / 1024;
    pMCD->CommittedPages = SysPerfInfo.CommittedPages;
    pMCD->CommittedPages *= LocalPageSize;
    pMCD->CommitList    = SysPerfInfo.CommitLimit;
    pMCD->CommitList    *= LocalPageSize;
    pMCD->PageFaults    = SysPerfInfo.PageFaultCount;
    pMCD->WriteCopies   = SysPerfInfo.CopyOnWriteCount;
    pMCD->TransitionFaults  = SysPerfInfo.TransitionCount;
    pMCD->CacheFaults   = FileCache.PageFaultCount;
    pMCD->DemandZeroFaults  = SysPerfInfo.DemandZeroCount;
    pMCD->Pages         = SysPerfInfo.PageReadCount +
                            SysPerfInfo.DirtyPagesWriteCount;
    pMCD->PagesInput    = SysPerfInfo.PageReadCount;
    pMCD->PageReads     = SysPerfInfo.PageReadIoCount;
    pMCD->DirtyPages    = SysPerfInfo.DirtyPagesWriteCount;
    pMCD->DirtyWrites   = SysPerfInfo.DirtyWriteIoCount;
    pMCD->PagedPool     = SysPerfInfo.PagedPoolPages;
    pMCD->PagedPool     *= LocalPageSize;
    pMCD->NonPagedPool  = SysPerfInfo.NonPagedPoolPages;
    pMCD->NonPagedPool  *= LocalPageSize;
    pMCD->PagedPoolAllocs   = SysPerfInfo.PagedPoolAllocs -
                                SysPerfInfo.PagedPoolFrees;
    pMCD->NonPagedPoolAllocs = SysPerfInfo.NonPagedPoolAllocs -
                                SysPerfInfo.NonPagedPoolFrees;
    pMCD->FreeSystemPtes    = SysPerfInfo.FreeSystemPtes;
    pMCD->CacheBytes    = FileCache.CurrentSize;
    pMCD->PeakCacheBytes    = FileCache.PeakSize;
    pMCD->ResidentPagedPoolBytes = SysPerfInfo.ResidentPagedPoolPage;
    pMCD->ResidentPagedPoolBytes *= LocalPageSize;
    pMCD->TotalSysCodeBytes     = SysPerfInfo.TotalSystemCodePages;
    pMCD->TotalSysCodeBytes     *= LocalPageSize;
    pMCD->ResidentSysCodeBytes  = SysPerfInfo.ResidentSystemCodePage;
    pMCD->ResidentSysCodeBytes  *= LocalPageSize;
    pMCD->TotalSysDriverBytes   = SysPerfInfo.TotalSystemDriverPages;
    pMCD->TotalSysDriverBytes   *= LocalPageSize;
    pMCD->ResidentSysDriverBytes = SysPerfInfo.ResidentSystemDriverPage;
    pMCD->ResidentSysDriverBytes *= LocalPageSize;
    pMCD->ResidentSysCacheBytes = SysPerfInfo.ResidentSystemCachePage;
    pMCD->ResidentSysCacheBytes *= LocalPageSize;

    //  This is reported as a percentage of CommittedPages/CommitLimit.
    //  these value return a value in "page" units. Since this is a
    //  fraction, the page size (i.e. converting pages to bytes) will
    //  cancel out and as such can be ignored, saving some CPU cycles
    //
    pMCD->CommitBytesInUse  = SysPerfInfo.CommittedPages;
    pMCD->CommitBytesLimit  = SysPerfInfo.CommitLimit;

#if 0	// no longer supported
    // load the VLM counters - this should really be removed period.
    pMCD->SystemVlmCommitCharge = 0;
    pMCD->SystemVlmPeakCommitCharge = 0;
    pMCD->SystemVlmSharedCommitCharge = 0;
#endif
    *lppData = (LPVOID)&pMCD[1];

    // round up buffer to the nearest QUAD WORD
    
    *lppData = ALIGN_ON_QWORD (*lppData);

    *lpcbTotalBytes =
        pMemoryDataDefinition->MemoryObjectType.TotalByteLength =
            (DWORD)((LPBYTE)*lppData - (LPBYTE)pMemoryDataDefinition);

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\perfcpu.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfcpu.c

Abstract:

    This file implements an Performance Object that presents
    System Processor performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/

//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfos.h"
#include "perfosmc.h"
#include "datacpu.h"

DWORD   dwCpuOpenCount = 0;        // count of "Open" threads

// variables local to this module.
static  SYSTEM_INTERRUPT_INFORMATION            *pProcessorInterruptInformation = NULL;
static  DWORD dwInterruptInfoBufferSize = 0;

static  SYSTEM_PROCESSOR_IDLE_INFORMATION       *pProcessorIdleInformation = NULL;
static  DWORD  dwProcessorIdleBufferSize = 0;

static  UCHAR *pProcessorBuffer = NULL;
static  ULONG ProcessorBufSize = 0;

BOOL    bPerfCpuUseIdleData = FALSE;
BOOL    bPerfCpuIdleDataTested = FALSE;


DWORD APIENTRY
OpenProcessorObject (
    LPWSTR lpDeviceNames
    )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    UNREFERENCED_PARAMETER (lpDeviceNames);
    
    if (!dwCpuOpenCount) {
        dwInterruptInfoBufferSize = (ULONG)BasicInfo.NumberOfProcessors *
            sizeof (SYSTEM_INTERRUPT_INFORMATION);

        pProcessorInterruptInformation = ALLOCMEM (hLibHeap,
            HEAP_ZERO_MEMORY, dwInterruptInfoBufferSize);

        if (pProcessorInterruptInformation == NULL) {
            status = ERROR_OUTOFMEMORY;
            goto OpenExitPoint;
        }

        ProcessorBufSize = BasicInfo.NumberOfProcessors *
                 sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);

        pProcessorBuffer = ALLOCMEM(hLibHeap, HEAP_ZERO_MEMORY,
                                                  ProcessorBufSize);
        if (pProcessorBuffer == NULL) {
            status = ERROR_OUTOFMEMORY;
            goto OpenExitPoint;
        }

        dwProcessorIdleBufferSize = BasicInfo.NumberOfProcessors *
                sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION);

        pProcessorIdleInformation = ALLOCMEM(hLibHeap, HEAP_ZERO_MEMORY,
                                                  dwProcessorIdleBufferSize);
        if (pProcessorIdleInformation == NULL) {
            status = ERROR_OUTOFMEMORY;
            goto OpenExitPoint;
        }

    }
    dwCpuOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:
    if (status == ERROR_OUTOFMEMORY) {
        if (pProcessorInterruptInformation) {
            FREEMEM (hLibHeap, 0, pProcessorInterruptInformation);
            pProcessorInterruptInformation = NULL;
        }
        if (pProcessorBuffer) {
            FREEMEM (hLibHeap, 0, pProcessorBuffer);
            pProcessorBuffer = NULL;
        }
        dwInterruptInfoBufferSize = 0;
        ProcessorBufSize = 0;
        dwProcessorIdleBufferSize = 0;
    }

    return status;
}

DWORD APIENTRY
CollectProcessorObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;
    DWORD   TotalLen;            //  Length of the total return block

    DWORD   dwBufferSize;
    DWORD   dwReturnedBufferSize = 0;

    PPROCESSOR_DATA_DEFINITION  pProcessorDataDefinition = NULL;
    PPROCESSOR_COUNTER_DATA     pPCD;
    PEX_PROCESSOR_DATA_DEFINITION  pExProcessorDataDefinition = NULL;
    PEX_PROCESSOR_COUNTER_DATA     pExPCD;

    PROCESSOR_COUNTER_DATA      pcdTotalData;
    EX_PROCESSOR_COUNTER_DATA   pexcdTotalData;

    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;

    ULONG CurProc;

    UNICODE_STRING ProcessorName;
    WCHAR ProcessorNameBuffer[512];

    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *pProcessorInformation = NULL;
    SYSTEM_PROCESSOR_IDLE_INFORMATION        *pProcIdleInformation = NULL;
    
    SYSTEM_INTERRUPT_INFORMATION *pThisProcessorInterruptInformation = NULL;
    DWORD   dwInterruptInfoBufferSize;
    NTSTATUS    ntStatus;

    //
    //  Check for sufficient space for processor data
    //

    // check for QUADWORD alignment of incoming pointer
    assert (((ULONG_PTR)(*lppData) & 0x00000007) == 0);

    if (!bPerfCpuIdleDataTested) {
        // call this function once to see if this info is available from the system
        //
        // get system idle information by processor
        //
        dwBufferSize = dwProcessorIdleBufferSize;

        ntStatus = NtQuerySystemInformation(
            SystemProcessorIdleInformation,
            pProcessorIdleInformation,
            dwBufferSize,
            &dwReturnedBufferSize
        );

        if (NT_SUCCESS(ntStatus)) {
            bPerfCpuUseIdleData = TRUE;
        } else {
            memset (pProcessorIdleInformation, 0, dwProcessorIdleBufferSize);
        }
        
        bPerfCpuIdleDataTested = TRUE;
    }

    if (bPerfCpuUseIdleData) {
        pExProcessorDataDefinition = (EX_PROCESSOR_DATA_DEFINITION *) *lppData;

        TotalLen =
            sizeof(EX_PROCESSOR_DATA_DEFINITION) +     // object def header
            ((sizeof (PERF_INSTANCE_DEFINITION) +   // plus an instance for
                ((MAX_INSTANCE_NAME + 1) * sizeof(WCHAR)) +
                sizeof (PROCESSOR_COUNTER_DATA)) *     // each processor and
                (BasicInfo.NumberOfProcessors + 1)); // the "total" instance
        TotalLen = QWORD_MULTIPLE(TotalLen);

        if ( *lpcbTotalBytes < TotalLen ) {
            lReturn = ERROR_MORE_DATA;
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            goto COLLECT_BAIL_OUT;
        }
    } else {
        pProcessorDataDefinition = (PROCESSOR_DATA_DEFINITION *) *lppData;

        TotalLen =
            sizeof(PROCESSOR_DATA_DEFINITION) +     // object def header
            ((sizeof (PERF_INSTANCE_DEFINITION) +   // plus an instance for
                ((MAX_INSTANCE_NAME + 1) * sizeof(WCHAR)) +
                sizeof (PROCESSOR_COUNTER_DATA)) *     // each processor and
                (BasicInfo.NumberOfProcessors + 1)); // the "total" instance

        if ( *lpcbTotalBytes < TotalLen ) {
            lReturn = ERROR_MORE_DATA;
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            goto COLLECT_BAIL_OUT;
        }
    }
    //
    // Get processor data from system
    //

    if ( ProcessorBufSize ) {
        ntStatus = NtQuerySystemInformation(
            SystemProcessorPerformanceInformation,
            pProcessorBuffer,
            ProcessorBufSize,
            &dwReturnedBufferSize
            );

        if (!NT_SUCCESS(ntStatus)) {
            // clear buffer & log error
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_PROCSSOR_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&ntStatus);

            memset (pProcessorBuffer, 0, ProcessorBufSize);
        }
    }

    //
    // get system interrupt information by processor
    //
    dwInterruptInfoBufferSize = (ULONG)BasicInfo.NumberOfProcessors *
        sizeof (SYSTEM_INTERRUPT_INFORMATION);

    ntStatus = NtQuerySystemInformation(
        SystemInterruptInformation,
        pProcessorInterruptInformation,
        dwInterruptInfoBufferSize,
        &dwReturnedBufferSize
    );

    if (!NT_SUCCESS(ntStatus)) {
        // clear buffer & log error
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_INTERRUPT_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&ntStatus);

        memset (pProcessorInterruptInformation, 0,
                    (BasicInfo.NumberOfProcessors *
                    sizeof (SYSTEM_INTERRUPT_INFORMATION)));
    }

    if (bPerfCpuUseIdleData) {
        //
        // get system idle information by processor
        //
        dwBufferSize = dwProcessorIdleBufferSize;

        ntStatus = NtQuerySystemInformation(
            SystemProcessorIdleInformation,
            pProcessorIdleInformation,
            dwBufferSize,
            &dwReturnedBufferSize
        );

        if (!NT_SUCCESS(ntStatus)) {
            // it worked once before or this flag wouldn't be set
            // so report the error.
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                PERFOS_UNABLE_QUERY_IDLE_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&ntStatus);

            memset (pProcessorIdleInformation, 0, dwProcessorIdleBufferSize);
        }
    } else {
        memset (pProcessorIdleInformation, 0, dwProcessorIdleBufferSize);
    }

    // clear the pointers to trap unassigned ones below
    pPCD = NULL;
    pExPCD = NULL;

    if ((!bPerfCpuUseIdleData) && (pProcessorDataDefinition != NULL)) {
        // use the original format of the structure
        // clear the "Total" instance
        memset (&pcdTotalData, 0, sizeof (pcdTotalData));

        //  Define processor data block
        //

        memcpy (pProcessorDataDefinition,
            &ProcessorDataDefinition,
            sizeof(PROCESSOR_DATA_DEFINITION));

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                &pProcessorDataDefinition[1];

        pProcessorInformation = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *)
                                    pProcessorBuffer;

        // point to the first processor in the returned array of interrupt
        // information. data is returned as an array of structures.

        pThisProcessorInterruptInformation = pProcessorInterruptInformation;
        pProcIdleInformation = pProcessorIdleInformation;

        for ( CurProc = 0;
            CurProc < (ULONG) BasicInfo.NumberOfProcessors;
            CurProc++ ) {

            //
            //  Define processor instance 0;
            //  More could be defined like this
            //

            ProcessorName.Length = 0;
            ProcessorName.MaximumLength = sizeof(ProcessorNameBuffer);
            ProcessorName.Buffer = ProcessorNameBuffer;

            RtlIntegerToUnicodeString(CurProc, 10, &ProcessorName);

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                    (PVOID *) &pPCD,
                                    0,
                                    0,
                                    (DWORD)-1,
                                    ProcessorNameBuffer);

            // test for Quadword Alignment
            assert (((ULONG_PTR)(pPCD) & 0x00000007) == 0);
            //
            //  Format and collect processor data.  While doing so,
            //  accumulate totals in the System Object Type data block.
            //  Pointers to these were initialized in QuerySystemData.
            //

            pPCD->CounterBlock.ByteLength = sizeof (PROCESSOR_COUNTER_DATA);

            pcdTotalData.ProcessorTime +=
                pPCD->ProcessorTime =
                    pProcessorInformation->IdleTime.QuadPart;
            pcdTotalData.UserTime +=
                pPCD->UserTime      =
                    pProcessorInformation->UserTime.QuadPart;
            // kernel time is total kernel time less the time spent in the
            // idle thread for that processor
            pcdTotalData.KernelTime +=
                pPCD->KernelTime    =
                    pProcessorInformation->KernelTime.QuadPart -
                                    pPCD->ProcessorTime;

            pcdTotalData.Interrupts +=
                pPCD->Interrupts    = pProcessorInformation->InterruptCount;
            pcdTotalData.DpcTime +=
                pPCD->DpcTime       = pProcessorInformation->DpcTime.QuadPart;
            pcdTotalData.InterruptTime +=
                pPCD->InterruptTime =
                    pProcessorInformation->InterruptTime.QuadPart;

            pcdTotalData.DpcCountRate +=
                pPCD->DpcCountRate  =
                    pThisProcessorInterruptInformation->DpcCount;

            pcdTotalData.DpcRate +=
                pPCD->DpcRate       =
                    pThisProcessorInterruptInformation->DpcRate;

            //
            //  Advance to next processor
            //

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pPCD[1];

            // point to next processor's data in return array(s)
            pProcessorInformation++;
            pThisProcessorInterruptInformation++;
            pProcIdleInformation++;
        }

        // do the total instance now
        ProcessorName.Length = (WORD)((lstrlenW (wszTotal) + 1) * sizeof (WCHAR));
        ProcessorName.MaximumLength = (WORD)(sizeof (ProcessorNameBuffer));
        lstrcpyW (ProcessorNameBuffer, wszTotal);
        ProcessorName.Buffer = ProcessorNameBuffer;

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                (PVOID *) &pPCD,
                                0,
                                0,
                                (DWORD)-1,
                                ProcessorNameBuffer);

        // define the size
        pcdTotalData.CounterBlock.ByteLength = sizeof (PROCESSOR_COUNTER_DATA);

        // adjust the total values of the time fields to the number of
        // processors to "normalize" the values

        pcdTotalData.ProcessorTime /= BasicInfo.NumberOfProcessors;
        pcdTotalData.UserTime /= BasicInfo.NumberOfProcessors;
        pcdTotalData.KernelTime /= BasicInfo.NumberOfProcessors;

        pcdTotalData.DpcTime /= BasicInfo.NumberOfProcessors;
        pcdTotalData.InterruptTime /= BasicInfo.NumberOfProcessors;

        // these fields are OK as totals
        //
        //  pcdTotalData.Interrupts
        //  pcdTotalData.DpcCountRate
        //  pcdTotalData.DpcRate

        // copy total data to buffer
        memcpy (pPCD, &pcdTotalData, sizeof (pcdTotalData));

        // adjust local buffer pointer
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pPCD[1];

        //
        //  Now we know how large an area we used for the
        //  processor definition, so we can update the offset
        //  to the next object definition
        //

        pProcessorDataDefinition->ProcessorObjectType.NumInstances =
            BasicInfo.NumberOfProcessors + 1;

        *lppData = (LPVOID)pPerfInstanceDefinition;

        // round up buffer to the nearest QUAD WORD

        *lppData = ALIGN_ON_QWORD (*lppData);

        *lpcbTotalBytes =
            pProcessorDataDefinition->ProcessorObjectType.TotalByteLength =
                (DWORD)((LPBYTE) pPerfInstanceDefinition -
                (LPBYTE) pProcessorDataDefinition);
    } 

    if ((bPerfCpuUseIdleData) && (pExProcessorDataDefinition != NULL)) {
        // use the new extended structure
        // clear the "Total" instance
        memset (&pexcdTotalData, 0, sizeof (pexcdTotalData));

        //  Define processor data block
        //

        memcpy (pExProcessorDataDefinition,
            &ExProcessorDataDefinition,
            sizeof(EX_PROCESSOR_DATA_DEFINITION));

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                &pExProcessorDataDefinition[1];

        pProcessorInformation = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *)
                                    pProcessorBuffer;

        // point to the first processor in the returned array of interrupt
        // information. data is returned as an array of structures.

        pThisProcessorInterruptInformation = pProcessorInterruptInformation;
        pProcIdleInformation = pProcessorIdleInformation;

        for ( CurProc = 0;
            CurProc < (ULONG) BasicInfo.NumberOfProcessors;
            CurProc++ ) {

            //
            //  Define processor instance 0;
            //  More could be defined like this
            //

            ProcessorName.Length = 0;
            ProcessorName.MaximumLength = sizeof(ProcessorNameBuffer);
            ProcessorName.Buffer = ProcessorNameBuffer;

            RtlIntegerToUnicodeString(CurProc, 10, &ProcessorName);

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                    (PVOID *) &pExPCD,
                                    0,
                                    0,
                                    (DWORD)-1,
                                    ProcessorNameBuffer);

            // test for Quadword Alignment
            assert (((ULONG_PTR)(pExPCD) & 0x00000007) == 0);
            //
            //  Format and collect processor data.  While doing so,
            //  accumulate totals in the System Object Type data block.
            //  Pointers to these were initialized in QuerySystemData.
            //

            pExPCD->CounterBlock.ByteLength = sizeof (EX_PROCESSOR_COUNTER_DATA);

            pexcdTotalData.ProcessorTime +=
                pExPCD->ProcessorTime =
                    pProcessorInformation->IdleTime.QuadPart;
            pexcdTotalData.UserTime +=
                pExPCD->UserTime      =
                    pProcessorInformation->UserTime.QuadPart;
            // kernel time is total kernel time less the time spent in the
            // idle thread for that processor
            pexcdTotalData.KernelTime +=
                pExPCD->KernelTime    =
                    pProcessorInformation->KernelTime.QuadPart -
                                    pExPCD->ProcessorTime;

            pexcdTotalData.Interrupts +=
                pExPCD->Interrupts    = pProcessorInformation->InterruptCount;
            pexcdTotalData.DpcTime +=
                pExPCD->DpcTime       = pProcessorInformation->DpcTime.QuadPart;
            pexcdTotalData.InterruptTime +=
                pExPCD->InterruptTime =
                    pProcessorInformation->InterruptTime.QuadPart;

            pexcdTotalData.DpcCountRate +=
                pExPCD->DpcCountRate  =
                    pThisProcessorInterruptInformation->DpcCount;

            pexcdTotalData.DpcRate +=
                pExPCD->DpcRate       =
                    pThisProcessorInterruptInformation->DpcRate;

            // fill in the system idle info

            pexcdTotalData.IdleTime +=
                pExPCD->IdleTime = 
                    pProcIdleInformation->IdleTime;
            pexcdTotalData.C1Time +=
                pExPCD->C1Time = 
                    pProcIdleInformation->C1Time;
            pexcdTotalData.C2Time +=
                pExPCD->C2Time = 
                    pProcIdleInformation->C2Time;
            pexcdTotalData.C3Time +=
                pExPCD->C3Time = 
                    pProcIdleInformation->C3Time;
            pexcdTotalData.C1Transitions +=
                pExPCD->C1Transitions = 
                    pProcIdleInformation->C1Transitions;
            pexcdTotalData.C2Transitions +=
                pExPCD->C2Transitions = 
                    pProcIdleInformation->C2Transitions;
            pexcdTotalData.C3Transitions +=
                pExPCD->C3Transitions = 
                    pProcIdleInformation->C3Transitions;

            //
            //  Advance to next processor
            //

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pExPCD[1];

            // point to next processor's data in return array(s)
            pProcessorInformation++;
            pThisProcessorInterruptInformation++;
            pProcIdleInformation++;
        }

        // do the total instance now
        ProcessorName.Length = (WORD)((lstrlenW (wszTotal) + 1) * sizeof (WCHAR));
        ProcessorName.MaximumLength = (WORD)(sizeof (ProcessorNameBuffer));
        lstrcpyW (ProcessorNameBuffer, wszTotal);
        ProcessorName.Buffer = ProcessorNameBuffer;

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                (PVOID *) &pExPCD,
                                0,
                                0,
                                (DWORD)-1,
                                ProcessorNameBuffer);

        // define the size
        pexcdTotalData.CounterBlock.ByteLength = sizeof (PROCESSOR_COUNTER_DATA);

        // adjust the total values of the time fields to the number of
        // processors to "normalize" the values

        pexcdTotalData.ProcessorTime /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.UserTime /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.KernelTime /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.IdleTime /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.C1Time /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.C2Time /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.C3Time /= BasicInfo.NumberOfProcessors;

        pexcdTotalData.DpcTime /= BasicInfo.NumberOfProcessors;
        pexcdTotalData.InterruptTime /= BasicInfo.NumberOfProcessors;

        // these fields are OK as totals
        //
        //  pexcdTotalData.Interrupts
        //  pexcdTotalData.DpcCountRate
        //  pexcdTotalData.DpcRate

        // copy total data to buffer
        memcpy (pExPCD, &pexcdTotalData, sizeof (pexcdTotalData));

        // adjust local buffer pointer
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pExPCD[1];

        //
        //  Now we know how large an area we used for the
        //  processor definition, so we can update the offset
        //  to the next object definition
        //

        pExProcessorDataDefinition->ProcessorObjectType.NumInstances =
            BasicInfo.NumberOfProcessors + 1;

        *lppData = (LPVOID)pPerfInstanceDefinition;

        // round up buffer to the nearest QUAD WORD

        *lppData = ALIGN_ON_QWORD (*lppData);

        *lpcbTotalBytes =
            pExProcessorDataDefinition->ProcessorObjectType.TotalByteLength =
                (DWORD)((LPBYTE) pPerfInstanceDefinition -
                (LPBYTE) pExProcessorDataDefinition);
    }

    if ((pExProcessorDataDefinition == NULL) && (pProcessorDataDefinition == NULL)) {
        // then no data buffer found to use
        lReturn = ERROR_SUCCESS;
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        goto COLLECT_BAIL_OUT;
    }

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFOS: Processor Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFOS:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;

COLLECT_BAIL_OUT:

    return lReturn;
}

#pragma warning (disable : 4706)
DWORD APIENTRY
CloseProcessorObject (
)
/*++

Routine Description:

    This routine closes the open handles

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (dwCpuOpenCount > 0) {
        if (!(--dwCpuOpenCount)) { // when this is the last thread...
            // close stuff here
            if (hLibHeap != NULL) {
                if (pProcessorInterruptInformation != NULL) {
                    FREEMEM (hLibHeap, 0, pProcessorInterruptInformation);
                    pProcessorInterruptInformation = NULL;
                }

                if (pProcessorBuffer != NULL) {
                    FREEMEM (hLibHeap, 0, pProcessorBuffer);
                    pProcessorBuffer = NULL;
                }
                if (pProcessorIdleInformation != NULL) {
                    FREEMEM (hLibHeap, 0, pProcessorIdleInformation);
                    pProcessorIdleInformation = NULL;
                }
                dwInterruptInfoBufferSize = 0;
                ProcessorBufSize = 0;
                dwProcessorIdleBufferSize = 0;
            }
        }
    } else {
        // if the open count is 0, then these should have been deleted
        assert (pProcessorBuffer == NULL);
        assert (pProcessorInterruptInformation == NULL);
        assert (pProcessorIdleInformation == NULL);
    }

    return ERROR_SUCCESS;

}
#pragma warning (default : 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\datasys.h ===
/*++ 

Copyright (c) 1995-6 Microsoft Corporation

Module Name:

      DATASYS.h

Abstract:

    Header file for the Windows NT Operating System Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATASYS_H_
#define _DATASYS_H_

//
//  System data object
//

typedef struct _SYSTEM_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    SystemObjectType;
    PERF_COUNTER_DEFINITION     cdReadOperations;
    PERF_COUNTER_DEFINITION     cdWriteOperations;
    PERF_COUNTER_DEFINITION     cdOtherIOOperations;
    PERF_COUNTER_DEFINITION     cdReadBytes;
    PERF_COUNTER_DEFINITION     cdWriteBytes;
    PERF_COUNTER_DEFINITION     cdOtherIOBytes;
    PERF_COUNTER_DEFINITION     cdContextSwitches;
    PERF_COUNTER_DEFINITION     cdSystemCalls;
    PERF_COUNTER_DEFINITION     cdTotalReadWrites;
    PERF_COUNTER_DEFINITION     cdSystemElapsedTime;
    PERF_COUNTER_DEFINITION     cdProcessorQueueLength;
    PERF_COUNTER_DEFINITION     cdProcessCount;
    PERF_COUNTER_DEFINITION     cdThreadCount;
    PERF_COUNTER_DEFINITION     cdAlignmentFixups;
    PERF_COUNTER_DEFINITION     cdExceptionDispatches;
    PERF_COUNTER_DEFINITION     cdFloatingPointEmulations;
    PERF_COUNTER_DEFINITION     cdRegistryQuotaUsed;
    PERF_COUNTER_DEFINITION     cdRegistryQuotaAllowed;
} SYSTEM_DATA_DEFINITION, * PSYSTEM_DATA_DEFINITION;

typedef struct _SYSTEM_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                       ReadOperations;
    DWORD                       WriteOperations; 
    DWORD                       OtherIOOperations;
    LONGLONG                    ReadBytes;
    LONGLONG                    WriteBytes;
    LONGLONG                    OtherIOBytes;
    DWORD                       ContextSwitches;
    DWORD                       SystemCalls;
    DWORD                       TotalReadWrites;
    LONGLONG                    SystemElapsedTime;
    DWORD                       ProcessorQueueLength;
    DWORD                       ProcessCount;
    DWORD                       ThreadCount;
    DWORD                       AlignmentFixups;
    DWORD                       ExceptionDispatches;
    DWORD                       FloatingPointEmulations;
    DWORD                       RegistryQuotaUsed;
    DWORD                       RegistryQuotaAllowed;
} SYSTEM_COUNTER_DATA, * PSYSTEM_COUNTER_DATA;

extern SYSTEM_DATA_DEFINITION SystemDataDefinition;

#endif // _DATASYS_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\perfobj.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfobj.c

Abstract:

    This file implements an Performance Object that presents
    System Object Performance Counters

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include <stdio.h>
#include "perfos.h"
#include "perfosmc.h"
#include "dataobj.h"

DWORD   dwObjOpenCount = 0;        // count of "Open" threads

// variables local to this module.

static  HANDLE hEvent = NULL;
static  HANDLE hMutex = NULL;
static  HANDLE hSemaphore = NULL;
static  HANDLE hSection = NULL;


DWORD APIENTRY
OpenObjectsObject (
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/

{
    DWORD   status = ERROR_SUCCESS;
	LONG_PTR	TempHandle = -1;
    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    UNREFERENCED_PARAMETER (lpDeviceNames);

    if (dwObjOpenCount == 0) {
        // open Eventlog interface

        hEvent = CreateEvent(NULL,TRUE,TRUE,NULL);
        hSemaphore = CreateSemaphore(NULL,1,256,NULL);
        hMutex = CreateMutex(NULL,FALSE,NULL);
        hSection = CreateFileMapping((HANDLE)TempHandle,NULL,PAGE_READWRITE,0,8192,NULL);
    }

    dwObjOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

    return status;
}


DWORD APIENTRY
CollectObjectsObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the system objects object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

    Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD  TotalLen;            //  Length of the total return block

    NTSTATUS    status;

    POBJECTS_DATA_DEFINITION    pObjectsDataDefinition;
    POBJECTS_COUNTER_DATA       pOCD;

    POBJECT_TYPE_INFORMATION ObjectInfo;
    WCHAR Buffer[ 256 ];

    //
    //  Check for sufficient space for objects data
    //

    pObjectsDataDefinition = (OBJECTS_DATA_DEFINITION *) *lppData;

    TotalLen = sizeof(OBJECTS_DATA_DEFINITION) +
                sizeof (OBJECTS_COUNTER_DATA);

    TotalLen = QWORD_MULTIPLE (TotalLen);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define objects data block
    //

    memcpy (pObjectsDataDefinition,
        &ObjectsDataDefinition,
        sizeof(OBJECTS_DATA_DEFINITION));

    //
    //  Format and collect objects data
    //

    pOCD = (POBJECTS_COUNTER_DATA)&pObjectsDataDefinition[1];

    pOCD->CounterBlock.ByteLength = sizeof (OBJECTS_COUNTER_DATA);

    ObjectInfo = (POBJECT_TYPE_INFORMATION)Buffer;
    status = NtQueryObject( NtCurrentProcess(),
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Processes = ObjectInfo->TotalNumberOfObjects;
    } else {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_PROCESS_OBJECT_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);

        pOCD->Processes = 0;
    }


    status = NtQueryObject( NtCurrentThread(),
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Threads = ObjectInfo->TotalNumberOfObjects;
    } else {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_THREAD_OBJECT_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);

        pOCD->Threads = 0;
    }


    status = NtQueryObject( hEvent,
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Events = ObjectInfo->TotalNumberOfObjects;
    } else {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_EVENT_OBJECT_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);

        pOCD->Events = 0;
    }


    status = NtQueryObject( hSemaphore,
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Semaphores = ObjectInfo->TotalNumberOfObjects;
    } else {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_SEMAPHORE_OBJECT_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);

        pOCD->Semaphores = 0;
    }


    status = NtQueryObject( hMutex,
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Mutexes = ObjectInfo->TotalNumberOfObjects;
    } else {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_MUTEX_OBJECT_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);

        pOCD->Mutexes = 0;
    }

    status = NtQueryObject( hSection,
                ObjectTypeInformation,
                ObjectInfo,
                sizeof( Buffer ),
                NULL
                );

    if (NT_SUCCESS(status)) {
        pOCD->Sections = ObjectInfo->TotalNumberOfObjects;
    } else {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_SECTION_OBJECT_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);

        pOCD->Sections = 0;
    }

    *lppData = (LPVOID)&pOCD[1];

    // round up buffer to the nearest QUAD WORD

    *lppData = ALIGN_ON_QWORD (*lppData);

    *lpcbTotalBytes =
        pObjectsDataDefinition->ObjectsObjectType.TotalByteLength =
            (DWORD)((LPBYTE) *lppData -
            (LPBYTE) pObjectsDataDefinition);

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}

#pragma warning (disable : 4706)
DWORD APIENTRY
CloseObjectsObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (dwObjOpenCount > 0) {
        dwObjOpenCount--;
        if (dwObjOpenCount == 0) { // when this is the last thread...
            // close stuff here
            if (hEvent != NULL) {
                CloseHandle(hEvent);
                hEvent = NULL;
            }

            if (hMutex != NULL) {
                CloseHandle(hMutex);
                hMutex = NULL;
            }

            if (hSemaphore != NULL) {
                CloseHandle(hSemaphore);
                hSemaphore = NULL;
            }
            
            if (hSection != NULL) {
                CloseHandle(hSection);
                hSection = NULL;
            }
        }
    }

    return ERROR_SUCCESS;

}
#pragma warning (default : 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\perfos.h ===
extern  HANDLE                          hEventLog;       // handle to event log
extern  HANDLE                          hLibHeap;       // dll heap
extern  SYSTEM_BASIC_INFORMATION        BasicInfo;
extern  SYSTEM_PERFORMANCE_INFORMATION  SysPerfInfo;

extern  LPWSTR  wszTotal;

extern  DWORD   dwObjOpenCount;
extern  DWORD   dwCpuOpenCount;
extern  DWORD   dwPageOpenCount;

// perfos.c
PM_QUERY_PROC   QueryOsObjectData;

//  perfcach.c
PM_LOCAL_COLLECT_PROC CollectCacheObjectData;

//  perfcpu.c
PM_OPEN_PROC    OpenProcessorObject;
PM_LOCAL_COLLECT_PROC CollectProcessorObjectData;
PM_CLOSE_PROC   CloseProcessorObject;

//  perfmem.c
PM_LOCAL_COLLECT_PROC CollectMemoryObjectData;

//  perfobj.c
PM_OPEN_PROC    OpenObjectsObject;
PM_LOCAL_COLLECT_PROC CollectObjectsObjectData;
PM_CLOSE_PROC   CloseObjectsObject;

//  perfpage.c
PM_OPEN_PROC    OpenPageFileObject;
PM_LOCAL_COLLECT_PROC CollectPageFileObjectData;
PM_CLOSE_PROC   ClosePageFileObject;

//  perfsys.c
PM_LOCAL_COLLECT_PROC CollectSystemObjectData;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\perfos.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfos.c

Abstract:


Author:

    Bob Watson (a-robw) Aug 95

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <assert.h>
#include <perfutil.h>
#include "perfos.h"
#include "perfosmc.h"

// bit field definitions for collect function flags
#define POS_GET_SYS_PERF_INFO       ((DWORD)0x00010000)

#define POS_COLLECT_CACHE_DATA      ((DWORD)0x00010001)
#define POS_COLLECT_CPU_DATA        ((DWORD)0x00000002)
#define POS_COLLECT_MEMORY_DATA     ((DWORD)0x00010004)
#define POS_COLLECT_OBJECTS_DATA    ((DWORD)0x00000008)
#define POS_COLLECT_PAGEFILE_DATA   ((DWORD)0x00000010)
#define POS_COLLECT_SYSTEM_DATA     ((DWORD)0x00010020)

#define POS_COLLECT_FUNCTION_MASK   ((DWORD)0x0000003F)

#define POS_COLLECT_GLOBAL_DATA     ((DWORD)0x0001003F)
#define POS_COLLECT_FOREIGN_DATA    ((DWORD)0)
#define POS_COLLECT_COSTLY_DATA     ((DWORD)0)

// global variables to this DLL

HANDLE  ThisDLLHandle = NULL;
HANDLE  hEventLog     = NULL;
HANDLE  hLibHeap      = NULL;

SYSTEM_BASIC_INFORMATION BasicInfo;
SYSTEM_PERFORMANCE_INFORMATION  SysPerfInfo;

PM_OPEN_PROC    OpenOSObject;
PM_COLLECT_PROC CollectOSObjectData;
PM_CLOSE_PROC   CloseOSObject;

LPWSTR  wszTotal = NULL;

// variables local to this module

static POS_FUNCTION_INFO    posDataFuncInfo[] = {
    {CACHE_OBJECT_TITLE_INDEX,      POS_COLLECT_CACHE_DATA,     0, CollectCacheObjectData},
    {PROCESSOR_OBJECT_TITLE_INDEX,  POS_COLLECT_CPU_DATA,       0, CollectProcessorObjectData},
    {MEMORY_OBJECT_TITLE_INDEX,     POS_COLLECT_MEMORY_DATA,    0, CollectMemoryObjectData},
    {OBJECT_OBJECT_TITLE_INDEX,     POS_COLLECT_OBJECTS_DATA,   0, CollectObjectsObjectData},
    {PAGEFILE_OBJECT_TITLE_INDEX,   POS_COLLECT_PAGEFILE_DATA,  0, CollectPageFileObjectData},
    {SYSTEM_OBJECT_TITLE_INDEX,     POS_COLLECT_SYSTEM_DATA,    0, CollectSystemObjectData}
};

#define POS_NUM_FUNCS   (sizeof(posDataFuncInfo) / sizeof(posDataFuncInfo[1]))

static  bInitOk  = FALSE;
static  bReportedNotOpen = FALSE;

static
BOOL
DllProcessAttach (
    IN  HANDLE DllHandle
)
/*++

Description:

    perform any initialization function that apply to all object
    modules
   
--*/
{
    BOOL    bReturn = TRUE;
    LONG    status;
    WCHAR   wszTempBuffer[512];
    LONG    lStatus;
    DWORD   dwBufferSize;

    UNREFERENCED_PARAMETER (DllHandle);

    if (hLibHeap == NULL) {
        hLibHeap = HeapCreate (0, 1, 0);
    }

    assert (hLibHeap != NULL);

    if (hLibHeap == NULL) {
        return FALSE;
    }

    // open handle to the event log
    if (hEventLog == NULL) {
        hEventLog = MonOpenEventLog((LPWSTR)L"PerfOS");
        //
        //  collect basic and static processor data
        //

        status = NtQuerySystemInformation(
                     SystemBasicInformation,
                     &BasicInfo,
                     sizeof(SYSTEM_BASIC_INFORMATION),
                     NULL
                     );

        if (!NT_SUCCESS(status)) {
            BasicInfo.PageSize = 0;
            status = (LONG)RtlNtStatusToDosError(status);
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFOS_UNABLE_QUERY_BASIC_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);

            bReturn = FALSE;
        }
    }

    lStatus = GetPerflibKeyValue (
        szTotalValue,
        REG_SZ,
        sizeof(wszTempBuffer),
        (LPVOID)&wszTempBuffer[0],
        DEFAULT_TOTAL_STRING_LEN,
        (LPVOID)&szDefaultTotalString[0]);

    if (lStatus == ERROR_SUCCESS) {
        // then a string was returned in the temp buffer
        dwBufferSize = lstrlenW (wszTempBuffer) + 1;
        dwBufferSize *= sizeof (WCHAR);
        wszTotal = ALLOCMEM (hLibHeap, HEAP_ZERO_MEMORY, dwBufferSize);
        if (wszTotal == NULL) {
            // unable to allocate buffer so use static buffer
            wszTotal = (LPWSTR)&szDefaultTotalString[0];
        } else {
            memcpy (wszTotal, wszTempBuffer, dwBufferSize);
        }
    } else {
        // unable to get string from registry so just use static buffer
        wszTotal = (LPWSTR)&szDefaultTotalString[0];
    }

    return bReturn;
}

static
BOOL
DllProcessDetach (
    IN  HANDLE DllHandle
)
{
    UNREFERENCED_PARAMETER (DllHandle);

    if ((dwCpuOpenCount + dwPageOpenCount + dwObjOpenCount) != 0) {
        // close the objects now sinc this is the last chance
        // as the DLL is in the process of being unloaded
        // if any of the open counters are > 1, then set them to 1 
        // to insure the object is closed on this call
        if (dwCpuOpenCount > 1) dwCpuOpenCount = 1;
        if (dwPageOpenCount > 1) dwPageOpenCount = 1;
        if (dwObjOpenCount > 1) dwObjOpenCount = 1;

        CloseOSObject();
    }

    assert ((dwCpuOpenCount + dwPageOpenCount + dwObjOpenCount) == 0);

    if ((wszTotal != NULL) && (wszTotal != &szDefaultTotalString[0])) {
        FREEMEM (hLibHeap, 0, wszTotal);
        wszTotal = NULL;
    }

    if (HeapDestroy (hLibHeap)) hLibHeap = NULL;

    if (hEventLog != NULL) {
        MonCloseEventLog ();
	hEventLog = NULL;	 
    }
    return TRUE;
}

BOOL
__stdcall
DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    ReservedAndUnused;

    // this will prevent the DLL from getting
    // the DLL_THREAD_* messages
    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach (DLLHandle);

        case DLL_PROCESS_DETACH:
            return DllProcessDetach (DLLHandle);

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            return TRUE;
    }
}

DWORD APIENTRY
OpenOSObject (
    LPWSTR lpDeviceNames
    )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    DWORD   status;

    // cache object does not need to be opened

    // open Processor Object
    status = OpenProcessorObject (lpDeviceNames);

    // memory object does not need to be opened

    // open Objects object
    if (status == ERROR_SUCCESS) {
        status = OpenObjectsObject (lpDeviceNames);
        // open Pagefile object
        if (status == ERROR_SUCCESS) {
            status = OpenPageFileObject (lpDeviceNames);
            if (status != ERROR_SUCCESS) {
               // processor & Objects opened & page file did not
               // close the open objects
               CloseProcessorObject ();
               CloseObjectsObject();
            }
         } else {
            // processor Opend and Objects did not
            // close the open objects
            CloseProcessorObject();
         }
    } else {
        // nothing opened
    }

    // System Object does not need to be opened

    if (status == ERROR_SUCCESS) {
        bInitOk = TRUE;
    } else {
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFOS_UNABLE_OPEN,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);
    }

    return  status;
}

DWORD APIENTRY
ReadOSObjectData (
    IN      DWORD   FunctionCallMask,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the OS object

Arguments:

   IN       DWORD FunctionCallMask
            bit mask of functions to call

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            data structure. In the case of an item list, Global or Costly
            query, this will be a collection of one or more perf data objects.
            In the case of a PERF_QUERY_OBJECTS request, this will be an array
            of DWORDs listing the object ID's of the perf data objects
            supported by this DLL.

         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the number of objects listed in the array of DWORDs referenced
            by the pObjList argument
            
         OUT: the number of objects returned by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    NTSTATUS    Status;
    DWORD       lReturn = ERROR_SUCCESS;

    DWORD       FunctionIndex;

    DWORD       dwNumObjectsFromFunction;
    DWORD       dwOrigBuffSize;
    DWORD       dwByteSize;

    DWORD       dwReturnedBufferSize;

    // collect data 
    if (FunctionCallMask & POS_GET_SYS_PERF_INFO) {
        Status = NtQuerySystemInformation(
            SystemPerformanceInformation,
            &SysPerfInfo,
            sizeof(SysPerfInfo),
            &dwReturnedBufferSize
            );

        if (!NT_SUCCESS(Status)) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFOS_UNABLE_QUERY_SYS_PERF_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&Status);
            memset (&SysPerfInfo, 0, sizeof(SysPerfInfo));
        }
    } else {
        memset (&SysPerfInfo, 0, sizeof(SysPerfInfo));
    }

    *lpNumObjectTypes = 0;
    dwOrigBuffSize = dwByteSize = *lpcbTotalBytes;
    *lpcbTotalBytes = 0;

    // remove query bits
    FunctionCallMask &= POS_COLLECT_FUNCTION_MASK;

    for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
        if (posDataFuncInfo[FunctionIndex].dwCollectFunctionBit &
            FunctionCallMask) {
            dwNumObjectsFromFunction = 0;

            // check for QUADWORD alignment of data buffer
            assert (((ULONG_PTR)(*lppData) & 0x00000007) == 0);

            lReturn = (*posDataFuncInfo[FunctionIndex].pCollectFunction) (
                lppData,
                &dwByteSize,
                &dwNumObjectsFromFunction);

            if (lReturn == ERROR_SUCCESS) {
                *lpNumObjectTypes += dwNumObjectsFromFunction;
                *lpcbTotalBytes += dwByteSize;
                dwOrigBuffSize -= dwByteSize;
                dwByteSize = dwOrigBuffSize;
            } else {
                break;
            }
        }
        // *lppData is updated by each function
        // *lpcbTotalBytes is updated after each successful function
        // *lpNumObjects is updated after each successful function
    }

    return lReturn;
}   

DWORD APIENTRY
QueryOSObjectData (
    IN      LPDWORD pObjList,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN       LPDWORD *pObjList
            pointer to an array of Performance Objects that are
            to be returned to the caller. Each object is referenced by its
            DWORD value. If the first element in the array is one of the
            following then only the first item is read and the following
            data is returned:

                PERF_QUERY_OBJECTS   an array of object id's supported
                                by this function is returned in the data

                PERF_QUERY_GLOBAL    all perf objects supported by this
                                function are returned (Except COSTLY objects)

                PERF_QUERY_COSTLY    all COSTLY perf objects supported
                                by this function are returned

                Foreign objects are not supported by this API

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            data structure. In the case of an item list, Global or Costly
            query, this will be a collection of one or more perf data objects.
            In the case of a PERF_QUERY_OBJECTS request, this will be an array
            of DWORDs listing the object ID's of the perf data objects
            supported by this DLL.

         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the number of objects listed in the array of DWORDs referenced
            by the pObjList argument
            
         OUT: the number of objects returned by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG        lReturn = ERROR_SUCCESS;
    DWORD       FunctionCallMask = 0;
    DWORD       FunctionIndex;
    LPDWORD     pdwRetBuffer;

    DWORD       ObjectIndex;
    
    if (!bInitOk) {
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFOS_NOT_OPEN,
            NULL,
            0,
            0,
            NULL,
            NULL);
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        goto QUERY_BAIL_OUT;
    }

    // evaluate the object list

    if (*lpNumObjectTypes == 1) {
        // then see if it's a predefined request value
        if (pObjList[0] == PERF_QUERY_GLOBAL) {
            FunctionCallMask = POS_COLLECT_GLOBAL_DATA;
        } else if (pObjList[0] == PERF_QUERY_COSTLY) {
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
        } else if (pObjList[0] == PERF_QUERY_OBJECTS) {
            if (*lpcbTotalBytes < (POS_NUM_FUNCS * sizeof(DWORD))) {
                lReturn = ERROR_MORE_DATA;
            } else {
                pdwRetBuffer = (LPDWORD)*lppData;
                for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                    pdwRetBuffer[FunctionIndex] =
                        posDataFuncInfo[FunctionIndex].dwObjectId;
                }
                *lppData = &pdwRetBuffer[FunctionIndex];
                *lpcbTotalBytes = (POS_NUM_FUNCS * sizeof(DWORD));
                *lpNumObjectTypes = FunctionIndex;
                lReturn = ERROR_SUCCESS;
                goto QUERY_BAIL_OUT;
            }
        }
    }

    if (FunctionCallMask == 0) {
        // it's not a predfined value so run through the list
        // read the object list and build the call mask
        ObjectIndex = 0;
        while (ObjectIndex < *lpNumObjectTypes) {
            // search for this object in the list of object id's 
            // supported by this DLL
            for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                if (pObjList[ObjectIndex] ==
                    posDataFuncInfo[FunctionIndex].dwObjectId) {
                    FunctionCallMask |=
                        posDataFuncInfo[FunctionIndex].dwCollectFunctionBit;
                    break; // out of inner loop
                }
            }
            ObjectIndex++;
        }
    }

    if (FunctionCallMask != 0) {
        lReturn = ReadOSObjectData (FunctionCallMask,
                                lppData,    
                                lpcbTotalBytes,
                                lpNumObjectTypes);
    } else {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
    }

QUERY_BAIL_OUT:
    return  lReturn;
}

DWORD APIENTRY
CollectOSObjectData (
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN       LPWSTR   lpValueName
            pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;

    // build bit mask of functions to call

    DWORD       dwQueryType;
    DWORD       FunctionCallMask = 0;
    DWORD       FunctionIndex;

    if (!bInitOk) {
        if (!bReportedNotOpen) {
            bReportedNotOpen = ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFOS_NOT_OPEN,
                NULL,
                0,
                0,
                NULL,
                NULL);
        }
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        goto COLLECT_BAIL_OUT;
    }

    dwQueryType = GetQueryType (lpValueName);

    switch (dwQueryType) {
        case QUERY_ITEMS:
            for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                if (IsNumberInUnicodeList (
                    posDataFuncInfo[FunctionIndex].dwObjectId, lpValueName)) {
                    FunctionCallMask |=
                        posDataFuncInfo[FunctionIndex].dwCollectFunctionBit;
                }
            }
            break;

        case QUERY_GLOBAL:
            FunctionCallMask = POS_COLLECT_GLOBAL_DATA;
            break;

        case QUERY_FOREIGN:
            FunctionCallMask = POS_COLLECT_FOREIGN_DATA;
            break;

        case QUERY_COSTLY:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;

        default:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;
    }

    if (FunctionCallMask != 0) {
        lReturn = ReadOSObjectData (FunctionCallMask,
                                lppData,    
                                lpcbTotalBytes,
                                lpNumObjectTypes);
    } else {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
    }

COLLECT_BAIL_OUT:
    
    return lReturn;
}

DWORD APIENTRY
CloseOSObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD   status;
    DWORD   dwReturn = ERROR_SUCCESS;

    // cache object does not need to be closeed

    // close Processor Object
    status = CloseProcessorObject ();
    assert (status == ERROR_SUCCESS);
    if (status != ERROR_SUCCESS) dwReturn = status;

    // memory object does not need to be closeed

    // close Objects object
    status = CloseObjectsObject ();
    assert (status == ERROR_SUCCESS);
    if (status != ERROR_SUCCESS) dwReturn = status;

    // close Pagefile object
    status = ClosePageFileObject ();
    assert (status == ERROR_SUCCESS);
    if (status != ERROR_SUCCESS) dwReturn = status;

    // System Object does not need to be closeed

    return  dwReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\perfpage.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfpage.c

Abstract:

    This file implements an Performance Object that presents
    system Page file performance data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <assert.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfos.h"
#include "perfosmc.h"
#include "datapage.h"

DWORD   dwPageOpenCount = 0;        // count of "Open" threads

static  PSYSTEM_PAGEFILE_INFORMATION pSysPageFileInfo = NULL;
static  DWORD  dwSysPageFileInfoSize = 0; // size of page file info array


DWORD APIENTRY
OpenPageFileObject (
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/

{
    DWORD   status = ERROR_SUCCESS;
    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    UNREFERENCED_PARAMETER (lpDeviceNames);

    if (!dwPageOpenCount) {
        // allocate the memory for the Page file info

        dwSysPageFileInfoSize = LARGE_BUFFER_SIZE;

        pSysPageFileInfo = ALLOCMEM (
            hLibHeap, HEAP_ZERO_MEMORY,
            dwSysPageFileInfoSize);

        if (pSysPageFileInfo == NULL) {
            status = ERROR_OUTOFMEMORY;
            goto OpenExitPoint;
        }
    }

    dwPageOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}


DWORD APIENTRY
CollectPageFileObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the XXX object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

    Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block

    DWORD   PageFileNumber;
    DWORD   NumPageFileInstances;
    DWORD   dwReturnedBufferSize;

    NTSTATUS    status;

    PSYSTEM_PAGEFILE_INFORMATION    pThisPageFile;
    PPAGEFILE_DATA_DEFINITION       pPageFileDataDefinition;
    PPERF_INSTANCE_DEFINITION       pPerfInstanceDefinition;
    PPAGEFILE_COUNTER_DATA          pPFCD;
    PAGEFILE_COUNTER_DATA           TotalPFCD;

    //
    //  Check for sufficient space for the Pagefile object
    //  and counter type definition records, + one instance and
    //  one set of counter data
    //

    TotalLen = sizeof(PAGEFILE_DATA_DEFINITION) +
                sizeof(PERF_INSTANCE_DEFINITION) +
                MAX_PATH * sizeof(WCHAR) +
                sizeof(PAGEFILE_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    status = (NTSTATUS) -1; // so we go throug the loop at least once

    while ((status = NtQuerySystemInformation(
                SystemPageFileInformation,  // item id
                pSysPageFileInfo,           // address of buffer to get data
                dwSysPageFileInfoSize,      // size of buffer
                &dwReturnedBufferSize)) == STATUS_INFO_LENGTH_MISMATCH) {
        dwSysPageFileInfoSize += INCREMENT_BUFFER_SIZE;
        pThisPageFile = pSysPageFileInfo;
        pSysPageFileInfo = REALLOCMEM (hLibHeap,
            0, pSysPageFileInfo,
            dwSysPageFileInfoSize);

        if (pSysPageFileInfo == NULL) {
            status = ERROR_OUTOFMEMORY;
            FREEMEM(hLibHeap, 0, pThisPageFile); // free the original buffer
            pThisPageFile = NULL;
            break;
        }
    }

    if ( !NT_SUCCESS(status) ) {
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFOS_UNABLE_QUERY_PAGEFILE_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            &status);
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        status = (NTSTATUS)RtlNtStatusToDosError(status);
        return status;
    }

    pPageFileDataDefinition = (PPAGEFILE_DATA_DEFINITION) *lppData;
    //
    //  Define Page File data block
    //

    memcpy (pPageFileDataDefinition,
        &PagefileDataDefinition,
        sizeof(PAGEFILE_DATA_DEFINITION));

    // Now load data for each PageFile

    // clear the total fields
    memset (&TotalPFCD, 0, sizeof(TotalPFCD));
    TotalPFCD.CounterBlock.ByteLength = sizeof (PAGEFILE_COUNTER_DATA);

    PageFileNumber = 0;
    NumPageFileInstances = 0;

    pThisPageFile = pSysPageFileInfo;   // initialize pointer to list of pagefiles

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                            &pPageFileDataDefinition[1];

    // the check for NULL pointer is NOT the exit criteria for this loop,
    // merely a check to bail out if the first (or any subsequent) pointer
    // is NULL. Normally the loop will exit when the NextEntryOffset == 0

    while ( pThisPageFile != NULL ) {

        // compute the size required for the next instance record

        TotalLen =
            // current bytes already used
            (DWORD)((LPBYTE)pPerfInstanceDefinition -
                (LPBYTE)pPageFileDataDefinition)
            // + this instance definition
            + sizeof(PERF_INSTANCE_DEFINITION)
            // + the file (instance) name
            + QWORD_MULTIPLE(pThisPageFile->PageFileName.Length + sizeof(WCHAR))
            // + the data block
            + sizeof (PAGEFILE_COUNTER_DATA);

        TotalLen = QWORD_MULTIPLE(TotalLen+4); // round up to the next quadword

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        // Build an Instance

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
            (PVOID *) &pPFCD,
            0,
            0,
            (DWORD)-1,
            pThisPageFile->PageFileName.Buffer);

        //
        //  Format the pagefile data
        //

        pPFCD->CounterBlock.ByteLength = sizeof (PAGEFILE_COUNTER_DATA);

        pPFCD->PercentInUse = pThisPageFile->TotalInUse;
        pPFCD->PeakUsageBase =
            pPFCD->PercentInUseBase = pThisPageFile->TotalSize;
        pPFCD->PeakUsage = pThisPageFile->PeakUsage;

        // update the total accumulators

        TotalPFCD.PeakUsageBase =
            TotalPFCD.PercentInUseBase += pThisPageFile->TotalSize;
        TotalPFCD.PeakUsage     += pThisPageFile->PeakUsage;
        TotalPFCD.PercentInUse  += pThisPageFile->TotalInUse;

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pPFCD[1];
        NumPageFileInstances++;
        PageFileNumber++;

        if (pThisPageFile->NextEntryOffset != 0) {
            pThisPageFile = (PSYSTEM_PAGEFILE_INFORMATION)\
                        ((BYTE *)pThisPageFile + pThisPageFile->NextEntryOffset);
        } else {
            break;
        }
    }


    if (NumPageFileInstances > 0) {
        // compute the size required for the next instance record

        TotalLen =
            // current bytes already used
            (DWORD)((LPBYTE)pPerfInstanceDefinition -
                (LPBYTE)pPageFileDataDefinition)
            // + this instance definition
            + sizeof(PERF_INSTANCE_DEFINITION)
            // + the file (instance) name
            + QWORD_MULTIPLE((lstrlenW (wszTotal) + 1) * sizeof (WCHAR))
            // + the data block
            + sizeof (PAGEFILE_COUNTER_DATA);

        TotalLen = QWORD_MULTIPLE(TotalLen+4); // round up to the next quadword

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        // Build the Total Instance

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
            (PVOID *)&pPFCD,
            0,
            0,
            (DWORD)-1,
            (LPWSTR)wszTotal);

        //
        //  copy the total data
        //

        memcpy (pPFCD, &TotalPFCD, sizeof (TotalPFCD));

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pPFCD[1];
        NumPageFileInstances++;
    }
    // Note number of PageFile instances

    pPageFileDataDefinition->PagefileObjectType.NumInstances =
        NumPageFileInstances;

    //
    //  update pointers for return
    //

    *lppData = (LPVOID) pPerfInstanceDefinition;

    // round up buffer to the nearest QUAD WORD

    *lppData = ALIGN_ON_QWORD (*lppData);

    *lpcbTotalBytes =
        pPageFileDataDefinition->PagefileObjectType.TotalByteLength =
            (DWORD)((PCHAR) *lppData -
            (PCHAR) pPageFileDataDefinition);

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFOS: Paging File Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFOS:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}


#pragma warning (disable : 4706)
DWORD APIENTRY
ClosePageFileObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (dwPageOpenCount > 0) {
        if (!(--dwPageOpenCount)) { // when this is the last thread...
            // close stuff here
            if (hLibHeap != NULL) {
                if (pSysPageFileInfo != NULL) {
                    FREEMEM (hLibHeap, 0, pSysPageFileInfo);
                    pSysPageFileInfo = NULL;
                }
            }
        }
    } else {
        // if open count == 0, then this should be null
        assert (pSysPageFileInfo == NULL);
    }

    return ERROR_SUCCESS;

}
#pragma warning (default: 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\datadhcp.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    DHCPdata.c

    Constant data structures for the FTP Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/
#define UNICODE 1
#include <windows.h>
#include <winperf.h>
#include "dhcpctrs.h"
#include "datadhcp.h"


//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

//
//  DO NOT CHANGE THE ORDER HERE --- THAT WILL GIVE TROBULE TO
//  THE SERVICE (global.h struct Stats definition).
//

DHCPDATA_DATA_DEFINITION DhcpDataDataDefinition =
{
    {   // DHCPDataObjectType
        sizeof(DHCPDATA_DATA_DEFINITION) + DHCPDATA_SIZE_OF_PERFORMANCE_DATA,
        sizeof(DHCPDATA_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        DHCPCTRS_COUNTER_OBJECT,
        0,
        DHCPCTRS_COUNTER_OBJECT,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_DHCPDATA_COUNTERS,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // PacketsReceived
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_PACKETS_RECEIVED,
        0,
        DHCPCTRS_PACKETS_RECEIVED,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_PACKETS_RECEIVED_OFFSET,
    },

    {   // PacketsDuplicate
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_PACKETS_DUPLICATE,
        0,
        DHCPCTRS_PACKETS_DUPLICATE,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_PACKETS_DUPLICATE_OFFSET,
    },

    {   // PacketsExpired
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_PACKETS_EXPIRED,
        0,
        DHCPCTRS_PACKETS_EXPIRED,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_PACKETS_EXPIRED_OFFSET,
    },

    {   // MilliSecondsPerPacket
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_MILLISECONDS_PER_PACKET,
        0,
        DHCPCTRS_MILLISECONDS_PER_PACKET,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL,
        sizeof(DWORD),
        DHCPDATA_MILLISECONDS_PER_PACKET_OFFSET,
    },

    {   // ActiveQueuePackets
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_PACKETS_IN_ACTIVE_QUEUE,
        0,
        DHCPCTRS_PACKETS_IN_ACTIVE_QUEUE,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL,
        sizeof(DWORD),
        DHCPDATA_PACKETS_IN_ACTIVE_QUEUE_OFFSET,
    },

    {   // PingQueuePackets
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_PACKETS_IN_PING_QUEUE,
        0,
        DHCPCTRS_PACKETS_IN_PING_QUEUE,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL,
        sizeof(DWORD),
        DHCPDATA_PACKETS_IN_PING_QUEUE_OFFSET,
    },

    {   // Discovers
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_DISCOVERS,
        0,
        DHCPCTRS_DISCOVERS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_DISCOVERS_OFFSET,
    },

    {   // Offers
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_OFFERS,
        0,
        DHCPCTRS_OFFERS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_OFFERS_OFFSET,
    },

    {   // Requests
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_REQUESTS,
        0,
        DHCPCTRS_REQUESTS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_REQUESTS_OFFSET,
    },

    {   // Informs
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_INFORMS,
        0,
        DHCPCTRS_INFORMS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_INFORMS_OFFSET,
    },

    {   // Acks
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_ACKS,
        0,
        DHCPCTRS_ACKS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_ACKS_OFFSET,
    },

    {   // Nacks
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_NACKS,
        0,
        DHCPCTRS_NACKS,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_NACKS_OFFSET
    },

    {   // Declines
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_DECLINES,
        0,
        DHCPCTRS_DECLINES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_DECLINES_OFFSET
    },

    {   // Releases
        sizeof(PERF_COUNTER_DEFINITION),
        DHCPCTRS_RELEASES,
        0,
        DHCPCTRS_RELEASES,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DHCPDATA_RELEASES_OFFSET,
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\os\perfsys.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfsys.c

Abstract:

    This file implements an Performance Object that presents
    System Performance Object information

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfos.h"
#include "perfosmc.h"
#include "datasys.h"

static  DWORD   dwOpenCount = 0;        // count of "Open" threads

typedef struct _PERFSYS_THREAD_DATA_BLOCK {
    DWORD   dwProcessCount;
    DWORD   dwNullProcessCount;
    DWORD   dwThreadCount;
    DWORD   dwReadyThreads;     // (1) this is the same as the queue length
    DWORD   dwTerminatedThreads;    // (4)
    DWORD   dwWaitingThreads;       // (5)
    DWORD   dwTransitionThreads;    // (6)
} PERFSYS_THREAD_DATA_BLOCK, * PPERFSYS_THREAD_DATA_BLOCK;


#pragma warning (disable : 4706)
DWORD
GetSystemThreadInfo (
    PPERFSYS_THREAD_DATA_BLOCK pTDB
)
{
    NTSTATUS    status;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;

    ULONG ProcessNumber;
    ULONG NumThreadInstances;
    ULONG ThreadNumber;
    ULONG ProcessBufferOffset;
    BOOLEAN NullProcess;

    UCHAR *pProcessBuffer, *pOldBuffer;
    ULONG ProcessBufSize = LARGE_BUFFER_SIZE;

    DWORD dwReturnedBufferSize;

    // reset the caller's buffer
    memset (pTDB, 0, sizeof (PERFSYS_THREAD_DATA_BLOCK));

    pProcessBuffer = ALLOCMEM (hLibHeap, 0, ProcessBufSize);

    if (pProcessBuffer == NULL) {
        status = ERROR_OUTOFMEMORY;
    } else {
        while( (status = NtQuerySystemInformation(
                            SystemProcessInformation,
                            pProcessBuffer,
                            ProcessBufSize,
                            &dwReturnedBufferSize)) ==
                                STATUS_INFO_LENGTH_MISMATCH ) {
            ProcessBufSize += INCREMENT_BUFFER_SIZE;
            pOldBuffer = pProcessBuffer;
            if ( !(pProcessBuffer = REALLOCMEM(hLibHeap, 0,
                                                pProcessBuffer,
                                                ProcessBufSize)) ) {
                FREEMEM(hLibHeap, 0, pOldBuffer);
                status = ERROR_OUTOFMEMORY;
                break;
            }
        }
    }

    if ( NT_SUCCESS(status) ) {
        // walk processes and threads to count 'ready' threads
        ProcessNumber = 0;
        NumThreadInstances = 0;

        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;
        ProcessBufferOffset = 0;

        while ( ProcessInfo != NULL ) {
            if ( ProcessInfo->ImageName.Buffer != NULL ||
                ProcessInfo->NumberOfThreads > 0 ) {
                NullProcess = FALSE;
                pTDB->dwProcessCount++;
            } else {
                NullProcess = TRUE;
                pTDB->dwNullProcessCount++;
            }

            ThreadNumber = 0;       //  Thread number of this process

            ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

            while ( !NullProcess &&
                    ThreadNumber < ProcessInfo->NumberOfThreads ) {

                //
                //  Format and collect Thread data
                //
                pTDB->dwThreadCount++;

                // update thread state counters
                if (ThreadInfo->ThreadState == 1) {
                    // then it's READY
                    pTDB->dwReadyThreads++;
                } else if (ThreadInfo->ThreadState == 4) {
                    // then it's TERMINATED
                    pTDB->dwTerminatedThreads++;
                } else if (ThreadInfo->ThreadState == 5) {
                    // then it's WAITING
                    pTDB->dwWaitingThreads++;
                } else if (ThreadInfo->ThreadState == 6) {
                    // then it's in TRANSITION
                    pTDB->dwTransitionThreads++;
                }

                ThreadNumber++;
                ThreadInfo++;
            }

            if (ProcessInfo->NextEntryOffset == 0) {
                // that was the last process
                break;
            }

            ProcessBufferOffset += ProcessInfo->NextEntryOffset;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                            &pProcessBuffer[ProcessBufferOffset];

            if ( !NullProcess ) {
                ProcessNumber++;
            }
        }

    } else {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_PROCESS_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&status);
    }

    if (pProcessBuffer != NULL) {
        FREEMEM (hLibHeap, 0, pProcessBuffer);
    }

    return ERROR_SUCCESS;

}
#pragma warning (default : 4706)

DWORD APIENTRY
CollectSystemObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the System object

Arguments:

    QuerySystemData -    Get data about system

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

         Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block

    NTSTATUS    ntStatus;

    PSYSTEM_DATA_DEFINITION     pSystemDataDefinition;
    PSYSTEM_COUNTER_DATA        pSCD;

    SYSTEM_EXCEPTION_INFORMATION    ExceptionInfo;
    SYSTEM_REGISTRY_QUOTA_INFORMATION   RegistryInfo;
    SYSTEM_TIMEOFDAY_INFORMATION    SysTimeInfo;
    PERFSYS_THREAD_DATA_BLOCK       TDB;

    DWORD   dwReturnedBufferSize;

    //  Check for sufficient space for system data
    //

    pSystemDataDefinition = (SYSTEM_DATA_DEFINITION *) *lppData;

    TotalLen = sizeof(SYSTEM_DATA_DEFINITION) +
            sizeof(SYSTEM_COUNTER_DATA);

    TotalLen = QWORD_MULTIPLE (TotalLen);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define system data block
    //

    memcpy (pSystemDataDefinition,
        &SystemDataDefinition,
        sizeof(SYSTEM_DATA_DEFINITION));

    //
    //  Format and collect system data
    //

    // get the exception data

    ntStatus = NtQuerySystemInformation(
        SystemExceptionInformation,
        &ExceptionInfo,
        sizeof(ExceptionInfo),
        NULL
    );

    if (!NT_SUCCESS(ntStatus)) {
        // unable to collect the data from the system so
        // clear the return data structure to prevent bogus data from
        // being returned
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_EXCEPTION_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&ntStatus);
        memset (&ExceptionInfo, 0, sizeof(ExceptionInfo));
    }

    // collect registry quota info

    memset (&RegistryInfo, 0, sizeof (SYSTEM_REGISTRY_QUOTA_INFORMATION));
    ntStatus = NtQuerySystemInformation (
        SystemRegistryQuotaInformation,
        (PVOID)&RegistryInfo,
        sizeof(RegistryInfo),
        NULL);

    if (ntStatus != STATUS_SUCCESS) {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_REGISTRY_QUOTA_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&ntStatus);
        // clear the data fields
        memset (&RegistryInfo, 0, sizeof (SYSTEM_REGISTRY_QUOTA_INFORMATION));
    }

    ntStatus = NtQuerySystemInformation(
        SystemTimeOfDayInformation,
        &SysTimeInfo,
        sizeof(SysTimeInfo),
        &dwReturnedBufferSize
        );

    if (!NT_SUCCESS(ntStatus)) {
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            PERFOS_UNABLE_QUERY_SYSTEM_TIME_INFO,
            NULL,
            0,
            sizeof(DWORD),
            NULL,
            (LPVOID)&ntStatus);
        memset (&SysTimeInfo, 0, sizeof(SysTimeInfo));
    }

    // get thread info
    ntStatus = GetSystemThreadInfo (&TDB);
    if (!NT_SUCCESS(ntStatus)) {
        memset (&TDB, 0, sizeof(TDB));
    }

	// update the object perf time (freq is constant)
    pSystemDataDefinition->SystemObjectType.PerfTime = SysTimeInfo.CurrentTime;

    pSCD = (PSYSTEM_COUNTER_DATA)&pSystemDataDefinition[1];

    pSCD->CounterBlock.ByteLength = sizeof(SYSTEM_COUNTER_DATA);

    pSCD->ReadOperations    = SysPerfInfo.IoReadOperationCount;
    pSCD->WriteOperations   = SysPerfInfo.IoWriteOperationCount;
    pSCD->OtherIOOperations = SysPerfInfo.IoOtherOperationCount;

    pSCD->ReadBytes         = SysPerfInfo.IoReadTransferCount.QuadPart;
    pSCD->WriteBytes        = SysPerfInfo.IoWriteTransferCount.QuadPart;
    pSCD->OtherIOBytes      = SysPerfInfo.IoOtherTransferCount.QuadPart;

    pSCD->ContextSwitches   = SysPerfInfo.ContextSwitches;
    pSCD->SystemCalls       = SysPerfInfo.SystemCalls;

    pSCD->TotalReadWrites   = SysPerfInfo.IoReadOperationCount +
                                SysPerfInfo.IoWriteOperationCount;

    pSCD->SystemElapsedTime = SysTimeInfo.BootTime.QuadPart - SysTimeInfo.BootTimeBias;

    // leave room for the ProcessorQueueLength data
    pSCD->ProcessorQueueLength  = TDB.dwReadyThreads;
    pSCD->ProcessCount          = TDB.dwProcessCount;
    pSCD->ThreadCount           = TDB.dwThreadCount;

    pSCD->AlignmentFixups       = ExceptionInfo.AlignmentFixupCount ;
    pSCD->ExceptionDispatches   = ExceptionInfo.ExceptionDispatchCount ;
    pSCD->FloatingPointEmulations = ExceptionInfo.FloatingEmulationCount ;

    pSCD->RegistryQuotaUsed     = RegistryInfo.RegistryQuotaUsed;
    pSCD->RegistryQuotaAllowed  = RegistryInfo.RegistryQuotaAllowed;

    *lppData = (LPBYTE)&pSCD[1];

    // round up buffer to the nearest QUAD WORD
    
    *lppData = ALIGN_ON_QWORD (*lppData);

    *lpcbTotalBytes =
        pSystemDataDefinition->SystemObjectType.TotalByteLength =
            (DWORD)((LPBYTE)*lppData - (LPBYTE)pSystemDataDefinition);

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\datadhcp.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    dhcpdata.h

    Extensible object definitions for the DHCP Server's counter
    objects & counters.


    FILE HISTORY:
        Pradeepb     20-July-1993 Created.
        RameshV      05-Aug-1998 Adapted for DHCP

*/


#ifndef _DHCPDATA_H_
#define _DHCPDATA_H_


//
//  This structure is used to ensure the first counter is properly
//  aligned.  Unfortunately, since PERF_COUNTER_BLOCK consists
//  of just a single DWORD, any LARGE_INTEGERs that immediately
//  follow will not be aligned properly.
//
//  This structure requires "natural" packing & alignment (probably
//  quad-word, especially on Alpha).  Ergo, keep it out of the
//  #pragma pack(4) scope below.
//

typedef struct _DHCPDATA_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK  PerfCounterBlock;
    LARGE_INTEGER       DummyEntryForAlignmentPurposesOnly;

} DHCPDATA_COUNTER_BLOCK;


//
//  The routines that load these structures assume that all fields
//  are DWORD packed & aligned.
//

#pragma pack(4)


//
//  Offsets within a PERF_COUNTER_BLOCK.
//


#define DHCPDATA_PACKETS_RECEIVED_OFFSET         (0*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_PACKETS_DUPLICATE_OFFSET        (1*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_PACKETS_EXPIRED_OFFSET          (2*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_MILLISECONDS_PER_PACKET_OFFSET  (3*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_PACKETS_IN_ACTIVE_QUEUE_OFFSET  (4*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_PACKETS_IN_PING_QUEUE_OFFSET    (5*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_DISCOVERS_OFFSET                (6*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_OFFERS_OFFSET                   (7*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_REQUESTS_OFFSET                 (8*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_INFORMS_OFFSET                  (9*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_ACKS_OFFSET                     (10*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_NACKS_OFFSET                    (11*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_DECLINES_OFFSET                 (12*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_RELEASES_OFFSET                 (13*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
#define DHCPDATA_SIZE_OF_PERFORMANCE_DATA        (14*sizeof(DWORD) + sizeof(DHCPDATA_COUNTER_BLOCK))
//
//  The counter structure returned.
//

typedef struct _DHCPDATA_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            ObjectType;
    PERF_COUNTER_DEFINITION     PacketsReceived;
    PERF_COUNTER_DEFINITION     PacketsDuplicate;
    PERF_COUNTER_DEFINITION     PacketsExpired;
    PERF_COUNTER_DEFINITION     MilliSecondsPerPacket;
    PERF_COUNTER_DEFINITION     ActiveQueuePackets;
    PERF_COUNTER_DEFINITION     PingQueuePackets;
    PERF_COUNTER_DEFINITION     Discovers;
    PERF_COUNTER_DEFINITION     Offers;
    PERF_COUNTER_DEFINITION     Requests;
    PERF_COUNTER_DEFINITION     Informs;
    PERF_COUNTER_DEFINITION     Acks;
    PERF_COUNTER_DEFINITION     Nacks;
    PERF_COUNTER_DEFINITION     Declines;
    PERF_COUNTER_DEFINITION     Releases;
} DHCPDATA_DATA_DEFINITION;


extern  DHCPDATA_DATA_DEFINITION    DhcpDataDataDefinition;


#define NUMBER_OF_DHCPDATA_COUNTERS ((sizeof(DHCPDATA_DATA_DEFINITION) -      \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))


#define DHCPDATA_PERFORMANCE_KEY	\
	TEXT("System\\CurrentControlSet\\Services\\DHCPServer\\Performance")
//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _DHCPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\datanbf.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datanbf.c

Abstract:
       
    a file containing the constant data structures
    for the Performance Monitor data for the Nbf
    Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the Nbf Extensible Objects.  This is an 
    example of how other such objects could be defined.

Created:

    Russ Blake  07/31/92

Revision History:

    None.

--*/
//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include "datanbf.h"

//
//  Constant structure initializations
//

NBF_RESOURCE_DATA_DEFINITION NbfResourceDataDefinition = {

    {   sizeof(NBF_RESOURCE_DATA_DEFINITION) + SIZE_OF_NBF_RESOURCE_DATA,
        sizeof(NBF_RESOURCE_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        494,
        0,
        495,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(NBF_RESOURCE_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        1,
        0,
        0
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        496,
        0,
        497,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        MAXIMUM_USED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        498,
        0,
        499,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        AVERAGE_USED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        500,
        0,
        501,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUMBER_OF_EXHAUSTIONS_OFFSET
    }
};




NBF_DATA_DEFINITION NbfDataDefinition = {

    {   sizeof(NBF_DATA_DEFINITION) + SIZE_OF_NBF_DATA,
        sizeof(NBF_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        492,
        0,
        493,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(NBF_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        5,     // default is Bytes Total /sec
        0,
        0
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        438,
        0,
        439,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DATAGRAMS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        440,
        0,
        441,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        DATAGRAM_BYTES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        400,
        0,
        451,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKETS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        456,
        0,
        457,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FRAMES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        458,
        0,
        459,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FRAMES_BYTES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        67,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        BYTES_TOTAL_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        412,
        0,
        413,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        OPEN_CONNECTIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        414,
        0,
        415,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        CONNECTIONS_NO_RETRY_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        416,
        0,
        417,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        CONNECTIONS_RETRY_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        418,
        0,
        419,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        LOCAL_DISCONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        420,
        0,
        421,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        REMOTE_DISCONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        422,
        0,
        423,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        LINK_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        424,
        0,
        425,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ADAPTER_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        426,
        0,
        427,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SESSION_TIMEOUTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        428,
        0,
        429,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        CANCELLED_CONNECTIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        430,
        0,
        431,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        REMOTE_RESOURCE_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        432,
        0,
        433,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        LOCAL_RESOURCE_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        434,
        0,
        435,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NOT_FOUND_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        436,
        0,
        437,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NO_LISTEN_FAILURES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        442,
        0,
        443,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DATAGRAMS_SENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        444,
        0,
        445,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        DATAGRAM_BYTES_SENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        446,
        0,
        447,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        DATAGRAMS_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        448,
        0,
        449,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        DATAGRAM_BYTES_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        452,
        0,
        453,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKETS_SENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        266,
        0,
        455,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKETS_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        460,
        0,
        461,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FRAMES_SENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        462,
        0,
        463,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FRAME_BYTES_SENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        464,
        0,
        465,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FRAMES_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        466,
        0,
        467,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FRAME_BYTES_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        468,
        0,
        469,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FRAMES_RESENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        470,
        0,
        471,
        0,
        -4,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FRAME_BYTES_RESENT_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        472,
        0,
        473,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FRAMES_REJECTED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        474,
        0,
        475,
        0,
        -4,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        FRAME_BYTES_REJECTED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        476,
        0,
        477,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        RESPONSE_TIMER_EXPIRATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        478,
        0,
        479,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ACK_TIMER_EXPIRATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        480,
        0,
        481,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        MAXIMUM_SEND_WINDOW_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        482,
        0,
        483,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        AVERAGE_SEND_WINDOW_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        484,
        0,
        485,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PIGGYBACK_ACK_QUEUED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        486,
        0,
        487,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        PIGGYBACK_ACK_TIMEOUTS_OFFSET
    }
};



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\datanbt.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datanbt.c

Abstract:

    The file containing the constant data structures
    for the Performance Monitor data for the Nbt 
    Extensible Objects.

   This file contains a set of constant data structures which are
   currently defined for the Nbt Extensible Objects.  This is an 
   example of how other such objects could be defined.

Created:

   Christos Tsollis  08/26/92 

Revision History:

--*/
//
//
//  Include files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include "datanbt.h"

//
//  Constant structure initializations
//

NBT_DATA_DEFINITION NbtDataDefinition = {

    {   sizeof(NBT_DATA_DEFINITION),
        sizeof(NBT_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        502,
        0,
        503,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(NBT_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        2,
        0,
        0
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        505,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        RECEIVED_BYTES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        506,
        0,
        507,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        SENT_BYTES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        509,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        TOTAL_BYTES_OFFSET
    }
};


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\dhcpctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    dhcpctrs.h

    Offset definitions for the DHCP Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    OpenDhcpPerformanceData procedure, they will be added to the
    DHCP Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the DHCPCTRS.DLL DLL code as well as the
    DHCPCTRS.INI definition file.  DHCPCTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.

*/


#ifndef _DHCPCTRS_H_
#define _DHCPCTRS_H_

//
//  The WINS Server counter object.
//

#define DHCPCTRS_COUNTER_OBJECT           0


//
//  The individual counters.
//

#define DHCPCTRS_PACKETS_RECEIVED         2
#define DHCPCTRS_PACKETS_DUPLICATE        4
#define DHCPCTRS_PACKETS_EXPIRED          6
#define DHCPCTRS_MILLISECONDS_PER_PACKET  8
#define DHCPCTRS_PACKETS_IN_ACTIVE_QUEUE  10
#define DHCPCTRS_PACKETS_IN_PING_QUEUE    12
#define DHCPCTRS_DISCOVERS                14
#define DHCPCTRS_OFFERS                   16
#define DHCPCTRS_REQUESTS                 18
#define DHCPCTRS_INFORMS                  20
#define DHCPCTRS_ACKS                     22
#define DHCPCTRS_NACKS                    24
#define DHCPCTRS_DECLINES                 26
#define DHCPCTRS_RELEASES                 28

#endif  // _DHCPCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\datanbt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datanbt.c

Abstract:
       
    Header file for the Nbt Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Created:

    Christos Tsollis  08/26/92 

Revision History:

--*/

#ifndef _DATANBT_H_
#define _DATANBT_H_

/****************************************************************************\
                           18 Jan 92
                           russbl

           Adding a Counter to the Extensible Objects Code



1.  Modify the object definition in extdata.h:

    a.   Add a define for the offset of the counter in the
   data block for the given object type.

    b.   Add a PERF_COUNTER_DEFINITION to the <object>_DATA_DEFINITION.

2.  Add the Titles to the Registry in perfctrs.ini and perfhelp.ini:

    a.   Add Text for the Counter Name and the Text for the Help.

    b.   Add them to the bottom so we don't have to change all the
        numbers.

    c.  Change the Last Counter and Last Help entries under
        PerfLib in software.ini.

    d.  To do this at setup time, see section in pmintrnl.txt for
        protocol.

3.  Now add the counter to the object definition in extdata.c.
    This is the initializing, constant data which will actually go
    into the structure you added to the <object>_DATA_DEFINITION in
    step 1.b.   The type of the structure you are initializing is a
    PERF_COUNTER_DEFINITION.  These are defined in winperf.h.

4.  Add code in extobjct.c to collect the data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/
 
//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may 
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define NBT_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------


//
//  Nbt Connection object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define RESERVED_DWORD_VALUE        sizeof(DWORD)
#define RECEIVED_BYTES_OFFSET       RESERVED_DWORD_VALUE + sizeof(DWORD)
#define SENT_BYTES_OFFSET           RECEIVED_BYTES_OFFSET + sizeof(LARGE_INTEGER)
#define TOTAL_BYTES_OFFSET          SENT_BYTES_OFFSET + sizeof(LARGE_INTEGER)
#define SIZE_OF_NBT_DATA            TOTAL_BYTES_OFFSET + sizeof(LARGE_INTEGER)


//
//  This is the counter structure presently returned by Nbf for
//  each Connection. Each Connection is an Instance, named by the name of
//  the remote endpoint.
//

typedef struct _NBT_DATA_DEFINITION {
    PERF_OBJECT_TYPE            NbtObjectType;
    PERF_COUNTER_DEFINITION     BytesReceived;
    PERF_COUNTER_DEFINITION     BytesSent;
    PERF_COUNTER_DEFINITION     BytesTotal;
} NBT_DATA_DEFINITION;

#pragma pack ()

#endif //_DATANBT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\datatcp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datatcp.c

Abstract:
       
    Header file for the TCP/IP (Network Interface, IP, ICMP,
    TCP, UDP) Extensible Object data definitions. 

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Created:

    Christos Tsollis   08/28/92

Revision History:

--*/
#ifndef _DATATCP_H_
#define _DATATCP_H_


/****************************************************************************\
								   18 Jan 92
								   russbl

           Adding a Counter to the Extensible Objects Code



1.  Modify the object definition in extdata.h:

    a.	Add a define for the offset of the counter in the
	data block for the given object type.

    b.	Add a PERF_COUNTER_DEFINITION to the <object>_DATA_DEFINITION.

2.  Add the Titles to the Registry in perfctrs.ini and perfhelp.ini:

    a.	Add Text for the Counter Name and the Text for the Help.

    b.	Add them to the bottom so we don't have to change all the
        numbers.

    c.  Change the Last Counter and Last Help entries under
        PerfLib in software.ini.

    d.  To do this at setup time, see section in pmintrnl.txt for
        protocol.

3.  Now add the counter to the object definition in extdata.c.
    This is the initializing, constant data which will actually go
    into the structure you added to the <object>_DATA_DEFINITION in
    step 1.b.	The type of the structure you are initializing is a
    PERF_COUNTER_DEFINITION.  These are defined in winperf.h.

4.  Add code in extobjct.c to collect the data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/
 
//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may 
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define TCPIP_NUM_PERF_OBJECT_TYPES 5


//----------------------------------------------------------------------------

//
//  The Network Interface object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define IF_OCTETS_OFFSET		sizeof(DWORD)
#define IF_PACKETS_OFFSET		IF_OCTETS_OFFSET + sizeof(LONGLONG)
#define IF_INPKTS_OFFSET		IF_PACKETS_OFFSET + sizeof(DWORD)
#define IF_OUTPKTS_OFFSET		IF_INPKTS_OFFSET + sizeof(DWORD)
#define IF_SPEED_OFFSET 		IF_OUTPKTS_OFFSET + sizeof(DWORD)
#define IF_INOCTETS_OFFSET 		IF_SPEED_OFFSET + sizeof(DWORD)
#define IF_INUCASTPKTS_OFFSET		IF_INOCTETS_OFFSET + sizeof(DWORD)
#define IF_INNUCASTPKTS_OFFSET		IF_INUCASTPKTS_OFFSET + sizeof(DWORD)
#define IF_INDISCARDS_OFFSET		IF_INNUCASTPKTS_OFFSET + sizeof(DWORD)
#define IF_INERRORS_OFFSET		IF_INDISCARDS_OFFSET + sizeof(DWORD)
#define IF_INUNKNOWNPROTOS_OFFSET 	IF_INERRORS_OFFSET + sizeof(DWORD)
#define IF_OUTOCTETS_OFFSET		IF_INUNKNOWNPROTOS_OFFSET +sizeof(DWORD)
#define IF_OUTUCASTPKTS_OFFSET		IF_OUTOCTETS_OFFSET + sizeof(DWORD)
#define IF_OUTNUCASTPKTS_OFFSET		IF_OUTUCASTPKTS_OFFSET + sizeof(DWORD)
#define IF_OUTDISCARDS_OFFSET		IF_OUTNUCASTPKTS_OFFSET + sizeof(DWORD)
#define IF_OUTERRORS_OFFSET		IF_OUTDISCARDS_OFFSET + sizeof(DWORD)
#define IF_OUTQLEN_OFFSET		IF_OUTERRORS_OFFSET + sizeof(DWORD)
#define SIZE_OF_IF_DATA   		IF_OUTQLEN_OFFSET + sizeof(DWORD)


//
//  This is the counter structure presently returned for
//  each Network Interface. 
//

typedef struct _NET_INTERFACE_DATA_DEFINITION {
    PERF_OBJECT_TYPE            NetInterfaceObjectType;
    PERF_COUNTER_DEFINITION     Octets;
    PERF_COUNTER_DEFINITION     Packets;
    PERF_COUNTER_DEFINITION     InPackets;
    PERF_COUNTER_DEFINITION     OutPackets;
    PERF_COUNTER_DEFINITION     Speed;
    PERF_COUNTER_DEFINITION     InOctets;
    PERF_COUNTER_DEFINITION     InUcastPackets;
    PERF_COUNTER_DEFINITION     InNonUcastPackets;
    PERF_COUNTER_DEFINITION     InDiscards;
    PERF_COUNTER_DEFINITION     InErrors;
    PERF_COUNTER_DEFINITION     InUnknownProtos;
    PERF_COUNTER_DEFINITION     OutOctets;
    PERF_COUNTER_DEFINITION     OutUcastPackets;
    PERF_COUNTER_DEFINITION     OutNonUcastPackets;
    PERF_COUNTER_DEFINITION     OutDiscards;
    PERF_COUNTER_DEFINITION     OutErrors;
    PERF_COUNTER_DEFINITION     OutQueueLength;
} NET_INTERFACE_DATA_DEFINITION;


//----------------------------------------------------------------------------

//
//  IP object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define IP_DATAGRAMS_OFFSET		sizeof(DWORD)
#define IP_INRECEIVES_OFFSET		IP_DATAGRAMS_OFFSET + sizeof(DWORD)
#define IP_INHDRERRORS_OFFSET		IP_INRECEIVES_OFFSET + sizeof(DWORD)
#define IP_INADDRERRORS_OFFSET		IP_INHDRERRORS_OFFSET + sizeof(DWORD)
#define IP_FORWDATAGRAMS_OFFSET		IP_INADDRERRORS_OFFSET + sizeof(DWORD)
#define IP_INUNKNOWNPROTOS_OFFSET	IP_FORWDATAGRAMS_OFFSET + sizeof(DWORD)
#define IP_INDISCARDS_OFFSET		IP_INUNKNOWNPROTOS_OFFSET +sizeof(DWORD)
#define IP_INDELIVERS_OFFSET		IP_INDISCARDS_OFFSET + sizeof(DWORD)
#define IP_OUTREQUESTS_OFFSET		IP_INDELIVERS_OFFSET + sizeof(DWORD)
#define IP_OUTDISCARDS_OFFSET		IP_OUTREQUESTS_OFFSET + sizeof(DWORD)
#define IP_OUTNOROUTES_OFFSET		IP_OUTDISCARDS_OFFSET + sizeof(DWORD)
#define IP_REASMREQDS_OFFSET		IP_OUTNOROUTES_OFFSET + sizeof(DWORD)
#define IP_REASMOKS_OFFSET		IP_REASMREQDS_OFFSET + sizeof(DWORD)
#define IP_REASMFAILS_OFFSET		IP_REASMOKS_OFFSET + sizeof(DWORD)
#define IP_FRAGOKS_OFFSET		IP_REASMFAILS_OFFSET + sizeof(DWORD)
#define IP_FRAGFAILS_OFFSET		IP_FRAGOKS_OFFSET + sizeof(DWORD)
#define IP_FRAGCREATES_OFFSET		IP_FRAGFAILS_OFFSET + sizeof(DWORD)
#define SIZE_OF_IP_DATA			IP_FRAGCREATES_OFFSET + sizeof(DWORD)


//
// This is the counter structure presently returned for IP.
//


typedef struct _IP_DATA_DEFINITION {
    PERF_OBJECT_TYPE            IPObjectType;
    PERF_COUNTER_DEFINITION     Datagrams;
    PERF_COUNTER_DEFINITION     InReceives;
    PERF_COUNTER_DEFINITION     InHeaderErrors;
    PERF_COUNTER_DEFINITION     InAddrErrors;
    PERF_COUNTER_DEFINITION     ForwardDatagrams;
    PERF_COUNTER_DEFINITION     InUnknownProtos;
    PERF_COUNTER_DEFINITION     InDiscards;
    PERF_COUNTER_DEFINITION     InDelivers;
    PERF_COUNTER_DEFINITION     OutRequests;
    PERF_COUNTER_DEFINITION     OutDiscards;
    PERF_COUNTER_DEFINITION     OutNoRoutes;
    PERF_COUNTER_DEFINITION     ReassemblyRequireds;
    PERF_COUNTER_DEFINITION     ReassemblyOKs;
    PERF_COUNTER_DEFINITION     ReassemblyFails;
    PERF_COUNTER_DEFINITION     FragmentOKs;
    PERF_COUNTER_DEFINITION     FragmentFails;
    PERF_COUNTER_DEFINITION     FragmentCreates;
} IP_DATA_DEFINITION;



//----------------------------------------------------------------------------

//
//  ICMP object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define ICMP_MESSAGES_OFFSET		sizeof(DWORD)
#define ICMP_INMSGS_OFFSET		ICMP_MESSAGES_OFFSET + sizeof(DWORD)
#define ICMP_INERRORS_OFFSET		ICMP_INMSGS_OFFSET + sizeof(DWORD)
#define ICMP_INDESTUNREACHS_OFFSET	ICMP_INERRORS_OFFSET + sizeof(DWORD)
#define ICMP_INTIMEEXCDS_OFFSET		ICMP_INDESTUNREACHS_OFFSET+sizeof(DWORD)
#define ICMP_INPARMPROBS_OFFSET		ICMP_INTIMEEXCDS_OFFSET + sizeof(DWORD)
#define ICMP_INSRCQUENCHS_OFFSET	ICMP_INPARMPROBS_OFFSET + sizeof(DWORD)
#define ICMP_INREDIRECTS_OFFSET		ICMP_INSRCQUENCHS_OFFSET + sizeof(DWORD)
#define ICMP_INECHOS_OFFSET		ICMP_INREDIRECTS_OFFSET + sizeof(DWORD)
#define ICMP_INECHOREPS_OFFSET		ICMP_INECHOS_OFFSET + sizeof(DWORD)
#define ICMP_INTIMESTAMPS_OFFSET	ICMP_INECHOREPS_OFFSET + sizeof(DWORD)
#define ICMP_INTIMESTAMPREPS_OFFSET	ICMP_INTIMESTAMPS_OFFSET + sizeof(DWORD)
#define ICMP_INADDRMASKS_OFFSET		ICMP_INTIMESTAMPREPS_OFFSET + \
					sizeof(DWORD)
#define ICMP_INADDRMASKREPS_OFFSET	ICMP_INADDRMASKS_OFFSET + sizeof(DWORD)
#define ICMP_OUTMSGS_OFFSET		ICMP_INADDRMASKREPS_OFFSET+sizeof(DWORD)
#define ICMP_OUTERRORS_OFFSET		ICMP_OUTMSGS_OFFSET + sizeof(DWORD)
#define ICMP_OUTDESTUNREACHS_OFFSET	ICMP_OUTERRORS_OFFSET + sizeof(DWORD)
#define ICMP_OUTTIMEEXCDS_OFFSET	ICMP_OUTDESTUNREACHS_OFFSET + \
					sizeof(DWORD)
#define ICMP_OUTPARMPROBS_OFFSET	ICMP_OUTTIMEEXCDS_OFFSET + sizeof(DWORD)
#define ICMP_OUTSRCQUENCHS_OFFSET	ICMP_OUTPARMPROBS_OFFSET + sizeof(DWORD)
#define ICMP_OUTREDIRECTS_OFFSET	ICMP_OUTSRCQUENCHS_OFFSET+ sizeof(DWORD)
#define ICMP_OUTECHOS_OFFSET		ICMP_OUTREDIRECTS_OFFSET + sizeof(DWORD)
#define ICMP_OUTECHOREPS_OFFSET		ICMP_OUTECHOS_OFFSET + sizeof(DWORD)
#define ICMP_OUTTIMESTAMPS_OFFSET	ICMP_OUTECHOREPS_OFFSET + sizeof(DWORD)
#define ICMP_OUTTIMESTAMPREPS_OFFSET	ICMP_OUTTIMESTAMPS_OFFSET+ sizeof(DWORD)
#define ICMP_OUTADDRMASKS_OFFSET	ICMP_OUTTIMESTAMPREPS_OFFSET + \
					sizeof(DWORD)
#define ICMP_OUTADDRMASKREPS_OFFSET	ICMP_OUTADDRMASKS_OFFSET + sizeof(DWORD)
#define SIZE_OF_ICMP_DATA		ICMP_OUTADDRMASKREPS_OFFSET + \
					sizeof(DWORD)



//
// This is the counter structure presently returned for ICMP.
//


typedef struct _ICMP_DATA_DEFINITION {
    PERF_OBJECT_TYPE            ICMPObjectType;
    PERF_COUNTER_DEFINITION     Messages;
    PERF_COUNTER_DEFINITION     InMessages;
    PERF_COUNTER_DEFINITION     InErrors;
    PERF_COUNTER_DEFINITION     InDestinationUnreachables;
    PERF_COUNTER_DEFINITION     InTimeExceededs;
    PERF_COUNTER_DEFINITION     InParameterProblems;
    PERF_COUNTER_DEFINITION     InSourceQuenchs;
    PERF_COUNTER_DEFINITION     InRedirects;
    PERF_COUNTER_DEFINITION     InEchos;
    PERF_COUNTER_DEFINITION     InEchoReplys;
    PERF_COUNTER_DEFINITION     InTimestamps;
    PERF_COUNTER_DEFINITION     InTimestampReplys;
    PERF_COUNTER_DEFINITION     InAddressMasks;
    PERF_COUNTER_DEFINITION     InAddressMaskReplys;
    PERF_COUNTER_DEFINITION     OutMessages;
    PERF_COUNTER_DEFINITION     OutErrors;
    PERF_COUNTER_DEFINITION     OutDestinationUnreachables;
    PERF_COUNTER_DEFINITION     OutTimeExceededs;
    PERF_COUNTER_DEFINITION     OutParameterProblems;
    PERF_COUNTER_DEFINITION     OutSourceQuenchs;
    PERF_COUNTER_DEFINITION     OutRedirects;
    PERF_COUNTER_DEFINITION     OutEchos;
    PERF_COUNTER_DEFINITION     OutEchoReplys;
    PERF_COUNTER_DEFINITION     OutTimestamps;
    PERF_COUNTER_DEFINITION     OutTimestampReplys;
    PERF_COUNTER_DEFINITION     OutAddressMasks;
    PERF_COUNTER_DEFINITION     OutAddressMaskReplys;
} ICMP_DATA_DEFINITION;




//----------------------------------------------------------------------------

//
//  TCP object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define TCP_SEGMENTS_OFFSET		sizeof(DWORD)
#define TCP_CURRESTAB_OFFSET		TCP_SEGMENTS_OFFSET + sizeof(DWORD)
#define TCP_ACTIVEOPENS_OFFSET		TCP_CURRESTAB_OFFSET + sizeof(DWORD)
#define TCP_PASSIVEOPENS_OFFSET		TCP_ACTIVEOPENS_OFFSET + sizeof(DWORD)
#define TCP_ATTEMPTFAILS_OFFSET		TCP_PASSIVEOPENS_OFFSET + sizeof(DWORD)
#define TCP_ESTABRESETS_OFFSET		TCP_ATTEMPTFAILS_OFFSET + sizeof(DWORD)
#define TCP_INSEGS_OFFSET		TCP_ESTABRESETS_OFFSET + sizeof(DWORD)
#define TCP_OUTSEGS_OFFSET		TCP_INSEGS_OFFSET + sizeof(DWORD)
#define TCP_RETRANSSEGS_OFFSET		TCP_OUTSEGS_OFFSET + sizeof(DWORD)
#define SIZE_OF_TCP_DATA		TCP_RETRANSSEGS_OFFSET + sizeof(DWORD)



//
// This is the counter structure presently returned for TCP.
//


typedef struct _TCP_DATA_DEFINITION {
    PERF_OBJECT_TYPE            TCPObjectType;
    PERF_COUNTER_DEFINITION     Segments;
    PERF_COUNTER_DEFINITION     CurrentlyEstablished;
    PERF_COUNTER_DEFINITION     ActiveOpens;
    PERF_COUNTER_DEFINITION     PassiveOpens;
    PERF_COUNTER_DEFINITION     AttemptFailures;
    PERF_COUNTER_DEFINITION     EstabResets;
    PERF_COUNTER_DEFINITION     InSegments;
    PERF_COUNTER_DEFINITION     OutSegments;
    PERF_COUNTER_DEFINITION     RetransmittedSegments;
} TCP_DATA_DEFINITION;


//----------------------------------------------------------------------------

//
//  UDP object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define UDP_DATAGRAMS_OFFSET		sizeof(DWORD)
#define UDP_INDATAGRAMS_OFFSET		UDP_DATAGRAMS_OFFSET + sizeof(DWORD)
#define UDP_NOPORTS_OFFSET		UDP_INDATAGRAMS_OFFSET + sizeof(DWORD)
#define UDP_INERRORS_OFFSET		UDP_NOPORTS_OFFSET + sizeof(DWORD)
#define UDP_OUTDATAGRAMS_OFFSET		UDP_INERRORS_OFFSET + sizeof(DWORD)
#define SIZE_OF_UDP_DATA		UDP_OUTDATAGRAMS_OFFSET + sizeof(DWORD)



//
// This is the counter structure presently returned for UDP.
//


typedef struct _UDP_DATA_DEFINITION {
    PERF_OBJECT_TYPE            UDPObjectType;
    PERF_COUNTER_DEFINITION     Datagrams;
    PERF_COUNTER_DEFINITION     InDatagrams;
    PERF_COUNTER_DEFINITION     NoPorts;
    PERF_COUNTER_DEFINITION     InErrors;
    PERF_COUNTER_DEFINITION     OutDatagrams;
} UDP_DATA_DEFINITION;

#pragma pack ()

#endif  //_DATATCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\datanbf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

      datanbf.h  

Abstract:

    Header file for the Nbf Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

   Russ Blake  07/30/92

Revision History:


--*/

#ifndef _DATANBF_H_
#define _DATANBF_H_

/****************************************************************************\
								   18 Jan 92
								   russbl

           Adding a Counter to the Extensible Objects Code



1.  Modify the object definition in extdata.h:

    a.	Add a define for the offset of the counter in the
	data block for the given object type.

    b.	Add a PERF_COUNTER_DEFINITION to the <object>_DATA_DEFINITION.

2.  Add the Titles to the Registry in perfctrs.ini and perfhelp.ini:

    a.	Add Text for the Counter Name and the Text for the Help.

    b.	Add them to the bottom so we don't have to change all the
        numbers.

    c.  Change the Last Counter and Last Help entries under
        PerfLib in software.ini.

    d.  To do this at setup time, see section in pmintrnl.txt for
        protocol.

3.  Now add the counter to the object definition in extdata.c.
    This is the initializing, constant data which will actually go
    into the structure you added to the <object>_DATA_DEFINITION in
    step 1.b.	The type of the structure you are initializing is a
    PERF_COUNTER_DEFINITION.  These are defined in winperf.h.

4.  Add code in extobjct.c to collect the data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/
 
//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may 
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define NBF_NUM_PERF_OBJECT_TYPES 2

//----------------------------------------------------------------------------

//
//  Nbf Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define MAXIMUM_USED_OFFSET         sizeof(DWORD)
#define AVERAGE_USED_OFFSET         MAXIMUM_USED_OFFSET + sizeof(DWORD)
#define NUMBER_OF_EXHAUSTIONS_OFFSET \
                                    AVERAGE_USED_OFFSET + sizeof(DWORD)
#define SIZE_OF_NBF_RESOURCE_DATA   NUMBER_OF_EXHAUSTIONS_OFFSET + \
                                        sizeof(DWORD)


//
//  This is the counter structure presently returned by Nbf for
//  each Resource.  Each Resource is an Instance, named by its number.
//

typedef struct _NBF_RESOURCE_DATA_DEFINITION {
    PERF_OBJECT_TYPE            NbfResourceObjectType;
    PERF_COUNTER_DEFINITION     MaximumUsed;
    PERF_COUNTER_DEFINITION     AverageUsed;
    PERF_COUNTER_DEFINITION     NumberOfExhaustions;
} NBF_RESOURCE_DATA_DEFINITION;


//----------------------------------------------------------------------------

//
//  Nbf object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define DATAGRAMS_OFFSET            sizeof(DWORD)
#define DATAGRAM_BYTES_OFFSET       DATAGRAMS_OFFSET + sizeof(DWORD)
#define PACKETS_OFFSET              DATAGRAM_BYTES_OFFSET + \
					sizeof(LARGE_INTEGER)
#define FRAMES_OFFSET               PACKETS_OFFSET + sizeof(DWORD)
#define FRAMES_BYTES_OFFSET         FRAMES_OFFSET + sizeof(DWORD)
#define BYTES_TOTAL_OFFSET          FRAMES_BYTES_OFFSET + \
                     					sizeof(LARGE_INTEGER)
#define OPEN_CONNECTIONS_OFFSET     BYTES_TOTAL_OFFSET + \
                     					sizeof(LARGE_INTEGER)
#define CONNECTIONS_NO_RETRY_OFFSET OPEN_CONNECTIONS_OFFSET + sizeof(DWORD)
#define CONNECTIONS_RETRY_OFFSET    CONNECTIONS_NO_RETRY_OFFSET + sizeof(DWORD)
#define LOCAL_DISCONNECTS_OFFSET    CONNECTIONS_RETRY_OFFSET + sizeof(DWORD)
#define REMOTE_DISCONNECTS_OFFSET   LOCAL_DISCONNECTS_OFFSET + sizeof(DWORD)
#define LINK_FAILURES_OFFSET        REMOTE_DISCONNECTS_OFFSET + sizeof(DWORD)
#define ADAPTER_FAILURES_OFFSET     LINK_FAILURES_OFFSET + sizeof(DWORD)
#define SESSION_TIMEOUTS_OFFSET     ADAPTER_FAILURES_OFFSET + sizeof(DWORD)
#define CANCELLED_CONNECTIONS_OFFSET \
                                    SESSION_TIMEOUTS_OFFSET + sizeof(DWORD)
#define REMOTE_RESOURCE_FAILURES_OFFSET \
                                    CANCELLED_CONNECTIONS_OFFSET + sizeof(DWORD)
#define LOCAL_RESOURCE_FAILURES_OFFSET \
                                    REMOTE_RESOURCE_FAILURES_OFFSET + \
                                        sizeof(DWORD)
#define NOT_FOUND_FAILURES_OFFSET   LOCAL_RESOURCE_FAILURES_OFFSET + \
                                        sizeof(DWORD)
#define NO_LISTEN_FAILURES_OFFSET   NOT_FOUND_FAILURES_OFFSET + sizeof(DWORD)
#define DATAGRAMS_SENT_OFFSET       NO_LISTEN_FAILURES_OFFSET + \
                                        sizeof(DWORD)
#define DATAGRAM_BYTES_SENT_OFFSET  DATAGRAMS_SENT_OFFSET + sizeof(DWORD)
#define DATAGRAMS_RECEIVED_OFFSET   DATAGRAM_BYTES_SENT_OFFSET + \
					sizeof(LARGE_INTEGER)
#define DATAGRAM_BYTES_RECEIVED_OFFSET \
                                    DATAGRAMS_RECEIVED_OFFSET + sizeof(DWORD)
#define PACKETS_SENT_OFFSET         DATAGRAM_BYTES_RECEIVED_OFFSET + \
                                        sizeof(LARGE_INTEGER)
#define PACKETS_RECEIVED_OFFSET     PACKETS_SENT_OFFSET + sizeof(DWORD)
#define FRAMES_SENT_OFFSET          PACKETS_RECEIVED_OFFSET + \
                                        sizeof(DWORD)
#define FRAME_BYTES_SENT_OFFSET \
                                    FRAMES_SENT_OFFSET + sizeof(DWORD)
#define FRAMES_RECEIVED_OFFSET      FRAME_BYTES_SENT_OFFSET + \
					sizeof(LARGE_INTEGER)
#define FRAME_BYTES_RECEIVED_OFFSET \
                                    FRAMES_RECEIVED_OFFSET + \
                                        sizeof(DWORD)
#define FRAMES_RESENT_OFFSET        FRAME_BYTES_RECEIVED_OFFSET + \
					sizeof(LARGE_INTEGER)
#define FRAME_BYTES_RESENT_OFFSET \
                                    FRAMES_RESENT_OFFSET + sizeof(DWORD)
#define FRAMES_REJECTED_OFFSET      FRAME_BYTES_RESENT_OFFSET + \
					sizeof(LARGE_INTEGER)
#define FRAME_BYTES_REJECTED_OFFSET \
                                    FRAMES_REJECTED_OFFSET + sizeof(DWORD)
#define RESPONSE_TIMER_EXPIRATIONS_OFFSET \
                                    FRAME_BYTES_REJECTED_OFFSET + \
					sizeof(LARGE_INTEGER)
#define ACK_TIMER_EXPIRATIONS_OFFSET \
                                    RESPONSE_TIMER_EXPIRATIONS_OFFSET + \
                                        sizeof(DWORD)
#define MAXIMUM_SEND_WINDOW_OFFSET \
                                    ACK_TIMER_EXPIRATIONS_OFFSET + \
                                        sizeof(DWORD)
#define AVERAGE_SEND_WINDOW_OFFSET \
                                    MAXIMUM_SEND_WINDOW_OFFSET + \
                                        sizeof(DWORD)
#define PIGGYBACK_ACK_QUEUED_OFFSET \
                                    AVERAGE_SEND_WINDOW_OFFSET + \
                                        sizeof(DWORD)
#define PIGGYBACK_ACK_TIMEOUTS_OFFSET \
                                    PIGGYBACK_ACK_QUEUED_OFFSET + \
                                        sizeof(DWORD)
#define RESERVED_DWORD_1 \
                                    PIGGYBACK_ACK_TIMEOUTS_OFFSET + \
                                        sizeof(DWORD)
#define SIZE_OF_NBF_DATA            RESERVED_DWORD_1 + sizeof(DWORD)


//
//  This is the counter structure presently returned by Nbf.
//  (The followig typedef doesn't match the data structure defined
//  in datanbf.c nor the data offsets defines above.  However, the
//  offsets do match the datanbf.c data struct.)
//

typedef struct _NBF_DATA_DEFINITION {
    PERF_OBJECT_TYPE            NbfObjectType;
    PERF_COUNTER_DEFINITION     OpenConnections;
    PERF_COUNTER_DEFINITION     ConnectionsAfterNoRetry;
    PERF_COUNTER_DEFINITION     ConnectionsAfterRetry;
    PERF_COUNTER_DEFINITION     LocalDisconnects;
    PERF_COUNTER_DEFINITION     RemoteDisconnects;
    PERF_COUNTER_DEFINITION     LinkFailures;
    PERF_COUNTER_DEFINITION     AdapterFailures;
    PERF_COUNTER_DEFINITION     SessionTimeouts;
    PERF_COUNTER_DEFINITION     CancelledConnections;
    PERF_COUNTER_DEFINITION     RemoteResourceFailures;
    PERF_COUNTER_DEFINITION     LocalResourceFailures;
    PERF_COUNTER_DEFINITION     NotFoundFailures;
    PERF_COUNTER_DEFINITION     NoListenFailures;
    PERF_COUNTER_DEFINITION     Datagrams;
    PERF_COUNTER_DEFINITION     DatagramBytes;
    PERF_COUNTER_DEFINITION     DatagramsSent;
    PERF_COUNTER_DEFINITION     DatagramBytesSent;
    PERF_COUNTER_DEFINITION     DatagramsReceived;
    PERF_COUNTER_DEFINITION     DatagramBytesReceived;
    PERF_COUNTER_DEFINITION     Packets;
    PERF_COUNTER_DEFINITION     PacketsSent;
    PERF_COUNTER_DEFINITION     PacketsReceived;
    PERF_COUNTER_DEFINITION     DataFrames;
    PERF_COUNTER_DEFINITION     DataFrameBytes;
    PERF_COUNTER_DEFINITION     DataFramesSent;
    PERF_COUNTER_DEFINITION     DataFrameBytesSent;
    PERF_COUNTER_DEFINITION     DataFramesReceived;
    PERF_COUNTER_DEFINITION     DataFrameBytesReceived;
    PERF_COUNTER_DEFINITION     DataFramesResent;
    PERF_COUNTER_DEFINITION     DataFrameBytesResent;
    PERF_COUNTER_DEFINITION     DataFramesRejected;
    PERF_COUNTER_DEFINITION     DataFrameBytesRejected;
    PERF_COUNTER_DEFINITION     TotalBytes;
    PERF_COUNTER_DEFINITION     ResponseTimerExpirations;
    PERF_COUNTER_DEFINITION     AckTimerExpirations;
    PERF_COUNTER_DEFINITION     MaximumSendWindow;
    PERF_COUNTER_DEFINITION     AverageSendWindow;
    PERF_COUNTER_DEFINITION     PiggybackAckQueued;
    PERF_COUNTER_DEFINITION     PiggybackAckTimeouts;
} NBF_DATA_DEFINITION;

#pragma pack ()

#endif //_DATANBF_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\datatcp.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datatcp.c

Abstract:

    The file containing the constant data structures
    for the Performance Monitor data for the TCP/IP 
    Extensible Objects (Network Interface, IP, ICMP, TCP
    and UDP).

    This file contains a set of constant data structures which are
    currently defined for the TCP/IP Extensible Objects.  This is an 
    example of how other such objects could be defined.

Created:

    Christos Tsollis  08/28/92 

Revision History:

--*/
//
//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include "datatcp.h"

//
//  Constant structure initializations
//


NET_INTERFACE_DATA_DEFINITION NetInterfaceDataDefinition = {

    {   sizeof(NET_INTERFACE_DATA_DEFINITION) + SIZE_OF_IF_DATA,
        sizeof(NET_INTERFACE_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        510,
        0,
        511,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(NET_INTERFACE_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,     // default is Byte Total/sec  
        0,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        513,
        0,
        -4,
        PERF_DETAIL_ADVANCED, 
        PERF_COUNTER_BULK_COUNT, 
        sizeof(LONGLONG),
        IF_OCTETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        400,
        0,
        515,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_PACKETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        266,
        0,
        517,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_INPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        452,
        0,
        519,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_OUTPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        520,
        0,
        521,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_SPEED_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        523,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_INOCTETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        524,
        0,
        525,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_INUCASTPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        526,
        0,
        527,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_INNUCASTPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        528,
        0,
        529,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_INDISCARDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        530,
        0,
        531,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_INERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        532,
        0,
        533,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_INUNKNOWNPROTOS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        506,
        0,
        535,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_OUTOCTETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        536,
        0,
        537,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_OUTUCASTPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        538,
        0,
        539,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IF_OUTNUCASTPKTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        540,
        0,
        541,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_OUTDISCARDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        542,
        0,
        543,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_OUTERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        544,
        0,
        545,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IF_OUTQLEN_OFFSET
    }
};




IP_DATA_DEFINITION IpDataDefinition = {

    {   sizeof(IP_DATA_DEFINITION) + SIZE_OF_IP_DATA,
        sizeof(IP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        546,
        0,
        547,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(IP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        438,
        0,
        549,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_DATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        446,
        0,
        551,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_INRECEIVES_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        552,
        0,
        553,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_INHDRERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        554,
        0,
        555,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_INADDRERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        556,
        0,
        557,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_FORWDATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        558,
        0,
        559,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_INUNKNOWNPROTOS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        560,
        0,
        561,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_INDISCARDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        562,
        0,
        563,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_INDELIVERS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        442,
        0,
        565,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_OUTREQUESTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        566,
        0,
        567,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_OUTDISCARDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        568,
        0,
        569,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_OUTNOROUTES_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        570,
        0,
        571,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_REASMREQDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        572,
        0,
        573,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_REASMOKS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        574,
        0,
        575,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_REASMFAILS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        576,
        0,
        577,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_FRAGOKS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        578,
        0,
        579,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        IP_FRAGFAILS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        580,
        0,
        581,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IP_FRAGCREATES_OFFSET
    }
};



ICMP_DATA_DEFINITION IcmpDataDefinition = {

    {   sizeof(ICMP_DATA_DEFINITION) + SIZE_OF_ICMP_DATA,
        sizeof(ICMP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        582,
        0,
        583,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(ICMP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        584,
        0,
        585,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_MESSAGES_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        586,
        0,
        587,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INMSGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        588,
        0,
        589,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        590,
        0,
        591,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INDESTUNREACHS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        592,
        0,
        593,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INTIMEEXCDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        594,
        0,
        595,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INPARMPROBS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        596,
        0,
        597,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INSRCQUENCHS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        598,
        0,
        599,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INREDIRECTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        600,
        0,
        601,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INECHOS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        602,
        0,
        603,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INECHOREPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        604,
        0,
        605,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INTIMESTAMPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        606,
        0,
        607,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_INTIMESTAMPREPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        608,
        0,
        609,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INADDRMASKS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        610,
        0,
        611,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_INADDRMASKREPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        612,
        0,
        613,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTMSGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        614,
        0,
        615,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        616,
        0,
        617,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTDESTUNREACHS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        618,
        0,
        619,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTTIMEEXCDS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        620,
        0,
        621,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTPARMPROBS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        622,
        0,
        623,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTSRCQUENCHS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        624,
        0,
        625,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTREDIRECTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        626,
        0,
        627,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTECHOS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        628,
        0,
        629,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTECHOREPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        630,
        0,
        631,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTTIMESTAMPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        632,
        0,
        633,
        0,
        -1,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        ICMP_OUTTIMESTAMPREPS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        634,
        0,
        635,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTADDRMASKS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        636,
        0,
        637,
        0,
        0,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        ICMP_OUTADDRMASKREPS_OFFSET
    }
};



TCP_DATA_DEFINITION TcpDataDefinition = {

    {   sizeof(TCP_DATA_DEFINITION) + SIZE_OF_TCP_DATA,
        sizeof(TCP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        638,
        0,
        639,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(TCP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        640,
        0,
        641,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP_SEGMENTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        642,
        0,
        643,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP_CURRESTAB_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        644,
        0,
        645,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP_ACTIVEOPENS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        646,
        0,
        647,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP_PASSIVEOPENS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        648,
        0,
        649,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP_ATTEMPTFAILS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        650,
        0,
        651,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        TCP_ESTABRESETS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        652,
        0,
        653,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP_INSEGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        654,
        0,
        655,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP_OUTSEGS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        656,
        0,
        657,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        TCP_RETRANSSEGS_OFFSET
    }
};




UDP_DATA_DEFINITION UdpDataDefinition = {

    {   sizeof(UDP_DATA_DEFINITION) + SIZE_OF_UDP_DATA,
        sizeof(UDP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        658,
        0,
        659,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(UDP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        -1,
        0
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        438,
        0,
        661,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP_DATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        446,
        0,
        663,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP_INDATAGRAMS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        664,
        0,
        665,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP_NOPORTS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        666,
        0,
        667,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        UDP_INERRORS_OFFSET
    },
    {        sizeof(PERF_COUNTER_DEFINITION),
        442,
        0,
        669,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        UDP_OUTDATAGRAMS_OFFSET
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\oidfile.c ===
char *lpOutputFileName = "";

//
// CODEWORK - use snmpapi.dll instead of importing.
//


#include "..\..\net\snmp\tools\mibcc\oidconv.c"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "perfctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\perfnbf.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfnbf.c

Abstract:

    This file implements the Extensible Objects for
    the Nbf LAN object types

    This code originally existed for NetBEUI only.  Later, it was
    adaped to handle Netrware protocol level NWNB, SPX, and IPX.
    The code was not everywhere changed to reflect this, due to the
    lateness of the change.  Therefore, sometimes you will see NBF
    where you should see TDI.

Created:

    Russ Blake  07/30/92

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <nb30.h>
#include <tdi.h>
#include <winperf.h>
#include "perfctr.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "datanbf.h"

//
//  References to constants which initialize the Object type definitions
//

extern NBF_DATA_DEFINITION NbfDataDefinition;
extern NBF_RESOURCE_DATA_DEFINITION NbfResourceDataDefinition;



//
// TDI data structures
//

#define NBF_PROTOCOL 0
#define IPX_PROTOCOL 1
#define SPX_PROTOCOL 2
#define NWNB_PROTOCOL 3
#define NUMBER_OF_PROTOCOLS_HANDLED 4

typedef struct _TDI_DATA_DEFINITION {
   int               NumberOfResources;
   HANDLE            fileHandle;
   UNICODE_STRING    DeviceName;
} TDI_DATA_DEFINITION, *PTDI_DATA_DEFINITION;

typedef struct _TDI_PROTOCOLS_DATA {
   int                     NumOfDevices;
   int                     MaxDeviceName;
   int                     MaxNumOfResources;
   PTDI_DATA_DEFINITION    pTDIData;
} TDI_PROTOCOLS_DATA;

TDI_PROTOCOLS_DATA TDITbl[NUMBER_OF_PROTOCOLS_HANDLED];

DWORD   dwTdiProtocolRefCount[NUMBER_OF_PROTOCOLS_HANDLED] = {0,0,0,0};
DWORD   dwTdiRefCount = 0;

DWORD ObjectNameTitleIndices[NUMBER_OF_PROTOCOLS_HANDLED] = { 492,
                                                              488,
                                                              490,
                                                              398 };

//
// NBF data structures
//

ULONG ProviderStatsLength;               // Resource-dependent size
PTDI_PROVIDER_STATISTICS ProviderStats = NULL;
                                         // Provider statistics

//
// NetBUEI Resource Instance Names
//
LPCWSTR NetResourceName[] =
    {
    (LPCWSTR)L"Link(11)",
    (LPCWSTR)L"Address(12)",
    (LPCWSTR)L"Address File(13)",
    (LPCWSTR)L"Connection(14)",
    (LPCWSTR)L"Request(15)",
    (LPCWSTR)L"UI Frame(21)",
    (LPCWSTR)L"Packet(22)",
    (LPCWSTR)L"Receive Packet(23)",
    (LPCWSTR)L"Receive Buffer(24)"
    };
#define NUMBER_OF_NAMES sizeof(NetResourceName)/sizeof(NetResourceName[0])
#define MAX_NBF_RESOURCE_NAME_LENGTH    20

//
//  Function Prototypes
//

PM_OPEN_PROC    OpenNbfPerformanceData;
PM_COLLECT_PROC CollectNbfPerformanceData;
PM_CLOSE_PROC   CloseNbfPerformanceData;

PM_OPEN_PROC    OpenIPXPerformanceData;
PM_COLLECT_PROC CollectIPXPerformanceData;
PM_CLOSE_PROC   CloseIPXPerformanceData;

PM_OPEN_PROC    OpenSPXPerformanceData;
PM_COLLECT_PROC CollectSPXPerformanceData;
PM_CLOSE_PROC   CloseSPXPerformanceData;

PM_OPEN_PROC    OpenNWNBPerformanceData;
PM_COLLECT_PROC CollectNWNBPerformanceData;
PM_CLOSE_PROC   CloseNWNBPerformanceData;

DWORD OpenTDIPerformanceData(LPWSTR lpDeviceNames,
                             DWORD  CurrentProtocol);
DWORD CollectTDIPerformanceData(IN LPWSTR lpValueName,
                                IN OUT LPVOID *lppData,
                                IN OUT LPDWORD lpcbTotalBytes,
                                IN OUT LPDWORD lpNumObjectTypes,
                                IN DWORD CurrentProtocol);
DWORD CloseTDIPerformanceData(DWORD CurrentProtocol);


DWORD
OpenNbfPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open each device and remember the handle
    that the device returns.

Arguments:

    Pointer to each device to be opened


Return Value:

    None.

--*/

{
    return OpenTDIPerformanceData(lpDeviceNames, NBF_PROTOCOL);
}

DWORD
OpenIPXPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open each device and remember the handle
    that the device returns.

Arguments:

    Pointer to each device to be opened


Return Value:

    None.

--*/

{
    return OpenTDIPerformanceData(lpDeviceNames, IPX_PROTOCOL);
}

DWORD
OpenSPXPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open each device and remember the handle
    that the device returns.

Arguments:

    Pointer to each device to be opened


Return Value:

    None.

--*/
{
    DWORD   dwStatus;

    dwStatus = OpenTDIPerformanceData(lpDeviceNames, SPX_PROTOCOL);
    if (dwStatus == ERROR_FILE_NOT_FOUND) {
        // no devices is not really an error, even though no counters
        // will be collected, this presents a much less alarming
        // message to the user.
        REPORT_WARNING (SPX_NO_DEVICE, LOG_USER);
        dwStatus = ERROR_SUCCESS;
    }
    return dwStatus;

}

DWORD
OpenNWNBPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open each device and remember the handle
    that the device returns.

Arguments:

    Pointer to each device to be opened


Return Value:

    None.

--*/

{
    return OpenTDIPerformanceData(lpDeviceNames, NWNB_PROTOCOL);
}

void
CleanUpTDIData (
    DWORD  CurrentProtocol
    )
/*++

Routine Description:

    This routine will celanup all the memory allocated for the
    CurrentProtocol

Arguments:

    IN      DWORD    CurrentProtocol
         this is the index of the protocol for which we are currently
         gathering statistics



Return Value:

    None.

--*/

{
    int     NumOfDevices;
    int     i;
    PTDI_DATA_DEFINITION pTDIData;

    pTDIData = TDITbl[CurrentProtocol].pTDIData;
    if (pTDIData == NULL)
        // nothing to cleanup
        return;

    NumOfDevices = TDITbl[CurrentProtocol].NumOfDevices;
    for (i=0; i < NumOfDevices; i++, pTDIData++) {
        if (pTDIData->DeviceName.Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, pTDIData->DeviceName.Buffer);
        }
        if (pTDIData->fileHandle) {
            NtClose (pTDIData->fileHandle);
        }
    }
    RtlFreeHeap(RtlProcessHeap(), 0,
        TDITbl[CurrentProtocol].pTDIData);
    TDITbl[CurrentProtocol].pTDIData = NULL;

}


#pragma warning ( disable : 4127)
DWORD
OpenTDIPerformanceData(
    LPWSTR lpDeviceNames,
    DWORD  CurrentProtocol
    )
/*++

Routine Description:

    This routine will open each device and remember the handle
    that the device returns.

Arguments:

    IN      LPWSTR   lpDeviceNames
         pointer to each device to be opened

    IN      DWORD    CurrentProtocol
         this is the index of the protocol for which we are currently
         gathering statistics



Return Value:

    None.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING FileString;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    TDI_REQUEST_USER_QUERY_INFO QueryInfo;
    HANDLE  fileHandle;
    LPWSTR   lpLocalDeviceNames;
    int      NumOfDevices;
    LPWSTR   lpSaveDeviceName;
    PTDI_DATA_DEFINITION pTemp;
    PTDI_PROVIDER_INFO ProviderInfo=NULL;
    BOOL        bInitThisProtocol = FALSE;

    MonOpenEventLog();  // this function maintains a reference count

    lpLocalDeviceNames = lpDeviceNames;

    if (dwTdiProtocolRefCount[CurrentProtocol] == 0) {
        bInitThisProtocol = TRUE;
        TDITbl[CurrentProtocol].MaxDeviceName = 0;
        NumOfDevices = TDITbl[CurrentProtocol].NumOfDevices = 0;
        TDITbl[CurrentProtocol].pTDIData = NULL;

        while (TRUE) {

            if (lpLocalDeviceNames == NULL || *lpLocalDeviceNames == L'\0') {
                break;
            }

            REPORT_INFORMATION_DATA (TDI_OPEN_ENTERED,
                LOG_VERBOSE,
                lpLocalDeviceNames,
                (lstrlenW(lpLocalDeviceNames) * sizeof(WCHAR)));

            RtlInitUnicodeString (&FileString, lpLocalDeviceNames);
            lpSaveDeviceName = RtlAllocateHeap(RtlProcessHeap(),
                        HEAP_ZERO_MEMORY,
                        sizeof (WCHAR) * (lstrlenW(lpLocalDeviceNames) + 1));

            if (!lpSaveDeviceName) {
                REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_USER);
                if (NumOfDevices == 0)
                    return ERROR_OUTOFMEMORY;
                else
                    break;
            }


            InitializeObjectAttributes(
                &ObjectAttributes,
                &FileString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            Status = NtOpenFile(
                         &fileHandle,
                         SYNCHRONIZE | FILE_READ_DATA,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(Status)) {
                RtlFreeHeap(RtlProcessHeap(), 0, lpSaveDeviceName);
                REPORT_ERROR_DATA (TDI_OPEN_FILE_ERROR, LOG_DEBUG,
                  lpLocalDeviceNames, (lstrlenW(lpLocalDeviceNames) * sizeof(WCHAR)));
                REPORT_ERROR_DATA (TDI_OPEN_FILE_ERROR, LOG_DEBUG,
                    &IoStatusBlock, sizeof(IoStatusBlock));
                if (NumOfDevices == 0) {
                    return RtlNtStatusToDosError(Status);
                } else {
                    break;
                }
            }

            if (NumOfDevices == 0) {
                // allocate memory to hold the device data
                TDITbl[CurrentProtocol].pTDIData =
                    RtlAllocateHeap(RtlProcessHeap(),
                        HEAP_ZERO_MEMORY,
                        sizeof(TDI_DATA_DEFINITION));

                if (TDITbl[CurrentProtocol].pTDIData == NULL) {
                    REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_DEBUG);
                    NtClose(fileHandle);
                    RtlFreeHeap(RtlProcessHeap(), 0, lpSaveDeviceName);
                    return ERROR_OUTOFMEMORY;
                }
            } else {
                // resize to hold multiple devices

                pTemp = RtlReAllocateHeap(RtlProcessHeap(), 0,
                        TDITbl[CurrentProtocol].pTDIData,
                        sizeof(TDI_DATA_DEFINITION) * (NumOfDevices + 1));
                if (pTemp == NULL) {
                    NtClose(fileHandle);
                    RtlFreeHeap(RtlProcessHeap(), 0, lpSaveDeviceName);
                    CleanUpTDIData(CurrentProtocol);
                    REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_USER);
                    return ERROR_OUTOFMEMORY;
                } else {
                    TDITbl[CurrentProtocol].pTDIData = pTemp;
                }
            }

            // build the TDI Data structure for this device instance
            TDITbl[CurrentProtocol].pTDIData[NumOfDevices].fileHandle
                = fileHandle;
            TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.MaximumLength =
                (WORD)(sizeof (WCHAR) * (lstrlenW(lpLocalDeviceNames) + 1));
            TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.Length =
                (WORD)(TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.Length - sizeof(WCHAR));
            TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.Buffer =
                lpSaveDeviceName;
            RtlCopyUnicodeString (
                &(TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName),
                &FileString);

            if (TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.MaximumLength
                > TDITbl[CurrentProtocol].MaxDeviceName) {
                TDITbl[CurrentProtocol].MaxDeviceName =
                    TDITbl[CurrentProtocol].pTDIData[NumOfDevices].DeviceName.MaximumLength;
            }

            // now increment NumOfDevices
            NumOfDevices++;
            TDITbl[CurrentProtocol].NumOfDevices = NumOfDevices;


            // increment to the next device string
            lpLocalDeviceNames += lstrlenW(lpLocalDeviceNames) + 1;
        }
        REPORT_INFORMATION (TDI_OPEN_FILE_SUCCESS, LOG_VERBOSE);
    }

    dwTdiProtocolRefCount[CurrentProtocol]++;

    if (TDITbl[CurrentProtocol].NumOfDevices == 0) {
        return ERROR_SUCCESS;
    }

    //
    // The following common buffer is used by all protocols.  NBF
    // is bigger because of resource data returned.
    //

    if (ProviderStats == NULL && CurrentProtocol != NBF_PROTOCOL) {
        ProviderStatsLength = sizeof(TDI_PROVIDER_STATISTICS);

        ProviderStats = RtlAllocateHeap(RtlProcessHeap(),
                                        HEAP_ZERO_MEMORY,
                                        ProviderStatsLength);

        if (ProviderStats == NULL) {
            REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_USER);
            CleanUpTDIData(CurrentProtocol);
            return ERROR_OUTOFMEMORY;
        }
    }

    if ((CurrentProtocol == NBF_PROTOCOL) && bInitThisProtocol) {

        //
        // Query provider info to get resource count.
        //

        ProviderInfo = RtlAllocateHeap(RtlProcessHeap(),
                                       HEAP_ZERO_MEMORY,
                                       sizeof(TDI_PROVIDER_INFO));
        if ( ProviderInfo == NULL ) {
            REPORT_ERROR (TDI_PROVIDER_INFO_MEMORY, LOG_USER);
            CleanUpTDIData(CurrentProtocol);
            return ERROR_OUTOFMEMORY;
        }

        QueryInfo.QueryType = TDI_QUERY_PROVIDER_INFO;

        pTemp = TDITbl[CurrentProtocol].pTDIData;
        TDITbl[CurrentProtocol].MaxNumOfResources = 0;

        for (NumOfDevices = 0;
             NumOfDevices < TDITbl[CurrentProtocol].NumOfDevices;
             NumOfDevices++, pTemp++) {

            // loop thru all the devices to see if they can be opened
            // if one of them fails, then stop the whole thing.
            // we should probably save the good ones but...
            Status = NtDeviceIoControlFile(
                         pTemp->fileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         IOCTL_TDI_QUERY_INFORMATION,
                         (PVOID)&QueryInfo,
                         sizeof(TDI_REQUEST_USER_QUERY_INFO),
                         (PVOID)ProviderInfo,
                         sizeof(TDI_PROVIDER_INFO));

            pTemp->NumberOfResources = ProviderInfo->NumberOfResources;
            if ((int)ProviderInfo->NumberOfResources >
                TDITbl[CurrentProtocol].MaxNumOfResources) {
                TDITbl[CurrentProtocol].MaxNumOfResources =
                    ProviderInfo->NumberOfResources;
            }

            if (!NT_SUCCESS(Status)) {
                RtlFreeHeap(RtlProcessHeap(), 0, ProviderInfo);
                REPORT_ERROR (TDI_UNABLE_READ_DEVICE, LOG_DEBUG);
                REPORT_ERROR_DATA (TDI_IOCTL_FILE_ERROR, LOG_DEBUG,
                       &IoStatusBlock, sizeof(IoStatusBlock));
                CleanUpTDIData(CurrentProtocol);
                return RtlNtStatusToDosError(Status);
            }
        }

        REPORT_INFORMATION (TDI_IOCTL_FILE, LOG_VERBOSE);

        ProviderStatsLength = sizeof(TDI_PROVIDER_STATISTICS) +
                                  (TDITbl[CurrentProtocol].MaxNumOfResources *
                                   sizeof(TDI_PROVIDER_RESOURCE_STATS));

        //
        // Buffer may have been allocated smaller by other protocol.
        //

        if (ProviderStats != NULL) {
            RtlFreeHeap(RtlProcessHeap(), 0, ProviderStats);
        }
        ProviderStats = RtlAllocateHeap(RtlProcessHeap(),
                                        HEAP_ZERO_MEMORY,
                                        ProviderStatsLength);

        if (ProviderStats == NULL) {
            REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_USER);
            RtlFreeHeap(RtlProcessHeap(), 0, ProviderInfo);
            CleanUpTDIData(CurrentProtocol);
            return ERROR_OUTOFMEMORY;
        }

        if (ProviderInfo) {
            RtlFreeHeap(RtlProcessHeap(), 0, ProviderInfo);
        }
    }
    
    dwTdiRefCount++;

    REPORT_INFORMATION (TDI_OPEN_PERFORMANCE_DATA, LOG_DEBUG);
    return ERROR_SUCCESS;
}
#pragma warning ( default : 4127)

DWORD
CollectNbfPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)


/*++

Routine Description:

    This routine will return the data for the Nbf counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    return CollectTDIPerformanceData(lpValueName,
                                     lppData,
                                     lpcbTotalBytes,
                                     lpNumObjectTypes,
                                     NBF_PROTOCOL);
}

DWORD
CollectIPXPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)


/*++

Routine Description:

    This routine will return the data for the IPX counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    return CollectTDIPerformanceData(lpValueName,
                                     lppData,
                                     lpcbTotalBytes,
                                     lpNumObjectTypes,
                                     IPX_PROTOCOL);
}

DWORD
CollectSPXPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)


/*++

Routine Description:

    This routine will return the data for the SPX counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    return CollectTDIPerformanceData(lpValueName,
                                     lppData,
                                     lpcbTotalBytes,
                                     lpNumObjectTypes,
                                     SPX_PROTOCOL);
}

DWORD
CollectNWNBPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)


/*++

Routine Description:

    This routine will return the data for the NWNB counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    return CollectTDIPerformanceData(lpValueName,
                                     lppData,
                                     lpcbTotalBytes,
                                     lpNumObjectTypes,
                                     NWNB_PROTOCOL);
}

DWORD
CollectTDIPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes,
    IN      DWORD   CurrentProtocol
)


/*++

Routine Description:

    This routine will return the data for the TDI counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

    IN      DWORD    CurrentProtocol
         this is the index of the protocol for which we are currently
         gathering statistics


Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

    ULONG SpaceNeeded;
    PDWORD pdwCounter = NULL;
    LARGE_INTEGER UNALIGNED *pliCounter;
    LARGE_INTEGER UNALIGNED *pliFrameBytes;
    LARGE_INTEGER UNALIGNED *pliDatagramBytes;
    PERF_COUNTER_BLOCK *pPerfCounterBlock;
    NBF_DATA_DEFINITION *pNbfDataDefinition;
    NBF_RESOURCE_DATA_DEFINITION *pNbfResourceDataDefinition;

    // Variables for collecting the data from Nbf

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
    TDI_REQUEST_USER_QUERY_INFO QueryInfo;

    //  Variables for collecting data about Nbf Resouces

    int   NumResource;
    ULONG ResourceSpace;
    UNICODE_STRING ResourceName;
    WCHAR ResourceNameBuffer[MAX_NBF_RESOURCE_NAME_LENGTH + 1];

    INT                                 NumOfDevices;
    PTDI_DATA_DEFINITION                pTDIData;
    INT                                 i;
    INT                                 TotalNumberOfResources;

    // variables used for error logging

    DWORD                               dwDataReturn[2];
    DWORD                               dwQueryType;

    if (lpValueName == NULL) {
        REPORT_INFORMATION (TDI_COLLECT_ENTERED, LOG_VERBOSE);
    } else {
        REPORT_INFORMATION_DATA (TDI_COLLECT_ENTERED,
                                 LOG_VERBOSE,
                                 lpValueName,
                                 (DWORD)(lstrlenW(lpValueName)*sizeof(WCHAR)));
    }
    //
    // before doing anything else,
    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if ((dwQueryType == QUERY_COSTLY) || (dwQueryType == QUERY_FOREIGN)) {
        // NBF foriegn data requests are not supported so bail out
        REPORT_INFORMATION (TDI_FOREIGN_DATA_REQUEST, LOG_VERBOSE);
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
        if (CurrentProtocol == NBF_PROTOCOL) {
            if ( !(IsNumberInUnicodeList (ObjectNameTitleIndices[CurrentProtocol],
                                      lpValueName)) &&
                 !(IsNumberInUnicodeList (NBF_RESOURCE_OBJECT_TITLE_INDEX,
                                      lpValueName))) {

                // request received for objects not provided by NBF

                REPORT_INFORMATION (TDI_UNSUPPORTED_ITEM_REQUEST, LOG_VERBOSE);

                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_SUCCESS;
            }
        } // NBF_PROTOCOL
        else if ( !(IsNumberInUnicodeList (ObjectNameTitleIndices[CurrentProtocol],
                                      lpValueName))) {
            // request received for objects not provided by this protocol
            REPORT_INFORMATION (TDI_UNSUPPORTED_ITEM_REQUEST, LOG_VERBOSE);
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        } // other protocol
    }   // dwQueryType == QUERY_ITEMS

    // if no NBF devices were opened, in the OPEN routine, then
    // leave now.

    if (TDITbl[CurrentProtocol].pTDIData == NULL) {
        REPORT_WARNING (TDI_NULL_HANDLE, LOG_DEBUG);
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    pNbfDataDefinition = (NBF_DATA_DEFINITION *) *lppData;

    pTDIData = TDITbl[CurrentProtocol].pTDIData;
    NumOfDevices = TDITbl[CurrentProtocol].NumOfDevices;

    // Compute space needed to hold Nbf Resource Data

    if (CurrentProtocol != NBF_PROTOCOL) {
        ResourceSpace = 0;
    } else {
        ResourceSpace = sizeof(NBF_RESOURCE_DATA_DEFINITION) +
                        (TDITbl[CurrentProtocol].MaxNumOfResources *
                            (sizeof(PERF_INSTANCE_DEFINITION) +
                        QWORD_MULTIPLE(
                            (MAX_NBF_RESOURCE_NAME_LENGTH * sizeof(WCHAR)) +
                             sizeof(UNICODE_NULL)) +
                        SIZE_OF_NBF_RESOURCE_DATA));
        ResourceSpace *= NumOfDevices;
    }

    SpaceNeeded = sizeof(NBF_DATA_DEFINITION) +
                  SIZE_OF_NBF_DATA +
                  ResourceSpace;

    // now add in the per instance NBF data
    SpaceNeeded += NumOfDevices *
        (SIZE_OF_NBF_DATA +
         sizeof(PERF_INSTANCE_DEFINITION) +
         QWORD_MULTIPLE(
             (TDITbl[CurrentProtocol].MaxDeviceName * sizeof(WCHAR))
             + sizeof(UNICODE_NULL)));

    if ( *lpcbTotalBytes < SpaceNeeded ) {
        dwDataReturn[0] = *lpcbTotalBytes;
        dwDataReturn[1] = SpaceNeeded;
        REPORT_WARNING_DATA (TDI_DATA_BUFFER_SIZE_ERROR,
                             LOG_DEBUG,
                             &dwDataReturn,
                             sizeof(dwDataReturn));
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    REPORT_INFORMATION (TDI_DATA_BUFFER_SIZE_SUCCESS, LOG_VERBOSE);

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //

    RtlMoveMemory(pNbfDataDefinition,
           &NbfDataDefinition,
           sizeof(NBF_DATA_DEFINITION));

    pNbfDataDefinition->NbfObjectType.ObjectNameTitleIndex =
        ObjectNameTitleIndices[CurrentProtocol];

    pNbfDataDefinition->NbfObjectType.ObjectHelpTitleIndex =
        ObjectNameTitleIndices[CurrentProtocol] + 1;

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
        &pNbfDataDefinition[1];

    if (NumOfDevices > 0) {
        for (i=0; i < NumOfDevices; i++, pTDIData++) {
            //
            //  Format and collect Nbf data
            //

            QueryInfo.QueryType = TDI_QUERY_PROVIDER_STATISTICS;

            Status = NtDeviceIoControlFile(
                         pTDIData->fileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         IOCTL_TDI_QUERY_INFORMATION,
                         (PVOID)&QueryInfo,
                         sizeof(TDI_REQUEST_USER_QUERY_INFO),
                         (PVOID)ProviderStats,
                         ProviderStatsLength);

            if (Status != STATUS_SUCCESS) {
                REPORT_ERROR (TDI_UNABLE_READ_DEVICE, LOG_DEBUG);
                REPORT_ERROR_DATA (TDI_QUERY_INFO_ERROR,
                                   LOG_DEBUG,
                                   &IoStatusBlock,
                                   sizeof (IoStatusBlock));
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_SUCCESS;
            }

            REPORT_INFORMATION (TDI_QUERY_INFO_SUCCESS, LOG_DEBUG);


            MonBuildInstanceDefinition(
                pPerfInstanceDefinition,
                (PVOID *)&pPerfCounterBlock,
                0,
                0,
                (DWORD)PERF_NO_UNIQUE_ID,
                &(pTDIData->DeviceName));


            pPerfCounterBlock->ByteLength = SIZE_OF_NBF_DATA;

            pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

            *pdwCounter = ProviderStats->DatagramsSent +
                          ProviderStats->DatagramsReceived;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            pliDatagramBytes = pliCounter;
            pliCounter->QuadPart = ProviderStats->DatagramBytesSent.QuadPart +
                                   ProviderStats->DatagramBytesReceived.QuadPart;
            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->PacketsSent + ProviderStats->PacketsReceived;
            *++pdwCounter = ProviderStats->DataFramesSent +
                            ProviderStats->DataFramesReceived;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            pliFrameBytes = pliCounter;
            pliCounter->QuadPart = ProviderStats->DataFrameBytesSent.QuadPart +
                                   ProviderStats->DataFrameBytesReceived.QuadPart;

            //  Get the Bytes Total/sec which is the sum of Frame Byte /sec
            //  and Datagram byte/sec
            ++pliCounter;
            pliCounter->QuadPart = pliDatagramBytes->QuadPart +
                                   pliFrameBytes->QuadPart;
            //
            //  Get the TDI raw data.
            //
            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->OpenConnections;
            *++pdwCounter = ProviderStats->ConnectionsAfterNoRetry;
            *++pdwCounter = ProviderStats->ConnectionsAfterRetry;
            *++pdwCounter = ProviderStats->LocalDisconnects;
            *++pdwCounter = ProviderStats->RemoteDisconnects;
            *++pdwCounter = ProviderStats->LinkFailures;
            *++pdwCounter = ProviderStats->AdapterFailures;
            *++pdwCounter = ProviderStats->SessionTimeouts;
            *++pdwCounter = ProviderStats->CancelledConnections;
            *++pdwCounter = ProviderStats->RemoteResourceFailures;
            *++pdwCounter = ProviderStats->LocalResourceFailures;
            *++pdwCounter = ProviderStats->NotFoundFailures;
            *++pdwCounter = ProviderStats->NoListenFailures;
            *++pdwCounter = ProviderStats->DatagramsSent;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DatagramBytesSent;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->DatagramsReceived;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DatagramBytesReceived;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->PacketsSent;
            *++pdwCounter = ProviderStats->PacketsReceived;
            *++pdwCounter = ProviderStats->DataFramesSent;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DataFrameBytesSent;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->DataFramesReceived;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DataFrameBytesReceived;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->DataFramesResent;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DataFrameBytesResent;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->DataFramesRejected;

            pliCounter = (LARGE_INTEGER UNALIGNED *) ++pdwCounter;
            *pliCounter = ProviderStats->DataFrameBytesRejected;

            pdwCounter = (PDWORD) ++pliCounter;
            *pdwCounter = ProviderStats->ResponseTimerExpirations;
            *++pdwCounter = ProviderStats->AckTimerExpirations;
            *++pdwCounter = ProviderStats->MaximumSendWindow;
            *++pdwCounter = ProviderStats->AverageSendWindow;
            *++pdwCounter = ProviderStats->PiggybackAckQueued;
            *++pdwCounter = ProviderStats->PiggybackAckTimeouts;
            *++pdwCounter = 0; //reserved

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                      ((PBYTE) pPerfCounterBlock +
                                       SIZE_OF_NBF_DATA);
        }

        pNbfResourceDataDefinition = (NBF_RESOURCE_DATA_DEFINITION *)
                                     ++pdwCounter;
    } else {
        pNbfResourceDataDefinition = (NBF_RESOURCE_DATA_DEFINITION *)
            pPerfInstanceDefinition;
    }

    TotalNumberOfResources = 0;

    pNbfDataDefinition->NbfObjectType.NumInstances = NumOfDevices;
    pNbfDataDefinition->NbfObjectType.TotalByteLength =
        (DWORD)((PBYTE) pdwCounter - (PBYTE) pNbfDataDefinition);

    if (CurrentProtocol == NBF_PROTOCOL) {

        RtlMoveMemory(pNbfResourceDataDefinition,
                      &NbfResourceDataDefinition,
                      sizeof(NBF_RESOURCE_DATA_DEFINITION));

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pNbfResourceDataDefinition[1];

        pTDIData = TDITbl[CurrentProtocol].pTDIData;

        for (i = 0; i < NumOfDevices; i++, pTDIData++) {
            // for most cases, we will have only one deivce,
            // then we could just use the ProviderStats read
            // for NBF data.
            if (NumOfDevices > 1) {
                // need to read ProviderStat again for multiple devices
                QueryInfo.QueryType = TDI_QUERY_PROVIDER_STATISTICS;

                Status = NtDeviceIoControlFile(
                             pTDIData->fileHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             IOCTL_TDI_QUERY_INFORMATION,
                             (PVOID)&QueryInfo,
                             sizeof(TDI_REQUEST_USER_QUERY_INFO),
                             (PVOID)ProviderStats,
                             ProviderStatsLength);

                if (Status != STATUS_SUCCESS) {
                    REPORT_ERROR (TDI_UNABLE_READ_DEVICE, LOG_DEBUG);
                    REPORT_ERROR_DATA (TDI_QUERY_INFO_ERROR,
                                       LOG_DEBUG,
                                       &IoStatusBlock,
                                       sizeof (IoStatusBlock));
                    *lpcbTotalBytes = (DWORD) 0;
                    *lpNumObjectTypes = (DWORD) 0;
                    return ERROR_SUCCESS;
                }
            }

            TotalNumberOfResources += pTDIData->NumberOfResources;

            for ( NumResource = 0;
                  NumResource < pTDIData->NumberOfResources;
                  NumResource++ ) {

                //
                //  Format and collect Nbf Resource data
                //

                if (NumResource < NUMBER_OF_NAMES) {
                    RtlInitUnicodeString(&ResourceName,
                                         NetResourceName[NumResource]);
                } else {
                    ResourceName.Length = 0;
                    ResourceName.MaximumLength = MAX_NBF_RESOURCE_NAME_LENGTH +
                                                 sizeof(UNICODE_NULL);
                    ResourceName.Buffer = ResourceNameBuffer;
                    RtlIntegerToUnicodeString(NumResource,
                                              10,
                                              &ResourceName);
                }

                MonBuildInstanceDefinition(
                    pPerfInstanceDefinition,
                    (PVOID *)&pPerfCounterBlock,
                    ObjectNameTitleIndices[CurrentProtocol],
                    i,
                    (DWORD)PERF_NO_UNIQUE_ID,
                    &ResourceName);

                pPerfCounterBlock->ByteLength = SIZE_OF_NBF_RESOURCE_DATA;

                pdwCounter = (PDWORD)&pPerfCounterBlock[1]; // define pointer to first
                                                            // counter in block
                *pdwCounter++ =
                    ProviderStats->ResourceStats[NumResource].MaximumResourceUsed;
                *pdwCounter++ =
                    ProviderStats->ResourceStats[NumResource].AverageResourceUsed;
                *pdwCounter++ =
                    ProviderStats->ResourceStats[NumResource].ResourceExhausted;

                // set pointer to where next instance buffer should show up

                pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                          ((PBYTE) pPerfCounterBlock +
                                           SIZE_OF_NBF_RESOURCE_DATA);
                // set for loop termination

                pdwCounter = (PDWORD) pPerfInstanceDefinition;

            }  // NumberOfResources
        }   // NumOfDevices
    } // NBF_PROTOCOL

    *lppData = pdwCounter;

    pNbfResourceDataDefinition->NbfResourceObjectType.TotalByteLength =
        (DWORD)((PBYTE) pdwCounter - (PBYTE) pNbfResourceDataDefinition);

    if (CurrentProtocol != NBF_PROTOCOL) {
        *lpNumObjectTypes = 1;
        // bytes used are those of the first (i.e. only) object returned
        *lpcbTotalBytes = pNbfDataDefinition->NbfObjectType.TotalByteLength;
    } else {
        // set count of object types returned
        *lpNumObjectTypes = NBF_NUM_PERF_OBJECT_TYPES;
        // set length of this object
            *lpcbTotalBytes;
        // note the bytes used by first object
        *lpcbTotalBytes = pNbfDataDefinition->NbfObjectType.TotalByteLength;
        // add the bytes used by the second object
        *lpcbTotalBytes +=
            pNbfResourceDataDefinition->NbfResourceObjectType.TotalByteLength;
        // set number of instances loaded
        pNbfResourceDataDefinition->NbfResourceObjectType.NumInstances =
            TotalNumberOfResources;
    }

    REPORT_INFORMATION (TDI_COLLECT_DATA, LOG_DEBUG);
    return ERROR_SUCCESS;
}


DWORD
CloseNbfPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to Nbf devices.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    return CloseTDIPerformanceData(NBF_PROTOCOL);
}

DWORD
CloseIPXPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to IPX devices.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    return CloseTDIPerformanceData(IPX_PROTOCOL);
}

DWORD
CloseSPXPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to SPX devices.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    return CloseTDIPerformanceData(SPX_PROTOCOL);
}

DWORD
CloseNWNBPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to NWNB devices.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    return CloseTDIPerformanceData(NWNB_PROTOCOL);
}

DWORD
CloseTDIPerformanceData(
    DWORD CurrentProtocol
)

/*++

Routine Description:

    This routine closes the open handles to TDI devices.

Arguments:

    Current protocol index.


Return Value:

    ERROR_SUCCESS

--*/

{
    REPORT_INFORMATION (TDI_CLOSE_ENTERED, LOG_VERBOSE);

    if (dwTdiProtocolRefCount[CurrentProtocol] > 0) {
        dwTdiProtocolRefCount[CurrentProtocol]--;
        if (dwTdiProtocolRefCount[CurrentProtocol] == 0) {
            CleanUpTDIData (CurrentProtocol);
        }
    }

    if (dwTdiRefCount > 0) {
        dwTdiRefCount--;
        if (dwTdiRefCount == 0) {
            if ( ProviderStats ) {
                RtlFreeHeap(RtlProcessHeap(), 0, ProviderStats);
                ProviderStats = NULL;
                REPORT_INFORMATION (TDI_PROVIDER_STATS_FREED, LOG_VERBOSE);
            }
        }
    }

    MonCloseEventLog ();

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\perftcp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perftcp.h  

Abstract:

    This file provides the RFC 1156 Object Identifier Strings
    for all the performance data kept by SNMP agents that 
    are interesting to the Performance monitor. 

Author:

    Christos Tsollis 8/28/92  

Revision History:


--*/
#ifndef _PERFTCP_H_
#define _PERFTCP_H_
// 
// This is the array of the Object Identifier Strings for the IP, ICMP, TCP and
// UDP performance data kept by SNMP agents that are interesting to the 
// Performance Monitor.
//


#define NO_OF_OIDS	55  // Number of IP, ICMP, TCP and UDP Oids used


CHAR *OidStr[NO_OF_OIDS] =
{
	".iso.org.dod.internet.mgmt.mib-2.interfaces.ifNumber.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInReceives.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInHdrErrors.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInAddrErrors.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipForwDatagrams.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInUnknownProtos.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInDiscards.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipInDelivers.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipOutRequests.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipOutDiscards.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipOutNoRoutes.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipReasmReqds.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipReasmOKs.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipReasmFails.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipFragOKs.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipFragFails.0",
	".iso.org.dod.internet.mgmt.mib-2.ip.ipFragCreates.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpCurrEstab.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpActiveOpens.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpPassiveOpens.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpAttemptFails.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpEstabResets.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpInSegs.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpOutSegs.0",
	".iso.org.dod.internet.mgmt.mib-2.tcp.tcpRetransSegs.0",
	".iso.org.dod.internet.mgmt.mib-2.udp.udpInDatagrams.0",
	".iso.org.dod.internet.mgmt.mib-2.udp.udpNoPorts.0",
	".iso.org.dod.internet.mgmt.mib-2.udp.udpInErrors.0",
	".iso.org.dod.internet.mgmt.mib-2.udp.udpOutDatagrams.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInMsgs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInErrors.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInDestUnreachs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInTimeExcds.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInParmProbs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInSrcQuenchs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInRedirects.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInEchos.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInEchoReps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInTimestamps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInTimestampReps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInAddrMasks.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpInAddrMaskReps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutMsgs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutErrors.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutDestUnreachs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutTimeExcds.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutParmProbs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutSrcQuenchs.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutRedirects.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutEchos.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutEchoReps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutTimestamps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutTimestampReps.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutAddrMasks.0",
	".iso.org.dod.internet.mgmt.mib-2.icmp.icmpOutAddrMaskReps.0"
};


//
// The indices of the various counters in their VarBind lists.
//

#define IF_NUMBER_INDEX				0
#define IP_INRECEIVES_INDEX			1
#define IP_INHDRERRORS_INDEX			2
#define IP_INADDRERRORS_INDEX			3
#define IP_FORWDATAGRAMS_INDEX			4
#define IP_INUNKNOWNPROTOS_INDEX		5
#define IP_INDISCARDS_INDEX			6
#define IP_INDELIVERS_INDEX			7
#define IP_OUTREQUESTS_INDEX			8
#define IP_OUTDISCARDS_INDEX			9
#define IP_OUTNOROUTES_INDEX			10
#define IP_REASMREQDS_INDEX			11
#define IP_REASMOKS_INDEX			12
#define IP_REASMFAILS_INDEX			13
#define IP_FRAGOKS_INDEX			14
#define IP_FRAGFAILS_INDEX			15
#define IP_FRAGCREATES_INDEX			16
#define TCP_CURRESTAB_INDEX			17
#define TCP_ACTIVEOPENS_INDEX			18
#define TCP_PASSIVEOPENS_INDEX			19
#define TCP_ATTEMPTFAILS_INDEX			20
#define TCP_ESTABRESETS_INDEX			21
#define TCP_INSEGS_INDEX			22
#define TCP_OUTSEGS_INDEX			23
#define TCP_RETRANSSEGS_INDEX			24
#define UDP_INDATAGRAMS_INDEX			25
#define UDP_NOPORTS_INDEX			26
#define UDP_INERRORS_INDEX			27
#define UDP_OUTDATAGRAMS_INDEX			28

#define ICMP_INMSGS_INDEX			0
#define ICMP_INERRORS_INDEX			1
#define ICMP_INDESTUNREACHS_INDEX		2
#define ICMP_INTIMEEXCDS_INDEX			3
#define ICMP_INPARMPROBS_INDEX			4
#define ICMP_INSRCQUENCHS_INDEX			5
#define ICMP_INREDIRECTS_INDEX			6
#define ICMP_INECHOS_INDEX			7
#define ICMP_INECHOREPS_INDEX			8
#define ICMP_INTIMESTAMPS_INDEX			9
#define ICMP_INTIMESTAMPREPS_INDEX		10
#define ICMP_INADDRMASKS_INDEX			11
#define ICMP_INADDRMASKREPS_INDEX		12
#define ICMP_OUTMSGS_INDEX			13
#define ICMP_OUTERRORS_INDEX			14
#define ICMP_OUTDESTUNREACHS_INDEX		15
#define ICMP_OUTTIMEEXCDS_INDEX			16
#define ICMP_OUTPARMPROBS_INDEX			17
#define ICMP_OUTSRCQUENCHS_INDEX		18
#define ICMP_OUTREDIRECTS_INDEX			19
#define ICMP_OUTECHOS_INDEX			20
#define ICMP_OUTECHOREPS_INDEX			21
#define ICMP_OUTTIMESTAMPS_INDEX		22
#define ICMP_OUTTIMESTAMPREPS_INDEX		23
#define ICMP_OUTADDRMASKS_INDEX			24
#define ICMP_OUTADDRMASKREPS_INDEX		25


// 
// This is the array of the Object Identifier Strings for the Network Interface
// performance data kept by SNMP agents that are interesting to the 
// Performance Monitor.
//


#define NO_OF_IF_OIDS	14	// Number of Network Interface Oids used


CHAR *IfOidStr[NO_OF_IF_OIDS] =
{
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifIndex",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifSpeed",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInOctets", 
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInUcastPkts",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInNUcastPkts", 
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInDiscards",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInErrors",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifInUnknownProtos",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutOctets", 
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutUcastPkts",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutNUcastPkts", 
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutDiscards",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutErrors",
".iso.org.dod.internet.mgmt.mib-2.interfaces.ifTable.ifEntry.ifOutQLen"
};



//
// The indices of the various counters in the above array.
//

#define IF_INDEX_INDEX				0
#define IF_SPEED_INDEX				1
#define IF_INOCTETS_INDEX			2
#define IF_INUCASTPKTS_INDEX			3
#define IF_INNUCASTPKTS_INDEX			4
#define IF_INDISCARDS_INDEX			5
#define IF_INERRORS_INDEX			6
#define IF_INUNKNOWNPROTOS_INDEX		7
#define IF_OUTOCTETS_INDEX			8
#define IF_OUTUCASTPKTS_INDEX			9
#define IF_OUTNUCASTPKTS_INDEX			10
#define IF_OUTDISCARDS_INDEX			11
#define IF_OUTERRORS_INDEX			12
#define IF_OUTQLEN_INDEX			13


SNMPAPI SnmpMgrText2Oid (
    IN LPSTR string,
    OUT AsnObjectIdentifier *oid);

#endif //_PERFTCP_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\perfdhcp.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfdhcp.c

    This file implements the Extensible Performance Objects for
    the DHCP Server service.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.
        RameshV     05-Aug-1998 Adapted to DHCP Server service.
                                Used Shared memory instead of LPC

*/

#define UNICODE 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winperf.h>
#include <lm.h>

#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include "dhcpctrs.h"
#include "perfmsg.h"
#include "perfutil.h"
#include "datadhcp.h"
#include "perfctr.h"

#pragma warning (disable : 4201)
#include <dhcpapi.h>
#pragma warning (default : 4201)

//
//  Private globals.
//

DWORD   cOpens    = 0;                 // Active "opens" reference count.
BOOL    fInitOK   = FALSE;             // TRUE if DLL initialized OK.
BOOL    sfLogOpen = FALSE;             //indicates whether the log is
                                       //open or closed

BOOL    sfErrReported = FALSE;        //to prevent the same error from being
                                      //logged continuously

#define LOCAL_SERVER                  TEXT("127.0.0.1")

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenDhcpPerformanceData;
PM_COLLECT_PROC CollectDhcpPerformanceData;
PM_CLOSE_PROC   CloseDhcpPerformanceData;

//
//  Private helper functions
//
LPDHCP_PERF_STATS SharedMem;
HANDLE            ShSegment             = NULL;
BOOL              fSharedMemInitialized = FALSE;

DWORD
InitSharedMem(
    VOID
)
{
    ULONG Error = ERROR_SUCCESS;

    if( FALSE == fSharedMemInitialized ) {
        // create named temporary mapping file
        SharedMem = NULL;
        ShSegment = CreateFileMapping(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            sizeof(DHCP_PERF_STATS),
            (LPCWSTR)DHCPCTR_SHARED_MEM_NAME
        );

        if( NULL != ShSegment ) {
            // we have a file now map a view into it
            SharedMem = (LPVOID) MapViewOfFile(
                ShSegment,
                FILE_MAP_READ,
                0,
                0,
                sizeof(DHCP_PERF_STATS)
            );

            if( NULL != SharedMem ) {
                fSharedMemInitialized = TRUE;
            } else {
                // unable to map view
                Error = GetLastError();
                CloseHandle(ShSegment);
                ShSegment = NULL;
                // SharedMem is NULL;
            }
        } else {
            // unable to create file mapping
            Error = GetLastError();
            // ShSegment is NULL;
            // SharedMem is NULL;
        }
    } else {
        // already initialized so continue
    }

    return Error;
}

VOID
CleanupSharedMem(
    VOID
)
{
    if( FALSE == fSharedMemInitialized ) return;

    if( NULL != SharedMem ) UnmapViewOfFile( SharedMem );
    if( NULL != ShSegment ) CloseHandle( ShSegment );

    SharedMem = NULL;
    ShSegment = NULL;
    fSharedMemInitialized = FALSE;
}

//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenDhcpPPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        Pradeepb     20-July-1993 Created.`
        RameshV      05-Aug-1998 Adapted for DHCP.

********************************************************************/
DWORD OpenDhcpPerformanceData( LPWSTR lpDeviceNames )
{
    DWORD err  = NO_ERROR;
    DWORD dwFirstCounter = 0;
    DWORD dwFirstHelp = 0;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    UNREFERENCED_PARAMETER (lpDeviceNames);

    if( !fInitOK )
    {
        PERF_COUNTER_DEFINITION * pctr;
        DWORD                     i;
        HKEY                      DhcpKey;

        REPORT_INFORMATION( DHCP_OPEN_ENTERED, LOG_VERBOSE );

        //
        //  This is the *first* open.
        //

        err = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            (LPCWSTR)L"System\\CurrentControlSet\\Services\\DHCPServer\\Performance",
            0,
            KEY_READ,
            &DhcpKey
        );

        if( ERROR_SUCCESS == err ) {
            ULONG dwSize = sizeof(dwFirstCounter);
            err = RegQueryValueExW(
                DhcpKey,
                (LPCWSTR)L"First Counter",
                NULL,
                NULL,
                (LPBYTE)&dwFirstCounter,
                &dwSize
            );
            RegCloseKey(DhcpKey);
        }

        if (err == ERROR_SUCCESS) {
            // first help index is 1 more than first counter index as LODCTR installs it.
            dwFirstHelp = dwFirstCounter + 1;

            err = InitSharedMem();
            if( ERROR_SUCCESS != err ) return err;

            if (!MonOpenEventLog())
            {
                sfLogOpen = TRUE;
            }

            if( ERROR_SUCCESS == err ) {
                //
                //  Update the object & counter name & help indicies.
                //

                DhcpDataDataDefinition.ObjectType.ObjectNameTitleIndex
                    += dwFirstCounter;
                DhcpDataDataDefinition.ObjectType.ObjectHelpTitleIndex
                    += dwFirstHelp;

                pctr = &DhcpDataDataDefinition.PacketsReceived;

                for( i = 0 ; i < NUMBER_OF_DHCPDATA_COUNTERS ; i++ )
                {
                    pctr->CounterNameTitleIndex += dwFirstCounter;
                    pctr->CounterHelpTitleIndex += dwFirstHelp;
                    pctr++;
                }

                //
                //  Remember that we initialized OK.
                //

                fInitOK = TRUE;
            }
        } else {
            // if here, then either the perf key or the counter strings
            // have not been installed so set the error code.
            err = DHCP_NOT_INSTALLED;
            REPORT_WARNING( DHCP_NOT_INSTALLED, LOG_DEBUG );
        }

    }


    //
    //  Bump open counter.
    //

    if( err == NO_ERROR )
    {
        InterlockedIncrement(&cOpens);
    }

    //
    // if sfLogOpen is FALSE, it means that all threads we closed the
    // event log in CloseDHCPPerformanceData
    //

    if (!sfLogOpen)
    {
       MonOpenEventLog();
    }

    if( 0 == err ) {
        REPORT_INFORMATION( DHCP_OPEN_SUCCESS, LOG_DEBUG );
    } else {
        REPORT_INFORMATION( DHCP_OPEN_FAILURE, LOG_DEBUG );
    }

    if (DHCP_NOT_INSTALLED == err) {
        // sanitize the return value to avoid spamming the event log
        err = ERROR_SUCCESS;
        // this will prevent perflib from generating an error and
        // since the fInitOK flag is still FLASE, all calls to the collect
        // function will return no data.
        // however, the DLL will still be loaded and the functions called
        // even though there's no real point.
        // returning an error code, however will spam the event log with
        // error messages so this is the quitest way to go.
    }

    return err;

}   // OpenDHCPPerformanceData

/*******************************************************************

    NAME:       CollectDhcpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectDhcpPerformanceData( LPWSTR    lpValueName,
                                 LPVOID  * lppData,
                                 LPDWORD   lpcbTotalBytes,
                                 LPDWORD   lpNumObjectTypes )
{
    DWORD                    dwQueryType;
    ULONG                    cbRequired;
    DWORD                    *pdwCounter;
    DHCPDATA_COUNTER_BLOCK   *pCounterBlock;
    DHCPDATA_DATA_DEFINITION *pDhcpDataDataDefinition;
    DWORD          	     Status;
    DHCP_PERF_STATS      PerfStats;

    //
    //  No need to even try if we failed to open...
    //

    if( NULL == lpValueName ) {
        REPORT_INFORMATION( DHCP_COLLECT_ENTERED, LOG_VERBOSE );
    } else {
        REPORT_INFORMATION_DATA(
            DHCP_COLLECT_ENTERED, LOG_VERBOSE,
            (LPVOID) lpValueName, (DWORD)(wcslen(lpValueName)*sizeof(WCHAR))
        );
    }

    if( !fInitOK )
    {
        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if( dwQueryType == QUERY_FOREIGN )
    {
        //
        //  We don't do foreign queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        DhcpDataDataDefinition.ObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return NO_ERROR;
        }
    }

    //
    //  See if there's enough space.
    //

    pDhcpDataDataDefinition = (DHCPDATA_DATA_DEFINITION *)*lppData;

    cbRequired = sizeof(DHCPDATA_DATA_DEFINITION) +
				DHCPDATA_SIZE_OF_PERFORMANCE_DATA;

    if( *lpcbTotalBytes < cbRequired )
    {
        DWORD Diff = (cbRequired - *lpcbTotalBytes );

        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        REPORT_INFORMATION_DATA(
            DHCP_COLLECT_NO_MEM, LOG_VERBOSE,
            (PVOID) &Diff, sizeof(Diff) );

        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pDhcpDataDataDefinition,
             &DhcpDataDataDefinition,
             sizeof(DHCPDATA_DATA_DEFINITION) );

    //
    //  Try to retrieve the data.
    //

    if( NULL == SharedMem ) {
        Status = ERROR_INVALID_HANDLE;
    } else {
        Status = ERROR_SUCCESS;
    }

    if( Status != ERROR_SUCCESS )
    {
        //
        // if we haven't logged the error yet, log it
        //
        if (!sfErrReported)
        {
            REPORT_ERROR(DHCP_COLLECT_ERR, LOG_USER);
            sfErrReported = TRUE;
        }

        //
        //  Error retrieving statistics.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    //
    // Ahaa, we got the statistics, reset flag if set
    //
    if (sfErrReported)
    {
       sfErrReported = FALSE;
    }
    //
    //  Format the DHCP Server data.
    //

    pCounterBlock = (DHCPDATA_COUNTER_BLOCK *)( pDhcpDataDataDefinition + 1 );

    pCounterBlock->PerfCounterBlock.ByteLength =
				DHCPDATA_SIZE_OF_PERFORMANCE_DATA;

    //
    //  Get the pointer to the first (DWORD) counter.  This
    //  pointer *must* be quadword aligned.
    //

    pdwCounter = (DWORD *)( pCounterBlock + 1 );

    ASSERT( ( (DWORD_PTR)pdwCounter & 3 ) == 0 );

    //
    //  Move the DWORDs into the buffer.
    //
    PerfStats = *SharedMem;
    PerfStats.dwNumMilliSecondsProcessed /= (
        1 + PerfStats.dwNumPacketsProcessed
    );
    memcpy( (LPBYTE)pdwCounter, (LPBYTE)&PerfStats, sizeof(ULONG)*NUMBER_OF_DHCPDATA_COUNTERS);
    pdwCounter += NUMBER_OF_DHCPDATA_COUNTERS;

    //
    //  Update arguments for return.
    //

    *lppData          = (PVOID)pdwCounter;
    *lpNumObjectTypes = 1;
    *lpcbTotalBytes   = (DWORD)((BYTE *)pdwCounter - (BYTE *)pDhcpDataDataDefinition);

    //
    //  Success!  Honest!!
    //

    REPORT_INFORMATION( DHCP_COLLECT_SUCCESS, LOG_VERBOSE );
    return NO_ERROR;

}   // CollectDHCPPerformanceData

/*******************************************************************

    NAME:       CloseDHCPPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseDhcpPerformanceData( VOID )
{
    LONG   lOpens;
    //
    //  No real cleanup to do here.
    //

    REPORT_INFORMATION( DHCP_CLOSE_ENTERED, LOG_VERBOSE );

    //
    // NOTE: The interlocked operations are used just as a safeguard.
    // As with all perflibs, these 3 functions should be called within
    // a data mutex.
    //
    lOpens = InterlockedDecrement(&cOpens);
    assert (lOpens >= 0);
    if (lOpens == 0)
    {
      //
      // unbind from the nameserver. There could be synch. problems since
      // sfLogOpen is changed in both Open and Close functions. This at the
      // max. will affect logging. It being unclear at this point whether or
      // not Open gets called multiple times (from all looks of it, it is only
      // called once), this flag may even not be necessary.
      //
      MonCloseEventLog();
      sfLogOpen = FALSE;
      CleanupSharedMem();
    }
    return NO_ERROR;

}   // CloseDHCPPerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\perftcp.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perftcp.c

Abstract:

    This file implements the Extensible Objects for
    the TCP/IP LAN object types

Created:

    Christos Tsollis  08/26/92

Revision History:

    10/28/92    a-robw (Bob Watson)
            added Message Logging and Foreign Computer Support interface.


--*/
//
//  Disable SNMP interface
//
//      This file has been modified to circumvent the SNMP service and
//      go right to the agent DLL. In doing this, performance has been
//      improved at the expense of only being able to query the local
//      machine. The USE_SNMP flag has been used to save as much of the
//      old code as possible (it used to work) but the emphesis of this
//      modification is to make it work "around" SNMP and, as such, the
//      USE_SNMP blocks of code HAVE NOT (at this time) BEEN TESTED!
//      Caveat Emptor!  (a-robw)
//
#ifdef USE_SNMP
#undef USE_SNMP
#endif

//#define LOAD_MGMTAPI
#ifdef LOAD_MGMTAPI
#undef LOAD_MGMTAPI
#endif

#define LOAD_INETMIB1
//#ifdef LOAD_INETMIB1
//#undef LOAD_INETMIB1
//#endif

//
//  Disable DSIS interface for now
//
#ifdef USE_DSIS
#undef USE_DSIS
#endif

//
// Use IPHLPAPI.DLL
//
#ifndef USE_SNMP
#define USE_IPHLPAPI
#ifdef  LOAD_INETMIB1
#undef  LOAD_INETMIB1
#endif
#endif

//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntprfctr.h>
#include <windows.h>
#include <winperf.h>
#include <winbase.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#ifdef USE_SNMP
#include <mgmtapi.h>
#endif
#include <snmp.h>
#ifdef USE_IPHLPAPI
#include <iphlpapi.h>
#endif
#include "perfctr.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "perfnbt.h"
//#include "perfdsis.h"   ! not yet !
#ifndef USE_IPHLPAPI
#include "perftcp.h"
#endif
#include "datatcp.h"

#define ALIGN_SIZE 0x00000008

//
//  Global Variables
//

//
// References to constants which initialize the Object type definitions
//

extern NET_INTERFACE_DATA_DEFINITION    NetInterfaceDataDefinition;
extern IP_DATA_DEFINITION               IpDataDefinition;
extern ICMP_DATA_DEFINITION             IcmpDataDefinition;
extern TCP_DATA_DEFINITION              TcpDataDefinition;
extern UDP_DATA_DEFINITION              UdpDataDefinition;


#ifndef USE_SNMP    // only include if not using SNMP interface
//
HANDLE  hSnmpEvent = NULL;  // handler for SNMP Extension Agent

#endif

//
// TCP/IP data structures
//
#ifdef USE_SNMP
LPSNMP_MGR_SESSION      TcpIpSession = (LPSNMP_MGR_SESSION) NULL;
                                        // The SNMP manager session providing
                                        // the requested information.
#else
BOOL                    TcpIpSession = FALSE;
                                        // The SNMP manager session providing
                                        // the requested information.
#endif

#ifdef USE_IPHLPAPI
#define MAX_INTERFACE_LEN   MAX_PATH    // Maximum length of a network interface
                                        // name
#define DEFAULT_INTERFACES  20          // Default interfaces count

DWORD        IfNum;
MIB_IPSTATS  IpStats;
MIB_ICMP     IcmpStats;
MIB_TCPSTATS TcpStats;
MIB_UDPSTATS UdpStats;
PMIB_IFTABLE IfTable = NULL;
DWORD        IfTableSize = 0;
#else
AsnObjectName           RefNames[NO_OF_OIDS];

RFC1157VarBind          RefVariableBindingsArray[NO_OF_OIDS],
                        VariableBindingsArray[NO_OF_OIDS];
                                        // The array of the variable bindings,
                                        // used by the SNMP agent functions
                                        // to record the info we want for the
                                        // IP, ICMP, TCP and UDP protocols




RFC1157VarBind          IFPermVariableBindingsArray[NO_OF_IF_OIDS];
                                        // The initialization array of the
                                        // variable bindings,
                                        // used by the SNMP agent functions
                                        // to record the info we want for each
                                        // of the Network Interfaces


RFC1157VarBindList      RefVariableBindings;
RFC1157VarBindList      RefIFVariableBindings;
RFC1157VarBindList      RefVariableBindingsICMP;
                                        // The headers of the lists with the
                                        // variable bindings.
                                        // The headers of the lists with the
                                        // variable bindings.

RFC1157VarBind          NetIfRequest;   // structure for net request
RFC1157VarBindList      NetIfRequestList;

//
//  Constants
//

#define TIMEOUT             500     // Communication timeout in milliseconds
#define RETRIES             5       // Communication time-out/retry count

#define MAX_INTERFACE_LEN   10      // Maximum length of a network interface
                                    // name


#define OIDS_OFFSET         0       // Offset of other than the ICMP Oids
                                    // in the VariableBindingsArray[]
#define ICMP_OIDS_OFFSET    29      // Offset of the ICMP Oids in the array



#define OIDS_LENGTH         29      // Number of the other than the ICMP
                                    // Oids in the VariableBindingsArray[]
#define ICMP_OIDS_LENGTH    26      // Number of the ICMP Oids in the array

//
// Macro Definitions (To avoid long expressions)
//

#define IF_COUNTER(INDEX)        \
                  (IFVariableBindings.list[(INDEX)].value.asnValue.counter)
#define IF_GAUGE(INDEX)                \
                  (IFVariableBindings.list[(INDEX)].value.asnValue.gauge)
#define IP_COUNTER(INDEX)        \
                  (VariableBindings.list[(INDEX)].value.asnValue.counter)
#define ICMP_COUNTER(INDEX)        \
                  (VariableBindingsICMP.list[(INDEX)].value.asnValue.counter)
#define TCP_COUNTER(INDEX)        \
                  (VariableBindings.list[(INDEX)].value.asnValue.counter)
#define UDP_COUNTER(INDEX)        \
                  (VariableBindings.list[(INDEX)].value.asnValue.counter)
#define TCP_GAUGE(INDEX)                \
                  (VariableBindings.list[(INDEX)].value.asnValue.gauge)
#endif

#define TCP_OBJECT  0x00000001
#define UDP_OBJECT  0x00000002
#define IP_OBJECT   0x00000004
#define ICMP_OBJECT 0x00000008
#define NET_OBJECT  0x00000010
#define NBT_OBJECT  0x00000020
#define SNMP_OBJECTS (TCP_OBJECT+UDP_OBJECT+IP_OBJECT+ICMP_OBJECT+NET_OBJECT)
#define SNMP_ERROR  0x40000000


#define DO_COUNTER_OBJECT(flags,counter) \
                    ((((flags) & (counter)) == (counter)) ? TRUE : FALSE)

//
//  Function Prototypes
//

PM_OPEN_PROC    OpenTcpIpPerformanceData;
PM_COLLECT_PROC CollectTcpIpPerformanceData;
PM_CLOSE_PROC   CloseTcpIpPerformanceData;

#ifdef LOAD_INETMIB1
HANDLE  hInetMibDll;
PFNSNMPEXTENSIONINIT pSnmpExtensionInit;
PFNSNMPEXTENSIONQUERY pSnmpExtensionQuery;
#endif

DWORD   dwTcpRefCount = 0;

static const WCHAR szFriendlyNetworkInterfaceNames[] = {L"FriendlyNetworkInterfaceNames"};
static const WCHAR szTcpipPerformancePath[] = {L"SYSTEM\\CurrentControlSet\\Services\\TcpIp\\Performance"};
static BOOL bUseFriendlyNames = FALSE;

__inline Assign64(
    IN LONGLONG       qwSrc,
    IN PLARGE_INTEGER pqwDest
    )
{
    PLARGE_INTEGER pqwSrc = (PLARGE_INTEGER) &qwSrc;
    pqwDest->LowPart  = pqwSrc->LowPart;
    pqwDest->HighPart = pqwSrc->HighPart;
}

static
BOOL
FriendlyNameIsSet ()
{
    BOOL bReturn = TRUE;

    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hKeyTcpipPerformance = NULL;
    DWORD   dwType = 0;
    DWORD   dwSize = 0;
    DWORD   dwValue = 0;
    
    dwStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        szTcpipPerformancePath,
        0L,
        KEY_READ,
        &hKeyTcpipPerformance);

    if (dwStatus == ERROR_SUCCESS) {
        dwSize = sizeof(dwValue);
        dwStatus = RegQueryValueExW (
            hKeyTcpipPerformance,
            szFriendlyNetworkInterfaceNames,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);

        if ((dwStatus == ERROR_SUCCESS) && (dwValue == 0) && 
            ((dwType == REG_DWORD) || ((dwType == REG_BINARY) && (dwSize == sizeof (DWORD))))) {
            bReturn = FALSE;
        }

        RegCloseKey (hKeyTcpipPerformance);
    }

    return bReturn;
}

DWORD
OpenTcpIpPerformanceData (
    IN LPWSTR dwVoid        // Argument needed only to conform to calling
                            // interface for this routine. (NT > 312) RBW
)
/*++

Routine Description:

    This routine will open all the TCP/IP devices and remember the handles
    returned by the devices.


Arguments:

    IN LPWSTR dwVoid
        not used

Return Value:

    ERROR_SUCCESS if successful completion
    error returned by OpenNbtPerformanceData
    error returned by OpenDsisPerformanceData
    or Win32 Error value

--*/
{
    DWORD          Status;
    TCHAR         ComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD         cchBuffer = MAX_COMPUTERNAME_LENGTH+1;

    DWORD    dwDataReturn[2];  // event log data
#ifdef LOAD_INETMIB1
    UINT    nErrorMode;
#endif

#ifndef USE_IPHLPAPI
    register i;
#ifdef LOAD_MGMTAPI
    HANDLE  hMgmtApiDll;    // handle to library
    FARPROC     SnmpMgrStrToOid;    // address of function
#else
#define     SnmpMgrStrToOid(a,b)    SnmpMgrText2Oid((a),(b))
#endif

#ifdef LOAD_INETMIB1
    AsnObjectIdentifier     SnmpOid;
#endif
#endif

    UNREFERENCED_PARAMETER (dwVoid);
    
    MonOpenEventLog ();

    REPORT_INFORMATION (TCP_OPEN_ENTERED, LOG_VERBOSE);

    HEAP_PROBE();

    if (dwTcpRefCount == 0) {
        // Open NBT
        Status = OpenNbtPerformanceData (0L);
        if ( Status != ERROR_SUCCESS ) {
            // NBT reports any Open errors to the user
            REPORT_ERROR (TCP_NBT_OPEN_FAIL, LOG_DEBUG);
            return Status;
        }
        REPORT_INFORMATION (TCP_NBT_OPEN_SUCCESS, LOG_VERBOSE);

#ifdef USE_DSIS
        Status = OpenDsisPerformanceData (0L);
        if (Status != ERROR_SUCCESS) {
            // DSIS Open reports Open errors to the user
            REPORT_ERROR  (TCP_DSIS_OPEN_FAIL, LOG_DEBUG);
            return (Status);
        }

        REPORT_INFORMATION (TCP_DSIS_OPEN_SUCCESS, LOG_VERBOSE);
#endif // USE_DSIS

#ifdef LOAD_MGMTAPI   // this STILL craps out

        hMgmtApiDll = LoadLibrary ("MGMTAPI.DLL");

        if (hMgmtApiDll == NULL) {
            dwDataReturn[0] = GetLastError ();
            REPORT_ERROR_DATA (TCP_LOAD_LIBRARY_FAIL, LOG_USER,
                &dwDataReturn[0], (sizeof (DWORD)));
            return (dwDataReturn[0]);
        }

        SnmpMgrStrToOid = GetProcAddress (hMgmtApiDll, "SnmpMgrStrToOid");

        if (!(BOOL)SnmpMgrStrToOid) {
            dwDataReturn[0] = GetLastError();
            REPORT_ERROR_DATA (TCP_GET_STRTOOID_ADDR_FAIL, LOG_USER,
                &dwDataReturn[0], (sizeof (DWORD)));
            CloseNbtPerformanceData ();
            FreeLibrary (hMgmtApiDll);
            return (dwDataReturn[0]);
        }
#else

        // SnmpMgrStrToOid is defined as a macro above

#endif // LOAD_MGMTAPI

#ifdef LOAD_INETMIB1   // this STILL craps out

        // don't pop up any dialog boxes
        nErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);

        hInetMibDll = LoadLibrary ("INETMIB1.DLL");

        if (hInetMibDll == NULL) {
            dwDataReturn[0] = GetLastError ();
            REPORT_ERROR_DATA (TCP_LOAD_LIBRARY_FAIL, LOG_USER,
                &dwDataReturn[0], (sizeof (DWORD)));
            CloseNbtPerformanceData ();
            // restore Error Mode
            SetErrorMode (nErrorMode);
            return (dwDataReturn[0]);
        } else {
            // restore Error Mode
            SetErrorMode (nErrorMode);
        }

        pSnmpExtensionInit = (PFNSNMPEXTENSIONINIT)GetProcAddress
            (hInetMibDll, "SnmpExtensionInit");
        pSnmpExtensionQuery = (PFNSNMPEXTENSIONQUERY)GetProcAddress
            (hInetMibDll, "SnmpExtensionQuery");

        if (!pSnmpExtensionInit || !pSnmpExtensionQuery) {
            dwDataReturn[0] = GetLastError();
            REPORT_ERROR_DATA (TCP_LOAD_ROUTINE_FAIL, LOG_USER,
                &dwDataReturn[0], (sizeof (DWORD)));
            FreeLibrary (hInetMibDll);
            CloseNbtPerformanceData ();
            return (dwDataReturn[0]);
        }

#endif  // LOAD_INETMIB1
        // Initialize the Variable Binding list for IP, ICMP, TCP and UDP

        Status = 0; // initialize error count

        HEAP_PROBE();

#ifndef USE_IPHLPAPI
        for (i = 0; i < NO_OF_OIDS; i++) {
            if (!SnmpMgrStrToOid (OidStr[i], &(RefNames[i]))) {
                Status++;
                REPORT_ERROR_DATA (TCP_BAD_OBJECT, LOG_DEBUG,
                    OidStr[i], strlen(OidStr[i]));
                RefNames[i].ids = NULL;
                RefNames[i].idLength = 0;
            }
            RefVariableBindingsArray[i].value.asnType = ASN_NULL;
        }

        if (Status == 0) {
            REPORT_INFORMATION (TCP_BINDINGS_INIT, LOG_VERBOSE);
        }

        HEAP_PROBE();

        // Initialize the Variable Binding list for Network interfaces

        Status = 0;
        for (i = 0; i < NO_OF_IF_OIDS; i++) {
            if (!SnmpMgrStrToOid (IfOidStr[i], &(IFPermVariableBindingsArray[i].name))) {
                Status++;
                REPORT_ERROR_DATA (TCP_BAD_OBJECT, LOG_DEBUG,
                    IfOidStr[i], strlen(IfOidStr[i]));
            }

            IFPermVariableBindingsArray[i].value.asnType = ASN_NULL;
        }

        HEAP_PROBE();

#ifdef LOAD_MGMTAPI
        FreeLibrary (hMgmtApiDll);  // done with SnmpMgrStrToOid routine
#endif
        // initialize list structures

        RefVariableBindings.list = RefVariableBindingsArray + OIDS_OFFSET;
        RefVariableBindings.len = OIDS_LENGTH;

        RefVariableBindingsICMP.list =
            RefVariableBindingsArray + ICMP_OIDS_OFFSET;
        RefVariableBindingsICMP.len = ICMP_OIDS_LENGTH;

        RefIFVariableBindings.list = IFPermVariableBindingsArray;
        RefIFVariableBindings.len = NO_OF_IF_OIDS;
#endif

        if ( GetComputerName ((LPTSTR)ComputerName, (LPDWORD)&cchBuffer) == FALSE ) {
            dwDataReturn[0] = GetLastError();
            dwDataReturn[1] = 0;
            REPORT_ERROR_DATA (TCP_COMPUTER_NAME, LOG_USER,
                    &dwDataReturn, sizeof(dwDataReturn));
            CloseNbtPerformanceData ();
            return dwDataReturn[0];
        }

#ifdef USE_IPHLPAPI
        // enforce that TcpIpSession is on.
        //
        TcpIpSession = TRUE;
#else
#ifdef USE_SNMP

        // Establish the SNMP connection to communicate with the local SNMP agent

    /* This portion of the code for OpenTcpIpPerformanceData() could be used in
       the CollectTcpIpPerformanceData() routine to open an SNMP Manager session
       and collect data for the Network Interfaces, and IP, ICMP, TCP and UDP
       protocols for a remote machine.

       So, name this portion of the code: A
     */

        if ( (TcpIpSession = SnmpMgrOpen ((LPSTR) ComputerName,
                (LPSTR) "public",
                TIMEOUT,
                RETRIES)) == NULL ) {
            dwDataReturn[0] = GetLastError();
            REPORT_ERROR_DATA (TCP_SNMP_MGR_OPEN, LOG_USER,
                &dwDataReturn, sizeof(DWORD));
            return dwDataReturn[0];
        }

    /* End of code A
     */
#else

        // if not using the standard SNMP interface, then TcpIpSession is
        // a "boolean" to indicate if a session has been initialized and
        // can therefore be used

        TcpIpSession =  FALSE;       // make sure it's FALSE

        // initialize inet mib routines

        Status = (*pSnmpExtensionInit)(
            0L,
            &hSnmpEvent,    // event is created by Init Routine
            &SnmpOid
            );

        if (Status) {
            TcpIpSession = TRUE;   // return TRUE to indicate OK
        }

#endif  // USE_SNMP
#endif

        bUseFriendlyNames = FriendlyNameIsSet();
    }
    dwTcpRefCount++;

    HEAP_PROBE();
    REPORT_INFORMATION (TCP_OPEN_PERFORMANCE_DATA, LOG_DEBUG);
    return ERROR_SUCCESS;
} // OpenTcpIpPerformanceData



#pragma warning ( disable : 4127)
DWORD
CollectTcpIpPerformanceData(
    LPWSTR  lpValueName,
    LPVOID  *lppData,
    LPDWORD lpcbTotalBytes,
    LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for all the TCP/IP counters.

Arguments:

    Pointer to unicode string which is value passed to the registry for the
    query.

    Pointer to pointer to where to place the data.

    Size in bytes of the data buffer.


Return Value:

    Win32 Status.  If successful, pointer to where to place the data
    will be set to location following this routine's returned data block.

--*/

{
    DWORD                                Status;

    // Variables for reformatting the TCP/IP data

    register PDWORD                     pdwCounter, pdwPackets;
    NET_INTERFACE_DATA_DEFINITION       *pNetInterfaceDataDefinition;
    IP_DATA_DEFINITION                  *pIpDataDefinition;
    ICMP_DATA_DEFINITION                *pIcmpDataDefinition;
    TCP_DATA_DEFINITION                 *pTcpDataDefinition;
    UDP_DATA_DEFINITION                 *pUdpDataDefinition;
    DWORD                               SpaceNeeded;
    UNICODE_STRING                      InterfaceName;
    ANSI_STRING                         AnsiInterfaceName;
    WCHAR                               InterfaceNameBuffer[MAX_INTERFACE_LEN+1];
    CHAR                                AnsiInterfaceNameBuffer[MAX_INTERFACE_LEN+1];
    register PERF_INSTANCE_DEFINITION   *pPerfInstanceDefinition;
    PERF_COUNTER_BLOCK                  *pPerfCounterBlock;
    LPVOID                              lpDataTemp;
    DWORD                               NumObjectTypesTemp;

    LPWSTR                              lpFromString;
    DWORD                               dwQueryType;
    DWORD                               dwCounterFlags;
    DWORD                               dwThisChar;
    DWORD                               dwBlockSize;

    // Variables for collecting the TCP/IP data

    AsnInteger                          ErrorStatus;
    AsnInteger                          ErrorIndex;
    AsnInteger                          NetInterfaces;
    AsnInteger                          Interface;
    DWORD                               SentTemp;
    DWORD                               ReceivedTemp;

    DWORD                               dwDataReturn[2]; // for error values
    BOOL                                bFreeName;

#ifndef USE_IPHLPAPI
    int                                 i;
    BOOL                                bStatus;
#if USE_SNMP
    RFC1157VarBind                      IFVariableBindingsArray[NO_OF_IF_OIDS];
                                         // The array of the variable bindings,
                                         // used by the SNMP agent functions
                                         // to record the info we want for each
                                         // of the Network Interfaces

    RFC1157VarBind                      *VBElem;

    AsnInteger                          VBItem;
#endif

    RFC1157VarBindList                  IFVariableBindings,
                                        IFVariableBindingsCall,
                                        VariableBindings,
                                        VariableBindingsICMP;
                                        // The header of the above list with
                                        // the variable bindings.
#endif

    //
    //  ***************** executable code starts here *******************
    //
    ErrorStatus = 0L;
    ErrorIndex = 0L;

    if (lpValueName == NULL) {
        REPORT_INFORMATION (TCP_COLLECT_ENTERED, LOG_VERBOSE);
    } else {
        REPORT_INFORMATION_DATA (TCP_COLLECT_ENTERED, LOG_VERBOSE,
            (LPVOID)lpValueName, (DWORD)(lstrlenW(lpValueName)*sizeof(WCHAR)));
    }
    //
    // IF_DATA are all in DWORDS. We need to allow 1 of the octets which
    // will be __int64
    //
    dwBlockSize = SIZE_OF_IF_DATA + (1 * sizeof(DWORD));

    HEAP_PROBE();
    //
    // before doing anything else,
    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN) {

        // find start of computer name to pass to CollectDsisPerformanceData
        // this should put the pointer at the first character after the space
        // presumably the computer name

        lpFromString = lpValueName +
            ((sizeof(L"Foreign ")/sizeof(WCHAR))+1);
        // check for double slash notation and move past if found

        while (*lpFromString == '\\') {
            lpFromString++;
        }

        //
        // initialize local variables for sending to CollectDsisPerformanceData
        // routine
        //
        lpDataTemp = *lppData;
        SpaceNeeded = *lpcbTotalBytes;
        NumObjectTypesTemp = *lpNumObjectTypes;

        REPORT_INFORMATION_DATA (TCP_FOREIGN_COMPUTER_CMD, LOG_VERBOSE,
            (LPVOID)lpFromString, (DWORD)(lstrlenW(lpFromString)*sizeof(WCHAR)));
#ifdef USE_DSIS
        Status = CollectDsisPerformanceData (
            lpFromString,
                (LPVOID *) &lpDataTemp,
                  (LPDWORD) &SpaceNeeded,
                  (LPDWORD) &NumObjectTypesTemp);
        //
        // look at returned arguments to see if an error occured
        //  and send the appropriate event to the event log
        //
        if (Status == ERROR_SUCCESS) {

            if (NumObjectTypesTemp > 0) {
                REPORT_INFORMATION_DATA (TCP_DSIS_COLLECT_DATA_SUCCESS, LOG_DEBUG,
                &NumObjectTypesTemp, sizeof (NumObjectTypesTemp));
            } else {
                REPORT_ERROR (TCP_DSIS_NO_OBJECTS, LOG_DEBUG);
            }

            //
            //    update main return variables
            //
            *lppData = ALIGN_ON_QWORD(lpDataTemp);
            *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
            *lpNumObjectTypes = NumObjectTypesTemp;
            return ERROR_SUCCESS;
        } else {
            REPORT_ERROR_DATA (TCP_DSIS_COLLECT_DATA_ERROR, LOG_DEBUG,
                &Status, sizeof (Status));
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return Status;
        }
#else
        // no foreign data interface supported
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
#endif // USE_DSIS
    } // endif QueryType == Foreign

    dwCounterFlags = 0;

    // determine what to return

    if (dwQueryType == QUERY_GLOBAL) {
        dwCounterFlags |= NBT_OBJECT;
        dwCounterFlags |= SNMP_OBJECTS;
    } else if (dwQueryType == QUERY_ITEMS) {
        // check for the items provided by this routine
        //
        //  Since the data requests for the following protocols are all
        //  bundled together, we'll send back all the data. Collecting it
        //  via SNMP is the hard part. once that's done, sending it back
        //  is trivial.
        //
        if (IsNumberInUnicodeList (TCP_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= SNMP_OBJECTS;
        } else if (IsNumberInUnicodeList (UDP_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= SNMP_OBJECTS;
        } else if (IsNumberInUnicodeList (IP_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= SNMP_OBJECTS;
        } else if (IsNumberInUnicodeList (ICMP_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= SNMP_OBJECTS;
        } else if (IsNumberInUnicodeList (NET_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= SNMP_OBJECTS;
        }

        if (IsNumberInUnicodeList (NBT_OBJECT_TITLE_INDEX, lpValueName)) {
            dwCounterFlags |= NBT_OBJECT;
        }
    }

#ifndef USE_IPHLPAPI
    // copy Binding array structures to working buffers for Snmp queries

    RtlMoveMemory (VariableBindingsArray,
        RefVariableBindingsArray,
        sizeof (RefVariableBindingsArray));

    VariableBindings.list        = VariableBindingsArray + OIDS_OFFSET;
    VariableBindings.len         = OIDS_LENGTH;

    VariableBindingsICMP.list    = VariableBindingsArray + ICMP_OIDS_OFFSET;
    VariableBindingsICMP.len     = ICMP_OIDS_LENGTH;
#endif
    if (DO_COUNTER_OBJECT (dwCounterFlags, NBT_OBJECT)) {
        // Copy the parameters. We'll call the NBT Collect routine with these
        // parameters
        lpDataTemp = *lppData;
        SpaceNeeded = *lpcbTotalBytes;
        NumObjectTypesTemp = *lpNumObjectTypes;

        // Collect NBT data
        Status = CollectNbtPerformanceData (lpValueName,
                                            (LPVOID *) &lpDataTemp,
                                            (LPDWORD) &SpaceNeeded,
                                            (LPDWORD) &NumObjectTypesTemp) ;
        if (Status != ERROR_SUCCESS)  {
            // NBT Collection routine logs error messages to user
            REPORT_ERROR_DATA (TCP_NBT_COLLECT_DATA, LOG_DEBUG,
            &Status, sizeof (Status));
            *lpcbTotalBytes = 0L;
            *lpNumObjectTypes = 0L;
            return Status;
        }
    } else {
        // Initialize the parameters. We'll use these local
        // parameters for remaining routines if NBT didn't use them
        lpDataTemp = *lppData;
        SpaceNeeded = 0;
        NumObjectTypesTemp = 0;
    }

    /* To collect data for the Network Interfaces, and IP, ICMP, TCP and UDP
    protocols for a remote machine whose name is in the Unicode string pointed
    to by the lpValueName argument of CollectTcpIpData() routine, modify the
    routine as follows:

    1. Remove all the Nbt stuff from the code.

    2. Convert the remote machine name from Unicode to Ansi, and have a local
    LPSTR variable pointing to the Ansi remote machine name.

    3. Place the above portion of the code named A after this comment.

    4. Place the code named B (which is at the end of the file) at the end
    of this routine to close the opened SNMP session.

    */

    // get network info from SNMP agent

    if ((dwCounterFlags & SNMP_OBJECTS) > 0) { // if any SNMP Objects selected
        if (TRUE) { // and not a skeleton request
#ifdef USE_SNMP
            if ( TcpIpSession == (LPSNMP_MGR_SESSION) NULL ) {
                REPORT_WARNING (TCP_NULL_SESSION, LOG_DEBUG);
                *lppData = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }
#else
            if (!TcpIpSession) {
                REPORT_WARNING (TCP_NULL_SESSION, LOG_DEBUG);
                *lppData = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }
#endif
            // Get the data for the IP, ICMP, TCP and UDP protocols, as well as
            // the number of existing network interfaces.

            // create local query list

            HEAP_PROBE();

#ifdef USE_IPHLPAPI
            Status = GetNumberOfInterfaces(&IfNum);
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn, sizeof(dwDataReturn));
                *lppData          = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes   = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            Status = GetIpStatistics(&IpStats);
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn, sizeof(dwDataReturn));
                *lppData          = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes   = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            Status = GetTcpStatistics(&TcpStats);
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn, sizeof(dwDataReturn));
                *lppData          = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes   = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            Status = GetUdpStatistics(&UdpStats);
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn, sizeof(dwDataReturn));
                *lppData          = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes   = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            Status = GetIcmpStatistics(&IcmpStats);
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_ICMP_REQUEST, LOG_DEBUG,
                &dwDataReturn, sizeof(dwDataReturn));
                *lppData          = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes   = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            HEAP_PROBE();
        } // endif (TRUE)
#else
#ifdef USE_SNMP
            SnmpUtilVarBindListCpy (&VariableBindings,
                &RefVariableBindings);
#else

            for (i = 0; i < NO_OF_OIDS; i++) {
                SnmpUtilOidCpy (&(RefVariableBindingsArray[i].name),
                                &(RefNames[i]));
            }

            VariableBindings.list = RtlAllocateHeap (
                RtlProcessHeap(),
                0L,
                (RefVariableBindings.len * sizeof(RFC1157VarBind)));

            if (!VariableBindings.list) {
                REPORT_ERROR (TCP_SNMP_BUFFER_ALLOC_FAIL, LOG_DEBUG);
                *lppData = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            } else {
                RtlMoveMemory (
                    VariableBindings.list,
                    RefVariableBindings.list,
                    (RefVariableBindings.len * sizeof(RFC1157VarBind)));
                VariableBindings.len = RefVariableBindings.len;
            }
#endif

            HEAP_PROBE();

#ifdef USE_SNMP
            bStatus = SnmpMgrRequest (TcpIpSession,
                                ASN_RFC1157_GETREQUEST,
                                &VariableBindings,
                                &ErrorStatus,
                                &ErrorIndex);
#else
            bStatus = (*pSnmpExtensionQuery) (ASN_RFC1157_GETREQUEST,
                                &VariableBindings,
                                &ErrorStatus,
                                &ErrorIndex);
#endif
            if ( !bStatus ) {
                dwDataReturn[0] = ErrorStatus;
                dwDataReturn[1] = ErrorIndex;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn, sizeof(dwDataReturn));
                *lppData = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                SnmpUtilVarBindListFree (&VariableBindings);
                return ERROR_SUCCESS;
            }


            if ( ErrorStatus > 0 ) {
                dwDataReturn[0] = ErrorStatus;
                dwDataReturn[1] = ErrorIndex;
                REPORT_ERROR_DATA (TCP_SNMP_MGR_REQUEST, LOG_DEBUG,
                &dwDataReturn, sizeof(dwDataReturn));
                *lppData = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                SnmpUtilVarBindListFree (&VariableBindings);
                return ERROR_SUCCESS;
            }

            HEAP_PROBE();

#ifdef USE_SNMP
            SnmpUtilVarBindListCpy (&VariableBindingsICMP,
                &RefVariableBindingsICMP);
#else
            VariableBindingsICMP.list = RtlAllocateHeap (
                RtlProcessHeap(),
                0L,
                (RefVariableBindingsICMP.len * sizeof(RFC1157VarBind)));

            if (!VariableBindingsICMP.list) {
                REPORT_ERROR (TCP_SNMP_BUFFER_ALLOC_FAIL, LOG_DEBUG);
                *lppData = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded;
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            } else {
                RtlMoveMemory (
                    VariableBindingsICMP.list,
                    RefVariableBindingsICMP.list,
                    (RefVariableBindingsICMP.len * sizeof(RFC1157VarBind)));
                VariableBindingsICMP.len = RefVariableBindingsICMP.len;
            }
#endif

            HEAP_PROBE();

#ifdef USE_SNMP
            bStatus = SnmpMgrRequest (TcpIpSession,
                                ASN_RFC1157_GETREQUEST,
                                &VariableBindingsICMP,
                                &ErrorStatus,

#else
            bStatus = (*pSnmpExtensionQuery) (ASN_RFC1157_GETREQUEST,
                                &VariableBindingsICMP,
                                &ErrorStatus,
                                &ErrorIndex);
#endif

            if ( !bStatus ) {
                dwDataReturn[0] = ErrorStatus;
                dwDataReturn[1] = ErrorIndex;
                REPORT_ERROR_DATA (TCP_ICMP_REQUEST, LOG_DEBUG,
                &dwDataReturn, sizeof(dwDataReturn));
                *lppData = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;

                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);

                return ERROR_SUCCESS;
            }
            if ( ErrorStatus > 0 ) {
                dwDataReturn[0] = ErrorStatus;
                dwDataReturn[1] = ErrorIndex;
                REPORT_ERROR_DATA (TCP_ICMP_REQUEST, LOG_DEBUG,
                &dwDataReturn, sizeof(dwDataReturn));
                *lppData = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;

                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);

                return ERROR_SUCCESS;
            }
        } // endif (TRUE)

        HEAP_PROBE();

        // make sure everything made it back OK

        if (VariableBindingsICMP.list == 0) {
            REPORT_WARNING (TCP_NULL_ICMP_BUFF, LOG_DEBUG);
            dwCounterFlags |= (SNMP_ERROR); // return null data
        }

        if (VariableBindings.list == 0) {
            REPORT_WARNING (TCP_NULL_TCP_BUFF, LOG_DEBUG);
            dwCounterFlags |= (SNMP_ERROR); // return null data
            dwCounterFlags &= ~NET_OBJECT; // don't do NET Interface ctrs.
        }
#endif

        if (DO_COUNTER_OBJECT(dwCounterFlags, SNMP_ERROR)) {
            REPORT_WARNING (TCP_NULL_SNMP_BUFF, LOG_USER);
        }

        if (DO_COUNTER_OBJECT (dwCounterFlags, NET_OBJECT)) {

            SpaceNeeded += sizeof (NET_INTERFACE_DATA_DEFINITION);
            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn, sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);
#endif
                return ERROR_MORE_DATA;
            }

            pNetInterfaceDataDefinition =
                (NET_INTERFACE_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pNetInterfaceDataDefinition,
                    &NetInterfaceDataDefinition,
                    sizeof (NET_INTERFACE_DATA_DEFINITION));

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                        (pNetInterfaceDataDefinition + 1);
#ifdef USE_IPHLPAPI
            NetInterfaces = IfNum;
#else
            NetInterfaces =
                VariableBindings.list[IF_NUMBER_INDEX].value.asnValue.number;
#endif

            REPORT_INFORMATION_DATA (TCP_NET_INTERFACE, LOG_VERBOSE,
                &NetInterfaces, sizeof(NetInterfaces));

            if ( NetInterfaces ) {

                // Initialize the Variable Binding list for the
                // Network Interface Performance Data

#ifndef USE_IPHLPAPI
                HEAP_PROBE();
#ifdef USE_SNMP
                SnmpUtilVarBindListCpy (&IFVariableBindings,
                    &RefIFVariableBindings);
#else

                SnmpUtilVarBindListCpy (&IFVariableBindingsCall,
                    &RefIFVariableBindings);

                IFVariableBindings.list = RtlAllocateHeap (
                    RtlProcessHeap(),
                    0L,
                    (RefIFVariableBindings.len * sizeof(RFC1157VarBind)));

                if (!IFVariableBindings.list) {
                    REPORT_ERROR (TCP_SNMP_BUFFER_ALLOC_FAIL, LOG_DEBUG);
                    *lppData = ALIGN_ON_QWORD(lpDataTemp);
                    *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
                    *lpNumObjectTypes = NumObjectTypesTemp;
                    return ERROR_SUCCESS;
                } else {
                    RtlMoveMemory (
                        IFVariableBindings.list,
                        IFVariableBindingsCall.list,
                        (IFVariableBindingsCall.len * sizeof(RFC1157VarBind)));
                    IFVariableBindings.len = RefIFVariableBindings.len;
                }
#endif
#endif
                HEAP_PROBE();

                // Initialize buffer for the network interfaces' names

                AnsiInterfaceName.Length =
                AnsiInterfaceName.MaximumLength = MAX_INTERFACE_LEN + 1;
                AnsiInterfaceName.Buffer = AnsiInterfaceNameBuffer;

            }

#ifdef USE_IPHLPAPI

            Status = GetNumberOfInterfaces(&NetInterfaces);
            if ((Status != ERROR_SUCCESS) || (NetInterfaces < DEFAULT_INTERFACES)) {
                NetInterfaces = DEFAULT_INTERFACES;
            }
            IfTableSize = SIZEOF_IFTABLE(NetInterfaces);
            Status = ERROR_INSUFFICIENT_BUFFER;
            SentTemp = 0;
            IfTable = NULL;
            while ((Status == ERROR_INSUFFICIENT_BUFFER) &&
                   (SentTemp++ < 10)) {
                if (IfTable) {
                    HeapFree(RtlProcessHeap(), 0L, IfTable);
                }
                IfTable = (PMIB_IFTABLE) RtlAllocateHeap(
                        RtlProcessHeap(), 0L, IfTableSize);
                if (!IfTable)
                {
                    REPORT_ERROR (TCP_SNMP_BUFFER_ALLOC_FAIL, LOG_DEBUG);
                    *lppData = ALIGN_ON_QWORD(lpDataTemp);
                    *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
                    *lpNumObjectTypes = NumObjectTypesTemp;
                    return ERROR_SUCCESS;
                }
                Status = GetIfTable(IfTable, & IfTableSize, FALSE);
            }
            if (Status)
            {
                dwDataReturn[0] = Status;
                dwDataReturn[1] = 0;
                REPORT_ERROR_DATA (TCP_NET_GETNEXT_REQUEST, LOG_DEBUG,
                &dwDataReturn, sizeof(dwDataReturn));
#ifdef USE_IPHLPAPI
                if (IfTable) {
                    RtlFreeHeap(RtlProcessHeap(), 0L, IfTable);
                    IfTable = NULL;
                }
#endif
                *lppData          = ALIGN_ON_QWORD(lpDataTemp);
                *lpcbTotalBytes   = QWORD_MULTIPLE(SpaceNeeded);
                *lpNumObjectTypes = NumObjectTypesTemp;
                return ERROR_SUCCESS;
            }

            NetInterfaces = IfTable->dwNumEntries;
#endif
            // Loop for every network interface

            for ( Interface = 0; Interface < NetInterfaces; Interface++ )  {

                // Get the data for the network interface
                HEAP_PROBE();
#ifndef USE_IPHLPAPI
#ifdef USE_SNMP
                bStatus = SnmpMgrRequest ( TcpIpSession,
                                    ASN_RFC1157_GETNEXTREQUEST,
                                    &IFVariableBindings,
                                    &ErrorStatus,
                                    &ErrorIndex);
#else
                bStatus = (*pSnmpExtensionQuery) (ASN_RFC1157_GETNEXTREQUEST,
                                    &IFVariableBindings,
                                    &ErrorStatus,
                                    &ErrorIndex);
#endif
                HEAP_PROBE();

                if ( ! bStatus ) {
                            continue;
                }

                if ( ErrorStatus > 0 ) {
                    dwDataReturn[0] = ErrorStatus;
                    dwDataReturn[1] = ErrorIndex;
                    REPORT_ERROR_DATA (TCP_NET_GETNEXT_REQUEST, LOG_DEBUG,
                    &dwDataReturn, sizeof(dwDataReturn));
                    continue;
                }
#endif

                bFreeName = FALSE;
                // Everything is fine, so go get the data (prepare a new instance)
#ifdef USE_IPHLPAPI
                RtlInitAnsiString(&AnsiInterfaceName, IfTable->table[Interface].bDescr);
#else
                AnsiInterfaceName.Length = (USHORT)sprintf (AnsiInterfaceNameBuffer,
                        "%ld",
                        IFVariableBindings.list[IF_INDEX_INDEX].value.asnValue.number);
#endif

                if (AnsiInterfaceName.Length <= MAX_INTERFACE_LEN) {
                    RtlInitUnicodeString(&InterfaceName, NULL);
                    RtlAnsiStringToUnicodeString(
                        &InterfaceName,
                        &AnsiInterfaceName,
                        TRUE);
                    bFreeName = TRUE;
                }
                else {
                    InterfaceName.Length =
                    InterfaceName.MaximumLength = (MAX_INTERFACE_LEN + 1) * sizeof (WCHAR);
                    InterfaceName.Buffer = InterfaceNameBuffer;

                    RtlAnsiStringToUnicodeString (&InterfaceName,
                                                   &AnsiInterfaceName,
                                                   FALSE);
                }
                SpaceNeeded += sizeof (PERF_INSTANCE_DEFINITION) +
                    QWORD_MULTIPLE(InterfaceName.Length+sizeof(UNICODE_NULL)) +
                    dwBlockSize;

                if ( *lpcbTotalBytes < SpaceNeeded ) {
                    dwDataReturn[0] = *lpcbTotalBytes;
                    dwDataReturn[1] = SpaceNeeded;
                    REPORT_WARNING_DATA (TCP_NET_BUFFER_SIZE, LOG_DEBUG,
                        &dwDataReturn, sizeof(dwDataReturn));
                    //
                    //  if the buffer size is too small here, throw everything
                    //  away (including the NBT stuff) and return buffer size
                    //  error. If all goes well the caller will call back shortly
                    //  with a larger buffer and everything will be re-collected.
                    //
                    *lpcbTotalBytes = 0;
                    *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                    SnmpUtilVarBindListFree (&IFVariableBindings);
                    SnmpUtilVarBindListFree (&VariableBindings);
                    SnmpUtilVarBindListFree (&VariableBindingsICMP);
#else
                    if (IfTable) {
                        RtlFreeHeap(RtlProcessHeap(), 0L, IfTable);
                        IfTable = NULL;
                    }
#endif

                    return ERROR_MORE_DATA;
                }

                if (bUseFriendlyNames) {
                    // replace any reserved characters in the instance name with safe ones
                    for (dwThisChar = 0; dwThisChar <= (InterfaceName.Length / sizeof (WCHAR)); dwThisChar++) {
                        switch (InterfaceName.Buffer[dwThisChar]) {
                            case L'(': InterfaceName.Buffer[dwThisChar] = L'['; break;
                            case L')': InterfaceName.Buffer[dwThisChar] = L']'; break;
                            case L'#': InterfaceName.Buffer[dwThisChar] = L'_'; break;
                            case L'/': InterfaceName.Buffer[dwThisChar] = L'_'; break;
                            case L'\\': InterfaceName.Buffer[dwThisChar] = L'_'; break;
                            default: break;
                        }
                    }
                }


                MonBuildInstanceDefinition (pPerfInstanceDefinition,
                                            (PVOID *) &pPerfCounterBlock,
                                            0,
                                            0,
                                            (bUseFriendlyNames ? (DWORD)PERF_NO_UNIQUE_ID : (DWORD)(Interface + 1)),
                                            &InterfaceName);

                if (bFreeName) {
                    RtlFreeUnicodeString(&InterfaceName);
                }
                pPerfCounterBlock->ByteLength = dwBlockSize;

                pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
                Assign64( IfTable->table[Interface].dwInOctets
                            + IfTable->table[Interface].dwOutOctets,
                          (PLARGE_INTEGER) pdwCounter);
    
                REPORT_INFORMATION (TCP_COPYING_DATA, LOG_VERBOSE);

                pdwPackets = pdwCounter + 2;

                pdwCounter += 4; // skip packet counters first

                *++pdwCounter = IfTable->table[Interface].dwSpeed;
                *++pdwCounter = IfTable->table[Interface].dwInOctets;

                ReceivedTemp = *++pdwCounter = IfTable->table[Interface].dwInUcastPkts;
                ReceivedTemp += *++pdwCounter = IfTable->table[Interface].dwInNUcastPkts;
                ReceivedTemp += *++pdwCounter = IfTable->table[Interface].dwInDiscards;
                ReceivedTemp += *++pdwCounter = IfTable->table[Interface].dwInErrors;
                ReceivedTemp += *++pdwCounter = IfTable->table[Interface].dwInUnknownProtos;
                *++pdwCounter = IfTable->table[Interface].dwOutOctets;
                SentTemp = *++pdwCounter = IfTable->table[Interface].dwOutUcastPkts;
                SentTemp += *++pdwCounter = IfTable->table[Interface].dwOutNUcastPkts;
                *++pdwCounter = IfTable->table[Interface].dwOutDiscards;
                *++pdwCounter = IfTable->table[Interface].dwOutErrors;
                *++pdwCounter = IfTable->table[Interface].dwOutQLen;
#else
                Assign64( IF_COUNTER(IF_INOCTETS_INDEX) +
                                        IF_COUNTER(IF_OUTOCTETS_INDEX,
                          (PLARGE_INTEGER) pdwCounter);

                REPORT_INFORMATION (TCP_COPYING_DATA, LOG_VERBOSE);

                pdwPackets = pdwCounter + 2;
                pdwCounter += 4;    // skip packet counters first
                //
                // NOTE: We are skipping 2 words for Total bytes,
                // and one each for total packets, in packets & out packets
                //

                *++pdwCounter = IF_GAUGE(IF_SPEED_INDEX);
                *++pdwCounter = IF_COUNTER(IF_INOCTETS_INDEX);

                ReceivedTemp = *++pdwCounter = IF_COUNTER(IF_INUCASTPKTS_INDEX);
                ReceivedTemp += *++pdwCounter = IF_COUNTER(IF_INNUCASTPKTS_INDEX);
                ReceivedTemp += *++pdwCounter = IF_COUNTER(IF_INDISCARDS_INDEX);
                ReceivedTemp += *++pdwCounter = IF_COUNTER(IF_INERRORS_INDEX);
                ReceivedTemp += *++pdwCounter = IF_COUNTER(IF_INUNKNOWNPROTOS_INDEX);
                *++pdwCounter = IF_COUNTER(IF_OUTOCTETS_INDEX);

                SentTemp = *pdwCounter = IF_COUNTER(IF_OUTUCASTPKTS_INDEX);
                SentTemp += *++pdwCounter = IF_COUNTER(IF_OUTNUCASTPKTS_INDEX);
                *++pdwCounter = IF_COUNTER(IF_OUTDISCARDS_INDEX);
                *++pdwCounter = IF_COUNTER(IF_OUTERRORS_INDEX);
                *++pdwCounter = IF_COUNTER(IF_OUTQLEN_INDEX);
#endif
                *pdwPackets = ReceivedTemp + SentTemp;
                *++pdwPackets = ReceivedTemp;
                *++pdwPackets = SentTemp;

                pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                        (((PBYTE) pPerfCounterBlock) + dwBlockSize);

#ifndef USE_IPHLPAPI
#if USE_SNMP
                // Prepare to get the data for the next network interface

                if ( Interface < NetInterfaces ) {

                        for ( i = 0; i < NO_OF_IF_OIDS; i++ ) {

//                        SnmpUtilOidFree (&IFVariableBindingsArray[i].name);

                        SnmpUtilOidCpy (&IFVariableBindingsArray[i].name,
                                &IFVariableBindings.list[i].name);
                        }
                }

                SnmpUtilVarBindListFree (&IFVariableBindings);

                IFVariableBindings.list = IFVariableBindingsArray;
                IFVariableBindings.len  = NO_OF_IF_OIDS;
#else
                if ( Interface < NetInterfaces ) {

                    // since SnmpExtesionQuery returned newly allocated
                    // OID buffers, we need to:
                    //  1. free the original OID Buffers
                    //  2. copy the new into the old
                    //  3. free the returned buffers (OID's and data)
                    //  4. realloc a clean "new" buffer and
                    //  5. copy the new OIDS (with empty data) into
                    //      new buffer

                    for ( i = 0; i < NO_OF_IF_OIDS; i++ ) {

//                        SnmpUtilOidFree (&IFVariableBindingsCall.list[i].name);

                        SnmpUtilOidCpy (&IFVariableBindingsCall.list[i].name,
                                &IFVariableBindings.list[i].name);

                    }
                    SnmpUtilVarBindListFree (&IFVariableBindings);

                    IFVariableBindings.list = RtlAllocateHeap (
                        RtlProcessHeap(),
                        0L,
                        (RefIFVariableBindings.len * sizeof(RFC1157VarBind)));

                    if (!VariableBindings.list) {
                        REPORT_ERROR (TCP_SNMP_BUFFER_ALLOC_FAIL, LOG_DEBUG);
                        *lppData = lpDataTemp;
                        *lpcbTotalBytes = SpaceNeeded;
                        *lpNumObjectTypes = NumObjectTypesTemp;
#ifdef USE_IPHLPAPI
                        if (IfTable) {
                            RtlFreeHeap(RtlProcessHeap(), 0L, IfTable);
                            IfTable = NULL;
                        }
#endif
                        return ERROR_SUCCESS;
                    } else {
                        RtlMoveMemory (
                            IFVariableBindings.list,
                            IFVariableBindingsCall.list,
                            (IFVariableBindingsCall.len * sizeof(RFC1157VarBind)));
                        IFVariableBindings.len = RefIFVariableBindings.len;
                    }
                }

#endif
#endif
                HEAP_PROBE();
            }

            pNetInterfaceDataDefinition->NetInterfaceObjectType.TotalByteLength =
                        (DWORD)((PBYTE) pPerfInstanceDefinition - (PBYTE) pNetInterfaceDataDefinition);

            pNetInterfaceDataDefinition->NetInterfaceObjectType.NumInstances =
                        NetInterfaces;

            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)pPerfInstanceDefinition;
            // SpaceNeeded is kept up already

            HEAP_PROBE();

            if ( NetInterfaces ) {
#ifndef USE_IPHLPAPI
               SnmpUtilVarBindListFree (&IFVariableBindings);
//            SnmpUtilVarBindListFree (&IFVariableBindingsCall);
               RtlFreeHeap (RtlProcessHeap(), 0L, IFVariableBindingsCall.list);
#endif
            }

            HEAP_PROBE();

        } // end if Net Counters

        // Get IP data

#ifdef USE_IPHLPAPI
        if (IfTable) {
            RtlFreeHeap(RtlProcessHeap(), 0L, IfTable);
            IfTable = NULL;
        }
#endif

        HEAP_PROBE();

        if (DO_COUNTER_OBJECT (dwCounterFlags, IP_OBJECT)) {

            SpaceNeeded +=  (sizeof(IP_DATA_DEFINITION)   + SIZE_OF_IP_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn, sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);
#endif
                return ERROR_MORE_DATA;
            }

            pIpDataDefinition = (IP_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pIpDataDefinition,
                &IpDataDefinition,
                sizeof (IP_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pIpDataDefinition + 1);
            pPerfCounterBlock->ByteLength = SIZE_OF_IP_DATA;

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
            *pdwCounter   = IpStats.dwInReceives + IpStats.dwOutRequests;
            *++pdwCounter = IpStats.dwInReceives;
            *++pdwCounter = IpStats.dwInHdrErrors;
            *++pdwCounter = IpStats.dwInAddrErrors;
            *++pdwCounter = IpStats.dwForwDatagrams;
            *++pdwCounter = IpStats.dwInUnknownProtos;
            *++pdwCounter = IpStats.dwInDiscards;
            *++pdwCounter = IpStats.dwInDelivers;
            *++pdwCounter = IpStats.dwOutRequests;
            *++pdwCounter = IpStats.dwOutDiscards;
            *++pdwCounter = IpStats.dwOutNoRoutes;
            *++pdwCounter = IpStats.dwReasmReqds;
            *++pdwCounter = IpStats.dwReasmOks;
            *++pdwCounter = IpStats.dwReasmFails;
            *++pdwCounter = IpStats.dwFragOks;
            *++pdwCounter = IpStats.dwFragFails;
            *++pdwCounter = IpStats.dwFragCreates;
#else
            *pdwCounter = IP_COUNTER(IP_INRECEIVES_INDEX) +
                            IP_COUNTER(IP_OUTREQUESTS_INDEX);

            *++pdwCounter = IP_COUNTER(IP_INRECEIVES_INDEX);
            *++pdwCounter = IP_COUNTER(IP_INHDRERRORS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_INADDRERRORS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_FORWDATAGRAMS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_INUNKNOWNPROTOS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_INDISCARDS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_INDELIVERS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_OUTREQUESTS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_OUTDISCARDS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_OUTNOROUTES_INDEX);
            *++pdwCounter = IP_COUNTER(IP_REASMREQDS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_REASMOKS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_REASMFAILS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_FRAGOKS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_FRAGFAILS_INDEX);
            *++pdwCounter = IP_COUNTER(IP_FRAGCREATES_INDEX);
#endif
            // setup counters and pointers for  next counter

            NumObjectTypesTemp +=1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

        HEAP_PROBE();

        // Get ICMP data

        if (DO_COUNTER_OBJECT (dwCounterFlags, ICMP_OBJECT)) {
            // The data for the network interfaces are now ready. So, let's get
            // the data for the IP, ICMP, TCP and UDP protocols.

            SpaceNeeded +=  (sizeof(ICMP_DATA_DEFINITION)  + SIZE_OF_ICMP_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn, sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
                SnmpUtilVarBindListFree (&VariableBindingsICMP);
#endif
                return ERROR_MORE_DATA;
            }

            pIcmpDataDefinition = (ICMP_DATA_DEFINITION *) lpDataTemp;;

            RtlMoveMemory (pIcmpDataDefinition,
                &IcmpDataDefinition,
                sizeof (ICMP_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pIcmpDataDefinition + 1);
            pPerfCounterBlock->ByteLength = SIZE_OF_ICMP_DATA;

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
            *pdwCounter   = IcmpStats.stats.icmpInStats.dwMsgs
                          + IcmpStats.stats.icmpOutStats.dwMsgs;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwMsgs;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwErrors;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwDestUnreachs;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwTimeExcds;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwParmProbs;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwSrcQuenchs;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwRedirects;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwEchos;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwEchoReps;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwTimestamps;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwTimestampReps;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwAddrMasks;
            *++pdwCounter = IcmpStats.stats.icmpInStats.dwAddrMaskReps;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwMsgs;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwErrors;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwDestUnreachs;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwTimeExcds;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwParmProbs;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwSrcQuenchs;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwRedirects;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwEchos;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwEchoReps;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwTimestamps;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwTimestampReps;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwAddrMasks;
            *++pdwCounter = IcmpStats.stats.icmpOutStats.dwAddrMaskReps;
#else
            *pdwCounter = ICMP_COUNTER(ICMP_INMSGS_INDEX) +
                    ICMP_COUNTER(ICMP_OUTMSGS_INDEX);

            *++pdwCounter = ICMP_COUNTER(ICMP_INMSGS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INERRORS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INDESTUNREACHS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INTIMEEXCDS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INPARMPROBS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INSRCQUENCHS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INREDIRECTS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INECHOS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INECHOREPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INTIMESTAMPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INTIMESTAMPREPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INADDRMASKS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_INADDRMASKREPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTMSGS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTERRORS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTDESTUNREACHS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTTIMEEXCDS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTPARMPROBS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTSRCQUENCHS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTREDIRECTS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTECHOS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTECHOREPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTTIMESTAMPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTTIMESTAMPREPS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTADDRMASKS_INDEX);
            *++pdwCounter = ICMP_COUNTER(ICMP_OUTADDRMASKREPS_INDEX);
#endif

            HEAP_PROBE();

//            SnmpUtilVarBindListFree (&VariableBindingsICMP);

            HEAP_PROBE();

            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }
#ifndef USE_IPHLPAPI
        SnmpUtilVarBindListFree (&VariableBindingsICMP);
#endif

        HEAP_PROBE();

        // Get TCP data

        if (DO_COUNTER_OBJECT (dwCounterFlags, TCP_OBJECT)) {

            // The data for the network interfaces are now ready. So, let's get
            // the data for the IP, ICMP, TCP and UDP protocols.

            SpaceNeeded += (sizeof(TCP_DATA_DEFINITION)  + SIZE_OF_TCP_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn, sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
#endif
                return ERROR_MORE_DATA;
            }

            pTcpDataDefinition = (TCP_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pTcpDataDefinition,
                &TcpDataDefinition,
                sizeof (TCP_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pTcpDataDefinition + 1);
            pPerfCounterBlock->ByteLength = SIZE_OF_TCP_DATA;

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
            *pdwCounter   = TcpStats.dwInSegs + TcpStats.dwOutSegs;
            *++pdwCounter = TcpStats.dwCurrEstab;
            *++pdwCounter = TcpStats.dwActiveOpens;
            *++pdwCounter = TcpStats.dwPassiveOpens;
            *++pdwCounter = TcpStats.dwAttemptFails;
            *++pdwCounter = TcpStats.dwEstabResets;
            *++pdwCounter = TcpStats.dwInSegs;
            *++pdwCounter = TcpStats.dwOutSegs;
            *++pdwCounter = TcpStats.dwRetransSegs;
#else
            *pdwCounter = TCP_COUNTER(TCP_INSEGS_INDEX) +
                    TCP_COUNTER(TCP_OUTSEGS_INDEX);

            *++pdwCounter = TCP_GAUGE(TCP_CURRESTAB_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_ACTIVEOPENS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_PASSIVEOPENS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_ATTEMPTFAILS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_ESTABRESETS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_INSEGS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_OUTSEGS_INDEX);
            *++pdwCounter = TCP_COUNTER(TCP_RETRANSSEGS_INDEX);
#endif
            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

        HEAP_PROBE();

        // Get UDP data

        if (DO_COUNTER_OBJECT (dwCounterFlags, UDP_OBJECT)) {

            // The data for the network interfaces are now ready. So, let's get
            // the data for the IP, ICMP, TCP and UDP protocols.

            SpaceNeeded += (sizeof(UDP_DATA_DEFINITION)   + SIZE_OF_UDP_DATA);

            if ( *lpcbTotalBytes < SpaceNeeded ) {
                dwDataReturn[0] = *lpcbTotalBytes;
                dwDataReturn[1] = SpaceNeeded;
                REPORT_WARNING_DATA (TCP_NET_IF_BUFFER_SIZE, LOG_DEBUG,
                    &dwDataReturn, sizeof(dwDataReturn));
                //
                //  if the buffer size is too small here, throw everything
                //  away (including the NBT stuff) and return buffer size
                //  error. If all goes well the caller will call back shortly
                //  with a larger buffer and everything will be re-collected.
                //
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;

#ifndef USE_IPHLPAPI
                SnmpUtilVarBindListFree (&VariableBindings);
#endif
                return ERROR_MORE_DATA;
            }

            pUdpDataDefinition = (UDP_DATA_DEFINITION *) lpDataTemp;

            RtlMoveMemory (pUdpDataDefinition,
                &UdpDataDefinition,
                sizeof (UDP_DATA_DEFINITION));

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) (pUdpDataDefinition + 1);
            pPerfCounterBlock->ByteLength = SIZE_OF_UDP_DATA;

            pdwCounter = (PDWORD) (pPerfCounterBlock + 1);

#ifdef USE_IPHLPAPI
            *pdwCounter   = UdpStats.dwInDatagrams + UdpStats.dwOutDatagrams;
            *++pdwCounter = UdpStats.dwInDatagrams;
            *++pdwCounter = UdpStats.dwNoPorts;
            *++pdwCounter = UdpStats.dwInErrors;
            *++pdwCounter = UdpStats.dwOutDatagrams;
#else
            *pdwCounter = UDP_COUNTER(UDP_INDATAGRAMS_INDEX) +
                    UDP_COUNTER(UDP_OUTDATAGRAMS_INDEX);

            *++pdwCounter = UDP_COUNTER(UDP_INDATAGRAMS_INDEX);
            *++pdwCounter = UDP_COUNTER(UDP_NOPORTS_INDEX);
            *++pdwCounter = UDP_COUNTER(UDP_INERRORS_INDEX);
            *++pdwCounter = UDP_COUNTER(UDP_OUTDATAGRAMS_INDEX);
#endif
            // setup counters and pointers for  next counter

            NumObjectTypesTemp += 1;
            lpDataTemp = (LPVOID)++pdwCounter;
            // SpaceNeeded is kept up already

        }

#ifndef USE_IPHLPAPI
#ifdef USE_SNMP

        // Get prepared for the next data collection

        VariableBindings.list       = VariableBindingsArray + OIDS_OFFSET;
        VariableBindings.len        = OIDS_LENGTH;
        VariableBindingsICMP.list   = VariableBindingsArray + ICMP_OIDS_OFFSET;
        VariableBindingsICMP.len    = ICMP_OIDS_LENGTH;

#else
        HEAP_PROBE();

        SnmpUtilVarBindListFree (&VariableBindings);

        HEAP_PROBE();

#endif
#endif
    } // endif SNMP Objects

    // Set the returned values

    *lppData = ALIGN_ON_QWORD((LPVOID) lpDataTemp);
    *lpcbTotalBytes = QWORD_MULTIPLE(SpaceNeeded);
    *lpNumObjectTypes = NumObjectTypesTemp;

    HEAP_PROBE();

    REPORT_SUCCESS (TCP_COLLECT_DATA, LOG_DEBUG);
    return ERROR_SUCCESS;
} // CollectTcpIpPerformanceData
#pragma warning ( default : 4127)

DWORD
CloseTcpIpPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to TCP/IP devices.

Arguments:

    None.


Return Value:

    Win32 Status.

--*/

{
#ifndef USE_IPHLPAPI
    int i;
#endif

    REPORT_INFORMATION (TCP_ENTERING_CLOSE, LOG_VERBOSE);

    if (dwTcpRefCount > 0) {
        dwTcpRefCount--;
        if (dwTcpRefCount == 0) {
            // Close NBT
            CloseNbtPerformanceData ();


#ifdef USE_DSIS
            // Close DSIS
            CloseDsisPerformanceData ();
#endif // USE_DSIS

            /* This portion of the code for CloseTcpIpPerformanceData() could be used in
               the CollectTcpIpPerformanceData() routine to close an open SNMP Manager
               session.

               So, name this portion of the code: B

            */
#ifdef USE_SNMP
            if ( TcpIpSession != (LPSNMP_MGR_SESSION) NULL ) {
                if ( ! SnmpMgrClose (TcpIpSession) ) {
                    REPORT_ERROR_DATA (TCP_SNMP_MGR_CLOSE, LOG_DEBUG,
                        GetLastError (), sizeof(DWORD));
                }

                TcpIpSession = (LPSNMP_MGR_SESSION) NULL;
            } else {
                REPORT_WARNING (TCP_NULL_SESSION, LOG_DEBUG);
            }

            /* End of code B
             */
#endif

            HEAP_PROBE();

#ifndef USE_IPHLPAPI
            for (i = 0; i < NO_OF_OIDS; i++) {
                SnmpUtilOidFree ( &(RefNames[i]));
            }

            HEAP_PROBE();

            for (i = 0; i < NO_OF_IF_OIDS; i++) {
                SnmpUtilOidFree (&(IFPermVariableBindingsArray[i].name));
            }

            HEAP_PROBE();
#else
            if (IfTable) {
                RtlFreeHeap(RtlProcessHeap(), 0L, IfTable);
                IfTable = NULL;
            }
#endif

#if 0
            // this is closed by the INETMIB1 on process detach
            // so we don't need to do it here.

            // close event handle used by SNMP
            if (CloseHandle (hSnmpEvent)) {
                hSnmpEvent = NULL;
            }
#endif

#ifdef LOAD_INETMIB1

            FreeLibrary (hInetMibDll);

#endif
        }
    }

    MonCloseEventLog();

    return ERROR_SUCCESS;

}   // CloseTcpIpPerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\perfnbt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

      perfnbt.h  

Abstract:

   This file provides the function prototypes for the routines
   to open, collect and close Nbt Performance Data. It also
   provides the perfnbt.c module with some structure and
   constant definitions.

Author:

   Christos Tsollis 8/26/92  

Revision History:


--*/
#ifndef  _PERFNBT_H_
#define  _PERFNBT_H_

// 
//  Nbt structures and constants (many of them are really defined in 
//  <sys\snet\nbt_stat.h>
//

#define NBT_DEVICE 		"\\Device\\Streams\\nbt"
#define MAX_ENDPOINTS_PER_MSG	32   // max no. of ENDPOINT_INFOs per message
#define HOSTNAME_LENGTH		17
#define SCOPE_ID_LENGTH		240
#define NBT_ENDPOINT_INFO	NBT_XEBINFO


//
// Structures passed/returned in s_ioctl() command
//

typedef struct nbt_stat		NBT_STATUS;
typedef struct nbt_info		NBT_INFO; 


//
// Per Endpoint (Connection) Data
//

typedef struct xebinfo		ENDPOINT_INFO;

    
//
// Other structures
//

typedef struct strbuf		BUFFER_STRUCT;
typedef struct strioctl		IOCTL_STRUCT;

//
// Prototypes for the Nbt routines
//

extern DWORD OpenNbtPerformanceData ();
extern DWORD CollectNbtPerformanceData (LPWSTR, LPVOID *, LPDWORD, LPDWORD);
extern DWORD CloseNbtPerformanceData ();

#endif //_PERFNBT_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the routine that constructs the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h)
                 
Created:    

    Russ Blake  07/30/92

Revision History:

--*/
//
//  include files
//        
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "perfctr.h"   // error message definition
#include "perfmsg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

PRTL_HEAP_INFORMATION   pInfoBuffer = NULL;
ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string 

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < '0') ? INVALID : \
     (c > '9') ? INVALID : \
     DIGIT)

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    PUNICODE_STRING Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    WCHAR *pName;

    //
    //  Include trailing null in name size
    //

    NameLength = Name->Length;
    if ( !NameLength ||
         Name->Buffer[(NameLength/sizeof(WCHAR))-1] != UNICODE_NULL ) {
        NameLength += sizeof(WCHAR);
    }

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          QWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    pName = (PWCHAR)&pBuffer[1];
    RtlMoveMemory(pName,Name->Buffer,Name->Length);

    //  Always null terminated.  Space for this reserved above.

    pName[(NameLength/sizeof(WCHAR))-1] = UNICODE_NULL;

    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);
    return 0;
}


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = "EventLogLevel";

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;
   
    // if global value of the logging level not initialized or is disabled, 
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,                         
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,           
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }
       
    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }
    
    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller
      
Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog) {
        if (dwLogUsers)
            dwLogUsers--;
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
            hEventLog = 0;
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}

#pragma warning ( disable : 4127)
BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:
        
    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    
    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then 
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            
            case DELIMITER:
                // a delimter is either the delimiter character or the 
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
#pragma warning ( default : 4127)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
//    (assumes dword is 4 bytes)
#define ALIGN_ON_DWORD(x) ((LPVOID) (((DWORD_PTR)(x) + 3) & ~3))

#define DWORD_MULTIPLE(x) (((x) + 3) & ~3)

#define CLEAR_FIRST_FOUR_BYTES(x)     *(DWORD *)(x) = 0L

//    (assumes QuadWORD is 8 bytes)
#define ALIGN_ON_QWORD(x) ((LPVOID) (((DWORD_PTR)(x) + 7) & ~7))

#define QWORD_MULTIPLE(x) (((x) + 7) & ~7)

#define CLEAR_FIRST_EIGHT_BYTES(x)     *(LONGLONG *)(x) = 0L

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

BOOL MonBuildInstanceDefinition (PERF_INSTANCE_DEFINITION *, 
				 PVOID *,
				 DWORD,
				 DWORD,
				 DWORD,
				 PUNICODE_STRING);

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

//
//  Memory Probe macro (not implemented)
//
#define HEAP_PROBE()    ;

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\dataexpr.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataexpr.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Extended Process Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataexpr.h"

// dummy variable for field sizing.
static EXPROCESS_COUNTER_DATA   ecd;

//
//  Constant structure initializations 
//      defined in dataexpr.h
//

EXPROCESS_DATA_DEFINITION ExProcessDataDefinition = {
    {   0,
        sizeof (EXPROCESS_DATA_DEFINITION),
        sizeof (PERF_OBJECT_TYPE),
        EXPROCESS_OBJECT_TITLE_INDEX,
        0,
        787,
        0,
        PERF_DETAIL_WIZARD,
        (sizeof(EXPROCESS_DATA_DEFINITION) - sizeof (PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        784,
        0,
        785,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ProcessId),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ProcessId
    },              
    {   sizeof(PERF_COUNTER_DEFINITION),
        776,
        0,
        777,
        0,
        -4,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageReservedBytes),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageReservedBytes
    },              
    {   sizeof(PERF_COUNTER_DEFINITION),
        778,
        0,
        779,
        0,
        -4,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageFreeBytes),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageFreeBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        780,
        0,                                 
        781,
        0,
        -4,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedBytes),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        782,
        0,                               
        783,
        0,   
        -4,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.FreeBytes),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->FreeBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        710,
        0,                           
        711,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitNoAccess),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitNoAccess
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        712,
        0,
        713,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitReadOnly),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        714,
        0,
        715,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitReadWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        716,
        0,
        717,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        718,
        0,
        719,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitExecute),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitExecute
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        720,
        0,
        721,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitExecuteRead),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitExecuteRead
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        722,
        0,
        723,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitExecuteWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitExecuteWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        724,
        0,
        725,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.CommitExecuteWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->CommitExecuteWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        726,
        0,
        727,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedNoAccess),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedNoAccess
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        728,
        0,
        729,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedReadOnly),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        730,
        0,
        731,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedReadWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        732,
        0,
        733,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        734,
        0,
        735,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedExecute),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedExecute
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        736,
        0,
        737,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedExecuteRead),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedExecuteRead
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        738,
        0,
        739,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedExecuteWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedExecuteWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        742,
        0,
        743,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ReservedExecuteWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ReservedExecuteWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        744,
        0,
        745,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedNoAccess),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedNoAccess
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        746,
        0,
        747,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedReadOnly),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        748,
        0,
        749,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedReadWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        750,
        0,
        751,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        752,
        0,
        753,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedExecute),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedExecute
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        754,
        0,
        755,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedExecuteRead),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedExecuteRead
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        756,
        0,
        757,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedExecuteWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedExecuteWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        758,
        0,
        759,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.UnassignedExecuteWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->UnassignedExecuteWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        760,
        0,
        761,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalNoAccess),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalNoAccess
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        762,
        0,
        763,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalReadOnly),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        764,
        0,
        765,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalReadWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        766,
        0,
        767,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        768,
        0,
        769,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalExecute),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalExecute
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        770,
        0,
        771,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalExecuteRead),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalExecuteRead
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        772,
        0,
        773,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalExecuteWrite),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalExecuteWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        774,
        0,
        775,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (ecd.ImageTotalExecuteWriteCopy),
        (DWORD)(ULONG_PTR)&((PEXPROCESS_COUNTER_DATA)0)->ImageTotalExecuteWriteCopy
    }

};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\perfctrs\perfnbt.c ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfnbt.c

Abstract:

   This file implements the Extensible Objects for
   the LAN object types

Created:


Revision History:

--*/
//
// include files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>
#include <windows.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <winperf.h>
#include "perfctr.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "perfnbt.h"
#include "datanbt.h"

// New header file for getting nbt data
#pragma warning (disable : 4201)
#include <tdi.h>
#include <nbtioctl.h>
#pragma warning (default : 4201)

enum eSTATE
{
    NBT_RECONNECTING,      // waiting for the worker thread to run NbtConnect
    NBT_IDLE,              // not Transport connection
    NBT_ASSOCIATED,        // associated with an address element
    NBT_CONNECTING,        // establishing Transport connection
    NBT_SESSION_INBOUND,   // waiting for a session request after tcp connection setup inbound
    NBT_SESSION_WAITACCEPT, // waiting for accept after a listen has been satisfied
    NBT_SESSION_OUTBOUND,  // waiting for a session response after tcp connection setup
    NBT_SESSION_UP,        // got positive response
    NBT_DISCONNECTING,     // sent a disconnect down to Tcp, but it hasn't completed yet
    NBT_DISCONNECTED      // a session has been disconnected but not closed with TCP yet
};

//
//  References to constants which initialize the Object type definitions
//

extern NBT_DATA_DEFINITION NbtDataDefinition;

#define NBT_CONNECTION_NAME_LENGTH     17
#define NETBIOS_NAME_SIZE              NBT_CONNECTION_NAME_LENGTH-1

//
// Nbt data structures
//

typedef struct _NBT_DEVICE_DATA {
   HANDLE            hFileHandle;
   UNICODE_STRING    DeviceName;
} NBT_DEVICE_DATA, *PNBT_DEVICE_DATA;

PNBT_DEVICE_DATA     pNbtDeviceData;
int                  MaxNbtDeviceName;
int                  NumberOfNbtDevices;

// initial count - will update to last
PVOID                pNbtDataBuffer = NULL;
int                  NbtDataBufferSize;

DWORD               dwNbtRefCount = 0;

// HANDLE NbtHandle = INVALID_HANDLE_VALUE; // Handle of Nbt Device


#define NBT_CONTROLLING_STREAM   "CSB" // Ignore Controlling Stream XEB
#define NBT_LISTEN_CONNECTION    3     // All NBT connections with type <= 3,
                                       // are just listening for clients


// The error value returned by the perfctrs.dll when an error occurs while we
// are getting the data for the NBT connections.
// The error codes we get from the socket calls (OpenStream(), s_ioctl(),
// getmsg()) are Unix errors, not Dos or Windows errors. Hopefully, somebody
// will implement the conversion from these errors to Windows errors.
// The error value is not used within the Collect data routine because this
// routine shouldn't return an error in case it fails to collect Nbt data from
// connections. In this case, it just returns the buffer it was supposed to
// place the data into, unchanged.

#define ERROR_NBT_NET_RESPONSE   \
         (RtlNtStatusToDosError(STATUS_INVALID_NETWORK_RESPONSE))

#define     BUFF_SIZE   650

PM_OPEN_PROC    OpenNbtPerformanceData;
PM_COLLECT_PROC CollectNbtPerformanceData;
PM_CLOSE_PROC   CloseNbtPerformanceData;

//------------------------------------------------------------------------
NTSTATUS
OpenNbt(
    IN char                *path,
    OUT PHANDLE            pHandle,
    OUT UNICODE_STRING     *uc_name_string
)

/*++

Routine Description:

    This function opens a stream.

Arguments:

    path        - path to the STREAMS driver
    oflag       - currently ignored.  In the future, O_NONBLOCK will be
                    relevant.
    ignored     - not used

Return Value:

    An NT handle for the stream, or INVALID_HANDLE_VALUE if unsuccessful.

--*/

{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
//    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;

    RtlInitString(&name_string, path);
    RtlAnsiStringToUnicodeString(uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status =
    NtCreateFile(
        &StreamHandle,
        SYNCHRONIZE | FILE_READ_DATA ,
//        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        NULL,
        0);

//    RtlFreeUnicodeString(&uc_name_string);

    *pHandle = StreamHandle;

    return(status);

} // Open_nbt

NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS                        status;
    TDI_REQUEST_QUERY_INFORMATION   QueryInfo;
    IO_STATUS_BLOCK                 iosb;
    PVOID                           pInput;
    ULONG                           SizeInput;

    if (Ioctl == IOCTL_TDI_QUERY_INFORMATION)
    {
        pInput = &QueryInfo;
        QueryInfo.QueryType = TDI_QUERY_ADAPTER_STATUS; // node status or whatever
        SizeInput = sizeof(TDI_REQUEST_QUERY_INFORMATION);
    }
    else
    {
        pInput = NULL;
        SizeInput = 0;
    }

    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
    }

    return(status);

}  // DeviceIoCtrl


PCHAR
printable(
    IN PCHAR  string,
    IN PCHAR  StrOut
    )

/*++

Routine Description:

    This procedure converts non prinatble characaters to periods ('.')

Arguments:
    string - the string to convert
    StrOut - ptr to a string to put the converted string into

Return Value:

    a ptr to the string that was converted (Strout)

--*/
{
    PCHAR   Out;
    PCHAR   cp;
    LONG     i;

    Out = StrOut;
    for (cp = string, i= 0; i < NETBIOS_NAME_SIZE; cp++,i++) {
        if (isprint(*cp)) {
            *Out++ = *cp;
            continue;
        }

        if (*cp >= 128) { /* extended characters are ok */
            *Out++ = *cp;
            continue;
        }
        *Out++ = '.';
    }
    return(StrOut);
}  // printable



#pragma warning ( disable : 4127)
DWORD
OpenNbtPerformanceData (
   IN LPWSTR dwVoid            // not used by this routine
)

/*++


Routine Description:

    This routine will open the Nbt device and remember the handle returned
    by the device.


Arguments:

    None.


Return Value:

    ERROR_NBT_NET_RESPONSE  if unable to open NBT stream device

    ERROR_SUCCESS if open was successful

--*/
{
    PCHAR   SubKeyLinkage=(PCHAR)"system\\currentcontrolset\\services\\netbt\\linkage";
    PCHAR   Linkage=(PCHAR)"Export";
    CHAR    *pBuffer = NULL;
    CHAR    *lpLocalDeviceNames;
    LONG    status, status2;
    DWORD   Type;
    ULONG   size;
    HKEY    Key;
    HANDLE  hFileHandle;
    UNICODE_STRING   fileString;
    NTSTATUS ntstatus;
    PNBT_DEVICE_DATA   pTemp;

    UNREFERENCED_PARAMETER (dwVoid);

    MonOpenEventLog();

    REPORT_INFORMATION (NBT_OPEN_ENTERED, LOG_VERBOSE);

    if (InterlockedIncrement(&dwNbtRefCount) == 1) {

        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SubKeyLinkage,
                     0,
                     KEY_READ,
                     &Key);

        if (status == ERROR_SUCCESS) {
            // now read the linkage values
            size = 0;
            pBuffer = NULL;
            status2 = RegQueryValueEx(Key,
                        Linkage,
                        NULL,
                        &Type,
                        (LPBYTE)pBuffer,
                        &size);
            if ((size > 0) &&
                    ((status2 == ERROR_MORE_DATA) ||
                     (status2 == ERROR_SUCCESS))) {
                pBuffer = RtlAllocateHeap(
                                RtlProcessHeap(), 0, size);
                if (pBuffer == NULL) {
                    RegCloseKey(Key);
                    return ERROR_OUTOFMEMORY;
                }
                status2 = RegQueryValueEx(Key,
                            Linkage,
                            NULL,
                            &Type,
                            (LPBYTE)pBuffer,
                            &size);
            }
            RegCloseKey(Key);
            if (status2 != ERROR_SUCCESS) {
                if (pBuffer != NULL) {
                    RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
                }
                return ERROR_SUCCESS;
            }
       }
       else {
          return ERROR_SUCCESS;
       }

       if (pBuffer == NULL) {
          return ERROR_SUCCESS;
       }
       lpLocalDeviceNames = pBuffer;
       while (TRUE) {

          if (*lpLocalDeviceNames == '\0') {
             break;
          }

          ntstatus = OpenNbt (lpLocalDeviceNames,
             &hFileHandle,
             &fileString);

          if (ntstatus == ERROR_SUCCESS) {
             if (NumberOfNbtDevices == 0) {
                // allocate memory to hold the device data
                pNbtDeviceData = RtlAllocateHeap(RtlProcessHeap(),
                   HEAP_ZERO_MEMORY,
                   sizeof(NBT_DEVICE_DATA));

                if (pNbtDeviceData == NULL) {
                   RtlFreeUnicodeString(&fileString);
                   if (pBuffer) {
                       RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
                   }
                   return ERROR_OUTOFMEMORY;
                }
             }
             else {
                // resize to hold multiple devices
                pTemp = RtlReAllocateHeap(RtlProcessHeap(), 0,
                   pNbtDeviceData,
                   sizeof(NBT_DEVICE_DATA) * (NumberOfNbtDevices + 1));
                if (pTemp == NULL) {
                   NtClose(hFileHandle);
                   RtlFreeUnicodeString(&fileString);
                   RtlFreeHeap(RtlProcessHeap(), 0, pNbtDeviceData);
                   pNbtDeviceData = NULL;
                   REPORT_ERROR (TDI_PROVIDER_STATS_MEMORY, LOG_USER);
                   break;
                }
                else {
                   pNbtDeviceData = pTemp;
                }
             }

             // build the Data structure for this device instance
             pNbtDeviceData[NumberOfNbtDevices].hFileHandle
                = hFileHandle;
             pNbtDeviceData[NumberOfNbtDevices].DeviceName.MaximumLength =
                fileString.MaximumLength;
             pNbtDeviceData[NumberOfNbtDevices].DeviceName.Length =
                fileString.Length;
             pNbtDeviceData[NumberOfNbtDevices].DeviceName.Buffer =
                fileString.Buffer;
             NumberOfNbtDevices++;

             if (fileString.MaximumLength > MaxNbtDeviceName) {
                MaxNbtDeviceName = fileString.MaximumLength;
             }
          }  // ntstatus OK
          else {
             RtlFreeUnicodeString(&fileString);
          }

          // increment to the next device string
    //      lpLocalDeviceNames += strlen(lpLocalDeviceNames) + 1;
          // we only support one device at this point since we cannot
          // tell which Connection goes with which device
          break;

          }  // while TRUE
   }

   REPORT_SUCCESS (NBT_OPEN_PERFORMANCE_DATA, LOG_DEBUG);
   if (pBuffer) {
       RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
   }
   return ERROR_SUCCESS;

}
#pragma warning ( default : 4127)


DWORD
CollectNbtPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Nbt counters.

   IN       LPWSTR   lpValueName
         pointer to a wide character null-terminated string passed by the
         registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  lpNumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.
--*/
{

   // Variables for reformatting the Nbt data

   LARGE_INTEGER UNALIGNED *pliCounter;
   NBT_DATA_DEFINITION     *pNbtDataDefinition;
   PPERF_OBJECT_TYPE       pNbtObject;
   ULONG                   SpaceNeeded;
   UNICODE_STRING          ConnectionName;
   ANSI_STRING             AnsiConnectionName;
   WCHAR                   ConnectionNameBuffer[NBT_CONNECTION_NAME_LENGTH + 20];
#if 0
   // be sure to check the reference below...
   WCHAR                   DeviceNameBuffer[NBT_CONNECTION_NAME_LENGTH + 1 + 128];
#endif
   CHAR                    AnsiConnectionNameBuffer[NBT_CONNECTION_NAME_LENGTH + 1 + 20];
   WCHAR                   TotalName[] = L"Total";
   PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
   PERF_COUNTER_BLOCK      *pPerfCounterBlock;
   CHAR                    NameOut[NETBIOS_NAME_SIZE +4];

//   int                     ConnectionCounter = 0; /* this is not used anymore */
   LARGE_INTEGER           TotalReceived, TotalSent;

   DWORD                   dwDataReturn[2];
   NTSTATUS                status;
   tCONNECTION_LIST        *pConList;
   tCONNECTIONS            *pConns;
   LONG                    Count;
   int                     i;
   int                     NumberOfConnections = 5;   // assume 5 to start
   PVOID                   pOldBuffer;

   if (lpValueName == NULL) {
       REPORT_INFORMATION (NBT_COLLECT_ENTERED, LOG_VERBOSE);
   } else {
       REPORT_INFORMATION_DATA (NBT_COLLECT_ENTERED, LOG_VERBOSE,
          lpValueName, (lstrlenW(lpValueName) * sizeof(WCHAR)));
   }


   //
   // define pointer for Object Data structure (NBT object def.)
   //

   pNbtDataDefinition = (NBT_DATA_DEFINITION *) *lppData;
   pNbtObject = (PPERF_OBJECT_TYPE) pNbtDataDefinition;

   if (!pNbtDeviceData || NumberOfNbtDevices == 0)
      {
      //
      // Error getting NBT info, so return 0 bytes, 0 objects and
      //  log error
      //
      if (NumberOfNbtDevices > 0) {
          // only report an error if there are devices
          // returning data but they can't be read.
          REPORT_ERROR (NBT_IOCTL_INFO_ERROR, LOG_USER);
      }
      *lpcbTotalBytes = (DWORD) 0;
      *lpNumObjectTypes = (DWORD) 0;
      return ERROR_SUCCESS;
      }

   if (!pNbtDataBuffer)
      {
      NbtDataBufferSize = 1024L;
      pNbtDataBuffer = RtlAllocateHeap(RtlProcessHeap(),
         HEAP_ZERO_MEMORY,
         NbtDataBufferSize
         );
      if (!pNbtDataBuffer)
         {
         *lpcbTotalBytes = (DWORD) 0;
         *lpNumObjectTypes = (DWORD) 0;
         return ERROR_SUCCESS;
         }
      }

   REPORT_SUCCESS (NBT_IOCTL_INFO_SUCCESS, LOG_VERBOSE);


   // Compute space needed to hold NBT data
   SpaceNeeded = sizeof(NBT_DATA_DEFINITION) +
      (NumberOfConnections *
      NumberOfNbtDevices *
      (sizeof(PERF_INSTANCE_DEFINITION) +
      QWORD_MULTIPLE((NBT_CONNECTION_NAME_LENGTH + 1) * sizeof(WCHAR)) +
      QWORD_MULTIPLE(MaxNbtDeviceName)
      + SIZE_OF_NBT_DATA));

   if ( *lpcbTotalBytes < SpaceNeeded ) {
      dwDataReturn[0] = *lpcbTotalBytes;
      dwDataReturn[1] = SpaceNeeded;
      REPORT_WARNING_DATA (NBT_DATA_BUFFER_SIZE, LOG_DEBUG,
         &dwDataReturn, sizeof (dwDataReturn));
      return ERROR_MORE_DATA;
   }



   AnsiConnectionName.Length =
   AnsiConnectionName.MaximumLength = sizeof(AnsiConnectionNameBuffer);
   AnsiConnectionName.Buffer = AnsiConnectionNameBuffer;
   //
   //  If here, then there's a object to display so initialize
   //    the Object data structure in the buffer passed to us.
   //
   RtlMoveMemory(pNbtDataDefinition, &NbtDataDefinition, sizeof(NBT_DATA_DEFINITION));
   //
   // point to where the first instance of this will be (if we find one.
   //
   pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
               (pNbtDataDefinition + 1);

   TotalReceived.LowPart =  0; // initialize counters
   TotalSent.LowPart = 0;
   TotalReceived.HighPart =  0; // initialize counters
   TotalSent.HighPart = 0;

   // NOTE:- we only support NumberOfNbtDevices == 1 since
   // DeviceIoCtrl can't tell which connection is for which NBT device
   for (i=0; i < NumberOfNbtDevices; i++)
      {
      if (pNbtDeviceData[i].hFileHandle == 0 ||
         pNbtDeviceData[i].hFileHandle == INVALID_HANDLE_VALUE)
         {
         continue;
         }

      status = STATUS_BUFFER_OVERFLOW;
      while (status == STATUS_BUFFER_OVERFLOW)
         {
         status = DeviceIoCtrl (
            pNbtDeviceData[i].hFileHandle,
            pNbtDataBuffer,
            NbtDataBufferSize,
            IOCTL_NETBT_GET_CONNECTIONS);
         if (status == STATUS_BUFFER_OVERFLOW)
            {
            // resize to hold multiple devices
            NbtDataBufferSize += 1024L;
            pOldBuffer = pNbtDataBuffer;
            pNbtDataBuffer = RtlReAllocateHeap(RtlProcessHeap(), 0,
               pNbtDataBuffer,
               NbtDataBufferSize);

            if (pNbtDataBuffer == NULL || NbtDataBufferSize == 0x0FFFFL)
               {
               *lpcbTotalBytes = (DWORD) 0;
               *lpNumObjectTypes = (DWORD) 0;
               RtlFreeHeap(RtlProcessHeap(), 0, pOldBuffer);
               pNbtDataBuffer = NULL;
               return ERROR_SUCCESS;
               }
            }
         }  // while Buffer overflow

      pConList = (tCONNECTION_LIST *) pNbtDataBuffer;
      Count = pConList->ConnectionCount;
      pConns = pConList->ConnList;

      if (Count == 0)
         {
         continue;
         }

      if (NumberOfConnections < Count)
         {
         NumberOfConnections = Count;

         // Better check space needed to hold NBT data again
         // this is because the Count could be hugh
         SpaceNeeded = sizeof(NBT_DATA_DEFINITION) +
            (NumberOfConnections *
            NumberOfNbtDevices *
            (sizeof(PERF_INSTANCE_DEFINITION) +
            QWORD_MULTIPLE((NBT_CONNECTION_NAME_LENGTH + 1) * sizeof(WCHAR)) +
            QWORD_MULTIPLE(MaxNbtDeviceName )
            + SIZE_OF_NBT_DATA));


         if ( *lpcbTotalBytes < SpaceNeeded ) {
            dwDataReturn[0] = *lpcbTotalBytes;
            dwDataReturn[1] = SpaceNeeded;
            REPORT_WARNING_DATA (NBT_DATA_BUFFER_SIZE, LOG_DEBUG,
               &dwDataReturn, sizeof (dwDataReturn));
            return ERROR_MORE_DATA;
            }
         }

      while ( Count-- )
         {
         if (pConns->State == NBT_SESSION_UP)
            {
            // only care about UP connection

            if (pConns->RemoteName[0])
               {
               AnsiConnectionName.Length = (USHORT)sprintf (
                  AnsiConnectionNameBuffer,
                  "%16.16s",
                  printable(pConns->RemoteName, NameOut));
               }
            else if (pConns->LocalName[0])
               {
               if (pConns->LocalName[NETBIOS_NAME_SIZE-1] < ' ')
                  {
                  AnsiConnectionName.Length = (USHORT)sprintf (
                     AnsiConnectionNameBuffer,
                     "%15.15s%02.2X",
                     printable(pConns->LocalName, NameOut),
                     pConns->LocalName[NETBIOS_NAME_SIZE-1]);
                  }
               else
                  {
                  AnsiConnectionName.Length = (USHORT)sprintf (
                     AnsiConnectionNameBuffer,
                     "%16.16s",
                     printable(pConns->LocalName, NameOut));
                  }
               }
            else
               {
               AnsiConnectionNameBuffer[0] = ' ';
               AnsiConnectionName.Length = 1;
               }

            ConnectionName.Length =
               ConnectionName.MaximumLength =
               sizeof(ConnectionNameBuffer);
            ConnectionName.Buffer = ConnectionNameBuffer;

            RtlAnsiStringToUnicodeString (&ConnectionName,
               &AnsiConnectionName,
               FALSE);

            // no need to put in device name since we can
            // only support one device
#if 0
            lstrcpyW (DeviceNameBuffer, pNbtDeviceData[i].DeviceName.Buffer);
            lstrcatW (DeviceNameBuffer, L" ");
            lstrcatW (DeviceNameBuffer, ConnectionNameBuffer);

            ConnectionName.Length =
               lstrlenW (DeviceNameBuffer) * sizeof(WCHAR);
            ConnectionName.MaximumLength =
               sizeof(DeviceNameBuffer);
            ConnectionName.Buffer = DeviceNameBuffer;
#endif

            //
            //    load instance data into buffer
            //
            MonBuildInstanceDefinition (pPerfInstanceDefinition,
               (PVOID *) &pPerfCounterBlock,
               0,
               0,
               (DWORD)PERF_NO_UNIQUE_ID,   // no unique ID, Use the name instead
//               ConnectionCounter++,
               &ConnectionName);

            //
            //    adjust object size values to include new instance
            //

            pNbtObject->NumInstances++;
            //
            // initialize this instance's counter block

            pPerfCounterBlock->ByteLength = SIZE_OF_NBT_DATA;

            pliCounter = (LARGE_INTEGER UNALIGNED * ) (pPerfCounterBlock + 2);

            *(pliCounter++) = pConns->BytesRcvd;
            TotalReceived.QuadPart = TotalReceived.QuadPart +
               pConns->BytesRcvd.QuadPart;

            *pliCounter++ = pConns->BytesSent;
            TotalSent.QuadPart = TotalSent.QuadPart +
               pConns->BytesSent.QuadPart;

            pliCounter->QuadPart = pConns->BytesRcvd.QuadPart +
               pConns->BytesSent.QuadPart;

            //
            // update pointer for next instance
            //
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
               (((PBYTE) pPerfCounterBlock) + SIZE_OF_NBT_DATA);

            }  // pConns->State == NBT_SESSION_UP

         pConns++;

         } // while ( Count-- )
      }  // for i < NumberOfNbtDevices



   // The last instance definition contains the total data from all the
   // displayed connections

   RtlInitUnicodeString (&ConnectionName, TotalName);
   MonBuildInstanceDefinition (pPerfInstanceDefinition,
            (PVOID *) &pPerfCounterBlock,
            0,
            0,
//            ConnectionCounter++,
            (DWORD)PERF_NO_UNIQUE_ID,   // no unique ID, Use the name instead
            &ConnectionName);

   //
   //    adjust object size values to include new instance
   //

   pNbtObject->NumInstances++;
   pNbtObject->TotalByteLength += sizeof (PERF_INSTANCE_DEFINITION)
                                  + SIZE_OF_NBT_DATA;

   // initialize counter block for this instance

   pPerfCounterBlock->ByteLength = SIZE_OF_NBT_DATA;

   // load counters

   pliCounter = (LARGE_INTEGER UNALIGNED * ) (pPerfCounterBlock + 2);
   (*(pliCounter++)) = TotalReceived;
   (*(pliCounter++)) = TotalSent;
   pliCounter->QuadPart = TotalReceived.QuadPart + TotalSent.QuadPart;
   pliCounter++;

   // Set returned values
   *lppData = (LPVOID)pliCounter;

   *lpNumObjectTypes = NBT_NUM_PERF_OBJECT_TYPES;
   *lpcbTotalBytes = (DWORD)((LPBYTE)pliCounter-(LPBYTE)pNbtObject);

   pNbtDataDefinition->NbtObjectType.TotalByteLength = *lpcbTotalBytes;

   REPORT_INFORMATION (NBT_COLLECT_DATA, LOG_DEBUG);
   return ERROR_SUCCESS;
}



DWORD
CloseNbtPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to Nbt devices.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    int     i;

    REPORT_INFORMATION (NBT_CLOSE, LOG_VERBOSE);

    if (InterlockedDecrement(&dwNbtRefCount) == 0) {
        if (pNbtDeviceData) {
            for (i=0; i < NumberOfNbtDevices; i++) {
               if (pNbtDeviceData[i].DeviceName.Buffer) {
                   RtlFreeUnicodeString(&(pNbtDeviceData[i].DeviceName));
               }

               if (pNbtDeviceData[i].hFileHandle) {
                   NtClose (pNbtDeviceData[i].hFileHandle);
               }
            }

            RtlFreeHeap( RtlProcessHeap(), 0, pNbtDeviceData);

            pNbtDeviceData = NULL;
            NumberOfNbtDevices = 0;
        }


        if (pNbtDataBuffer) {
              RtlFreeHeap( RtlProcessHeap(), 0, pNbtDataBuffer);
              pNbtDataBuffer = NULL;
              NbtDataBufferSize = 0;
        }
    }

    MonCloseEventLog();

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\dataheap.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataheap.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Heap Performance data objects

Created:

    Adrian Marinescu  9-Mar-2000

Revision History:

--*/

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataheap.h"

// dummy variable for field sizing.

static HEAP_COUNTER_DATA   tcd;

//
//  Constant structure initializations 
//      defined in dataheap.h
//

HEAP_DATA_DEFINITION HeapDataDefinition = {
    {   0,
        sizeof(HEAP_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        HEAP_OBJECT_TITLE_INDEX,
        0,
        (HEAP_OBJECT_TITLE_INDEX + 1),
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(HEAP_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1762,
        0,
        1763,
        0,
        -6,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.CommittedBytes),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->CommittedBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1764,
        0,
        1765,
        0,
        -7,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.ReservedBytes),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->ReservedBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1766,
        0,
        1767,
        0,
        -7,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.VirtualBytes),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->VirtualBytes
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1768,
        0,
        1769,
        0,
        -5,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.FreeSpace),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->FreeSpace
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1770,
        0,
        1771,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.FreeListLength),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->FreeListLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1772,
        0,
        1773,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.AllocTime),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->AllocTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1774,
        0,
        1775,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof (tcd.FreeTime),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->FreeTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1776,
        0,
        1777,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.UncommitedRangesLength),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->UncommitedRangesLength
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1778,
        0,
        1779,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.DiffOperations),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->DiffOperations
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1780,
        0,
        1781,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.LookasideAllocs),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LookasideAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1782,
        0,
        1783,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.LookasideFrees),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LookasideFrees
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1784,
        0,
        1785,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.SmallAllocs),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->SmallAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1786,
        0,
        1787,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.SmallFrees),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->SmallFrees
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1788,
        0,
        1789,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.MedAllocs),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->MedAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1790,
        0,
        1791,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.MedFrees),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->MedFrees
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1792,
        0,
        1793,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.LargeAllocs),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LargeAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1794,
        0,
        1795,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.LargeFrees),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LargeFrees
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1796,
        0,
        1797,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.TotalAllocs),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->TotalAllocs
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1798,
        0,
        1799,
        0,
        -3,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.TotalFrees),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->TotalFrees
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1800,
        0,
        1801,
        0,
        -2,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.LookasideBlocks),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LookasideBlocks
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1802,
        0,
        1803,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.LargestLookasideDepth),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LargestLookasideDepth
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1804,
        0,
        1805,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.BlockFragmentation),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->BlockFragmentation
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1806,
        0,
        1807,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.VAFragmentation),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->VAFragmentation
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1808,
        0,
        1809,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.LockContention),
        (DWORD)(ULONG_PTR)&((PHEAP_COUNTER_DATA)0)->LockContention
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\dataexpr.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAEXPR.h

Abstract:

    Header file for the Windows NT Extended Process Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATA_EX_PROCESS_H_
#define _DATA_EX_PROCESS_H_

//
//  extended process performance definition structure
//

typedef struct _EXPROCESS_DATA_DEFINITION {
    PERF_OBJECT_TYPE        ExProcessObjectType;
    PERF_COUNTER_DEFINITION ProcessId;
    PERF_COUNTER_DEFINITION ImageReservedBytes;
    PERF_COUNTER_DEFINITION ImageFreeBytes;
    PERF_COUNTER_DEFINITION ReservedBytes;
    PERF_COUNTER_DEFINITION FreeBytes;
    PERF_COUNTER_DEFINITION CommitNoAccess;
    PERF_COUNTER_DEFINITION CommitReadOnly;
    PERF_COUNTER_DEFINITION CommitReadWrite;
    PERF_COUNTER_DEFINITION CommitWriteCopy;
    PERF_COUNTER_DEFINITION CommitExecute;
    PERF_COUNTER_DEFINITION CommitExecuteRead;
    PERF_COUNTER_DEFINITION CommitExecuteWrite;
    PERF_COUNTER_DEFINITION CommitExecuteWriteCopy;
    PERF_COUNTER_DEFINITION ReservedNoAccess;
    PERF_COUNTER_DEFINITION ReservedReadOnly;
    PERF_COUNTER_DEFINITION ReservedReadWrite;
    PERF_COUNTER_DEFINITION ReservedWriteCopy;
    PERF_COUNTER_DEFINITION ReservedExecute;
    PERF_COUNTER_DEFINITION ReservedExecuteRead;
    PERF_COUNTER_DEFINITION ReservedExecuteWrite;
    PERF_COUNTER_DEFINITION ReservedExecuteWriteCopy;
    PERF_COUNTER_DEFINITION UnassignedNoAccess;
    PERF_COUNTER_DEFINITION UnassignedReadOnly;
    PERF_COUNTER_DEFINITION UnassignedReadWrite;
    PERF_COUNTER_DEFINITION UnassignedWriteCopy;
    PERF_COUNTER_DEFINITION UnassignedExecute;
    PERF_COUNTER_DEFINITION UnassignedExecuteRead;
    PERF_COUNTER_DEFINITION UnassignedExecuteWrite;
    PERF_COUNTER_DEFINITION UnassignedExecuteWriteCopy;
    PERF_COUNTER_DEFINITION ImageTotalNoAccess;
    PERF_COUNTER_DEFINITION ImageTotalReadOnly;
    PERF_COUNTER_DEFINITION ImageTotalReadWrite;
    PERF_COUNTER_DEFINITION ImageTotalWriteCopy;
    PERF_COUNTER_DEFINITION ImageTotalExecute;
    PERF_COUNTER_DEFINITION ImageTotalExecuteRead;
    PERF_COUNTER_DEFINITION ImageTotalExecuteWrite;
    PERF_COUNTER_DEFINITION ImageTotalExecuteWriteCopy;
} EXPROCESS_DATA_DEFINITION, * PEXPROCESS_DATA_DEFINITION;

typedef struct _EXPROCESS_COUNTER_DATA {
    PERF_COUNTER_BLOCK       CounterBlock;
    DWORD                    Reserved;  // for alignment
    LONGLONG                 ProcessId;
    LONGLONG                 ImageReservedBytes;
    LONGLONG                 ImageFreeBytes;
    LONGLONG                 ReservedBytes;
    LONGLONG                 FreeBytes;
    LONGLONG                 CommitNoAccess;
    LONGLONG                 CommitReadOnly;
    LONGLONG                 CommitReadWrite;
    LONGLONG                 CommitWriteCopy;
    LONGLONG                 CommitExecute;
    LONGLONG                 CommitExecuteRead;
    LONGLONG                 CommitExecuteWrite;
    LONGLONG                 CommitExecuteWriteCopy;
    LONGLONG                 ReservedNoAccess;
    LONGLONG                 ReservedReadOnly;
    LONGLONG                 ReservedReadWrite;
    LONGLONG                 ReservedWriteCopy;
    LONGLONG                 ReservedExecute;
    LONGLONG                 ReservedExecuteRead;
    LONGLONG                 ReservedExecuteWrite;
    LONGLONG                 ReservedExecuteWriteCopy;
    LONGLONG                 UnassignedNoAccess;
    LONGLONG                 UnassignedReadOnly;
    LONGLONG                 UnassignedReadWrite;
    LONGLONG                 UnassignedWriteCopy;
    LONGLONG                 UnassignedExecute;
    LONGLONG                 UnassignedExecuteRead;
    LONGLONG                 UnassignedExecuteWrite;
    LONGLONG                 UnassignedExecuteWriteCopy;
    LONGLONG                 ImageTotalNoAccess;
    LONGLONG                 ImageTotalReadOnly;
    LONGLONG                 ImageTotalReadWrite;
    LONGLONG                 ImageTotalWriteCopy;
    LONGLONG                 ImageTotalExecute;
    LONGLONG                 ImageTotalExecuteRead;
    LONGLONG                 ImageTotalExecuteWrite;
    LONGLONG                 ImageTotalExecuteWriteCopy;
} EXPROCESS_COUNTER_DATA, *PEXPROCESS_COUNTER_DATA;

extern EXPROCESS_DATA_DEFINITION ExProcessDataDefinition;

#endif // _DATA_EX_PROCESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\dataheap.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAHEAP.h

Abstract:

    Header file for the Windows NT heap Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Adrian Marinescu  9-Mar-2000

Revision History:


--*/

#ifndef _DATAHEAP_H_
#define _DATAHEAP_H_

//
//  This is the counter structure presently returned by NT.  The
//  Performance Monitor MUST *NOT* USE THESE STRUCTURES!
//

typedef struct _HEAP_DATA_DEFINITION {
    PERF_OBJECT_TYPE		HeapObjectType;
    PERF_COUNTER_DEFINITION	CommittedBytes;
    PERF_COUNTER_DEFINITION	ReservedBytes;
    PERF_COUNTER_DEFINITION	VirtualBytes;
    PERF_COUNTER_DEFINITION	FreeSpace;
    PERF_COUNTER_DEFINITION	FreeListLength;
    PERF_COUNTER_DEFINITION	AllocTime;
    PERF_COUNTER_DEFINITION	FreeTime;
    PERF_COUNTER_DEFINITION	UncommitedRangesLength;
    PERF_COUNTER_DEFINITION	DiffOperations;
    PERF_COUNTER_DEFINITION	LookasideAllocs;
    PERF_COUNTER_DEFINITION	LookasideFrees;
    PERF_COUNTER_DEFINITION	SmallAllocs;
    PERF_COUNTER_DEFINITION	SmallFrees;
    PERF_COUNTER_DEFINITION	MedAllocs;
    PERF_COUNTER_DEFINITION	MedFrees;
    PERF_COUNTER_DEFINITION	LargeAllocs;
    PERF_COUNTER_DEFINITION	LargeFrees;
    PERF_COUNTER_DEFINITION	TotalAllocs;
    PERF_COUNTER_DEFINITION	TotalFrees;
    PERF_COUNTER_DEFINITION	LookasideBlocks;
    PERF_COUNTER_DEFINITION	LargestLookasideDepth;
    PERF_COUNTER_DEFINITION	BlockFragmentation;
    PERF_COUNTER_DEFINITION	VAFragmentation;
    PERF_COUNTER_DEFINITION	LockContention;
} HEAP_DATA_DEFINITION, *PHEAP_DATA_DEFINITION;


typedef struct _HEAP_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    LONG                    Reserved1;      // for alignment of longlongs
    ULONGLONG	            CommittedBytes;
    ULONGLONG	            ReservedBytes;
    ULONGLONG	            VirtualBytes;
    ULONGLONG	            FreeSpace;
    LONG	                FreeListLength;
    LONG                    Reserved2;      // for alignment of longlongs
    LONGLONG            	AllocTime;
    LONGLONG                FreeTime;
    ULONG                   UncommitedRangesLength;
    ULONG                   DiffOperations;
    ULONG                   LookasideAllocs;
    ULONG                   LookasideFrees;
    ULONG                   SmallAllocs;
    ULONG                   SmallFrees;
    ULONG                   MedAllocs;
    ULONG                   MedFrees;
    ULONG                   LargeAllocs;
    ULONG                   LargeFrees;
    ULONG                   TotalAllocs;
    ULONG                   TotalFrees;
    ULONG                   LookasideBlocks;
    ULONG                   LargestLookasideDepth;
    ULONG                   BlockFragmentation;
    ULONG                   VAFragmentation;
    ULONG                   LockContention;
    ULONG                   Reserved3;
} HEAP_COUNTER_DATA, *PHEAP_COUNTER_DATA;

extern  HEAP_DATA_DEFINITION HeapDataDefinition;

#endif // _DATAHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\dataimag.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAIMAG.h

Abstract:

    Header file for the Windows NT Image Details Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATAPHYS_H_
#define _DATAPHYS_H_

//
//  image details disk performance definition structure
//

typedef struct _IMAGE_DATA_DEFINITION {
    PERF_OBJECT_TYPE        ImageObjectType;
    PERF_COUNTER_DEFINITION ImageAddrNoAccess;
    PERF_COUNTER_DEFINITION ImageAddrReadOnly;
    PERF_COUNTER_DEFINITION ImageAddrReadWrite;
    PERF_COUNTER_DEFINITION ImageAddrWriteCopy;
    PERF_COUNTER_DEFINITION ImageAddrExecute;
    PERF_COUNTER_DEFINITION ImageAddrExecuteReadOnly;
    PERF_COUNTER_DEFINITION ImageAddrExecuteReadWrite;
    PERF_COUNTER_DEFINITION ImageAddrExecuteWriteCopy;
} IMAGE_DATA_DEFINITION, *PIMAGE_DATA_DEFINITION;


typedef struct _IMAGE_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    LONGLONG                 ImageAddrNoAccess;
    LONGLONG                 ImageAddrReadOnly;
    LONGLONG                 ImageAddrReadWrite;
    LONGLONG                 ImageAddrWriteCopy;
    LONGLONG                 ImageAddrExecute;
    LONGLONG                 ImageAddrExecuteReadOnly;
    LONGLONG                 ImageAddrExecuteReadWrite;
    LONGLONG                 ImageAddrExecuteWriteCopy;
} IMAGE_COUNTER_DATA, * PIMAGE_COUNTER_DATA;

extern IMAGE_DATA_DEFINITION  ImageDataDefinition;

#endif // _DATAPHYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\dataimag.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataimag.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Image Details Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataimag.h"

// dummy variable for field sizing.
static IMAGE_COUNTER_DATA   icd;

//
//  Constant structure initializations 
//      defined in dataimag.h
//
IMAGE_DATA_DEFINITION  ImageDataDefinition = {
    {   0,
        sizeof (IMAGE_DATA_DEFINITION),
        sizeof (PERF_OBJECT_TYPE),
        IMAGE_OBJECT_TITLE_INDEX,
        0,
        741,
        0,
        PERF_DETAIL_WIZARD,
        (sizeof(IMAGE_DATA_DEFINITION) - sizeof (PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {0L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        788,
        0,
        789,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrNoAccess),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrNoAccess
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        790,
        0,
        791,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrReadOnly),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        792,
        0,
        793,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrReadWrite),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        794,
        0,
        795,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrWriteCopy),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrWriteCopy
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        796,
        0,
        797,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrExecute),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrExecute
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        798,
        0,
        799,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrExecuteReadOnly),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrExecuteReadOnly
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        800,
        0,
        801,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrExecuteReadWrite),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrExecuteReadWrite
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        802,
        0,
        803,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(icd.ImageAddrExecuteWriteCopy),
        (DWORD)(ULONG_PTR)&((IMAGE_COUNTER_DATA *)0)->ImageAddrExecuteWriteCopy
    }
};



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\datajob.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

      DATAJOB.h

Abstract:

    Header file for the Windows NT Processor Job Object counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/
#ifndef _DATAJOB_H_
#define _DATAJOB_H_

// don't include the "TOTAL" counters since we are reporting only rates
// (for now) the total rates are redundant.

#ifndef _DATAJOB_INCLUDE_TOTAL_COUNTERS
#define _DATAJOB_INCLUDE_TOTAL_COUNTERS
#endif


//
//  Process data object definitions.
//
//
//  This is the counter structure presently returned by NT.  The
//  Performance Monitor MUST *NOT* USE THESE STRUCTURES!
//

typedef struct _JOB_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    JobObjectType;
    PERF_COUNTER_DEFINITION	    cdCurrentProcessorTime;
    PERF_COUNTER_DEFINITION	    cdCurrentUserTime;
    PERF_COUNTER_DEFINITION	    cdCurrentKernelTime;
#ifdef _DATAJOB_INCLUDE_TOTAL_COUNTERS
    PERF_COUNTER_DEFINITION	    cdTotalProcessorTime;
    PERF_COUNTER_DEFINITION	    cdTotalUserTime;
    PERF_COUNTER_DEFINITION	    cdTotalKernelTime;
    PERF_COUNTER_DEFINITION	    cdCurrentProcessorUsage;
    PERF_COUNTER_DEFINITION	    cdCurrentUserUsage;
    PERF_COUNTER_DEFINITION	    cdCurrentKernelUsage;
#endif
    PERF_COUNTER_DEFINITION	    cdPageFaults;
	PERF_COUNTER_DEFINITION		cdTotalProcessCount;
	PERF_COUNTER_DEFINITION		cdCurrentProcessCount;
	PERF_COUNTER_DEFINITION		cdTerminatedProcessCount;
} JOB_DATA_DEFINITION, * PJOB_DATA_DEFINITION;

typedef struct _JOB_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    LONGLONG                    CurrentProcessorTime;
    LONGLONG                    CurrentUserTime;
    LONGLONG                    CurrentKernelTime;
#ifdef _DATAJOB_INCLUDE_TOTAL_COUNTERS
    LONGLONG                    TotalProcessorTime;
    LONGLONG                    TotalUserTime;
    LONGLONG                    TotalKernelTime;
    LONGLONG                    CurrentProcessorUsage;
    LONGLONG                    CurrentUserUsage;
    LONGLONG                    CurrentKernelUsage;
#endif //_DATAJOB_INCLUDE_TOTAL_COUNTERS
    DWORD                  	    PageFaults;
    DWORD                  	    TotalProcessCount;
    DWORD                  	    ActiveProcessCount;
    DWORD                  	    TerminatedProcessCount;
} JOB_COUNTER_DATA, * PJOB_COUNTER_DATA;

extern JOB_DATA_DEFINITION JobDataDefinition;

typedef struct _JOB_DETAILS_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    JobDetailsObjectType;
    PERF_COUNTER_DEFINITION	    cdProcessorTime;
    PERF_COUNTER_DEFINITION	    cdUserTime;
    PERF_COUNTER_DEFINITION	    cdKernelTime;
    PERF_COUNTER_DEFINITION	    cdPeakVirtualSize;
    PERF_COUNTER_DEFINITION	    cdVirtualSize;
    PERF_COUNTER_DEFINITION	    cdPageFaults;
    PERF_COUNTER_DEFINITION	    cdPeakWorkingSet;
    PERF_COUNTER_DEFINITION	    cdTotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	PERF_COUNTER_DEFINITION		cdPrivateWorkingSet;
	PERF_COUNTER_DEFINITION		cdSharedWorkingSet;
#endif
    PERF_COUNTER_DEFINITION	    cdPeakPageFile;
    PERF_COUNTER_DEFINITION	    cdPageFile;
    PERF_COUNTER_DEFINITION	    cdPrivatePages;
    PERF_COUNTER_DEFINITION     cdThreadCount;
    PERF_COUNTER_DEFINITION     cdBasePriority;
    PERF_COUNTER_DEFINITION     cdElapsedTime;
    PERF_COUNTER_DEFINITION     cdProcessId;
    PERF_COUNTER_DEFINITION     cdCreatorProcessId;
    PERF_COUNTER_DEFINITION     cdPagedPool;
    PERF_COUNTER_DEFINITION     cdNonPagedPool;
    PERF_COUNTER_DEFINITION     cdHandleCount;
    PERF_COUNTER_DEFINITION     cdReadOperationCount;
    PERF_COUNTER_DEFINITION     cdWriteOperationCount;
    PERF_COUNTER_DEFINITION     cdDataOperationCount;
    PERF_COUNTER_DEFINITION     cdOtherOperationCount;
    PERF_COUNTER_DEFINITION     cdReadTransferCount;
    PERF_COUNTER_DEFINITION     cdWriteTransferCount;
    PERF_COUNTER_DEFINITION     cdDataTransferCount;
    PERF_COUNTER_DEFINITION     cdOtherTransferCount;
} JOB_DETAILS_DATA_DEFINITION, * PJOB_DETAILS_DATA_DEFINITION;

typedef struct _JOB_DETAILS_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                  	    PageFaults;
    LONGLONG                    ProcessorTime;
    LONGLONG                    UserTime;
    LONGLONG                    KernelTime;
    LONGLONG                    PeakVirtualSize;
    LONGLONG                    VirtualSize;
    LONGLONG               	    PeakWorkingSet;
    LONGLONG               	    TotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	DWORD						PrivateWorkingSet;
	DWORD						SharedWorkingSet;
#endif
    LONGLONG                    PeakPageFile;
    LONGLONG                    PageFile;
    LONGLONG                    PrivatePages;
    DWORD                       ThreadCount;
    DWORD                       BasePriority;
    LONGLONG                    ElapsedTime;
    LONGLONG                    ProcessId;
    LONGLONG                    CreatorProcessId;
    DWORD                       PagedPool;
    DWORD                       NonPagedPool;
    DWORD                       HandleCount;
    DWORD                       Reserved;       // for alignment
    LONGLONG                    ReadOperationCount;
    LONGLONG                    WriteOperationCount;
    LONGLONG                    DataOperationCount;
    LONGLONG                    OtherOperationCount;
    LONGLONG                    ReadTransferCount;
    LONGLONG                    WriteTransferCount;
    LONGLONG                    DataTransferCount;
    LONGLONG                    OtherTransferCount;
} JOB_DETAILS_COUNTER_DATA, *PJOB_DETAILS_COUNTER_DATA;

extern JOB_DETAILS_DATA_DEFINITION	JobDetailsDataDefinition;

#endif // _DATAJOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\dataproc.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dataproc.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Process Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "dataproc.h"

// dummy variable for field sizing.
static PROCESS_COUNTER_DATA   pcd;

//
//  Constant structure initializations 
//      defined in dataproc.h
//

PROCESS_DATA_DEFINITION ProcessDataDefinition = {

    {   0,  // depends on number of instanced found
        sizeof(PROCESS_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        PROCESS_OBJECT_TITLE_INDEX,
        0,
        231,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(PROCESS_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        189,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_100NSEC_TIMER,
        sizeof(pcd.ProcessorTime),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        157,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(pcd.UserTime),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->UserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        159,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(pcd.KernelTime),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->KernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        172,
        0,
        173,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PeakVirtualSize),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PeakVirtualSize
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        174,
        0,
        175,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.VirtualSize),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->VirtualSize
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        28,
        0,
        177,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(pcd.PageFaults),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PageFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        178,
        0,
        179,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PeakWorkingSet),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PeakWorkingSet
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        180,
        0,
        181,
        0,
        -5,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.TotalWorkingSet),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->TotalWorkingSet
    },
#ifdef _DATAPROC_PRIVATE_WS_
    {   sizeof(PERF_COUNTER_DEFINITION),
        1478,
        0,
        1479,
        0,
        -5,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PrivateWorkingSet),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PrivateWorkingSet
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1480,
        0,
        1481,
        0,
        -5,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.SharedWorkingSet),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->SharedWorkingSet
    },
#endif
    {   sizeof(PERF_COUNTER_DEFINITION),
        182,
        0,
        183,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PeakPageFile),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PeakPageFile
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        184,
        0,
        185,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PageFile),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PageFile
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        186,
        0,
        187,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(pcd.PrivatePages),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PrivatePages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        680,
        0,
        681,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.ThreadCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ThreadCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        682,
        0,
        683,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.BasePriority),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->BasePriority
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        684,
        0,
        685,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_ELAPSED_TIME,
        sizeof(pcd.ElapsedTime),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ElapsedTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        784,
        0,
        785,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.ProcessId),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ProcessId
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1410,
        0,
        1411,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.CreatorProcessId),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->CreatorProcessId
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        56,
        0,
        57,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.PagedPool),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->PagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        58,
        0,
        59,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.NonPagedPool),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->NonPagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        952,
        0,
        953,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(pcd.HandleCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->HandleCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1412,
        0,
        1413,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.ReadOperationCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ReadOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1414,
        0,
        1415,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.WriteOperationCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->WriteOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1416,
        0,
        1417,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.DataOperationCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->DataOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1418,
        0,
        1419,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.OtherOperationCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->OtherOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1420,
        0,
        1421,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.ReadTransferCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->ReadTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1422,
        0,
        1423,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.WriteTransferCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->WriteTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1424,
        0,
        1425,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.DataTransferCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->DataTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1426,
        0,
        1427,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(pcd.OtherTransferCount),
        (DWORD)(ULONG_PTR)&((PPROCESS_COUNTER_DATA)0)->OtherTransferCount
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\datajob.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datajob.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Job Performance data objects

Created:

    Bob Watson  10-Oct-97

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datajob.h"

// dummy variable for field sizing.
static JOB_COUNTER_DATA		jcd;
static JOB_DETAILS_COUNTER_DATA		jdd;

//
//  Constant structure initializations 
//      defined in datajob.h
//

JOB_DATA_DEFINITION JobDataDefinition = {
    {   0,  // depends on number of instances found
        sizeof(JOB_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        JOB_OBJECT_TITLE_INDEX,
        0,
        JOB_OBJECT_TITLE_INDEX + 1,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(JOB_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 2,
        0,
        JOB_FIRST_COUNTER_INDEX + 3,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jcd.CurrentProcessorTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 4,
        0,
        JOB_FIRST_COUNTER_INDEX + 5,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jcd.CurrentUserTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentUserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 6,
        0,
        JOB_FIRST_COUNTER_INDEX + 7,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jcd.CurrentKernelTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentKernelTime
    },
#ifdef _DATAJOB_INCLUDE_TOTAL_COUNTERS
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 8,
        0,
        JOB_FIRST_COUNTER_INDEX + 9,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.TotalProcessorTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->TotalProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 10,
        0,
        JOB_FIRST_COUNTER_INDEX + 11,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.TotalUserTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->TotalUserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 12,
        0,
        JOB_FIRST_COUNTER_INDEX + 13,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.TotalKernelTime),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->TotalKernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 22,
        0,
        JOB_FIRST_COUNTER_INDEX + 23,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.CurrentProcessorUsage),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentProcessorUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 24,
        0,
        JOB_FIRST_COUNTER_INDEX + 25,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.CurrentUserUsage),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentUserUsage
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 26,
        0,
        JOB_FIRST_COUNTER_INDEX + 27,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jcd.CurrentKernelUsage),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->CurrentKernelUsage
    },
#endif //_DATAJOB_INCLUDE_TOTAL_COUNTERS
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 14,
        0,
        JOB_FIRST_COUNTER_INDEX + 15,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(jcd.PageFaults),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->PageFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 16,
        0,
        JOB_FIRST_COUNTER_INDEX + 17,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jcd.TotalProcessCount),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->TotalProcessCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 18,
        0,
        JOB_FIRST_COUNTER_INDEX + 19,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jcd.ActiveProcessCount),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->ActiveProcessCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        JOB_FIRST_COUNTER_INDEX + 20,
        0,
        JOB_FIRST_COUNTER_INDEX + 21,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jcd.TerminatedProcessCount),
        (DWORD)(ULONG_PTR)&((PJOB_COUNTER_DATA)0)->TerminatedProcessCount
    }
};

JOB_DETAILS_DATA_DEFINITION JobDetailsDataDefinition = {
    {   0,  // depends on number of instanced found
        sizeof(JOB_DETAILS_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        JOB_DETAILS_OBJECT_TITLE_INDEX,
        0,
        JOB_DETAILS_OBJECT_TITLE_INDEX + 1,
        0,
        PERF_DETAIL_ADVANCED,
        (sizeof(JOB_DETAILS_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        189,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jdd.ProcessorTime),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        157,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jdd.UserTime),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->UserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        159,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof(jdd.KernelTime),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->KernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        172,
        0,
        173,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PeakVirtualSize),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PeakVirtualSize
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        174,
        0,
        175,
        0,
        -6,
        PERF_DETAIL_EXPERT,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.VirtualSize),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->VirtualSize
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        28,
        0,
        177,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(jdd.PageFaults),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PageFaults
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        178,
        0,
        179,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PeakWorkingSet),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PeakWorkingSet
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        180,
        0,
        181,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.TotalWorkingSet),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->TotalWorkingSet
    },
#ifdef _DATAPROC_PRIVATE_WS_
    {   sizeof(PERF_COUNTER_DEFINITION),
        1478,
        0,
        1479,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PrivateWorkingSet),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PrivateWorkingSet
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1480,
        0,
        1481,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.SharedWorkingSet),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->SharedWorkingSet
    },
#endif
    {   sizeof(PERF_COUNTER_DEFINITION),
        182,
        0,
        183,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PeakPageFile),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PeakPageFile
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        184,
        0,
        185,
        0,
        -6,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PageFile),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PageFile
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        186,
        0,
        187,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.PrivatePages),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PrivatePages
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        680,
        0,
        681,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jdd.ThreadCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ThreadCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        682,
        0,
        683,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jdd.BasePriority),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->BasePriority
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        684,
        0,
        685,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_ELAPSED_TIME,
        sizeof(jdd.ElapsedTime),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ElapsedTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        784,
        0,
        785,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.ProcessId),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ProcessId
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1410,
        0,
        1411,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(jdd.CreatorProcessId),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->CreatorProcessId
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        56,
        0,
        57,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jdd.PagedPool),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->PagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        58,
        0,
        59,
        0,
        -5,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jdd.NonPagedPool),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->NonPagedPool
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        952,
        0,
        953,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(jdd.HandleCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->HandleCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1412,
        0,
        1413,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.ReadOperationCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ReadOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1414,
        0,
        1415,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.WriteOperationCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->WriteOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1416,
        0,
        1417,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.DataOperationCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->DataOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1418,
        0,
        1419,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.OtherOperationCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->OtherOperationCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1420,
        0,
        1421,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.ReadTransferCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->ReadTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1422,
        0,
        1423,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.WriteTransferCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->WriteTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1424,
        0,
        1425,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.DataTransferCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->DataTransferCount
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        1426,
        0,
        1427,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(jdd.OtherTransferCount),
        (DWORD)(ULONG_PTR)&((PJOB_DETAILS_COUNTER_DATA)0)->OtherTransferCount
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\datatdet.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATATDET.h

Abstract:

    Header file for the Windows NT Thread Detail Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATA_THREAD_DETAIL_H_
#define _DATA_THREAD_DETAIL_H_

//
//  thread detail performance definition structure
//
typedef struct _THREAD_DETAILS_DATA_DEFINITION {
    PERF_OBJECT_TYPE        ThreadDetailsObjectType;
    PERF_COUNTER_DEFINITION UserPc;
} THREAD_DETAILS_DATA_DEFINITION, *PTHREAD_DETAILS_DATA_DEFINITION;

typedef struct _THREAD_DETAILS_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   Reserved;
    LONGLONG		    UserPc;
} THREAD_DETAILS_COUNTER_DATA, * PTHREAD_DETAILS_COUNTER_DATA;

extern THREAD_DETAILS_DATA_DEFINITION ThreadDetailsDataDefinition;

#endif // _DATA_THREAD_DETAIL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\datatdet.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datatdet.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Thread Detail Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datatdet.h"

// dummy variable for field sizing.
static THREAD_DETAILS_COUNTER_DATA  tdcd;

//
//  Constant structure initializations 
//      defined in datatdet.h
//

THREAD_DETAILS_DATA_DEFINITION ThreadDetailsDataDefinition =
{
    {
        0,
        sizeof (THREAD_DETAILS_DATA_DEFINITION),
        sizeof (PERF_OBJECT_TYPE),
        THREAD_DETAILS_OBJECT_TITLE_INDEX,
        0,
        (THREAD_DETAILS_OBJECT_TITLE_INDEX+1),
        0,
        PERF_DETAIL_WIZARD,
        (sizeof(THREAD_DETAILS_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE)) /
            sizeof (PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L, 0L},
        {0L, 0L}
    },
    {
        sizeof (PERF_COUNTER_DEFINITION),
        708,
        0,
        709,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_LARGE_RAWCOUNT_HEX,
        sizeof (tdcd.UserPc),
        (DWORD)(ULONG_PTR)&((PTHREAD_DETAILS_COUNTER_DATA)0)->UserPc
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\dataproc.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATAPROC.h

Abstract:

    Header file for the Windows NT Processor Process counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/
#ifndef _DATAPROC_H_
#define _DATAPROC_H_

#ifdef	_DATAPROC_PRIVATE_WS_
#undef	_DATAPROC_PRIVATE_WS_
#endif

//
//  Process data object definitions.
//
//
//  This is the counter structure presently returned by NT.  The
//  Performance Monitor MUST *NOT* USE THESE STRUCTURES!
//

typedef struct _PROCESS_DATA_DEFINITION {
    PERF_OBJECT_TYPE		    ProcessObjectType;
    PERF_COUNTER_DEFINITION	    cdProcessorTime;
    PERF_COUNTER_DEFINITION	    cdUserTime;
    PERF_COUNTER_DEFINITION	    cdKernelTime;
    PERF_COUNTER_DEFINITION	    cdPeakVirtualSize;
    PERF_COUNTER_DEFINITION	    cdVirtualSize;
    PERF_COUNTER_DEFINITION	    cdPageFaults;
    PERF_COUNTER_DEFINITION	    cdPeakWorkingSet;
    PERF_COUNTER_DEFINITION	    cdTotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	PERF_COUNTER_DEFINITION		cdPrivateWorkingSet;
	PERF_COUNTER_DEFINITION		cdSharedWorkingSet;
#endif
	PERF_COUNTER_DEFINITION	    cdPeakPageFile;
    PERF_COUNTER_DEFINITION	    cdPageFile;
    PERF_COUNTER_DEFINITION	    cdPrivatePages;
    PERF_COUNTER_DEFINITION     cdThreadCount;
    PERF_COUNTER_DEFINITION     cdBasePriority;
    PERF_COUNTER_DEFINITION     cdElapsedTime;
    PERF_COUNTER_DEFINITION     cdProcessId;
    PERF_COUNTER_DEFINITION     cdCreatorProcessId;
    PERF_COUNTER_DEFINITION     cdPagedPool;
    PERF_COUNTER_DEFINITION     cdNonPagedPool;
    PERF_COUNTER_DEFINITION     cdHandleCount;
    PERF_COUNTER_DEFINITION     cdReadOperationCount;
    PERF_COUNTER_DEFINITION     cdWriteOperationCount;
    PERF_COUNTER_DEFINITION     cdDataOperationCount;
    PERF_COUNTER_DEFINITION     cdOtherOperationCount;
    PERF_COUNTER_DEFINITION     cdReadTransferCount;
    PERF_COUNTER_DEFINITION     cdWriteTransferCount;
    PERF_COUNTER_DEFINITION     cdDataTransferCount;
    PERF_COUNTER_DEFINITION     cdOtherTransferCount;
} PROCESS_DATA_DEFINITION, * PPROCESS_DATA_DEFINITION;

typedef struct _PROCESS_COUNTER_DATA {
    PERF_COUNTER_BLOCK          CounterBlock;
    DWORD                  	    PageFaults;
    LONGLONG                    ProcessorTime;
    LONGLONG                    UserTime;
    LONGLONG                    KernelTime;
    LONGLONG              	    PeakVirtualSize;
    LONGLONG                    VirtualSize;
    LONGLONG                  	PeakWorkingSet;
    LONGLONG                  	TotalWorkingSet;
#ifdef _DATAPROC_PRIVATE_WS_
	DWORD						PrivateWorkingSet;
	DWORD						SharedWorkingSet;
#endif
    LONGLONG                    PeakPageFile;
    LONGLONG                    PageFile;
    LONGLONG                    PrivatePages;
    DWORD                       ThreadCount;
    DWORD                       BasePriority;
    LONGLONG                    ElapsedTime;
    DWORD                       ProcessId;
    DWORD                       CreatorProcessId;
    DWORD                       PagedPool;
    DWORD                       NonPagedPool;
    DWORD                       HandleCount;
    DWORD                       Reserved;   // for alignment
    LONGLONG                    ReadOperationCount;
    LONGLONG                    WriteOperationCount;
    LONGLONG                    DataOperationCount;
    LONGLONG                    OtherOperationCount;
    LONGLONG                    ReadTransferCount;
    LONGLONG                    WriteTransferCount;
    LONGLONG                    DataTransferCount;
    LONGLONG                    OtherTransferCount;
} PROCESS_COUNTER_DATA, * PPROCESS_COUNTER_DATA;

extern PROCESS_DATA_DEFINITION ProcessDataDefinition;

#endif // _DATAPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\perfheap.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfheap.c

Abstract:

    This file implements an Performance Object that presents
    Heap performance object data

Created:

    Adrian Marinescu  9-Mar-2000

Revision History:


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "dataheap.h"


//
//  Redefinition for heap data
//


#define MAX_HEAP_COUNT 200
#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64
#define HEAP_OP_COUNT 2

#define HEAP_OP_ALLOC 0
#define HEAP_OP_FREE 1

typedef struct _HEAP_ENTRY {
    USHORT Size;
    USHORT PreviousSize;
    UCHAR SegmentIndex;
    UCHAR Flags;
    UCHAR UnusedBytes;
    UCHAR SmallTagIndex;
#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PVOID UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PVOID TagEntries;
    PVOID UCRSegments;
    PVOID UnusedUnCommittedRanges;

    ULONG AlignRound;
    ULONG AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    USHORT FreeListsInUseTerminate;
    USHORT AllocatorBackTraceIndex;
    ULONG NonDedicatedListLength;
    PVOID LargeBlocksIndex;
    PVOID PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PVOID LockVariable;
    PVOID CommitRoutine;

    PVOID Lookaside;
    ULONG LookasideLockCount;

} HEAP, *PHEAP;

typedef struct _HEAP_PERF_DATA {

    UINT64 CountFrequence;
    UINT64 OperationTime[HEAP_OP_COUNT];

    //
    //  The data bellow are only for sampling
    //

    ULONG  Sequence;

    UINT64 TempTime[HEAP_OP_COUNT];
    ULONG  TempCount[HEAP_OP_COUNT];

} HEAP_PERF_DATA, *PHEAP_PERF_DATA;

//
//  The heap index structure
//

typedef struct _HEAP_INDEX {
    
    ULONG ArraySize;
    ULONG VirtualMemorySize;

    HEAP_PERF_DATA PerfData;

    union {
        
        PULONG FreeListsInUseUlong;
        PUCHAR FreeListsInUseBytes;
    } u;

    PVOID *FreeListHints;

} HEAP_INDEX, *PHEAP_INDEX;


typedef struct _HEAP_LOOKASIDE {
    SLIST_HEADER ListHead;

    USHORT Depth;
    USHORT MaximumDepth;

    ULONG TotalAllocates;
    ULONG AllocateMisses;
    ULONG TotalFrees;
    ULONG FreeMisses;

    ULONG LastTotalAllocates;
    ULONG LastAllocateMisses;

    ULONG Counters[2];

} HEAP_LOOKASIDE, *PHEAP_LOOKASIDE;

//
//  Local variables
//

static HEAP_LOOKASIDE LookasideBuffer[HEAP_MAXIMUM_FREELISTS];
static DWORD PageSize = 0;

//
//  Implementation for heap query function
//

BOOLEAN
ReadHeapData (
    IN HANDLE hProcess,
    IN ULONG HeapNumber,
    IN PHEAP Heap,
    OUT PHEAP_COUNTER_DATA    pHCD
    )

/*++

    Routine Description:
    
        The routine loads into the given heap couter structure the 
        data from the heap structure

    Arguments:
    
        hProcess - The process containing the heap
        
        Heap - the heap address
        
        pPerfInstanceDefinition - Performance instance definition data
        
        pHCD - Counter data

    Returns:
        Returns TRUE if query succeeds.

--*/

{
    HEAP_SEGMENT CrtSegment;
    HEAP CrtHeap;
    ULONG SegmentIndex;
    RTL_CRITICAL_SECTION CriticalSection;
    HEAP_INDEX HeapIndex;

    ULONG i;

    //
    //  Read the heap structure from the process address space
    //

    if (!ReadProcessMemory(hProcess, Heap, &CrtHeap, sizeof(CrtHeap), NULL)) {

        return FALSE;
    }

    //
    //  We won't display data for heaps w/o index. 
    //

    if ((CrtHeap.LargeBlocksIndex == NULL) 
            &&
        (HeapNumber != 0)) {

        //
        //  We are not handling small heaps
        //

        return FALSE;
    }

    pHCD->FreeSpace = CrtHeap.TotalFreeSize;
    pHCD->FreeListLength = CrtHeap.NonDedicatedListLength;

    pHCD->CommittedBytes = 0;
    pHCD->ReservedBytes = 0;
    pHCD->VirtualBytes = 0;
    pHCD->UncommitedRangesLength = 0;

    //
    //  Walking the heap segments and get the virtual address counters
    //

    for (SegmentIndex = 0; SegmentIndex < HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        if ((CrtHeap.Segments[SegmentIndex] == NULL) ||
            !ReadProcessMemory(hProcess, CrtHeap.Segments[SegmentIndex], &CrtSegment, sizeof(CrtSegment), NULL)) {

            break;
        }

        pHCD->ReservedBytes += CrtSegment.NumberOfPages * PageSize;
        pHCD->CommittedBytes += (CrtSegment.NumberOfPages - CrtSegment.NumberOfUnCommittedPages) * PageSize;
        pHCD->VirtualBytes += CrtSegment.NumberOfPages * PageSize - CrtSegment.LargestUnCommittedRange;
        pHCD->UncommitedRangesLength += CrtSegment.NumberOfUnCommittedRanges;
    }

    if (pHCD->CommittedBytes == 0) {
        pHCD->CommittedBytes = 1;
    }

    if (pHCD->VirtualBytes == 0) {
        pHCD->VirtualBytes = 1;
    }
    
    //
    //  Compute the heap fragmentation counters
    //

    pHCD->BlockFragmentation = (ULONG)(pHCD->FreeSpace * 100 / pHCD->CommittedBytes);
    pHCD->VAFragmentation =(ULONG)(((pHCD->VirtualBytes - pHCD->CommittedBytes)*100)/pHCD->VirtualBytes);

    //
    //  Read the lock contention
    //

    pHCD->LockContention = 0;

    if (ReadProcessMemory(hProcess, CrtHeap.LockVariable, &CriticalSection, sizeof(CriticalSection), NULL)) {
        
        RTL_CRITICAL_SECTION_DEBUG DebugInfo;

        if (ReadProcessMemory(hProcess, CriticalSection.DebugInfo, &DebugInfo, sizeof(DebugInfo), NULL)) {

            pHCD->LockContention = DebugInfo.ContentionCount;
        }
    }

    //
    //  Walk the lookaside to count the blocks
    //

    pHCD->LookasideAllocs = 0;
    pHCD->LookasideFrees = 0;
    pHCD->LookasideBlocks = 0;
    pHCD->LargestLookasideDepth = 0;
    pHCD->SmallAllocs = 0;
    pHCD->SmallFrees = 0;
    pHCD->MedAllocs = 0;
    pHCD->MedFrees = 0;
    pHCD->LargeAllocs = 0;
    pHCD->LargeFrees = 0;
    
    if (ReadProcessMemory(hProcess, CrtHeap.Lookaside, &LookasideBuffer, sizeof(LookasideBuffer), NULL)) {

        for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i++) {
            
            pHCD->SmallAllocs += LookasideBuffer[i].TotalAllocates;
            pHCD->SmallFrees += LookasideBuffer[i].TotalFrees;
            pHCD->LookasideAllocs += LookasideBuffer[i].TotalAllocates - LookasideBuffer[i].AllocateMisses;
            pHCD->LookasideFrees += LookasideBuffer[i].TotalFrees - LookasideBuffer[i].FreeMisses;

            if (LookasideBuffer[i].Depth > pHCD->LargestLookasideDepth) {

                pHCD->LargestLookasideDepth = LookasideBuffer[i].Depth;
            }

            if (i == 0) {
                
            } else if (i < 8) {
                
                pHCD->MedAllocs += LookasideBuffer[i].Counters[0];
                pHCD->MedFrees += LookasideBuffer[i].Counters[1];
            } else {
                
                pHCD->LargeAllocs += LookasideBuffer[i].Counters[0];
                pHCD->LargeFrees += LookasideBuffer[i].Counters[1];
            }
        }
    }
    
    pHCD->LookasideBlocks = pHCD->LookasideFrees - pHCD->LookasideAllocs;

    //
    //  Calculate the totals
    //

    pHCD->TotalAllocs = pHCD->SmallAllocs + pHCD->MedAllocs + pHCD->LargeAllocs;
    pHCD->TotalFrees = pHCD->SmallFrees + pHCD->MedFrees + pHCD->LargeFrees;
    
    //
    //  Set the difference between allocs and frees
    //

    pHCD->DiffOperations = pHCD->TotalAllocs - pHCD->TotalFrees;
    
    pHCD->AllocTime = 0;
    pHCD->AllocTime = 0;

    //
    //  Determine the alloc/free rates
    //
    
    if (ReadProcessMemory(hProcess, CrtHeap.LargeBlocksIndex, &HeapIndex, sizeof(HeapIndex), NULL)) {

        if (HeapIndex.PerfData.OperationTime[0]) {
            pHCD->AllocTime = HeapIndex.PerfData.CountFrequence / HeapIndex.PerfData.OperationTime[0];
        }
        
        if (HeapIndex.PerfData.OperationTime[1]) {
            pHCD->FreeTime = HeapIndex.PerfData.CountFrequence / HeapIndex.PerfData.OperationTime[1];
        }
    }
    
    return TRUE;
}


DWORD APIENTRY
CollectHeapObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)

/*++

Routine Description:

    This routine will return the data for the heap object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/

{
    LONG    lReturn = ERROR_SUCCESS;

    DWORD  TotalLen;            //  Length of the total return block

    PHEAP_DATA_DEFINITION pHeapDataDefinition;
    PPERF_INSTANCE_DEFINITION pPerfInstanceDefinition;
    PHEAP_COUNTER_DATA    pHCD;

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    ULONG ProcessNumber;
    ULONG NumHeapInstances;
    ULONG HeapNumber;
    ULONG ProcessBufferOffset;
    UNICODE_STRING HeapName;
    WCHAR HeapNameBuffer[MAX_THREAD_NAME_LENGTH+1];
    BOOL  bMoreProcesses = FALSE;
    
    HeapName.Length =
    HeapName.MaximumLength = (MAX_THREAD_NAME_LENGTH + 1) * sizeof(WCHAR);
    HeapName.Buffer = HeapNameBuffer;

    pHeapDataDefinition = (HEAP_DATA_DEFINITION *) *lppData;

    //
    //  Get the page size from the system
    //

    if (!PageSize) {
        SYSTEM_INFO SystemInfo;
        
        GetSystemInfo(&SystemInfo);
        PageSize = SystemInfo.dwPageSize;

    }

    //
    //  Check for sufficient space for Thread object type definition
    //

    TotalLen = sizeof(HEAP_DATA_DEFINITION) +
               sizeof(PERF_INSTANCE_DEFINITION) +
               sizeof(HEAP_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define the heap data block
    //

    memcpy(pHeapDataDefinition,
           &HeapDataDefinition,
           sizeof(HEAP_DATA_DEFINITION));

    pHeapDataDefinition->HeapObjectType.PerfTime = PerfTime;

    ProcessBufferOffset = 0;

    //
    // Now collect data for each process
    //

    ProcessNumber = 0;
    NumHeapInstances = 0;

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;

    pPerfInstanceDefinition =
        (PPERF_INSTANCE_DEFINITION)&pHeapDataDefinition[1];
    TotalLen = sizeof(HEAP_DATA_DEFINITION);

    if (ProcessInfo) {
        if (ProcessInfo->NextEntryOffset != 0) {
            bMoreProcesses = TRUE;
        }
    }
    while ( bMoreProcesses && (ProcessInfo != NULL)) {

        HANDLE hProcess;
        NTSTATUS Status;
        PROCESS_BASIC_INFORMATION BasicInfo;

        //
		// Get a handle to the process.
        //

		hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
									   PROCESS_VM_READ,
									   FALSE, (DWORD)(ULONGLONG)ProcessInfo->UniqueProcessId );

		if ( hProcess ) {
            
            //
            //  Get the process PEB
            //

            Status = NtQueryInformationProcess(
                        hProcess,
                        ProcessBasicInformation,
                        &BasicInfo,
                        sizeof(BasicInfo),
                        NULL
                        );

            if ( NT_SUCCESS(Status) ) {
                
                ULONG NumberOfHeaps;
                PVOID ProcessHeaps[MAX_HEAP_COUNT];
                PVOID HeapBuffer;
                PPEB Peb;
                
                Peb = BasicInfo.PebBaseAddress;

                //
                //  Read the heaps from the process PEB
                //

                if (!ReadProcessMemory(hProcess, &Peb->NumberOfHeaps, &NumberOfHeaps, sizeof(NumberOfHeaps), NULL)) {

                    goto READERROR;
                }

                //
                //  Limit the number of heaps to be read
                //

                if (NumberOfHeaps > MAX_HEAP_COUNT) {

                    NumberOfHeaps = MAX_HEAP_COUNT;
                }

                if (!ReadProcessMemory(hProcess, &Peb->ProcessHeaps, &HeapBuffer, sizeof(HeapBuffer), NULL)) {

                    goto READERROR;
                }
                
                if (!ReadProcessMemory(hProcess, HeapBuffer, &ProcessHeaps, NumberOfHeaps * sizeof(PVOID), NULL)) {

                    goto READERROR;
                }

                //
                //  Loop through the heaps and retireve the data
                //

                for (HeapNumber = 0; HeapNumber < NumberOfHeaps; HeapNumber++) {

                    TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                               (MAX_THREAD_NAME_LENGTH+1+sizeof(DWORD))*
                                   sizeof(WCHAR) +
                               sizeof (HEAP_COUNTER_DATA);

                    if ( *lpcbTotalBytes < TotalLen ) {
                        *lpcbTotalBytes = (DWORD) 0;
                        *lpNumObjectTypes = (DWORD) 0;
                        
                        CloseHandle( hProcess );
                        return ERROR_MORE_DATA;
                    }
                    
                    //
                    //  Build the monitor instance based on the process name and 
                    //  heap address
                    //

                    RtlIntegerToUnicodeString( (ULONG)(ULONGLONG)ProcessHeaps[HeapNumber],
                                               16,
                                               &HeapName);

                    MonBuildInstanceDefinition(pPerfInstanceDefinition,
                        (PVOID *) &pHCD,
                        PROCESS_OBJECT_TITLE_INDEX,
                        ProcessNumber,
                        (DWORD)-1,
                        HeapName.Buffer);

                    pHCD->CounterBlock.ByteLength = sizeof(HEAP_COUNTER_DATA);
                    
                    //
                    //  Get the data from the heap
                    //

                    if (ReadHeapData ( hProcess,
                                       HeapNumber,
                                       (PHEAP)ProcessHeaps[HeapNumber],
                                       pHCD) ) {

                        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pHCD[1];
                        NumHeapInstances++;
                    }
                }
            }
READERROR:
    		CloseHandle( hProcess );
        }

        ProcessNumber++;
        
        //
        //  Move to the next process, if any
        //

        if (ProcessInfo->NextEntryOffset == 0) {
            bMoreProcesses = FALSE;
            continue;
        }

        ProcessBufferOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                       &pProcessBuffer[ProcessBufferOffset];
    }

    // Note number of heap instances

    pHeapDataDefinition->HeapObjectType.NumInstances =
        NumHeapInstances;

    //
    //  Now we know how large an area we used for the
    //  heap definition, so we can update the offset
    //  to the next object definition
    //

    *lpcbTotalBytes =
        pHeapDataDefinition->HeapObjectType.TotalByteLength =
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pHeapDataDefinition);

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFPROC: Heap Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lppData = (LPVOID)pPerfInstanceDefinition;

    *lpNumObjectTypes = 1;

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\perfimag.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfimag.c

Abstract:

    This file implements an Performance Object that presents
    Image details performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "dataimag.h"

DWORD APIENTRY
BuildImageObject (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes,
    IN      BOOL    bLongImageName
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

    IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

    IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

    IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

    IN      BOOL    bLongImageName
            TRUE -- use the full path of the library file name in the instance
            FALSE - use only the file name in the instance

    Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block

    PIMAGE_DATA_DEFINITION          pImageDataDefinition;
    PPERF_INSTANCE_DEFINITION       pPerfInstanceDefinition;
    PIMAGE_COUNTER_DATA             pICD;
    DWORD                           dwNumInstances;

    DWORD                           dwImageNameLength;

    DWORD                           dwProcessIndex;

    PPROCESS_VA_INFO                pThisProcess;
    PMODINFO                        pThisImage;

    dwNumInstances = 0;

    pImageDataDefinition = (IMAGE_DATA_DEFINITION *) *lppData;

    //
    //  Check for sufficient space for Image object type definition
    //

    TotalLen = sizeof(IMAGE_DATA_DEFINITION) +
               sizeof(PERF_INSTANCE_DEFINITION) +
               MAX_PROCESS_NAME_LENGTH +
               sizeof(IMAGE_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define Page File data block
    //

    memcpy(pImageDataDefinition,
        &ImageDataDefinition,
        sizeof(IMAGE_DATA_DEFINITION));

    // update object title index if this is a Long Image object

    if (bLongImageName) {
        pImageDataDefinition->ImageObjectType.ObjectNameTitleIndex =
            LONG_IMAGE_OBJECT_TITLE_INDEX;
        pImageDataDefinition->ImageObjectType.ObjectHelpTitleIndex =
            LONG_IMAGE_OBJECT_TITLE_INDEX + 1;
    }

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                &pImageDataDefinition[1];

    // Now load data for each Image

    pThisProcess = pProcessVaInfo;
    dwProcessIndex = 0;
    TotalLen = sizeof(IMAGE_DATA_DEFINITION);

    while (pThisProcess) {

        pThisImage = pThisProcess->pMemBlockInfo;

        while (pThisImage) {

            dwImageNameLength = (bLongImageName ? pThisImage->LongInstanceName->Length :
                    pThisImage->InstanceName->Length);
            dwImageNameLength += sizeof(WCHAR);
            dwImageNameLength = QWORD_MULTIPLE(dwImageNameLength);
        
            // see if this instance will fit

            TotalLen += sizeof (PERF_INSTANCE_DEFINITION) +
                dwImageNameLength + 
//                (MAX_PROCESS_NAME_LENGTH + 1) * sizeof (WCHAR) +
                sizeof (DWORD) +
                sizeof (IMAGE_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_MORE_DATA;
            }

            MonBuildInstanceDefinition (pPerfInstanceDefinition,
                (PVOID *) &pICD,
                EXPROCESS_OBJECT_TITLE_INDEX,
                dwProcessIndex,
                (DWORD)-1,
                (bLongImageName ? pThisImage->LongInstanceName->Buffer :
                    pThisImage->InstanceName->Buffer));

            pICD->CounterBlock.ByteLength = sizeof(IMAGE_COUNTER_DATA);

            pICD->ImageAddrNoAccess           = pThisImage->CommitVector[NOACCESS];
            pICD->ImageAddrReadOnly           = pThisImage->CommitVector[READONLY];
            pICD->ImageAddrReadWrite          = pThisImage->CommitVector[READWRITE];
            pICD->ImageAddrWriteCopy          = pThisImage->CommitVector[WRITECOPY];
            pICD->ImageAddrExecute            = pThisImage->CommitVector[EXECUTE];
            pICD->ImageAddrExecuteReadOnly    = pThisImage->CommitVector[EXECUTEREAD];
            pICD->ImageAddrExecuteReadWrite   = pThisImage->CommitVector[EXECUTEREADWRITE];
            pICD->ImageAddrExecuteWriteCopy   = pThisImage->CommitVector[EXECUTEWRITECOPY];

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pICD[1];

            // adjust Total Length value to reflect ACTUAL size used

            TotalLen = (DWORD)((PCHAR) pPerfInstanceDefinition -
                (PCHAR) pImageDataDefinition);

            dwNumInstances++;

            pThisImage = pThisImage->pNextModule;
        }
        pThisProcess = pThisProcess->pNextProcess;
        dwProcessIndex++;
    }

    pImageDataDefinition->ImageObjectType.NumInstances += dwNumInstances;

    *lpcbTotalBytes =
        pImageDataDefinition->ImageObjectType.TotalByteLength =
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pImageDataDefinition);

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFPROC: Image Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lppData = (LPVOID) pPerfInstanceDefinition;

    // increment number of objects in this data block
    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}

DWORD APIENTRY
CollectImageObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    return BuildImageObject (
                lppData,
                lpcbTotalBytes,
                lpNumObjectTypes,
                FALSE); // use short names
}

DWORD APIENTRY
CollectLongImageObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    return BuildImageObject (
                lppData,
                lpcbTotalBytes,
                lpNumObjectTypes,
                TRUE); // use long names
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\datathrd.h ===
/*++ 

Copyright (c) 1996 Microsoft Corporation

Module Name:

      DATATHRD.h

Abstract:

    Header file for the Windows NT Thread Performance counters.

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

    Bob Watson  28-Oct-1996

Revision History:


--*/

#ifndef _DATATHRD_H_
#define _DATATHRD_H_

//
//  This is the counter structure presently returned by NT.  The
//  Performance Monitor MUST *NOT* USE THESE STRUCTURES!
//

typedef struct _THREAD_DATA_DEFINITION {
    PERF_OBJECT_TYPE		ThreadObjectType;
    PERF_COUNTER_DEFINITION	ProcessorTime;
    PERF_COUNTER_DEFINITION	UserTime;
    PERF_COUNTER_DEFINITION	KernelTime;
    PERF_COUNTER_DEFINITION	ContextSwitches;
    PERF_COUNTER_DEFINITION ThreadElapsedTime;
    PERF_COUNTER_DEFINITION ThreadPriority;
    PERF_COUNTER_DEFINITION ThreadBasePriority;
    PERF_COUNTER_DEFINITION ThreadStartAddr;
    PERF_COUNTER_DEFINITION ThreadState;
    PERF_COUNTER_DEFINITION WaitReason;
    PERF_COUNTER_DEFINITION ProcessId;
    PERF_COUNTER_DEFINITION ThreadId;
} THREAD_DATA_DEFINITION;


typedef struct _THREAD_COUNTER_DATA {
    PERF_COUNTER_BLOCK      CounterBlock;
    LONGLONG        	    ProcessorTime;
    LONGLONG        	    UserTime;
    LONGLONG        	    KernelTime;
    DWORD                  	ContextSwitches;
    LONGLONG                ThreadElapsedTime;
    DWORD                   ThreadPriority;
    DWORD                   ThreadBasePriority;
    LPVOID                  ThreadStartAddr;
    DWORD                   ThreadState;
    DWORD                   WaitReason;
    DWORD                   ProcessId;
    DWORD                   ThreadId;
} THREAD_COUNTER_DATA, * PTHREAD_COUNTER_DATA;

extern  THREAD_DATA_DEFINITION ThreadDataDefinition;

#endif // _DATATHRD_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\datathrd.c ===
/*++ 

Copyright (c) 1996  Microsoft Corporation

Module Name:

    datathrd.c

Abstract:
       
    a file containing the constant data structures used by the Performance
    Monitor data for the Thread Performance data objects

Created:

    Bob Watson  22-Oct-1996

Revision History:

    None.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "datathrd.h"

// dummy variable for field sizing.
static THREAD_COUNTER_DATA   tcd;

//
//  Constant structure initializations 
//      defined in datathrd.h
//
THREAD_DATA_DEFINITION ThreadDataDefinition = {
    {   0,
        sizeof(THREAD_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        THREAD_OBJECT_TITLE_INDEX,
        0,
        233,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(THREAD_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION),
        0,
        0,
        UNICODE_CODE_PAGE,
        {0L,0L},
        {10000000L,0L}        
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        6,
        0,
        191,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_100NSEC_TIMER,
        sizeof (tcd.ProcessorTime),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ProcessorTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        142,
        0,
        193,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof (tcd.UserTime),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->UserTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        144,
        0,
        195,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_100NSEC_TIMER,
        sizeof (tcd.KernelTime),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->KernelTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        146,
        0,
        197,
        0,
        -2,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof (tcd.ContextSwitches),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ContextSwitches
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        684,
        0,
        699,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_ELAPSED_TIME,
        sizeof (tcd.ThreadElapsedTime),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadElapsedTime
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        694,
        0,
        695,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.ThreadPriority),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadPriority
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        682,
        0,
        697,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.ThreadBasePriority),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadBasePriority
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        706,
        0,
        707,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT_HEX,
        sizeof (tcd.ThreadStartAddr),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadStartAddr
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        46,
        0,
        47,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.ThreadState),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadState
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        336,
        0,
        337,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.WaitReason),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->WaitReason
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        784,
        0,
        785,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.ProcessId),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ProcessId
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        804,
        0,
        805,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_COUNTER_RAWCOUNT,
        sizeof (tcd.ThreadId),
        (DWORD)(ULONG_PTR)&((PTHREAD_COUNTER_DATA)0)->ThreadId
    }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\perfexpr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfexpr.c

Abstract:

    This file implements an Performance Object that presents
    Extended Process performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "dataexpr.h"

DWORD APIENTRY
CollectExProcessObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block
    DWORD   NumExProcessInstances;

    PPROCESS_VA_INFO            pThisProcess;   // pointer to current process
    PERF_INSTANCE_DEFINITION    *pPerfInstanceDefinition;
    EXPROCESS_DATA_DEFINITION   *pExProcessDataDefinition;

    PEXPROCESS_COUNTER_DATA     pECD;

    if (pProcessVaInfo) {   // process only if a buffer is available
        pExProcessDataDefinition = (EXPROCESS_DATA_DEFINITION *)*lppData;

        // check for sufficient space in buffer for at least one entry

        TotalLen = sizeof(EXPROCESS_DATA_DEFINITION) +
                    sizeof(PERF_INSTANCE_DEFINITION) +
                    (MAX_PROCESS_NAME_LENGTH + 1) * sizeof (WCHAR) +
                    sizeof(EXPROCESS_COUNTER_DATA);

        if (*lpcbTotalBytes < TotalLen) {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_MORE_DATA;
        }

        // copy process data block to buffer

        memcpy (pExProcessDataDefinition,
                        &ExProcessDataDefinition,
                        sizeof(EXPROCESS_DATA_DEFINITION));

        NumExProcessInstances = 0;

        pThisProcess = pProcessVaInfo;

        TotalLen = sizeof(EXPROCESS_DATA_DEFINITION);

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pExProcessDataDefinition[1];

        while (pThisProcess) {

            // see if this instance will fit

            TotalLen += sizeof (PERF_INSTANCE_DEFINITION) +
                (MAX_PROCESS_NAME_LENGTH + 1) * sizeof (WCHAR) +
                sizeof (DWORD) +
                sizeof (EXPROCESS_COUNTER_DATA);

            if (*lpcbTotalBytes < TotalLen) {
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;
                return ERROR_MORE_DATA;
            }

            MonBuildInstanceDefinition (pPerfInstanceDefinition,
                (PVOID *) &pECD,
                0,
                0,
                (DWORD)-1,
                pThisProcess->pProcessName->Buffer);

            NumExProcessInstances++;

            pECD->CounterBlock.ByteLength = sizeof (EXPROCESS_COUNTER_DATA);

            // load counters from the process va data structure

            pECD->ProcessId             = pThisProcess->dwProcessId;
            pECD->ImageReservedBytes    = pThisProcess->ImageReservedBytes;
            pECD->ImageFreeBytes        = pThisProcess->ImageFreeBytes;
            pECD->ReservedBytes         = pThisProcess->ReservedBytes;
            pECD->FreeBytes             = pThisProcess->FreeBytes;

            pECD->CommitNoAccess        = pThisProcess->MappedCommit[NOACCESS];
            pECD->CommitReadOnly        = pThisProcess->MappedCommit[READONLY];
            pECD->CommitReadWrite       = pThisProcess->MappedCommit[READWRITE];
            pECD->CommitWriteCopy       = pThisProcess->MappedCommit[WRITECOPY];
            pECD->CommitExecute         = pThisProcess->MappedCommit[EXECUTE];
            pECD->CommitExecuteRead     = pThisProcess->MappedCommit[EXECUTEREAD];
            pECD->CommitExecuteWrite    = pThisProcess->MappedCommit[EXECUTEREADWRITE];
            pECD->CommitExecuteWriteCopy = pThisProcess->MappedCommit[EXECUTEWRITECOPY];

            pECD->ReservedNoAccess      = pThisProcess->PrivateCommit[NOACCESS];
            pECD->ReservedReadOnly      = pThisProcess->PrivateCommit[READONLY];
            pECD->ReservedReadWrite     = pThisProcess->PrivateCommit[READWRITE];
            pECD->ReservedWriteCopy     = pThisProcess->PrivateCommit[WRITECOPY];
            pECD->ReservedExecute       = pThisProcess->PrivateCommit[EXECUTE];
            pECD->ReservedExecuteRead   = pThisProcess->PrivateCommit[EXECUTEREAD];
            pECD->ReservedExecuteWrite  = pThisProcess->PrivateCommit[EXECUTEREADWRITE];
            pECD->ReservedExecuteWriteCopy = pThisProcess->PrivateCommit[EXECUTEWRITECOPY];

            pECD->UnassignedNoAccess    = pThisProcess->OrphanTotals.CommitVector[NOACCESS];
            pECD->UnassignedReadOnly    = pThisProcess->OrphanTotals.CommitVector[READONLY];
            pECD->UnassignedReadWrite   = pThisProcess->OrphanTotals.CommitVector[READWRITE];
            pECD->UnassignedWriteCopy   = pThisProcess->OrphanTotals.CommitVector[WRITECOPY];
            pECD->UnassignedExecute     = pThisProcess->OrphanTotals.CommitVector[EXECUTE];
            pECD->UnassignedExecuteRead = pThisProcess->OrphanTotals.CommitVector[EXECUTEREAD];
            pECD->UnassignedExecuteWrite = pThisProcess->OrphanTotals.CommitVector[EXECUTEREADWRITE];
            pECD->UnassignedExecuteWriteCopy = pThisProcess->OrphanTotals.CommitVector[EXECUTEWRITECOPY];

            pECD->ImageTotalNoAccess    = pThisProcess->MemTotals.CommitVector[NOACCESS];
            pECD->ImageTotalReadOnly    = pThisProcess->MemTotals.CommitVector[READONLY];
            pECD->ImageTotalReadWrite   = pThisProcess->MemTotals.CommitVector[READWRITE];
            pECD->ImageTotalWriteCopy   = pThisProcess->MemTotals.CommitVector[WRITECOPY];
            pECD->ImageTotalExecute     = pThisProcess->MemTotals.CommitVector[EXECUTE];
            pECD->ImageTotalExecuteRead = pThisProcess->MemTotals.CommitVector[EXECUTEREAD];
            pECD->ImageTotalExecuteWrite = pThisProcess->MemTotals.CommitVector[EXECUTEREADWRITE];
            pECD->ImageTotalExecuteWriteCopy = pThisProcess->MemTotals.CommitVector[EXECUTEWRITECOPY];

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pECD[1];

            pThisProcess = pThisProcess->pNextProcess; // point to next process
        } // end while not at end of list

    } // end if valid process info buffer
    else {
        // pProcessVaInfo is NULL.  Initialize the DataDef and return
        // with no data
        pExProcessDataDefinition = (EXPROCESS_DATA_DEFINITION *)*lppData;

        TotalLen = sizeof(EXPROCESS_DATA_DEFINITION) +
            sizeof (PERF_INSTANCE_DEFINITION) +
            (MAX_PROCESS_NAME_LENGTH + 1) * sizeof (WCHAR) +
            sizeof (DWORD) +
            sizeof (EXPROCESS_COUNTER_DATA);

        if (*lpcbTotalBytes < TotalLen) {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_MORE_DATA;
        }

        // copy process data block to buffer

        memcpy (pExProcessDataDefinition,
                        &ExProcessDataDefinition,
                        sizeof(EXPROCESS_DATA_DEFINITION));

        NumExProcessInstances = 0;

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    &pExProcessDataDefinition[1];

    }

    pExProcessDataDefinition->ExProcessObjectType.NumInstances =
        NumExProcessInstances;

    *lpcbTotalBytes =
        pExProcessDataDefinition->ExProcessObjectType.TotalByteLength =
        (DWORD)((PCHAR) pPerfInstanceDefinition -
        (PCHAR) pExProcessDataDefinition);

    *lppData = (LPVOID) pPerfInstanceDefinition;

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\perfproc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfproc.c

Abstract:

    This file implements an Performance Object that presents
    Image details performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "dataproc.h"

static  BOOL           bOldestProcessTime = FALSE;
static  LARGE_INTEGER  OldestProcessTime = {0,0};


DWORD APIENTRY
CollectProcessObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;

    PPERF_INSTANCE_DEFINITION   pPerfInstanceDefinition;
    PPROCESS_DATA_DEFINITION    pProcessDataDefinition;
    PPROCESS_COUNTER_DATA       pPCD;
    PROCESS_COUNTER_DATA        pcdTotal;

    ULONG   NumProcessInstances;
    BOOLEAN NullProcess;

    PUNICODE_STRING pProcessName;
    ULONG ProcessBufferOffset;

    pProcessDataDefinition = (PROCESS_DATA_DEFINITION *) *lppData;

    //
    //  Check for sufficient space for Process object type definition
    //

    TotalLen = sizeof(PROCESS_DATA_DEFINITION) +
               sizeof (PERF_INSTANCE_DEFINITION) +
               MAX_VALUE_NAME_LENGTH +
               sizeof(PROCESS_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define Process data block
    //

    memcpy(pProcessDataDefinition,
           &ProcessDataDefinition,
           sizeof(PROCESS_DATA_DEFINITION));

    pProcessDataDefinition->ProcessObjectType.PerfTime = PerfTime;

    ProcessBufferOffset = 0;

    // Now collect data for each process

    NumProcessInstances = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pProcessBuffer;

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pProcessDataDefinition[1];

    // adjust TotalLen to be the size of the buffer already in use
    TotalLen = sizeof (PROCESS_DATA_DEFINITION);

    // zero the total instance buffer
    memset (&pcdTotal, 0, sizeof (pcdTotal));

    while ( ProcessInfo != NULL ) {

        // see if this instance will fit
        TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                   ((MAX_PROCESS_NAME_LENGTH+1+sizeof(DWORD)) * sizeof(WCHAR)) +
                   sizeof (PROCESS_COUNTER_DATA);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_MORE_DATA;
        }

        // check for Live processes
        //  (i.e. name or threads)

        pProcessName = NULL;

        if ((ProcessInfo->ImageName.Buffer != NULL) ||
            (ProcessInfo->NumberOfThreads > 0)){
                // thread is not Dead
            // get process name
            if (lProcessNameCollectionMethod == PNCM_MODULE_FILE) {
                pProcessName = GetProcessSlowName (ProcessInfo);
            } else {
               pProcessName = GetProcessShortName (ProcessInfo);
            }
            NullProcess = FALSE;
        } else {
            // thread is dead
            NullProcess = TRUE;
        }

        if ( !NullProcess ) {

            // get the old process creation time the first time we are in
            // this routine
            if (!bOldestProcessTime) {
                if (OldestProcessTime.QuadPart <= 0) {
                    OldestProcessTime = ProcessInfo->CreateTime;
                } else if (ProcessInfo->CreateTime.QuadPart > 0) {
                    // both time values are not zero, see which one is smaller
                    if (OldestProcessTime.QuadPart >
                        ProcessInfo->CreateTime.QuadPart) {
                        OldestProcessTime = ProcessInfo->CreateTime;
                    }
                }
            }

            // get Pool usage for this process

            NumProcessInstances++;

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                (PVOID *) &pPCD,
                0,
                0,
                (DWORD)-1,
                (pProcessName ? pProcessName->Buffer : NULL)
                );

            // test structure for Quadword Alignment
            assert (((DWORD)(pPCD) & 0x00000007) == 0);

            //
            //  Format and collect Process data
            //

            pPCD->CounterBlock.ByteLength = sizeof (PROCESS_COUNTER_DATA);
            //
            //  Convert User time from 100 nsec units to counter frequency.
            //
            pcdTotal.ProcessorTime +=
                pPCD->ProcessorTime = ProcessInfo->KernelTime.QuadPart +
                                    ProcessInfo->UserTime.QuadPart;
            pcdTotal.UserTime +=
                pPCD->UserTime = ProcessInfo->UserTime.QuadPart;
            pcdTotal.KernelTime +=
                pPCD->KernelTime = ProcessInfo->KernelTime.QuadPart;

            pcdTotal.PeakVirtualSize +=
                pPCD->PeakVirtualSize = ProcessInfo->PeakVirtualSize;
            pcdTotal.VirtualSize +=
                pPCD->VirtualSize = ProcessInfo->VirtualSize;

            pcdTotal.PageFaults +=
                pPCD->PageFaults = ProcessInfo->PageFaultCount;
            pcdTotal.PeakWorkingSet +=
                pPCD->PeakWorkingSet = ProcessInfo->PeakWorkingSetSize;
            pcdTotal.TotalWorkingSet +=
                pPCD->TotalWorkingSet = ProcessInfo->WorkingSetSize;

#ifdef _DATAPROC_PRIVATE_WS_
            pcdTotal.PrivateWorkingSet +=
                pPCD->PrivateWorkingSet = ProcessInfo->PrivateWorkingSetSize;
            pcdTotal.SharedWorkingSet +=
                pPCD->SharedWorkingSet =
					ProcessInfo->WorkingSetSize -
					ProcessInfo->PrivateWorkingSetSize;
#endif //_DATAPROC_PRIVATE_WS_

            pcdTotal.PeakPageFile +=
                pPCD->PeakPageFile = ProcessInfo->PeakPagefileUsage;
            pcdTotal.PageFile +=
                pPCD->PageFile = ProcessInfo->PagefileUsage;

            pcdTotal.PrivatePages +=
                pPCD->PrivatePages = ProcessInfo->PrivatePageCount;

            pcdTotal.ThreadCount +=
                pPCD->ThreadCount = ProcessInfo->NumberOfThreads;

            // base priority is not totaled
            pPCD->BasePriority = ProcessInfo->BasePriority;

            // elpased time is not totaled
            if (bOldestProcessTime &&
                (ProcessInfo->CreateTime.QuadPart <= 0)) {
                pPCD->ElapsedTime = OldestProcessTime.QuadPart;
            } else {
                pPCD->ElapsedTime = ProcessInfo->CreateTime.QuadPart;
            }

            pPCD->ProcessId = HandleToUlong(ProcessInfo->UniqueProcessId);
            pPCD->CreatorProcessId = HandleToUlong(ProcessInfo->InheritedFromUniqueProcessId);

            pcdTotal.PagedPool +=
                pPCD->PagedPool = (DWORD)ProcessInfo->QuotaPagedPoolUsage;
            pcdTotal.NonPagedPool +=
                pPCD->NonPagedPool = (DWORD)ProcessInfo->QuotaNonPagedPoolUsage;
            pcdTotal.HandleCount +=
                pPCD->HandleCount = (DWORD)ProcessInfo->HandleCount;

            
            // update I/O counters
            pcdTotal.ReadOperationCount +=
                pPCD->ReadOperationCount = ProcessInfo->ReadOperationCount.QuadPart;
            pcdTotal.DataOperationCount += 
                pPCD->DataOperationCount = ProcessInfo->ReadOperationCount.QuadPart;
            pcdTotal.WriteOperationCount +=
                pPCD->WriteOperationCount = ProcessInfo->WriteOperationCount.QuadPart;
            pcdTotal.DataOperationCount += ProcessInfo->WriteOperationCount.QuadPart;
                pPCD->DataOperationCount += ProcessInfo->WriteOperationCount.QuadPart;
            pcdTotal.OtherOperationCount +=
                pPCD->OtherOperationCount = ProcessInfo->OtherOperationCount.QuadPart;

            pcdTotal.ReadTransferCount +=
                pPCD->ReadTransferCount = ProcessInfo->ReadTransferCount.QuadPart;
            pcdTotal.DataTransferCount +=
                pPCD->DataTransferCount = ProcessInfo->ReadTransferCount.QuadPart;
            pcdTotal.WriteTransferCount +=
                pPCD->WriteTransferCount = ProcessInfo->WriteTransferCount.QuadPart;
            pcdTotal.DataTransferCount += ProcessInfo->WriteTransferCount.QuadPart;
                pPCD->DataTransferCount += ProcessInfo->WriteTransferCount.QuadPart;
            pcdTotal.OtherTransferCount +=
                pPCD->OtherTransferCount = ProcessInfo->OtherTransferCount.QuadPart;
                        
            // set perfdata pointer to next byte
            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pPCD[1];
        }
        // exit if this was the last process in list
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }

        // point to next buffer in list
        ProcessBufferOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                          &pProcessBuffer[ProcessBufferOffset];

    }

    if (NumProcessInstances > 0) {

        // see if the total instance will fit
        TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                    (MAX_PROCESS_NAME_LENGTH+1+sizeof(DWORD))*
                        sizeof(WCHAR) +
                   sizeof (PROCESS_COUNTER_DATA);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_MORE_DATA;
        }

        // it looks like it will fit so create "total" instance

        NumProcessInstances++;

        // set the Total Elapsed Time to be the current time so that it will
        // show up as 0 when displayed.
        pcdTotal.ElapsedTime = pProcessDataDefinition->ProcessObjectType.PerfTime.QuadPart;

        MonBuildInstanceDefinition(pPerfInstanceDefinition,
            (PVOID *) &pPCD,
            0,
            0,
            (DWORD)-1,
            wszTotal);

        // test structure for Quadword Alignment
        assert (((DWORD)(pPCD) & 0x00000007) == 0);

        //
        //  Format and collect Process data
        //
        memcpy (pPCD, &pcdTotal, sizeof (pcdTotal));
        pPCD->CounterBlock.ByteLength = sizeof (PROCESS_COUNTER_DATA);
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pPCD[1];

    }

    // flag so we don't have to get the oldest Process Creation time again.
    bOldestProcessTime = TRUE;

    // Note number of process instances

    pProcessDataDefinition->ProcessObjectType.NumInstances =
        NumProcessInstances;

    //
    //  Now we know how large an area we used for the
    //  Process definition, so we can update the offset
    //  to the next object definition
    //

    *lpcbTotalBytes =
        pProcessDataDefinition->ProcessObjectType.TotalByteLength =
        (DWORD)((PCHAR) pPerfInstanceDefinition -
        (PCHAR) pProcessDataDefinition);

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFPROC: Process Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lppData = (LPVOID) pPerfInstanceDefinition;

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\perfsprc.h ===
#define MAX_PROCESS_NAME_LENGTH (MAX_PATH*sizeof(WCHAR))
#define MAX_THREAD_NAME_LENGTH  (10*sizeof(WCHAR))

//
//  Value to decide if process names should be collected from:
//      the SystemProcessInfo structure (fastest)
//          -- or --
//      the process's image file (slower, but shows Unicode filenames)
//
#define PNCM_NOT_DEFINED    ((LONG)-1)
#define PNCM_SYSTEM_INFO    0L
#define PNCM_MODULE_FILE    1L
extern  LONG    lProcessNameCollectionMethod;

#define IDLE_PROCESS_ID     ((DWORD)0)
#define SYSTEM_PROCESS_ID   ((DWORD)7)

//
// Process/Thread name format
//
#define NAME_FORMAT_BLANK           1           // Nothing appended
#define NAME_FORMAT_ID              2           // PID/TID appended

#define NAME_FORMAT_DEFAULT         1           // Default to what it used to be

//
//  VA structures & defines
//
#define NOACCESS            0
#define READONLY            1
#define READWRITE           2
#define WRITECOPY           3
#define EXECUTE             4
#define EXECUTEREAD         5
#define EXECUTEREADWRITE    6
#define EXECUTEWRITECOPY    7
#define MAXPROTECT          8

typedef struct _MODINFO {
    PVOID   BaseAddress;
    ULONG_PTR VirtualSize;
    PUNICODE_STRING InstanceName;
    PUNICODE_STRING LongInstanceName;
    ULONG_PTR TotalCommit;
    ULONG_PTR CommitVector[MAXPROTECT];
    struct _MODINFO   *pNextModule;
} MODINFO, *PMODINFO;

typedef struct _PROCESS_VA_INFO {
    PUNICODE_STRING      pProcessName;
    HANDLE               hProcess;
    ULONG_PTR             dwProcessId;
    //  process VA information
    PPROCESS_BASIC_INFORMATION BasicInfo;
    //  process VA statistics
    ULONG_PTR            ImageReservedBytes;
    ULONG_PTR            ImageFreeBytes;
    ULONG_PTR            ReservedBytes;
    ULONG_PTR            FreeBytes;
    ULONG_PTR            MappedGuard;
    ULONG_PTR            MappedCommit[MAXPROTECT];
    ULONG_PTR            PrivateGuard;
    ULONG_PTR            PrivateCommit[MAXPROTECT];
    //  process image statistics
    PMODINFO            pMemBlockInfo;  // pointer to image list
    MODINFO             OrphanTotals;   // blocks with no image
    MODINFO             MemTotals;      // sum of image data
    DWORD               LookUpTime;
    struct _PROCESS_VA_INFO    *pNextProcess;
} PROCESS_VA_INFO, *PPROCESS_VA_INFO;

extern PPROCESS_VA_INFO     pProcessVaInfo;    // list head

extern const WCHAR IDLE_PROCESS[];
extern const WCHAR SYSTEM_PROCESS[];

extern  PUNICODE_STRING pusLocalProcessNameBuffer;

extern  HANDLE                          hEventLog;       // handle to event log
extern  HANDLE                          hLibHeap;       // local heap
extern  LPWSTR  wszTotal;

extern  LPBYTE                          pProcessBuffer;
extern  LARGE_INTEGER                   PerfTime;

PM_LOCAL_COLLECT_PROC CollectProcessObjectData;
PM_LOCAL_COLLECT_PROC CollectThreadObjectData;
PM_LOCAL_COLLECT_PROC CollectHeapObjectData;
PM_LOCAL_COLLECT_PROC CollectExProcessObjectData;
PM_LOCAL_COLLECT_PROC CollectImageObjectData;
PM_LOCAL_COLLECT_PROC CollectLongImageObjectData;
PM_LOCAL_COLLECT_PROC CollectThreadDetailsObjectData;
PM_LOCAL_COLLECT_PROC CollectJobObjectData;
PM_LOCAL_COLLECT_PROC CollectJobDetailData;

PUNICODE_STRING
GetProcessShortName (
    PSYSTEM_PROCESS_INFORMATION pProcess
);

PUNICODE_STRING
GetProcessSlowName (
    PSYSTEM_PROCESS_INFORMATION pProcess
);

BOOL
GetProcessExeName(
    HANDLE  hProcessID,
    PUNICODE_STRING pusName
);

PPROCESS_VA_INFO
GetSystemVaData (
    IN PSYSTEM_PROCESS_INFORMATION
);

BOOL
FreeSystemVaData (
    IN PPROCESS_VA_INFO
);

ULONG
PerfIntegerToWString(
    IN ULONG Value,
    IN ULONG Base,
    IN LONG OutputLength,
    OUT LPWSTR String
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\perfsprc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfsprc.c

Abstract:


Author:

    Bob Watson (a-robw) Aug 95

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wchar.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfsprc.h"
#include "procmsg.h"

#include "dataheap.h" 


// bit field definitions for collect function flags
#define POS_READ_SYS_PROCESS_DATA       ((DWORD)0x00010000)
#define POS_READ_PROCESS_VM_DATA        ((DWORD)0x00020000)
#define	POS_READ_JOB_OBJECT_DATA		((DWORD)0x00040000)
#define POS_READ_JOB_DETAIL_DATA		((DWORD)0x00080000)
#define POS_READ_HEAP_DATA		        ((DWORD)0x00100000)

#define POS_COLLECT_PROCESS_DATA        ((DWORD)0x00010001)
#define POS_COLLECT_THREAD_DATA         ((DWORD)0x00010003)
#define POS_COLLECT_EXPROCESS_DATA      ((DWORD)0x00030004)
#define POS_COLLECT_IMAGE_DATA          ((DWORD)0x0003000C)
#define POS_COLLECT_LONG_IMAGE_DATA     ((DWORD)0x00030014)
#define POS_COLLECT_THREAD_DETAILS_DATA ((DWORD)0x00030024)
#define POS_COLLECT_JOB_OBJECT_DATA		((DWORD)0x00050040)
#define POS_COLLECT_JOB_DETAIL_DATA		((DWORD)0x000D00C1)
#define POS_COLLECT_HEAP_DATA           ((DWORD)0x00110101) 

#define POS_COLLECT_FUNCTION_MASK       ((DWORD)0x000001FF)

#define POS_COLLECT_GLOBAL_DATA         ((DWORD)0x001501C3)
#define POS_COLLECT_GLOBAL_NO_HEAP      ((DWORD)0x000500C3)
#define POS_COLLECT_FOREIGN_DATA        ((DWORD)0)
#define POS_COLLECT_COSTLY_DATA         ((DWORD)0x0003003C)

// global variables to this DLL

HANDLE  ThisDLLHandle = NULL;
HANDLE  hEventLog     = NULL;
LPWSTR  wszTotal = NULL;
HANDLE  hLibHeap = NULL;

LPBYTE  pProcessBuffer = NULL;
PPROCESS_VA_INFO     pProcessVaInfo = NULL;
PUNICODE_STRING pusLocalProcessNameBuffer = NULL;

LARGE_INTEGER PerfTime = {0,0};

const WCHAR IDLE_PROCESS[] = L"Idle";
const WCHAR SYSTEM_PROCESS[] = L"System";

const WCHAR szPerflibSubKey[] = L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
const WCHAR szPerfProcSubKey[] = L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\PerfProc\\Performance";

const WCHAR szDisplayHeapPerfObject[] = L"DisplayHeapPerfObject";
const WCHAR szProcessNameFormat[] = L"ProcessNameFormat";
const WCHAR szThreadNameFormat[] = L"ThreadNameFormat";

BOOL    PerfSprc_DisplayHeapPerfObject = FALSE;
DWORD   PerfSprc_dwProcessNameFormat = NAME_FORMAT_DEFAULT;
DWORD   PerfSprc_dwThreadNameFormat = NAME_FORMAT_DEFAULT;

extern DWORD bOpenJobErrorLogged;

//
//  Value to decide if process names should be collected from:
//      the SystemProcessInfo structure (fastest)
//          -- or --
//      the process's image file (slower, but shows Unicode filenames)
//
LONG    lProcessNameCollectionMethod = PNCM_NOT_DEFINED;

// variables local to this module

static POS_FUNCTION_INFO    posDataFuncInfo[] = {
    {PROCESS_OBJECT_TITLE_INDEX,    POS_COLLECT_PROCESS_DATA,   0,  CollectProcessObjectData},
    {THREAD_OBJECT_TITLE_INDEX,     POS_COLLECT_THREAD_DATA,    0,  CollectThreadObjectData},
    {EXPROCESS_OBJECT_TITLE_INDEX,  POS_COLLECT_EXPROCESS_DATA, 0,  CollectExProcessObjectData},
    {IMAGE_OBJECT_TITLE_INDEX,      POS_COLLECT_IMAGE_DATA,     0,  CollectImageObjectData},
    {LONG_IMAGE_OBJECT_TITLE_INDEX, POS_COLLECT_LONG_IMAGE_DATA,0,  CollectLongImageObjectData},
    {THREAD_DETAILS_OBJECT_TITLE_INDEX, POS_COLLECT_THREAD_DETAILS_DATA, 0, CollectThreadDetailsObjectData},
	{JOB_OBJECT_TITLE_INDEX,		POS_COLLECT_JOB_OBJECT_DATA, 0,	CollectJobObjectData},
	{JOB_DETAILS_OBJECT_TITLE_INDEX, POS_COLLECT_JOB_DETAIL_DATA, 0, CollectJobDetailData},
    {HEAP_OBJECT_TITLE_INDEX,       POS_COLLECT_HEAP_DATA,      0,  CollectHeapObjectData}
};

#define POS_NUM_FUNCS   (sizeof(posDataFuncInfo) / sizeof(posDataFuncInfo[1]))

static  BOOL    bInitOk  = FALSE;
static  DWORD   dwOpenCount = 0;
static  DWORD   ProcessBufSize = LARGE_BUFFER_SIZE;

PM_OPEN_PROC    OpenSysProcessObject;
PM_COLLECT_PROC CollecSysProcessObjectData;
PM_CLOSE_PROC   CloseSysProcessObject;

__inline
VOID
PerfpQuerySystemTime(
    IN PLARGE_INTEGER SystemTime
    )
{
    do {
        SystemTime->HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime->LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime->HighPart != USER_SHARED_DATA->SystemTime.High2Time);

}


BOOL
GetProcessExeName(
    HANDLE  hProcessID,
    PUNICODE_STRING pusName
)
{
    HANDLE                  hProcess;
    OBJECT_ATTRIBUTES       obProcess;
    CLIENT_ID               ClientId;
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PPEB Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    PLDR_DATA_TABLE_ENTRY   LdrEntry;
    LDR_DATA_TABLE_ENTRY    LdrEntryData;
    BOOL                    bReturn;
    WCHAR                   wszDllName[MAX_PATH];

    // open process for reading
    // get handle to process

    ClientId.UniqueThread = (HANDLE)NULL;
    ClientId.UniqueProcess = hProcessID;

    InitializeObjectAttributes(
        &obProcess,
        NULL,
        0,
        NULL,
        NULL
        );

    Status = NtOpenProcess(
        &hProcess,
        (ACCESS_MASK)PROCESS_ALL_ACCESS,
        &obProcess,
        &ClientId);

    if (! NT_SUCCESS(Status)){
        // unable to open the process,
        return FALSE;
    }

    // Get the process information

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        bReturn = FALSE;
    } else {
        Peb = BasicInfo.PebBaseAddress;

        //
        // get the loader information block
        //
        // Ldr = Peb->Ldr
        //

        if (!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL)) {
            // unable to read loader information
            bReturn = FALSE;
        } else {
            LdrHead = &Ldr->InMemoryOrderModuleList;

            //
            //  get the first memory block listed. this is the .EXE in NT
            //
            if (!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL)) {
                // unable to read memory link
                bReturn = FALSE;
            } else {
                LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

                if (!ReadProcessMemory(hProcess, LdrEntry, &LdrEntryData, sizeof(LdrEntryData), NULL)) {
                    // unable to read image header
                    bReturn = FALSE;
                } else {
                    if (!ReadProcessMemory(hProcess,
                        LdrEntryData.BaseDllName.Buffer,
                        (LPVOID)&wszDllName[0],
                        sizeof(wszDllName), NULL)) {
                        // unable to read DLL buffer
                        bReturn = FALSE;
                    } else {
                        // copy the short name to the caller's buffer
                        RtlInitUnicodeString (
                            pusName,
                            wszDllName);
                        SetLastError(ERROR_SUCCESS);
                    }
                }
            }
        }
        NtClose (hProcess);
    }

    return TRUE;
}

LONG
GetProcessNameColMeth (
    VOID
)
{
    NTSTATUS            Status;
    HANDLE              hPerflibKey;
    OBJECT_ATTRIBUTES   oaPerflibKey;
    UNICODE_STRING      PerflibSubKeyString;
    UNICODE_STRING      NameInfoValueString;
    LONG                lReturn = PNCM_SYSTEM_INFO;
    PKEY_VALUE_PARTIAL_INFORMATION    pKeyInfo;
    DWORD               dwBufLen;
    DWORD               dwRetBufLen;
    PDWORD              pdwValue;

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        szPerflibSubKey);

    InitializeObjectAttributes(
            &oaPerflibKey,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                MAXIMUM_ALLOWED,
                &oaPerflibKey
                );

    if (NT_SUCCESS (Status)) {
        // registry key opened, now read value.
        // allocate enough room for the structure, - the last
        // UCHAR in the struct, but + the data buffer (a dword)

        dwBufLen = sizeof(KEY_VALUE_PARTIAL_INFORMATION) -
            sizeof(UCHAR) + sizeof (DWORD);

        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ALLOCMEM (
            hLibHeap,
            HEAP_ZERO_MEMORY,
            dwBufLen);

        if (pKeyInfo != NULL) {
            // initialize value name string
            RtlInitUnicodeString (
                &NameInfoValueString,
                (LPCWSTR)L"CollectUnicodeProcessNames");

            dwRetBufLen = 0;
            Status = NtQueryValueKey (
                hPerflibKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                // check value of return data buffer
                pdwValue = (PDWORD)&pKeyInfo->Data[0];
                if (*pdwValue == PNCM_MODULE_FILE) {
                    lReturn = PNCM_MODULE_FILE;
                } else {
                    // all other values will cause this routine to return
                    // the default value of PNCM_SYSTEM_INFO;
                }
            }

            FREEMEM (hLibHeap, 0, pKeyInfo);
        }
        // close handle
        NtClose (hPerflibKey);
    }

    return lReturn;
}

VOID
PerfProcGlobalSettings (
    VOID
)
{
    NTSTATUS            Status;
    HANDLE              hPerfProcKey;
    OBJECT_ATTRIBUTES   oaPerfProcKey;
    UNICODE_STRING      PerfProcSubKeyString;
    UNICODE_STRING      NameInfoValueString;
    PKEY_VALUE_PARTIAL_INFORMATION    pKeyInfo;
    DWORD               dwBufLen;
    DWORD               dwRetBufLen;
    PDWORD              pdwValue;

    PerfpQuerySystemTime(&PerfTime);

    RtlInitUnicodeString (
        &PerfProcSubKeyString,
        szPerfProcSubKey);

    InitializeObjectAttributes(
            &oaPerfProcKey,
            &PerfProcSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerfProcKey,
                MAXIMUM_ALLOWED,
                &oaPerfProcKey
                );

    if (NT_SUCCESS (Status)) {
        // registry key opened, now read value.
        // allocate enough room for the structure, - the last
        // UCHAR in the struct, but + the data buffer (a dword)

        dwBufLen = sizeof(KEY_VALUE_PARTIAL_INFORMATION) -
            sizeof(UCHAR) + sizeof (DWORD);

        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ALLOCMEM (
            hLibHeap,
            HEAP_ZERO_MEMORY,
            dwBufLen);

        if (pKeyInfo != NULL) {
            // initialize value name string
            RtlInitUnicodeString (
                &NameInfoValueString,
                szDisplayHeapPerfObject);

            dwRetBufLen = 0;
            Status = NtQueryValueKey (
                hPerfProcKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                // check value of return data buffer
                pdwValue = (PDWORD)&pKeyInfo->Data[0];
                if (*pdwValue == 1) {
                    PerfSprc_DisplayHeapPerfObject = TRUE;
                } else {
                    // all other values will cause this routine to return
                    // the default value of FALSE 
                }
            }

            RtlInitUnicodeString(
                &NameInfoValueString,
                szProcessNameFormat);
            dwRetBufLen = 0;
            Status = NtQueryValueKey(
                hPerfProcKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                pdwValue = (PDWORD) &pKeyInfo->Data[0];
                PerfSprc_dwProcessNameFormat = *pdwValue;
            }

            RtlInitUnicodeString(
                &NameInfoValueString,
                szThreadNameFormat);
            dwRetBufLen = 0;
            Status = NtQueryValueKey(
                hPerfProcKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                pdwValue = (PDWORD) &pKeyInfo->Data[0];
                PerfSprc_dwThreadNameFormat = *pdwValue;
            }

            FREEMEM (hLibHeap, 0, pKeyInfo);
        }
        // close handle
        NtClose (hPerfProcKey);
    }
    if ((PerfSprc_dwProcessNameFormat < NAME_FORMAT_BLANK) ||
        (PerfSprc_dwProcessNameFormat > NAME_FORMAT_ID))
        PerfSprc_dwProcessNameFormat = NAME_FORMAT_DEFAULT;
    if ((PerfSprc_dwThreadNameFormat < NAME_FORMAT_BLANK) ||
        (PerfSprc_dwThreadNameFormat > NAME_FORMAT_ID))
        PerfSprc_dwThreadNameFormat = NAME_FORMAT_DEFAULT;
}

BOOL
DllProcessAttach (
    IN  HANDLE DllHandle
)
/*++

Description:

    perform any initialization function that apply to all object
    modules

--*/
{
    BOOL    bReturn = TRUE;
    WCHAR   wszTempBuffer[512];
    LONG    lStatus;
    DWORD   dwBufferSize;

    UNREFERENCED_PARAMETER (DllHandle);

    // open handle to the event log
    if (hEventLog == NULL) {
        hEventLog = MonOpenEventLog((LPWSTR)L"PerfProc");

        // create the local heap
        hLibHeap = HeapCreate (0, 1, 0);

        if (hLibHeap == NULL) {
            return FALSE;
        }

        if (lProcessNameCollectionMethod == PNCM_NOT_DEFINED) {
            // get desired process name collection method as defined in the
            // registry
            lProcessNameCollectionMethod = GetProcessNameColMeth ();
        }
    }

    lStatus = GetPerflibKeyValue (
        szTotalValue,
        REG_SZ,
        sizeof(wszTempBuffer),
        (LPVOID)&wszTempBuffer[0],
        DEFAULT_TOTAL_STRING_LEN,
        (LPVOID)&szDefaultTotalString[0]);

    if (lStatus == ERROR_SUCCESS) {
        // then a string was returned in the temp buffer
        dwBufferSize = lstrlenW (wszTempBuffer) + 1;
        dwBufferSize *= sizeof (WCHAR);
        wszTotal = ALLOCMEM (hLibHeap, HEAP_ZERO_MEMORY, dwBufferSize);
        if (wszTotal == NULL) {
            // unable to allocate buffer so use static buffer
            wszTotal = (LPWSTR)&szDefaultTotalString[0];
        } else {
            memcpy (wszTotal, wszTempBuffer, dwBufferSize);
        }
    } else {
        // unable to get string from registry so just use static buffer
        wszTotal = (LPWSTR)&szDefaultTotalString[0];
    }

    return bReturn;
}

BOOL
DllProcessDetach (
    IN  HANDLE DllHandle
)
{
    UNREFERENCED_PARAMETER (DllHandle);

    if (dwOpenCount > 0) {
        // the Library is being unloaded before it was
        // closed so close it now as this is the last
        // chance to do it before the library is tossed.
        // if the value of dwOpenCount is > 1, set it to
        // one to insure everything will be closed when
        // the close function is called.
        if (dwOpenCount > 1) dwOpenCount = 1;
        CloseSysProcessObject();
    }

    if ((wszTotal != NULL) && (wszTotal != &szDefaultTotalString[0])) {
        FREEMEM (hLibHeap, 0, wszTotal);
        wszTotal = NULL;
    }

    if (HeapDestroy (hLibHeap)) hLibHeap = NULL;

    if (hEventLog != NULL) {
        MonCloseEventLog ();
    }

    return TRUE;
}

BOOL
__stdcall
DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    ReservedAndUnused;

    // this will prevent the DLL from getting
    // the DLL_THREAD_* messages
    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            return DllProcessAttach (DLLHandle);

        case DLL_PROCESS_DETACH:
            return DllProcessDetach (DLLHandle);

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            return TRUE;
    }
}

PUNICODE_STRING
GetProcessSlowName (
    PSYSTEM_PROCESS_INFORMATION pProcess
)
/*++

GetProcessSlowName

Inputs:
    PSYSTEM_PROCESS_INFORMATION pProcess

    address of System Process Information data structure.

Outputs:

    None

Returns:

    Pointer to an initialized Unicode string (created by this routine)
    that contains the short name of the process image or a numeric ID
    if no name is found.

    If unable to allocate memory for structure, then NULL is returned.

--*/
{
    PWCHAR  pPeriod;
    PWCHAR  pThisChar;

    WORD    wStringSize;

    WORD    wThisChar;
    WORD    wLength;

    // this routine assumes that the allocated memory has been zero'd

    if (pusLocalProcessNameBuffer == NULL) {
        // allocate Unicode String Structure and adjacent buffer  first
        wLength = MAX_INSTANCE_NAME * sizeof(WCHAR);
        if (pProcess->ImageName.Length > 0) {
            if (wLength < pProcess->ImageName.Length) {
                wLength = pProcess->ImageName.Length;
            }
        }
        wStringSize = sizeof(UNICODE_STRING) + wLength + 64 + (WORD) sizeof(UNICODE_NULL);

        pusLocalProcessNameBuffer =
            ALLOCMEM (hLibHeap,
            HEAP_ZERO_MEMORY, // this will only 0 the buffer the first time!
            (DWORD)wStringSize);
        if (pusLocalProcessNameBuffer == NULL) {
            return NULL;
        } else {
            pusLocalProcessNameBuffer->MaximumLength = (WORD)(wStringSize - (WORD)(sizeof (UNICODE_STRING)));
        }
    }
    else {
        wStringSize = pusLocalProcessNameBuffer->MaximumLength;
    }
    pusLocalProcessNameBuffer->Length = 0;
    pusLocalProcessNameBuffer->Buffer = (PWCHAR)&pusLocalProcessNameBuffer[1];

    memset (     // buffer must be zero'd so we'll have a NULL Term
        pusLocalProcessNameBuffer->Buffer, 0,
        (DWORD)pusLocalProcessNameBuffer->MaximumLength);

    // get the process name from the image file

    GetProcessExeName (pProcess->UniqueProcessId, pusLocalProcessNameBuffer);

    if (pusLocalProcessNameBuffer->Length > 0) {   // some name has been defined

        pPeriod = (PWCHAR)pusLocalProcessNameBuffer->Buffer;
        pThisChar = (PWCHAR)pusLocalProcessNameBuffer->Buffer;
        wThisChar = 0;

        //
        //  go from beginning to end and find last backslash and
        //  last period in name
        //

        while (*pThisChar != 0) { // go until null
            if (*pThisChar == L'.') {
                pPeriod = pThisChar;
            }
            pThisChar++;    // point to next char
            wThisChar += sizeof(WCHAR);
            if (wThisChar >= pusLocalProcessNameBuffer->Length) {
                break;
            }
        }

        // if pPeriod is still pointing to the beginning of the
        // string, then no period was found

        if (pPeriod == (PWCHAR)pusLocalProcessNameBuffer->Buffer) {
            pPeriod = pThisChar; // set to end of string;
        } else {
            // if a period was found, then see if the extension is
            // .EXE, if so leave it, if not, then use end of string
            // (i.e. include extension in name)

            if (lstrcmpiW(pPeriod, (LPCWSTR)L".EXE") != 0) {
                pPeriod = pThisChar;
            }
        }

        // copy characters between period (or end of string) and
        // slash (or start of string) to make image name

        wStringSize = (WORD)((PCHAR)pPeriod - (PCHAR)pusLocalProcessNameBuffer->Buffer);
        wLength = pusLocalProcessNameBuffer->MaximumLength - sizeof(UNICODE_NULL);
        if (wStringSize >= wLength) {
            wStringSize = wLength;
        }
        *pPeriod = 0; // null terminate buffer
        if ((PerfSprc_dwProcessNameFormat == NAME_FORMAT_ID) &&
            (wStringSize < (wLength - 10))) {
            ULONG Length;
            Length = PerfIntegerToWString(
                        HandleToUlong(pProcess->UniqueProcessId),
                        10,
                        (pusLocalProcessNameBuffer->MaximumLength - wStringSize)
                            / sizeof(WCHAR),
                        pPeriod+1);
            if (Length > 0)
                *pPeriod = L'_';
            wStringSize += (WORD) (Length * sizeof(WCHAR));
        }
        pusLocalProcessNameBuffer->Length = wStringSize; // adjust length

    } else {    // no name defined so use Process #

        // check  to see if this is a system process and give it
        // a name

        switch (HandleToUlong(pProcess->UniqueProcessId)) {
            case IDLE_PROCESS_ID:
                RtlAppendUnicodeToString (pusLocalProcessNameBuffer,
                    (LPWSTR)IDLE_PROCESS);
                break;

            case SYSTEM_PROCESS_ID:
                RtlAppendUnicodeToString (pusLocalProcessNameBuffer,
                    (LPWSTR)SYSTEM_PROCESS);
                break;

            // if the id is not a system process, then use the id as the name

            default:
            // try accessing via the "regular" interface
            return (GetProcessShortName (pProcess));

                break;
        }
    }

    return pusLocalProcessNameBuffer;
}

PUNICODE_STRING
GetProcessShortName (
    PSYSTEM_PROCESS_INFORMATION pProcess
)
/*++

GetProcessShortName

Inputs:
    PSYSTEM_PROCESS_INFORMATION pProcess

    address of System Process Information data structure.

Outputs:

    None

Returns:

    Pointer to an initialized Unicode string (created by this routine)
    that contains the short name of the process image or a numeric ID
    if no name is found.

    If unable to allocate memory for structure, then NULL is returned.

--*/
{
    PWCHAR  pSlash;
    PWCHAR  pPeriod;
    PWCHAR  pThisChar;

    WORD    wStringSize;

    WORD    wThisChar;
    ULONG   ProcessId;
    WORD    wLength;

    // this routine assumes that the allocated memory has been zero'd

    if (pusLocalProcessNameBuffer == NULL) {
        // allocate Unicode String Structure and adjacent buffer  first
        wLength = MAX_INSTANCE_NAME * sizeof(WCHAR);
        if (pProcess->ImageName.Length > 0) {
            if (wLength < pProcess->ImageName.Length) {
                wLength = pProcess->ImageName.Length;
            }
        }
        wStringSize = sizeof(UNICODE_STRING) + wLength + 64 + (WORD) sizeof(UNICODE_NULL);

        pusLocalProcessNameBuffer =
            ALLOCMEM (hLibHeap,
            HEAP_ZERO_MEMORY, // this will only 0 the buffer the first time!
            (DWORD)wStringSize);

        if (pusLocalProcessNameBuffer == NULL) {
            return NULL;
        } else {
            pusLocalProcessNameBuffer->MaximumLength = (WORD)(wStringSize - (WORD)sizeof (UNICODE_STRING));
        }
    }
    else {
        wStringSize = pusLocalProcessNameBuffer->MaximumLength;
    }
    pusLocalProcessNameBuffer->Length = 0;
    pusLocalProcessNameBuffer->Buffer = (PWCHAR)&pusLocalProcessNameBuffer[1];

    memset (     // buffer must be zero'd so we'll have a NULL Term
        pusLocalProcessNameBuffer->Buffer, 0,
        (DWORD)pusLocalProcessNameBuffer->MaximumLength);

    ProcessId = HandleToUlong(pProcess->UniqueProcessId);
    if (pProcess->ImageName.Buffer) {   // some name has been defined

        pSlash = (PWCHAR)pProcess->ImageName.Buffer;
        pPeriod = (PWCHAR)pProcess->ImageName.Buffer;
        pThisChar = (PWCHAR)pProcess->ImageName.Buffer;
        wThisChar = 0;

        //
        //  go from beginning to end and find last backslash and
        //  last period in name
        //

        while (*pThisChar != 0) { // go until null
            if (*pThisChar == L'\\') {
                pSlash = pThisChar;
            } else if (*pThisChar == L'.') {
                pPeriod = pThisChar;
            }
            pThisChar++;    // point to next char
            wThisChar += sizeof(WCHAR);
            if (wThisChar >= pProcess->ImageName.Length) {
                break;
            }
        }

        // if pPeriod is still pointing to the beginning of the
        // string, then no period was found

        if (pPeriod == (PWCHAR)pProcess->ImageName.Buffer) {
            pPeriod = pThisChar; // set to end of string;
        } else {
            // if a period was found, then see if the extension is
            // .EXE, if so leave it, if not, then use end of string
            // (i.e. include extension in name)

            if (lstrcmpiW(pPeriod, (LPCWSTR)L".EXE") != 0) {
                pPeriod = pThisChar;
            }
        }

        if (*pSlash == L'\\') { // if pSlash is pointing to a slash, then
            pSlash++;   // point to character next to slash
        }

        // copy characters between period (or end of string) and
        // slash (or start of string) to make image name

        wStringSize = (WORD)((PCHAR)pPeriod - (PCHAR)pSlash); // size in bytes
        wLength = pusLocalProcessNameBuffer->MaximumLength - sizeof(UNICODE_NULL);
        if (wStringSize >= wLength) {
            wStringSize = wLength;
        }

        memcpy (pusLocalProcessNameBuffer->Buffer, pSlash, wStringSize);

        // null terminate is
        // not necessary because allocated memory is zero-init'd
        pPeriod = (PWCHAR) ((PCHAR) pusLocalProcessNameBuffer->Buffer + wStringSize);
        if (PerfSprc_dwProcessNameFormat == NAME_FORMAT_ID) {
            ULONG Length;
            Length = PerfIntegerToWString(
                        ProcessId,
                        10,
                        (pusLocalProcessNameBuffer->MaximumLength - wStringSize)
                            / sizeof(WCHAR),
                        pPeriod+1);
            if (Length > 0)
                *pPeriod = L'_';
            wStringSize += (WORD) (Length * sizeof(WCHAR));
        }
        pusLocalProcessNameBuffer->Length = wStringSize;
    } else {    // no name defined so use Process #

        // check  to see if this is a system process and give it
        // a name

        switch (ProcessId) {
            case IDLE_PROCESS_ID:
                RtlAppendUnicodeToString (pusLocalProcessNameBuffer,
                    (LPWSTR)IDLE_PROCESS);
                break;

            case SYSTEM_PROCESS_ID:
                RtlAppendUnicodeToString (pusLocalProcessNameBuffer,
                    (LPWSTR)SYSTEM_PROCESS);
                break;

            // if the id is not a system process, then use the id as the name

            default:
                RtlIntegerToUnicodeString (ProcessId,
                    10,
                    pusLocalProcessNameBuffer);

                break;
        }


    }

    return pusLocalProcessNameBuffer;
}

#pragma warning (disable : 4706)

DWORD
GetSystemProcessData (
)
{
    DWORD   dwReturnedBufferSize;
    NTSTATUS Status;
    DWORD WinError;
    PVOID pBuffer;

    //
    //  Get process data from system.
    //  if bGotProcessInfo is TRUE, that means we have the process
    //  info. collected earlier when we are checking for costly
    //  object types.
    //
    if (pProcessBuffer == NULL) {
        // allocate a new block
        pProcessBuffer = ALLOCMEM (hLibHeap, HEAP_ZERO_MEMORY,
            ProcessBufSize);
        if (pProcessBuffer == NULL) {
            return ERROR_OUTOFMEMORY;
        }
    }

    PerfpQuerySystemTime(&PerfTime);
    while( (Status = NtQuerySystemInformation(
                            SystemProcessInformation,
                            pProcessBuffer,
                            ProcessBufSize,
                            &dwReturnedBufferSize)) == STATUS_INFO_LENGTH_MISMATCH ) {
        // expand buffer & retry
        ProcessBufSize += INCREMENT_BUFFER_SIZE;

        pBuffer = pProcessBuffer;
        if ( !(pProcessBuffer = REALLOCMEM(hLibHeap, 0,
                                                    pProcessBuffer,
                                                    ProcessBufSize)) ) {
            FREEMEM(hLibHeap, 0, pBuffer);
            return (ERROR_OUTOFMEMORY);
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        // convert to win32 error
        WinError = (DWORD)RtlNtStatusToDosError(Status);
    }
    else {
        WinError = ERROR_SUCCESS;
    }

    return (WinError);

}
#pragma warning (default : 4706)

DWORD APIENTRY
OpenSysProcessObject (
    LPWSTR lpDeviceNames
    )
/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
{
    DWORD   status, dwSize;
    HKEY    hKey;
    
    UNREFERENCED_PARAMETER (lpDeviceNames);

    if (dwOpenCount == 0) {
        // clear the job object open error flag
        bOpenJobErrorLogged = FALSE;
        PerfProcGlobalSettings();
    }

    dwOpenCount++;

    bInitOk = TRUE;

    return  ERROR_SUCCESS;
}

DWORD APIENTRY
CollectSysProcessObjectData (
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN       LPWSTR   lpValueName
            pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;

    NTSTATUS    status;

    // build bit mask of functions to call

    DWORD       dwQueryType;
    DWORD       FunctionCallMask = 0;
    DWORD       FunctionIndex;

    DWORD       dwNumObjectsFromFunction;
    DWORD       dwOrigBuffSize;
    DWORD       dwByteSize;

    if (!bInitOk) {
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFPROC_NOT_OPEN,
            NULL,
            0,
            0,
            NULL,
            NULL);
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        lReturn = ERROR_SUCCESS;
        goto COLLECT_BAIL_OUT;
    }

    dwQueryType = GetQueryType (lpValueName);

    switch (dwQueryType) {
        case QUERY_ITEMS:
            for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
                if (IsNumberInUnicodeList (
                    posDataFuncInfo[FunctionIndex].dwObjectId, lpValueName)) {
                    FunctionCallMask |=
                        posDataFuncInfo[FunctionIndex].dwCollectFunctionBit;
                }
            }
            break;

        case QUERY_GLOBAL:
            // only return the HEAP data in a global query if it's enabled
            // if they ask for it specifically, then it's OK
            if (PerfSprc_DisplayHeapPerfObject) {
                FunctionCallMask = POS_COLLECT_GLOBAL_DATA;
            } else {
                // filter out the heap perf object
                FunctionCallMask = POS_COLLECT_GLOBAL_NO_HEAP;
            }
            break;

        case QUERY_FOREIGN:
            FunctionCallMask = POS_COLLECT_FOREIGN_DATA;
            break;

        case QUERY_COSTLY:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;

        default:
            FunctionCallMask = POS_COLLECT_COSTLY_DATA;
            break;
    }

    // collect data  from system
    if (FunctionCallMask & POS_READ_SYS_PROCESS_DATA) {
        status = GetSystemProcessData ();

        if (!NT_SUCCESS(status)) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFPROC_UNABLE_QUERY_PROCESS_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
        }
    } else {
        status = ERROR_SUCCESS;
    }
    
    // collect data  from system
    if ((status == ERROR_SUCCESS) &&
        (pProcessBuffer != NULL) &&
        (FunctionCallMask & POS_READ_PROCESS_VM_DATA)) {
         pProcessVaInfo = GetSystemVaData (
              (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer);
        // call function

        if (pProcessVaInfo == NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                PERFPROC_UNABLE_QUERY_VM_INFO,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&status);
            // zero buffer
        }
    } else {
        // zero buffer
    }

    // collect data
    *lpNumObjectTypes = 0;
    dwOrigBuffSize = dwByteSize = *lpcbTotalBytes;
    *lpcbTotalBytes = 0;

    // remove query bits
    FunctionCallMask &= POS_COLLECT_FUNCTION_MASK;

    for (FunctionIndex = 0; FunctionIndex < POS_NUM_FUNCS; FunctionIndex++) {
        if ((posDataFuncInfo[FunctionIndex].dwCollectFunctionBit & FunctionCallMask) == 
            (posDataFuncInfo[FunctionIndex].dwCollectFunctionBit & POS_COLLECT_FUNCTION_MASK)) {
            dwNumObjectsFromFunction = 0;
            lReturn = (*posDataFuncInfo[FunctionIndex].pCollectFunction) (
                lppData,
                &dwByteSize,
                &dwNumObjectsFromFunction);

            if (lReturn == ERROR_SUCCESS) {
                *lpNumObjectTypes += dwNumObjectsFromFunction;
                *lpcbTotalBytes += dwByteSize;
                dwOrigBuffSize -= dwByteSize;
                dwByteSize = dwOrigBuffSize;
            } else {
                break;
            }
        }
    }

    // this list of data must be freed after use
    if (pProcessVaInfo != NULL) {

        FreeSystemVaData (pProcessVaInfo);
        pProcessVaInfo = NULL;

    }


    // *lppData is updated by each function
    // *lpcbTotalBytes is updated after each successful function
    // *lpNumObjects is updated after each successful function

COLLECT_BAIL_OUT:

    return lReturn;
}

DWORD APIENTRY
CloseSysProcessObject (
)
/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    DWORD   status = ERROR_SUCCESS;
    PVOID   buffer;

    if (--dwOpenCount == 0) {
        if (hLibHeap != NULL) {
            // close
            if (pProcessBuffer != NULL) {
                buffer = pProcessBuffer;
                pProcessBuffer = NULL;
                FREEMEM (hLibHeap, 0, buffer);
            }

            if (pusLocalProcessNameBuffer != NULL) {
                buffer = pusLocalProcessNameBuffer;
                pusLocalProcessNameBuffer = NULL;
                FREEMEM (hLibHeap, 0, buffer);
            }
        }
    }
    return  status;

}

const CHAR PerfpIntegerWChars[] = {L'0', L'1', L'2', L'3', L'4', L'5',
                                   L'6', L'7', L'8', L'9', L'A', L'B',
                                   L'C', L'D', L'E', L'F'};

ULONG
PerfIntegerToWString(
    IN ULONG Value,
    IN ULONG Base,
    IN LONG OutputLength,
    OUT LPWSTR String
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    Base = 10; Shift = 0;  // Default to 10
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 32 ];
    *s = L'\0';
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
            }
        else {
            Digit = Value % Base;
            Value = Value / Base;
            }

        *--s = PerfpIntegerWChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG) (&Result[ 32 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = L'0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( 0 );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length*sizeof(WCHAR) );

            if ((LONG)Length < OutputLength) {
                String[ Length ] = L'\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( 0 );
            }

        return( Length );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\perfthrd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perfthrd.c

Abstract:

    This file implements an Performance Object that presents
    Thread performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "datathrd.h"

extern DWORD PerfSprc_dwThreadNameFormat;


DWORD APIENTRY
CollectThreadObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    LONG    lReturn = ERROR_SUCCESS;

    DWORD  TotalLen;            //  Length of the total return block

    THREAD_DATA_DEFINITION *pThreadDataDefinition;
    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
    PTHREAD_COUNTER_DATA    pTCD;
    THREAD_COUNTER_DATA     tcdTotal;

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    ULONG ProcessNumber;
    ULONG NumThreadInstances;
    ULONG ThreadNumber;
    ULONG ProcessBufferOffset;
    BOOLEAN NullProcess;
    BOOL    bMoreThreads;

    // total thread accumulator variables

    UNICODE_STRING ThreadName;
    WCHAR ThreadNameBuffer[MAX_THREAD_NAME_LENGTH+1];

    pThreadDataDefinition = (THREAD_DATA_DEFINITION *) *lppData;

    //
    //  Check for sufficient space for Thread object type definition
    //

    TotalLen = sizeof(THREAD_DATA_DEFINITION) +
               sizeof(PERF_INSTANCE_DEFINITION) +
               sizeof(THREAD_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define Thread data block
    //

    ThreadName.Length =
    ThreadName.MaximumLength = (MAX_THREAD_NAME_LENGTH + 1) * sizeof(WCHAR);
    ThreadName.Buffer = ThreadNameBuffer;

    memcpy(pThreadDataDefinition,
           &ThreadDataDefinition,
           sizeof(THREAD_DATA_DEFINITION));

    pThreadDataDefinition->ThreadObjectType.PerfTime = PerfTime;

    ProcessBufferOffset = 0;

    // Now collect data for each Thread

    ProcessNumber = 0;
    NumThreadInstances = 0;

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;

    pPerfInstanceDefinition =
        (PPERF_INSTANCE_DEFINITION)&pThreadDataDefinition[1];
    TotalLen = sizeof(THREAD_DATA_DEFINITION);

    // clear total accumulator
    memset (&tcdTotal, 0, sizeof (tcdTotal));

    bMoreThreads = FALSE;
    if (ProcessInfo) {
        if (ProcessInfo->NextEntryOffset != 0) {
            bMoreThreads = TRUE;
        }
    }
    while ( bMoreThreads && (ProcessInfo != NULL)) {

        if ( ProcessInfo->ImageName.Buffer != NULL ||
             ProcessInfo->NumberOfThreads > 0 ) {
            NullProcess = FALSE;
        } else {
            NullProcess = TRUE;
        }

        ThreadNumber = 0;       //  Thread number of this process

        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

        while ( !NullProcess &&
                ThreadNumber < ProcessInfo->NumberOfThreads ) {

            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                       (MAX_THREAD_NAME_LENGTH+1+sizeof(DWORD))*
                           sizeof(WCHAR) +
                       sizeof (THREAD_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_MORE_DATA;
            }

            if (PerfSprc_dwThreadNameFormat == NAME_FORMAT_ID) {
                PerfIntegerToWString(
                    HandleToUlong(ThreadInfo->ClientId.UniqueThread),
                    10,
                    MAX_THREAD_NAME_LENGTH+1,
                    ThreadNameBuffer);
            }
            else {
                // The only name we've got is the thread number

                RtlIntegerToUnicodeString(ThreadNumber,
                                          10,
                                          &ThreadName);
            }

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                (PVOID *) &pTCD,
                PROCESS_OBJECT_TITLE_INDEX,
                ProcessNumber,
                (DWORD)-1,
                ThreadName.Buffer);

            // test structure for Quadword Alignment
            assert (((DWORD)(pTCD) & 0x00000007) == 0);

            //
            //
            //  Format and collect Thread data
            //

            pTCD->CounterBlock.ByteLength = sizeof(THREAD_COUNTER_DATA);

            //
            //  Convert User time from 100 nsec units to counter
            //  frequency.
            //
            tcdTotal.ProcessorTime +=
                pTCD->ProcessorTime = ThreadInfo->KernelTime.QuadPart +
                                        ThreadInfo->UserTime.QuadPart;

            tcdTotal.UserTime +=
                pTCD->UserTime = ThreadInfo->UserTime.QuadPart;
            tcdTotal.KernelTime +=
                pTCD->KernelTime = ThreadInfo->KernelTime.QuadPart;

            tcdTotal.ContextSwitches +=
                pTCD->ContextSwitches = ThreadInfo->ContextSwitches;

            pTCD->ThreadElapsedTime = ThreadInfo->CreateTime.QuadPart;

            pTCD->ThreadPriority = (ThreadInfo->ClientId.UniqueProcess == 0) ?
                0 : ThreadInfo->Priority;

            pTCD->ThreadBasePriority = ThreadInfo->BasePriority;
            pTCD->ThreadStartAddr = ThreadInfo->StartAddress;
            pTCD->ThreadState =
                (DWORD)((ThreadInfo->ThreadState > 7) ?
                    7 : ThreadInfo->ThreadState);
            pTCD->WaitReason = (DWORD)ThreadInfo->WaitReason;

            // now stuff in the process and thread id's
            pTCD->ProcessId = HandleToUlong(ThreadInfo->ClientId.UniqueProcess);
            pTCD->ThreadId = HandleToUlong(ThreadInfo->ClientId.UniqueThread);

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pTCD[1];

            NumThreadInstances++;
            ThreadNumber++;
            ThreadInfo++;
        }

        if ( !NullProcess ) {
            ProcessNumber++;
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            bMoreThreads = FALSE;
            continue;
        }

        ProcessBufferOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                          &pProcessBuffer[ProcessBufferOffset];
    }

    if (NumThreadInstances > 0) {

        // See if the total instance will fit

        TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                    (MAX_THREAD_NAME_LENGTH+1+sizeof(DWORD))*
                        sizeof(WCHAR) +
                    sizeof (THREAD_COUNTER_DATA);

        if ( *lpcbTotalBytes < TotalLen ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }

        // set the Total Elapsed Time to be the current time so that it will
        // show up as 0 when displayed.
        tcdTotal.ThreadElapsedTime = pThreadDataDefinition->ThreadObjectType.PerfTime.QuadPart;

        // use the "total" for this instance
        MonBuildInstanceDefinition(pPerfInstanceDefinition,
            (PVOID *) &pTCD,
            PROCESS_OBJECT_TITLE_INDEX,
            ProcessNumber,
            (DWORD)-1,
            wszTotal);

        // test structure for Quadword Alignment
        assert (((DWORD)(pTCD) & 0x00000007) == 0);

        //
        //
        //  Format and collect Thread data
        //

        memcpy (pTCD, &tcdTotal, sizeof(tcdTotal));
        pTCD->CounterBlock.ByteLength = sizeof(THREAD_COUNTER_DATA);

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pTCD[1];

        NumThreadInstances++;
    }
    // Note number of Thread instances

    pThreadDataDefinition->ThreadObjectType.NumInstances =
        NumThreadInstances;

    //
    //  Now we know how large an area we used for the
    //  Thread definition, so we can update the offset
    //  to the next object definition
    //

    *lpcbTotalBytes =
        pThreadDataDefinition->ThreadObjectType.TotalByteLength =
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pThreadDataDefinition);

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFPROC: Thread Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lppData = (LPVOID)pPerfInstanceDefinition;

    *lpNumObjectTypes = 1;

    return lReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\perfjob.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    perfjob.c

Abstract:

    This file implements an Performance Job Object that presents
    information on the Job Object

Created:

    Bob Watson  8-Oct-1997

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "procmsg.h"
#include "datajob.h"

#define MAX_STR_CHAR    1024
#define    MAX_STR_SIZE    ((DWORD)((MAX_STR_CHAR - 1)* sizeof(WCHAR)))
#define MAX_NAME_LENGTH    MAX_PATH

#define BUFFERSIZE 1024

DWORD    dwBufferSize = BUFFERSIZE;

const WCHAR szJob[] = L"Job";
const WCHAR szObjDirName[] = L"\\BaseNamedObjects";

#define MAX_EVENT_STRINGS    4
WORD    wEvtStringCount;
LPWSTR    szEvtStringArray[MAX_EVENT_STRINGS];

UNICODE_STRING DirectoryName = {(sizeof(szObjDirName) - sizeof(WCHAR)), // name len - NULL
                                sizeof(szObjDirName),                   // size of buffer    
                                (PWCHAR)szObjDirName};                   // address of buffer

BOOL    bOpenJobErrorLogged = FALSE;

PSYSTEM_PROCESS_INFORMATION APIENTRY
GetProcessPointerFromProcessId (
    IN    ULONG_PTR    dwPid
)
{
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    ULONG ProcessBufferOffset = 0;
    BOOLEAN NullProcess;
    
    DWORD    dwIndex = 0;
    BOOL    bNotFound    = TRUE;
    BOOL    bMoreProcesses = FALSE;

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pProcessBuffer;
    if (ProcessInfo) {
        if (ProcessInfo->NextEntryOffset != 0) {
            bMoreProcesses = TRUE;
        }
    }
    while ( bMoreProcesses && bNotFound &&
            (ProcessInfo != NULL)) {
        // check for Live processes
        //  (i.e. name or threads)

        if ((ProcessInfo->ImageName.Buffer != NULL) ||
            (ProcessInfo->NumberOfThreads > 0)){
                // thread is not Dead
            NullProcess = FALSE;
        } else {
            // thread is dead
            NullProcess = TRUE;
        }

        if (( !NullProcess )  && (dwPid == (HandleToUlong(ProcessInfo->UniqueProcessId)))) {
            // found it so return current value
            bNotFound = FALSE;
            continue;
        } else {
            dwIndex++;
        }
        // exit if this was the last process in list
        if (ProcessInfo->NextEntryOffset == 0) {
            bMoreProcesses = FALSE;
            continue;
        }

        // point to next buffer in list
        ProcessBufferOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                          &pProcessBuffer[ProcessBufferOffset];
    }

    if (bNotFound) {
        return NULL;
    } else {
        return ProcessInfo;
    }
}

DWORD APIENTRY
CollectJobObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD   TotalLen;            //  Length of the total return block

    PPERF_INSTANCE_DEFINITION   pPerfInstanceDefinition;
    PJOB_DATA_DEFINITION        pJobDataDefinition;
    PJOB_COUNTER_DATA            pJCD;
    JOB_COUNTER_DATA            jcdTotal;

    NTSTATUS Status     = STATUS_SUCCESS;
    NTSTATUS tmpStatus  = STATUS_SUCCESS;
    HANDLE DirectoryHandle, JobHandle;
    ULONG ReturnedLength;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    OBJECT_ATTRIBUTES Attributes;
    WCHAR    wszNameBuffer[MAX_STR_CHAR];
    DWORD    dwSize;
    PUCHAR  Buffer;
    BOOL    bStatus;
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION JobAcctInfo;

    DWORD    dwWin32Status = ERROR_SUCCESS;
    ACCESS_MASK ExtraAccess = 0;
    ULONG Context = 0;
    DWORD    NumJobInstances = 0;

    // get size of a data block that has 1 instance
    TotalLen = sizeof(JOB_DATA_DEFINITION) +        // object def + counter defs
               sizeof (PERF_INSTANCE_DEFINITION) +    // 1 instance def
               MAX_VALUE_NAME_LENGTH +                // 1 instance name
               sizeof(JOB_COUNTER_DATA);            // 1 instance data block

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    // cast callers buffer to the object data definition type
    pJobDataDefinition = (JOB_DATA_DEFINITION *) *lppData;

    //
    //  Define Job Object data block
    //

    memcpy(pJobDataDefinition,
           &JobDataDefinition,
           sizeof(JOB_DATA_DEFINITION));

    // set timestamp of this object
    pJobDataDefinition->JobObjectType.PerfTime = PerfTime;

    // Now collect data for each job object found in system
    //
    //  Perform initial setup
    //
    Buffer = ALLOCMEM(hLibHeap, HEAP_ZERO_MEMORY, dwBufferSize);
    if ((Buffer == NULL)) {
        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFPROC_UNABLE_ALLOCATE_JOB_DATA,
            NULL,
            0,
            0,
            NULL,
            NULL);
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
    }

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pJobDataDefinition[1];

    // adjust TotalLen to be the size of the buffer already in use
    TotalLen = sizeof (JOB_DATA_DEFINITION);

    // zero the total instance buffer
    memset (&jcdTotal, 0, sizeof (jcdTotal));

    //
    //  Open the directory for list directory access
    //
    // this should always succeed since it's a system name we
    // will be querying
    //
    InitializeObjectAttributes( &Attributes,
                                &DirectoryName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    
    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY | ExtraAccess,
                                    &Attributes
                                  );
    if (NT_SUCCESS( Status )) {
        //
        // Get the actual name of the object directory object.
        //

        NameInfo = (POBJECT_NAME_INFORMATION) &Buffer[0];
        Status = NtQueryObject( DirectoryHandle,
                                 ObjectNameInformation,
                                 NameInfo,
                                 dwBufferSize,
                                 (PULONG) NULL );
    }

    if (NT_SUCCESS( Status )) {
        //
        //  Query the entire directory in one sweep
        //
        for (Status = NtQueryDirectoryObject( DirectoryHandle,
                                              Buffer,
                                              dwBufferSize,
                                              FALSE,
                                              FALSE,
                                              &Context,
                                              &ReturnedLength );
             NT_SUCCESS( Status );
             Status = NtQueryDirectoryObject( DirectoryHandle,
                                              Buffer,
                                              dwBufferSize,
                                              FALSE,
                                              FALSE,
                                              &Context,
                                              &ReturnedLength ) ) {

            //
            //  Check the status of the operation.
            //

            if (!NT_SUCCESS( Status )) {
                break;
            }

            //
            //  For every record in the buffer type out the directory information
            //

            //
            //  Point to the first record in the buffer, we are guaranteed to have
            //  one otherwise Status would have been No More Files
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

            //
            //  Continue while there's a valid record.  
            //
            while (DirInfo->Name.Length != 0) {

                //
                //  Print out information about the Job
                //

                if (wcsncmp ( DirInfo->TypeName.Buffer, &szJob[0], ((sizeof(szJob)/sizeof(WCHAR)) - 1)) == 0) {
                    ULONG len;
                    UNICODE_STRING JobName;
                    NTSTATUS Status;

                    // this is really a job, so list the name
                    dwSize = DirInfo->Name.Length;
                    if (dwSize > (MAX_STR_SIZE - sizeof(szObjDirName))) {
                        dwSize = MAX_STR_SIZE - sizeof(szObjDirName);
                    }
                    len = wcslen(szObjDirName);
                    wcscpy(wszNameBuffer, szObjDirName);
                    wszNameBuffer[len] = L'\\';
                    len++;
                    memcpy (&wszNameBuffer[len], DirInfo->Name.Buffer, dwSize);
                    wszNameBuffer[dwSize/sizeof(WCHAR)+len] = 0;

                    // now query the process ID's for this job

                    RtlInitUnicodeString(&JobName, wszNameBuffer);
                    InitializeObjectAttributes(
                        &Attributes,
                        &JobName,
                        0,
                        NULL, NULL);
                    Status = NtOpenJobObject(
                                &JobHandle,
                                JOB_OBJECT_QUERY,
                                &Attributes);
                    if (NT_SUCCESS(Status)) {

                        // strip Job name prefix for instance name
                        memcpy (wszNameBuffer, DirInfo->Name.Buffer, dwSize);
                        wszNameBuffer[dwSize/sizeof(WCHAR)] = 0;

                        bStatus = QueryInformationJobObject (
                            JobHandle,
                            JobObjectBasicAccountingInformation,
                            &JobAcctInfo,
                            sizeof(JobAcctInfo),
                            &ReturnedLength);

                        ASSERT (ReturnedLength == sizeof(JobAcctInfo));

                        if (bStatus) {
                            // *** create and initialize perf data instance here ***

                            // see if this instance will fit
                            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                                       DWORD_MULTIPLE ((DirInfo->Name.Length + sizeof(WCHAR))) +
                                       sizeof (JOB_COUNTER_DATA);

                            if ( *lpcbTotalBytes < TotalLen ) {
                                *lpcbTotalBytes = 0;
                                *lpNumObjectTypes = 0;
                                Status = STATUS_NO_MEMORY;
                                dwWin32Status =  ERROR_MORE_DATA;
                                break;
                            }

                            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                (PVOID *) &pJCD,
                                0,
                                0,
                                (DWORD)-1,
                                wszNameBuffer);

                            // test structure for Quadword Alignment
                            assert (((DWORD)(pJCD) & 0x00000007) == 0);

                            //
                            //  Format and collect Process data
                            //

                            pJCD->CounterBlock.ByteLength = sizeof (JOB_COUNTER_DATA);

                            jcdTotal.CurrentProcessorTime +=                     
                                pJCD->CurrentProcessorTime =
                                    JobAcctInfo.TotalUserTime.QuadPart +
                                    JobAcctInfo.TotalKernelTime.QuadPart;

                            jcdTotal.CurrentUserTime +=
                                pJCD->CurrentUserTime = JobAcctInfo.TotalUserTime.QuadPart;
                            jcdTotal.CurrentKernelTime +=
                                pJCD->CurrentKernelTime = JobAcctInfo.TotalKernelTime.QuadPart;

#ifdef _DATAJOB_INCLUDE_TOTAL_COUNTERS
                            // convert these times from 100 ns Time base to 1 mS time base
                            jcdTotal.TotalProcessorTime +=
                                pJCD->TotalProcessorTime =
                                    (JobAcctInfo.ThisPeriodTotalUserTime.QuadPart +
                                    JobAcctInfo.ThisPeriodTotalKernelTime.QuadPart) / 10000;
                            jcdTotal.TotalUserTime +=
                                pJCD->TotalUserTime =
                                    JobAcctInfo.ThisPeriodTotalUserTime.QuadPart / 10000;
                            jcdTotal.TotalKernelTime +=
                                pJCD->TotalKernelTime =
                                    JobAcctInfo.ThisPeriodTotalKernelTime.QuadPart / 1000;
                            jcdTotal.CurrentProcessorUsage +=
                                pJCD->CurrentProcessorUsage =
                                    (JobAcctInfo.TotalUserTime.QuadPart +
                                     JobAcctInfo.TotalKernelTime.QuadPart) / 10000;

                            jcdTotal.CurrentUserUsage +=
                                pJCD->CurrentUserUsage =
                                    JobAcctInfo.TotalUserTime.QuadPart / 10000;

                            jcdTotal.CurrentKernelUsage +=
                                pJCD->CurrentKernelUsage =
                                    JobAcctInfo.TotalKernelTime.QuadPart / 10000;
#endif
                            jcdTotal.PageFaults +=
                                pJCD->PageFaults = JobAcctInfo.TotalPageFaultCount;
                            jcdTotal.TotalProcessCount +=
                                pJCD->TotalProcessCount = JobAcctInfo.TotalProcesses;
                            jcdTotal.ActiveProcessCount +=
                                pJCD->ActiveProcessCount = JobAcctInfo.ActiveProcesses;
                            jcdTotal.TerminatedProcessCount +=
                                pJCD->TerminatedProcessCount = JobAcctInfo.TotalTerminatedProcesses;

                            NumJobInstances++;

                            CloseHandle (JobHandle);

                            // set perfdata pointer to next byte
                            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pJCD[1];
                        } else {
                            // unable to query job accounting info
                            dwWin32Status = GetLastError();
                            tmpStatus     = Status;
                            Status        = STATUS_SUCCESS;
                            if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
                                wEvtStringCount = 0;
                                szEvtStringArray[wEvtStringCount++] = wszNameBuffer;
                                // unable to open this Job
                                ReportEventW (hEventLog,
                                        EVENTLOG_WARNING_TYPE,
                                        0,
                                        PERFPROC_UNABLE_QUERY_JOB_ACCT,
                                        NULL,
                                        wEvtStringCount,
                                        sizeof(DWORD),
                                        szEvtStringArray,
                                        (LPVOID) & dwWin32Status);
                                bOpenJobErrorLogged = TRUE;
                            }
                        }
                    } else {
                        dwWin32Status = GetLastError();
                        tmpStatus     = Status;
                        Status        = STATUS_SUCCESS;
                        if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
                            wEvtStringCount = 0;
                            szEvtStringArray[wEvtStringCount++] = wszNameBuffer;
                            // unable to open this Job
                            ReportEventW (hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    PERFPROC_UNABLE_OPEN_JOB,
                                    NULL,
                                    wEvtStringCount,
                                    sizeof(DWORD),
                                    szEvtStringArray,
                                    (LPVOID) & dwWin32Status);
                            bOpenJobErrorLogged = TRUE;
                        }
                    }
                }

                //
                //  There is another record so advance DirInfo to the next entry
                //

                DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                              sizeof( OBJECT_DIRECTORY_INFORMATION ) );

            }

            RtlZeroMemory( Buffer, dwBufferSize );

        }

        if ((Status == STATUS_NO_MORE_FILES) ||
            (Status == STATUS_NO_MORE_ENTRIES)) {
            // this is OK
            Status = STATUS_SUCCESS;
        }

        if (Status == STATUS_SUCCESS && NumJobInstances == 0
                                     && bOpenJobErrorLogged == TRUE
                                     && dwWin32Status != ERROR_SUCCESS) {
            Status = tmpStatus;
        }

        if (Buffer) FREEMEM(hLibHeap, 0, Buffer);

        //
        //  Now close the directory object
        //

        (VOID) NtClose( DirectoryHandle );
    }

    if (NT_SUCCESS(Status)) {
        if (NumJobInstances > 0) {
            // see if the total instance will fit
            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                        (MAX_NAME_LENGTH+1+sizeof(DWORD))*
                          sizeof(WCHAR) +
                       sizeof (JOB_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;
                return ERROR_MORE_DATA;
            }

            // it looks like it will fit so create "total" instance

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                (PVOID *) &pJCD,
                0,
                0,
                (DWORD)-1,
                wszTotal);

            // test structure for Quadword Alignment
            assert (((DWORD)(pJCD) & 0x00000007) == 0);

            //
            //  transfer total info
            //
            memcpy (pJCD, &jcdTotal, sizeof (jcdTotal));
            pJCD->CounterBlock.ByteLength = sizeof (JOB_COUNTER_DATA);

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pJCD[1];
            NumJobInstances++;
        }

        pJobDataDefinition->JobObjectType.NumInstances =
            NumJobInstances;
        //
        //  Now we know how large an area we used for the
        //  data, so we can update the offset
        //  to the next object definition
        //

        *lpcbTotalBytes =
            pJobDataDefinition->JobObjectType.TotalByteLength =
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pJobDataDefinition);

#if DBG
        if (*lpcbTotalBytes > TotalLen ) {
            DbgPrint ("\nPERFPROC: Job Perf Ctr. Instance Size Underestimated:");
            DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
        }
#endif

        *lppData = (LPVOID) pPerfInstanceDefinition;

        *lpNumObjectTypes = 1;

    } else {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
            wEvtStringCount = 0;
            szEvtStringArray[wEvtStringCount++] = DirectoryName.Buffer;
            // unable to query the object directory
            ReportEventW (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    PERFPROC_UNABLE_QUERY_OBJECT_DIR,
                    NULL,
                    wEvtStringCount,
                    sizeof(DWORD),
                    szEvtStringArray,
                    (LPVOID)&Status);
            bOpenJobErrorLogged = TRUE;
        }
    }

    return ERROR_SUCCESS;
}

DWORD APIENTRY
CollectJobDetailData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PUNICODE_STRING pProcessName;

    DWORD   TotalLen;            //  Length of the total return block

    PPERF_INSTANCE_DEFINITION   pPerfInstanceDefinition;
    PJOB_DETAILS_DATA_DEFINITION        pJobDetailsDataDefinition;
    PJOB_DETAILS_COUNTER_DATA            pJDCD;
    JOB_DETAILS_COUNTER_DATA            jdcdTotal;
    JOB_DETAILS_COUNTER_DATA            jdcdGrandTotal;


    NTSTATUS Status    = STATUS_SUCCESS;
    NTSTATUS tmpStatus = STATUS_SUCCESS;
    HANDLE DirectoryHandle, JobHandle;
    ULONG ReturnedLength;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    OBJECT_ATTRIBUTES Attributes;
    WCHAR    wszNameBuffer[MAX_STR_CHAR];
    DWORD    i, dwSize;
    PUCHAR  Buffer;
    BOOL    bStatus;
    PJOBOBJECT_BASIC_PROCESS_ID_LIST pJobPidList;

    DWORD    dwWin32Status = ERROR_SUCCESS;
    ACCESS_MASK ExtraAccess = 0;
    ULONG Context = 0;
    DWORD    NumJobObjects = 0;
    DWORD    NumJobDetailInstances = 0;

    // get size of a data block that has 1 instance
    TotalLen = sizeof(JOB_DETAILS_DATA_DEFINITION) +        // object def + counter defs
               sizeof (PERF_INSTANCE_DEFINITION) +    // 1 instance def
               MAX_VALUE_NAME_LENGTH +                // 1 instance name
               sizeof(JOB_DETAILS_COUNTER_DATA);            // 1 instance data block

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    // cast callers buffer to the object data definition type
    pJobDetailsDataDefinition = (JOB_DETAILS_DATA_DEFINITION *) *lppData;

    //
    //  Define Job Details Object data block
    //

    memcpy(pJobDetailsDataDefinition,
           &JobDetailsDataDefinition,
           sizeof(JOB_DETAILS_DATA_DEFINITION));

    // set timestamp of this object
    pJobDetailsDataDefinition->JobDetailsObjectType.PerfTime = PerfTime;

    // Now collect data for each job object found in system
    //
    //  Perform initial setup
    //
    Buffer = NULL;
    pJobPidList = NULL;
    if (hLibHeap) {
        Buffer = ALLOCMEM(hLibHeap, HEAP_ZERO_MEMORY, dwBufferSize);
        pJobPidList = ALLOCMEM(hLibHeap, HEAP_ZERO_MEMORY, dwBufferSize);
    }
    if ((Buffer == NULL) || (pJobPidList == NULL)) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        // free the one that got allocated (if any)
        if (Buffer != NULL) FREEMEM(hLibHeap, 0, Buffer);
        if (pJobPidList != NULL) FREEMEM(hLibHeap, 0, pJobPidList);
        ReportEventW(hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            PERFPROC_UNABLE_ALLOCATE_JOB_DATA,
            NULL,
            0,
            0,
            szEvtStringArray,
            NULL);
        return ERROR_SUCCESS;
    }

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pJobDetailsDataDefinition[1];

    // adjust TotalLen to be the size of the buffer already in use
    TotalLen = sizeof (JOB_DETAILS_DATA_DEFINITION);

    // zero the total instance buffer
    memset (&jdcdGrandTotal, 0, sizeof (jdcdGrandTotal));

    //
    //  Open the directory for list directory access
    //
    // this should always succeed since it's a system name we
    // will be querying
    //
    InitializeObjectAttributes( &Attributes,
                                &DirectoryName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    
    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY | ExtraAccess,
                                    &Attributes
                                  );
    if (NT_SUCCESS( Status )) {
        //
        // Get the actual name of the object directory object.
        //

        NameInfo = (POBJECT_NAME_INFORMATION) &Buffer[0];
        Status = NtQueryObject( DirectoryHandle,
                                 ObjectNameInformation,
                                 NameInfo,
                                 dwBufferSize,
                                 (PULONG) NULL );
    }

    if (NT_SUCCESS( Status )) {
        //
        //  Query the entire directory in one sweep
        //
        for (Status = NtQueryDirectoryObject( DirectoryHandle,
                                              Buffer,
                                              dwBufferSize,
                                              FALSE,
                                              FALSE,
                                              &Context,
                                              &ReturnedLength );
             NT_SUCCESS( Status );
             Status = NtQueryDirectoryObject( DirectoryHandle,
                                              Buffer,
                                              dwBufferSize,
                                              FALSE,
                                              FALSE,
                                              &Context,
                                              &ReturnedLength ) ) {

            //
            //  Check the status of the operation.
            //

            if (!NT_SUCCESS( Status )) {
                break;
            }

            //
            //  For every record in the buffer type out the directory information
            //

            //
            //  Point to the first record in the buffer, we are guaranteed to have
            //  one otherwise Status would have been No More Files
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

            //
            //  contine while there's a valid record
            //

            while (DirInfo->Name.Length != 0) {

                //
                //  Print out information about the Job
                //

                if (wcsncmp ( DirInfo->TypeName.Buffer, &szJob[0], ((sizeof(szJob)/sizeof(WCHAR)) - 1)) == 0) {
                    ULONG len;
                    UNICODE_STRING JobName;
                    NTSTATUS Status;

                    // this is really a job, so list the name
                    dwSize = DirInfo->Name.Length;
                    if (dwSize > (MAX_STR_SIZE - sizeof(szObjDirName))) {
                        dwSize = MAX_STR_SIZE - sizeof(szObjDirName);
                    }
                    len = wcslen(szObjDirName);
                    wcscpy(wszNameBuffer, szObjDirName);
                    wszNameBuffer[len] = L'\\';
                    len++;
                    memcpy (&wszNameBuffer[len], DirInfo->Name.Buffer, dwSize);
                    wszNameBuffer[dwSize/sizeof(WCHAR)+len] = 0;

                    // now query the process ID's for this job

                    RtlInitUnicodeString(&JobName, wszNameBuffer);
                    InitializeObjectAttributes(
                        &Attributes,
                        &JobName,
                        0,
                        NULL, NULL);
                    Status = NtOpenJobObject(
                                &JobHandle,
                                JOB_OBJECT_QUERY,
                                &Attributes);

                    // clear the Job total counter block
                    memset (&jdcdTotal, 0, sizeof (jdcdTotal));

                    if (NT_SUCCESS(Status)) {
                        // strip Job name prefix for instance name
                        memcpy (wszNameBuffer, DirInfo->Name.Buffer, dwSize);
                        wszNameBuffer[dwSize/sizeof(WCHAR)] = 0;

                        // now query the process ID's for this job

                        bStatus = QueryInformationJobObject (
                            JobHandle,
                            JobObjectBasicProcessIdList,
                            pJobPidList,
                            dwBufferSize,
                            &ReturnedLength);

//                        ASSERT (bStatus == TRUE);
                        ASSERT (ReturnedLength <= BUFFERSIZE);
                        ASSERT (pJobPidList->NumberOfAssignedProcesses ==
                            pJobPidList->NumberOfProcessIdsInList);

                        // test to see if there was enough room in the first buffer
                        // for everything, if not, expand the buffer and retry

                        if ((bStatus) && (pJobPidList->NumberOfAssignedProcesses >
                            pJobPidList->NumberOfProcessIdsInList))    {
                            PJOBOBJECT_BASIC_PROCESS_ID_LIST pOldBuffer;
                            dwBufferSize +=
                                (pJobPidList->NumberOfAssignedProcesses -
                                 pJobPidList->NumberOfProcessIdsInList) *
                                 sizeof (DWORD);
                            pOldBuffer = pJobPidList;
                            pJobPidList = REALLOCMEM (hLibHeap, 0,
                                pJobPidList, dwBufferSize);
//                            ASSERT (pJobPidList != NULL);
                            if (pJobPidList != NULL) {
                                bStatus = QueryInformationJobObject (
                                    JobHandle,
                                    JobObjectBasicProcessIdList,
                                    pJobPidList,
                                    dwBufferSize,
                                    &ReturnedLength);
                            } else {        
                                bStatus = FALSE;
                                FREEMEM(hLibHeap, 0, pOldBuffer);
                                SetLastError ( ERROR_OUTOFMEMORY );
                            }
                        }

                        if (bStatus) {

                            for (i=0;i < pJobPidList->NumberOfProcessIdsInList; i++) {
                                // *** create and initialize perf data instance here ***
                                // get process data object from ID
                                ProcessInfo = GetProcessPointerFromProcessId (pJobPidList->ProcessIdList[i]);
                                
//                                ASSERT (ProcessInfo != NULL);

                                if (ProcessInfo != NULL) {

                                    // get process name
                                    if (lProcessNameCollectionMethod == PNCM_MODULE_FILE) {
                                        pProcessName = GetProcessSlowName (ProcessInfo);
                                    } else {
                                       pProcessName = GetProcessShortName (ProcessInfo);
                                    }
                                    ReturnedLength = pProcessName->Length + sizeof(WCHAR);

                                    // see if this instance will fit
                                    TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                                               DWORD_MULTIPLE (ReturnedLength) +
                                               sizeof (JOB_DETAILS_COUNTER_DATA);

                                    if ( *lpcbTotalBytes < TotalLen ) {
                                        *lpcbTotalBytes = 0;
                                        *lpNumObjectTypes = 0;
                                        Status = STATUS_NO_MEMORY;
                                        dwWin32Status =  ERROR_MORE_DATA;
                                        break;
                                    }

                                    MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                        (PVOID *) &pJDCD,
                                        JOB_OBJECT_TITLE_INDEX,
                                        NumJobObjects,
                                        (DWORD)-1,
                                        pProcessName->Buffer);

                                    // test structure for Quadword Alignment
                                    assert (((DWORD)(pJDCD) & 0x00000007) == 0);

                                    //
                                    //  Format and collect Process data
                                    //

                                    pJDCD->CounterBlock.ByteLength = sizeof (JOB_DETAILS_COUNTER_DATA);
                                    //
                                    //  Convert User time from 100 nsec units to counter frequency.
                                    //
                                    jdcdTotal.ProcessorTime +=
                                        pJDCD->ProcessorTime = ProcessInfo->KernelTime.QuadPart +
                                                            ProcessInfo->UserTime.QuadPart;
                                    jdcdTotal.UserTime +=
                                        pJDCD->UserTime = ProcessInfo->UserTime.QuadPart;
                                    jdcdTotal.KernelTime +=
                                        pJDCD->KernelTime = ProcessInfo->KernelTime.QuadPart;

                                    jdcdTotal.PeakVirtualSize +=
                                        pJDCD->PeakVirtualSize = ProcessInfo->PeakVirtualSize;
                                    jdcdTotal.VirtualSize +=
                                        pJDCD->VirtualSize = ProcessInfo->VirtualSize;

                                    jdcdTotal.PageFaults +=
                                        pJDCD->PageFaults = ProcessInfo->PageFaultCount;
                                    jdcdTotal.PeakWorkingSet +=
                                        pJDCD->PeakWorkingSet = ProcessInfo->PeakWorkingSetSize;
                                    jdcdTotal.TotalWorkingSet +=
                                        pJDCD->TotalWorkingSet = ProcessInfo->WorkingSetSize;

#ifdef _DATAPROC_PRIVATE_WS_
                                    jdcdTotal.PrivateWorkingSet +=
                                        pJDCD->PrivateWorkingSet = ProcessInfo->PrivateWorkingSetSize;
                                    jdcdTotal.SharedWorkingSet +=
                                        pJDCD->SharedWorkingSet =
                                            ProcessInfo->WorkingSetSize -
                                            ProcessInfo->PrivateWorkingSetSize;
#endif
                                    jdcdTotal.PeakPageFile +=
                                        pJDCD->PeakPageFile = ProcessInfo->PeakPagefileUsage;
                                    jdcdTotal.PageFile +=
                                        pJDCD->PageFile = ProcessInfo->PagefileUsage;

                                    jdcdTotal.PrivatePages +=
                                        pJDCD->PrivatePages = ProcessInfo->PrivatePageCount;

                                    jdcdTotal.ThreadCount +=
                                        pJDCD->ThreadCount = ProcessInfo->NumberOfThreads;

                                    // base priority is not totaled
                                    pJDCD->BasePriority = ProcessInfo->BasePriority;

                                    // elpased time is not totaled
                                    pJDCD->ElapsedTime = ProcessInfo->CreateTime.QuadPart;

                                    pJDCD->ProcessId = HandleToUlong(ProcessInfo->UniqueProcessId);
                                    pJDCD->CreatorProcessId = HandleToUlong(ProcessInfo->InheritedFromUniqueProcessId);

                                    jdcdTotal.PagedPool +=
                                        pJDCD->PagedPool = (DWORD)ProcessInfo->QuotaPagedPoolUsage;
                                    jdcdTotal.NonPagedPool +=
                                        pJDCD->NonPagedPool = (DWORD)ProcessInfo->QuotaNonPagedPoolUsage;
                                    jdcdTotal.HandleCount +=
                                        pJDCD->HandleCount = (DWORD)ProcessInfo->HandleCount;

                                    // update I/O counters
                                    jdcdTotal.ReadOperationCount +=
                                        pJDCD->ReadOperationCount = ProcessInfo->ReadOperationCount.QuadPart;
                                    jdcdTotal.DataOperationCount += 
                                        pJDCD->DataOperationCount = ProcessInfo->ReadOperationCount.QuadPart;
                                    jdcdTotal.WriteOperationCount +=
                                        pJDCD->WriteOperationCount = ProcessInfo->WriteOperationCount.QuadPart;
                                    jdcdTotal.DataOperationCount += ProcessInfo->WriteOperationCount.QuadPart;
                                        pJDCD->DataOperationCount += ProcessInfo->WriteOperationCount.QuadPart;
                                    jdcdTotal.OtherOperationCount +=
                                        pJDCD->OtherOperationCount = ProcessInfo->OtherOperationCount.QuadPart;

                                    jdcdTotal.ReadTransferCount +=
                                        pJDCD->ReadTransferCount = ProcessInfo->ReadTransferCount.QuadPart;
                                    jdcdTotal.DataTransferCount +=
                                        pJDCD->DataTransferCount = ProcessInfo->ReadTransferCount.QuadPart;
                                    jdcdTotal.WriteTransferCount +=
                                        pJDCD->WriteTransferCount = ProcessInfo->WriteTransferCount.QuadPart;
                                    jdcdTotal.DataTransferCount += ProcessInfo->WriteTransferCount.QuadPart;
                                        pJDCD->DataTransferCount += ProcessInfo->WriteTransferCount.QuadPart;
                                    jdcdTotal.OtherTransferCount +=
                                        pJDCD->OtherTransferCount = ProcessInfo->OtherTransferCount.QuadPart;
                        
                                    // set perfdata pointer to next byte
                                    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pJDCD[1];

                                    NumJobDetailInstances++;
                                } else {
                                    // unable to locate info on this process
                                    // for now, we'll ignore this...
                                }
                            }
                        
                            CloseHandle (JobHandle);

                            // see if this instance will fit
                            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                                       DWORD_MULTIPLE (MAX_STR_SIZE) +
                                       sizeof (JOB_DETAILS_COUNTER_DATA);

                            if ( *lpcbTotalBytes < TotalLen ) {
                                *lpcbTotalBytes = 0;
                                *lpNumObjectTypes = 0;
                                Status = STATUS_NO_MEMORY;
                                dwWin32Status =  ERROR_MORE_DATA;
                                break;
                            }

                            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                                (PVOID *) &pJDCD,
                                JOB_OBJECT_TITLE_INDEX,
                                NumJobObjects,
                                (DWORD)-1,
                                wszTotal);

                            // test structure for Quadword Alignment
                            assert (((DWORD)(pJDCD) & 0x00000007) == 0);

                            // copy total data to caller's buffer

                            memcpy (pJDCD, &jdcdTotal, sizeof (jdcdTotal));
                            pJDCD->CounterBlock.ByteLength = sizeof (JOB_DETAILS_COUNTER_DATA);

                            // update grand total instance
                            //
                            jdcdGrandTotal.ProcessorTime += jdcdTotal.ProcessorTime;
                            jdcdGrandTotal.UserTime += jdcdTotal.UserTime;
                            jdcdGrandTotal.KernelTime += jdcdTotal. KernelTime;
                            jdcdGrandTotal.PeakVirtualSize += jdcdTotal.PeakVirtualSize;
                            jdcdGrandTotal.VirtualSize += jdcdTotal.VirtualSize;

                            jdcdGrandTotal.PageFaults += jdcdTotal.PageFaults;
                            jdcdGrandTotal.PeakWorkingSet += jdcdTotal.PeakWorkingSet;
                            jdcdGrandTotal.TotalWorkingSet += jdcdTotal.TotalWorkingSet;

#ifdef _DATAPROC_PRIVATE_WS_
                            jdcdGrandTotal.PrivateWorkingSet += jdcdTotal.PrivateWorkingSet;
                            jdcdGrandTotal.SharedWorkingSet += jdcdTotal.SharedWorkingSet;
#endif

                            jdcdGrandTotal.PeakPageFile += jdcdTotal.PeakPageFile;
                            jdcdGrandTotal.PageFile += jdcdTotal.PageFile;
                            jdcdGrandTotal.PrivatePages += jdcdTotal.PrivatePages;
                            jdcdGrandTotal.ThreadCount += jdcdTotal.ThreadCount;

                            jdcdGrandTotal.PagedPool += jdcdTotal.PagedPool;
                            jdcdGrandTotal.NonPagedPool += jdcdTotal.NonPagedPool;
                            jdcdGrandTotal.HandleCount += jdcdTotal.HandleCount;

                            // set perfdata pointer to next byte
                            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pJDCD[1];

                            NumJobDetailInstances++;
                            NumJobObjects++;
                        } else {
                            // unable to read PID list from Job
                            dwWin32Status = GetLastError();
                            tmpStatus     = Status;
                            Status        = STATUS_SUCCESS;
                            if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
                                wEvtStringCount = 0;
                                szEvtStringArray[wEvtStringCount++] = wszNameBuffer;
                                // unable to open this Job
                                ReportEventW (hEventLog,
                                        EVENTLOG_WARNING_TYPE,
                                        0,
                                        PERFPROC_UNABLE_QUERY_JOB_PIDS,
                                        NULL,
                                        wEvtStringCount,
                                        sizeof(DWORD),
                                        szEvtStringArray,
                                        (LPVOID) & dwWin32Status);
                                bOpenJobErrorLogged = TRUE;
                            }
                        }
                    } else {
                        dwWin32Status = GetLastError();
                        tmpStatus     = Status;
                        Status        = STATUS_SUCCESS;
                        if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
                            wEvtStringCount = 0;
                            szEvtStringArray[wEvtStringCount++] = wszNameBuffer;
                            // unable to open this Job
                            ReportEventW (hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    PERFPROC_UNABLE_OPEN_JOB,
                                    NULL,
                                    wEvtStringCount,
                                    sizeof(DWORD),
                                    szEvtStringArray,
                                    (LPVOID) & dwWin32Status);
                            bOpenJobErrorLogged = TRUE;
                        }
                    }
                }

                //
                //  There is another record so advance DirInfo to the next entry
                //

                DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                              sizeof( OBJECT_DIRECTORY_INFORMATION ) );

            }

            RtlZeroMemory( Buffer, dwBufferSize );

        }

        if ((Status == STATUS_NO_MORE_FILES) ||
            (Status == STATUS_NO_MORE_ENTRIES)) {
            // this is OK
            Status = STATUS_SUCCESS;
        }

        if (Status == STATUS_SUCCESS && NumJobDetailInstances == 0
                                     && bOpenJobErrorLogged == TRUE
                                     && dwWin32Status != ERROR_SUCCESS) {
            Status = tmpStatus;
        }

        if (Buffer) FREEMEM(hLibHeap, 0, Buffer);
        if (pJobPidList) FREEMEM(hLibHeap, 0, pJobPidList);

        //
        //  Now close the directory object
        //

        (VOID) NtClose( DirectoryHandle );

        if (NumJobDetailInstances > 0) {
            // see if this instance will fit
            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                       DWORD_MULTIPLE (MAX_STR_SIZE) +
                       sizeof (JOB_DETAILS_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;
                Status = STATUS_NO_MEMORY;
                dwWin32Status =  ERROR_MORE_DATA;
            } else {

                // set the Total Elapsed Time to be the current time so that it will
                // show up as 0 when displayed.
                jdcdGrandTotal.ElapsedTime = pJobDetailsDataDefinition->JobDetailsObjectType.PerfTime.QuadPart;

                // build the grand total instance
                MonBuildInstanceDefinition(pPerfInstanceDefinition,
                    (PVOID *) &pJDCD,
                    JOB_OBJECT_TITLE_INDEX,
                    NumJobObjects,
                    (DWORD)-1,
                    wszTotal);

                // test structure for Quadword Alignment
                ASSERT (((ULONG_PTR)(pJDCD) & 0x00000007) == 0);

                // copy total data to caller's buffer

                memcpy (pJDCD, &jdcdGrandTotal, sizeof (jdcdGrandTotal));
                pJDCD->CounterBlock.ByteLength = sizeof (JOB_DETAILS_COUNTER_DATA);

                // update pointers
                pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pJDCD[1];
                NumJobDetailInstances++;
            }
        }

        pJobDetailsDataDefinition->JobDetailsObjectType.NumInstances =
            NumJobDetailInstances;

        //
        //  Now we know how large an area we used for the
        //  Process definition, so we can update the offset
        //  to the next object definition
        //

        *lpcbTotalBytes =
             pJobDetailsDataDefinition->JobDetailsObjectType.TotalByteLength =
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pJobDetailsDataDefinition);

#if DBG
        if (*lpcbTotalBytes > TotalLen ) {
            DbgPrint ("\nPERFPROC: Job Perf Ctr. Instance Size Underestimated:");
            DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
        }
#endif

        *lppData = (LPVOID) pPerfInstanceDefinition;

        *lpNumObjectTypes = 1;
    
    } else {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        if (bOpenJobErrorLogged == FALSE && MESSAGE_LEVEL >= LOG_VERBOSE) {
            wEvtStringCount = 0;
            szEvtStringArray[wEvtStringCount++] = DirectoryName.Buffer;
            // unable to query the object directory
            ReportEventW (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    PERFPROC_UNABLE_QUERY_OBJECT_DIR,
                    NULL,
                    wEvtStringCount,
                    sizeof(DWORD),
                    szEvtStringArray,
                    (LPVOID)&Status);
            bOpenJobErrorLogged = TRUE;

        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\extinit.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000   Microsoft Corporation

Module Name:

    extinit.c

Abstract:

    This file implements all the initialization library routines operating on
    extensible performance libraries.

Author:

    JeePang

Revision History:

    09/27/2000  -   JeePang     - Moved from perflib.c

--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <winperf.h>
#include <rpc.h>
#include "regrpc.h"
#include "ntconreg.h"
#include "prflbmsg.h"   // event log messages
#include "perflib.h"
#pragma warning(default:4306)

//
//  used for error logging control
#define DEFAULT_ERROR_LIMIT         1000

DWORD    dwExtCtrOpenProcWaitMs = OPEN_PROC_WAIT_TIME;
LONG    lExtCounterTestLevel = EXT_TEST_UNDEFINED;

PEXT_OBJECT
AllocateAndInitializeExtObject (
    HKEY    hServicesKey,
    HKEY    hPerfKey,
    PUNICODE_STRING  usServiceName
)
/*++

 AllocateAndInitializeExtObject

    allocates and initializes an extensible object information entry
    for use by the performance library.

    a pointer to the initialized block is returned if all goes well,
    otherwise no memory is allocated and a null pointer is returned.

    The calling function must close the open handles and free this
    memory block when it is no longer needed.

 Arguments:

    hServicesKey    -- open registry handle to the
        HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services hey

    hPerfKey -- the open registry key to the Performance sub-key under
        the selected service

    szServiceName -- The name of the service

--*/
{
    LONG    Status;
    HKEY    hKeyLinkage;

    BOOL    bUseQueryFn = FALSE;

    PEXT_OBJECT  pReturnObject = NULL;

    DWORD   dwType;
    DWORD   dwSize;
    DWORD   dwFlags = 0;
    DWORD   dwKeep;
    DWORD   dwObjectArray[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];
    DWORD   dwObjIndex = 0;
    DWORD   dwMemBlockSize = sizeof(EXT_OBJECT);
    DWORD   dwLinkageStringLen = 0;
    DWORD   dwErrorLimit;

    CHAR    szOpenProcName[MAX_PATH];
    CHAR    szCollectProcName[MAX_PATH];
    CHAR    szCloseProcName[MAX_PATH];
    WCHAR   szLibraryString[MAX_PATH];
    WCHAR   szLibraryExpPath[MAX_PATH];
    WCHAR   mszObjectList[MAX_PATH];
    WCHAR   szLinkageKeyPath[MAX_PATH];
    LPWSTR  szLinkageString = NULL;     // max path wasn't enough for some paths

    DLL_VALIDATION_DATA DllVD;
    FILETIME    LocalftLastGoodDllFileDate;

    DWORD   dwOpenTimeout;
    DWORD   dwCollectTimeout;

    LPWSTR  szThisObject;
    LPWSTR  szThisChar;

    LPSTR   pNextStringA;
    LPWSTR  pNextStringW;

    WCHAR   szMutexName[MAX_PATH];
    WCHAR   szPID[32];

    WORD    wStringIndex;
    LPWSTR  szMessageArray[2];
    BOOL    bDisable = FALSE;
    LPWSTR  szServiceName;

    // read the performance DLL name

    szServiceName = (LPWSTR) usServiceName->Buffer;

    dwType = 0;
    dwSize = sizeof(szLibraryString);
    memset (szLibraryString, 0, sizeof(szLibraryString));
    memset (szLibraryString, 0, sizeof(szLibraryExpPath));
    LocalftLastGoodDllFileDate.dwLowDateTime = 0;
    LocalftLastGoodDllFileDate.dwHighDateTime = 0;
    memset (&DllVD, 0, sizeof(DllVD));
    dwErrorLimit = DEFAULT_ERROR_LIMIT;
    dwCollectTimeout = dwExtCtrOpenProcWaitMs;
    dwOpenTimeout = dwExtCtrOpenProcWaitMs;

    Status = PrivateRegQueryValueExW (hPerfKey,
                            DLLValue,
                            NULL,
                            &dwType,
                            (LPBYTE)szLibraryString,
                            &dwSize);

    if (Status == ERROR_SUCCESS) {
        if (dwType == REG_EXPAND_SZ) {
            // expand any environment vars
            dwSize = ExpandEnvironmentStringsW(
                szLibraryString,
                szLibraryExpPath,
                MAX_PATH);

            if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                Status = ERROR_INVALID_DLL;
            } else {
                dwSize += 1;
                dwSize *= sizeof(WCHAR);
                dwMemBlockSize += QWORD_MULTIPLE(dwSize);
            }
        } else if (dwType == REG_SZ) {
            // look for dll and save full file Path
            dwSize = SearchPathW (
                NULL,   // use standard system search path
                szLibraryString,
                NULL,
                MAX_PATH,
                szLibraryExpPath,
                NULL);

            if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                Status = ERROR_INVALID_DLL;
            } else {
                dwSize += 1;
                dwSize *= sizeof(WCHAR);
                dwMemBlockSize += QWORD_MULTIPLE(dwSize);
            }
        } else {
            Status = ERROR_INVALID_DLL;
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
        }

        if (Status == ERROR_SUCCESS) {
            // we have the DLL name so get the procedure names
            dwType = 0;
            dwSize = sizeof(szOpenProcName);
            memset (szOpenProcName, 0, sizeof(szOpenProcName));
            Status = PrivateRegQueryValueExA (hPerfKey,
                                    OpenValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)szOpenProcName,
                                    &dwSize);
            if (((Status != ERROR_SUCCESS) || (szOpenProcName[0] == 0)) &&
                (lEventLogLevel >= LOG_USER)) {
                if (szServiceName != NULL) {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT,
                        ARG_TYPE_WSTR, Status,
                        szServiceName, usServiceName->MaximumLength, NULL));
                }
                else {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
                }
//                DebugPrint((1, "No open procedure for %ws %d\n",
//                                szServiceName, Status));
                bDisable = TRUE;
                wStringIndex = 0;
                szMessageArray[wStringIndex++] = (LPWSTR) L"Open";
                szMessageArray[wStringIndex++] = szServiceName;
                ReportEvent(hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    (DWORD)PERFLIB_PROC_NAME_NOT_FOUND,
                    NULL,
                    wStringIndex,
                    0,
                    szMessageArray,
                    NULL);
            }
#ifdef DBG
            else {
                DebugPrint((2, "Found %s for %ws\n",
                    szOpenProcName, szServiceName));

            }
#endif
        }
#ifdef DBG
        else {
            DebugPrint((1, "Invalid DLL found for %ws\n",
                szServiceName));
        }
#endif

        if (Status == ERROR_SUCCESS) {
            // add in size of previous string
            // the size value includes the Term. NULL
            dwMemBlockSize += QWORD_MULTIPLE(dwSize);

            // we have the procedure name so get the timeout value
            dwType = 0;
            dwSize = sizeof(dwOpenTimeout);
            Status = PrivateRegQueryValueExW (hPerfKey,
                                    OpenTimeout,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwOpenTimeout,
                                    &dwSize);

            // if error, then apply default
            if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                dwOpenTimeout = dwExtCtrOpenProcWaitMs;
                Status = ERROR_SUCCESS;
            }

        }

        if (Status == ERROR_SUCCESS) {
            // get next string

            dwType = 0;
            dwSize = sizeof(szCloseProcName);
            memset (szCloseProcName, 0, sizeof(szCloseProcName));
            Status = PrivateRegQueryValueExA (hPerfKey,
                                    CloseValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)szCloseProcName,
                                    &dwSize);
            if (((Status != ERROR_SUCCESS) || (szCloseProcName[0] == 0)) &&
                (lEventLogLevel >= LOG_USER)) {
                if (szServiceName != NULL) {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                        (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT,
                        ARG_TYPE_WSTR, Status,
                        szServiceName, usServiceName->MaximumLength, NULL));
                }
                else {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
                }
//                DebugPrint((1, "No close procedure for %ws\n",
//                    szServiceName));
                wStringIndex = 0;
                szMessageArray[wStringIndex++] = (LPWSTR) L"Close";
                szMessageArray[wStringIndex++] = szServiceName;
                ReportEvent(hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    (DWORD)PERFLIB_PROC_NAME_NOT_FOUND,
                    NULL,
                    wStringIndex,
                    0,
                    szMessageArray,
                    NULL);
                bDisable = TRUE;
            }
#ifdef DBG
            else {
                DebugPrint((2, "Found %s for %ws\n",
                            szCloseProcName, szServiceName));
            }
#endif
        }

        if (Status == ERROR_SUCCESS) {
            // add in size of previous string
            // the size value includes the Term. NULL
            dwMemBlockSize += QWORD_MULTIPLE(dwSize);

            // try to look up the query function which is the
            // preferred interface if it's not found, then
            // try the collect function name. If that's not found,
            // then bail
            dwType = 0;
            dwSize = sizeof(szCollectProcName);
            memset (szCollectProcName, 0, sizeof(szCollectProcName));
            Status = PrivateRegQueryValueExA (hPerfKey,
                                    QueryValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)szCollectProcName,
                                    &dwSize);

            if (Status == ERROR_SUCCESS) {
                // add in size of the Query Function Name
                // the size value includes the Term. NULL
                dwMemBlockSize += QWORD_MULTIPLE(dwSize);
                // get next string

                bUseQueryFn = TRUE;
                // the query function can support a static object list
                // so look it up

            } else {
                // the QueryFunction wasn't found so look up the
                // Collect Function name instead
                dwType = 0;
                dwSize = sizeof(szCollectProcName);
                memset (szCollectProcName, 0, sizeof(szCollectProcName));
                Status = PrivateRegQueryValueExA (hPerfKey,
                                        CollectValue,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)szCollectProcName,
                                        &dwSize);

                if (Status == ERROR_SUCCESS) {
                    // add in size of Collect Function Name
                    // the size value includes the Term. NULL
                    dwMemBlockSize += QWORD_MULTIPLE(dwSize);
                }
            }
            if (((Status != ERROR_SUCCESS) || (szCollectProcName[0] == 0)) &&
                (lEventLogLevel >= LOG_USER)) {
                if (szServiceName != NULL) {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                        (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT,
                        ARG_TYPE_WSTR, Status,
                        szServiceName, usServiceName->MaximumLength, NULL));
                }
                else {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
                }
                DebugPrint((1, "No collect procedure for %ws\n",
                    szServiceName));
                wStringIndex = 0;
                bDisable = TRUE;
                szMessageArray[wStringIndex++] = (LPWSTR) L"Collect";
                szMessageArray[wStringIndex++] = szServiceName;
                ReportEvent(hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    (DWORD)PERFLIB_PROC_NAME_NOT_FOUND,
                    NULL,
                    wStringIndex,
                    0,
                    szMessageArray,
                    NULL);
            }
#ifdef DBG
            else {
                DebugPrint((2, "Found %s for %ws\n",
                    szCollectProcName, szServiceName));
            }
#endif

            if (Status == ERROR_SUCCESS) {
                // we have the procedure name so get the timeout value
                dwType = 0;
                dwSize = sizeof(dwCollectTimeout);
                Status = PrivateRegQueryValueExW (hPerfKey,
                                        CollectTimeout,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)&dwCollectTimeout,
                                        &dwSize);

                // if error, then apply default
                if ((Status != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
                    dwCollectTimeout = dwExtCtrOpenProcWaitMs;
                    Status = ERROR_SUCCESS;
                }
            }
            // get the list of supported objects if provided by the registry

            dwType = 0;
            dwSize = sizeof(mszObjectList);
            memset (mszObjectList, 0, sizeof(mszObjectList));
            Status = PrivateRegQueryValueExW (hPerfKey,
                                    ObjListValue,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)mszObjectList,
                                    &dwSize);

            if (Status == ERROR_SUCCESS) {
                if (dwType != REG_MULTI_SZ) {
                    // convert space delimited list to msz
                    for (szThisChar = mszObjectList; *szThisChar != 0; szThisChar++) {
                        if (*szThisChar == L' ') *szThisChar = L'\0';
                    }
                    ++szThisChar;
                    *szThisChar = 0; // add MSZ term Null
                }
                for (szThisObject = mszObjectList, dwObjIndex = 0;
                    (*szThisObject != 0) && (dwObjIndex < MAX_PERF_OBJECTS_IN_QUERY_FUNCTION);
                    szThisObject += lstrlenW(szThisObject) + 1) {
                    dwObjectArray[dwObjIndex] = wcstoul(szThisObject, NULL, 10);
                    dwObjIndex++;
                }
                if ((*szThisObject != 0) &&
                    (lEventLogLevel >= LOG_USER)) {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                          (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, 0, NULL));
                    ReportEvent (hEventLog,
                        EVENTLOG_ERROR_TYPE,             // error type
                        0,                               // category (not used
                        (DWORD)PERFLIB_TOO_MANY_OBJECTS, // event,
                        NULL,                           // SID (not used),
                        0,                              // number of strings
                        0,                              // sizeof raw data
                        NULL,                           // message text array
                        NULL);                          // raw data
                }
            } else {
                // reset status since not having this is
                //  not a showstopper
                Status = ERROR_SUCCESS;
            }

            if (Status == ERROR_SUCCESS) {
                dwType = 0;
                dwKeep = 0;
                dwSize = sizeof(dwKeep);
                Status = PrivateRegQueryValueExW (hPerfKey,
                                        KeepResident,
                                        NULL,
                                        &dwType,
                                        (LPBYTE)&dwKeep,
                                        &dwSize);

                if ((Status == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                    if (dwKeep == 1) {
                        dwFlags |= PERF_EO_KEEP_RESIDENT;
                    } else {
                        // no change.
                    }
                } else {
                    // not fatal, just use the defaults.
                    Status = ERROR_SUCCESS;
                }

            }
            if (Status == ERROR_SUCCESS) {
                dwType = REG_DWORD;
                dwSize = sizeof(DWORD);
                PrivateRegQueryValueExW(
                    hPerfKey,
                    cszFailureLimit,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwErrorLimit,
                    &dwSize);
            }
        }
    }
    else {
        if (szLibraryString != NULL) {
            TRACE((WINPERF_DBG_TRACE_FATAL),
                (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT,
                ARG_TYPE_WSTR, Status,
                szLibraryString, WSTRSIZE(szLibraryString), NULL));
        }
        else {
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
        }
//        DebugPrint((1, "Cannot key for %ws. Error=%d\n",
//            szLibraryString, Status));
    }

    if (Status == ERROR_SUCCESS) {
        // get Library validation time
        dwType = 0;
        dwSize = sizeof(DllVD);
        Status = PrivateRegQueryValueExW (hPerfKey,
                                cszLibraryValidationData,
                                NULL,
                                &dwType,
                                (LPBYTE)&DllVD,
                                &dwSize);

        if ((Status != ERROR_SUCCESS) ||
            (dwType != REG_BINARY) ||
            (dwSize != sizeof (DllVD))){
            // then set this entry to be 0
            TRACE((WINPERF_DBG_TRACE_INFO),
                (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status,
                &dwType, sizeof(dwType), &dwSize, sizeof(dwSize), NULL));
            memset (&DllVD, 0, sizeof(DllVD));
            // and clear the error
            Status = ERROR_SUCCESS;
        }
    }

    if (Status == ERROR_SUCCESS) {
        // get the file timestamp of the last successfully accessed file
        dwType = 0;
        dwSize = sizeof(LocalftLastGoodDllFileDate);
        memset (&LocalftLastGoodDllFileDate, 0, sizeof(LocalftLastGoodDllFileDate));
        Status = PrivateRegQueryValueExW (hPerfKey,
                                cszSuccessfulFileData,
                                NULL,
                                &dwType,
                                (LPBYTE)&LocalftLastGoodDllFileDate,
                                &dwSize);

        if ((Status != ERROR_SUCCESS) ||
            (dwType != REG_BINARY) ||
            (dwSize != sizeof (LocalftLastGoodDllFileDate))) {
            // then set this entry to be Invalid
            memset (&LocalftLastGoodDllFileDate, 0xFF, sizeof(LocalftLastGoodDllFileDate));
            // and clear the error
            TRACE((WINPERF_DBG_TRACE_INFO),
                (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status,
                &dwType, sizeof(dwType), &dwSize, sizeof(dwSize), NULL));
            Status = ERROR_SUCCESS;
        }
    }

    if (Status == ERROR_SUCCESS) {
        lstrcpyW (szLinkageKeyPath, szServiceName);
        lstrcatW (szLinkageKeyPath, LinkageKey);

        Status = RegOpenKeyExW (
            hServicesKey,
            szLinkageKeyPath,
            0L,
            KEY_READ,
            &hKeyLinkage);

        if (Status == ERROR_SUCCESS) {
            // look up export value string
            dwSize = 0;
            dwType = 0;
            Status = PrivateRegQueryValueExW (
                hKeyLinkage,
                ExportValue,
                NULL,
                &dwType,
                NULL,
                &dwSize);
            // get size of string
            if (((Status != ERROR_SUCCESS) && (Status != ERROR_MORE_DATA)) ||
                ((dwType != REG_SZ) && (dwType != REG_MULTI_SZ))) {
                dwLinkageStringLen = 0;
                szLinkageString = NULL;
                // not finding a linkage key is not fatal so correct
                // status
                Status = ERROR_SUCCESS;
            } else {
                // allocate buffer
                szLinkageString = (LPWSTR)ALLOCMEM(dwSize);

                if (szLinkageString != NULL) {
                    // read string into buffer
                    dwType = 0;
                    Status = PrivateRegQueryValueExW (
                        hKeyLinkage,
                        ExportValue,
                        NULL,
                        &dwType,
                        (LPBYTE)szLinkageString,
                        &dwSize);

                    if ((Status != ERROR_SUCCESS) ||
                        ((dwType != REG_SZ) && (dwType != REG_MULTI_SZ))) {
                        // clear & release buffer
                        FREEMEM (szLinkageString);
                        szLinkageString = NULL;
                        dwLinkageStringLen = 0;
                        // not finding a linkage key is not fatal so correct
                        // status
                        Status = ERROR_SUCCESS;
                    } else {
                        // add size of linkage string to buffer
                        // the size value includes the Term. NULL
                        dwLinkageStringLen = dwSize;
                        dwMemBlockSize += QWORD_MULTIPLE(dwSize);
                    }
                } else {
                    // clear & release buffer
                    FREEMEM (szLinkageString);
                    szLinkageString = NULL;
                    dwLinkageStringLen = 0;
                    Status = ERROR_OUTOFMEMORY;
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                        (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status,
                        &dwSize, sizeof(dwSize), NULL));
                }
            }
            RegCloseKey (hKeyLinkage);
        } else {
            // not finding a linkage key is not fatal so correct
            // status
            // clear & release buffer
            szLinkageString = NULL;
            dwLinkageStringLen = 0;
            Status = ERROR_SUCCESS;
        }
    }

    if (Status == ERROR_SUCCESS) {
        // add in size of service name
/*        dwSize = lstrlenW (szServiceName);
        dwSize += 1;
        dwSize *= sizeof(WCHAR);
*/
        dwSize = usServiceName->MaximumLength;
        dwMemBlockSize += QWORD_MULTIPLE(dwSize);

        // allocate and initialize a new ext. object block
        pReturnObject = ALLOCMEM (dwMemBlockSize);

        if (pReturnObject != NULL) {
            // copy values to new buffer (all others are NULL)
            pNextStringA = (LPSTR)&pReturnObject[1];

            // copy Open Procedure Name
            pReturnObject->szOpenProcName = pNextStringA;
            lstrcpyA (pNextStringA, szOpenProcName);

            pNextStringA += lstrlenA (pNextStringA) + 1;
            pNextStringA = ALIGN_ON_QWORD(pNextStringA);

            pReturnObject->dwOpenTimeout = dwOpenTimeout;

            // copy collect function or query function, depending
            pReturnObject->szCollectProcName = pNextStringA;
            lstrcpyA (pNextStringA, szCollectProcName);

            pNextStringA += lstrlenA (pNextStringA) + 1;
            pNextStringA = ALIGN_ON_QWORD(pNextStringA);

            pReturnObject->dwCollectTimeout = dwCollectTimeout;

            // copy Close Procedure Name
            pReturnObject->szCloseProcName = pNextStringA;
            lstrcpyA (pNextStringA, szCloseProcName);

            pNextStringA += lstrlenA (pNextStringA) + 1;
            pNextStringA = ALIGN_ON_QWORD(pNextStringA);

            // copy Library path
            pNextStringW = (LPWSTR)pNextStringA;
            pReturnObject->szLibraryName = pNextStringW;
            lstrcpyW (pNextStringW, szLibraryExpPath);

            pNextStringW += lstrlenW (pNextStringW) + 1;
            pNextStringW = ALIGN_ON_QWORD(pNextStringW);

            // copy Linkage String if there is one
            if (szLinkageString != NULL) {
                pReturnObject->szLinkageString = pNextStringW;
                memcpy (pNextStringW, szLinkageString, dwLinkageStringLen);

                // length includes extra NULL char and is in BYTES
                pNextStringW += (dwLinkageStringLen / sizeof (WCHAR));
                pNextStringW = ALIGN_ON_QWORD(pNextStringW);
                // release the buffer now that it's been copied
                FREEMEM (szLinkageString);
                szLinkageString = NULL;
            }

            // copy Service name
            pReturnObject->szServiceName = pNextStringW;
            lstrcpyW (pNextStringW, szServiceName);

            pNextStringW += lstrlenW (pNextStringW) + 1;
            pNextStringW = ALIGN_ON_QWORD(pNextStringW);

            // load flags
            if (bUseQueryFn) {
                dwFlags |= PERF_EO_QUERY_FUNC;
            }
            pReturnObject->dwFlags =  dwFlags;

            pReturnObject->hPerfKey = hPerfKey;

            pReturnObject->LibData = DllVD; // validation data
            pReturnObject->ftLastGoodDllFileDate = LocalftLastGoodDllFileDate;

            // the default test level is "all tests"
            // if the file and timestamp work out OK, this can
            // be reset to the system test level
            pReturnObject->dwValidationLevel = EXT_TEST_ALL;

            // load Object array
            if (dwObjIndex > 0) {
                pReturnObject->dwNumObjects = dwObjIndex;
                memcpy (pReturnObject->dwObjList,
                    dwObjectArray, (dwObjIndex * sizeof(dwObjectArray[0])));
            }

            pReturnObject->llLastUsedTime = 0;

            // create Mutex name
            lstrcpyW (szMutexName, szServiceName);
            lstrcatW (szMutexName, (LPCWSTR)L"_Perf_Library_Lock_PID_");
            _ultow ((ULONG)GetCurrentProcessId(), szPID, 16);
            lstrcatW (szMutexName, szPID);

            pReturnObject->hMutex = CreateMutexW(NULL, FALSE, szMutexName);
            pReturnObject->dwErrorLimit = dwErrorLimit;
            if (   pReturnObject->hMutex != NULL
                && GetLastError() == ERROR_ALREADY_EXISTS) {
                Status = ERROR_SUCCESS;
            }
            else {
                Status = GetLastError();
            }
        } else {
            Status = ERROR_OUTOFMEMORY;
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, dwMemBlockSize, NULL));
        }
    }

    if ((Status == ERROR_SUCCESS) && (lpPerflibSectionAddr != NULL)) {
        PPERFDATA_SECTION_HEADER  pHead;
        DWORD           dwEntry;
        PPERFDATA_SECTION_RECORD  pEntry;
        // init perf data section
        pHead = (PPERFDATA_SECTION_HEADER)lpPerflibSectionAddr;
        pEntry = (PPERFDATA_SECTION_RECORD)lpPerflibSectionAddr;
        // get the entry first
        // the "0" entry is the header
        if (pHead->dwEntriesInUse < pHead->dwMaxEntries) {
            dwEntry = ++pHead->dwEntriesInUse;
            pReturnObject->pPerfSectionEntry = &pEntry[dwEntry];
            lstrcpynW (pReturnObject->pPerfSectionEntry->szServiceName,
                pReturnObject->szServiceName, PDSR_SERVICE_NAME_LEN);
        } else {
            // the list is full so bump the missing entry count
            pHead->dwMissingEntries++;
            pReturnObject->pPerfSectionEntry = NULL;
        }
    }


    if (Status != ERROR_SUCCESS) {
        SetLastError (Status);
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (&PerflibGuid, __LINE__, PERF_ALLOC_INIT_EXT, 0, Status, NULL));
        if (bDisable) {
            DisableLibrary(hPerfKey, szServiceName);
        }
        if (pReturnObject) {
            FREEMEM(pReturnObject);
            pReturnObject = NULL;
        }
        if (szLinkageString) {
            FREEMEM(szLinkageString);
        }
    }

    return pReturnObject;
}


void
OpenExtensibleObjects (
)

/*++

Routine Description:

    This routine will search the Configuration Registry for modules
    which will return data at data collection time.  If any are found,
    and successfully opened, data structures are allocated to hold
    handles to them.

    The global data access in this section is protected by the
    hGlobalDataMutex acquired by the calling function.

Arguments:

    None.
                  successful open.

Return Value:

    None.

--*/

{

    DWORD dwIndex;               // index for enumerating services
    ULONG KeyBufferLength;       // length of buffer for reading key data
    ULONG ValueBufferLength;     // length of buffer for reading value data
    ULONG ResultLength;          // length of data returned by Query call
    HANDLE hPerfKey;             // Root of queries for performance info
    HANDLE hServicesKey;         // Root of services
    REGSAM samDesired;           // access needed to query
    NTSTATUS Status;             // generally used for Nt call result status
    ANSI_STRING AnsiValueData;   // Ansi version of returned strings
    UNICODE_STRING ServiceName;  // name of service returned by enumeration
    UNICODE_STRING PathName;     // path name to services
    UNICODE_STRING PerformanceName;  // name of key holding performance data
    UNICODE_STRING ValueDataName;    // result of query of value is this name
    OBJECT_ATTRIBUTES ObjectAttributes;  // general use for opening keys
    PKEY_BASIC_INFORMATION KeyInformation;   // data from query key goes here

    WCHAR szServiceName[MAX_PATH];
    UNICODE_STRING usServiceName;

    LPTSTR  szMessageArray[8];
    DWORD   dwRawDataDwords[8];     // raw data buffer
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    DWORD   dwDefaultValue;

    HANDLE  hTimeOutEvent;

    PEXT_OBJECT      pLastObject = NULL;
    PEXT_OBJECT      pThisObject = NULL;

    //  Initialize do failure can deallocate if allocated

    ServiceName.Buffer = NULL;
    KeyInformation = NULL;
    ValueDataName.Buffer = NULL;
    AnsiValueData.Buffer = NULL;

    dwIndex = 0;

    RtlInitUnicodeString(&PathName, ExtPath);
    RtlInitUnicodeString(&PerformanceName, PerfSubKey);

    try {
        // get current event log level
        dwDefaultValue = LOG_NONE;
        Status = GetPerflibKeyValue (
                    EventLogLevel,
                    REG_DWORD,
                    sizeof(DWORD),
                    (LPVOID)&lEventLogLevel,
                    sizeof(DWORD),
                    (LPVOID)&dwDefaultValue);

        dwDefaultValue = EXT_TEST_ALL;
        Status = GetPerflibKeyValue (
                    ExtCounterTestLevel,
                    REG_DWORD,
                    sizeof(DWORD),
                    (LPVOID)&lExtCounterTestLevel,
                    sizeof(DWORD),
                    (LPVOID)&dwDefaultValue);

        dwDefaultValue = OPEN_PROC_WAIT_TIME;
        Status = GetPerflibKeyValue (
                    OpenProcedureWaitTime,
                    REG_DWORD,
                    sizeof(DWORD),
                    (LPVOID)&dwExtCtrOpenProcWaitMs,
                    sizeof(DWORD),
                    (LPVOID)&dwDefaultValue);

        dwDefaultValue = PERFLIB_TIMING_THREAD_TIMEOUT;
        Status = GetPerflibKeyValue (
                    LibraryUnloadTime,
                    REG_DWORD,
                    sizeof(DWORD),
                    (LPVOID)&dwThreadAndLibraryTimeout,
                    sizeof(DWORD),
                    (LPVOID)&dwDefaultValue);

        // register as an event log source if not already done.

        if (hEventLog == NULL) {
            hEventLog = RegisterEventSource (NULL, (LPCWSTR)TEXT("Perflib"));
        }

        if (ExtensibleObjects == NULL) {
            // create a list of the known performance data objects
            ServiceName.Length =
            ServiceName.MaximumLength = (WORD)(MAX_KEY_NAME_LENGTH +
                                        PerformanceName.MaximumLength +
                                        sizeof(UNICODE_NULL));

            ServiceName.Buffer = ALLOCMEM(ServiceName.MaximumLength);

            InitializeObjectAttributes(&ObjectAttributes,
                                    &PathName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

            samDesired = KEY_READ;

            Status = NtOpenKey(&hServicesKey,
                            samDesired,
                            &ObjectAttributes);


            KeyBufferLength = sizeof(KEY_BASIC_INFORMATION) + MAX_KEY_NAME_LENGTH;

            KeyInformation = ALLOCMEM(KeyBufferLength);

            ValueBufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) +
                                MAX_VALUE_NAME_LENGTH +
                                MAX_VALUE_DATA_LENGTH;

            ValueDataName.MaximumLength = MAX_VALUE_DATA_LENGTH;
            ValueDataName.Buffer = ALLOCMEM(ValueDataName.MaximumLength);

            AnsiValueData.MaximumLength = MAX_VALUE_DATA_LENGTH/sizeof(WCHAR);
            AnsiValueData.Buffer = ALLOCMEM(AnsiValueData.MaximumLength);

            //
            //  Check for successful NtOpenKey and allocation of dynamic buffers
            //

            if ( NT_SUCCESS(Status) &&
                ServiceName.Buffer != NULL &&
                KeyInformation != NULL &&
                ValueDataName.Buffer != NULL &&
                AnsiValueData.Buffer != NULL ) {

                dwIndex = 0;

                hTimeOutEvent = CreateEvent(NULL,TRUE,TRUE,NULL);

                // wait longer than the thread to give the timing thread
                // a chance to finish on it's own. This is really just a
                // failsafe step.

                while (NT_SUCCESS(Status)) {

                    Status = NtEnumerateKey(hServicesKey,
                                            dwIndex,
                                            KeyBasicInformation,
                                            KeyInformation,
                                            KeyBufferLength,
                                            &ResultLength);

                    dwIndex++;  //  next time, get the next key

                    if( !NT_SUCCESS(Status) ) {
                        // This is the normal exit: Status should be
                        // STATUS_NO_MORE_VALUES
                        break;
                    }

                    // Concatenate Service name with "\\Performance" to form Subkey

                    if ( ServiceName.MaximumLength >=
                        (USHORT)( KeyInformation->NameLength + sizeof(UNICODE_NULL) ) ) {

                        ServiceName.Length = (USHORT) KeyInformation->NameLength;

                        RtlMoveMemory(ServiceName.Buffer,
                                    KeyInformation->Name,
                                    ServiceName.Length);

                        ServiceName.Buffer[(ServiceName.Length/sizeof(WCHAR))] = 0; // null term

                        lstrcpyW (szServiceName, ServiceName.Buffer);
                        RtlInitUnicodeString(&usServiceName, szServiceName);

                        // zero terminate the buffer if space allows

                        RtlAppendUnicodeStringToString(&ServiceName,
                                                    &PerformanceName);

                        // Open Service\Performance Subkey

                        InitializeObjectAttributes(&ObjectAttributes,
                                                &ServiceName,
                                                OBJ_CASE_INSENSITIVE,
                                                hServicesKey,
                                                NULL);

                        samDesired = KEY_WRITE | KEY_READ; // to be able to disable perf DLL's

                        Status = NtOpenKey(&hPerfKey,
                                        samDesired,
                                        &ObjectAttributes);

                        if(! NT_SUCCESS(Status) ) {
                            samDesired = KEY_READ; // try read only access

                            Status = NtOpenKey(&hPerfKey,
                                            samDesired,
                                            &ObjectAttributes);
                        }

                        if( NT_SUCCESS(Status) ) {
                            // this has a performance key so read the info
                            // and add the entry to the list
                            pThisObject = AllocateAndInitializeExtObject (
                                hServicesKey, hPerfKey, &usServiceName);

                            if (pThisObject != NULL) {
                                if (ExtensibleObjects == NULL) {
                                    // set head pointer
                                    pLastObject =
                                        ExtensibleObjects = pThisObject;
                                    NumExtensibleObjects = 1;
                                } else {
                                    pLastObject->pNext = pThisObject;
                                    pLastObject = pThisObject;
                                    NumExtensibleObjects++;
                                }
                            } else {
                                if (szServiceName != NULL) {
                                    TRACE((WINPERF_DBG_TRACE_FATAL),
                                        (&PerflibGuid, __LINE__, PERF_OPEN_EXT_OBJS, ARG_TYPE_WSTR, 0,
                                        szServiceName, usServiceName.MaximumLength, NULL));
                                }
                                else {
                                    TRACE((WINPERF_DBG_TRACE_FATAL),
                                          (&PerflibGuid, __LINE__, PERF_OPEN_EXT_OBJS, 0, 0, NULL));
                                }
                                // the object wasn't initialized so toss
                                // the perf subkey handle.
                                // otherwise keep it open for later
                                // use and it will be closed when
                                // this extensible object is closed
                                NtClose (hPerfKey);
                            }
                        } else {
                            if (szServiceName != NULL) {
                                TRACE((WINPERF_DBG_TRACE_FATAL),
                                      (&PerflibGuid, __LINE__, PERF_OPEN_EXT_OBJS, ARG_TYPE_WSTR, Status,
                                    szServiceName, usServiceName.MaximumLength, NULL));
                            }
                            else {
                                TRACE((WINPERF_DBG_TRACE_FATAL),
                                      (&PerflibGuid, __LINE__, PERF_OPEN_EXT_OBJS, 0, Status, NULL));
                            }
                            // *** NEW FEATURE CODE ***
                            // unable to open the performance subkey
                            if (((Status != STATUS_OBJECT_NAME_NOT_FOUND) &&
                                (lEventLogLevel >= LOG_USER)) ||
                                (lEventLogLevel >= LOG_DEBUG)) {
                                // an error other than OBJECT_NOT_FOUND should be
                                // displayed if error logging is enabled
                                // if DEBUG level is selected, then write all
                                // non-success status returns to the event log
                                //
                                dwDataIndex = wStringIndex = 0;
                                dwRawDataDwords[dwDataIndex++] = PerfpDosError(Status);
                                if (lEventLogLevel >= LOG_DEBUG) {
                                    // if this is DEBUG mode, then log
                                    // the NT status as well.
                                    dwRawDataDwords[dwDataIndex++] =
                                        (DWORD)Status;
                                }
                                szMessageArray[wStringIndex++] =
                                    szServiceName;
                                ReportEvent (hEventLog,
                                    EVENTLOG_WARNING_TYPE,        // error type
                                    0,                          // category (not used)
                                    (DWORD)PERFLIB_NO_PERFORMANCE_SUBKEY, // event,
                                    NULL,                       // SID (not used),
                                    wStringIndex,               // number of strings
                                    dwDataIndex*sizeof(DWORD),  // sizeof raw data
                                    szMessageArray,                // message text array
                                    (LPVOID)&dwRawDataDwords[0]);           // raw data
                            }
                        }
                    }
                    Status = STATUS_SUCCESS;  // allow loop to continue
                }
                if (hTimeOutEvent != NULL) NtClose (hTimeOutEvent);
                NtClose (hServicesKey);
            }
        }
    } finally {
        if ( ServiceName.Buffer )
            FREEMEM(ServiceName.Buffer);
        if ( KeyInformation )
            FREEMEM(KeyInformation);
        if ( ValueDataName.Buffer )
            FREEMEM(ValueDataName.Buffer);
        if ( AnsiValueData.Buffer )
            FREEMEM(AnsiValueData.Buffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\perftdet.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    perftdet.c

Abstract:

    This file implements an Performance Object that presents
    Thread details performance object data

Created:

    Bob Watson  22-Oct-1996

Revision History


--*/
//
//  Include Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <perfutil.h>
#include "perfsprc.h"
#include "perfmsg.h"
#include "datatdet.h"

DWORD APIENTRY
CollectThreadDetailsObjectData (
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the processor object

Arguments:

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

   Returns:

             0 if successful, else Win 32 error code of failure

--*/
{
    DWORD  TotalLen;            //  Length of the total return block

    PTHREAD_DETAILS_DATA_DEFINITION pThreadDetailDataDefinition;
    PPERF_INSTANCE_DEFINITION       pPerfInstanceDefinition;
    PTHREAD_DETAILS_COUNTER_DATA    pTDCD;

    PSYSTEM_PROCESS_INFORMATION     ProcessInfo;
    PSYSTEM_THREAD_INFORMATION      ThreadInfo = NULL;

    ULONG ProcessNumber;
    ULONG NumThreadInstances;
    ULONG ThreadNumber = 0;
    ULONG ProcessBufferOffset;
    BOOLEAN NullProcess;

    NTSTATUS            Status;     // return from Nt Calls
    LONGLONG		llPcValue;  // value of current thread PC
    OBJECT_ATTRIBUTES   Obja;       // object attributes for thread context
    HANDLE              hThread;    // handle to current thread
    CONTEXT             ThreadContext; // current thread context struct

    UNICODE_STRING ThreadName;
    WCHAR ThreadNameBuffer[MAX_THREAD_NAME_LENGTH+1];
    BOOL    bMoreThreads;

    pThreadDetailDataDefinition = (THREAD_DETAILS_DATA_DEFINITION *) *lppData;

    //
    //  Check for sufficient space for Thread object type definition
    //

    TotalLen = sizeof(THREAD_DETAILS_DATA_DEFINITION) +
               sizeof(PERF_INSTANCE_DEFINITION) +
               sizeof(THREAD_DETAILS_COUNTER_DATA);

    if ( *lpcbTotalBytes < TotalLen ) {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    //
    //  Define Thread data block
    //

    ThreadName.Length =
    ThreadName.MaximumLength = (MAX_THREAD_NAME_LENGTH + 1) * sizeof(WCHAR);
    ThreadName.Buffer = ThreadNameBuffer;

    memcpy (pThreadDetailDataDefinition,
           &ThreadDetailsDataDefinition,
           sizeof(THREAD_DETAILS_DATA_DEFINITION));

    ProcessBufferOffset = 0;

    // Now collect data for each Thread

    ProcessNumber = 0;
    NumThreadInstances = 0;

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                              &pThreadDetailDataDefinition[1];

    TotalLen = sizeof (THREAD_DETAILS_DATA_DEFINITION);

    bMoreThreads = FALSE;
    if (ProcessInfo) {
        if (ProcessInfo->NextEntryOffset != 0) {
            bMoreThreads = TRUE;
        }
    }
    while ( bMoreThreads  && (ProcessInfo != NULL)) {

        if ( ProcessInfo->ImageName.Buffer != NULL ||
            ProcessInfo->NumberOfThreads > 0 ) {
            NullProcess = FALSE;
            ThreadNumber = 0;       //  Thread number of this process
            ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        } else {
            NullProcess = TRUE;
        }

        while ( !NullProcess &&
                ThreadNumber < ProcessInfo->NumberOfThreads ) {

            TotalLen += sizeof(PERF_INSTANCE_DEFINITION) +
                       (MAX_THREAD_NAME_LENGTH+1+sizeof(DWORD))*
                           sizeof(WCHAR) +
                       sizeof (THREAD_DETAILS_COUNTER_DATA);

            if ( *lpcbTotalBytes < TotalLen ) {
                *lpcbTotalBytes = 0;
                *lpNumObjectTypes = 0;
                return ERROR_MORE_DATA;
            }

            // Get Thread Context Information for Current PC field

            llPcValue = 0;
            InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);
            Status = NtOpenThread(
                        &hThread,
                        THREAD_GET_CONTEXT,
                        &Obja,
                        &ThreadInfo->ClientId
                        );
            if ( NT_SUCCESS(Status) ) {
                ThreadContext.ContextFlags = CONTEXT_CONTROL;
                Status = NtGetContextThread(hThread,&ThreadContext);
                NtClose(hThread);
                if ( NT_SUCCESS(Status) ) {
                    llPcValue = (LONGLONG)CONTEXT_TO_PROGRAM_COUNTER(&ThreadContext);
                } else {
                    llPcValue = 0;  // an error occured so send back 0 PC
                }
            } else {
                llPcValue = 0;  // an error occured so send back 0 PC
            }

            // The only name we've got is the thread number

            RtlIntegerToUnicodeString(ThreadNumber,
                                      10,
                                      &ThreadName);

            MonBuildInstanceDefinition(pPerfInstanceDefinition,
                (PVOID *) &pTDCD,
                EXPROCESS_OBJECT_TITLE_INDEX,
                ProcessNumber,
                (DWORD)-1,
                ThreadName.Buffer);

            //
            //
            //  Format and collect Thread data
            //

            pTDCD->CounterBlock.ByteLength = sizeof (THREAD_DETAILS_COUNTER_DATA);

            pTDCD->UserPc = llPcValue;

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pTDCD[1];
            NumThreadInstances++;
            ThreadNumber++;
            ThreadInfo++;
        }

        if (ProcessInfo->NextEntryOffset == 0) {
            // no more entries so bail out of the loop
            bMoreThreads = FALSE;
            continue;
        }

        ProcessBufferOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                          &pProcessBuffer[ProcessBufferOffset];

        if ( !NullProcess ) {
            ProcessNumber++;
        }
    }

    // Note number of Thread instances

    pThreadDetailDataDefinition->ThreadDetailsObjectType.NumInstances =
        NumThreadInstances;

    //
    //  Now we know how large an area we used for the
    //  Thread definition, so we can update the offset
    //  to the next object definition
    //

    *lpcbTotalBytes =
        pThreadDetailDataDefinition->ThreadDetailsObjectType.TotalByteLength =
            (DWORD)((PCHAR) pPerfInstanceDefinition -
            (PCHAR) pThreadDetailDataDefinition);

#if DBG
    if (*lpcbTotalBytes > TotalLen ) {
        DbgPrint ("\nPERFPROC: Thread Details Perf Ctr. Instance Size Underestimated:");
        DbgPrint ("\nPERFPROC:   Estimated size: %d, Actual Size: %d", TotalLen, *lpcbTotalBytes);
    }
#endif

    *lppData = (LPVOID) pPerfInstanceDefinition;

    *lpNumObjectTypes = 1;

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perfdlls\process\perfva.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992   Microsoft Corporation

Module Name:

    prflibva.c

Abstract:

    Virtual address space counter evaluation routines

    computes the process and image virtual address space usage for return
    via Perfmon API

Author:

    Stolen from the "internal" PVIEW SDK program and adapted for Perfmon by:

    a-robw (Bob Watson) 11/29/92

Revision History:

--*/
//
//  define routine's "personality"
//
#define UNICODE 1
//
//  Include files
//

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <perfutil.h>
#include "perfsprc.h"

#define DEFAULT_INCR (64*1024)
#ifdef _WIN64
#define STOP_AT (PVOID)(0xFFFFFFFF80000000)
#else
#define STOP_AT (PVOID)(0x80000000)
#endif

// Function Prototypes

PPROCESS_VA_INFO
GetProcessVaData (
    IN PSYSTEM_PROCESS_INFORMATION
);

PMODINFO
GetModuleVaData (
    PLDR_DATA_TABLE_ENTRY,  // module information structure
    PPROCESS_VA_INFO        // process data structure
);

BOOL
FreeProcessVaData (
    IN PPROCESS_VA_INFO
);

BOOL
FreeModuleVaData (
    IN PMODINFO
);


PMODINFO
LocateModInfo(
    IN PMODINFO,
    IN PVOID,
    IN SIZE_T
    );

DWORD
ProtectionToIndex(
    IN ULONG
    );

DWORD   dwProcessCount;
DWORD   dwModuleCount;


PPROCESS_VA_INFO
GetSystemVaData (
    IN PSYSTEM_PROCESS_INFORMATION pFirstProcess
)
/*++

GetSystemVaData

    Obtains the Process and Image Virtual Address information for all
    processes running on the system. (note that the routines called by
    this function allocate data structures consequently the corresponding
    FreeSystemVaData must be called to prevent memory "leaks")

Arguments

    IN PSYSTEM_PROCESS_INFORMATION
        pFirstProcess
            Pointer to first process in list of process structures returned
            by NtQuerySystemInformation service

Return Value

    Pointer to first process in list of processes
    or NULL if unable to obtain data

--*/
{
    PSYSTEM_PROCESS_INFORMATION     pThisProcess;
    PPROCESS_VA_INFO                pReturnValue = NULL;
    PPROCESS_VA_INFO                pLastProcess;
    PPROCESS_VA_INFO                pNewProcess;
    DWORD                           dwStartTime;
    BOOL                            bMoreProcesses;

    dwProcessCount = 0;
    dwModuleCount = 0;

    if (pFirstProcess != NULL) {

        pThisProcess = pFirstProcess;
        pLastProcess = NULL;
        bMoreProcesses = TRUE;

        while ( bMoreProcesses ) {  // loop exit is at bottom of loop
            dwStartTime = GetTickCount ();
            pNewProcess = GetProcessVaData(
                    pThisProcess);  // pointer to process Info structure
            if (pNewProcess) { // process data found OK
                pNewProcess->LookUpTime = GetTickCount() - dwStartTime;
                dwProcessCount++;
                if (!pLastProcess) {    // this is the first process returned
                    pReturnValue = pNewProcess; // save return value here
                } else {
                    pLastProcess->pNextProcess = pNewProcess;
                }
                pLastProcess = pNewProcess;
            }
            if ( pThisProcess->NextEntryOffset == 0 ) {
                bMoreProcesses = FALSE; // this is the last entry
            } else {   // point to the next process info structure
				pThisProcess = (PSYSTEM_PROCESS_INFORMATION)
					((PBYTE)pThisProcess + pThisProcess->NextEntryOffset);
            }
        }
        return pReturnValue;    // return pointer to first list entry
    } else {
        return NULL;
    }
}

PPROCESS_VA_INFO
GetProcessVaData (
    IN PSYSTEM_PROCESS_INFORMATION     pProcess
)
/*++

GetProcessVaData

    Gets the Virtual Memory usage details for the process passed in the
    argument list. Collects the data for all images in use by the process.

    Note that this routine allocates data structures that must be freed
    (using the FreeProcessVaData routine) when finished with them.


Arguments

    IN HANDLE hProcess
        handle to the process to collect data for

Return Value

    Pointer to completed Process VA info structure or
    NULL if unable to collect data
--*/
{
    NTSTATUS                Status;
    HANDLE                  hProcess;
    PPROCESS_VA_INFO        pThisProcess;
    PPEB                    pPeb;
    PPEB_LDR_DATA           Ldr;
    PLIST_ENTRY             LdrHead, LdrNext;
    LDR_DATA_TABLE_ENTRY    LdrEntryData, *pLdrEntry;
    PMODINFO                pNewModule, pLastModule;
    PVOID                   pBaseAddress;
    MEMORY_BASIC_INFORMATION VaBasicInfo;
    DWORD                   dwProtection;
    PMODINFO                pMod;
    SIZE_T                  dwRegionSize;
    OBJECT_ATTRIBUTES       obProcess;
    CLIENT_ID               ClientId;
    PUNICODE_STRING         pProcessNameBuffer;

    // get handle to process

    ClientId.UniqueThread = (HANDLE)NULL;
    ClientId.UniqueProcess = pProcess->UniqueProcessId;

    InitializeObjectAttributes(
        &obProcess,
        NULL,
        0,
        NULL,
        NULL
        );

    Status = NtOpenProcess(
        &hProcess,
        (ACCESS_MASK)PROCESS_ALL_ACCESS,
        &obProcess,
        &ClientId);

    if (! NT_SUCCESS(Status)){
        // unable to open the process, but still want to
        // create pThisProcess so we will not mess up
        // the process sequence.
        hProcess = 0;
//        return NULL;    // unable to open process
    }

    // allocate structure

    pThisProcess = ALLOCMEM (
        hLibHeap,
        HEAP_ZERO_MEMORY,
        sizeof (PROCESS_VA_INFO));

    if (pThisProcess) { // allocation successful
        // initialize fields

        pThisProcess->BasicInfo =  ALLOCMEM (
            hLibHeap,
            HEAP_ZERO_MEMORY,
            sizeof (PROCESS_BASIC_INFORMATION));

        if (!pThisProcess->BasicInfo) {
            // Bailout if unable to allocate memory
            goto PBailOut;
        }

        // zero process counters
        pThisProcess->MappedGuard = 0;
        pThisProcess->PrivateGuard = 0;
        pThisProcess->ImageReservedBytes = 0;
        pThisProcess->ImageFreeBytes = 0;
        pThisProcess->ReservedBytes = 0;
        pThisProcess->FreeBytes = 0;

        // get process short name from Process Info Structure

        // alloc a new buffer since GetProcessShortName reuses the name
        // buffer
        pThisProcess->pProcessName = ALLOCMEM (hLibHeap,
            HEAP_ZERO_MEMORY, (sizeof(UNICODE_STRING) + MAX_PROCESS_NAME_LENGTH));

        if (pThisProcess->pProcessName != NULL) {
            pThisProcess->pProcessName->Length = 0;
            pThisProcess->pProcessName->MaximumLength = MAX_PROCESS_NAME_LENGTH;
            pThisProcess->pProcessName->Buffer = (PWSTR)(&pThisProcess->pProcessName[1]);

            if (lProcessNameCollectionMethod == PNCM_MODULE_FILE) {
                pProcessNameBuffer = GetProcessSlowName (pProcess);
            } else {
               pProcessNameBuffer = GetProcessShortName (pProcess);
            }
            RtlCopyUnicodeString (pThisProcess->pProcessName,
                pProcessNameBuffer);
        } else {
            pThisProcess->pProcessName = NULL;
        }

        pThisProcess->dwProcessId = HandleToUlong(pProcess->UniqueProcessId);
        pThisProcess->hProcess = hProcess;

        // zero list pointers
        pThisProcess->pMemBlockInfo = NULL;
        pThisProcess->pNextProcess = NULL;

        if (hProcess) {

            Status = NtQueryInformationProcess (
                hProcess,
                ProcessBasicInformation,
                pThisProcess->BasicInfo,
                sizeof (PROCESS_BASIC_INFORMATION),
                NULL);

            if (!NT_SUCCESS(Status)){
                // if error reading data, then bail out
                goto SuccessExit;
            }

            // get pointer to the Process Environment Block

            pPeb = pThisProcess->BasicInfo->PebBaseAddress;

            // read address of loader information structure

            Status = NtReadVirtualMemory (
                hProcess,
                &pPeb->Ldr,
                &Ldr,
                sizeof (Ldr),
                NULL);

            // bail out if unable to read information

            if (!NT_SUCCESS(Status)){
                // if error reading data, then bail out
                goto SuccessExit;
            }

            //
            // get head pointer to linked list of memory modules used by
            // this process
            //

            LdrHead = &Ldr->InMemoryOrderModuleList;

            // Get address of next list entry

            Status = NtReadVirtualMemory (
                hProcess,
                &LdrHead->Flink,
                &LdrNext,
                sizeof (LdrNext),
                NULL);

            // bail out if unable to read information

            if (!NT_SUCCESS(Status)){
                // if error reading data, then bail out
                goto SuccessExit;
            }

            pLastModule = NULL;

            // walk down the list of modules until back at the top.
            // to list all the images in use by this process

            while ( LdrNext != LdrHead ) {
                // get record attached to list entry
	            pLdrEntry = CONTAINING_RECORD(LdrNext,
                                            LDR_DATA_TABLE_ENTRY,
                                            InMemoryOrderLinks);

                Status = NtReadVirtualMemory(
                            hProcess,
                            pLdrEntry,
                            &LdrEntryData,
                            sizeof(LdrEntryData),
                            NULL
                            );
                // if unable to read memory, then give up rest of search
                // and return what we have already.
                if ( !NT_SUCCESS(Status) ) {
                    goto SuccessExit;
                }


                pNewModule = GetModuleVaData (
                    &LdrEntryData,
                    pThisProcess);
                if (pNewModule) {   // if structure returned...
                    dwModuleCount++;
                    if (!pLastModule) { // if this is the first module...
                        // then set list head pointer
                        pThisProcess->pMemBlockInfo = pNewModule;
                    } else {
                        // otherwise link to list
                        pLastModule->pNextModule = pNewModule;
                    }
                    pLastModule = pNewModule;
                }
                LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
            } // end while not at end of list


            // now that we have a list of all images, query the process'
            // virtual memory for the list of memory blocks in use by this
            // process and assign them to the appropriate category of memory

            pBaseAddress = NULL;    // start at 0 and go to end of User VA space

            while (pBaseAddress < STOP_AT) { // truncate to 32-bit if necessary

                Status = NtQueryVirtualMemory (
                    hProcess,
                    pBaseAddress,
                    MemoryBasicInformation,
                    &VaBasicInfo,
                    sizeof(VaBasicInfo),
                    NULL);

                if (!NT_SUCCESS(Status)) {
                    goto SuccessExit;
                } else {
                    // get protection type for index into counter array
                    dwRegionSize = VaBasicInfo.RegionSize;
                    switch (VaBasicInfo.State) {
                        case MEM_COMMIT:
                            // if the memory is for an IMAGE, then search the image list
                            // for the corresponding image to update
                            dwProtection = ProtectionToIndex(VaBasicInfo.Protect);
                            if (VaBasicInfo.Type == MEM_IMAGE) {
                                // update process total
                                pThisProcess->MemTotals.CommitVector[dwProtection] += dwRegionSize;
                                pMod = LocateModInfo (pThisProcess->pMemBlockInfo, pBaseAddress, dwRegionSize);
                                if (pMod) { // if matching image found, then update
                                    pMod->CommitVector[dwProtection] += dwRegionSize;
                                    pMod->TotalCommit += dwRegionSize;
                                } else { // otherwise update orphan total
                                    pThisProcess->OrphanTotals.CommitVector[dwProtection] += dwRegionSize;
                                }
                            } else {
                                // if not assigned to an image, then update the process
                                // counters
                                if (VaBasicInfo.Type == MEM_MAPPED) {
                                    pThisProcess->MappedCommit[dwProtection] += dwRegionSize;
                                } else {
                                    pThisProcess->PrivateCommit[dwProtection] += dwRegionSize;
                                }
                            }
                            break;

                        case MEM_RESERVE:
                            if (VaBasicInfo.Type == MEM_IMAGE) {
                                pThisProcess->ImageReservedBytes += dwRegionSize;
                            } else {
                                pThisProcess->ReservedBytes += dwRegionSize;
                            }
                            break;

                        case MEM_FREE:
                            if (VaBasicInfo.Type == MEM_IMAGE) {
                                pThisProcess->ImageFreeBytes += dwRegionSize;
                            } else {
                                pThisProcess->FreeBytes += dwRegionSize;
                            }
                            break;

                        default:
                            break;
                    } // end switch (VaBasicInfo.State)
                } // endif QueryVM ok

                // go to next memory block

                pBaseAddress = (PVOID)((ULONG_PTR)pBaseAddress + dwRegionSize);

            } // end whil not at the end of  memory
        } // endif hProcess not NULL
    } // endif pThisProcess not NULL

SuccessExit:

    if (hProcess) CloseHandle(hProcess);

    return pThisProcess;

//
//  error recovery section, called when the routine is unable to
//  complete successfully to clean up before leaving
//

PBailOut:
    if (pThisProcess->BasicInfo) {
        FREEMEM (
            hLibHeap,
            0,
            pThisProcess->BasicInfo);
    }
    FREEMEM (
        hLibHeap,
        0,
        pThisProcess);
    if (hProcess) CloseHandle(hProcess);
    return NULL;
}

PMODINFO
GetModuleVaData (
    PLDR_DATA_TABLE_ENTRY ModuleListEntry,  // module information structure
    PPROCESS_VA_INFO    pProcess            // process data structure
)
/*++

GetModuleVaData

    Gets the Virtual Memory usage details for the module pointed to by the
    Process Memory Module List Entry argument in the argument list

    Note that this routine allocates data structures that must be freed
    (using the FreeModuleVaData routine) when finished with them.

Arguments

    IN HANDLE ModuleListEntry

Return Value

    Pointer to completed Module VA info structure or
    NULL if unable to collect data

--*/
{
    PMODINFO    pThisModule = NULL;    // module structure that is returned
    PUNICODE_STRING pusInstanceName = NULL;    // process->image
    PUNICODE_STRING pusLongInstanceName = NULL;    // process->fullimagepath
    UNICODE_STRING  usImageFileName = {0,0, NULL};	// image file name
    UNICODE_STRING  usExeFileName = {0,0, NULL};    // short name
    UNICODE_STRING  usNtFileName = {0,0, NULL};     // full Nt File Name

    PWCHAR          p,p1;
    PWCHAR      ImageNameBuffer = NULL;
    NTSTATUS    Status;
    HANDLE      hFile;
    HANDLE      hMappedFile;
    WORD        wStringSize;

    PVOID       MappedAddress;
    PVOID       MapBase;
    SIZE_T      dwMappedSize;

    PIMAGE_DOS_HEADER   DosHeader;
    PIMAGE_NT_HEADERS   FileHeader;

    LARGE_INTEGER       liSectionSize;
    PLARGE_INTEGER       pliSectionSize;
    LARGE_INTEGER       liSectionOffset;
    OBJECT_ATTRIBUTES   obFile;
    IO_STATUS_BLOCK     IoStatusBlock;
    BOOL                bRetCode;
	USHORT              wBufOffset;
	USHORT              wDiffSize;

    // allocate this item's memory

    pThisModule = ALLOCMEM (
        hLibHeap,
        HEAP_ZERO_MEMORY,
        sizeof (MODINFO));

    if (!pThisModule) {
        return NULL;
    }

    // allocate this items Instance Name Buffer

    wStringSize = (WORD)(ModuleListEntry->BaseDllName.MaximumLength +
        sizeof (UNICODE_NULL));

    pusInstanceName = ALLOCMEM (
        hLibHeap,
        HEAP_ZERO_MEMORY,
        wStringSize + sizeof(UNICODE_STRING))  ;

    if (!pusInstanceName) {
        goto MBailOut;
    }

    pusInstanceName->Length = 0;
    pusInstanceName->MaximumLength = wStringSize;
    pusInstanceName->Buffer = (PWCHAR)&pusInstanceName[1];

    // save instance name using full file path

    wStringSize = (WORD)(ModuleListEntry->FullDllName.MaximumLength +
        sizeof (UNICODE_NULL));

    pusLongInstanceName = ALLOCMEM (
        hLibHeap,
        HEAP_ZERO_MEMORY,
        wStringSize + sizeof (UNICODE_STRING));

    if (!pusLongInstanceName) {
        goto MBailOut;
    }

    pusLongInstanceName->Length = 0;
    pusLongInstanceName->MaximumLength = wStringSize;
    pusLongInstanceName->Buffer = (PWCHAR)&pusLongInstanceName[1];

    // allocate temporary buffer for image name

    usImageFileName.Length = ModuleListEntry->FullDllName.Length;
    usImageFileName.MaximumLength = ModuleListEntry->FullDllName.MaximumLength;
    ImageNameBuffer = usImageFileName.Buffer = ALLOCMEM(
        hLibHeap,
        HEAP_ZERO_MEMORY,
        usImageFileName.MaximumLength);
    if ( !usImageFileName.Buffer ) {
        goto MBailOut;
    }

    // allocate temporary buffer for exe name

    usExeFileName.Length = ModuleListEntry->BaseDllName.Length;
    usExeFileName.MaximumLength = ModuleListEntry->BaseDllName.MaximumLength;
    usExeFileName.Buffer = ALLOCMEM(
        hLibHeap,
        HEAP_ZERO_MEMORY,
        usExeFileName.MaximumLength);
    if ( !usExeFileName.Buffer ) {
        goto MBailOut;
    }

    // read base .exe/.dll name of image

    Status = NtReadVirtualMemory(
            pProcess->hProcess,
        	ModuleListEntry->BaseDllName.Buffer,
        	usExeFileName.Buffer,
        	usExeFileName.MaximumLength,
            NULL
            );
    if ( !NT_SUCCESS(Status) ) {
        goto MBailOut;
    }

    // read full name of image

    Status = NtReadVirtualMemory(
            pProcess->hProcess,
        	ModuleListEntry->FullDllName.Buffer,
        	usImageFileName.Buffer,
        	usImageFileName.MaximumLength,
            NULL
            );

    if ( !NT_SUCCESS(Status) ) {
        goto MBailOut;
    }

    // make a DOS filename to convert to NT again

	wDiffSize = wBufOffset = 0;
    p = p1 = usImageFileName.Buffer;
    while (*p != (WCHAR)0){
        if (*p == L':'){
            p1 = p;
			wDiffSize = wBufOffset;
        }
		wBufOffset += sizeof(WCHAR);
        p++;
    }
    if (p1 != usImageFileName.Buffer) {
		// move pointer
        usImageFileName.Buffer = --p1;
		// adjust length fields
		wDiffSize -= (USHORT)(sizeof(WCHAR));
		usImageFileName.Length = usImageFileName.Length - wDiffSize;
		usImageFileName.MaximumLength = usImageFileName.MaximumLength - wDiffSize;
    }

    // Create/copy a NT filename for Nt file operation

    bRetCode = RtlDosPathNameToNtPathName_U (
        usImageFileName.Buffer,
        &usNtFileName,
        NULL,
        NULL);

    if ( !bRetCode ) {
        goto MBailOut;
    }

    // get handle to file

    InitializeObjectAttributes(
        &obFile,
        &usNtFileName,
        FILE_ATTRIBUTE_NORMAL | OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile (
        &hFile,
        (ACCESS_MASK)GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
        &obFile,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL & FILE_ATTRIBUTE_VALID_FLAGS,
        FILE_SHARE_READ,
        FILE_OPEN,
        0,
        NULL,
        0);

    if (!NT_SUCCESS(Status)) {
        goto MBailOut;
    }

    pliSectionSize = &liSectionSize;
    liSectionSize.HighPart = 0;
    liSectionSize.LowPart = 0;

    InitializeObjectAttributes (
        &obFile,
        NULL,
        0,
        NULL,
        NULL);

    Status = NtCreateSection (
        &hMappedFile,
        SECTION_QUERY | SECTION_MAP_READ,
        &obFile,
        pliSectionSize,
        PAGE_READONLY,
        SEC_COMMIT,
        hFile);

    if ( ! NT_SUCCESS(Status)) {
        CloseHandle(hFile);
        goto MBailOut;
        }

    // get pointer to mapped memory
    MappedAddress = MapBase = NULL;
    dwMappedSize = 0;

    liSectionOffset.LowPart = 0;
    liSectionOffset.HighPart = 0;

    Status = NtMapViewOfSection (
        hMappedFile,
        NtCurrentProcess(),
        &MapBase,
        0L,
        0L,
        &liSectionOffset,
        &dwMappedSize,
        ViewShare,
        0L,
        PAGE_READONLY);

    CloseHandle(hMappedFile);

    if (NT_SUCCESS(Status)) {
        MappedAddress = MapBase;
    } else {
        CloseHandle(hFile);
        goto MBailOut;
    }

    // check for dos image signature (if a dos file)

    DosHeader = (PIMAGE_DOS_HEADER)MappedAddress;

    if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
        UnmapViewOfFile(MappedAddress);
        CloseHandle(hFile);
        goto MBailOut;
        }

    FileHeader = (PIMAGE_NT_HEADERS)((UINT_PTR)DosHeader + DosHeader->e_lfanew);

    if ( FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
        UnmapViewOfFile(MappedAddress);
        CloseHandle(hFile);
        goto MBailOut;
        }

    // get base address for this module and save in local data structure

    pThisModule->BaseAddress = ModuleListEntry->DllBase;

    // get image name

    RtlCopyUnicodeString (
        pusInstanceName,
        &usExeFileName);

    RtlCopyUnicodeString (
        pusLongInstanceName,
        &usImageFileName);

    pThisModule->InstanceName = pusInstanceName;
    pThisModule->LongInstanceName = pusLongInstanceName;
    pThisModule->pNextModule = NULL;
    pThisModule->TotalCommit = 0;

    memset (
        &pThisModule->CommitVector[0], 0,
        sizeof (pThisModule->CommitVector));

    pThisModule->VirtualSize = FileHeader->OptionalHeader.SizeOfImage;

    // close file handles

    UnmapViewOfFile(MappedAddress);
    CloseHandle(hFile);

    // free local memory
    FREEMEM (
        RtlProcessHeap(),   // this is allocated by an RTL function
        0,
        usNtFileName.Buffer);

//    FREEMEM (
//        hLibHeap,
//        0,
//        RelativeName.RelativeName.Buffer);

    FREEMEM (
        hLibHeap,
        0,
        ImageNameBuffer);

    FREEMEM (
        hLibHeap,
        0,
        usExeFileName.Buffer);

    return (pThisModule);   // return pointer to completed module structure
//
//  Module bail out point, called when the routine is unable to continue
//  for some reason. This cleans up any allocated memory, etc.
//
MBailOut:

    if (pThisModule) {
        FREEMEM (
            hLibHeap,
            0,
            pThisModule);
    }

    if (usNtFileName.Buffer) {
        FREEMEM (
            RtlProcessHeap(),   // this is allocated by an RTL function
            0,
            usNtFileName.Buffer);
    }

//    if (RelativeName.RelativeName.Buffer) {
//        FREEMEM (
//            hLibHeap,
//            0,
//            RelativeName.RelativeName.Buffer);
//    }

    if (pusInstanceName) {
        FREEMEM (
            hLibHeap,
            0,
            pusInstanceName);

        }

    if (pusLongInstanceName) {
        FREEMEM (
            hLibHeap,
            0,
            pusLongInstanceName);

        }

    if (ImageNameBuffer) {
        FREEMEM (
            hLibHeap,
            0,
            ImageNameBuffer);
        }

    if (usExeFileName.Buffer){
        FREEMEM (
            hLibHeap,
            0,
            usExeFileName.Buffer);
        }

    return NULL;
}

PMODINFO
LocateModInfo(
    IN PMODINFO    pFirstMod,
    IN PVOID    pAddress,
    IN SIZE_T   dwExtent
    )
/*++

LocateModInfo

    Locates the images associated with the address passed in the argument list

Arguments

    IN PMODINFO pFirstMod,
        first module entry  in process list

    IN PVOID Address
        Address to search for in list

Return Value

    Pointer to matching image or
    NULL if no match found

--*/
{
    PMODINFO    pThisMod;

    pThisMod = pFirstMod;

    while (pThisMod)  { // go to end of list or match is found

        // match criteria are:
        //  address >= Module BaseAddress  and
        //  address+extent between base and base+image_extent

        if (pAddress >= pThisMod->BaseAddress) {
            if ((PVOID)((PDWORD)pAddress + dwExtent) <=
                (PVOID)((ULONG_PTR)pThisMod->BaseAddress+pThisMod->VirtualSize)) {
                return (pThisMod);
            }
        }

        pThisMod = pThisMod->pNextModule;

    }

    return NULL;
}

DWORD
ProtectionToIndex(
    IN ULONG Protection
    )
/*++

ProtectionToIndex

    Determine the memory access protection type and return local code

Arguments

   IN ULONG
        Protection

        Process memory protection mask

Return Value

    Local value of protection type

--*/
{
    Protection &= (PAGE_NOACCESS |
                    PAGE_READONLY |
                    PAGE_READWRITE |
                    PAGE_WRITECOPY |
                    PAGE_EXECUTE |
                    PAGE_EXECUTE_READ |
                    PAGE_EXECUTE_READWRITE |
                    PAGE_EXECUTE_WRITECOPY);

    switch ( Protection ) {

        case PAGE_NOACCESS:
                return NOACCESS;

        case PAGE_READONLY:
                return READONLY;

        case PAGE_READWRITE:
                return READWRITE;

        case PAGE_WRITECOPY:
                return WRITECOPY;

        case PAGE_EXECUTE:
                return EXECUTE;

        case PAGE_EXECUTE_READ:
                return EXECUTEREAD;

        case PAGE_EXECUTE_READWRITE:
                return EXECUTEREADWRITE;

        case PAGE_EXECUTE_WRITECOPY:
                return EXECUTEWRITECOPY;
        default:
                return 0xFFFFFFFF;
        }
}

BOOL
FreeSystemVaData (
    IN PPROCESS_VA_INFO pFirstProcess
)
{
    PPROCESS_VA_INFO pThisProcess, pNextProcess;

    pThisProcess = pFirstProcess;
    while (pThisProcess) {
        pNextProcess = pThisProcess->pNextProcess;  // save pointer to next
        FreeProcessVaData (pThisProcess);
        pThisProcess = pNextProcess;    // do next until NULL pointer
    }
    return (FALSE);
}

BOOL
FreeProcessVaData (
    IN PPROCESS_VA_INFO pProcess
)
{
    PMODINFO    pThisModule, pNextModule;

    if (pProcess) {
        if (pProcess->pProcessName) {
            FREEMEM (
                hLibHeap,
                0,
                pProcess->pProcessName);
            pProcess->pProcessName = NULL;
        }
        if (pProcess->BasicInfo) {
            FREEMEM (
                hLibHeap,
                0,
                pProcess->BasicInfo);
            pProcess->BasicInfo = NULL;
        }


        pThisModule = pProcess->pMemBlockInfo;
        while (pThisModule) {
            pNextModule = pThisModule->pNextModule;
            FreeModuleVaData (pThisModule);
            pThisModule = pNextModule;
        }
        //
        //  and finally throw ourselves away
        //
        FREEMEM (
            hLibHeap,
            0,
            pProcess);
    }
    return FALSE;
}

BOOL
FreeModuleVaData (
    IN PMODINFO pModule
)
{
    if (pModule) {
        if (pModule->InstanceName) {
            FREEMEM(
                hLibHeap,
                0,
                pModule->InstanceName);
            pModule->InstanceName = NULL;
        }
        if (pModule->LongInstanceName) {
            FREEMEM(
                hLibHeap,
                0,
                pModule->LongInstanceName);
            pModule->LongInstanceName = NULL;
        }
        FREEMEM (
            hLibHeap,
            0,
            pModule);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\extquery.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000   Microsoft Corporation

Module Name:

    extinit.c

Abstract:

    This file implements all the initialization library routines operating on
    extensible performance libraries.

Author:

    JeePang

Revision History:

    09/27/2000  -   JeePang     - Moved from perflib.c

--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <winperf.h>
#include <rpc.h>
#include "regrpc.h"
#include "ntconreg.h"
#include "prflbmsg.h"   // event log messages
#include "perflib.h"
#pragma warning(default:4306)

//
//  static constant definitions
//
//      constants used by guard page testing
//
#define GUARD_PAGE_SIZE 1024
#define GUARD_PAGE_CHAR 0xA5
#define GUARD_PAGE_DWORD 0xA5A5A5A5

typedef struct _EXT_OBJ_ITEM {
    DWORD       dwObjId;
    DWORD       dwFlags;
} EXT_OBJ_LIST, *PEXT_OBJ_LIST;

#define PERF_EOL_ITEM_FOUND ((DWORD)0x00000001)

__inline
DWORD
RegisterExtObjListAccess ()
{
    LONG    Status;
    LARGE_INTEGER   liWaitTime;

    if (hGlobalDataMutex != NULL) {
        liWaitTime.QuadPart = MakeTimeOutValue(QUERY_WAIT_TIME);
        // wait for access to the list of ext objects
        Status = NtWaitForSingleObject (
            hGlobalDataMutex,
            FALSE,
            &liWaitTime);
        if (Status != WAIT_TIMEOUT) {
            if (hExtObjListIsNotInUse != NULL) {
                // indicate that we are going to use the list
                InterlockedIncrement ((LONG *)&dwExtObjListRefCount);
                if (dwExtObjListRefCount > 0) {
                    ResetEvent (hExtObjListIsNotInUse); // indicate list is busy
                } else {
                    SetEvent (hExtObjListIsNotInUse); // indicate list is not busy
                }
                Status = ERROR_SUCCESS;
            } else {
                Status = ERROR_NOT_READY;
            }
            ReleaseMutex (hGlobalDataMutex);
        }  // else return status;
    } else {
        Status = ERROR_LOCK_FAILED;
    }
    return Status;
}

__inline
DWORD
DeRegisterExtObjListAccess ()
{
    LONG    Status;
    LARGE_INTEGER   liWaitTime;

    if (hGlobalDataMutex != NULL) {
        liWaitTime.QuadPart = MakeTimeOutValue(QUERY_WAIT_TIME);
        // wait for access to the list of ext objects
        Status = NtWaitForSingleObject (
            hGlobalDataMutex,
            FALSE,
            &liWaitTime);
        if (Status != WAIT_TIMEOUT) {
            if (hExtObjListIsNotInUse != NULL) {
                assert (dwExtObjListRefCount > 0);
                // indicate that we are going to use the list
                InterlockedDecrement ((LONG *)&dwExtObjListRefCount);
                if (dwExtObjListRefCount > 0) {
                    ResetEvent (hExtObjListIsNotInUse); // indicate list is busy
                } else {
                    SetEvent (hExtObjListIsNotInUse); // indicate list is not busy
                }
                Status = ERROR_SUCCESS;
            } else {
                Status = ERROR_NOT_READY;
            }
            ReleaseMutex (hGlobalDataMutex);
        }  // else return status;
    } else {
        Status = ERROR_LOCK_FAILED;
    }
    return Status;
}

LONG
QueryExtensibleData (
    COLLECT_THREAD_DATA * pArgs
)
/*++
  QueryExtensibleData -    Get data from extensible objects

      Inputs:

          dwQueryType         - Query type (GLOBAL, COSTLY, item list, etc.)

          lpValueName         -   pointer to value string (unused)

          lpData              -   pointer to start of data block
                                  where data is being collected

          lpcbData            -   pointer to size of data buffer

          lppDataDefinition   -   pointer to pointer to where object
                                  definition for this object type should
                                  go

      Outputs:

          *lppDataDefinition  -   set to location for next Type
                                  Definition if successful

      Returns:

          0 if successful, else Win 32 error code of failure


--*/
{
    DWORD   dwQueryType = pArgs->dwQueryType;
    LPWSTR  lpValueName = pArgs->lpValueName;
    LPBYTE  lpData = pArgs->lpData;
    LPDWORD lpcbData = pArgs->lpcbData;
    LPVOID  *lppDataDefinition = pArgs->lppDataDefinition;

    DWORD Win32Error=ERROR_SUCCESS;          //  Failure code
    DWORD BytesLeft;
    DWORD InitialBytesLeft;
    DWORD NumObjectTypes;

    LPVOID  lpExtDataBuffer = NULL;
    LPVOID  lpCallBuffer = NULL;
    LPVOID  lpLowGuardPage = NULL;
    LPVOID  lpHiGuardPage = NULL;
    LPVOID  lpEndPointer = NULL;
    LPVOID  lpBufferBefore = NULL;
    LPVOID  lpBufferAfter = NULL;
    PUCHAR  lpCheckPointer;
    LARGE_INTEGER   liStartTime, liEndTime, liWaitTime;

    PEXT_OBJECT  pThisExtObj = NULL;
    DWORD   dwLibEntry;

    BOOL    bGuardPageOK;
    BOOL    bBufferOK;
    BOOL    bException;
    BOOL    bUseSafeBuffer;
    BOOL    bUnlockObjData = FALSE;

    LPTSTR  szMessageArray[8];
    ULONG_PTR   dwRawDataDwords[8];     // raw data buffer
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    LONG    lReturnValue = ERROR_SUCCESS;

    LONG    lDllTestLevel;

    LONG                lInstIndex;
    DWORD               lCtrIndex;
    PERF_OBJECT_TYPE    *pObject, *pNextObject;
    PERF_INSTANCE_DEFINITION    *pInstance;
    PERF_COUNTER_DEFINITION     *pCounterDef;
    PERF_DATA_BLOCK     *pPerfData;
    BOOL                bForeignDataBuffer;

    DWORD           dwItemsInArray = 0;
    DWORD           dwItemsInList = 0;
    volatile PEXT_OBJ_LIST   pQueryList = NULL;
    LPWSTR          pwcThisChar;

    DWORD           dwThisNumber;
    DWORD           dwIndex, dwEntry;
    BOOL            bFound;
    BOOL            bDisabled = FALSE;
    BOOL            bUseTimer;
    DWORD           dwType = 0;
    DWORD           dwValue = 0;
    DWORD           dwSize = sizeof(DWORD);
    DWORD           status = 0;
    DWORD           dwObjectBufSize;

    OPEN_PROC_WAIT_INFO opwInfo;
    HANDLE  hPerflibFuncTimer;
    PVOID           pOldBuffer;

    HEAP_PROBE();

    // see if perf data has been disabled
    // this is to prevent crashing WINLOGON if the
    // system has installed a bogus DLL

    assert (ghKeyPerflib != NULL);
    dwSize = sizeof(dwValue);
    dwValue = dwType = 0;
    status = PrivateRegQueryValueExW (
        ghKeyPerflib,
        DisablePerformanceCounters,
        NULL,
        &dwType,
        (LPBYTE)&dwValue,
        &dwSize);

    if ((status == ERROR_SUCCESS) &&
        (dwType == REG_DWORD) &&
        (dwValue == 1)) {
        // then DON'T Load any libraries and unload any that have been
        // loaded
        bDisabled = TRUE;
    }

    // if data collection is disabled and there's a collection thread
    // then close it
    if (bDisabled && (hCollectThread != NULL)) {
        pArgs->dwActionFlags = CTD_AF_CLOSE_THREAD;
    } else if (!bDisabled &&
        ((hCollectThread == NULL) && (dwCollectionFlags == COLL_FLAG_USE_SEPARATE_THREAD))) {
        // then data collection is enabled and they want a separate collection
        // thread, but there's no thread at the moment, so create it here
        pArgs->dwActionFlags = CTD_AF_OPEN_THREAD;
    }

    lReturnValue = RegisterExtObjListAccess();

    if (lReturnValue == ERROR_SUCCESS) {
        liStartTime.QuadPart = 0;
        InitialBytesLeft = 0;
        liEndTime.QuadPart = 0;

        if ((dwQueryType == QUERY_ITEMS) && (!bDisabled)) {
            // alloc the call list
            pwcThisChar = lpValueName;
            dwThisNumber = 0;

            // read the value string and build an object ID list

            while (*pwcThisChar != 0) {
                dwThisNumber = GetNextNumberFromList (
                    pwcThisChar, &pwcThisChar);
                if (dwThisNumber != 0) {
                    if (dwItemsInList >= dwItemsInArray) {
                        dwItemsInArray += 16;   // starting point for # of objects
                        pOldBuffer = NULL;
                        if (pQueryList == NULL) {
                            // alloc a new buffer
                            pQueryList = ALLOCMEM ((sizeof(EXT_OBJ_LIST) * dwItemsInArray));
                        } else {
                            // realloc a new buffer
                            pOldBuffer = pQueryList;
                            pQueryList = REALLOCMEM(pQueryList,
                                (sizeof(EXT_OBJ_LIST) * dwItemsInArray));
                        }
                        if (pQueryList == NULL) {
                            // unable to alloc memory so bail
                            if (pOldBuffer)
                                FREEMEM(pOldBuffer);
                            return ERROR_OUTOFMEMORY;
                        }
                    }

                    // then add to the list
                    pQueryList[dwItemsInList].dwObjId = dwThisNumber;
                    pQueryList[dwItemsInList].dwFlags = 0;
                    dwItemsInList++;
                }
            }

            if (Win32Error == ERROR_SUCCESS) {
                //
                //  Walk through list of ext. objects and tag the ones to call
                //  as the query objects are found
                //
                for (pThisExtObj = ExtensibleObjects, dwLibEntry = 0;
                    pThisExtObj != NULL;
                    pThisExtObj = pThisExtObj->pNext, dwLibEntry++) {

                    if (pThisExtObj->dwNumObjects > 0) {
                        // then examine list
                        for (dwIndex = 0; dwIndex < pThisExtObj->dwNumObjects; dwIndex++) {
                            // look at each entry in the list
                            for (dwEntry = 0; dwEntry < dwItemsInList; dwEntry++) {
                                if (pQueryList[dwEntry].dwObjId == pThisExtObj->dwObjList[dwIndex]) {
                                    // tag this entry as found
                                    pQueryList[dwEntry].dwFlags |= PERF_EOL_ITEM_FOUND;
                                    // tag the object as needed
                                    pThisExtObj->dwFlags |= PERF_EO_OBJ_IN_QUERY;
                                }
                            }
                        }
                    } else {
                        // this entry doesn't list it's supported objects
                    }
                }

                assert (dwLibEntry == NumExtensibleObjects);

                // see if any in the query list do not have entries

                bFound = TRUE;
                for (dwEntry = 0; dwEntry < dwItemsInList; dwEntry++) {
                    if (!(pQueryList[dwEntry].dwFlags & PERF_EOL_ITEM_FOUND)) {
                        // no matching object found
                        bFound = FALSE;
                        break;
                    }
                }

                if (!bFound) {
                    // at least one of the object ID's in the query list was
                    // not found in an object that supports an object list
                    // then tag all entries that DO NOT support an object list
                    // to be called and hope one of them supports it/them.
                    for (pThisExtObj = ExtensibleObjects;
                         pThisExtObj != NULL;
                         pThisExtObj = pThisExtObj->pNext) {
                        if (pThisExtObj->dwNumObjects == 0) {
                            // tag this one so it will be called
                            pThisExtObj->dwFlags |= PERF_EO_OBJ_IN_QUERY;
                        }
                    }
                }
            } // end if first scan was successful

            if (pQueryList != NULL) FREEMEM (pQueryList);
        } // end if QUERY_ITEMS


        if (lReturnValue == ERROR_SUCCESS) {
            for (pThisExtObj = ExtensibleObjects;
                 pThisExtObj != NULL;
                 pThisExtObj = pThisExtObj->pNext) {

                // set the current ext object pointer
                pArgs->pCurrentExtObject = pThisExtObj;
                // convert timeout value
                liWaitTime.QuadPart = MakeTimeOutValue (pThisExtObj->dwCollectTimeout);

                // close the unused Perf DLL's IF:
                //  the perflib key is disabled or this is an item query
                //  and this is an Item (as opposed to a global or foreign)  query or
                //      the requested objects are not it this library or this library is disabled
                //  and this library has been opened
                //
                if (((dwQueryType == QUERY_ITEMS) || bDisabled) &&
                    (bDisabled || (!(pThisExtObj->dwFlags & PERF_EO_OBJ_IN_QUERY)) || (pThisExtObj->dwFlags & PERF_EO_DISABLED)) &&
                    (pThisExtObj->hLibrary != NULL)) {
                    // then free this object
                    if (pThisExtObj->hMutex != NULL) {
                        NTSTATUS NtStatus = NtWaitForSingleObject (
                            pThisExtObj->hMutex,
                            FALSE,
                            &liWaitTime);
                        Win32Error = PerfpDosError(NtStatus);
                        if (NtStatus == STATUS_SUCCESS) {
                            // then we got a lock
                            CloseExtObjectLibrary (pThisExtObj, bDisabled);
                            ReleaseMutex (pThisExtObj->hMutex);
                        } else {
                            pThisExtObj->dwLockoutCount++;
                            DebugPrint((0, "Unable to Lock object for %ws to close in Query\n", pThisExtObj->szServiceName));
                        }
                    } else {
                        Win32Error = ERROR_LOCK_FAILED;
                        DebugPrint((0, "No Lock found for %ws\n", pThisExtObj->szServiceName));
                    }

                    if (hCollectThread != NULL) {
                        // close the collection thread

                    }
                } else if (((dwQueryType == QUERY_FOREIGN) ||
                            (dwQueryType == QUERY_GLOBAL) ||
                            (dwQueryType == QUERY_COSTLY) ||
                            ((dwQueryType == QUERY_ITEMS) &&
                             (pThisExtObj->dwFlags & PERF_EO_OBJ_IN_QUERY))) &&
                           (!(pThisExtObj->dwFlags & PERF_EO_DISABLED))) {

                    // initialize values to pass to the extensible counter function
                    NumObjectTypes = 0;
                    BytesLeft = (DWORD) (*lpcbData - ((LPBYTE) *lppDataDefinition - lpData));
                    bException = FALSE;

                    if ((pThisExtObj->hLibrary == NULL) ||
                        (dwQueryType == QUERY_GLOBAL) ||
                        (dwQueryType == QUERY_COSTLY)) {
                        // lock library object
                        if (pThisExtObj->hMutex != NULL) {
                            NTSTATUS NtStatus = NtWaitForSingleObject (
                                pThisExtObj->hMutex,
                                FALSE,
                                &liWaitTime);
                            Win32Error = ERROR_SUCCESS;
                            if (NtStatus == STATUS_SUCCESS) {
                                // if this is a global or costly query, then reset the "in query"
                                // flag for this object. The next ITEMS query will restore it.
                                if ((dwQueryType == QUERY_GLOBAL) ||
                                    (dwQueryType == QUERY_COSTLY)) {
                                    pThisExtObj->dwFlags &= ~PERF_EO_OBJ_IN_QUERY;
                                }
                                // if necessary, open the library
                                if (pThisExtObj->hLibrary == NULL) {
                                    // make sure the library is open
                                    Win32Error = OpenExtObjectLibrary(pThisExtObj);
                                    if (Win32Error != ERROR_SUCCESS) {
                                        if (Win32Error != ERROR_SERVICE_DISABLED) {
                                            // SERVICE_DISABLED is returned when the
                                            // service has been disabled via ExCtrLst.
                                            // so no point in complaining about it.
                                            // assume error has been posted
                                            DebugPrint((0, "Unable to open perf counter library for %ws, Error: 0x%8.8x\n",
                                                pThisExtObj->szServiceName, Win32Error));
                                        }
                                        ReleaseMutex (pThisExtObj->hMutex);
                                        continue; // to next entry
                                    }
                                }
                                ReleaseMutex (pThisExtObj->hMutex);
                            } else {
                                Win32Error = PerfpDosError(NtStatus);
                                pThisExtObj->dwLockoutCount++;
                                DebugPrint((0, "Unable to Lock object for %ws to open for Query\n", pThisExtObj->szServiceName));
                            }
                        } else {
                            Win32Error = ERROR_LOCK_FAILED;
                            DebugPrint((0, "No Lock found for %ws\n", pThisExtObj->szServiceName));
                        }
                    } else {
                        // library should be ready to use
                    }

                    // if this dll is trusted, then use the system
                    // defined test level, otherwise, test it
                    // thorourghly
                    bUseTimer = TRUE;   // default
                    if (!(lPerflibConfigFlags & PLCF_NO_DLL_TESTING)) {
                        if (pThisExtObj->dwFlags & PERF_EO_TRUSTED) {
                            lDllTestLevel = lExtCounterTestLevel;
                            bUseTimer = FALSE;   // Trusted DLL's are not timed
                        } else {
                            // not trusted so use full test
                            lDllTestLevel = EXT_TEST_ALL;
                        }
                    } else {
                        // disable DLL testing
                        lDllTestLevel = EXT_TEST_NOMEMALLOC;
                        bUseTimer = FALSE;   // Timing is disabled as well
                    }

                    if (lDllTestLevel < EXT_TEST_NOMEMALLOC) {
                        bUseSafeBuffer = TRUE;
                    } else {
                        bUseSafeBuffer = FALSE;
                    }

                    // allocate a local block of memory to pass to the
                    // extensible counter function.

                    if (bUseSafeBuffer) {
                        lpExtDataBuffer = ALLOCMEM (BytesLeft + (2*GUARD_PAGE_SIZE));
                    } else {
                        lpExtDataBuffer =
                            lpCallBuffer = *lppDataDefinition;
                    }

                    if (lpExtDataBuffer != NULL) {

                        if (bUseSafeBuffer) {
                            // set buffer pointers
                            lpLowGuardPage = lpExtDataBuffer;
                            lpCallBuffer = (LPBYTE)lpExtDataBuffer + GUARD_PAGE_SIZE;
                            lpHiGuardPage = (LPBYTE)lpCallBuffer + BytesLeft;
                            lpEndPointer = (LPBYTE)lpHiGuardPage + GUARD_PAGE_SIZE;

                            // initialize GuardPage Data

                            memset (lpLowGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
                            memset (lpHiGuardPage, GUARD_PAGE_CHAR, GUARD_PAGE_SIZE);
                        }

                        lpBufferBefore = lpCallBuffer;
                        lpBufferAfter = NULL;
                        hPerflibFuncTimer = NULL;

                        try {
                            //
                            //  Collect data from extensible objects
                            //

                            if (pThisExtObj->hMutex != NULL) {
                                NTSTATUS NtStatus = NtWaitForSingleObject (
                                    pThisExtObj->hMutex,
                                    FALSE,
                                    &liWaitTime);
                                Win32Error = PerfpDosError(NtStatus);
                                if ((NtStatus == STATUS_SUCCESS)  &&
                                    (pThisExtObj->CollectProc != NULL)) {

                                    bUnlockObjData = TRUE;

                                    opwInfo.pNext = NULL;
                                    opwInfo.szLibraryName = pThisExtObj->szLibraryName;
                                    opwInfo.szServiceName = pThisExtObj->szServiceName;
                                    opwInfo.dwWaitTime = pThisExtObj->dwCollectTimeout;
                                    opwInfo.dwEventMsg = PERFLIB_COLLECTION_HUNG;
                                    opwInfo.pData = (LPVOID)pThisExtObj;
                                    if (bUseTimer) {
                                        hPerflibFuncTimer = StartPerflibFunctionTimer(&opwInfo);
                                        // if no timer, continue anyway, even though things may
                                        // hang, it's better than not loading the DLL since they
                                        // usually load OK
                                        //
                                        if (hPerflibFuncTimer == NULL) {
                                            // unable to get a timer entry
                                            DebugPrint((0, "Unable to acquire timer for Collect Proc\n"));
                                        }
                                    } else {
                                        hPerflibFuncTimer = NULL;
                                    }

                                    InitialBytesLeft = BytesLeft;

                                    QueryPerformanceCounter (&liStartTime);

                                    Win32Error =  (*pThisExtObj->CollectProc) (
                                            lpValueName,
                                            &lpCallBuffer,
                                            &BytesLeft,
                                            &NumObjectTypes);

                                    QueryPerformanceCounter (&liEndTime);

                                    if (hPerflibFuncTimer != NULL) {
                                        // kill timer
                                        KillPerflibFunctionTimer (hPerflibFuncTimer);
                                        hPerflibFuncTimer = NULL;
                                    }

                                    // update statistics

                                    pThisExtObj->dwLastBufferSize = BytesLeft;

                                    if (BytesLeft > pThisExtObj->dwMaxBufferSize) {
                                        pThisExtObj->dwMaxBufferSize = BytesLeft;
                                    }

                                    if ((Win32Error == ERROR_MORE_DATA) &&
                                        (InitialBytesLeft > pThisExtObj->dwMaxBufferRejected)) {
                                        pThisExtObj->dwMaxBufferRejected = InitialBytesLeft;
                                    }

                                    lpBufferAfter = lpCallBuffer;

                                    pThisExtObj->llLastUsedTime = GetTimeAsLongLong();

                                    ReleaseMutex (pThisExtObj->hMutex);
                                    bUnlockObjData = FALSE;
                                } else {
                                    if ((pThisExtObj->CollectProc != NULL) &&
                                        (lEventLogLevel >= LOG_USER)) {
                                        DebugPrint((0,
                                            "Unable to Lock object for %ws to Collect data\n",
                                            pThisExtObj->szServiceName));
                                        dwDataIndex = wStringIndex = 0;
                                        dwRawDataDwords[dwDataIndex++] = BytesLeft;
                                        dwRawDataDwords[dwDataIndex++] =
                                            (ULONG_PTR)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                                        szMessageArray[wStringIndex++] =
                                            pThisExtObj->szServiceName;
                                        szMessageArray[wStringIndex++] =
                                            pThisExtObj->szLibraryName;
                                        ReportEvent (hEventLog,
                                            EVENTLOG_WARNING_TYPE,      // error type
                                            0,                          // category (not used)
                                            (DWORD)PERFLIB_COLLECTION_HUNG,   // event,
                                            NULL,                       // SID (not used),
                                            wStringIndex,              // number of strings
                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                            szMessageArray,                // message text array
                                            (LPVOID)&dwRawDataDwords[0]);           // raw data

                                        pThisExtObj->dwLockoutCount++;
                                    } else {
                                        // else it's not open so ignore.
                                        BytesLeft = 0;
                                        NumObjectTypes = 0;
                                    }
                                }
                            } else {
                                Win32Error = ERROR_LOCK_FAILED;
                                DebugPrint((0, "No Lock found for %ws\n", pThisExtObj->szServiceName));
                            }

                            if ((Win32Error == ERROR_SUCCESS) && (BytesLeft > 0)) {
                                // increment perf counters
                                if ((BytesLeft > InitialBytesLeft) &&
                                    (lEventLogLevel >= LOG_USER)) {
                                    // memory error
                                    dwDataIndex = wStringIndex = 0;
                                    dwRawDataDwords[dwDataIndex++] = (ULONG_PTR)InitialBytesLeft;
                                    dwRawDataDwords[dwDataIndex++] = (ULONG_PTR)BytesLeft;
                                    szMessageArray[wStringIndex++] =
                                        pThisExtObj->szServiceName;
                                    szMessageArray[wStringIndex++] =
                                        pThisExtObj->szLibraryName;
                                    ReportEvent (hEventLog,
                                        EVENTLOG_ERROR_TYPE,      // error type
                                        0,                          // category (not used)
                                        (DWORD)PERFLIB_INVALID_SIZE_RETURNED,   // event,
                                        NULL,                       // SID (not used),
                                        wStringIndex,              // number of strings
                                        dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                        szMessageArray,                // message text array
                                        (LPVOID)&dwRawDataDwords[0]);           // raw data

                                    // disable the dll unless:
                                    //      testing has been disabled.
                                    //      or this is a trusted DLL (which are never disabled)
                                    //  the event log message should be reported in any case since
                                    //  this is a serious error
                                    //
                                    if ((!(lPerflibConfigFlags & PLCF_NO_DLL_TESTING)) &&
                                        (!(pThisExtObj->dwFlags & PERF_EO_TRUSTED))) {
                                        DisablePerfLibrary (pThisExtObj);
                                    }
                                    // set error values to correct entries
                                    BytesLeft = 0;
                                    NumObjectTypes = 0;
                                } else {
                                    // the buffer seems ok so far, so validate it

                                    InterlockedIncrement ((LONG *)&pThisExtObj->dwCollectCount);
                                    pThisExtObj->llElapsedTime +=
                                        liEndTime.QuadPart - liStartTime.QuadPart;

                                    // test all returned buffers for correct alignment
                                    if ((((ULONG_PTR)BytesLeft & (ULONG_PTR)0x07)) &&
                                        !(lPerflibConfigFlags & PLCF_NO_ALIGN_ERRORS)) {
                                        if (((pThisExtObj->dwFlags & PERF_EO_ALIGN_ERR_POSTED) == 0) &&
                                            (lEventLogLevel >= LOG_USER)) {
                                            dwDataIndex = wStringIndex = 0;
                                            dwRawDataDwords[dwDataIndex++] = (ULONG_PTR)lpCallBuffer;
                                            dwRawDataDwords[dwDataIndex++] = (ULONG_PTR)BytesLeft;
                                            szMessageArray[wStringIndex++] =
                                                pThisExtObj->szServiceName;
                                            szMessageArray[wStringIndex++] =
                                                pThisExtObj->szLibraryName;
                                            ReportEvent (hEventLog,
                                                EVENTLOG_WARNING_TYPE,      // error type
                                                0,                          // category (not used)
                                                (DWORD)PERFLIB_BUFFER_ALIGNMENT_ERROR,   // event,
                                                NULL,                       // SID (not used),
                                                wStringIndex,              // number of strings
                                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                szMessageArray,                // message text array
                                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                                            pThisExtObj->dwFlags |= PERF_EO_ALIGN_ERR_POSTED;
                                        }
                                    }

                                    if (bUseSafeBuffer) {
                                        // a data buffer was returned and
                                        // the function returned OK so see how things
                                        // turned out...
                                        //
                                        //
                                        // check for buffer corruption here
                                        //
                                        bBufferOK = TRUE; // assume it's ok until a check fails
                                        //
                                        if (lDllTestLevel <= EXT_TEST_BASIC) {
                                            //
                                            //  check 1: bytes left should be the same as
                                            //      new data buffer ptr - orig data buffer ptr
                                            //
                                            if (BytesLeft != (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore)) {
                                                if (lEventLogLevel >= LOG_USER) {
                                                    // issue WARNING, that bytes left param is incorrect
                                                    // load data for eventlog message
                                                    // since this error is correctable (though with
                                                    // some risk) this won't be reported at LOG_USER
                                                    // level
                                                    dwDataIndex = wStringIndex = 0;
                                                    dwRawDataDwords[dwDataIndex++] = BytesLeft;
                                                    dwRawDataDwords[dwDataIndex++] =
                                                        (ULONG_PTR)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                                                    szMessageArray[wStringIndex++] =
                                                        pThisExtObj->szServiceName;
                                                    szMessageArray[wStringIndex++] =
                                                        pThisExtObj->szLibraryName;
                                                    ReportEvent (hEventLog,
                                                        EVENTLOG_WARNING_TYPE,      // error type
                                                        0,                          // category (not used)
                                                        (DWORD)PERFLIB_BUFFER_POINTER_MISMATCH,   // event,
                                                        NULL,                       // SID (not used),
                                                        wStringIndex,              // number of strings
                                                        dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                        szMessageArray,                // message text array
                                                        (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                }

                                                // toss this buffer
                                                bBufferOK = FALSE;
                                                DisablePerfLibrary (pThisExtObj);
                                                // <<old code>>
                                                // we'll keep the buffer, since the returned bytes left
                                                // value is ignored anyway, in order to make the
                                                // rest of this function work, we'll fix it here
                                                // BytesLeft = (DWORD)((LPBYTE)lpBufferAfter - (LPBYTE)lpBufferBefore);
                                                // << end old code >>
                                            }
                                            //
                                            //  check 2: buffer after ptr should be < hi Guard page ptr
                                            //
                                            if (((LPBYTE)lpBufferAfter > (LPBYTE)lpHiGuardPage) && bBufferOK) {
                                                // see if they exceeded the allocated memory
                                                if ((LPBYTE)lpBufferAfter >= (LPBYTE)lpEndPointer) {
                                                    // this is very serious since they've probably trashed
                                                    // the heap by overwriting the heap sig. block
                                                    // issue ERROR, buffer overrun
                                                    if (lEventLogLevel >= LOG_USER) {
                                                        // load data for eventlog message
                                                        dwDataIndex = wStringIndex = 0;
                                                        dwRawDataDwords[dwDataIndex++] =
                                                            (ULONG_PTR)((LPBYTE)lpBufferAfter - (LPBYTE)lpHiGuardPage);
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szLibraryName;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szServiceName;
                                                        ReportEvent (hEventLog,
                                                            EVENTLOG_ERROR_TYPE,        // error type
                                                            0,                          // category (not used)
                                                            (DWORD)PERFLIB_HEAP_ERROR,  // event,
                                                            NULL,                       // SID (not used),
                                                            wStringIndex,               // number of strings
                                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                            szMessageArray,             // message text array
                                                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                    }
                                                } else {
                                                    // issue ERROR, buffer overrun
                                                    if (lEventLogLevel >= LOG_USER) {
                                                        // load data for eventlog message
                                                        dwDataIndex = wStringIndex = 0;
                                                        dwRawDataDwords[dwDataIndex++] =
                                                            (ULONG_PTR)((LPBYTE)lpBufferAfter - (LPBYTE)lpHiGuardPage);
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szLibraryName;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szServiceName;
                                                        ReportEvent (hEventLog,
                                                            EVENTLOG_ERROR_TYPE,        // error type
                                                            0,                          // category (not used)
                                                            (DWORD)PERFLIB_BUFFER_OVERFLOW,     // event,
                                                            NULL,                       // SID (not used),
                                                            wStringIndex,              // number of strings
                                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                            szMessageArray,                // message text array
                                                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                    }
                                                }
                                                bBufferOK = FALSE;
                                                DisablePerfLibrary (pThisExtObj);
                                                // since the DLL overran the buffer, the buffer
                                                // must be too small (no comments about the DLL
                                                // will be made here) so the status will be
                                                // changed to ERROR_MORE_DATA and the function
                                                // will return.
                                                Win32Error = ERROR_MORE_DATA;
                                            }
                                            //
                                            //  check 3: check lo guard page for corruption
                                            //
                                            if (bBufferOK) {
                                                bGuardPageOK = TRUE;
                                                for (lpCheckPointer = (PUCHAR)lpLowGuardPage;
                                                        lpCheckPointer < (PUCHAR)lpBufferBefore;
                                                    lpCheckPointer++) {
                                                    if (*lpCheckPointer != GUARD_PAGE_CHAR) {
                                                        bGuardPageOK = FALSE;
                                                            break;
                                                    }
                                                }
                                                if (!bGuardPageOK) {
                                                    // issue ERROR, Lo Guard Page corrupted
                                                    if (lEventLogLevel >= LOG_USER) {
                                                        // load data for eventlog message
                                                        dwDataIndex = wStringIndex = 0;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szLibraryName;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szServiceName;
                                                        ReportEvent (hEventLog,
                                                            EVENTLOG_ERROR_TYPE,        // error type
                                                            0,                          // category (not used)
                                                            (DWORD)PERFLIB_GUARD_PAGE_VIOLATION, // event
                                                            NULL,                       // SID (not used),
                                                            wStringIndex,              // number of strings
                                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                            szMessageArray,                // message text array
                                                            (LPVOID)&dwRawDataDwords[0]);           // raw data


                                                    }
                                                    bBufferOK = FALSE;
                                                    DisablePerfLibrary (pThisExtObj);
                                                }
                                            }
                                            //
                                            //  check 4: check hi guard page for corruption
                                            //
                                            if (bBufferOK) {
                                                bGuardPageOK = TRUE;
                                                for (lpCheckPointer = (PUCHAR)lpHiGuardPage;
                                                    lpCheckPointer < (PUCHAR)lpEndPointer;
                                                    lpCheckPointer++) {
                                                        if (*lpCheckPointer != GUARD_PAGE_CHAR) {
                                                            bGuardPageOK = FALSE;
                                                        break;
                                                    }
                                                }
                                                if (!bGuardPageOK) {
                                                    // issue ERROR, Hi Guard Page corrupted
                                                    if (lEventLogLevel >= LOG_USER) {
                                                        // load data for eventlog message
                                                        dwDataIndex = wStringIndex = 0;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szLibraryName;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szServiceName;
                                                        ReportEvent (hEventLog,
                                                            EVENTLOG_ERROR_TYPE,        // error type
                                                            0,                          // category (not used)
                                                            (DWORD)PERFLIB_GUARD_PAGE_VIOLATION, // event,
                                                            NULL,                       // SID (not used),
                                                            wStringIndex,              // number of strings
                                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                            szMessageArray,                // message text array
                                                            (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                    }

                                                    bBufferOK = FALSE;
                                                    DisablePerfLibrary (pThisExtObj);
                                                }
                                            }
                                            //
                                            if ((lDllTestLevel <= EXT_TEST_ALL) && bBufferOK) {
                                                //
                                                //  Internal consistency checks
                                                //
                                                //
                                                //  Check 5: Check object length field values
                                                //
                                                // first test to see if this is a foreign
                                                // computer data block or not
                                                //
                                                pPerfData = (PERF_DATA_BLOCK *)lpBufferBefore;
                                                if ((pPerfData->Signature[0] == (WCHAR)'P') &&
                                                    (pPerfData->Signature[1] == (WCHAR)'E') &&
                                                    (pPerfData->Signature[2] == (WCHAR)'R') &&
                                                    (pPerfData->Signature[3] == (WCHAR)'F')) {
                                                    // if this is a foreign computer data block, then the
                                                    // first object is after the header
                                                    pObject = (PERF_OBJECT_TYPE *) (
                                                        (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                                    bForeignDataBuffer = TRUE;
                                                } else {
                                                    // otherwise, if this is just a buffer from
                                                    // an extensible counter, the object starts
                                                    // at the beginning of the buffer
                                                    pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                                    bForeignDataBuffer = FALSE;
                                                }
                                                // go to where the pointers say the end of the
                                                // buffer is and then see if it's where it
                                                // should be
                                                dwObjectBufSize = 0;
                                                for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                                    dwObjectBufSize += pObject->TotalByteLength;
                                                    pObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                        pObject->TotalByteLength);
                                                }
                                                if (((LPBYTE)pObject != (LPBYTE)lpCallBuffer) ||
                                                    (dwObjectBufSize > BytesLeft)) {
                                                    // then a length field is incorrect. This is FATAL
                                                    // since it can corrupt the rest of the buffer
                                                    // and render the buffer unusable.
                                                    if (lEventLogLevel >= LOG_USER) {
                                                        // load data for eventlog message
                                                        dwDataIndex = wStringIndex = 0;
                                                        dwRawDataDwords[dwDataIndex++] = NumObjectTypes;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szLibraryName;
                                                        szMessageArray[wStringIndex++] =
                                                            pThisExtObj->szServiceName;
                                                        ReportEvent (hEventLog,
                                                            EVENTLOG_ERROR_TYPE,        // error type
                                                            0,                          // category (not used)
                                                            (DWORD)PERFLIB_INCORRECT_OBJECT_LENGTH, // event,
                                                            NULL,                       // SID (not used),
                                                            wStringIndex,               // number of strings
                                                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                            szMessageArray,             // message text array
                                                            (LPVOID)&dwRawDataDwords[0]); // raw data
                                                    }
                                                    bBufferOK = FALSE;
                                                    DisablePerfLibrary (pThisExtObj);
                                                }
                                                //
                                                //  Test 6: Test Object definitions fields
                                                //
                                                if (bBufferOK) {
                                                    // set object pointer
                                                    if (bForeignDataBuffer) {
                                                        pObject = (PERF_OBJECT_TYPE *) (
                                                            (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                                    } else {
                                                        // otherwise, if this is just a buffer from
                                                        // an extensible counter, the object starts
                                                        // at the beginning of the buffer
                                                        pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                                    }

                                                    for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                                        pNextObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                            pObject->DefinitionLength);

                                                        if (pObject->NumCounters != 0) {
                                                            pCounterDef = (PERF_COUNTER_DEFINITION *)
                                                                ((LPBYTE)pObject + pObject->HeaderLength);
                                                            lCtrIndex = 0;
                                                            while (lCtrIndex < pObject->NumCounters) {
                                                                if ((LPBYTE)pCounterDef < (LPBYTE)pNextObject) {
                                                                    // still ok so go to next counter
                                                                    pCounterDef = (PERF_COUNTER_DEFINITION *)
                                                                        ((LPBYTE)pCounterDef + pCounterDef->ByteLength);
                                                                    lCtrIndex++;
                                                                } else {
                                                                    bBufferOK = FALSE;
                                                                    break;
                                                                }
                                                            }
                                                            if ((LPBYTE)pCounterDef != (LPBYTE)pNextObject) {
                                                                bBufferOK = FALSE;
                                                            }
                                                        }

                                                        if (!bBufferOK) {
                                                            break;
                                                        } else {
                                                            pObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                                pObject->TotalByteLength);
                                                        }
                                                    }

                                                    if (!bBufferOK) {
                                                        if (lEventLogLevel >= LOG_USER) {
                                                            // load data for eventlog message
                                                            dwDataIndex = wStringIndex = 0;
                                                            dwRawDataDwords[dwDataIndex++] = pObject->ObjectNameTitleIndex;
                                                            szMessageArray[wStringIndex++] =
                                                                pThisExtObj->szLibraryName;
                                                            szMessageArray[wStringIndex++] =
                                                                pThisExtObj->szServiceName;
                                                            ReportEvent (hEventLog,
                                                                EVENTLOG_ERROR_TYPE,        // error type
                                                                0,                          // category (not used)
                                                                (DWORD)PERFLIB_INVALID_DEFINITION_BLOCK, // event,
                                                                NULL,                       // SID (not used),
                                                                wStringIndex,              // number of strings
                                                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                                szMessageArray,                // message text array
                                                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                        }
                                                        DisablePerfLibrary (pThisExtObj);
                                                    }

                                                }
                                                //
                                                //  Test 7: Test instance field size values
                                                //
                                                if (bBufferOK) {
                                                    // set object pointer
                                                    if (bForeignDataBuffer) {
                                                        pObject = (PERF_OBJECT_TYPE *) (
                                                            (LPBYTE)pPerfData + pPerfData->HeaderLength);
                                                    } else {
                                                        // otherwise, if this is just a buffer from
                                                        // an extensible counter, the object starts
                                                        // at the beginning of the buffer
                                                        pObject = (PERF_OBJECT_TYPE *)lpBufferBefore;
                                                    }

                                                    for (dwIndex = 0; dwIndex < NumObjectTypes; dwIndex++) {
                                                        pNextObject = (PERF_OBJECT_TYPE *)((LPBYTE)pObject +
                                                            pObject->TotalByteLength);

                                                        if (pObject->NumInstances != PERF_NO_INSTANCES) {
                                                            pInstance = (PERF_INSTANCE_DEFINITION *)
                                                                ((LPBYTE)pObject + pObject->DefinitionLength);
                                                            lInstIndex = 0;
                                                            while (lInstIndex < pObject->NumInstances) {
                                                                PERF_COUNTER_BLOCK *pCounterBlock;

                                                                pCounterBlock = (PERF_COUNTER_BLOCK *)
                                                                    ((PCHAR) pInstance + pInstance->ByteLength);

                                                                pInstance = (PERF_INSTANCE_DEFINITION *)
                                                                    ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);

                                                                lInstIndex++;
                                                            }
                                                            if ((LPBYTE)pInstance > (LPBYTE)pNextObject) {
                                                                bBufferOK = FALSE;
                                                            }
                                                        }

                                                        if (!bBufferOK) {
                                                            break;
                                                        } else {
                                                            pObject = pNextObject;
                                                        }
                                                    }

                                                    if (!bBufferOK) {
                                                        if (lEventLogLevel >= LOG_USER) {
                                                            // load data for eventlog message
                                                            dwDataIndex = wStringIndex = 0;
                                                            dwRawDataDwords[dwDataIndex++] = pObject->ObjectNameTitleIndex;
                                                            szMessageArray[wStringIndex++] =
                                                                pThisExtObj->szLibraryName;
                                                            szMessageArray[wStringIndex++] =
                                                                pThisExtObj->szServiceName;
                                                            ReportEvent (hEventLog,
                                                                EVENTLOG_ERROR_TYPE,        // error type
                                                                0,                          // category (not used)
                                                                (DWORD)PERFLIB_INCORRECT_INSTANCE_LENGTH, // event,
                                                                NULL,                       // SID (not used),
                                                                wStringIndex,              // number of strings
                                                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                                                szMessageArray,                // message text array
                                                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                                                        }
                                                        DisablePerfLibrary (pThisExtObj);
                                                    }
                                                }
                                            }
                                        }
                                        //
                                        // if all the tests pass,then copy the data to the
                                        // original buffer and update the pointers
                                        if (bBufferOK) {
                                            RtlMoveMemory (*lppDataDefinition,
                                                lpBufferBefore,
                                                BytesLeft); // returned buffer size
                                        } else {
                                            NumObjectTypes = 0; // since this buffer was tossed
                                            BytesLeft = 0; // reset the size value since the buffer wasn't used
                                        }
                                    } else {
                                        // function already copied data to caller's buffer
                                        // so no further action is necessary
                                    }
                                    *lppDataDefinition = (LPVOID)((LPBYTE)(*lppDataDefinition) + BytesLeft);    // update data pointer
                                }
                            } else {
                                if (Win32Error != ERROR_SUCCESS) {
                                    InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
                                }
                                if (bUnlockObjData) {
                                    ReleaseMutex (pThisExtObj->hMutex);
                                }

                                NumObjectTypes = 0; // clear counter
                            }// end if function returned successfully

                        } except (EXCEPTION_EXECUTE_HANDLER) {
                            Win32Error = GetExceptionCode();
                            InterlockedIncrement ((LONG *)&pThisExtObj->dwErrorCount);
                            bException = TRUE;

                            if (bUnlockObjData) {
                                ReleaseMutex (pThisExtObj->hMutex);
                                bUnlockObjData = FALSE;
                            }

                            if (hPerflibFuncTimer != NULL) {
                                // kill timer
                                KillPerflibFunctionTimer (hPerflibFuncTimer);
                                hPerflibFuncTimer = NULL;
                            }
                        }
                        if (bUseSafeBuffer) {
                            FREEMEM (lpExtDataBuffer);
                        }
                    } else {
                        // unable to allocate memory so set error value
                        Win32Error = ERROR_OUTOFMEMORY;
                    } // end if temp buffer allocated successfully
                    //
                    //  Update the count of the number of object types
                    //
                    ((PPERF_DATA_BLOCK) lpData)->NumObjectTypes += NumObjectTypes;

                    if ( Win32Error != ERROR_SUCCESS) {
                        if (bException ||
                            !((Win32Error == ERROR_MORE_DATA) ||
                              (Win32Error == WAIT_TIMEOUT))) {
                            // inform on exceptions & illegal error status only
                            if (lEventLogLevel >= LOG_USER) {
                                // load data for eventlog message
                                dwDataIndex = wStringIndex = 0;
                                dwRawDataDwords[dwDataIndex++] = Win32Error;
                                szMessageArray[wStringIndex++] =
                                    pThisExtObj->szServiceName;
                                szMessageArray[wStringIndex++] =
                                    pThisExtObj->szLibraryName;
                                ReportEvent (hEventLog,
                                    EVENTLOG_ERROR_TYPE,        // error type
                                    0,                          // category (not used)
                                    (DWORD)PERFLIB_COLLECT_PROC_EXCEPTION,   // event,
                                    NULL,                       // SID (not used),
                                    wStringIndex,              // number of strings
                                    dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                    szMessageArray,                // message text array
                                    (LPVOID)&dwRawDataDwords[0]);           // raw data

                            } else {
                                if (bException) {
                                    DebugPrint((0, "Extensible Counter %d generated an exception code: 0x%8.8x (%dL)\n",
                                        NumObjectTypes, Win32Error, Win32Error));
                                } else {
                                    DebugPrint((0, "Extensible Counter %d returned error code: 0x%8.8x (%dL)\n",
                                        NumObjectTypes, Win32Error, Win32Error));
                                }
                            }
                            if (bException) {
                                DisablePerfLibrary (pThisExtObj);
                            }
                        }
                        // the ext. dll is only supposed to return:
                        //  ERROR_SUCCESS even if it encountered a problem, OR
                        //  ERROR_MODE_DATA if the buffer was too small.
                        // if it's ERROR_MORE_DATA, then break and return the
                        // error now, since it'll just be returned again and again.
                        if (Win32Error == ERROR_MORE_DATA) {
                            lReturnValue = Win32Error;
                            break;
                        }
                    }

                    // update perf data in global section
                    if (pThisExtObj->pPerfSectionEntry != NULL) {
                        pThisExtObj->pPerfSectionEntry->llElapsedTime =
                            pThisExtObj->llElapsedTime;

                        pThisExtObj->pPerfSectionEntry->dwCollectCount =
                            pThisExtObj->dwCollectCount;

                        pThisExtObj->pPerfSectionEntry->dwOpenCount =
                            pThisExtObj->dwOpenCount;

                        pThisExtObj->pPerfSectionEntry->dwCloseCount =
                            pThisExtObj->dwCloseCount;

                        pThisExtObj->pPerfSectionEntry->dwLockoutCount =
                            pThisExtObj->dwLockoutCount;

                        pThisExtObj->pPerfSectionEntry->dwErrorCount =
                            pThisExtObj->dwErrorCount;

                        pThisExtObj->pPerfSectionEntry->dwLastBufferSize =
                            pThisExtObj->dwLastBufferSize;

                        pThisExtObj->pPerfSectionEntry->dwMaxBufferSize =
                            pThisExtObj->dwMaxBufferSize;

                        pThisExtObj->pPerfSectionEntry->dwMaxBufferRejected =
                            pThisExtObj->dwMaxBufferRejected;

                    } else {
                        // no data section was initialized so skip
                    }
                } // end if this object is to be called
            } // end for each object
        } // else an error occurred so unable to call functions
        Win32Error = DeRegisterExtObjListAccess();
    } // else unable to access ext object list

    HEAP_PROBE();

    if (bDisabled) lReturnValue = ERROR_SERVICE_DISABLED;
    return lReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\ntconreg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1996   Microsoft Corporation

Module Name:

    ntconreg.h

Abstract:

    Header file for the NT Configuration Registry

    This file contains definitions which provide the interface to
    the Performance Configuration Registry.
    NOTE: This file is also included by other files in the regular
    registry support routines.

Author:

    Russ Blake  11/15/91

Revision History:

    04/20/91    -   russbl      -   Converted to lib in Registry
                                      from stand-alone .dll form.
    11/04/92    -   a-robw      -  added pagefile counters


--*/
//
#include <winperf.h>    // for fn prototype declarations
#include <ntddnfs.h>
#include <srvfsctl.h>
#include <assert.h>
//
//  Until USER supports Unicode, we have to work in ASCII:
//

#define DEFAULT_NT_CODE_PAGE 437
#define UNICODE_CODE_PAGE      0

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
//  Assumes x is DWORD, and returns a DWORD
//
#define DWORD_MULTIPLE(x) (((ULONG)(x) + ((4)-1)) & ~((ULONG)(4)-1))
#define QWORD_MULTIPLE(x) (((ULONG)(x) + ((8)-1)) & ~((ULONG)(8)-1))

//
//  Returns a PVOID
//
#define ALIGN_ON_DWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((4)-1)) & ~((ULONG_PTR)(4)-1)))
#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))

//
//  Definitions for internal use by the Performance Configuration Registry
//
//  They have been moved to perfdlls and perflib.h and left here
//  for references only
//

// #define NUM_VALUES 2
// #define MAX_INSTANCE_NAME 32
// #define DEFAULT_LARGE_BUFFER 8*1024
// #define INCREMENT_BUFFER_SIZE 4*1024
// #define MAX_PROCESS_NAME_LENGTH 256*sizeof(WCHAR)
// #define MAX_THREAD_NAME_LENGTH 10*sizeof(WCHAR)
// #define MAX_KEY_NAME_LENGTH 256*sizeof(WCHAR)
// #define MAX_VALUE_NAME_LENGTH 256*sizeof(WCHAR)
// #define MAX_VALUE_DATA_LENGTH 256*sizeof(WCHAR)

typedef PM_OPEN_PROC    *OPENPROC;
typedef PM_COLLECT_PROC *COLLECTPROC;
typedef PM_QUERY_PROC   *QUERYPROC;
typedef PM_CLOSE_PROC   *CLOSEPROC;

DWORD
PerfOpenKey ();

BOOL
PerfRegCleanup ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\extlib.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000   Microsoft Corporation

Module Name:

    extlib.c

Abstract:

    This file implements all the library routines operating on
    extensible performance libraries.

Author:

    JeePang

Revision History:

    09/27/2000  -   JeePang     - Moved from perflib.c

--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <winperf.h>
#include <rpc.h>
#include "regrpc.h"
#include "ntconreg.h"
#include "prflbmsg.h"   // event log messages
#include "perflib.h"
#pragma warning(default:4306)

// default trusted file list
// all files presume to start with "perf"

// static LONGLONG    llTrustedNamePrefix = 0x0066007200650050;   // "Perf"
#define NAME_PREFIX L"Perf"

DWORD       dwTrustedFileNames[] = {
    0x0053004F,         // "OS"   for PerfOS.dll
    0x0065004E,         // "Ne"   for PerfNet.dll
    0x00720050,         // "Pr"   for PerfProc.dll
    0x00690044          // "Di"   for PerfDisk.dll
};

CONST DWORD dwTrustedFileNameCount = 
                sizeof(dwTrustedFileNames) / sizeof (dwTrustedFileNames[0]);
// there must be at least 8 chars in the name to be checked as trusted by
// default trusted file names are at least 8 chars in length

CONST DWORD dwMinTrustedFileNameLen = 6;

BOOL
ServiceIsTrustedByDefault (
    LPCWSTR     szServiceName
)
{
    BOOL        bReturn = FALSE;
    DWORD       dwNameToTest;
    DWORD       dwIdx;

    if (szServiceName != NULL) {
        // check for min size
        dwIdx = 0;
        while ((dwIdx < dwMinTrustedFileNameLen) && (szServiceName[dwIdx] > 0))
dwIdx++;

        if (dwIdx == dwMinTrustedFileNameLen) {
            // test first 4 bytes to see if they match
            if (!wcsncmp(szServiceName, NAME_PREFIX, sizeof(LONGLONG))) {
                // then see if the rest is in this list
                dwNameToTest = * ((DWORD *)(szServiceName+4));
                for (dwIdx = 0; dwIdx < dwTrustedFileNameCount; dwIdx++) {
                    if (dwNameToTest == dwTrustedFileNames[dwIdx]) {
                        // match found
                        bReturn = TRUE;
                        break;
                    } else {
                        // no match so continue
                    }
                }
            } else {
                // no match so return false
            }
        } else {
            // the name to be checked is too short so it mustn't be
            // a trusted one.
        }
    } else {
        // no string so return false
    }
    return bReturn;
}

DWORD
CloseExtObjectLibrary (
    PEXT_OBJECT  pObj,
    BOOL        bCloseNow
)
/*++

  CloseExtObjectLibrary
    Closes and unloads the specified performance counter library and
    deletes all references to the functions.

    The unloader is "lazy" in that it waits for the library to be
    inactive for a specified time before unloading. This is due to the
    fact that Perflib can not ever be certain that no thread will need
    this library from one call to the next. In order to prevent "thrashing"
    due to constantly loading and unloading of the library, the unloading
    is delayed to make sure it's not really needed.

    This function expects locked and exclusive access to the object while
    it is opening. This must be provided by the calling function.

 Arguments:

    pObj    -- pointer to the object information structure of the
                perf object to close

    bCloseNow -- the flag to indicate the library should be closed
                immediately. This is the result of the calling function
                closing the registry key.

--*/
{
    DWORD       Status = ERROR_SUCCESS;
    LONGLONG    TimeoutTime;

    if (((dwThreadAndLibraryTimeout == 0) ||
         (dwThreadAndLibraryTimeout == INFINITE)) && !bCloseNow) {
        return Status;
    }
    if (pObj->hLibrary != NULL) {
        // get current time to test timeout
        TimeoutTime = GetTimeAsLongLong();
        // timeout time is in ms
        TimeoutTime -= dwThreadAndLibraryTimeout;

        // don't close the library unless the object hasn't been accessed for
        // a while or the caller is closing the key

        if ((TimeoutTime > pObj->llLastUsedTime) || bCloseNow) {

            // don't toss if this library has the "keep" flag set and this
            // isn't a "close now" case

            if (!bCloseNow && (pObj->dwFlags & PERF_EO_KEEP_RESIDENT)) {
                // keep it loaded until the key is closed.
            } else {
                // then this is the last one to close the library
                // free library

                try {
                    // call close function for this DLL
                    Status = (*pObj->CloseProc)();
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    Status = GetExceptionCode();
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                        (&PerflibGuid, __LINE__, PERF_CLOSE_EXTOBJLIB, 
                        ARG_TYPE_STR, Status,
//                        pObj->szCloseProcName,
//                        STRSIZE(pObj->szCloseProcName), NULL));
                        TRACE_STR(pObj->szCloseProcName), NULL));
                }

                FreeLibrary (pObj->hLibrary);
                pObj->hLibrary = NULL;

                // clear all pointers that are now invalid
                pObj->OpenProc = NULL;
                pObj->CollectProc = NULL;
                pObj->QueryProc = NULL;
                pObj->CloseProc = NULL;
                InterlockedIncrement((LONG *)&pObj->dwCloseCount);

                pObj->llLastUsedTime = 0;
            }
        }

        Status = ERROR_SUCCESS;
    } else {
        // already closed
        Status = ERROR_SUCCESS;
    }

    return Status;
}


DWORD
OpenExtObjectLibrary (
    PEXT_OBJECT  pObj
)
/*++

 OpenExtObjectLibrary

    Opens the specified library and looks up the functions used by
    the performance library. If the library is successfully
    loaded and opened then the open procedure is called to initialize
    the object.

    This function expects locked and exclusive access to the object while
    it is opening. This must be provided by the calling function.

 Arguments:

    pObj    -- pointer to the object information structure of the
                perf object to close

--*/
{
    DWORD   FnStatus = ERROR_SUCCESS;
    DWORD   Status = ERROR_SUCCESS;
    DWORD   dwOpenEvent = 0;
    DWORD   dwType;
    DWORD   dwSize;
    DWORD   dwValue;

    // variables used for event logging
    DWORD   dwDataIndex;
    WORD    wStringIndex;
    ULONG_PTR   dwRawDataDwords[8];
    LPWSTR  szMessageArray[8];

    HANDLE  hPerflibFuncTimer = NULL;
    DLL_VALIDATION_DATA CurrentDllData;

    OPEN_PROC_WAIT_INFO opwInfo;
    UINT    nErrorMode;
    LPWSTR  szServiceName;
    DWORD   szServiceNameSize;

    BOOL    bUseTimer;
    // check to see if the library has already been opened

    if (pObj->dwFlags & PERF_EO_DISABLED) return ERROR_SERVICE_DISABLED;

    if (pObj->hLibrary == NULL) {
        // library isn't loaded yet, so
        // check to see if this function is enabled

        dwType = 0;
        dwSize = sizeof (dwValue);
        dwValue = 0;
        Status = PrivateRegQueryValueExW (
            pObj->hPerfKey,
            DisablePerformanceCounters,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);

        if ((Status == ERROR_SUCCESS) &&
            (dwType == REG_DWORD) &&
            (dwValue == 1)) {
            // then DON'T Load this library
            pObj->dwFlags |= PERF_EO_DISABLED;
        } else {
            // set the error status & the flag value
            Status = ERROR_SUCCESS;
            pObj->dwFlags &= ~PERF_EO_DISABLED;
        }

        szServiceName = pObj->szServiceName;
        if (szServiceName == NULL) {
            szServiceName = (LPWSTR) &NULL_STRING[0];
        }
        szServiceNameSize = WSTRSIZE(szServiceName);

        if ((Status == ERROR_SUCCESS)  &&
            (pObj->LibData.FileSize > 0)) {

            if (ServiceIsTrustedByDefault(pObj->szServiceName)) {
                // then set as trusted and continue
                pObj->dwFlags |= PERF_EO_TRUSTED;
            } else {
                // see if this is a trusted file or a file that has been updated
                // get the file information
                memset (&CurrentDllData, 0, sizeof(CurrentDllData));
                Status = GetPerfDllFileInfo (
                    pObj->szLibraryName,
                    &CurrentDllData);

                if (Status == ERROR_SUCCESS) {
                    // compare file data to registry data and update flags
                    if ((*(LONGLONG *)&pObj->LibData.CreationDate) ==
                        (*(LONGLONG *)&CurrentDllData.CreationDate) &&
                        (pObj->LibData.FileSize == CurrentDllData.FileSize)) {
                        pObj->dwFlags |= PERF_EO_TRUSTED;
                    } else if (lEventLogLevel >= LOG_USER) {
                        TRACE((WINPERF_DBG_TRACE_WARNING),
                            (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                            ARG_TYPE_WSTR, 0, szServiceName,
                            szServiceNameSize, NULL));
                        // load data for eventlog message
                        dwDataIndex = wStringIndex = 0;
                        szMessageArray[wStringIndex++] =
                            pObj->szLibraryName;
                        szMessageArray[wStringIndex++] =
                            pObj->szServiceName;

                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,        // error type
                            0,                          // category (not used)
                            (DWORD)PERFLIB_NOT_TRUSTED_FILE,  // event,
                            NULL,                       // SID (not used),
                            wStringIndex,               // number of strings
                            0,                          // sizeof raw data
                            szMessageArray,             // message text array
                            NULL);                       // raw data
                    }
                }
            }
        }

        if ((Status == ERROR_SUCCESS) && (!(pObj->dwFlags & PERF_EO_DISABLED))) {
            //  go ahead and load it
            nErrorMode = SetErrorMode (SEM_FAILCRITICALERRORS);
            // then load library & look up functions
            pObj->hLibrary = LoadLibraryExW (pObj->szLibraryName,
                NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

            if (pObj->hLibrary != NULL) {
                // lookup function names
                pObj->OpenProc = (OPENPROC)GetProcAddress(
                    pObj->hLibrary, pObj->szOpenProcName);
                if (pObj->OpenProc == NULL) {
                    TRACE((WINPERF_DBG_TRACE_FATAL),
                        (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                        0, szServiceName, szServiceNameSize,
                        TRACE_STR(pObj->szOpenProcName), NULL));
                    if (lEventLogLevel >= LOG_USER) {
                        WCHAR wszProcName[MAX_PATH+1];

                        Status = GetLastError();
                        // load data for eventlog message
                        dwDataIndex = wStringIndex = 0;
                        dwRawDataDwords[dwDataIndex++] =
                            (ULONG_PTR)Status;
                        wcstombs(pObj->szOpenProcName, wszProcName, MAX_PATH);
                        szMessageArray[wStringIndex++] = &wszProcName[0];
                        szMessageArray[wStringIndex++] =
                            pObj->szLibraryName;
                        szMessageArray[wStringIndex++] =
                            pObj->szServiceName;

                        ReportEvent (hEventLog,
                            EVENTLOG_ERROR_TYPE,        // error type
                            0,                          // category (not used)
                            (DWORD)PERFLIB_OPEN_PROC_NOT_FOUND,              // event,
                            NULL,                       // SID (not used),
                            wStringIndex,               // number of strings
                            dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                            szMessageArray,             // message text array
                            (LPVOID)&dwRawDataDwords[0]);           // raw data

                    }
                    DisablePerfLibrary (pObj);
                }

                if (Status == ERROR_SUCCESS) {
                    if (pObj->dwFlags & PERF_EO_QUERY_FUNC) {
                        pObj->QueryProc = (QUERYPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->CollectProc = (COLLECTPROC)pObj->QueryProc;
                    } else {
                        pObj->CollectProc = (COLLECTPROC)GetProcAddress (
                            pObj->hLibrary, pObj->szCollectProcName);
                        pObj->QueryProc = (QUERYPROC)pObj->CollectProc;
                    }

                    if (pObj->CollectProc == NULL) {
                        TRACE((WINPERF_DBG_TRACE_FATAL),
                            (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                            0, szServiceName, szServiceNameSize,
                            TRACE_STR(pObj->szCollectProcName), NULL));
                        if (lEventLogLevel >= LOG_USER) {
                            WCHAR wszProcName[MAX_PATH+1];

                            Status = GetLastError();
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] =
                                (ULONG_PTR)Status;
                            wcstombs(pObj->szCollectProcName,
                                     wszProcName, MAX_PATH);
                            szMessageArray[wStringIndex++] = &wszProcName[0];
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;
                            szMessageArray[wStringIndex++] =
                                pObj->szServiceName;

                            ReportEvent (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)PERFLIB_COLLECT_PROC_NOT_FOUND,              // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                szMessageArray,             // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        }
                        DisablePerfLibrary (pObj);
                    }
                }

                if (Status == ERROR_SUCCESS) {
                    pObj->CloseProc = (CLOSEPROC)GetProcAddress (
                        pObj->hLibrary, pObj->szCloseProcName);

                    if (pObj->CloseProc == NULL) {
                        TRACE((WINPERF_DBG_TRACE_FATAL),
                            (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                            0, szServiceName, szServiceNameSize,
                            TRACE_STR(pObj->szCloseProcName), NULL));
                        if (lEventLogLevel >= LOG_USER) {
                            WCHAR wszProcName[MAX_PATH+1];

                            Status = GetLastError();
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] =
                                (ULONG_PTR)Status;
                            wcstombs(pObj->szCollectProcName,
                                     wszProcName, MAX_PATH);
                            szMessageArray[wStringIndex++] = &wszProcName[0];
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;
                            szMessageArray[wStringIndex++] =
                                pObj->szServiceName;

                            ReportEvent (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)PERFLIB_CLOSE_PROC_NOT_FOUND,              // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                szMessageArray,             // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        }

                        DisablePerfLibrary (pObj);
                    }
                }

                bUseTimer = TRUE;   // default
                if (!(lPerflibConfigFlags & PLCF_NO_DLL_TESTING)) {
                    if (pObj->dwFlags & PERF_EO_TRUSTED) {
                        bUseTimer = FALSE;   // Trusted DLL's are not timed
                    }
                } else {
                    // disable DLL testing
                    bUseTimer = FALSE;   // Timing is disabled as well
                }

                if (Status == ERROR_SUCCESS) {
                    try {
                        // start timer
                        opwInfo.pNext = NULL;
                        opwInfo.szLibraryName = pObj->szLibraryName;
                        opwInfo.szServiceName = pObj->szServiceName;
                        opwInfo.dwWaitTime = pObj->dwOpenTimeout;
                        opwInfo.dwEventMsg = PERFLIB_OPEN_PROC_TIMEOUT;
                        opwInfo.pData = (LPVOID)pObj;
                        if (bUseTimer) {
                            hPerflibFuncTimer = StartPerflibFunctionTimer(&opwInfo);
                            // if no timer, continue anyway, even though things may
                            // hang, it's better than not loading the DLL since they
                            // usually load OK
                            //
                            if (hPerflibFuncTimer == NULL) {
                                // unable to get a timer entry
                                TRACE((WINPERF_DBG_TRACE_WARNING),
                                      (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB, 0, 0, NULL));
                            }
                        } else {
                            hPerflibFuncTimer = NULL;
                        }

                        // call open procedure to initialize DLL
                        FnStatus = (*pObj->OpenProc)(pObj->szLinkageString);
                        // check the result.
                        if (FnStatus != ERROR_SUCCESS) {
                            TRACE((WINPERF_DBG_TRACE_FATAL),
                                (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                                FnStatus, szServiceName, szServiceNameSize,
                                pObj->szLinkageString, (pObj->szLinkageString) ?
                                WSTRSIZE(pObj->szLinkageString) : 0, NULL));
                            dwOpenEvent = PERFLIB_OPEN_PROC_FAILURE;
                        } else {
                            InterlockedIncrement((LONG *)&pObj->dwOpenCount);
                        }

                    } except (EXCEPTION_EXECUTE_HANDLER) {
                        FnStatus = GetExceptionCode();
                        TRACE((WINPERF_DBG_TRACE_FATAL),
                            (&PerflibGuid, __LINE__, PERF_OPEN_EXTOBJLIB,
                            ARG_DEF(ARG_TYPE_WSTR, 1), FnStatus,
                            szServiceName, szServiceNameSize, NULL));
                        dwOpenEvent = PERFLIB_OPEN_PROC_EXCEPTION;
                    }

                    if (hPerflibFuncTimer != NULL) {
                        // kill timer
                        Status = KillPerflibFunctionTimer (hPerflibFuncTimer);
                        hPerflibFuncTimer = NULL;
                    }

                    if (FnStatus != ERROR_SUCCESS) {
                        DWORD ReportError = 1;
                        if (dwOpenEvent == PERFLIB_OPEN_PROC_EXCEPTION) {
                            DisablePerfLibrary (pObj);
                        }
                        else {
                            ReportError = PerfUpdateErrorCount(pObj, 1);
                        }
                        if  ((ReportError > 0) && (lEventLogLevel >= LOG_USER)) {
                            // load data for eventlog message
                            dwDataIndex = wStringIndex = 0;
                            dwRawDataDwords[dwDataIndex++] =
                                (ULONG_PTR)FnStatus;
                            szMessageArray[wStringIndex++] =
                                pObj->szServiceName;
                            szMessageArray[wStringIndex++] =
                                pObj->szLibraryName;

                            ReportEventW (hEventLog,
                                (WORD)EVENTLOG_ERROR_TYPE, // error type
                                0,                          // category (not used)
                                dwOpenEvent,                // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                dwDataIndex*sizeof(ULONG_PTR),  // sizeof raw data
                                szMessageArray,                // message text array
                                (LPVOID)&dwRawDataDwords[0]);           // raw data
                        }
                    }
                    else {
                        PerfUpdateErrorCount(pObj, 0);
                    }
                }

                if (FnStatus != ERROR_SUCCESS) {
                    // clear fields
                    pObj->OpenProc = NULL;
                    pObj->CollectProc = NULL;
                    pObj->QueryProc = NULL;
                    pObj->CloseProc = NULL;
                    if (pObj->hLibrary != NULL) {
                        FreeLibrary (pObj->hLibrary);
                        pObj->hLibrary = NULL;
                    }
                    Status = FnStatus;
                } else {
                    pObj->llLastUsedTime = GetTimeAsLongLong();
                }
            } else {
                Status = GetLastError();
            }
            SetErrorMode (nErrorMode);
        }
    } else {
        // else already open so bump the ref count
        pObj->llLastUsedTime = GetTimeAsLongLong();
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\perflib.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1994   Microsoft Corporation

Module Name:

    perflib.c

Abstract:

    This file implements the Configuration Registry
    for the purposes of the Performance Monitor.


    This file contains the code which implements the Performance part
    of the Configuration Registry.

Author:

    Russ Blake  11/15/91

Revision History:

    04/20/91    -   russbl      -   Converted to lib in Registry
                                      from stand-alone .dll form.
    11/04/92    -   a-robw      -  added pagefile and image counter routines

    11/01/96    -   bobw        -  revamped to support dynamic loading and
                                    unloading of performance modules

--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntregapi.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <winperf.h>
#include <rpc.h>
#include "regrpc.h"
#include "ntconreg.h"
#include "prflbmsg.h"   // event log messages
#include <initguid.h>
#include <guiddef.h>
#define _INIT_WINPERFP_
#include "perflib.h"
#pragma warning (default:4306)

#define NUM_VALUES 2

//
//  performance gathering thead priority
//
#define DEFAULT_THREAD_PRIORITY     THREAD_BASE_PRIORITY_LOWRT
//
//  constants
//
const   WCHAR DLLValue[] = L"Library";
const   CHAR OpenValue[] = "Open";
const   CHAR CloseValue[] = "Close";
const   CHAR CollectValue[] = "Collect";
const   CHAR QueryValue[] = "Query";
const   WCHAR ObjListValue[] = L"Object List";
const   WCHAR LinkageKey[] = L"\\Linkage";
const   WCHAR ExportValue[] = L"Export";
const   WCHAR PerflibKey[] = L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
const   WCHAR HKLMPerflibKey[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
const   WCHAR CounterValue[] = L"Counter";
const   WCHAR HelpValue[] = L"Help";
const   WCHAR PerfSubKey[] = L"\\Performance";
const   WCHAR ExtPath[] = L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services";
const   WCHAR OpenTimeout[] = L"Open Timeout";
const   WCHAR CollectTimeout[] = L"Collect Timeout";
const   WCHAR EventLogLevel[] = L"EventLogLevel";
const   WCHAR ExtCounterTestLevel[] = L"ExtCounterTestLevel";
const   WCHAR OpenProcedureWaitTime[] = L"OpenProcedureWaitTime";
const   WCHAR TotalInstanceName[] = L"TotalInstanceName";
const   WCHAR LibraryUnloadTime[] = L"Library Unload Time";
const   WCHAR KeepResident[] = L"Keep Library Resident";
const   WCHAR NULL_STRING[] = L"\0";    // pointer to null string
const   WCHAR UseCollectionThread[] = L"UseCollectionThread";
const   WCHAR cszLibraryValidationData[] = L"Library Validation Code";
const   WCHAR cszSuccessfulFileData[] = L"Successful File Date";
const   WCHAR cszPerflibFlags[] = L"Configuration Flags";
const   WCHAR FirstCounter[] = L"First Counter";
const   WCHAR LastCounter[] = L"Last Counter";
const   WCHAR FirstHelp[] = L"First Help";
const   WCHAR LastHelp[] = L"Last Help";
const   WCHAR cszFailureCount[] = L"Error Count";
const   WCHAR cszFailureLimit[] = L"Error Count Limit";

//
//  external variables defined in perfname.c
//
extern   WCHAR    DefaultLangId[];
WCHAR    NativeLangId[8] = L"\0";

//
//  Data collection thread variables
//
#define COLLECTION_WAIT_TIME        10000L  // 10 seconds to get all the data
HANDLE   hCollectThread = NULL;
#define COLLECT_THREAD_PROCESS_EVENT    0
#define COLLECT_THREAD_EXIT_EVENT       1
#define COLLECT_THREAD_LOOP_EVENT_COUNT 2

#define COLLECT_THREAD_DONE_EVENT       2
#define COLLECT_THREAD_EVENT_COUNT      3
static  HANDLE  hCollectEvents[COLLECT_THREAD_EVENT_COUNT];
static  BOOL    bThreadHung = FALSE;

static  DWORD CollectThreadFunction (LPVOID dwArg);

#define COLL_FLAG_USE_SEPARATE_THREAD   1
DWORD   dwCollectionFlags = 0;

//
//      Global variable Definitions
//
// event log handle for perflib generated errors
//
HANDLE  hEventLog = NULL;

//
//  used to count concurrent opens.
//
DWORD NumberOfOpens = 0;

//
//  Synchronization objects for Multi-threaded access
//
HANDLE   hGlobalDataMutex = NULL; // sync for ctr object list

//
//  computer name cache buffers. Initialized in predefh.c
//

DWORD ComputerNameLength;
LPWSTR pComputerName = NULL;

//  The next pointer is used to point to an array of addresses of
//  Open/Collect/Close routines found by searching the Configuration Registry.

//                  object list head
PEXT_OBJECT ExtensibleObjects = NULL;
//
//                  count of active list users (threads)
DWORD       dwExtObjListRefCount = 0;
//
//                  event to indicate the object list is not in use
HANDLE      hExtObjListIsNotInUse = NULL;
//
//                  Number of Extensible Objects found during the "open" call
DWORD       NumExtensibleObjects = 0;
//
//  see if the perflib data is restricted to ADMIN's ONLY or just anyone
//
static  LONG    lCheckProfileSystemRight = CPSR_NOT_DEFINED;

//
//  flag to see if the ProfileSystemPerformance priv should be set.
//      if it is attempted and the caller does not have permission to use this priv.
//      it won't be set. This is only attempted once.
//
static  BOOL    bEnableProfileSystemPerfPriv = FALSE;

//
//  timeout value (in mS) for timing threads & libraries
//
DWORD   dwThreadAndLibraryTimeout = PERFLIB_TIMING_THREAD_TIMEOUT;

//      global key for access to HKLM\Software\....\Perflib
//
HKEY    ghKeyPerflib = NULL;

//
//      Error report frequency

DWORD   dwErrorFrequency = 1;

LONG    lEventLogLevel = LOG_NONE;
LONG    lPerflibConfigFlags = PLCF_DEFAULT;

// performance data block entries
WCHAR   szPerflibSectionFile[MAX_PATH];
WCHAR   szPerflibSectionName[MAX_PATH];
HANDLE  hPerflibSectionFile = NULL;
HANDLE  hPerflibSectionMap = NULL;
LPVOID  lpPerflibSectionAddr = NULL;

DWORD   dwBoostPriority = 1;

#define     dwPerflibSectionMaxEntries  127L
const DWORD dwPerflibSectionSize = (sizeof(PERFDATA_SECTION_HEADER) + \
                                   (sizeof(PERFDATA_SECTION_RECORD) * dwPerflibSectionMaxEntries));

// forward function references

LONG
PerfEnumTextValue (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpValueName,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData,
    OUT LPDWORD lpcbLen  OPTIONAL
    );

#if 0 // collection thread functions are not supported
DWORD
OpenCollectionThread (
)
{
    BOOL    bError = FALSE;
    DWORD   dwThreadID;

    assert (hCollectThread == NULL);

    // if it's already created, then just return
    if (hCollectThread != NULL) return ERROR_SUCCESS;

    bThreadHung = FALSE;
    hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] = CreateEvent (
        NULL,  // default security
        FALSE, // auto reset
        FALSE, // non-signaled
        NULL); // no name
    bError = hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] == NULL;
    assert (hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] != NULL);

    hCollectEvents[COLLECT_THREAD_EXIT_EVENT] = CreateEvent (
        NULL,  // default security
        FALSE, // auto reset
        FALSE, // non-signaled
        NULL); // no name
    bError = (hCollectEvents[COLLECT_THREAD_EXIT_EVENT] == NULL) | bError;
    assert (hCollectEvents[COLLECT_THREAD_EXIT_EVENT] != NULL);

    hCollectEvents[COLLECT_THREAD_DONE_EVENT] = CreateEvent (
        NULL,  // default security
        FALSE, // auto reset
        FALSE, // non-signaled
        NULL); // no name
    bError = (hCollectEvents[COLLECT_THREAD_DONE_EVENT] == NULL) | bError;
    assert (hCollectEvents[COLLECT_THREAD_DONE_EVENT] != NULL);

    if (!bError) {
        // create data collection thread
        hCollectThread = CreateThread (
            NULL,   // default security
            0,      // default stack size
            (LPTHREAD_START_ROUTINE)CollectThreadFunction,
            NULL,   // no argument
            0,      // no flags
            &dwThreadID);  // we don't need the ID so it's in an automatic variable

        if (hCollectThread == NULL) {
            bError = TRUE;
        }

        assert (hCollectThread != NULL);
    }

    if (bError) {
        if (hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] != NULL) {
            CloseHandle (hCollectEvents[COLLECT_THREAD_PROCESS_EVENT]);
            hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] = NULL;
        }
        if (hCollectEvents[COLLECT_THREAD_EXIT_EVENT] != NULL) {
            CloseHandle (hCollectEvents[COLLECT_THREAD_EXIT_EVENT]);
            hCollectEvents[COLLECT_THREAD_EXIT_EVENT] = NULL;
        }
        if (hCollectEvents[COLLECT_THREAD_DONE_EVENT] != NULL) {
            CloseHandle (hCollectEvents[COLLECT_THREAD_DONE_EVENT] = NULL);
            hCollectEvents[COLLECT_THREAD_DONE_EVENT] = NULL;
        }

        if (hCollectThread != NULL) {
            CloseHandle (hCollectThread);
            hCollectThread = NULL;
        }

        return (GetLastError());
    } else {
        return ERROR_SUCCESS;
    }
}


DWORD
CloseCollectionThread (
)
{
    if (hCollectThread != NULL) {
        // close the data collection thread
        if (bThreadHung) {
            // then kill it the hard way
            // this might cause problems, but it's better than
            // a thread leak
            TerminateThread (hCollectThread, ERROR_TIMEOUT);
        } else {
            // then ask it to leave
            SetEvent (hCollectEvents[COLLECT_THREAD_EXIT_EVENT]);
        }
        // wait for thread to leave
        WaitForSingleObject (hCollectThread, COLLECTION_WAIT_TIME);

        // close the handles and clear the variables
        CloseHandle (hCollectThread);
        hCollectThread = NULL;

        CloseHandle (hCollectEvents[COLLECT_THREAD_PROCESS_EVENT]);
        hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] = NULL;

        CloseHandle (hCollectEvents[COLLECT_THREAD_EXIT_EVENT]);
        hCollectEvents[COLLECT_THREAD_EXIT_EVENT] = NULL;

        CloseHandle (hCollectEvents[COLLECT_THREAD_DONE_EVENT]);
        hCollectEvents[COLLECT_THREAD_DONE_EVENT] = NULL;
    } else {
        // nothing was opened
    }
    return ERROR_SUCCESS;
}
#endif

DWORD
PerfOpenKey (
)
{

    LARGE_INTEGER       liPerfDataWaitTime;
    PLARGE_INTEGER      pTimeout;

    NTSTATUS status = STATUS_SUCCESS;
    DWORD   dwFnStatus = ERROR_SUCCESS;

    DWORD   dwType, dwSize, dwValue;
    HANDLE  hDataMutex;
    DWORD   bMutexHeld = FALSE;
    OSVERSIONINFOEXW OsVersion;

    if (hGlobalDataMutex == NULL) {
        hDataMutex = CreateMutex(NULL, TRUE, NULL);
        if (hDataMutex == NULL) {
            DebugPrint((0, "Perf Data Mutex Not Initialized\n"));
            goto OPD_Error_Exit_NoSemaphore;
        }
        if (InterlockedCompareExchangePointer(
                &hGlobalDataMutex,
                hDataMutex,
                NULL) != NULL) {
            CloseHandle(hDataMutex);    // mutex just got created by another thread
            hDataMutex = NULL;
        }
        else {
            hGlobalDataMutex = hDataMutex;
            bMutexHeld = TRUE;
        }
    }
    if (!bMutexHeld) {
        if ((dwThreadAndLibraryTimeout == 0) ||
            (dwThreadAndLibraryTimeout == INFINITE)) {
            pTimeout = NULL;
        }
        else {
            liPerfDataWaitTime.QuadPart = MakeTimeOutValue(dwThreadAndLibraryTimeout);
            pTimeout = &liPerfDataWaitTime;
        }

        status = NtWaitForSingleObject (
            hGlobalDataMutex, // Mutex
            FALSE,          // not alertable
            pTimeout);   // wait time

        if (status != STATUS_SUCCESS) {
            // unable to contine, return error;
            dwFnStatus = PerfpDosError(status);
            DebugPrint((0, "Status=%X in waiting for global mutex",
                    status));
            goto OPD_Error_Exit_NoSemaphore;
        }
    }

    // if here, then the data semaphore has been acquired by this thread

    if (!NumberOfOpens++) {
        if (ghKeyPerflib == NULL) {
            dwFnStatus = (DWORD)RegOpenKeyExW (
                HKEY_LOCAL_MACHINE,
                HKLMPerflibKey,
                0L,
                KEY_READ,
                &ghKeyPerflib);
        }

        assert (ghKeyPerflib != NULL);
        dwSize = sizeof(dwValue);
        dwValue = dwType = 0;
        dwFnStatus = PrivateRegQueryValueExW (
            ghKeyPerflib,
            DisablePerformanceCounters,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);

        if ((dwFnStatus == ERROR_SUCCESS) &&
            (dwType == REG_DWORD) &&
            (dwValue == 1)) {
            // then DON'T Load any libraries and unload any that have been
            // loaded
            NumberOfOpens--;    // since it didn't open.
            dwFnStatus = ERROR_SERVICE_DISABLED;
        } else {
            ComputerNameLength = 0;
            GetComputerNameW(pComputerName, &ComputerNameLength);
            ComputerNameLength++;  // account for the NULL terminator

            pComputerName = ALLOCMEM(ComputerNameLength * sizeof(WCHAR));
            if (pComputerName == NULL) {
                ComputerNameLength = 0;
            }
            else {
                if ( !GetComputerNameW(pComputerName, &ComputerNameLength) ) {
                //
                // Signal failure to data collection routine
                //

                    ComputerNameLength = 0;
                } else {
                    pComputerName[ComputerNameLength] = UNICODE_NULL;
                    ComputerNameLength = (ComputerNameLength+1) * sizeof(WCHAR);
                }
            }

            WinPerfStartTrace(ghKeyPerflib);

            // create event and indicate the list is busy
            hExtObjListIsNotInUse = CreateEvent (NULL, TRUE, FALSE, NULL);

            // read collection thread flag
            dwType = 0;
            dwSize = sizeof(DWORD);
            dwFnStatus = PrivateRegQueryValueExW (ghKeyPerflib,
                            cszPerflibFlags,
                            NULL,
                            &dwType,
                            (LPBYTE)&lPerflibConfigFlags,
                            &dwSize);

            if ((dwFnStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                // then keep it
            } else {
                // apply default value
                lPerflibConfigFlags = PLCF_DEFAULT;
            }

            // create global section for perf data on perflibs
            if ((hPerflibSectionFile == NULL) && (lPerflibConfigFlags & PLCF_ENABLE_PERF_SECTION)) {
                WCHAR   szTmpFileName[MAX_PATH];
                PPERFDATA_SECTION_HEADER pHead;
                WCHAR   szPID[32];

                // create section name
                lstrcpyW (szPerflibSectionName, (LPCWSTR)L"Perflib_Perfdata_");
                _ultow ((ULONG)GetCurrentProcessId(), szPID, 16);
                lstrcatW (szPerflibSectionName, szPID);

                // create filename
                lstrcpyW (szTmpFileName, (LPCWSTR)L"%TEMP%\\");
                lstrcatW (szTmpFileName, szPerflibSectionName);
                lstrcatW (szTmpFileName, (LPCWSTR)L".dat");
                ExpandEnvironmentStrings (szTmpFileName, szPerflibSectionFile, MAX_PATH);

                hPerflibSectionFile = CreateFile (szPerflibSectionFile,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_TEMPORARY,
                    NULL);

                if (hPerflibSectionFile != INVALID_HANDLE_VALUE) {
                    // create file mapping object
                    hPerflibSectionMap = CreateFileMapping (
                        hPerflibSectionFile,
                        NULL,
                        PAGE_READWRITE,
                        0, dwPerflibSectionSize,
                        szPerflibSectionName);

                    if (hPerflibSectionMap != NULL) {
                        // map view of file
                        lpPerflibSectionAddr = MapViewOfFile (
                            hPerflibSectionMap,
                            FILE_MAP_WRITE,
                            0,0, dwPerflibSectionSize);
                        if (lpPerflibSectionAddr != NULL) {
                            // init section if not already
                            pHead = (PPERFDATA_SECTION_HEADER)lpPerflibSectionAddr;
                            if (pHead->dwInitSignature != PDSH_INIT_SIG) {
                                // then init
                                // clear file to 0
                                memset (pHead, 0, dwPerflibSectionSize);
                                pHead->dwEntriesInUse = 0;
                                pHead->dwMaxEntries = dwPerflibSectionMaxEntries;
                                pHead->dwMissingEntries = 0;
                                pHead->dwInitSignature = PDSH_INIT_SIG;
                            } else {
                                // already initialized so leave it
                            }
                        } else {
                            // unable to map file so close
                            TRACE((WINPERF_DBG_TRACE_WARNING),
                                  (&PerflibGuid, __LINE__, PERF_OPEN_KEY, 0, 0, NULL));
                            CloseHandle (hPerflibSectionMap);
                            hPerflibSectionMap = NULL;
                            CloseHandle (hPerflibSectionFile);
                            hPerflibSectionFile = NULL;
                        }
                    } else {
                        // unable to create file mapping so close file
                        TRACE((WINPERF_DBG_TRACE_WARNING),
                              (&PerflibGuid, __LINE__, PERF_OPEN_KEY, 0, 0, NULL));
                        CloseHandle (hPerflibSectionFile);
                        hPerflibSectionFile = NULL;
                    }
                } else {
                    // unable to open file so no perf stats available
                    TRACE((WINPERF_DBG_TRACE_WARNING),
                          (&PerflibGuid, __LINE__, PERF_OPEN_KEY, 0, 0, NULL));
                    hPerflibSectionFile = NULL;
                }
            }

            // find and open perf counters
            OpenExtensibleObjects();

            dwExtObjListRefCount = 0;
            SetEvent (hExtObjListIsNotInUse); // indicate the list is not busy

            // read collection thread flag
            dwType = 0;
            dwSize = sizeof(DWORD);
            dwFnStatus = PrivateRegQueryValueExW (ghKeyPerflib,
                            UseCollectionThread,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwCollectionFlags,
                            &dwSize);
            if ((dwFnStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
                // validate the answer
                switch (dwCollectionFlags) {
                    case 0:
                        // this is a valid value
                        break;

                    case COLL_FLAG_USE_SEPARATE_THREAD:
                        // this feature is not supported so skip through
                    default:
                        // this is for invalid values
                        dwCollectionFlags = 0;
                        // dwCollectionFlags = COLL_FLAG_USE_SEPARATE_THREAD;
                        break;
                }
            }

            if (dwFnStatus != ERROR_SUCCESS) {
                dwCollectionFlags = 0;
                // dwCollectionFlags = COLL_FLAG_USE_SEPARATE_THREAD;
            }

            if (dwCollectionFlags == COLL_FLAG_USE_SEPARATE_THREAD) {
                // create data collection thread
                // a seperate thread is required for COM/OLE compatibity as some
                // client threads may be COM initialized incorrectly for the
                // extensible counter DLL's that may be called
//                status = OpenCollectionThread ();
            } else {
                hCollectEvents[COLLECT_THREAD_PROCESS_EVENT] = NULL;
                hCollectEvents[COLLECT_THREAD_EXIT_EVENT] = NULL;
                hCollectEvents[COLLECT_THREAD_DONE_EVENT] = NULL;
                hCollectThread = NULL;
            }
            dwFnStatus = ERROR_SUCCESS;
        }
        RtlZeroMemory(&OsVersion, sizeof(OsVersion));
        OsVersion.dwOSVersionInfoSize = sizeof(OsVersion);
        status = RtlGetVersion((POSVERSIONINFOW) &OsVersion);
        if (NT_SUCCESS(status)) {
            if (OsVersion.wProductType == VER_NT_WORKSTATION) {
                dwBoostPriority = 0;
            }
        }
    }
//    KdPrint(("PERFLIB: [Open]  Pid: %d, Number Of PerflibHandles: %d\n",
//            GetCurrentProcessId(), NumberOfOpens));

    if (hGlobalDataMutex != NULL) ReleaseMutex (hGlobalDataMutex);

OPD_Error_Exit_NoSemaphore:
    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_OPEN_KEY, 0, status,
           &NumberOfOpens, sizeof(NumberOfOpens), NULL));
    return dwFnStatus;
}


LONG
PerfRegQueryValue (
    IN HKEY hKey,
    IN PUNICODE_STRING lpValueName,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE  lpData,
    OUT LPDWORD lpcbData,
    OUT LPDWORD lpcbLen  OPTIONAL
    )
/*++

    PerfRegQueryValue -   Get data

        Inputs:

            hKey            -   Predefined handle to open remote
                                machine

            lpValueName     -   Name of the value to be returned;
                                could be "ForeignComputer:<computername>
                                or perhaps some other objects, separated
                                by ~; must be Unicode string

            lpReserved      -   should be omitted (NULL)

            lpType          -   should be omitted (NULL)

            lpData          -   pointer to a buffer to receive the
                                performance data

            lpcbData        -   pointer to a variable containing the
                                size in bytes of the output buffer;
                                on output, will receive the number
                                of bytes actually returned

            lpcbLen         -   Return the number of bytes to transmit to
                                the client (used by RPC) (optional).

         Return Value:

            DOS error code indicating status of call or
            ERROR_SUCCESS if all ok

--*/
{
    DWORD  dwQueryType;         //  type of request
    DWORD  TotalLen;            //  Length of the total return block
    DWORD  Win32Error;          //  Failure code
    DWORD  lFnStatus = ERROR_SUCCESS;   // Win32 status to return to caller
    LPVOID pDataDefinition;     //  Pointer to next object definition
    UNICODE_STRING  usLocalValue = {0,0, NULL};

    PERF_DATA_BLOCK *pPerfDataBlock = (PERF_DATA_BLOCK *)lpData;

    LARGE_INTEGER   liQueryWaitTime ;
    THREAD_BASIC_INFORMATION    tbiData;

    LONG   lOldPriority, lNewPriority;

    NTSTATUS status = STATUS_SUCCESS;

    LPWSTR  lpLangId = NULL;

    DBG_UNREFERENCED_PARAMETER(lpReserved);

    HEAP_PROBE();

    
    lOldPriority = lNewPriority = -1;
    // make a local copy of the value string if the arg references
    // the static buffer since it can be overwritten by
    // some of the RegistryEventSource call made by this routine

    pDataDefinition = NULL;
    if (lpValueName != NULL) {
        if (lpValueName == &NtCurrentTeb( )->StaticUnicodeString) {
            if (RtlCreateUnicodeString (
                &usLocalValue, lpValueName->Buffer)) {
                lFnStatus = ERROR_SUCCESS;
            } else {
                // unable to create string
                lFnStatus = ERROR_INVALID_PARAMETER;
            }
        } else {
            // copy the arg to the local structure
            memcpy (&usLocalValue, lpValueName, sizeof(UNICODE_STRING));
        }
    } else {
        lFnStatus = ERROR_INVALID_PARAMETER;
        goto PRQV_ErrorExit1;
    }

    if (lFnStatus != ERROR_SUCCESS) {
        goto PRQV_ErrorExit1;
    }

    if (hGlobalDataMutex == NULL) {
        // if a Mutex was not allocated then the key needs to be opened.
        // Without synchronization, it's too easy for threads to get
        // tangled up
        lFnStatus = PerfOpenKey ();

        if (lFnStatus == ERROR_SUCCESS) {
            if (!TestClientForAccess ()) {
                if (lEventLogLevel >= LOG_USER) {

                    LPTSTR  szMessageArray[2];
                    TCHAR   szUserName[128];
                    TCHAR   szModuleName[MAX_PATH];
                    DWORD   dwUserNameLength;

                    dwUserNameLength = sizeof(szUserName)/sizeof(TCHAR);
                    GetUserName (szUserName, &dwUserNameLength);
                    GetModuleFileName (NULL, szModuleName,
                        sizeof(szModuleName)/sizeof(TCHAR));

                    szMessageArray[0] = szUserName;
                    szMessageArray[1] = szModuleName;

                    ReportEvent (hEventLog,
                        EVENTLOG_ERROR_TYPE,        // error type
                        0,                          // category (not used)
                        (DWORD)PERFLIB_ACCESS_DENIED, // event,
                        NULL,                       // SID (not used),
                        2,                          // number of strings
                        0,                          // sizeof raw data
                        szMessageArray,             // message text array
                        NULL);                      // raw data
                }
                lFnStatus = ERROR_ACCESS_DENIED;
                TRACE((WINPERF_DBG_TRACE_FATAL),
                      (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, lFnStatus, NULL));
            }
        }
    }

    if (lFnStatus != ERROR_SUCCESS) {
        // goto the exit point
        goto PRQV_ErrorExit1;
    }
    if (dwBoostPriority != 0) {
        status = NtQueryInformationThread (
                    NtCurrentThread(),
                    ThreadBasicInformation,
                    &tbiData,
                    sizeof(tbiData),
                    NULL);

        if (NT_SUCCESS(status)) {
            lOldPriority = tbiData.Priority;
        } else {
            TRACE((WINPERF_DBG_TRACE_WARNING),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0,
                  status, NULL));
            lOldPriority = -1;
        }

        lNewPriority = DEFAULT_THREAD_PRIORITY; // perfmon's favorite priority

        //
        //  Only RAISE the priority here. Don't lower it if it's high
        //

        if ((lOldPriority > 0) && (lOldPriority < lNewPriority)) {

            status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadPriority,
                        &lNewPriority,
                        sizeof(lNewPriority)
                        );
            if (!NT_SUCCESS(status)) {
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0,
                      status, NULL));
                lOldPriority = -1;
            }

        } else {
            lOldPriority = -1;  // to save resetting at the end
        }
    }

    //
    // Set the length parameter to zero so that in case of an error,
    // nothing will be transmitted back to the client and the client won't
    // attempt to unmarshall anything.
    //

    if( ARGUMENT_PRESENT( lpcbLen )) {
        *lpcbLen = 0;
    }

    // if here, then assume the caller has the necessary access

    /*
        determine query type, can be one of the following
            Global
                get all objects
            List
                get objects in list (usLocalValue)

            Foreign Computer
                call extensible Counter Routine only

            Costly
                costly object items

            Counter
                get counter names for the specified language Id

            Help
                get help names for the specified language Id

    */
    dwQueryType = GetQueryType (usLocalValue.Buffer);
    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, dwQueryType, NULL));

    if (dwQueryType == QUERY_COUNTER || dwQueryType == QUERY_HELP ||
        dwQueryType == QUERY_ADDCOUNTER || dwQueryType == QUERY_ADDHELP ) {

        liQueryWaitTime.QuadPart = MakeTimeOutValue(QUERY_WAIT_TIME);

        status = NtWaitForSingleObject (
            hGlobalDataMutex, // semaphore
            FALSE,          // not alertable
            &liQueryWaitTime);          // wait 'til timeout

        if (status != STATUS_SUCCESS) {
            lFnStatus = ERROR_BUSY;
            Win32Error = ERROR_BUSY;
            TotalLen = *lpcbData;
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
        } else {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
            if (hKey == HKEY_PERFORMANCE_DATA) {
                lpLangId = NULL;
            } else if (hKey == HKEY_PERFORMANCE_TEXT) {
                lpLangId = DefaultLangId;
            } else if (hKey == HKEY_PERFORMANCE_NLSTEXT) {
                RtlZeroMemory(NativeLangId, 8 * sizeof(WCHAR));
                lpLangId = &NativeLangId[0];
                PerfGetLangId(NativeLangId);
            }

            status = PerfGetNames (
                dwQueryType,
                &usLocalValue,
                lpData,
                lpcbData,
                lpcbLen,
                lpLangId);

            TRACE((WINPERF_DBG_TRACE_INFO),
                (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status,
                &hKey, sizeof(hKey), NULL));

            if (!NT_SUCCESS(status) && (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
                // Sublanguage doesn't exist, so try the real one
                //
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
                RtlZeroMemory(NativeLangId, 8 * sizeof(WCHAR));
                PerfGetPrimaryLangId(GetUserDefaultUILanguage(), NativeLangId);
                status = PerfGetNames (
                            dwQueryType,
                            &usLocalValue,
                            lpData,
                            lpcbData,
                            lpcbLen,
                            lpLangId);
            }
            if (!NT_SUCCESS(status)) {
                TRACE((WINPERF_DBG_TRACE_FATAL),
                      (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
                // convert error to win32 for return
            }
            lFnStatus = PerfpDosError(status);

            if (ARGUMENT_PRESENT (lpType)) {
                // test for optional value
                *lpType = REG_MULTI_SZ;
            }

            ReleaseMutex (hGlobalDataMutex);
        }
    } else {
	    // define info block for data collection
	    COLLECT_THREAD_DATA CollectThreadData = {0, NULL, NULL, NULL, NULL, NULL, 0, 0};

        liQueryWaitTime.QuadPart = MakeTimeOutValue(QUERY_WAIT_TIME);

        status = NtWaitForSingleObject (
            hGlobalDataMutex, // semaphore
            FALSE,          // not alertable
            &liQueryWaitTime);          // wait 'til timeout

        if (status != STATUS_SUCCESS) {
            lFnStatus = ERROR_BUSY;
            Win32Error = ERROR_BUSY;
            TotalLen = *lpcbData;
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
        } else {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, status, NULL));
           //
           //  Format Return Buffer: start with basic data block
           //
           TotalLen = sizeof(PERF_DATA_BLOCK) +
                       ((CNLEN+sizeof(UNICODE_NULL))*sizeof(WCHAR));
           if ( *lpcbData < TotalLen ) {
               Win32Error = ERROR_MORE_DATA;
               TRACE((WINPERF_DBG_TRACE_ERROR),
                     (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, TotalLen,
                 lpcbData, sizeof(DWORD), NULL));
           } else {
                // foreign data provider will return the perf data header

                if (dwQueryType == QUERY_FOREIGN) {

                    // reset the values to avoid confusion

                    // *lpcbData = 0;  // 0 bytes  (removed to enable foreign computers)
                    pDataDefinition = (LPVOID)lpData;
                    memset (lpData, 0, sizeof (PERF_DATA_BLOCK)); // clear out header

                } else {

                    MonBuildPerfDataBlock(pPerfDataBlock,
                                        (PVOID *) &pDataDefinition,
                                        0,
                                        PROCESSOR_OBJECT_TITLE_INDEX);
                }

                CollectThreadData.dwQueryType = dwQueryType;
                CollectThreadData.lpValueName = usLocalValue.Buffer,
                CollectThreadData.lpData = lpData;
                CollectThreadData.lpcbData = lpcbData;
                CollectThreadData.lppDataDefinition = &pDataDefinition;
                CollectThreadData.pCurrentExtObject = NULL;
                CollectThreadData.lReturnValue = ERROR_SUCCESS;
                CollectThreadData.dwActionFlags = CTD_AF_NO_ACTION;

                if (hCollectThread == NULL) {
                    // then call the function directly and hope for the best
                    Win32Error = QueryExtensibleData (
                        &CollectThreadData);
                } else {
                    // collect the data in a separate thread
                    // load the args
                    // set event to get things going
                    SetEvent (hCollectEvents[COLLECT_THREAD_PROCESS_EVENT]);

                    // now wait for the thread to return
                    Win32Error = WaitForSingleObject (
                        hCollectEvents[COLLECT_THREAD_DONE_EVENT],
                        COLLECTION_WAIT_TIME);

                    if (Win32Error == WAIT_TIMEOUT) {
                        bThreadHung = TRUE;
                        // log error

                        TRACE((WINPERF_DBG_TRACE_FATAL),
                              (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, Win32Error, NULL));
                        if (lEventLogLevel >= LOG_USER) {
                            LPSTR   szMessageArray[2];
                            WORD    wStringIndex;
                            // load data for eventlog message
                            wStringIndex = 0;
                            if (CollectThreadData.pCurrentExtObject != NULL) {
                                szMessageArray[wStringIndex++] =
                                    CollectThreadData.pCurrentExtObject->szCollectProcName;
                            } else {
                                szMessageArray[wStringIndex++] = "Unknown";
                            }

                            ReportEventA (hEventLog,
                                EVENTLOG_ERROR_TYPE,        // error type
                                0,                          // category (not used)
                                (DWORD)PERFLIB_COLLECTION_HUNG,              // event,
                                NULL,                       // SID (not used),
                                wStringIndex,               // number of strings
                                0,                          // sizeof raw data
                                szMessageArray,             // message text array
                                NULL);                      // raw data

                        }

                        DisablePerfLibrary (CollectThreadData.pCurrentExtObject);

//                        DebugPrint((0, "Collection thread is hung in %s\n",
//                            CollectThreadData.pCurrentExtObject->szCollectProcName != NULL ?
//                            CollectThreadData.pCurrentExtObject->szCollectProcName : "Unknown"));
                        // and then wait forever for the thread to return
                        // this is done to prevent the function from returning
                        // while the collection thread is using the buffer
                        // passed in by the calling function and causing
                        // all kind of havoc should the buffer be changed and/or
                        // deleted and then have the thread continue for some reason

                        Win32Error = WaitForSingleObject (
                            hCollectEvents[COLLECT_THREAD_DONE_EVENT],
                            INFINITE);

                    }
                    bThreadHung = FALSE;    // in case it was true, but came out
                    // here the thread has returned so continue on
                    Win32Error = CollectThreadData.lReturnValue;
                }
#if 0
                if (CollectThreadData.dwActionFlags != CTD_AF_NO_ACTION) {
                    if (CollectThreadData.dwActionFlags == CTD_AF_OPEN_THREAD) {
                        OpenCollectionThread();
                    } else if (CollectThreadData.dwActionFlags == CTD_AF_CLOSE_THREAD) {
                        CloseCollectionThread();
                    } else {
                        assert (CollectThreadData.dwActionFlags != 0);
                    }
                }
#endif
            }
            ReleaseMutex (hGlobalDataMutex);
        }

        // if an error was encountered, return it

        if (Win32Error != ERROR_SUCCESS) {
            lFnStatus = Win32Error;
        } else {
            //
            //  Final housekeeping for data return: note data size
            //

            TotalLen = (DWORD) ((PCHAR) pDataDefinition - (PCHAR) lpData);
            *lpcbData = TotalLen;

            pPerfDataBlock->TotalByteLength = TotalLen;
            lFnStatus = ERROR_SUCCESS;
        }

        if (ARGUMENT_PRESENT (lpcbLen)) { // test for optional parameter
            *lpcbLen = TotalLen;
        }

        if (ARGUMENT_PRESENT (lpType)) { // test for optional value
            *lpType = REG_BINARY;
        }
    }

 PRQV_ErrorExit1:
    if (dwBoostPriority != 0) {
        // reset thread to original priority
        if ((lOldPriority > 0) && (lOldPriority != lNewPriority)) {
            NtSetInformationThread(
                NtCurrentThread(),
                ThreadPriority,
                &lOldPriority,
                sizeof(lOldPriority)
                );
        }
    }

    if (usLocalValue.Buffer != NULL) {
        // restore the value string if it was from the local static buffer
        // then free the local buffer
        if (lpValueName == &NtCurrentTeb( )->StaticUnicodeString) {
            memcpy (lpValueName->Buffer, usLocalValue.Buffer, usLocalValue.MaximumLength);
            RtlFreeUnicodeString (&usLocalValue);
        }
    }

    HEAP_PROBE();
    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_REG_QUERY_VALUE, 0, lFnStatus, NULL));
    return (LONG) lFnStatus;
}


LONG
PerfRegCloseKey
  (
    IN OUT PHKEY phKey
    )

/*++

Routine Description:

    Closes all performance handles when the usage count drops to 0.

Arguments:

    phKey - Supplies a handle to an open key to be closed.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    NTSTATUS status;
    LARGE_INTEGER   liQueryWaitTime ;

    HANDLE  hObjMutex;

    LONG    lReturn = ERROR_SUCCESS;
    HKEY    hKey;

    PEXT_OBJECT  pThisExtObj, pNextExtObj;
    //
    // Set the handle to NULL so that RPC knows that it has been closed.
    //

    hKey = *phKey;
    *phKey = NULL;

    if (hKey != HKEY_PERFORMANCE_DATA) {
        return ERROR_SUCCESS;
    }

    if (NumberOfOpens == 0) {
//        KdPrint(("PERFLIB: [Close] Pid: %d, Number Of PerflibHandles: %d\n",
//            GetCurrentProcessId(), NumberOfOpens));
        return ERROR_SUCCESS;
    }

    // wait for ext obj list to be "un"-busy

    liQueryWaitTime.QuadPart = MakeTimeOutValue (CLOSE_WAIT_TIME);
    status = NtWaitForSingleObject (
        hExtObjListIsNotInUse,
        FALSE,
        &liQueryWaitTime);

    if (status == STATUS_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status, NULL));

        // then the list is inactive so continue
        if (hGlobalDataMutex != NULL) {   // if a mutex was allocated, then use it

            // if here, then assume a mutex is ready

            liQueryWaitTime.QuadPart = MakeTimeOutValue(CLOSE_WAIT_TIME);

            status = NtWaitForSingleObject (
                hGlobalDataMutex, // semaphore
                FALSE,          // not alertable
                &liQueryWaitTime);          // wait forever

            if (status == STATUS_SUCCESS) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status, NULL));
                // now we have a lock on the global data, so continue
                NumberOfOpens--;
                if (!NumberOfOpens && (hKey == HKEY_PERFORMANCE_DATA)) {

                    // walk down list of known objects and close and delete each one
                    pNextExtObj = ExtensibleObjects;
                    while (pNextExtObj != NULL) {
                        // close and destroy each entry in the list
                        pThisExtObj = pNextExtObj;
                        hObjMutex = pThisExtObj->hMutex;
                        status = NtWaitForSingleObject (
                            hObjMutex,
                            FALSE,
                            &liQueryWaitTime);

                        if (status == STATUS_SUCCESS) {
                            TRACE((WINPERF_DBG_TRACE_INFO),
                                (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status,
                                pThisExtObj->szServiceName,
                                WSTRSIZE(pThisExtObj->szServiceName),
                                NULL));
                            InterlockedIncrement((LONG *)&pThisExtObj->dwLockoutCount);
                            status = CloseExtObjectLibrary(pThisExtObj, TRUE);

                            // close the handle to the perf subkey
                            NtClose (pThisExtObj->hPerfKey);

                            ReleaseMutex (hObjMutex);   // release
                            CloseHandle (hObjMutex);    // and free
                            pNextExtObj = pThisExtObj->pNext;

                            // toss the memory for this object
                            FREEMEM (pThisExtObj);
                        } else {
                            TRACE((WINPERF_DBG_TRACE_INFO),
                                (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status,
                                pThisExtObj->szServiceName,
                                WSTRSIZE(pThisExtObj->szServiceName),
                                NULL));
                            // this shouldn't happen since we've locked the
                            // list of objects
                            pNextExtObj = pThisExtObj->pNext;
                        }
                    }

                    // close the global objects
                    FREEMEM(pComputerName);
                    ComputerNameLength = 0;
                    pComputerName = NULL;

                    ExtensibleObjects = NULL;
                    NumExtensibleObjects = 0;

                    // close the timer thread
                    DestroyPerflibFunctionTimer ();

                    if (hEventLog != NULL) {
                        DeregisterEventSource (hEventLog);
                        hEventLog = NULL;
                    } // else the event log has already been closed

                    // release event handle
                    CloseHandle (hExtObjListIsNotInUse);
                    hExtObjListIsNotInUse = NULL;

//                    CloseCollectionThread();

                    if (ghKeyPerflib != NULL) {
                        RegCloseKey(ghKeyPerflib);
                        ghKeyPerflib = NULL;
                    }

                    if (lpPerflibSectionAddr != NULL) {
                        UnmapViewOfFile (lpPerflibSectionAddr);
                        lpPerflibSectionAddr = NULL;
                        CloseHandle (hPerflibSectionMap);
                        hPerflibSectionMap = NULL;
                        CloseHandle (hPerflibSectionFile);
                        hPerflibSectionFile = NULL;
                    }
                    ReleaseMutex(hGlobalDataMutex);

                } else { // this isn't the last open call so return success
                    assert(NumberOfOpens != 0);
                    ReleaseMutex (hGlobalDataMutex);
                }
            } else {
                TRACE((WINPERF_DBG_TRACE_FATAL),
                      (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status, NULL));
                // unable to lock the global data mutex in a timely fashion
                // so return
                lReturn = ERROR_BUSY;
            }
        } else {
            // if there's no mutex then something's fishy. It probably hasn't
            // been opened, yet.
            lReturn = ERROR_NOT_READY;
        }
    } else {
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, status, NULL));
        // the object list is still in use so return and let the
        // caller try again later
        lReturn = WAIT_TIMEOUT;
    }

//    KdPrint(("PERFLIB: [Close] Pid: %d, Number Of PerflibHandles: %d\n",
//        GetCurrentProcessId(), NumberOfOpens));

    TRACE((WINPERF_DBG_TRACE_INFO),
        (&PerflibGuid, __LINE__, PERF_REG_CLOSE_KEY, 0, lReturn,
        &NumberOfOpens, sizeof(NumberOfOpens), NULL));
    return lReturn;

}


LONG
PerfRegSetValue (
    IN HKEY hKey,
    IN LPWSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN LPBYTE  lpData,
    IN DWORD cbData
    )
/*++

    PerfRegSetValue -   Set data

        Inputs:

            hKey            -   Predefined handle to open remote
                                machine

            lpValueName     -   Name of the value to be returned;
                                could be "ForeignComputer:<computername>
                                or perhaps some other objects, separated
                                by ~; must be Unicode string

            lpReserved      -   should be omitted (NULL)

            lpType          -   should be REG_MULTI_SZ

            lpData          -   pointer to a buffer containing the
                                performance name

            lpcbData        -   pointer to a variable containing the
                                size in bytes of the input buffer;

         Return Value:

            DOS error code indicating status of call or
            ERROR_SUCCESS if all ok

--*/

{
    DWORD  dwQueryType;         //  type of request
    LPWSTR  lpLangId = NULL;
    NTSTATUS status;
    UNICODE_STRING String;
    LONG    lReturn = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(dwType);
    UNREFERENCED_PARAMETER(Reserved);

    dwQueryType = GetQueryType (lpValueName);

    TRACE((WINPERF_DBG_TRACE_INFO),
        (&PerflibGuid, __LINE__, PERF_REG_SET_VALUE, 0, dwQueryType,
        &hKey, sizeof(hKey), NULL));

    // convert the query to set commands
    if ((dwQueryType == QUERY_COUNTER) ||
        (dwQueryType == QUERY_ADDCOUNTER)) {
        dwQueryType = QUERY_ADDCOUNTER;
    } else if ((dwQueryType == QUERY_HELP) ||
              (dwQueryType == QUERY_ADDHELP)) {
        dwQueryType = QUERY_ADDHELP;
    } else {
        lReturn = ERROR_BADKEY;
        goto Error_exit;
    }

    if (hKey == HKEY_PERFORMANCE_TEXT) {
        lpLangId = DefaultLangId;
    } else if (hKey == HKEY_PERFORMANCE_NLSTEXT) {
        lpLangId = &NativeLangId[0];
        PerfGetLangId(NativeLangId);
    } else {
        lReturn = ERROR_BADKEY;
        goto Error_exit;
    }

    RtlInitUnicodeString(&String, lpValueName);

    status = PerfGetNames (
        dwQueryType,
        &String,
        lpData,
        &cbData,
        NULL,
        lpLangId);

    if (!NT_SUCCESS(status) && (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (&PerflibGuid, __LINE__, PERF_REG_SET_VALUE, 0, status, NULL));

        // Sublanguage doesn't exist, so try the real one
        //
        PerfGetPrimaryLangId(GetUserDefaultUILanguage(), NativeLangId);
        status = PerfGetNames (
                    dwQueryType,
                    &String,
                    lpData,
                    &cbData,
                    NULL,
                    lpLangId);
    }
    if (!NT_SUCCESS(status)) {
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (&PerflibGuid, __LINE__, PERF_REG_SET_VALUE, 0, status, NULL));

        lReturn = (error_status_t)PerfpDosError(status);
    }

Error_exit:
    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_REG_SET_VALUE, 0, lReturn, NULL));
    return (lReturn);
}


LONG
PerfRegEnumKey (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpName,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT PUNICODE_STRING lpClass OPTIONAL,
    OUT PFILETIME lpftLastWriteTime OPTIONAL
    )

/*++

Routine Description:

    Enumerates keys under HKEY_PERFORMANCE_DATA.

Arguments:

    Same as RegEnumKeyEx.  Returns that there are no such keys.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNREFERENCED_PARAMETER(hKey);
    UNREFERENCED_PARAMETER(dwIndex);
    UNREFERENCED_PARAMETER(lpReserved);

    lpName->Length = 0;

    if (ARGUMENT_PRESENT (lpClass)) {
        lpClass->Length = 0;
    }

    if ( ARGUMENT_PRESENT(lpftLastWriteTime) ) {
        lpftLastWriteTime->dwLowDateTime = 0;
        lpftLastWriteTime->dwHighDateTime = 0;
    }

    return ERROR_NO_MORE_ITEMS;
}


LONG
PerfRegQueryInfoKey (
    IN HKEY hKey,
    OUT PUNICODE_STRING lpClass,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcbMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    This returns information concerning the predefined handle
    HKEY_PERFORMANCE_DATA

Arguments:

    Same as RegQueryInfoKey.

Return Value:

    Returns ERROR_SUCCESS (0) for success.

--*/

{
    DWORD TempLength=0;
    DWORD MaxValueLen=0;
    UNICODE_STRING Null;
    SECURITY_DESCRIPTOR     SecurityDescriptor;
    HKEY                    hPerflibKey;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    DWORD                   PerfStatus = ERROR_SUCCESS;
    UNICODE_STRING          PerflibSubKeyString;
    BOOL                    bGetSACL = TRUE;

    UNREFERENCED_PARAMETER(lpReserved);

    if (lpClass->MaximumLength >= sizeof(UNICODE_NULL)) {
        lpClass->Length = 0;
        *lpClass->Buffer = UNICODE_NULL;
    }
    *lpcSubKeys = 0;
    *lpcbMaxSubKeyLen = 0;
    *lpcbMaxClassLen = 0;
    *lpcValues = NUM_VALUES;
    *lpcbMaxValueNameLen = VALUE_NAME_LENGTH;
    *lpcbMaxValueLen = 0;

    if ( ARGUMENT_PRESENT(lpftLastWriteTime) ) {
        lpftLastWriteTime->dwLowDateTime = 0;
        lpftLastWriteTime->dwHighDateTime = 0;
    }
    if ((hKey == HKEY_PERFORMANCE_TEXT) ||
        (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
        //
        // We have to go enumerate the values to determine the answer for
        // the MaxValueLen parameter.
        //
        Null.Buffer = NULL;
        Null.Length = 0;
        Null.MaximumLength = 0;
        PerfStatus = PerfEnumTextValue(hKey,
                          0,
                          &Null,
                          NULL,
                          NULL,
                          NULL,
                          &MaxValueLen,
                          NULL);
        if (PerfStatus == ERROR_SUCCESS) {
            PerfStatus = PerfEnumTextValue(hKey,
                            1,
                            &Null,
                            NULL,
                            NULL,
                            NULL,
                            &TempLength,
                            NULL);
        }

        if (PerfStatus == ERROR_SUCCESS) {
            if (TempLength > MaxValueLen) {
                MaxValueLen = TempLength;
            }
            *lpcbMaxValueLen = MaxValueLen;
        } else {
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_INFO_KEY, 0, PerfStatus, NULL));
            // unable to successfully enum text values for this
            // key so return 0's and the error code
            *lpcValues = 0;
            *lpcbMaxValueNameLen = 0;
        }
    }

    if (PerfStatus == ERROR_SUCCESS) {
        // continune if all is OK
        // now get the size of SecurityDescriptor for Perflib key

        RtlInitUnicodeString (
            &PerflibSubKeyString,
            PerflibKey);


        //
        // Initialize the OBJECT_ATTRIBUTES structure and open the key.
        //
        InitializeObjectAttributes(
                &Obja,
                &PerflibSubKeyString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );


        Status = NtOpenKey(
                    &hPerflibKey,
                    MAXIMUM_ALLOWED | ACCESS_SYSTEM_SECURITY,
                    &Obja
                    );

        if ( ! NT_SUCCESS( Status )) {
            Status = NtOpenKey(
                    &hPerflibKey,
                    MAXIMUM_ALLOWED,
                    &Obja
                    );
            bGetSACL = FALSE;
        }

        if ( ! NT_SUCCESS( Status )) {
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_INFO_KEY, 0, Status, NULL));
        } else {

            *lpcbSecurityDescriptor = 0;

            if (bGetSACL == FALSE) {
                //
                // Get the size of the key's SECURITY_DESCRIPTOR for OWNER, GROUP
                // and DACL. These three are always accessible (or inaccesible)
                // as a set.
                //
                Status = NtQuerySecurityObject(
                        hPerflibKey,
                        OWNER_SECURITY_INFORMATION
                        | GROUP_SECURITY_INFORMATION
                        | DACL_SECURITY_INFORMATION,
                        &SecurityDescriptor,
                        0,
                        lpcbSecurityDescriptor
                        );
            } else {
                //
                // Get the size of the key's SECURITY_DESCRIPTOR for OWNER, GROUP,
                // DACL, and SACL.
                //
                Status = NtQuerySecurityObject(
                            hPerflibKey,
                            OWNER_SECURITY_INFORMATION
                            | GROUP_SECURITY_INFORMATION
                            | DACL_SECURITY_INFORMATION
                            | SACL_SECURITY_INFORMATION,
                            &SecurityDescriptor,
                            0,
                            lpcbSecurityDescriptor
                            );
            }

            if( Status != STATUS_BUFFER_TOO_SMALL ) {
                *lpcbSecurityDescriptor = 0;
            } else {
                // this is expected so set status to success
                Status = STATUS_SUCCESS;
            }

            NtClose(hPerflibKey);
        }
        if (NT_SUCCESS( Status )) {
            PerfStatus = ERROR_SUCCESS;
        } else {
            TRACE((WINPERF_DBG_TRACE_FATAL),
                  (&PerflibGuid, __LINE__, PERF_REG_QUERY_INFO_KEY, 0, Status, NULL));
            // return error
            PerfStatus = PerfpDosError(Status);
        }
    } // else return status


    return (LONG) PerfStatus;
}


LONG
PerfRegEnumValue (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpValueName,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData,
    OUT LPDWORD lpcbLen  OPTIONAL
    )

/*++

Routine Description:

    Enumerates Values under HKEY_PERFORMANCE_DATA.

Arguments:

    Same as RegEnumValue.  Returns the values.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    USHORT cbNameSize;

    // table of names used by enum values
    UNICODE_STRING ValueNames[NUM_VALUES];

    ValueNames [0].Length = (WORD)(lstrlenW (GLOBAL_STRING) * sizeof(WCHAR));
    ValueNames [0].MaximumLength = (WORD)(ValueNames [0].Length + sizeof(UNICODE_NULL));
    ValueNames [0].Buffer =  (LPWSTR)GLOBAL_STRING;
    ValueNames [1].Length = (WORD)(lstrlenW(COSTLY_STRING) * sizeof(WCHAR));
    ValueNames [1].MaximumLength = (WORD)(ValueNames [1].Length + sizeof(UNICODE_NULL));
    ValueNames [1].Buffer = (LPWSTR)COSTLY_STRING;

    if ((hKey == HKEY_PERFORMANCE_TEXT) ||
        (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
        return(PerfEnumTextValue(hKey,
                                  dwIndex,
                                  lpValueName,
                                  lpReserved,
                                  lpType,
                                  lpData,
                                  lpcbData,
                                  lpcbLen));
    }

    if ( dwIndex >= NUM_VALUES ) {

        //
        // This is a request for data from a non-existent value name
        //

        *lpcbData = 0;

        return ERROR_NO_MORE_ITEMS;
    }

    cbNameSize = ValueNames[dwIndex].Length;

    if ( lpValueName->MaximumLength < cbNameSize ) {
        return ERROR_MORE_DATA;
    } else {

         lpValueName->Length = cbNameSize;
         RtlCopyUnicodeString(lpValueName, &ValueNames[dwIndex]);

         if (ARGUMENT_PRESENT (lpType)) {
            *lpType = REG_BINARY;
         }

         return PerfRegQueryValue(hKey,
                                  lpValueName,
                                  NULL,
                                  lpType,
                                  lpData,
                                  lpcbData,
                                  lpcbLen);

    }
}


LONG
PerfEnumTextValue (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpValueName,
    OUT LPDWORD lpReserved OPTIONAL,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData,
    OUT LPDWORD lpcbLen  OPTIONAL
    )
/*++

Routine Description:

    Enumerates Values under Perflib\lang

Arguments:

    Same as RegEnumValue.  Returns the values.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING FullValueName;
    LONG            lReturn = ERROR_SUCCESS;

    //
    // Only two values, "Counter" and "Help"
    //
    if (dwIndex==0) {
        lpValueName->Length = 0;
        RtlInitUnicodeString(&FullValueName, CounterValue);
    } else if (dwIndex==1) {
        lpValueName->Length = 0;
        RtlInitUnicodeString(&FullValueName, HelpValue);
    } else {
        return(ERROR_NO_MORE_ITEMS);
    }
    RtlCopyUnicodeString(lpValueName, &FullValueName);

    //
    // We need to NULL terminate the name to make RPC happy.
    //
    if (lpValueName->Length+sizeof(WCHAR) <= lpValueName->MaximumLength) {
        lpValueName->Buffer[lpValueName->Length / sizeof(WCHAR)] = UNICODE_NULL;
        lpValueName->Length += sizeof(UNICODE_NULL);
    }

    lReturn = PerfRegQueryValue(hKey,
                             &FullValueName,
                             lpReserved,
                             lpType,
                             lpData,
                             lpcbData,
                             lpcbLen);

    return lReturn;

}

#if 0
DWORD
CollectThreadFunction (
    LPDWORD dwArg
)
{
    DWORD   dwWaitStatus = 0;
    BOOL    bExit = FALSE;
    NTSTATUS   status = STATUS_SUCCESS;
    THREAD_BASIC_INFORMATION    tbiData;
    LONG    lOldPriority, lNewPriority;
    LONG    lStatus;

    UNREFERENCED_PARAMETER (dwArg);

//    KdPrint(("PERFLIB: Entering Data Collection Thread: PID: %d, TID: %d\n",
//        GetCurrentProcessId(), GetCurrentThreadId()));
    // raise the priority of this thread
    status = NtQueryInformationThread (
        NtCurrentThread(),
        ThreadBasicInformation,
        &tbiData,
        sizeof(tbiData),
        NULL);

    if (NT_SUCCESS(status)) {
        lOldPriority = tbiData.Priority;
        lNewPriority = DEFAULT_THREAD_PRIORITY; // perfmon's favorite priority

        //
        //  Only RAISE the priority here. Don't lower it if it's high
        //
        if (lOldPriority < lNewPriority) {
            status = NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadPriority,
                    &lNewPriority,
                    sizeof(lNewPriority)
                    );
            if (status != STATUS_SUCCESS) {
                DebugPrint((0, "Set Thread Priority failed: 0x%8.8x\n", status));
            }
        }
    }

    // wait for flags
    while (!bExit) {
        dwWaitStatus = WaitForMultipleObjects (
            COLLECT_THREAD_LOOP_EVENT_COUNT,
            hCollectEvents,
            FALSE, // wait for ANY event to go
            INFINITE); // wait for ever
        // see why the wait returned:
        if (dwWaitStatus == (WAIT_OBJECT_0 + COLLECT_THREAD_PROCESS_EVENT)) {
            // the event is cleared automatically
            // collect data
            lStatus = QueryExtensibleData (
                &CollectThreadData);
            CollectThreadData.lReturnValue = lStatus;
            SetEvent (hCollectEvents[COLLECT_THREAD_DONE_EVENT]);
        } else if (dwWaitStatus == (WAIT_OBJECT_0 + COLLECT_THREAD_EXIT_EVENT)) {
            bExit = TRUE;
            continue;   // go up and bail out
        } else {
            // who knows, so output message
            KdPrint(("\nPERFLILB: Collect Thread wait returned unknown value: 0x%8.8x",dwWaitStatus));
            bExit = TRUE;
            continue;
        }
    }
//    KdPrint(("PERFLIB: Leaving Data Collection Thread: PID: %d, TID: %d\n",
//        GetCurrentProcessId(), GetCurrentThreadId()));
    return ERROR_SUCCESS;
}
#endif

BOOL
PerfRegCleanup()
/*++

Routine Description:

    Cleans up anything that perflib uses before it unloads. Assumes
    that there are queries or perf reg opens outstanding.

Arguments:

    None

Return Value:

    Returns TRUE if succeed. FALSE otherwise.

--*/

{
    if (hGlobalDataMutex != NULL) {
        if (NumberOfOpens != 0)
            return FALSE;
        CloseHandle(hGlobalDataMutex);
        hGlobalDataMutex = NULL;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\perflib.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000-2001   Microsoft Corporation

Module Name:

    perflib.h

Abstract:

        Private functions and data structures used by perflib only

Author:

    JeePang  09/27/2000

Revision History:


--*/

#ifndef _PERFLIB_H_
#define _PERFLIB_H_
#define _WMI_SOURCE_
#include <wmistr.h>
#include <evntrace.h>

//
// Private registry function to prevent query within RegQueryValue
// This needs to preceed winperfp.h since it needs this function
//
LONG
PrivateRegQueryValueExT (
    HKEY    hKey,
    LPVOID  lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData,
    BOOL    bUnicode
);

#include <winperfp.h>

//
// Commonly used macros
//

#define HEAP_PROBE()    ;       // Not implemented

#define ALLOCMEM(size)     RtlAllocateHeap (RtlProcessHeap(), HEAP_ZERO_MEMORY, size)
#define REALLOCMEM(pointer, newsize) \
                                    RtlReAllocateHeap (RtlProcessHeap(), 0, pointer, newsize)
#define FREEMEM(pointer)   if ((pointer)) { RtlFreeHeap (RtlProcessHeap(), 0, pointer); }

#define MAX_KEY_NAME_LENGTH 256*sizeof(WCHAR)
#define MAX_VALUE_NAME_LENGTH 256*sizeof(WCHAR)
#define MAX_VALUE_DATA_LENGTH 256*sizeof(WCHAR)

//  flag to determine the "noisiness" of the event logging
//  this value is read from the system registry when the extensible
//  objects are loaded and used for the subsequent calls.
//
//
//    Levels:  LOG_UNDEFINED = registry log level not read yet
//             LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging      (warnings & errors)
//             LOG_VERBOSE = Maximum Debugging    (informational, success,
//                              error and warning messages
//
#define  LOG_UNDEFINED  ((LONG)-1)
#define  LOG_NONE       0
#define  LOG_USER       1
#define  LOG_DEBUG      2
#define  LOG_VERBOSE    3

//
//  define configurable extensible counter buffer testing
//
//  Test Level      Event that will prevent data buffer
//                  from being returne in PerfDataBlock
//
//  EXT_TEST_NOMEMALLOC Collect Fn. writes directly to calling fn's buffer
//
//      all the following test levels have the collect fn. write to a
//      buffer allocated separately from the calling fn's buffer
//
//  EXT_TEST_NONE   Collect Fn. Returns bad status or generates exception
//  EXT_TEST_BASIC  Collect Fn. has buffer overflow or violates guard page
//  EXT_TEST_ALL    Collect Fn. object or instance lengths are not conistent
//
//
#define     EXT_TEST_UNDEFINED  0
#define     EXT_TEST_ALL        1
#define     EXT_TEST_BASIC      2
#define     EXT_TEST_NONE       3
#define     EXT_TEST_NOMEMALLOC 4


//  Misc. configuration flags used by lPerflibConfigFlags
//
//      PLCF_NO_ALIGN_ERRORS        if set inhibit alignment error messages
//      PLCF_NO_DISABLE_DLLS        if set, auto disable of bad perf DLL's is inhibited
//      PLCF_NO_DLL_TESTING         disable all DLL testing for ALL dll's (overrides lExtCounterTestLevel)
//      PLCF_ENABLE_TIMEOUT_DISABLE if set then disable when timeout errors occur (unless PLCF_NO_DISABLE_DLLS is set)
//      PLCF_ENABLE_PERF_SECTION    enable the perflib performance data memory section
//
#define PLCF_NO_ALIGN_ERRORS        ((DWORD)0x00000001)
#define PLCF_NO_DISABLE_DLLS        ((DWORD)0x00000002)
#define PLCF_NO_DLL_TESTING         ((DWORD)0x00000004)
#define PLCF_ENABLE_TIMEOUT_DISABLE ((DWORD)0x00000008)
#define PLCF_ENABLE_PERF_SECTION    ((DWORD)0x00000010)

#define     PLCF_DEFAULT    PLCF_ENABLE_PERF_SECTION

#define COLL_FLAG_USE_SEPARATE_THREAD   1

#define CTD_AF_NO_ACTION        ((DWORD)0x00000000)
#define CTD_AF_CLOSE_THREAD     ((DWORD)0x00000001)
#define CTD_AF_OPEN_THREAD      ((DWORD)0x00000002)

//
// Constants & Flags used for EXT_OBJECT->dwFlags
//

// use query proc
#define PERF_EO_QUERY_FUNC          ((DWORD)0x00000001)
// true when DLL ret. error
#define PERF_EO_BAD_DLL             ((DWORD)0x00000002)
// true if lib should not be trimmed
#define PERF_EO_KEEP_RESIDENT       ((DWORD)0x00000004)
// true when in query list
#define PERF_EO_OBJ_IN_QUERY        ((DWORD)0x80000000)
// set if alignment error has been posted to event log
#define PERF_EO_ALIGN_ERR_POSTED    ((DWORD)0x00000008)
// set of the "Disable Performance Counters" value is set
#define PERF_EO_DISABLED            ((DWORD)0x00000010)
// set when the DLL is deemed trustworthy
#define PERF_EO_TRUSTED             ((DWORD)0x00000020)
// set when the DLL has been replaced with a new file
#define PERF_EO_NEW_FILE            ((DWORD)0x00000040)

typedef struct _DLL_VALIDATION_DATA {
    FILETIME    CreationDate;
    LONGLONG    FileSize;
} DLL_VALIDATION_DATA, *PDLL_VALIDATION_DATA;

#define EXT_OBJ_INFO_NAME_LENGTH    32

typedef struct _PERFDATA_SECTION_HEADER {
    DWORD       dwEntriesInUse;
    DWORD       dwMaxEntries;
    DWORD       dwMissingEntries;
    DWORD       dwInitSignature;
    BYTE        reserved[112];
} PERFDATA_SECTION_HEADER, *PPERFDATA_SECTION_HEADER;

#define PDSH_INIT_SIG   ((DWORD)0x01234567)

#define PDSR_SERVICE_NAME_LEN   32
typedef struct _PERFDATA_SECTION_RECORD {
    WCHAR       szServiceName[PDSR_SERVICE_NAME_LEN];
    LONGLONG    llElapsedTime;
    DWORD       dwCollectCount; // number of times Collect successfully called
    DWORD       dwOpenCount;    // number of Loads & opens
    DWORD       dwCloseCount;   // number of Unloads & closes
    DWORD       dwLockoutCount; // count of lock timeouts
    DWORD       dwErrorCount;   // count of errors (other than timeouts)
    DWORD       dwLastBufferSize; // size of the last buffer returned
    DWORD       dwMaxBufferSize; // size of MAX buffer returned
    DWORD       dwMaxBufferRejected; // size of largest buffer returned as too small
    BYTE        Reserved[24];     // reserved to make structure 128 bytes
} PERFDATA_SECTION_RECORD, *PPERFDATA_SECTION_RECORD;

//
// Default wait times for perf procs
//
#define CLOSE_WAIT_TIME     5000L   // wait time for query mutex (in ms)
#define QUERY_WAIT_TIME     2000L    // wait time for query mutex (in ms)
#define OPEN_PROC_WAIT_TIME 10000L  // default wait time for open proc to finish (in ms)

typedef struct _EXT_OBJECT {
        struct _EXT_OBJECT *pNext;   // pointer to next item in list
        HANDLE      hMutex;         // sync mutex for this function
        OPENPROC    OpenProc;       // address of the open routine
        LPSTR       szOpenProcName; // open procedure name
        LPWSTR      szLinkageString; // param for open proc
        COLLECTPROC CollectProc;    // address of the collect routine
        QUERYPROC   QueryProc;      // address of query proc
        LPSTR       szCollectProcName;  // collect procedure name
        DWORD       dwCollectTimeout;   // wait time in MS for collect proc
        DWORD       dwOpenTimeout;  // wait time in MS for open proc
        CLOSEPROC   CloseProc;     // address of the close routine
        LPSTR       szCloseProcName;    // close procedure name
        HANDLE      hLibrary ;     // handle returned by LoadLibraryW
        LPWSTR      szLibraryName;  // full path of library
        HKEY        hPerfKey;       // handle to performance sub key fo this service
        DWORD       dwNumObjects;  // number of supported objects
        DWORD       dwObjList[MAX_PERF_OBJECTS_IN_QUERY_FUNCTION];    // address of array of supported objects
        DWORD       dwFlags;        // flags
        DWORD       dwValidationLevel; // collect function validation/test level
        LPWSTR      szServiceName;  // service name
        LONGLONG    llLastUsedTime; // FILETIME of last access
        DLL_VALIDATION_DATA   LibData; // validation data
        FILETIME    ftLastGoodDllFileDate; // creation date of last successfully accessed DLL
// Performance statistics
        PPERFDATA_SECTION_RECORD      pPerfSectionEntry;  // pointer to entry in global section
        LONGLONG    llElapsedTime;  // time spent in call
        DWORD       dwCollectCount; // number of times Collect successfully called
        DWORD       dwOpenCount;    // number of Loads & opens
        DWORD       dwCloseCount;   // number of Unloads & closes
        DWORD       dwLockoutCount; // count of lock timeouts
        DWORD       dwErrorCount;   // count of errors (other than timeouts)
        DWORD       dwLastBufferSize; // size of the last buffer returned
        DWORD       dwMaxBufferSize; // size of MAX buffer returned
        DWORD       dwMaxBufferRejected; // size of largest buffer returned as too small
        DWORD       dwErrorLimit;
} EXT_OBJECT, *PEXT_OBJECT;

#define PERF_EOL_ITEM_FOUND ((DWORD)0x00000001)

typedef struct _COLLECT_THREAD_DATA {
    DWORD   dwQueryType;
    LPWSTR  lpValueName;
    LPBYTE  lpData;
    LPDWORD lpcbData;
    LPVOID  *lppDataDefinition;
    PEXT_OBJECT  pCurrentExtObject;
    LONG    lReturnValue;
    DWORD   dwActionFlags;
} COLLECT_THREAD_DATA, * PCOLLECT_THREAD_DATA;

// convert mS to relative time
#define MakeTimeOutValue(ms) ((LONGLONG)((LONG)(ms) * -10000L))

extern DWORD   dwThreadAndLibraryTimeout;
extern LONG    lEventLogLevel;
extern HANDLE  hEventLog;
extern LPVOID  lpPerflibSectionAddr;
extern DWORD    NumExtensibleObjects;
extern LONG    lExtCounterTestLevel;
extern PEXT_OBJECT  ExtensibleObjects;
extern HKEY    ghKeyPerflib;
extern HANDLE  hCollectThread;
extern DWORD   dwCollectionFlags;
extern DWORD   ComputerNameLength;
extern LPWSTR  pComputerName;
extern LONG    lPerflibConfigFlags;
extern HANDLE   hGlobalDataMutex;
extern HANDLE   hExtObjListIsNotInUse;
extern DWORD    dwExtObjListRefCount;

//
// Inline functions used by all
//

__inline
LONGLONG
GetTimeAsLongLong ()
/*++
    Returns time performance timer converted to ms.

-*/
{
    LARGE_INTEGER liCount, liFreq;
    LONGLONG        llReturn;

    if (NtQueryPerformanceCounter (&liCount, &liFreq) == STATUS_SUCCESS) {
        llReturn = liCount.QuadPart * 1000 / liFreq.QuadPart;
    } else {
        llReturn = 0;
    }
    return llReturn;
}

//
// From utils.h
//

#define LAST_BASE_INDEX 1847

// query types

#define QUERY_GLOBAL       1
#define QUERY_ITEMS        2
#define QUERY_FOREIGN      3
#define QUERY_COSTLY       4
#define QUERY_COUNTER      5
#define QUERY_HELP         6
#define QUERY_ADDCOUNTER   7
#define QUERY_ADDHELP      8

// structure for passing to extensible counter open procedure wait thread

typedef struct _OPEN_PROC_WAIT_INFO {
    struct _OPEN_PROC_WAIT_INFO *pNext;
    LPWSTR  szLibraryName;
    LPWSTR  szServiceName;
    DWORD   dwWaitTime;
    DWORD   dwEventMsg;
    LPVOID  pData;
} OPEN_PROC_WAIT_INFO, FAR * LPOPEN_PROC_WAIT_INFO;

#define PERFLIB_TIMING_THREAD_TIMEOUT  120000  // 2 min (in milliseconds)
// #define PERFLIB_TIMING_THREAD_TIMEOUT   30000  // 30 sec (for debugging)

extern const   WCHAR GLOBAL_STRING[];
extern const   WCHAR COSTLY_STRING[];

extern const   DWORD VALUE_NAME_LENGTH;
extern const   WCHAR DisablePerformanceCounters[];
//
// Registry settings/values supported by Perflib
//

extern const   WCHAR DLLValue[];
extern const   CHAR OpenValue[];
extern const   CHAR CloseValue[];
extern const   CHAR CollectValue[];
extern const   CHAR QueryValue[];
extern const   WCHAR ObjListValue[];
extern const   WCHAR LinkageKey[];
extern const   WCHAR ExportValue[];
extern const   WCHAR PerflibKey[];
extern const   WCHAR HKLMPerflibKey[];
extern const   WCHAR CounterValue[];
extern const   WCHAR HelpValue[];
extern const   WCHAR PerfSubKey[];
extern const   WCHAR ExtPath[];
extern const   WCHAR OpenTimeout[];
extern const   WCHAR CollectTimeout[];
extern const   WCHAR EventLogLevel[];
extern const   WCHAR ExtCounterTestLevel[];
extern const   WCHAR OpenProcedureWaitTime[];
extern const   WCHAR TotalInstanceName[];
extern const   WCHAR LibraryUnloadTime[];
extern const   WCHAR KeepResident[];
extern const   WCHAR NULL_STRING[];
extern const   WCHAR UseCollectionThread[];
extern const   WCHAR cszLibraryValidationData[];
extern const   WCHAR cszSuccessfulFileData[];
extern const   WCHAR cszPerflibFlags[];
extern const   WCHAR FirstCounter[];
extern const   WCHAR LastCounter[];
extern const   WCHAR FirstHelp[];
extern const   WCHAR LastHelp[];
extern const   WCHAR cszFailureCount[];
extern const   WCHAR cszFailureLimit[];

//
// From perfsec.h
//

//
//  Value to decide if process names should be collected from:
//      the SystemProcessInfo structure (fastest)
//          -- or --
//      the process's image file (slower, but shows Unicode filenames)
//
#define PNCM_NOT_DEFINED    ((LONG)-1)
#define PNCM_SYSTEM_INFO    0L
#define PNCM_MODULE_FILE    1L
//
//  Value to decide if the SE_PROFILE_SYSTEM_NAME priv should be checked
//
#define CPSR_NOT_DEFINED    ((LONG)-1)
#define CPSR_EVERYONE       0L
#define CPSR_CHECK_ENABLED  1L
#define CPSR_CHECK_PRIVS    1L

//
// Common functions
//
VOID
OpenExtensibleObjects(
    );

DWORD
OpenExtObjectLibrary (
    PEXT_OBJECT  pObj
);

DWORD
CloseExtObjectLibrary (
    PEXT_OBJECT  pObj,
    BOOL        bCloseNow
);

LONG
QueryExtensibleData (
    COLLECT_THREAD_DATA * pArgs
);


//
// From perfname.c
//

NTSTATUS
PerfGetNames (
   DWORD    QueryType,
   PUNICODE_STRING lpValueName,
   LPBYTE   lpData,
   LPDWORD  lpcbData,
   LPDWORD  lpcbLen,
   LPWSTR   lpLangId
);

VOID
PerfGetLangId(
    WCHAR *FullLangId
    );

VOID
PerfGetPrimaryLangId(
    DWORD   dwLangId,
    WCHAR * PrimaryLangId
    );


//
// From utils.c
//

NTSTATUS
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
);

BOOL
MatchString (
    IN LPCWSTR lpValueArg,
    IN LPCWSTR lpNameArg
);


DWORD
GetQueryType (
    IN LPWSTR lpValue
);

DWORD
GetNextNumberFromList (
    IN LPWSTR   szStartChar,
    IN LPWSTR   *szNextChar
);

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
);

BOOL
MonBuildPerfDataBlock(
    PERF_DATA_BLOCK *pBuffer,
    PVOID *pBufferNext,
    DWORD NumObjectTypes,
    DWORD DefaultObject
);

//
// Timer functions
//
HANDLE
StartPerflibFunctionTimer (
    IN  LPOPEN_PROC_WAIT_INFO pInfo
);

DWORD
KillPerflibFunctionTimer (
    IN  HANDLE  hPerflibTimer
);


DWORD
DestroyPerflibFunctionTimer (
);

LONG
GetPerfDllFileInfo (
    LPCWSTR             szFileName,
    PDLL_VALIDATION_DATA  pDllData
);

#define PrivateRegQueryValueExW(a,b,c,d,e,f)    \
        PrivateRegQueryValueExT(a,(LPVOID)b,c,d,e,f,TRUE)

#define PrivateRegQueryValueExA(a,b,c,d,e,f)    \
        PrivateRegQueryValueExT(a,(LPVOID)b,c,d,e,f,FALSE)

DWORD
PerfpDosError(
    IN NTSTATUS Status
    );

#ifdef DBG
VOID
PerfpDebug(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define DebugPrint(x) PerfpDebug x
#else
#define DebugPrint(x)
#endif // DBG

DWORD
DisablePerfLibrary (
    PEXT_OBJECT  pObj
);

DWORD
DisableLibrary(
    IN HKEY   hPerfKey,
    IN LPWSTR szServiceName
    );

DWORD
PerfCheckRegistry(
    IN HKEY hPerfKey,
    IN LPCWSTR szServiceName
    );

DWORD
PerfUpdateErrorCount(
    PEXT_OBJECT pObj,
    DWORD ErrorCount
    );

//
// From perfsec.c
//

BOOL
TestClientForPriv (
    BOOL    *pbThread,
    LPTSTR  szPrivName
);

BOOL
TestClientForAccess (
    VOID
);

LONG
GetProcessNameColMeth (
    VOID
);

LONG
GetPerfDataAccess (
    VOID
);

#endif // _PERFLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\sources.inc ===
TARGETNAME=perflib
TARGETPATH=obj
TARGETTYPE=LIBRARY

PASS1_PUBLISH={$(O)\perflib.lib=$(PROJECT_LIB_PATH)\perflib.lib}

INCLUDES=..\..;$(PROJECT_ROOT)\screg\winreg\prflbmsg\$(O);$(WINDOWS_INC_PATH)

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\perflib.c \
        ..\perfname.c \
        ..\perfsec.c \
        ..\utils.c \
        ..\extlib.c \
        ..\extinit.c \
        ..\extquery.c

LINKLIBS= $(BASE_LIB_PATH)\wmiclnt.lib

C_DEFINES=$(C_DEFINES) -DWIN32 -DSTRICT -D_ADVAPI32_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\perfname.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1994   Microsoft Corporation

Module Name:

    perfname.c

Abstract:

    This file returns the Counter names or help text.



Author:

    HonWah Chan  10/12/93

Revision History:



--*/
#define UNICODE
#define _UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "ntconreg.h"
#include "perflib.h"
#pragma warning(default:4306)

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4
#define QUERY_COUNTER   5
#define QUERY_HELP      6
#define QUERY_ADDCOUNTER   7
#define QUERY_ADDHELP      8

#define tohexdigit(x) ((CHAR) (((x) < 10) ? ((x) + L'0') : ((x) + L'a' - 10)))

#define  LANG_ID_START  25
WCHAR    FileNameTemplate[] = L"\\SystemRoot\\system32\\perf0000.dat";
WCHAR    SubFileNameTemplate[] = L"\\SystemRoot\\system32\\prf00000.dat";
WCHAR    DefaultLangId[] = L"009";

extern   WCHAR COUNTER_STRING[];
extern   WCHAR HELP_STRING[];
extern   WCHAR ADDCOUNTER_STRING[];
extern   WCHAR ADDHELP_STRING[];

VOID   Perflib004Update(LPWSTR pLangIdRequest);
LPWSTR PerflibCheckPerfFile(LPWSTR szLangId);

NTSTATUS
PerfGetNames    (
   IN    DWORD    QueryType,
   IN    PUNICODE_STRING lpValueName,
   OUT   LPBYTE   lpData,
   OUT   LPDWORD  lpcbData,
   OUT   LPDWORD  lpcbLen  OPTIONAL,
   IN    LPWSTR   lpLanguageId   OPTIONAL
   )
/*++

PerfGetCounterName

Arguments - Get either counter names or help text for the given language.
      If there is no language ID specified in the input, the default English
      version is returned.

Inputs -

   QueryType      -  Either QUERY_COUNTER or QUERY_HELP
                     or QUERY_ADDCOUNTER or QUERY_ADDHELP

   lpValueName    -  Either "Counter ???" or "Explain ???"
                     or "Addcounter ???" or "Addexplain ???"

   lpData         -  pointer to a buffer to receive the names

   lpcbData       -  pointer to a variable containing the size in bytes of
                     the output buffer; on output, will receive the number
                     of bytes actually returned

   lpcbLen        -  Return the number of bytes to transmit to
                     the client (used by RPC) (optional).

   lpLanguageId   -  Input string for the language id desired.

   Return Value -

            error code indicating status of call or
            ERROR_SUCCESS if all ok


--*/
{
    UNICODE_STRING NtFileName;
    NTSTATUS Status;
    WCHAR    Names[50], QueryChar;
    ULONG    NameLen, StartIndex;

    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    FILE_STANDARD_INFORMATION FileInformation;
    HANDLE  File;
    LPWSTR  pLangIdRequest;
    LPWSTR  pTmpLangId;
    BOOL    bAddNames, bSubLang;

    // build the file name
    RtlMoveMemory (Names, FileNameTemplate, sizeof(FileNameTemplate));

    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_GET_NAMES,
          ARG_DEF(ARG_TYPE_WSTR, 2), 0,
          &QueryType, sizeof(QueryType),
          lpValueName->Buffer, WSTRSIZE(lpValueName->Buffer), NULL));

    if (QueryType == QUERY_ADDCOUNTER || QueryType == QUERY_ADDHELP) {
        bAddNames = TRUE;
    } else {
        bAddNames = FALSE;
    }

    if (QueryType == QUERY_COUNTER || QueryType == QUERY_ADDCOUNTER) {
        QueryChar = L'c';
        NameLen = (ULONG) wcslen(COUNTER_STRING);
    } else {
        NameLen = (ULONG) wcslen(HELP_STRING);
        QueryChar = L'h';
    }

    if (lpLanguageId) {
        pLangIdRequest = lpLanguageId;
    } else {
        // get the lang id from the input lpValueName
        pLangIdRequest = lpValueName->Buffer + NameLen;
        do {
            if (lpValueName->Length < (NameLen + 3) * sizeof(WCHAR)) {
                // lpValueName is too small to contain the lang id, use default
                pLangIdRequest = DefaultLangId;
                break;
            }

            if (*pLangIdRequest >= L'0' && *pLangIdRequest <= L'9') {
                // found the first digit
                break;
            }
            pLangIdRequest++;
            NameLen++;
        } while (NameLen > 0); // always TRUE

        // Specially for 004 (CHT and CHS) if this is a Whistler upgrade.
        // Need to copy perfc004.dat/perfh004.dat to prfc0?04.dat/prfh0?04.dat
        // then rename perfc004.dat/perfh004.dat so that PERFLIB will not find
        // them in the future.
        // Currently this is a hack.
        //
        Perflib004Update(pLangIdRequest);

        pTmpLangId     = pLangIdRequest;
        pLangIdRequest = PerflibCheckPerfFile(pTmpLangId);
        if (pLangIdRequest == NULL) {
            pLangIdRequest = pTmpLangId;
        }
    }

    bSubLang =  ((pLangIdRequest[3] >= L'0') && (pLangIdRequest[3] <= L'9'));
    StartIndex = LANG_ID_START;
    if (bSubLang) {
        StartIndex = LANG_ID_START - 1;
        RtlMoveMemory(Names, SubFileNameTemplate, sizeof(SubFileNameTemplate));
    }

    Names[StartIndex] = QueryChar;
    Names[StartIndex + 1] = *pLangIdRequest++;
    Names[StartIndex + 2] = *pLangIdRequest++;
    Names[StartIndex + 3] = *pLangIdRequest++;
    if (bSubLang) {
        Names[StartIndex + 4] = *pLangIdRequest;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (&PerflibGuid, __LINE__, PERF_GET_NAMES,
          ARG_DEF(ARG_TYPE_WSTR, 1), 0,
          Names, WSTRSIZE(Names), NULL));

    RtlInitUnicodeString(&NtFileName, Names);
    // open the file for info
    InitializeObjectAttributes( &ObjectAttributes,
                                &NtFileName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                NULL
                              );
    if (bAddNames) {
        // writing name to data file

        LARGE_INTEGER   ByteOffset;

        ByteOffset.LowPart = ByteOffset.HighPart = 0;
        Status = NtCreateFile( &File,
                               SYNCHRONIZE | GENERIC_WRITE,
                               &ObjectAttributes,
                               &IoStatus,
                               NULL,               // no initial size
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ,
                               FILE_SUPERSEDE,     // always create
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,               // no ea buffer
                               0                   // no ea buffer
                           );
        if (!NT_SUCCESS( Status )) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            return( Status );
        }
        Status = NtWriteFile( File,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatus,
                              lpData,
                              *lpcbData,
                              &ByteOffset,
                              NULL
                             );

        if (!NT_SUCCESS( Status )) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            NtClose( File );
            return( Status );
        }
    } else {
        // reading name from data file
        Status = NtOpenFile( &File,
                             SYNCHRONIZE | GENERIC_READ,
                             &ObjectAttributes,
                             &IoStatus,
                             FILE_SHARE_DELETE |
                                FILE_SHARE_READ |
                                FILE_SHARE_WRITE,
                             FILE_SYNCHRONOUS_IO_NONALERT |
                                FILE_NON_DIRECTORY_FILE
                           );

        if (!NT_SUCCESS( Status )) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            return( Status );
        }

        Status = NtQueryInformationFile( File,
                                         &IoStatus,
                                         (PVOID)&FileInformation,
                                         sizeof( FileInformation ),
                                         FileStandardInformation
                                       );

        if (NT_SUCCESS( Status )) {
            if (FileInformation.EndOfFile.HighPart) {
                Status = STATUS_BUFFER_OVERFLOW;
                TRACE((WINPERF_DBG_TRACE_INFO),
                    (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            }
        }

        if (!NT_SUCCESS( Status )) {
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            NtClose( File );
            return( Status );
        }

        if (!ARGUMENT_PRESENT (lpData) ||
            *lpcbData < FileInformation.EndOfFile.LowPart) {
            NtClose( File );
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
            if (ARGUMENT_PRESENT (lpcbLen)) {
                // no data yet for the rpc
                *lpcbLen = 0;
            }
            *lpcbData = FileInformation.EndOfFile.LowPart;
            if (ARGUMENT_PRESENT (lpData)) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                    (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
                return (STATUS_BUFFER_OVERFLOW);
            }

            return(STATUS_SUCCESS);
        }


        Status = NtReadFile( File,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             lpData,
                             FileInformation.EndOfFile.LowPart,
                             NULL,
                             NULL
                            );

        if (NT_SUCCESS( Status )) {

            Status = IoStatus.Status;

            if (NT_SUCCESS( Status )) {
                if (IoStatus.Information != FileInformation.EndOfFile.LowPart) {
                    Status = STATUS_END_OF_FILE;
                }
            }
        }
        else {
            TRACE((WINPERF_DBG_TRACE_INFO),
                (&PerflibGuid, __LINE__, PERF_GET_NAMES, 0, Status, NULL));
        }

        if (NT_SUCCESS( Status )) {
            *lpcbData = FileInformation.EndOfFile.LowPart;

            if (ARGUMENT_PRESENT (lpcbLen))
                *lpcbLen = FileInformation.EndOfFile.LowPart;
        }
    } // end of reading names

    NtClose (File);
    return (Status);

}

VOID
PerfGetPrimaryLangId(
    DWORD   dwLangId,
    WCHAR * PrimaryLangId
    )
{
    // build the native language id
    WCHAR    LangId;
    WCHAR    nDigit;

    LangId = (WCHAR) PRIMARYLANGID(dwLangId);

    nDigit = (WCHAR) (LangId >> 8);
    PrimaryLangId[0] = tohexdigit(nDigit);

    nDigit = (WCHAR) (LangId & 0XF0) >> 4;
    PrimaryLangId[1] = tohexdigit(nDigit);

    nDigit = (WCHAR) (LangId & 0xF);
    PrimaryLangId[2] = tohexdigit(nDigit);
    PrimaryLangId[3] = L'\0';
}

VOID
PerfGetLangId(
    WCHAR *FullLangId
    )
{
    WCHAR LangId;
    WCHAR nDigit;

    LangId = (WCHAR) GetUserDefaultUILanguage();

    nDigit = (LangId & 0xF000) >> 12;
    FullLangId[0] = tohexdigit(nDigit);

    nDigit = (LangId & 0x0F00) >> 8;
    FullLangId[1] = tohexdigit(nDigit);

    nDigit = (LangId & 0x00F0) >> 4;
    FullLangId[2] = tohexdigit(nDigit);

    nDigit = LangId & 0xF;
    FullLangId[3] = tohexdigit(nDigit);

    FullLangId[4] = L'\0';
}

DWORD
GetLangIdFromSzLang(
    LPWSTR szLangId
    )
{
    DWORD dwLangId  = 0;
    DWORD dwLangLen = lstrlenW(szLangId);
    DWORD i;
    WCHAR wszDigit;

    for (i = 0; i < dwLangLen; i ++) {
        dwLangId <<= 4;
        wszDigit = szLangId[i];
        if (wszDigit >= L'0' && wszDigit <= L'9') {
            dwLangId += (wszDigit - L'0');
        }
        else if (wszDigit >= L'a' && wszDigit <= 'f') {
            dwLangId += (10 + wszDigit - L'a');
        }
        else if (wszDigit >= L'A' && wszDigit <= 'F') {
            dwLangId += (10 + wszDigit - L'A');
        }
        else {
            dwLangId = 0;
            break;
        }
    }

    return dwLangId;
}

WCHAR   szRtnLang[5];
WCHAR   szSysDir[MAX_PATH];
WCHAR   szSrchDir[MAX_PATH];
WCHAR   szTmpFile[MAX_PATH];
LPCWSTR szCtrLangFile    = L"perfc";
LPCWSTR szCtrSubLangFile = L"prfc";
LPCWSTR szHlpLangFile    = L"perfh";
LPCWSTR szHlpSubLangFile = L"prfh";
LPCWSTR sz004CtrLangFile = L"perfc004.dat";
LPCWSTR sz004HlpLangFile = L"perfh004.dat";
LPCWSTR szFileExt        = L".dat";

LPWSTR
PerflibFindCounterFile(
    IN  LPWSTR szFilePath,
    IN  BOOLEAN bCheckSubLang,
    IN  LPWSTR szLangId
   )
{
    WCHAR            szThisLang[5];
    WCHAR            szPrimaryLang[5];
    DWORD            dwThisLang;
    DWORD            dwFileLen;
    WIN32_FIND_DATAW FindFileData;
    BOOLEAN          bResult = FALSE;
    HANDLE           hFile   = FindFirstFileExW(szFilePath,
                                                FindExInfoStandard,
                                                & FindFileData,
                                                FindExSearchNameMatch,
                                                NULL,
                                                0);
    RtlZeroMemory(szRtnLang, 5 * sizeof(WCHAR));
    if (hFile != INVALID_HANDLE_VALUE) {
        if (bCheckSubLang) {
            do {
                dwFileLen = lstrlenW(FindFileData.cFileName);
                if (dwFileLen == 12) {
                    ZeroMemory(szThisLang, 5 * sizeof(WCHAR));
                    ZeroMemory(szPrimaryLang, 5 * sizeof(WCHAR));
                    lstrcpynW(szThisLang,
                            (LPWSTR) (FindFileData.cFileName + (dwFileLen - 8)),
                            5);
                    dwThisLang = GetLangIdFromSzLang(szThisLang);
                    if (dwThisLang != 0) {
                        PerfGetPrimaryLangId(dwThisLang, szPrimaryLang);
                        bResult = (lstrcmpiW(szPrimaryLang, szLangId) == 0);
                        if (bResult == TRUE) {
                            lstrcpyW(szRtnLang, szThisLang);
                        }
                    }
                }
            }
            while (FindNextFileW(hFile, & FindFileData));
        }
        else {
            bResult = TRUE;
            lstrcpyW(szRtnLang, szLangId);
        }
        FindClose(hFile);
    }
    return bResult ? szRtnLang : NULL;
}

LPWSTR
PerflibCheckPerfFile(
    IN  LPWSTR LangId
    )
{
    DWORD     dwLangLen = lstrlenW(LangId);
    DWORD     dwLangId;
    LPWSTR    szRtnLang = NULL;
    WCHAR     szLang[5];

    ZeroMemory(szSysDir, sizeof(WCHAR) * MAX_PATH);
    GetSystemDirectoryW(szSysDir, MAX_PATH);
    ZeroMemory(szSrchDir, sizeof(WCHAR) * MAX_PATH);
    if (dwLangLen == 4) {
        lstrcpyW(szSrchDir, szSysDir);
        lstrcatW(szSrchDir, L"\\");
        lstrcatW(szSrchDir, szCtrSubLangFile);
        lstrcatW(szSrchDir, LangId);
        lstrcatW(szSrchDir, szFileExt);
        szRtnLang = PerflibFindCounterFile(szSrchDir, FALSE, LangId);

        if (szRtnLang == NULL) {
            dwLangId = GetLangIdFromSzLang(LangId);
            if (dwLangId != 0) {
                ZeroMemory(szLang, sizeof(WCHAR) * 5);
                PerfGetPrimaryLangId(dwLangId, szLang);
                ZeroMemory(szSrchDir, sizeof(WCHAR) * MAX_PATH);
                lstrcpyW(szSrchDir, szSysDir);
                lstrcatW(szSrchDir, L"\\");
                lstrcatW(szSrchDir, szCtrLangFile);
                lstrcatW(szSrchDir, szLang);
                lstrcatW(szSrchDir, szFileExt);
                szRtnLang = PerflibFindCounterFile(szSrchDir, FALSE, szLang);
            }
        }
    }
    else {
        // dwLangId should be 3, this is primary UserDefaultUILanguage.
        //
        ZeroMemory(szSrchDir, sizeof(WCHAR) * MAX_PATH);
        lstrcpyW(szSrchDir, szSysDir);
        lstrcatW(szSrchDir, L"\\");
        lstrcatW(szSrchDir, szCtrLangFile);
        lstrcatW(szSrchDir, LangId);
        lstrcatW(szSrchDir, szFileExt);
        szRtnLang = PerflibFindCounterFile(szSrchDir, FALSE, LangId);
        if (szRtnLang == NULL) {
            ZeroMemory(szSrchDir, sizeof(WCHAR) * MAX_PATH);
            lstrcpyW(szSrchDir, szSysDir);
            lstrcatW(szSrchDir, L"\\");
            lstrcatW(szSrchDir, szCtrSubLangFile);
            lstrcatW(szSrchDir, L"??");
            lstrcatW(szSrchDir, (LPWSTR) (LangId + 1));
            lstrcatW(szSrchDir, szFileExt);
            szRtnLang = PerflibFindCounterFile(szSrchDir, TRUE, LangId);
        }
    }
    return szRtnLang;
}

VOID
PerflibRename004File(
    IN  LPWSTR  szSysDir,
    IN  LPWSTR  szLangId,
    IN  BOOLEAN bCounterFile
)
{
    ZeroMemory(szSrchDir, sizeof(WCHAR) * MAX_PATH);
    lstrcpyW(szSrchDir, szSysDir);
    lstrcatW(szSrchDir, L"\\");
    if (bCounterFile) {
        lstrcatW(szSrchDir, sz004CtrLangFile);
    }
    else {
        lstrcatW(szSrchDir, sz004HlpLangFile);
    }

    ZeroMemory(szTmpFile, sizeof(WCHAR) * MAX_PATH);
    lstrcpyW(szTmpFile, szSysDir);
    lstrcatW(szTmpFile, L"\\");
    if (szLangId) {
        if (bCounterFile) {
            lstrcatW(szTmpFile, szCtrSubLangFile);
        }
        else {
            lstrcatW(szTmpFile, szHlpSubLangFile);
        }
        lstrcatW(szTmpFile, szLangId);
        lstrcatW(szTmpFile, szFileExt);
        CopyFileW(szSrchDir, szTmpFile, FALSE);
    }
    else {
        lstrcatW(szTmpFile, L"\\");
        if (bCounterFile) {
            lstrcatW(szTmpFile, sz004CtrLangFile);
        }
        else {
            lstrcatW(szTmpFile, sz004HlpLangFile);
        }
        lstrcatW(szTmpFile, L".tmp");
        DeleteFileW(szTmpFile);
        MoveFileW(szSrchDir, szTmpFile);
    }
}

VOID
Perflib004Update(
    IN  LPWSTR pLangIdRequest
)
{
    if (GetLangIdFromSzLang(pLangIdRequest) != LANG_CHINESE) goto Cleanup;

    // Search whether PERFC004.DAT and PRFC0?04.DAT are in System32 directory
    //
    ZeroMemory(szSysDir, sizeof(WCHAR) * MAX_PATH);
    GetSystemDirectoryW(szSysDir, MAX_PATH);

    if (SearchPathW(szSysDir, sz004CtrLangFile, NULL, 0, NULL, NULL) == 0)
        goto Cleanup;

    ZeroMemory(szRtnLang, sizeof(WCHAR) * 5);
    PerfGetLangId(szRtnLang);
    ZeroMemory(szTmpFile, sizeof(WCHAR) * MAX_PATH);
    lstrcpyW(szTmpFile, szCtrSubLangFile);
    lstrcatW(szTmpFile, szRtnLang);
    lstrcatW(szTmpFile, szFileExt);
    
    if (SearchPathW(szSysDir, szTmpFile, NULL, 0, NULL, NULL) == 0)
        goto Cleanup;

    // Found PERFC004.DAT, assume that PERFH004.DAT is also there.
    // Rename to PRFC0?04.DAT/PRFH0?04.DAT
    //
    PerflibRename004File(szSysDir, szRtnLang, TRUE);
    PerflibRename004File(szSysDir, szRtnLang, FALSE);
    PerflibRename004File(szSysDir, NULL,      TRUE);
    PerflibRename004File(szSysDir, NULL,      FALSE);

Cleanup:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\perfsec.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1994   Microsoft Corporation

Module Name:

    perfsec.c

Abstract:

    This file implements the _access checking functions used by the
    performance registry API's

Author:

    Bob Watson (a-robw)

Revision History:

    8-Mar-95    Created (and extracted from Perflib.c

--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "ntconreg.h"
#include "perflib.h"
#pragma warning(default:4306)

#define INITIAL_SID_BUFFER_SIZE     4096
#define FREE_IF_ALLOC(x)    if ((x) != NULL) {FREEMEM(x);}

BOOL
TestTokenForPriv(
    HANDLE hToken,
	LPTSTR	szPrivName
)
/***************************************************************************\
* TestTokenForPriv
*
* Returns TRUE if the token passed has the specified privilege
*
* The token handle passed must have TOKEN_QUERY access.
*
* History:
* 03-07-95 a-robw		Created
\***************************************************************************/
{
	BOOL		bStatus;
	LUID		PrivLuid;
	PRIVILEGE_SET	PrivSet;
	LUID_AND_ATTRIBUTES	PrivLAndA[1];

	BOOL		bReturn = FALSE;

	// get value of priv

	bStatus = LookupPrivilegeValue (
		NULL,
		szPrivName,
		&PrivLuid);

	if (!bStatus) {
		// unable to lookup privilege
		goto Exit_Point;
	}

	// build Privilege Set for function call

	PrivLAndA[0].Luid = PrivLuid;
	PrivLAndA[0].Attributes = 0;

	PrivSet.PrivilegeCount = 1;
	PrivSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
	PrivSet.Privilege[0] = PrivLAndA[0];

	// check for the specified priv in the token

	bStatus = PrivilegeCheck (
		hToken,
		&PrivSet,
		&bReturn);

	if (bStatus) {
		SetLastError (ERROR_SUCCESS);
	}

    //
    // Tidy up
    //
Exit_Point:

    return(bReturn);
}

BOOL
TestClientForPriv (
	BOOL	*pbThread,
	LPTSTR	szPrivName
)
/***************************************************************************\
* TestClientForPriv
*
* Returns TRUE if our client has the specified privilege
* Otherwise, returns FALSE.
*
\***************************************************************************/
{
    BOOL bResult;
    BOOL bIgnore;
	DWORD	dwLastError;

	BOOL	bThreadFlag = FALSE; // assume data is from process or an error occurred

    HANDLE hClient;

	SetLastError (ERROR_SUCCESS);

    bResult = OpenThreadToken(GetCurrentThread(),	// This Thread
                             TOKEN_QUERY,           	//DesiredAccess
							 FALSE,					// use context of calling thread
                             &hClient);           	//TokenHandle
    if (!bResult) {
		// unable to get a Thread Token, try a Process Token
	    bResult = OpenProcessToken(GetCurrentProcess(),	// This Process
                             TOKEN_QUERY,           	//DesiredAccess
                             &hClient);           		//TokenHandle
	} else {
		// data is from current THREAD
		bThreadFlag = TRUE;
	}

    if (bResult) {
		try {
        	bResult = TestTokenForPriv( hClient, szPrivName );
        } except (EXCEPTION_EXECUTE_HANDLER) {
			bResult = FALSE;
		}
        bIgnore = CloseHandle( hClient );
        ASSERT(bIgnore == TRUE);
	} else {
		dwLastError = GetLastError ();
	}

	// set thread flag if present
	if (pbThread != NULL) {
		try {
			*pbThread = bThreadFlag;
        } except (EXCEPTION_EXECUTE_HANDLER) {
			SetLastError (ERROR_INVALID_PARAMETER);
		}
	}

    return(bResult);
}

LONG
GetProcessNameColMeth (
    VOID
)
{
    NTSTATUS            Status;
    HANDLE              hPerflibKey;
    OBJECT_ATTRIBUTES   oaPerflibKey;
    UNICODE_STRING      PerflibSubKeyString;
    UNICODE_STRING      NameInfoValueString;
    LONG                lReturn = PNCM_SYSTEM_INFO;
    PKEY_VALUE_PARTIAL_INFORMATION    pKeyInfo;
    DWORD               dwBufLen;
    DWORD               dwRetBufLen;
    PDWORD              pdwValue;

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");

    InitializeObjectAttributes(
            &oaPerflibKey,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                MAXIMUM_ALLOWED,
                &oaPerflibKey
                );

    if (NT_SUCCESS (Status)) {
        // registry key opened, now read value.
        // allocate enough room for the structure, - the last
        // UCHAR in the struct, but + the data buffer (a dword)

        dwBufLen = sizeof(KEY_VALUE_PARTIAL_INFORMATION) -
            sizeof(UCHAR) + sizeof (DWORD);

        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ALLOCMEM (dwBufLen);

        if (pKeyInfo != NULL) {
            // initialize value name string
            RtlInitUnicodeString (
                &NameInfoValueString,
                L"CollectUnicodeProcessNames");

            dwRetBufLen = 0;
            Status = NtQueryValueKey (
                hPerflibKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                // check value of return data buffer
                pdwValue = (PDWORD)&pKeyInfo->Data[0];
                if (*pdwValue == PNCM_MODULE_FILE) {
                    lReturn = PNCM_MODULE_FILE;
                } else {
                    // all other values will cause this routine to return
                    // the default value of PNCM_SYSTEM_INFO;
                }
            }

            FREEMEM (pKeyInfo);
        }
        // close handle
        NtClose (hPerflibKey);
    }

    return lReturn;
}

LONG
GetPerfDataAccess (
    VOID
)
{
    NTSTATUS            Status;
    HANDLE              hPerflibKey;
    OBJECT_ATTRIBUTES   oaPerflibKey;
    UNICODE_STRING      PerflibSubKeyString;
    UNICODE_STRING      NameInfoValueString;
    LONG                lReturn = CPSR_EVERYONE;
    PKEY_VALUE_PARTIAL_INFORMATION    pKeyInfo;
    DWORD               dwBufLen;
    DWORD               dwRetBufLen;
    PDWORD              pdwValue;

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");

    InitializeObjectAttributes(
            &oaPerflibKey,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                MAXIMUM_ALLOWED,
                &oaPerflibKey
                );

    if (NT_SUCCESS (Status)) {
        // registry key opened, now read value.
        // allocate enough room for the structure, - the last
        // UCHAR in the struct, but + the data buffer (a dword)

        dwBufLen = sizeof(KEY_VALUE_PARTIAL_INFORMATION) -
            sizeof(UCHAR) + sizeof (DWORD);

        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ALLOCMEM (dwBufLen);

        if (pKeyInfo != NULL) {

            // see if the user right should be checked

            // init value name string
            RtlInitUnicodeString (
                &NameInfoValueString,
                L"CheckProfileSystemRight");

            dwRetBufLen = 0;
            Status = NtQueryValueKey (
                hPerflibKey,
                &NameInfoValueString,
                KeyValuePartialInformation,
                (PVOID)pKeyInfo,
                dwBufLen,
                &dwRetBufLen);

            if (NT_SUCCESS(Status)) {
                // check value of return data buffer
                pdwValue = (PDWORD)&pKeyInfo->Data[0];
                if (*pdwValue == CPSR_CHECK_ENABLED) {
                    lReturn = CPSR_CHECK_PRIVS;
                } else {
                    // all other values will cause this routine to return
                    // the default value of CPSR_EVERYONE
                }
            }

            FREEMEM (pKeyInfo);
        }
        // close handle
        NtClose (hPerflibKey);
    }

    return lReturn;
}

BOOL
TestClientForAccess ( 
    VOID
)
/***************************************************************************\
* TestClientForAccess
*
* Returns TRUE if our client is allowed to read the perflib key.
* Otherwise, returns FALSE.
*
\***************************************************************************/
{
    HKEY hKeyPerflib;
    DWORD   dwStatus;
    BOOL bResult = FALSE;

    dwStatus = RegOpenKeyExW(
       HKEY_LOCAL_MACHINE,
       L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib",
       0L,
       KEY_READ,
       & hKeyPerflib);

    if (dwStatus == ERROR_SUCCESS) {
        RegCloseKey(hKeyPerflib);
        bResult = TRUE;
    }

    return (bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\tests\testperf.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    testperf.c

Abstract:

    
    Test program for very basic perflib features

Author:

    01-Nov-2000 JeePang

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <stdlib.h>

#include <winperf.h>

#define BUFSIZE     1024 * 1024

char Buffer[BUFSIZE];

int _cdecl main(int argc, char *argv[])
{
    DWORD status, dwSize;

    LANGID iLanguage;

    iLanguage = GetUserDefaultLangID();
    printf("User locale:        %04X Primary %X Sub %X\n",
        iLanguage, PRIMARYLANGID(iLanguage), SUBLANGID(iLanguage));

    iLanguage = GetSystemDefaultLangID();
    printf("System locale:      %04X Primary %X Sub %X\n",
        iLanguage, PRIMARYLANGID(iLanguage), SUBLANGID(iLanguage));

    iLanguage = GetUserDefaultUILanguage();
    printf("User UI Language:   %04X Primary %X Sub %X\n",
        iLanguage, PRIMARYLANGID(iLanguage), SUBLANGID(iLanguage));

    iLanguage = GetSystemDefaultUILanguage();
    printf("System UI Language: %04X Primary %X Sub %X\n",
        iLanguage, PRIMARYLANGID(iLanguage), SUBLANGID(iLanguage));

    dwSize = BUFSIZE;
    status = RegQueryValueExW(
                HKEY_PERFORMANCE_NLSTEXT,
                L"Counter",
                NULL,
                NULL,
                Buffer,
                &dwSize);

    printf("Query NLSTEXT: status=%d dwSize=%d\n", status, dwSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\regconn\shutinit.c ===
#include <shutinit_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\regconn\regconn.h ===
/*++


Copyright (c) 1999 Microsoft Corporation

Module Name:

    regconn.h

Abstract:

    This module is the header file for the regconn library

Author:

    Dragos C. Sambotin (dragoss) 21-May-1999

--*/

//
// Common helper routine used by RegConnectRegistry and InitiateSystemShutdown
//

#ifndef __REG_CONN_H__
#define __REG_CONN_H__

typedef LONG (*PBIND_CALLBACK)(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PVOID Context1,
    IN PVOID Context2
    );

typedef struct _SHUTDOWN_CONTEXT {
    DWORD dwTimeout;
    BOOLEAN bForceAppsClosed;
    BOOLEAN bRebootAfterShutdown;
} SHUTDOWN_CONTEXT, *PSHUTDOWN_CONTEXT;

//
// SHUTDOWN_CONTEXTEX contains an additional
// parameter indicating the reason for the shutdown
//

typedef struct _SHUTDOWN_CONTEXTEX {
    DWORD dwTimeout;
    BOOLEAN bForceAppsClosed;
    BOOLEAN bRebootAfterShutdown;
    DWORD dwReason; 
} SHUTDOWN_CONTEXTEX, *PSHUTDOWN_CONTEXTEX;

LONG
BaseBindToMachineShutdownInterface(
    IN LPCWSTR lpMachineName,
    IN PBIND_CALLBACK BindCallback,
    IN PVOID Context1,
    IN PVOID Context2
    );


DWORD
RegConn_nb_nb(
    IN  LPCWSTR ServerName,
    OUT RPC_BINDING_HANDLE * pBindingHandle
    );

DWORD
RegConn_nb_tcp(
    IN  LPCWSTR ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD
RegConn_nb_ipx(
    IN  LPCWSTR               ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD
RegConn_np(
    IN  LPCWSTR              ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD
RegConn_spx(
    IN  LPCWSTR              ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD RegConn_ip_tcp(
    IN  LPCWSTR  ServerName,
    OUT RPC_BINDING_HANDLE * pBindingHandle
    );

LONG
NewShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PREG_UNICODE_STRING Message,
    IN PVOID Context2
    );

LONG
NewShutdownCallbackEx(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PREG_UNICODE_STRING Message,
    IN PVOID Context2
    );

LONG
NewAbortShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PVOID Context1,
    IN PVOID Context2
    );


#endif //__REG_CONN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\regconn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by regconn.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\prflbmsg\dummy.c ===
int
DummyEntryPoint(void)
{
    return 1 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\regconn\shutcall.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    shutcall.c


Abstract:

    This module contains callbacks for RP-Calling into winlogon's
    shutdown interface

Author:

    Dragos C. Sambotin (dragoss) 21-May-1999

Notes:


Revision History:


--*/


#include <rpc.h>
#include "shutinit.h"
#include "regconn.h"


LONG
NewShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PREG_UNICODE_STRING Message,
    IN PSHUTDOWN_CONTEXT ShutdownContext
    )
/*++

Routine Description:

    New callback for binding to a machine to initiate a shutdown.
    This will call into BaseInitiateShutdown from InitShutdown interface (in winlogon),
    instead of BaseInitiateSystemShutdown from winreg interface

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

    Message - Supplies message to display during shutdown timeout period.

    ShutdownContext - Supplies remaining parameters for BaseInitiateSystemShutdown

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseInitiateShutdown((PREGISTRY_SERVER_NAME)pbinding,
                                            Message,
                                            ShutdownContext->dwTimeout,
                                            ShutdownContext->bForceAppsClosed,
                                            ShutdownContext->bRebootAfterShutdown);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}


LONG
NewShutdownCallbackEx(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PREG_UNICODE_STRING Message,
    IN PSHUTDOWN_CONTEXTEX ShutdownContext
    )
/*++

Routine Description:

    New version of callback for binding to a machine to initiate a shutdown.
    This will call BaseInitiateShutdownEx from InitShutdown interface (in winlogon)
    instead of BaseInitiateSystemShutdownEx from winreg interface

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

    Message - Supplies message to display during shutdown timeout period.

    ShutdownContext - Supplies remaining parameters for BaseInitiateSystemShutdown

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseInitiateShutdownEx((PREGISTRY_SERVER_NAME)pbinding,
                                            Message,
                                            ShutdownContext->dwTimeout,
                                            ShutdownContext->bForceAppsClosed,
                                            ShutdownContext->bRebootAfterShutdown,
                                            ShutdownContext->dwReason);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}


LONG
NewAbortShutdownCallback(
    IN RPC_BINDING_HANDLE *pbinding,
    IN PVOID Unused1,
    IN PVOID Unused2
    )
/*++

Routine Description:

    New callback for binding to a machine to abort a shutdown.
    This will call into BaseAbortShutdown in InitShutdown interface (in winlogon),
    instead of BaseAbortSystemShutdown in winreg interface

Arguments:

    pbinding - Supplies a pointer to the RPC binding context

Return Value:

    ERROR_SUCCESS if no error.

--*/

{
    DWORD Result;

    RpcTryExcept {
        Result = BaseAbortShutdown((PREGISTRY_SERVER_NAME)pbinding);
    } RpcExcept(EXCEPTION_EXECUTE_HANDLER) {
        Result = RpcExceptionCode();
    } RpcEndExcept;

    if (Result != ERROR_SUCCESS) {
        RpcBindingFree(pbinding);
    }
    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\perflib\utils.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1997   Microsoft Corporation

Module Name:

    utils.c

Abstract:

        Utility functions used by the performance library functions

Author:

    Russ Blake  11/15/91

Revision History:


--*/
#define UNICODE
//
//  Include files
//
#pragma warning(disable:4306)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <prflbmsg.h>
#include <regrpc.h>
#include "ntconreg.h"
#include "perflib.h"
#pragma warning(default:4306)

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < '0') ? INVALID : \
     (c > '9') ? INVALID : \
     DIGIT)

#define MAX_KEYWORD_LEN   (sizeof (ADDHELP_STRING) / sizeof(WCHAR))
const   WCHAR GLOBAL_STRING[]     = L"GLOBAL";
const   WCHAR FOREIGN_STRING[]    = L"FOREIGN";
const   WCHAR COSTLY_STRING[]     = L"COSTLY";
const   WCHAR COUNTER_STRING[]    = L"COUNTER";
const   WCHAR HELP_STRING[]       = L"EXPLAIN";
const   WCHAR HELP_STRING2[]      = L"HELP";
const   WCHAR ADDCOUNTER_STRING[] = L"ADDCOUNTER";
const   WCHAR ADDHELP_STRING[]    = L"ADDEXPLAIN";
const   WCHAR ONLY_STRING[]       = L"ONLY";
const   WCHAR DisablePerformanceCounters[] = L"Disable Performance Counters";

// minimum length to hold a value name understood by Perflib

const   DWORD VALUE_NAME_LENGTH = ((sizeof(COSTLY_STRING) * sizeof(WCHAR)) + sizeof(UNICODE_NULL));

#define PL_TIMER_START_EVENT    0
#define PL_TIMER_EXIT_EVENT     1
#define PL_TIMER_NUM_OBJECTS    2

static HANDLE   hTimerHandles[PL_TIMER_NUM_OBJECTS] = {NULL,NULL};

static  HANDLE  hTimerDataMutex = NULL;
static  HANDLE  hPerflibTimingThread   = NULL;
static  LPOPEN_PROC_WAIT_INFO   pTimerItemListHead = NULL;
#define PERFLIB_TIMER_INTERVAL  200     // 200 ms Timer
#define PERFLIB_TIMEOUT_COUNT    64

extern HANDLE hEventLog;

#ifdef DBG
#include <stdio.h> // for _vsnprintf
#define DEBUG_BUFFER_LENGTH MAX_PATH*2

ULONG PerfLibDebug = 0;
UCHAR PerfLibDebugBuffer[DEBUG_BUFFER_LENGTH];
#endif


//
//  Perflib functions:
//
NTSTATUS
GetPerflibKeyValue (
    LPCWSTR szItem,
    DWORD   dwRegType,
    DWORD   dwMaxSize,      // ... of pReturnBuffer in bytes
    LPVOID  pReturnBuffer,
    DWORD   dwDefaultSize,  // ... of pDefault in bytes
    LPVOID  pDefault
)
/*++

    read and return the current value of the specified value
    under the Perflib registry key. If unable to read the value
    return the default value from the argument list.

    the value is returned in the pReturnBuffer.

--*/
{

    HKEY                    hPerflibKey;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          PerflibSubKeyString;
    UNICODE_STRING          ValueNameString;
    LONG                    lReturn = STATUS_SUCCESS;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInformation, pTemp;
    ULONG                   ValueBufferLength;
    ULONG                   ResultLength;
    BOOL                    bUseDefault = TRUE;

    // initialize UNICODE_STRING structures used in this function

    RtlInitUnicodeString (
        &PerflibSubKeyString,
        (LPCWSTR)L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");

    RtlInitUnicodeString (
        &ValueNameString,
        (LPWSTR)szItem);

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //
    InitializeObjectAttributes(
            &Obja,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    Status = NtOpenKey(
                &hPerflibKey,
                KEY_READ,
                &Obja
                );

    if (NT_SUCCESS( Status )) {
        // read value of desired entry

        ValueBufferLength = ResultLength = 1024;
        pValueInformation = ALLOCMEM(ResultLength);

        if (pValueInformation != NULL) {
            while ( (Status = NtQueryValueKey(hPerflibKey,
                                            &ValueNameString,
                                            KeyValuePartialInformation,
                                            pValueInformation,
                                            ValueBufferLength,
                                            &ResultLength))
                    == STATUS_BUFFER_OVERFLOW ) {

                pTemp = pValueInformation;
                pValueInformation = REALLOCMEM(pValueInformation,
                                                        ResultLength);
                if ( pValueInformation == NULL) {
                    FREEMEM(pTemp);
                    Status = STATUS_NO_MEMORY;
                    break;
                } else {
                    ValueBufferLength = ResultLength;
                }
            }

            if (NT_SUCCESS(Status)) {
                // check to see if it's the desired type
                if (pValueInformation->Type == dwRegType) {
                    // see if it will fit
                    if (pValueInformation->DataLength <= dwMaxSize) {
                        memcpy (pReturnBuffer, &pValueInformation->Data[0],
                            pValueInformation->DataLength);
                        bUseDefault = FALSE;
                        lReturn = STATUS_SUCCESS;
                    }
                }
            } else {
                // return the default value
                lReturn = Status;
            }
            // release temp buffer
            if (pValueInformation) {
                FREEMEM (pValueInformation);
            }
        } else {
            // unable to allocate memory for this operation so
            // just return the default value
        }
        // close the registry key
        NtClose(hPerflibKey);
    } else {
        // return default value
    }

    if (bUseDefault) {
        memcpy (pReturnBuffer, pDefault, dwDefaultSize);
        lReturn = STATUS_SUCCESS;
    }

    return lReturn;
}

BOOL
MatchString (
    IN LPCWSTR lpValueArg,
    IN LPCWSTR lpNameArg
)
/*++

MatchString

    return TRUE if lpName is in lpValue.  Otherwise return FALSE

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

    IN lpName
        string for one of the keyword names

Return TRUE | FALSE

--*/
{
    BOOL    bFound      = TRUE; // assume found until contradicted
    LPWSTR  lpValue     = (LPWSTR)lpValueArg;
    LPWSTR  lpName      = (LPWSTR)lpNameArg;

    // check to the length of the shortest string

    while ((*lpValue != 0) && (*lpName != 0)) {
        if (*lpValue++ != *lpName++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    return (bFound);
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    QUERY_COUNTER
        if lpValue == pointer to "Counter" string

    QUERY_HELP
        if lpValue == pointer to "Explain" string

    QUERY_ADDCOUNTER
        if lpValue == pointer to "Addcounter" string

    QUERY_ADDHELP
        if lpValue == pointer to "Addexplain" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   LocalBuff[MAX_KEYWORD_LEN+1];
    WORD    i;

    if (lpValue == 0 || *lpValue == 0)
        return QUERY_GLOBAL;

    // convert the input string to Upper case before matching
    for (i=0; i < MAX_KEYWORD_LEN; i++) {
        if (*lpValue == TEXT(' ') || *lpValue == TEXT('\0')) {
            break;
        }
        LocalBuff[i] = *lpValue ;
        if (*lpValue >= TEXT('a') && *lpValue <= TEXT('z')) {
            LocalBuff[i]  = LocalBuff[i] - TEXT('a') + TEXT('A');
        }
        lpValue++ ;
    }
    LocalBuff[i] = TEXT('\0');

    // check for "Global" request
    if (MatchString (LocalBuff, GLOBAL_STRING))
        return QUERY_GLOBAL ;

    // check for "Foreign" request
    if (MatchString (LocalBuff, FOREIGN_STRING))
        return QUERY_FOREIGN ;

    // check for "Costly" request
    if (MatchString (LocalBuff, COSTLY_STRING))
        return QUERY_COSTLY;

    // check for "Counter" request
    if (MatchString (LocalBuff, COUNTER_STRING))
        return QUERY_COUNTER;

    // check for "Help" request
    if (MatchString (LocalBuff, HELP_STRING))
        return QUERY_HELP;

    if (MatchString (LocalBuff, HELP_STRING2))
        return QUERY_HELP;

    // check for "AddCounter" request
    if (MatchString (LocalBuff, ADDCOUNTER_STRING))
        return QUERY_ADDCOUNTER;

    // check for "AddHelp" request
    if (MatchString (LocalBuff, ADDHELP_STRING))
        return QUERY_ADDHELP;

    // None of the above, then it must be an item list
    return QUERY_ITEMS;

}

DWORD
GetNextNumberFromList (
    IN LPWSTR   szStartChar,
    IN LPWSTR   *szNextChar
)
/*++

 Reads a character string from the szStartChar to the next
 delimiting space character or the end of the string and returns
 the value of the decimal number found. If no valid number is found
 then 0 is returned. The pointer to the next character in the
 string is returned in the szNextChar parameter. If the character
 referenced by this pointer is 0, then the end of the string has
 been reached.

--*/
{
    DWORD   dwThisNumber    = 0;
    WCHAR   *pwcThisChar    = szStartChar;
    WCHAR   wcDelimiter     = L' ';
    BOOL    bValidNumber    = FALSE;

    if (szStartChar != 0) {
        do {
            switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
                case DIGIT:
                    // if this is the first digit after a delimiter, then
                    // set flags to start computing the new number
                    bValidNumber = TRUE;
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                    break;

                case DELIMITER:
                    // a delimter is either the delimiter character or the
                    // end of the string ('\0') if when the delimiter has been
                    // reached a valid number was found, then return it
                    //
                    if (bValidNumber || (*pwcThisChar == 0)) {
                        *szNextChar = pwcThisChar;
                        return dwThisNumber;
                    } else {
                        // continue until a non-delimiter char or the
                        // end of the file is found
                    }
                    break;

                case INVALID:
                    // if an invalid character was encountered, ignore all
                    // characters up to the next delimiter and then start fresh.
                    // the invalid number is not compared.
                    bValidNumber = FALSE;
                    break;

                default:
                    break;

            }
            pwcThisChar++;
        } while (pwcThisChar != NULL);    // always TRUE - avoid W4 warning
        return 0;
    } else {
        *szNextChar = szStartChar;
        return 0;
    }
}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;

    while (*pwcThisChar != 0) {
        dwThisNumber = GetNextNumberFromList (
            pwcThisChar, &pwcThisChar);
        if (dwNumber == dwThisNumber) return TRUE;
    }
    // if here, then the number wasn't found
    return FALSE;

}   // IsNumberInUnicodeList

BOOL
MonBuildPerfDataBlock(
    PERF_DATA_BLOCK *pBuffer,
    PVOID *pBufferNext,
    DWORD NumObjectTypes,
    DWORD DefaultObject
)
/*++

    MonBuildPerfDataBlock -     build the PERF_DATA_BLOCK structure

        Inputs:

            pBuffer         -   where the data block should be placed

            pBufferNext     -   where pointer to next byte of data block
                                is to begin; DWORD aligned

            NumObjectTypes  -   number of types of objects being reported

            DefaultObject   -   object to display by default when
                                this system is selected; this is the
                                object type title index
--*/

{
    // Initialize Signature and version ID for this data structure

    pBuffer->Signature[0] = L'P';
    pBuffer->Signature[1] = L'E';
    pBuffer->Signature[2] = L'R';
    pBuffer->Signature[3] = L'F';

    pBuffer->LittleEndian = TRUE;

    pBuffer->Version = PERF_DATA_VERSION;
    pBuffer->Revision = PERF_DATA_REVISION;

    //
    //  The next field will be filled in at the end when the length
    //  of the return data is known
    //

    pBuffer->TotalByteLength = 0;

    pBuffer->NumObjectTypes = NumObjectTypes;
    pBuffer->DefaultObject = DefaultObject;
    GetSystemTime(&pBuffer->SystemTime);
    NtQueryPerformanceCounter(&pBuffer->PerfTime,&pBuffer->PerfFreq);
    GetSystemTimeAsFileTime ((FILETIME *)&pBuffer->PerfTime100nSec.QuadPart);

    if ( ComputerNameLength ) {

        //  There is a Computer name: i.e., the network is installed

        pBuffer->SystemNameLength = ComputerNameLength;
        pBuffer->SystemNameOffset = sizeof(PERF_DATA_BLOCK);
        RtlMoveMemory(&pBuffer[1],
               pComputerName,
               ComputerNameLength);
        *pBufferNext = (PVOID) ((PCHAR) &pBuffer[1] +
                                QWORD_MULTIPLE(ComputerNameLength));
        pBuffer->HeaderLength = (DWORD)((PCHAR) *pBufferNext - (PCHAR) pBuffer);
    } else {

        // Member of Computers Anonymous

        pBuffer->SystemNameLength = 0;
        pBuffer->SystemNameOffset = 0;
        *pBufferNext = &pBuffer[1];
        pBuffer->HeaderLength = sizeof(PERF_DATA_BLOCK);
    }

    return 0;
}

//
// Timer functions
//
DWORD
PerflibTimerFunction (
    LPDWORD dwArg
)
/*++

 PerflibTimerFunction

    Timing thread used to write an event log message if the timer expires.

    This thread runs until the Exit event is set or the wait for the
    Exit event times out.

    While the start event is set, then the timer checks the current events
    to be timed and reports on any that have expired. It then sleeps for
    the duration of the timing interval after which it checks the status
    of the start & exit events to begin the next cycle.

    The timing events are added and deleted from the list only by the
    StartPerflibFunctionTimer and KillPerflibFunctionTimer functions.

 Arguments

    dwArg -- Not Used

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    BOOL                    bKeepTiming = TRUE;
    LPOPEN_PROC_WAIT_INFO   pLocalInfo;
    LPWSTR                  szMessageArray[2];
    LARGE_INTEGER           liWaitTime;

    UNREFERENCED_PARAMETER (dwArg);

//    KdPrint (("\nPERFLIB: Entering Timing Thread: PID: %d, TID: %d", 
//        GetCurrentProcessId(), GetCurrentThreadId()));

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& PerflibGuid,
           __LINE__,
           PERF_TIMERFUNCTION,
           0,
           STATUS_SUCCESS,
           NULL));

    while (bKeepTiming) {
        liWaitTime.QuadPart =
            MakeTimeOutValue((PERFLIB_TIMING_THREAD_TIMEOUT));
        // wait for either the start or exit event flags to be set
        NtStatus = NtWaitForMultipleObjects (
                PL_TIMER_NUM_OBJECTS,
                &hTimerHandles[0],
                WaitAny,          //wait for either one to be set
                FALSE,            // not alertable
                &liWaitTime);

        if ((NtStatus != STATUS_TIMEOUT) &&
            (NtStatus <= STATUS_WAIT_3)) {
            if ((NtStatus - STATUS_WAIT_0) == PL_TIMER_EXIT_EVENT ) {
//              KdPrint (("\nPERFLIB: Timing Thread received Exit Event (1): PID: %d, TID: %d", 
//                    GetCurrentProcessId(), GetCurrentThreadId()));

                // then that's all
                bKeepTiming = FALSE;
                NtStatus = STATUS_SUCCESS;
                break;
            } else if ((NtStatus - STATUS_WAIT_0) == PL_TIMER_START_EVENT) {
//                KdPrint (("\nPERFLIB: Timing Thread received Start Event: PID: %d, TID: %d", 
//                    GetCurrentProcessId(), GetCurrentThreadId()));
                // then the timer is running so wait the interval period
                // wait on exit event here to prevent hanging
                liWaitTime.QuadPart =
                    MakeTimeOutValue((PERFLIB_TIMER_INTERVAL));
                NtStatus = NtWaitForSingleObject (
                        hTimerHandles[PL_TIMER_EXIT_EVENT],
                        FALSE,
                        &liWaitTime);

                if (NtStatus == STATUS_TIMEOUT) {
                    // then the wait time expired without being told
                    // to terminate the thread so
                    // now evaluate the list of timed events
                    // lock the data mutex
                    DWORD dwTimeOut = 0;

//                    KdPrint (("\nPERFLIB: Timing Thread Evaluating Entries: PID: %d, TID: %d", 
//                        GetCurrentProcessId(), GetCurrentThreadId()));

                    liWaitTime.QuadPart =
                        MakeTimeOutValue((PERFLIB_TIMER_INTERVAL * 2));

                    NtStatus = STATUS_TIMEOUT;
                    while (   NtStatus == STATUS_TIMEOUT
                           && dwTimeOut < PERFLIB_TIMEOUT_COUNT) {
                        NtStatus = NtWaitForSingleObject (
                                hTimerDataMutex,
                                FALSE,
                                & liWaitTime);
                        if (NtStatus == STATUS_TIMEOUT) {
                            dwTimeOut ++;
                            DebugPrint((2, "\nPERFLIB:NtWaitForSingleObject(TimerDataMutex,%d) time out for the %dth time. PID: %d, TID: %d",
                                    liWaitTime, dwTimeOut,
                                    GetCurrentProcessId(),
                                    GetCurrentThreadId()));
                            TRACE((WINPERF_DBG_TRACE_WARNING),
                                  (& PerflibGuid,
                                   __LINE__,
                                   PERF_TIMERFUNCTION,
                                   0,
                                   STATUS_TIMEOUT,
                                   & dwTimeOut, sizeof(dwTimeOut),
                                   NULL));
                        }
                    }

                    if (NtStatus != STATUS_WAIT_0) {
                        // cannot grab hTimerDataMutex, there is no guarantee
                        // that this is the exclusive one to work on
                        // pTimerItemListHead list, so just bail out.
                        //
                        bKeepTiming = FALSE;
                        NtStatus    = STATUS_SUCCESS;
                        TRACE((WINPERF_DBG_TRACE_WARNING),
                              (& PerflibGuid,
                               __LINE__,
                               PERF_TIMERFUNCTION,
                               0,
                               NtStatus,
                               NULL));
                        break;
                    }
                    else {
                        for (pLocalInfo = pTimerItemListHead;
                            pLocalInfo != NULL;
                            pLocalInfo = pLocalInfo->pNext) {

//                              KdPrint (("\nPERFLIB: Timing Thread Entry %d. count %d: PID: %d, TID: %d", 
//                              (DWORD)pLocalInfo, pLocalInfo->dwWaitTime,
//                              GetCurrentProcessId(), GetCurrentThreadId()));

                            if (pLocalInfo->dwWaitTime > 0) {
                                if (pLocalInfo->dwWaitTime == 1) {
                                    // then this is the last interval so log error
                                    // if this DLL hasn't already been disabled

                                    szMessageArray[0] = pLocalInfo->szServiceName;
                                    szMessageArray[1] = pLocalInfo->szLibraryName;

                                    ReportEvent (hEventLog,
                                        EVENTLOG_ERROR_TYPE,  // error type
                                        0,                    // category (not used)
                                        (DWORD)pLocalInfo->dwEventMsg, // event,
                                        NULL,                 // SID (not used),
                                        2,                    // number of strings
                                        0,                    // sizeof raw data
                                        szMessageArray,       // message text array
                                        NULL);                // raw data

                                    if (pLocalInfo->pData != NULL) {
                                        if (lPerflibConfigFlags & PLCF_ENABLE_TIMEOUT_DISABLE) {
                                            if (!(((PEXT_OBJECT)pLocalInfo->pData)->dwFlags & PERF_EO_DISABLED)) {
                                                // then pData is an extensible counter data block
                                                // disable the ext. counter
                                                DisablePerfLibrary ((PEXT_OBJECT)pLocalInfo->pData);
                                            } // end if not already disabled
                                        } // end if disable DLL on Timeouts is enabled
                                    } // data is NULL so skip
                                } 
                                pLocalInfo->dwWaitTime--;
                            }
                        }
                        ReleaseMutex (hTimerDataMutex);
                    }
                } else {
//                  KdPrint (("\nPERFLIB: Timing Thread received Exit Event (2): PID: %d, TID: %d", 
//                     GetCurrentProcessId(), GetCurrentThreadId()));

                    // we've been told to exit so
                    NtStatus = STATUS_SUCCESS;
                    bKeepTiming = FALSE;
                    break;
                }
            } else {
                // some unexpected error was returned
                assert (FALSE);
            }
        } else {
//            KdPrint (("\nPERFLIB: Timing Thread Timed out: PID: %d, TID: %d", 
//                GetCurrentProcessId(), GetCurrentThreadId()));
            // the wait timed out so it's time to go
            NtStatus = STATUS_SUCCESS;
            bKeepTiming = FALSE;
            break;
        }
    }

//    KdPrint (("\nPERFLIB: Leaving Timing Thread: PID: %d, TID: %d", 
//        GetCurrentProcessId(), GetCurrentThreadId()));

    return PerfpDosError(NtStatus);
}

HANDLE
StartPerflibFunctionTimer (
    IN  LPOPEN_PROC_WAIT_INFO pInfo
)
/*++

    Starts a timing event by adding it to the list of timing events.
    If the timer thread is not running, then the is started as well.

    If this is the first event in the list then the Start Event is
    set indicating that the timing thread can begin processing timing
    event(s).

--*/
{
    LONG    Status = ERROR_SUCCESS;
    LPOPEN_PROC_WAIT_INFO   pLocalInfo = NULL;
    DWORD   dwLibNameLen = 0;
    DWORD   dwBufferLength = sizeof (OPEN_PROC_WAIT_INFO);
    LARGE_INTEGER   liWaitTime;
    HANDLE  hReturn = NULL;
    HANDLE  hDataMutex;

    if (pInfo == NULL) {
        // no required argument
        Status = ERROR_INVALID_PARAMETER;
    } else {
        // check on or create sync objects

        // allocate timing events for the timing thread
        if (hTimerHandles[PL_TIMER_START_EVENT] == NULL) {
            // create the event as NOT signaled since we're not ready to start
            hTimerHandles[PL_TIMER_START_EVENT] = CreateEvent (NULL, TRUE, FALSE, NULL);
            if (hTimerHandles[PL_TIMER_START_EVENT] == NULL) {
                Status = GetLastError();
            }
        }

        if (hTimerHandles[PL_TIMER_EXIT_EVENT] == NULL) {
            hTimerHandles[PL_TIMER_EXIT_EVENT] = CreateEvent (NULL, TRUE, FALSE, NULL);
            if (hTimerHandles[PL_TIMER_EXIT_EVENT] == NULL) {
            Status = GetLastError();
            }
        }

        // create data sync mutex if it hasn't already been created
        if (hTimerDataMutex  == NULL) {
            hDataMutex = CreateMutex(NULL, FALSE, NULL);
            if (hDataMutex == NULL) {
                Status = GetLastError();
            }
            else {
                if (InterlockedCompareExchangePointer(& hTimerDataMutex,
                        hDataMutex,
                        NULL) != NULL) {
                    CloseHandle(hDataMutex);
                    hDataMutex = NULL;
                }
                else {
                    hTimerDataMutex = hDataMutex;
                }
            }
        }
    }

    if (Status == ERROR_SUCCESS) {
        // continue creating timer entry
        if (hPerflibTimingThread != NULL) {
    	    // see if the handle is valid (i.e the thread is alive)
            Status = WaitForSingleObject (hPerflibTimingThread, 0);
    	    if (Status == WAIT_OBJECT_0) {
                // the thread has terminated so close the handle
                CloseHandle (hPerflibTimingThread);
    	        hPerflibTimingThread = NULL;
    	        Status = ERROR_SUCCESS;
    	    } else if (Status == WAIT_TIMEOUT) {
		// the thread is still running so continue
		Status = ERROR_SUCCESS;
    	    } else {
		// some other, probably serious, error
		// so pass it on through
	    }
        } else {
	        // the thread has never been created yet so continue
        }

        if (hPerflibTimingThread == NULL) {
            // create the timing thread

            assert (pTimerItemListHead == NULL);    // there should be no entries, yet

            // everything is ready for the timer thread

            hPerflibTimingThread = CreateThread (
                NULL, 0,
                (LPTHREAD_START_ROUTINE)PerflibTimerFunction,
                NULL, 0, NULL);

            assert (hPerflibTimingThread != NULL);
            if (hPerflibTimingThread == NULL) {
                Status = GetLastError();
            }
        }

        if (Status == ERROR_SUCCESS) {

            // compute the length of the required buffer;

            dwLibNameLen = (lstrlenW (pInfo->szLibraryName) + 1) * sizeof(WCHAR);
            dwBufferLength += dwLibNameLen;
            dwBufferLength += (lstrlenW (pInfo->szServiceName) + 1) * sizeof(WCHAR);
            dwBufferLength = QWORD_MULTIPLE (dwBufferLength);

            pLocalInfo = ALLOCMEM (dwBufferLength);
            if (pLocalInfo == NULL)
                Status = ERROR_OUTOFMEMORY;
        }
        if ((Status == ERROR_SUCCESS) && (pLocalInfo != NULL)) {

            // copy the arg buffer to the local list

            pLocalInfo->szLibraryName = (LPWSTR)&pLocalInfo[1];
            lstrcpyW (pLocalInfo->szLibraryName, pInfo->szLibraryName);
            pLocalInfo->szServiceName = (LPWSTR)
                ((LPBYTE)pLocalInfo->szLibraryName + dwLibNameLen);
            lstrcpyW (pLocalInfo->szServiceName, pInfo->szServiceName);
            // convert wait time in milliseconds to the number of "loops"
            pLocalInfo->dwWaitTime = pInfo->dwWaitTime / PERFLIB_TIMER_INTERVAL;
            if (pLocalInfo->dwWaitTime  == 0) pLocalInfo->dwWaitTime =1; // have at least 1 loop
            pLocalInfo->dwEventMsg = pInfo->dwEventMsg;
            pLocalInfo->pData = pInfo->pData;

            // wait for access to the data
            if (hTimerDataMutex != NULL) {
                NTSTATUS NtStatus;
                liWaitTime.QuadPart =
                    MakeTimeOutValue((PERFLIB_TIMER_INTERVAL * 2));

                NtStatus = NtWaitForSingleObject (
                    hTimerDataMutex,
                    FALSE,
                    &liWaitTime);
                Status = PerfpDosError(NtStatus);
            } else {
                Status = ERROR_NOT_READY;
            }

            if (Status == WAIT_OBJECT_0) {
//                KdPrint (("\nPERFLIB: Timing Thread Adding Entry: %d (%d) PID: %d, TID: %d", 
//                    (DWORD)pLocalInfo, pLocalInfo->dwWaitTime,
//                    GetCurrentProcessId(), GetCurrentThreadId()));

                // we have access to the data so add this item to the front of the list
                pLocalInfo->pNext = pTimerItemListHead;
                pTimerItemListHead = pLocalInfo;
                ReleaseMutex (hTimerDataMutex);

                if (pLocalInfo->pNext == NULL) {
                    // then the list was empty before this call so start the timer
                    // going
                    SetEvent (hTimerHandles[PL_TIMER_START_EVENT]);
                }

                hReturn = (HANDLE)pLocalInfo;
            } else {
                SetLastError (Status);
            }
        } else {
            // unable to create thread
            SetLastError (Status);
        }
    } else {
        // unable to start timer
        SetLastError (Status);
    }

    return hReturn;
}

DWORD
KillPerflibFunctionTimer (
    IN  HANDLE  hPerflibTimer
)
/*++

    Terminates a timing event by removing it from the list. When the last
    item is removed from the list the Start event is reset so the timing
    thread will wait for either the next start event, exit event or it's
    timeout to expire.

--*/
{
    NTSTATUS Status;
    LPOPEN_PROC_WAIT_INFO   pArg = (LPOPEN_PROC_WAIT_INFO)hPerflibTimer;
    LPOPEN_PROC_WAIT_INFO   pLocalInfo;
    BOOL                    bFound = FALSE;
    LARGE_INTEGER           liWaitTime;
    DWORD   dwReturn = ERROR_SUCCESS;

    if (hTimerDataMutex == NULL) {
        dwReturn = ERROR_NOT_READY;
    } else if (pArg == NULL) {
        dwReturn = ERROR_INVALID_HANDLE;
    } else {
	// so far so good
        // wait for access to the data
        liWaitTime.QuadPart =
            MakeTimeOutValue((PERFLIB_TIMER_INTERVAL * 2));
        Status = NtWaitForSingleObject (
            hTimerDataMutex,
            FALSE,
            &liWaitTime);

        if (Status == STATUS_WAIT_0) {
            // we have access to the list so walk down the list and remove the
            // specified item
            // see if it's the first one in the list

//            KdPrint (("\nPERFLIB: Timing Thread Removing Entry: %d (%d) PID: %d, TID: %d", 
//                (DWORD)pArg, pArg->dwWaitTime,
//                GetCurrentProcessId(), GetCurrentThreadId()));

            if (pArg == pTimerItemListHead) {
                // then remove it
                pTimerItemListHead = pArg->pNext;
                bFound = TRUE;
            } else {
                for (pLocalInfo = pTimerItemListHead;
                    pLocalInfo != NULL;
                    pLocalInfo = pLocalInfo->pNext) {
                    if (pLocalInfo->pNext == pArg) {
                        pLocalInfo->pNext = pArg->pNext;
                        bFound = TRUE;
                        break;
                    }
                }
            }
            assert (bFound);

            if (bFound) {
                // it's out of the list so release the lock
                ReleaseMutex (hTimerDataMutex);

                if (pTimerItemListHead == NULL) {
                    // then the list is empty now so stop timing
                    // going
                    ResetEvent (hTimerHandles[PL_TIMER_START_EVENT]);
                }

                // free memory

                FREEMEM (pArg);
                dwReturn = ERROR_SUCCESS;
            } else {
                dwReturn = ERROR_NOT_FOUND;
            }
        } else {
            dwReturn = ERROR_TIMEOUT;
        }
    }

    return dwReturn;
}

DWORD
DestroyPerflibFunctionTimer (
)
/*++

    Terminates the timing thread and cancels any current timer events.
    NOTE: This routine can be called even if timer thread is not started!

--*/
{
    NTSTATUS    Status   = STATUS_WAIT_0;
    LPOPEN_PROC_WAIT_INFO   pThisItem;
    LPOPEN_PROC_WAIT_INFO   pNextItem;
    LARGE_INTEGER           liWaitTime;
    HANDLE hTemp;

    if (hTimerDataMutex != NULL) {
        DWORD  dwTimeOut = 0;
        LONG   dwStatus  = ERROR_SUCCESS;

        // wait for data mutex
        liWaitTime.QuadPart =
            MakeTimeOutValue((PERFLIB_TIMER_INTERVAL * 5));

        Status = STATUS_TIMEOUT;
        while (Status == STATUS_TIMEOUT && dwTimeOut < PERFLIB_TIMEOUT_COUNT) {
            Status = NtWaitForSingleObject (
                    hTimerDataMutex,
                    FALSE,
                    & liWaitTime);
            if (Status == STATUS_TIMEOUT) {
                if (hPerflibTimingThread != NULL) {
                    // see if the handle is valid (i.e the thread is alive)
                    dwStatus = WaitForSingleObject(hPerflibTimingThread,
                                                   liWaitTime.LowPart);
                    if (dwStatus == WAIT_OBJECT_0) {
                        // the thread has terminated so close the handle
                        Status = STATUS_WAIT_0;
                    }
                }
            }
            if (Status == STATUS_TIMEOUT) {
                dwTimeOut ++;
                DebugPrint((2, "\nPERFLIB:NtWaitForSingleObject(TimerDataMutex,%d) time out for the %dth time in DestroyPErflibFunctionTimer(). PID: %d, TID: %d",
                        liWaitTime, dwTimeOut,
                        GetCurrentProcessId(),
                        GetCurrentThreadId()));
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (& PerflibGuid,
                       __LINE__,
                       PERF_DESTROYFUNCTIONTIMER,
                       0,
                       STATUS_TIMEOUT,
                       & dwTimeOut, sizeof(dwTimeOut),
                       NULL));
            }
        }

        assert (Status != STATUS_TIMEOUT);
    }

    // free all entries in the list

    if (Status == STATUS_WAIT_0) {
        for (pNextItem = pTimerItemListHead;
            pNextItem != NULL;) {
            pThisItem = pNextItem;
            pNextItem = pThisItem->pNext;
            FREEMEM (pThisItem);
        }
    }
    else {
        TRACE((WINPERF_DBG_TRACE_WARNING),
              (& PerflibGuid,
               __LINE__,
               PERF_DESTROYFUNCTIONTIMER,
               0,
               Status,
               NULL));
    }
    // all items have been freed so clear header
    pTimerItemListHead = NULL;

    // set exit event
    if (hTimerHandles[PL_TIMER_EXIT_EVENT] != NULL) {
        SetEvent (hTimerHandles[PL_TIMER_EXIT_EVENT]);
    }

    if (hPerflibTimingThread != NULL) {
        // wait for thread to terminate
        liWaitTime.QuadPart =
            MakeTimeOutValue((PERFLIB_TIMER_INTERVAL * 5));

        Status = NtWaitForSingleObject (
            hPerflibTimingThread,
            FALSE,
            &liWaitTime);

        assert (Status != STATUS_TIMEOUT);

        hTemp = hPerflibTimingThread;
	    hPerflibTimingThread = NULL;
    	CloseHandle (hTemp);
    }

    if (hTimerDataMutex != NULL) {
        hTemp = hTimerDataMutex;
        hTimerDataMutex = NULL;
        // close handles and leave
    	ReleaseMutex (hTemp);
        CloseHandle (hTemp);
    }

    if (hTimerHandles[PL_TIMER_START_EVENT] != NULL) {
        CloseHandle (hTimerHandles[PL_TIMER_START_EVENT]);
        hTimerHandles[PL_TIMER_START_EVENT] = NULL;
    }

    if (hTimerHandles[PL_TIMER_EXIT_EVENT] != NULL) {
        CloseHandle (hTimerHandles[PL_TIMER_EXIT_EVENT]);
        hTimerHandles[PL_TIMER_EXIT_EVENT] = NULL;
    }

    return ERROR_SUCCESS;
}

LONG
PrivateRegQueryValueExT (
    HKEY    hKey,
    LPVOID  lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData,
    BOOL    bUnicode
)
/*
    wrapper function to allow RegQueryValues while inside a RegQueryValue

*/
{
    LONG    ReturnStatus;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
	BOOL	bStatus;

    UNICODE_STRING      usLocal = {0,0,NULL};
    PSTR                AnsiValueBuffer;
    ULONG               AnsiValueLength;
    PWSTR               UnicodeValueBuffer;
    ULONG               UnicodeValueLength;
    ULONG               Index;

    PKEY_VALUE_PARTIAL_INFORMATION  pValueInformation;
    LONG                    ValueBufferLength;
    ULONG                   ResultLength;


    UNREFERENCED_PARAMETER (lpReserved);

    if (bUnicode) {
        bStatus = RtlCreateUnicodeString (&usLocal, (LPCWSTR)lpValueName);
    } else {
        bStatus = RtlCreateUnicodeStringFromAsciiz (&usLocal, (LPCSTR)lpValueName);
    }

    if (bStatus) {

        ValueBufferLength =
		ResultLength =
			sizeof(KEY_VALUE_PARTIAL_INFORMATION) + *lpcbData;
        pValueInformation = ALLOCMEM(ResultLength);

        if (pValueInformation != NULL) {
            ntStatus = NtQueryValueKey(
                hKey,
                &usLocal,
                KeyValuePartialInformation,
                pValueInformation,
                ValueBufferLength,
                &ResultLength);

            if ((NT_SUCCESS(ntStatus) || ntStatus == STATUS_BUFFER_OVERFLOW)) {
                // return data
                if (ARGUMENT_PRESENT(lpType)) {
                    *lpType = pValueInformation->Type;
                }

                if (ARGUMENT_PRESENT(lpcbData)) {
                    *lpcbData = pValueInformation->DataLength;
                }

                if (NT_SUCCESS(ntStatus)) {
                    if (ARGUMENT_PRESENT(lpData)) {
                        if (!bUnicode &&
                            (pValueInformation->Type == REG_SZ ||
                            pValueInformation->Type == REG_EXPAND_SZ ||
                            pValueInformation->Type == REG_MULTI_SZ)
                        ) {
                            // then convert the unicode return to an
                            // ANSI string before returning
                            // the local wide buffer used

                            UnicodeValueLength  = ResultLength;
                            UnicodeValueBuffer  = (LPWSTR)&pValueInformation->Data[0];

                            AnsiValueBuffer = (LPSTR)lpData;
                            AnsiValueLength = ARGUMENT_PRESENT( lpcbData )?
                                                     *lpcbData : 0;
                            Index = 0;
                            ntStatus = RtlUnicodeToMultiByteN(
                                AnsiValueBuffer,
                                AnsiValueLength,
                                &Index,
                                UnicodeValueBuffer,
                                UnicodeValueLength);

                            if (NT_SUCCESS( ntStatus ) &&
                                (ARGUMENT_PRESENT( lpcbData ))) {
                                *lpcbData = Index;
                            }
                        } else {
                            if (pValueInformation->DataLength <= *lpcbData) {
                                // copy the buffer to the user's buffer
                                memcpy (lpData, &pValueInformation->Data[0],
                                    pValueInformation->DataLength);
                                ntStatus = STATUS_SUCCESS;
                             } else {
                                 ntStatus = STATUS_BUFFER_OVERFLOW;
                             }
                             *lpcbData = pValueInformation->DataLength;
                        }
                    }
                }
            }

            if (pValueInformation != NULL) {
                // release temp buffer
                FREEMEM (pValueInformation);
            }
        } else {
            // unable to allocate memory for this operation so
            ntStatus = STATUS_NO_MEMORY;
        }

        RtlFreeUnicodeString (&usLocal);
    } else {
		// this is a guess at the most likely cause for the string
		// creation to fail.
		ntStatus = STATUS_NO_MEMORY;
	}

    ReturnStatus = PerfpDosError(ntStatus);

    return ReturnStatus;
}

LONG
GetPerfDllFileInfo (
    LPCWSTR             szFileName,
    PDLL_VALIDATION_DATA  pDllData
)
{
    WCHAR   szFullPath[MAX_PATH*2];
    DWORD   dwStatus = ERROR_FILE_NOT_FOUND;
    DWORD   dwRetValue;
    HANDLE  hFile;
    BOOL    bStatus;
    LARGE_INTEGER   liSize;

    dwRetValue = SearchPathW (
        NULL,
        szFileName,
        NULL,
        sizeof(szFullPath) / sizeof(szFullPath[0]),
        szFullPath,
        NULL);

    if (dwRetValue > 0) {
        //then the file was found so open it.
        hFile = CreateFileW (
            szFullPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL, 
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            // get file creation date/time
            bStatus = GetFileTime (
                hFile,
                &pDllData->CreationDate,
                NULL, NULL);
            if (bStatus)  {
                // get file size
                liSize.LowPart  =  GetFileSize (
                    hFile, (PULONG)&liSize.HighPart);
                if (liSize.LowPart != 0xFFFFFFFF) {
                    pDllData->FileSize = liSize.QuadPart;
                    dwStatus = ERROR_SUCCESS;
                } else {
                    dwStatus = GetLastError();
                }
            } else {
                dwStatus = GetLastError();
            } 

            CloseHandle (hFile);
        } else {
            dwStatus = GetLastError();
        }
    } else {
        dwStatus = GetLastError();
    }

    return dwStatus;
}

DWORD
DisablePerfLibrary (
    PEXT_OBJECT  pObj
)
{
    // continue only if the "Disable" feature is enabled and
    // if this library hasn't already been disabled.
    if ((!(lPerflibConfigFlags & PLCF_NO_DISABLE_DLLS)) &&
        (!(pObj->dwFlags & PERF_EO_DISABLED))) {

        // set the disabled bit in the info
        pObj->dwFlags |= PERF_EO_DISABLED;
        return DisableLibrary(pObj->hPerfKey, pObj->szServiceName);
    }
    return ERROR_SUCCESS;
}


DWORD
DisableLibrary(
    IN HKEY hPerfKey,
    IN LPWSTR szServiceName
    )
{
    //
    // This routine will disable regardless of settings
    //
    DWORD   dwValue, dwSize;
    DWORD   dwFnStatus = ERROR_SUCCESS;
    WORD    wStringIndex = 0;
    LPWSTR  szMessageArray[2];

    // disable perf library entry in the service key
    dwSize = sizeof(dwValue);
    dwValue = 1;
    dwFnStatus = RegSetValueExW (
            hPerfKey,
            DisablePerformanceCounters,
            0L,
            REG_DWORD,
            (LPBYTE)&dwValue,
            dwSize);
        // report error

    if (dwFnStatus == ERROR_SUCCESS) {
        // system disabled
        szMessageArray[wStringIndex++] =
            szServiceName;

        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,        // error type
            0,                          // category (not used)
            (DWORD)PERFLIB_LIBRARY_DISABLED,              // event,
            NULL,                       // SID (not used),
            wStringIndex,               // number of strings
            0,                          // sizeof raw data
            szMessageArray,             // message text array
            NULL);                      // raw data
    } else {
        // local disable only
        szMessageArray[wStringIndex++] =
            szServiceName;

        ReportEvent (hEventLog,
            EVENTLOG_ERROR_TYPE,        // error type
            0,                          // category (not used)
            (DWORD)PERFLIB_LIBRARY_TEMP_DISABLED,              // event,
            NULL,                       // SID (not used),
            wStringIndex,               // number of strings
            0,                          // sizeof raw data
            szMessageArray,             // message text array
            NULL);                      // raw data
    }
    return ERROR_SUCCESS;
}

DWORD
PerfUpdateErrorCount(
    PEXT_OBJECT pObj,
    DWORD ErrorCount
    )
{
    DWORD Status;
    DWORD dwErrorCount, dwType, dwSize;

    dwErrorCount = 0;
    if (ErrorCount == 0) {  // reset to 0
        RegDeleteValueW(pObj->hPerfKey, cszFailureCount);
        return 0;
    }
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    Status = PrivateRegQueryValueExW(
                pObj->hPerfKey,
                cszFailureCount,
                NULL,
                &dwType,
                (LPBYTE)&dwErrorCount,
                &dwSize);
    if (Status != ERROR_SUCCESS)
        dwErrorCount = 0;

    dwErrorCount += ErrorCount;
    dwSize = sizeof(DWORD);
    Status = RegSetValueExW(
                pObj->hPerfKey,
                cszFailureCount,
                0L,
                REG_DWORD,
                (LPBYTE)&dwErrorCount,
                dwSize);

    if ((dwErrorCount >= pObj->dwErrorLimit) &&
        (pObj->dwErrorLimit != 0)) {
        DisablePerfLibrary(pObj);
    }
    if (dwErrorCount < 100)
        return dwErrorCount;
    ErrorCount = dwErrorCount % 100;
    if (ErrorCount > 10)
        return 0;
    return ErrorCount;
}

DWORD
PerfCheckRegistry(
    IN HKEY hPerfKey,
    IN LPCWSTR szServiceName
    )
{
    DWORD dwType = 0;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwData = 0;
    DWORD status;
    WORD  wStringIndex;
    LPWSTR szMessageArray[2];

    status = PrivateRegQueryValueExA(
                hPerfKey,
                FirstCounter,
                NULL,
                &dwType,
                (LPBYTE)&dwData,
                &dwSize);

    if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD) ||
        (dwData < LAST_BASE_INDEX)) {
        wStringIndex = 0;
        szMessageArray[wStringIndex++] = (LPWSTR) FirstCounter;
        szMessageArray[wStringIndex++] = (LPWSTR) szServiceName;
        ReportEvent(hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            (DWORD)PERFLIB_REGVALUE_NOT_FOUND,
            NULL,
            wStringIndex,
            0,
            szMessageArray,
            NULL);
        return FALSE;
    }

    status = PrivateRegQueryValueExA(
                hPerfKey,
                LastCounter,
                NULL,
                &dwType,
                (LPBYTE)&dwData,
                &dwSize);

    if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD) ||
        (dwData <= LAST_BASE_INDEX)) {
        wStringIndex = 0;
        szMessageArray[wStringIndex++] = (LPWSTR) LastCounter;
        szMessageArray[wStringIndex++] = (LPWSTR) szServiceName;
        ReportEvent(hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            (DWORD)PERFLIB_REGVALUE_NOT_FOUND,
            NULL,
            wStringIndex,
            0,
            szMessageArray,
            NULL);
        return FALSE;
    }

    status = PrivateRegQueryValueExA(
                hPerfKey,
                FirstHelp,
                NULL,
                &dwType,
                (LPBYTE)&dwData,
                &dwSize);

    if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD) ||
        (dwData < LAST_BASE_INDEX)) {
        wStringIndex = 0;
        szMessageArray[wStringIndex++] = (LPWSTR) FirstHelp;
        szMessageArray[wStringIndex++] = (LPWSTR) szServiceName;
        ReportEvent(hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            (DWORD)PERFLIB_REGVALUE_NOT_FOUND,
            NULL,
            wStringIndex,
            0,
            szMessageArray,
            NULL);
        return FALSE;
    }

    status = PrivateRegQueryValueExA(
                hPerfKey,
                LastHelp,
                NULL,
                &dwType,
                (LPBYTE)&dwData,
                &dwSize);

    if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD) ||
        (dwData <= LAST_BASE_INDEX)) {
        wStringIndex = 0;
        szMessageArray[wStringIndex++] = (LPWSTR) LastHelp;
        szMessageArray[wStringIndex++] = (LPWSTR) szServiceName;
        ReportEvent(hEventLog,
            EVENTLOG_ERROR_TYPE,
            0,
            (DWORD)PERFLIB_REGVALUE_NOT_FOUND,
            NULL,
            wStringIndex,
            0,
            szMessageArray,
            NULL);
        return FALSE;
    }

    return TRUE;
}

DWORD
PerfpDosError(
    IN NTSTATUS Status
    )
// Need to convert NtStatus that we generate to DosError
{
    if (Status == STATUS_SUCCESS)
        return ERROR_SUCCESS;
    if (Status == STATUS_BUFFER_OVERFLOW)
        return ERROR_MORE_DATA;
    if (Status == STATUS_TIMEOUT)
        return WAIT_TIMEOUT;
    if (Status <= STATUS_WAIT_63)
        return (DWORD) Status;
    return RtlNtStatusToDosError(Status);
}

#ifdef DBG
VOID
PerfpDebug(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all Perflib

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    if ((DebugPrintLevel <= (PerfLibDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & PerfLibDebug)) {
        DbgPrint("%d:Perflib:", GetCurrentThreadId());
    }
    else
        return;

    va_start(ap, DebugMessage);


    if ((DebugPrintLevel <= (PerfLibDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & PerfLibDebug)) {

        _vsnprintf(
            (LPSTR)PerfLibDebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        DbgPrint((LPSTR)PerfLibDebugBuffer);
    }

    va_end(ap);

}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\regconn\regbind.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    regbind.c

Abstract:

    This module contains routines for binding and unbinding to the Win32
    Registry server. 

Author:

    David J. Gilman (davegi) 06-Feb-1992

Revision History:
    Dragos C. Sambotin (dragoss) 21-May-1999
        Moved this code from ..\client\bind.c
        Added EndpointConn_np (pipe connecting)
        Added BaseBindToMachineShutdownInterface to bind to the new winlogon 
            ShutDown interface

--*/

#include <ntrpcp.h>
#include <rpc.h>
#include "shutinit.h"
#include "regconn.h"

//
// wRegConn_bind - common function to bind to a transport and free the
//                                      string binding.
//

wRegConn_bind(
    LPWSTR *    StringBinding,
    RPC_BINDING_HANDLE * pBindingHandle
    )
{
    DWORD RpcStatus;

    RpcStatus = RpcBindingFromStringBindingW(*StringBinding,pBindingHandle);

    RpcStringFreeW(StringBinding);
    if ( RpcStatus != RPC_S_OK ) {
        *pBindingHandle = NULL;
        return RpcStatus;
    }
    return(ERROR_SUCCESS);
}


/*++

Routine Description for the RegConn_* functions:

    Bind to the RPC server over the specified transport

Arguments:

    ServerName - Name of server to bind with (or netaddress).

    pBindingHandle - Location where binding handle is to be placed

Return Value:

    ERROR_SUCCESS - The binding has been successfully completed.

    ERROR_INVALID_COMPUTER_NAME - The ServerName syntax is invalid.

    ERROR_NO_MEMORY - There is not sufficient memory available to the
        caller to perform the binding.

--*/



//
// wRegConn_Netbios - Worker function to get a binding handle for any of the
//                                              netbios protocols
//

DWORD wRegConn_Netbios(
    IN  LPWSTR  rpc_protocol,
    IN  LPCWSTR  ServerName,
    OUT RPC_BINDING_HANDLE * pBindingHandle
    )

{
    RPC_STATUS        RpcStatus;
    LPWSTR            StringBinding;
    LPCWSTR           PlainServerName;

    *pBindingHandle = NULL;

    //
    // Ignore leading "\\"
    //

    if ((ServerName[0] == '\\') && (ServerName[1] == '\\')) {
        PlainServerName = &ServerName[2];
    } else {
        PlainServerName = ServerName;
    }

    RpcStatus = RpcStringBindingComposeW(0,
                                         rpc_protocol,
                                         (LPWSTR)PlainServerName,
                                         NULL,   // endpoint
                                         NULL,
                                         &StringBinding);

    if ( RpcStatus != RPC_S_OK ) {
        return( ERROR_BAD_NETPATH );
    }
    return(wRegConn_bind(&StringBinding, pBindingHandle));
}

DWORD
RegConn_nb_nb(
    IN  LPCWSTR ServerName,
    OUT RPC_BINDING_HANDLE * pBindingHandle
    )
{
        return(wRegConn_Netbios(L"ncacn_nb_nb",
                                ServerName,
                                pBindingHandle));
}

DWORD
RegConn_nb_tcp(
    IN  LPCWSTR ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
{
        return(wRegConn_Netbios(L"ncacn_nb_tcp",
                                ServerName,
                                pBindingHandle));
}

DWORD
RegConn_nb_ipx(
    IN  LPCWSTR               ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
{
        return(wRegConn_Netbios(L"ncacn_nb_ipx",
                                ServerName,
                                pBindingHandle));
}


//
// EndpointConn_np - connects to a specific pipe on the remote machine
//                              (Win95 does not support server-side named pipes)
//

DWORD
EndpointConn_np(
    IN  LPCWSTR              ServerName,
    IN unsigned short *      Endpoint,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
{
    RPC_STATUS  RpcStatus;
    LPWSTR      StringBinding;
    LPWSTR      SlashServerName;
    int         have_slashes;
    ULONG       NameLen;

    *pBindingHandle = NULL;

    if (ServerName[1] == L'\\') {
        have_slashes = 1;
    } else {
        have_slashes = 0;
    }

    //
    // Be nice and prepend slashes if not supplied.
    //

    NameLen = lstrlenW(ServerName);
    if ((!have_slashes) &&
        (NameLen > 0)) {

        //
        // Allocate new buffer large enough for two forward slashes and a
        // NULL terminator.
        //
        SlashServerName = LocalAlloc(LMEM_FIXED, (NameLen + 3) * sizeof(WCHAR));
        if (SlashServerName == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        SlashServerName[0] = L'\\';
        SlashServerName[1] = L'\\';
        lstrcpyW(&SlashServerName[2], ServerName);
    } else {
        SlashServerName = (LPWSTR)ServerName;
    }

    RpcStatus = RpcStringBindingComposeW(0,
                                         L"ncacn_np",
                                         SlashServerName,
                                         Endpoint,
                                         NULL,
                                         &StringBinding);
    if (SlashServerName != ServerName) {
        LocalFree(SlashServerName);
    }

    if ( RpcStatus != RPC_S_OK ) {
        return( ERROR_BAD_NETPATH );
    }

    return(wRegConn_bind(&StringBinding, pBindingHandle));
}

//
// RegConn_np - get a remote registry RPC binding handle for an NT server
//                              (Win95 does not support server-side named pipes)
//

DWORD
RegConn_np(
    IN  LPCWSTR              ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
{
    return EndpointConn_np(ServerName,L"\\PIPE\\winreg",pBindingHandle);
}


//
// RegConn_spx - Use the Netbios connection function, RPC will resolve the name
//                               via winsock.
//

DWORD
RegConn_spx(
    IN  LPCWSTR              ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
{
    return(wRegConn_Netbios(L"ncacn_spx",
                            ServerName,
                            pBindingHandle));
}


DWORD RegConn_ip_tcp(
    IN  LPCWSTR  ServerName,
    OUT RPC_BINDING_HANDLE * pBindingHandle
    )

{
    return(wRegConn_Netbios(L"ncacn_ip_tcp",
                            ServerName,
                            pBindingHandle));
}

RPC_BINDING_HANDLE
PREGISTRY_SERVER_NAME_bind(
        PREGISTRY_SERVER_NAME ServerName
    )

/*++

Routine Description:

    To make the remote registry multi-protocol aware, PREGISTRY_SERVER_NAME
        parameter actually points to an already bound binding handle.
        PREGISTRY_SERVER_NAME is declared a PWSTR only to help maintain
        compatibility with NT.

--*/

{
    return(*(RPC_BINDING_HANDLE *)ServerName);
}


void
PREGISTRY_SERVER_NAME_unbind(
    PREGISTRY_SERVER_NAME ServerName,
    RPC_BINDING_HANDLE BindingHandle
    )

/*++

Routine Description:

    This routine unbinds the RPC client from the server. It is called
    directly from the RPC stub that references the handle.

Arguments:

    ServerName - Not used.

    BindingHandle - Supplies the handle to unbind.

Return Value:

    None.

--*/

{
    DWORD    Status;

    UNREFERENCED_PARAMETER( ServerName );
    return;

}

LONG
BaseBindToMachineShutdownInterface(
    IN LPCWSTR lpMachineName,
    IN PBIND_CALLBACK BindCallback,
    IN PVOID Context1,
    IN PVOID Context2
    )

/*++

Routine Description:

    This is a helper routine used to create an RPC binding from
    a given machine name to the shutdown interface (now residing in winlogon)

Arguments:

    lpMachineName - Supplies a pointer to a machine name. Must not
                    be NULL.

    BindCallback - Supplies the function that should be called once
                   a binding has been created to initiate the connection.

    Context1 - Supplies the first parameter to pass to the callback routine.

    Context2 - Supplies the second parameter to pass to the callback routine.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    LONG    Error;
    RPC_BINDING_HANDLE binding;

    Error = EndpointConn_np(lpMachineName,L"\\PIPE\\InitShutdown",&binding);

    if (Error == ERROR_SUCCESS) {

        //
        // For the named pipes protocol, we use a static endpoint, so the
        // call to RpcEpResolveBinding is not needed.
        // Also, the server checks the user's credentials on opening
        // the named pipe, so RpcBindingSetAuthInfo is not needed.
        //
        Error = (BindCallback)(&binding,
                               Context1,
                               Context2);
        RpcBindingFree(&binding);
        if (Error != RPC_S_SERVER_UNAVAILABLE) {
            return Error;
        }
    }

    if (Error != ERROR_SUCCESS) {
        if ((Error == RPC_S_INVALID_ENDPOINT_FORMAT) ||
            (Error == RPC_S_INVALID_NET_ADDR) ) {
            Error = ERROR_INVALID_COMPUTERNAME;
        } else {
            Error = ERROR_BAD_NETPATH;
        }
    }

    return(Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\regsvc\regsvc.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    regsvc.c

Abstract:

    This module contains the implementation of the remote registry
    service. 
    
    It just initialize and starts the registry RPC server. The service
    is supposed automatically started by SC at boot, and then restarted
    if something goes wrong.

    Used \nt\private\samples\service as a template

Author:

    Dragos C. Sambotin (dragoss) 21-May-1999

Revision History:

    Dragos C. Sambotin (dragoss) 10-Aug-2000
        - converted to a dll to be loaded inside a svchost.exe instance
        - used base\screg\sc\svchost\sample\server as a template


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntrpcp.h>
#include <svcs.h>


SERVICE_STATUS_HANDLE   g_hStatus;
SERVICE_STATUS          g_status;
BOOLEAN                 g_FirstTime = TRUE;
PSVCHOST_GLOBAL_DATA    g_svcsGlobalData = NULL;

BOOL
InitializeWinreg( VOID );

BOOL
ShutdownWinreg(VOID);

BOOL
StartWinregRPCServer( VOID );

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    g_svcsGlobalData = pGlobals;
}

VOID
UpdateServiceStatus (DWORD dwCurrentState,
                     DWORD dwWin32ExitCode,
                     DWORD dwWaitHint)
{    

    static DWORD dwCheckPoint = 1;

    ASSERT (g_hStatus);

    if (dwCurrentState == SERVICE_START_PENDING) {
        g_status.dwControlsAccepted = 0;
    } else {
        g_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    }

    g_status.dwCurrentState = dwCurrentState;
    g_status.dwWin32ExitCode = dwWin32ExitCode;
    g_status.dwWaitHint = dwWaitHint;

    if ( ( dwCurrentState == SERVICE_RUNNING ) || ( dwCurrentState == SERVICE_STOPPED ) ) {
        g_status.dwCheckPoint = 0;
    } else {
        g_status.dwCheckPoint = dwCheckPoint++;
    }

    SetServiceStatus (g_hStatus, &g_status);
}

VOID
StopService()
{
    //
    // Terminate the registry RPC server
    //
    ShutdownWinreg();

    g_svcsGlobalData = NULL;
    // report the status to the service control manager.
    //
    UpdateServiceStatus (SERVICE_STOPPED,NO_ERROR,0);
}

//+---------------------------------------------------------------------------
// ServiceHandler - Called by the service controller at various times.
//
// type of LPHANDLER_FUNCTION
//
VOID
WINAPI
ServiceHandler (
    DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        UpdateServiceStatus (SERVICE_STOP_PENDING,ERROR_SERVICE_SPECIFIC_ERROR,3000);

        StopService();
        break;

    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_SHUTDOWN:
    default:
        // This may not be need, but refresh our status to the service
        // controller.
        //
        ASSERT (g_hStatus);
        SetServiceStatus (g_hStatus, &g_status);
        break;
    }
}

//+---------------------------------------------------------------------------
// ServiceMain - Called by svchost when starting this service.
//
// type of LPSERVICE_MAIN_FUNCTIONW
//
VOID
WINAPI
ServiceMain (
    DWORD   argc,
    PWSTR   argv[])
{
    RPC_STATUS Status;

    // Since we run in svchost.exe, we must have the 'share process' bit set.
    //
    ZeroMemory (&g_status, sizeof(g_status));
    g_status.dwServiceType      = SERVICE_WIN32_SHARE_PROCESS;
    g_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    ASSERT( g_svcsGlobalData != NULL );
    // Register the service control handler.
    //
    //DbgPrint( "Starting Remote Registry Service\n" );
    g_hStatus = RegisterServiceCtrlHandler (TEXT("RemoteRegistry"), ServiceHandler);
    if (g_hStatus)
    {
        UpdateServiceStatus (SERVICE_START_PENDING,NO_ERROR,3000);

        // now svchost.exe does it for us
        //RpcpInitRpcServer();

        if( g_FirstTime ) {
            if( !InitializeWinreg() ) {
                goto ErrorExit;
            }
            g_FirstTime = FALSE;
        } else {
            // just restart RPC service
            if( !StartWinregRPCServer() ) {
                goto ErrorExit;
            }
        }

        Status = RpcServerRegisterAuthInfo( NULL, RPC_C_AUTHN_WINNT, NULL, NULL );
    
        if( Status ) {
            goto Cleanup;
        }

        Status = RpcServerRegisterAuthInfo( NULL, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL);

        if( Status ) {
            goto Cleanup;
        }

        UpdateServiceStatus (SERVICE_RUNNING,NO_ERROR,0);

        return;


Cleanup:
        //
        // Terminate the registry RPC server
        //
        ShutdownWinreg();

ErrorExit:
        // report the status to the service control manager.
        //
        UpdateServiceStatus (SERVICE_STOPPED,NO_ERROR,0);
        
        //DbgPrint( "RegisterServiceCtrlHandler failed! (1)\n" );
    }
    else 
    {
        DbgPrint( "RegisterServiceCtrlHandler failed!  %d\n", GetLastError() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\regsvc\init.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module contains the initialization routine for the Win32 Registry
    API RPC server.

Author:

    David J. Gilman (davegi) 15-May-1992

--*/

#include <ntrpcp.h>
#include <rpc.h>
#include <svcs.h>
#include "regrpc.h"

BOOL InitializeRemoteSecurity( );

BOOL InitializeRegCreateKey( );

extern PSVCHOST_GLOBAL_DATA    g_svcsGlobalData;

BOOL
StartWinregRPCServer( 
                     )
{
    LPWSTR              ServiceName;
    NTSTATUS            Status;

    if( !g_svcsGlobalData ) {
        return FALSE;
    }
    ServiceName = INTERFACE_NAME;
    Status = g_svcsGlobalData->StartRpcServer(
                ServiceName,
                winreg_ServerIfHandle
                );
    ASSERT( NT_SUCCESS( Status ));
    if( ! NT_SUCCESS( Status )) {
        return FALSE;
    }
    
    return TRUE;
}

BOOL
InitializeWinreg(
    )

/*++

Routine Description:

    Initialize the Winreg RPC server by creating the notify thread,
    starting the server and creating the external synchronization event.

Arguments:

    None.

Return Value:

    BOOL - Returns TRUE if initialization is succesful.

--*/
{
    BOOL                Success;
    HANDLE              PublicEvent;

    //
    // Create the notify thread.
    //

    Success = InitializeRegNotifyChangeKeyValue( );
    ASSERT( Success == TRUE );
    if( Success == FALSE ) {
        return FALSE;
    }

    //
    // Initialize BaseRegCreateKey
    //

    Success = InitializeRegCreateKey( );
    ASSERT( Success == TRUE );
    if( Success == FALSE ) {
        return FALSE;
    }

    //
    // Initialize support for remote security
    //

    Success = InitializeRemoteSecurity( );
    if ( Success == FALSE )
    {
        return( FALSE );
    }

    //
    // Start the Winreg RPC server.
    //
    Success = StartWinregRPCServer( );
    if ( Success == FALSE )
    {
        return( FALSE );
    }

    //
    //  Let the world know that the server is running.
    //
    PublicEvent = CreateEvent( NULL, TRUE, TRUE, PUBLIC_EVENT );
    ASSERT( PublicEvent );
    if( !PublicEvent  ) {
        return FALSE;
    }

    //
    // Success!
    //

    return TRUE;
}

BOOL
ShutdownWinreg(
    )

/*++

Routine Description:

    Stops the Winreg RPC server.

Arguments:

    None.

Return Value:

    None

--*/
{
    // 
    // Stop the rpc server
    //
    if( !g_svcsGlobalData ) {
        return FALSE;
    }
    g_svcsGlobalData->StopRpcServer( winreg_ServerIfHandle );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\regsvc\dllmain.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    DLL entry point. Does nothing for now. We may add to it later.

Author:

    Dragos C. Sambotin (dragoss) 10-Aug-2000

--*/

// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Public windows headers.
//
#include <windows.h>


//+---------------------------------------------------------------------------
// DLL Entry Point
//
// DllMain should do as little work as possible.  Here's why:
//   1. Incorrectly assuming that thread attach/detach are 1:1. (explain)
//   2. Performance
//      a) touching pages (#3 below)
//      b) assume you will be loaded by someone who is performance-critical.
//
//   1. For every process that the DLL is attached to, DllMain gets called
//      with DLL_PROCESS_ATTACH.  For any new threads created or destroyed
//      after DLL_PROCESS_ATTACH, DllMain is called with DLL_THREAD_ATTACH
//      and DLL_THREAD_DETACH events.  Since it is rare that a DLL controls
//      or even knows about the clients that use it, it shouldn't assume
//      that DllMain is called only once (or even a small number of times).
//      In fact, you should assume the worst case (that it is called a lot)
//      and code for that case.  This is not unrealistic either.  If your
//      DLL gets attached to services.exe for example, you will be hit
//      with a lot of thread attach/detach events.  If you don't need these
//      events (and you shouldn't) your DllMain code needs to get paged in
//      (assuming it's not paged in) and called.
//
//   2. Over time, people tend to lose sight of why and when DLLs are loaded.
//      Further, as more APIs are added to the DLL the likelihood that the
//      DLL will be loaded increases.  (i.e. It becomes more useful.) It
//      is your responsibility to keep the performance of your DLL at a level
//      compatible with your most demanding (performance wise) client.  For
//      example: Say a very performance-critical client needs to use a small
//      piece of functionality in your DLL.  If you've done things in DllMain
//      (like create heaps, or access the registry, etc.) that don't strictly
//      need to be done to access that small piece of functionality, then
//      it is wasteful to do so and may be the straw that broke the camel's
//      back in terms of your client deciding your DLL is "too heavy" to be
//      used.  For the functionality in your DLL to "scale" from your first
//      very simple client to the Nth performance-critical client, you've got
//      to keep DllMain absolutely lean and mean.
//
//   3. Fewer code in DllMain means fewer pages touched when your DLL is
//      loaded.  If your DLL is loaded at all during boot of the OS or
//      an application, this means faster startup times.  Let's say it again
//      in another way -- "the more code you add to DllMain, the slower the
//      OS or application boots up".  You may think now that your DLL won't
//      be loaded during boot.  I'll bet most of the developers of the DLLs
//      that are now loaded during boot thought the same thing in the
//      beginning. ;-)  As your DLL becomes more useful, it gets used by
//      more and more parts of the system.
//
BOOL
WINAPI
DllMain (
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      pvReserved
    )
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {

    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regdkey.c ===
//depot/Lab04_N/Base/screg/winreg/server/regdkey.c#5 - integrate change 12179 (text)
/*++



Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regdkey.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry API to delete a key.  That is:

        - BaseRegDeleteKey

Author:

    David J. Gilman (davegi) 15-Nov-1991

Notes:

    See the Notes in Regkey.c.


--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include <malloc.h>
#ifdef LOCAL
#include "tsappcmp.h"
#include <wow64reg.h>
#endif



error_status_t
BaseRegDeleteKey(
    HKEY hKey,
    PUNICODE_STRING lpSubKey
    )

/*++

Routine Description:

    Delete a key.

Arguments:

    hKey - Supplies a handle to an open key.  The lpSubKey pathname
        parameter is relative to this key handle.  Any of the predefined
        reserved handles or a previously opened key handle may be used for
        hKey.

    lpSubKey - Supplies the downward key path to the key to delete.  May
        NOT be NULL.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    If successful, RegDeleteKey removes the key at the desired location
    from the registration database.  The entire key, including all of its
    values, will be removed.  The key to be deleted may NOT have children,
    otherwise the call will fail.  There must not be any open handles that
    refer to the key to be deleted, otherwise the call will fail.  DELETE
    access to the key being deleted is required.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;
    NTSTATUS            StatusCheck;
    HKEY                KeyHandle;
    BOOL                fSafeToDelete;

#ifdef LOCAL
    UNICODE_STRING      TmpStr = *lpSubKey; //used to keep original SubKey string
#endif //LOCAL

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Subtract the NULL from the string length. This was added
    //  by the client so that RPC would transmit the whole thing.
    //
    lpSubKey->Length -= sizeof( UNICODE_NULL );

#ifdef LOCAL
    //
    // see if this key is a special key in HKCR
    //
    if (REG_CLASS_IS_SPECIAL_KEY(hKey) ||
        (   (gdwRegistryExtensionFlags & TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION)
         && ExtractClassKey(&hKey,lpSubKey) ) ) {

        //
        // if this is a class registration, we call a special routine
        // to open this key
        //
        Status = BaseRegOpenClassKey(
            hKey,
            lpSubKey,
            0,
            MAXIMUM_ALLOWED,
            &KeyHandle);

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

    } else
#endif // LOCAL
    {
        //
        // Initialize the OBJECT_ATTRIBUTES structure and open the sub key
        // so that it can then be deleted.
        //

        InitializeObjectAttributes(
            &Obja,
            lpSubKey,
            OBJ_CASE_INSENSITIVE,
            hKey,
            NULL
            );

        Status = NtOpenKey(
            &KeyHandle,
            DELETE,
            &Obja
            );
    }

#ifdef LOCAL
    if (gpfnTermsrvDeleteKey) {
        //
        // Remove the key from the Terminal Server registry tracking database
        //
        gpfnTermsrvDeleteKey(KeyHandle);
    }
#endif

        //
        // If for any reason the key could not be opened, return the error.
        //

    if( NT_SUCCESS( Status )) {
        //
        // Call the Nt APIs to delete and close the key.
        //

#if defined(_WIN64) & defined ( LOCAL)
        HKEY hWowKey = Wow64OpenRemappedKeyOnReflection (KeyHandle);
#endif //wow64 reflection case

        Status = NtDeleteKey( KeyHandle );
        StatusCheck = NtClose( KeyHandle );
        ASSERT( NT_SUCCESS( StatusCheck ));

#if defined(_WIN64) & defined ( LOCAL)
        if ( (NT_SUCCESS( Status )) && (hWowKey != NULL))
            Wow64RegDeleteKey (hWowKey, NULL);

        if (hWowKey != NULL)
            NtClose (hWowKey);
#endif //wow64 reflection case
        
    }

#ifdef LOCAL
cleanup:

    *lpSubKey = TmpStr;
#endif
    RPC_REVERT_TO_SELF();

    //
    // Map the NTSTATUS code to a Win32 Registry error code and return.
    //

    return (error_status_t)RtlNtStatusToDosError( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regclass.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegClass.c

Abstract:

    This module contains routines to manipulate class registration
    registry keys for the win32 registry apis.  These routines are called
    from several of the functions for manipulating registry, including
    the functions that open, enumerate, create, and delete keys.

Author:

    Adam P. Edwards     (adamed)  14-Nov-1997

Key Functions:

    OpenCombinedClassesRoot
    BaseRegGetKeySemantics
    BaseRegOpenClassKey
    BaseRegOpenClassKeyFromLocation
    BaseRegGetUserAndMachineClass

Notes:

****************************************************
    PLEASE READ THIS IF YOU ARE NEW TO THIS CODE!!!!
****************************************************

    Starting with NT5, the HKEY_CLASSES_ROOT key is per-user
    instead of per-machine -- previously, HKCR was an alias for
    HKLM\Software\Classes.

    The per-user HKCR combines machine classes stored it the
    traditional HKLM\Software\Classes location with classes
    stored in HKCU\Software\Classes.

    Certain keys, such as CLSID, will have subkeys that come
    from both the machine and user locations.  When there is a conflict
    in key names, the user oriented key overrides the other one --
    only the user key is seen in that case.

    Here are the key ideas for this implementation:

    1. The changes for this module only affect keys under
       HKEY_CLASSES_ROOT. Only the Local registry
       implementation supports HKCR so all the changes are
       local only, they do not exist in the
       remote rpc registry server.

    2. We parse each key under HKCR as

         <prefix>\<intermediate>\<special>[\<classreg>]\[<lastelement>]

       where <prefix> is one of the forms

         \Registry\Machine\Software\Classes
         \Registry\User\<sid>\Software\Classes
         \Registry\User\<sid>_Classes

       <intermediate> can be a subpath of arbitrary length

       <special> is a certain list of keys, shown below in the
         gSpecialSubtrees table, e.g. IID, CLSID.

       <classreg> is any subkey of <special>.  <lastelement> is
         the remainder of the path.

    3. In order to quickly distinguish keys in HKCR from keys not in HKCR, we
       use tag bits on each registry handle that we return from an open or create
       if the key is under HKCR. When the HKCR predefined handle is opened,
       we set a tag on its handle index -- any children open or created with a
       parent key whose tag is set like this will inherit the tag. There are other
       tags, such as those for local and remote regkeys, already in use prior
       to the implementation of per user class registration in NT5. Please see
       the header file for more information on how to interpret the tags.

    4. The special keys have the following properties which differentiate
       them from standard registry keys:

       a. The children of a special key come from both HKLM\Software\Classes
          and HKCU\Software\Classes.  Thus, since CLSID is a special key,
          if HKLM\Software\Classes\CLSID\Key1 exists and
          HKCU\Software\Classes\CLSID\Key2 exists, one would find the keys
          Key1 and Key2 under HKCR\CLSID.
       b. If the same key exists in both the user and machine locations, only
          the user version of the key is seen under HKCR.

     5. To create the illusion described above, the code for several api's
        had to be modified:

        a. RegOpenKeyEx -- for HKCR subkeys, this api was modified to look
           for the key to open first in the user part of the registry,
           then the machine part if the user version did not exist. All
           keys opened with HKCR as an ancestor get a bit set in the handle
           index.

        b. RegCreateKeyEx -- modified in a fashion similar to RegOpenKeyEx.
        c. RegDeleteKey  -- modified to find key to delete in fashion similar
           to RegOpenKeyEx.

        d. RegEnumKeyEx -- extensive changes for HKCR. Previously this api was
           simply a wrapper to the kernel version. This is insufficient now
           because the kernel knows nothing of our hkcr scheme.  See regecls.*
           for details.

        e. RegQueryInfoKey -- changes related to RegEnumKeyEx changes -- see
           regecls.*, regqkey.c.

    It should be noted that HKCU\Software\Classes is not the true
    location of the user-only class data.  If it were, all the class
    data would be in ntuser.dat, which roams with the user.  Since
    class data can get very large, installation of a few apps
    would cause HKCU (ntuser.dat) to grow from a manageable size
    to many megabytes.  Since user-specific class data comes from
    the directory, it does not need to roam and therefore it was
    separated from HKCU (ntuser.dat) and stored in another hive
    mounted under HKEY_USERS.

    It is still desirable to allow access to this hive through
    HKCU\Software\Classes, so we use some trickery (symlinks) to
    make it seem as if the user class data exists there.

**************************
    IMPORTANT ASSUMPTIONS:
**************************

    This code assumes that all special keys exist in both
    HKEY_LOCAL_MACHINE\Software\Classes and HKEY_CURRENT_USER\Software\Classes.
    The code may break if this is not true.

--*/


#ifdef LOCAL

#include <rpc.h>
#include <string.h>
#include <wchar.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regecls.h"
#include <malloc.h>


NTSTATUS QueryKeyInfo(
    HKEY hKey,
    PKEY_FULL_INFORMATION* ppKeyFullInfo,
    ULONG BufferLength,
    BOOL fClass,
    USHORT MaxClassLength);

extern HKEY HKEY_ClassesRoot;

BOOL            gbCombinedClasses = TRUE;

PKEY_VALUE_PARTIAL_INFORMATION gpNameSpaceKeyInfo = NULL;

#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)

RTL_CRITICAL_SECTION gRegClassHeapCritSect;
DWORD                gcbAllocated = 0;
DWORD                gcAllocs = 0;
DWORD                gcbMaxAllocated = 0;
DWORD                gcMaxAllocs = 0;
PVOID                gpvAllocs;

#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

UNICODE_STRING gMachineClassesName = {
    REG_MACHINE_CLASSES_HIVE_NAMELEN,
    REG_MACHINE_CLASSES_HIVE_NAMELEN,
    REG_MACHINE_CLASSES_HIVE_NAME};


error_status_t
OpenCombinedClassesRoot(
     IN REGSAM samDesired,
    OUT HANDLE * phKey
    )
/*++

Routine Description:

    Attempts to open the the HKEY_CLASSES_ROOT predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\MACHINE\SOFTWARE\CLASSES.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          UsersHive;
    UNICODE_STRING          UsersMergedHive;

    // first try for a per-user HKCR
    RtlFormatCurrentUserKeyPath( &UsersHive );

    UsersMergedHive.MaximumLength = UsersHive.MaximumLength +
        REG_USER_HIVE_CLASSES_SUFFIXLEN + REG_CHAR_SIZE;

    //
    // alloca does not return NULL on failure, it throws an exception,
    // so return value is not checked.
    //
    UsersMergedHive.Buffer = alloca(UsersMergedHive.MaximumLength);

    RtlCopyUnicodeString(&UsersMergedHive, &UsersHive );

    // add the _Merged_Classes suffix
    Status = RtlAppendUnicodeToString( &UsersMergedHive, REG_USER_HIVE_CLASSES_SUFFIX);

    ASSERT(NT_SUCCESS(Status));

    //
    // Initialize the OBJECT_ATTRIBUTES structure so that it creates
    // (opens) the key "\HKU\<sid>_Merged_Classes" with a Security
    // Descriptor that allows everyone complete access.
    //

    InitializeObjectAttributes(
        &Obja,
        &UsersMergedHive,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(
                phKey,
                samDesired, // MAXIMUM_ALLOWED,
                &Obja
                );

    RtlFreeUnicodeString( &UsersHive );

    //
    // This key is the ancestor of all keys in HKCR, so
    // we must mark its handle so that its origin in HKCR
    // is propagated to all children opened with this handle
    //
    if (NT_SUCCESS(Status)) {

        *phKey = REG_CLASS_SET_SPECIAL_KEY(*phKey);

    }

    return Status;
}



NTSTATUS BaseRegGetKeySemantics(
    HKEY            hkParent,
    PUNICODE_STRING pSubKey,
    SKeySemantics*  pKeySemantics)
/*++

Routine Description:

    This function parses a key in HKEY_CLASSES_ROOT.  It is used to determine if a given key
    is a class registration unit key, as well as other syntactic / semantic information about
    the key.  It sets the value of pfIsClsRegKey to TRUE if it is, FALSE if not.

    The key in question is defined by the (hkParent, pSubKey) pair.

    Definitions for terms such as Prefix, Special Key, and class registration can
    be found at the top of this module.

Arguments:

    hkParent      - parent portion of key
    pSubKey       - child portion of key
    pKeySemantics - pointer to struct containing key semantic information -- the
                    following members of this structure are affected:

                    _fUser: TRUE if this key is rooted in HKEY_USERS, FALSE if not
                    _fMachine: TRUE if this key is rooted in HKLM, FALSE if not
                    _fCombinedClasses: TRUE if this key is rooted in HKEY_USERS\\<Sid>_Classes
                    _fClassRegistration: TRUE if this key is a class registration unit
                    _fClassRegParent: TRUE if this key is the parent of a class registration unit
                    _ichKeyStart: index to start of a class reg after the prefix -- this is after
                                 the pathsep which follows the prefix
                    _cbPrefixLen: Length (in bytes) of prefix from start of full path
                    _cbSpecialKey: Length (in bytes) of the name of the special key -- this is
                                 not from the start of the full path, just that key name only. It
                                 includes an initial pathsep.
                    _cbClassRegKey: length of class reg key name (not from start of full path).
                                 Includes an initial pathsep.
                    _cbFullPath: size of buffer structure pointed to by _pFullPath.  On return,
                                 this member is set to the number of bytes written to _pFullPath
                                 by the function, or the required number of bytes if the buffer
                                 passed in was too small
                    _pFullPath: KEY_NAME_INFORMATION structure containing the full pathname
                                of the registry key defined by (hkParent, pSubKey). This pathname
                                is null terminated.

Returns:

    NT_SUCCESS If the function completed successfully.  If the buffer pointed to by
    pKeySemantics->_pFullPath is not large enough to hold the name of the key, the
    function returns STATUS_BUFFER_TOO_SMALL and the required size in bytes is
    written to pKeySemantics->_cbFullPath.  The caller may then reallocate the buffer
    and call this function again.  All other errors return the appropriate NTSTATUS
    failure code.

Notes:

    After calling this function and getting a successful return status, the pKeySemantics
    structure should be freed by calling BaseRegReleaseKeySemantics

--*/
{
    NTSTATUS                 Status;
    UNICODE_STRING           NameInfo;
    PKEY_NAME_INFORMATION    pNameInfo;

    USHORT                   ichClassesKeyNameEnd;
    USHORT                   ichSpecialKeyNameEnd;
    USHORT                   cbName;
    ULONG                    cbObjInfo;
    WCHAR*                   szClassRegKeyEnd;

    //
    // Save in params
    //
    cbObjInfo = pKeySemantics->_cbFullPath  - REG_CHAR_SIZE; // subtract one for trailing \0
    pNameInfo = pKeySemantics->_pFullPath;

    //
    // reset out params
    //
    memset(&(pKeySemantics->_pFullPath), 0, sizeof(*(pKeySemantics->_pFullPath->Name)));
    memset(pKeySemantics, 0, sizeof(*pKeySemantics));

    //
    // restore in params
    //
    pKeySemantics->_pFullPath = pNameInfo;
    pKeySemantics->_cbFullPath = cbObjInfo;

    //
    // Get full name of key -- first, we need to find the path
    // for the registry key hkParent
    //
    if (!hkParent) {

        //
        // If no key name was specified, the full path is simply the subkey name
        //
        pKeySemantics->_cbFullPath = REG_CHAR_SIZE;
        (pKeySemantics->_pFullPath->Name)[0] = L'\0';
        pKeySemantics->_pFullPath->NameLength = 0;
        pKeySemantics->_cbFullPath = sizeof(*(pKeySemantics->_pFullPath));

    } else {

        Status = NtQueryKey(
            hkParent,
            KeyNameInformation,
            pKeySemantics->_pFullPath,
            cbObjInfo,
            &pKeySemantics->_cbFullPath);

        if (STATUS_KEY_DELETED == Status) {
            Status = STATUS_SUCCESS;
        }

        //
        // Kernel set the _cbFullPath member to the necessary size -- tack
        // on the length of the subkey too
        //

        //
        // Kernel set the _cbFullPath member to the necessary size -- tack
        // on the length of the subkey too
        //

        pKeySemantics->_cbFullPath += pSubKey->Length + REG_CHAR_SIZE * 2;

        //
        // The retrieval of the object's name information may have succeeded,
        // but we still need to append the subkey, so verify that enough
        // space is left
        //
        if (NT_SUCCESS(Status) && (cbObjInfo < pKeySemantics->_cbFullPath)) {
            //
            // we have successfully retrieved the info from the kernel,
            // but adding the subkey, we overflow ==> allocate a buffer
            // big enough and copy the info from _pFullPath
            //
            pNameInfo = (PKEY_NAME_INFORMATION) RegClassHeapAlloc(
                pKeySemantics->_cbFullPath);

            if (!pNameInfo) {
                return STATUS_NO_MEMORY;
            }

            RtlCopyMemory(pNameInfo->Name,
                          pKeySemantics->_pFullPath->Name,
                          pKeySemantics->_pFullPath->NameLength);
            pNameInfo->NameLength = pKeySemantics->_pFullPath->NameLength;

        }

        if (!NT_SUCCESS(Status)) {

            //
            // Retry by allocating a new buffer if the kernel thought the
            // supplied buffer was too small.  Add extra padding
            // because we may need to add a null terminator and pathsep later
            //
            if (STATUS_BUFFER_OVERFLOW == Status) {

                //
                // The _cbFullPath member was to the required length in the
                // call to NtQueryKey above and includes extra padding
                // for appending more characters
                //
                pNameInfo = (PKEY_NAME_INFORMATION) RegClassHeapAlloc(
                    pKeySemantics->_cbFullPath);

                if (!pNameInfo) {
                    return STATUS_NO_MEMORY;
                }

                cbObjInfo = pKeySemantics->_cbFullPath;

                //
                // Retry -- we should have a large enough buffer now
                //
                Status = NtQueryKey(
                    hkParent,
                    KeyNameInformation,
                    pNameInfo,
                    cbObjInfo,
                    &pKeySemantics->_cbFullPath);

                if (STATUS_KEY_DELETED == Status) {
                    Status = STATUS_SUCCESS;
                }
            }

            if (!NT_SUCCESS(Status)) {

                //
                // We allocated heap for the second query, but since it failed,
                // we need to free the allocated memory.
                //
                if (pNameInfo != pKeySemantics->_pFullPath) {
                    RegClassHeapFree(pNameInfo);
                }

                return Status;
            }
        }
    }

    //
    // If this isn't set, we know a non-registry key handle was passed in since
    // all registry handles have a path associated with them, whereas other types
    // of handles may not
    //
    if (!(pNameInfo->Name)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // We will always return success after this point, so it's
    // ok to set the full path member of the structure now. Make
    // sure we set the flag indicating that we had to allocate
    // memory to store the name if that was indeed the case
    //
    if (pNameInfo != pKeySemantics->_pFullPath) {
        pKeySemantics->_fAllocedNameBuf = TRUE;
    }

    pKeySemantics->_pFullPath = pNameInfo;

    //
    // Now that we know the name of the parent key, we can concatenate it
    // with the pSubKey parameter
    //

    //
    // First we need to add a trailing pathsep and NULL terminate it
    //
    pNameInfo->Name[pNameInfo->NameLength / 2] = L'\\';
    pNameInfo->Name[pNameInfo->NameLength / 2 + 1] = L'\0';

    //
    // Get a unicode string so we can perform string operations
    //
    RtlInitUnicodeString(&NameInfo, pNameInfo->Name);

    //
    // Adjust the length to reflect the unicode string -- right
    // now it inlcudes the length of the Length member of the
    // KEY_NAME_INFORMATION structure -- we just want the length
    // of the string
    //
    pNameInfo->NameLength = NameInfo.Length;

    //
    // Now add space to the string for the subkey and slash
    //
    NameInfo.MaximumLength += pSubKey->Length + REG_CHAR_SIZE;

    //
    // append the subkey to the parent key
    //

    //
    // We made sure the buffer was big enough, so the only way this will
    // fail is if pSubKey is invalid, which will cause an
    // access violation, so no need no test
    //
    Status = RtlAppendUnicodeStringToString(&NameInfo, pSubKey);

    ASSERT(NT_SUCCESS(Status));

    //
    // if the key name isn't at least as long as the shortest
    // classes hive name, leave.
    // This assumes that
    // HKU\\Sid_Classes is shorter than
    // HKU\\Sid\\Software\\Classes
    //
    if (NameInfo.Length < REG_CLASSES_HIVE_MIN_NAMELEN) {
        return STATUS_SUCCESS;
    }

    //
    // remove any terminating pathsep
    //
    if (NameInfo.Buffer[NameInfo.Length / 2 - 1] == L'\\') {
        NameInfo.Length-= sizeof(L'\\');
    }

    //
    // We're done getting the name of the key, save its length
    // for the caller
    //
    pNameInfo->NameLength = NameInfo.Length;

    //
    // cache the name length
    //
    cbName = (USHORT) pNameInfo->NameLength;

    //
    // null terminate the name
    //
    pNameInfo->Name[cbName / REG_CHAR_SIZE] = L'\0';

    if (REG_CLASS_IS_SPECIAL_KEY(hkParent)) {
        pKeySemantics->_fCombinedClasses = TRUE;
    }

    //
    // First, see if we're even in the correct hive -- we can check
    // certain characters in the path to avoid doing extra string compares
    //
    switch (pNameInfo->Name[REG_CLASSES_FIRST_DISTINCT_ICH])
    {
    case L'M':
    case L'm':
        //
        // check if we're in the machine hive
        //
        NameInfo.Length = REG_MACHINE_CLASSES_HIVE_NAMELEN;

        //
        // Compare prefix with the name for the machine classes key
        // Set machine flag if comparison returns equality.
        //
        if (RtlEqualUnicodeString(
                &NameInfo,
                &gMachineClassesName,
                TRUE) != 0) {

            NameInfo.Length = cbName;
            ichClassesKeyNameEnd = REG_MACHINE_CLASSES_HIVE_NAMECCH;

            pKeySemantics->_fMachine = TRUE;

            break;
        }

        return STATUS_SUCCESS;

    case L'U':
    case L'u':
        //
        // check if we're in the users hive
        //
        {
            //
            // This will try to find the user prefix -- it fails
            // if we're not in the user hive and returns a zero-length
            // prefix. Set the flag if it succeeds.
            //
            ichClassesKeyNameEnd = BaseRegGetUserPrefixLength(
                &NameInfo);

            if (!ichClassesKeyNameEnd) {
                return STATUS_SUCCESS;
            }

            pKeySemantics->_fUser = TRUE;

            break;
        }

        //
        // this isn't a class registration because it isn't in any of the
        // correct trees
        //
        return STATUS_SUCCESS;

    default:

        //
        // the appropriate characters weren't in the key name, so
        // this can't be a class registration
        //
        return STATUS_SUCCESS;
    }

    //
    // At this point, we've found the prefix. The next part of the key
    // is the special key -- we look for that now.
    //
    pKeySemantics->_cbPrefixLen = ichClassesKeyNameEnd * REG_CHAR_SIZE;
    pKeySemantics->_ichKeyStart = ichClassesKeyNameEnd;

    //
    // the start of the special key
    // is the character right after the end of the prefix
    //
    if (pKeySemantics->_cbPrefixLen < pNameInfo->NameLength) {
        pKeySemantics->_ichKeyStart++;
    }

    //
    // search for a special subkey of the classes hive --
    // this will return the index in the full path of the end
    // of the special key name.
    //
    ichSpecialKeyNameEnd = BaseRegCchSpecialKeyLen(
        &NameInfo,
        ichClassesKeyNameEnd,
        pKeySemantics);

    //
    // if we find that the entire key is a special key, we're done --
    // there's nothing after it in this case so there's no more to
    // parse
    //
    if (pKeySemantics->_fClassRegParent) {
        return STATUS_SUCCESS;
    }

    //
    // at this point, we know the key itself is a class registration
    //
    pKeySemantics->_fClassRegistration = TRUE;

    pKeySemantics->_cbClassRegKey = (USHORT) pNameInfo->NameLength -
        (pKeySemantics->_cbPrefixLen + pKeySemantics->_cbSpecialKey + REG_CHAR_SIZE);

    return STATUS_SUCCESS;
}


void BaseRegReleaseKeySemantics(SKeySemantics* pKeySemantics)
/*++
Routine Description:

    This function frees resources associated with an SKeySemantics object

Arguments:

    pKeySemantics - pointer to SKeySemantics object whose resources should
        be freed

Return Value:

    None

--*/
{
    if (pKeySemantics->_fAllocedNameBuf) {
        RegClassHeapFree(pKeySemantics->_pFullPath);
    }
}



NTSTATUS BaseRegOpenClassKey(
    IN HKEY hKey,
    IN PUNICODE_STRING lpSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)
/*++
Routine Description:

    This function is used to retry opening a class registration key.

Arguments:

    hKey - Supplies a handle to an open key.  The lpSubKey pathname
        parameter is relative to this key handle.

    lpSubKey - Supplies the downward key path to the key to open.
        lpSubKey is always relative to the key specified by hKey.

    dwOptions -- reserved.

    samDesired -- This access mask describes the desired security access
        for the key.

    phkResult -- Returns the handle to the newly opened key.

Return Value:

    Returns STATUS_SUCCESS if a key was successfully opened, otherwise it
        returns an NTSTATUS error code

    Note:

    The key must be a class registration key in order to be opened

--*/
{
    BYTE                rgNameInfoBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE];
    SKeySemantics       keyinfo;
    NTSTATUS            Status;

    //
    // Set up the buffer that will hold the name of the key
    //
    keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameInfoBuf;
    keyinfo._cbFullPath = sizeof(rgNameInfoBuf);
    keyinfo._fAllocedNameBuf = FALSE;

    //
    // get information about this key
    //
    Status = BaseRegGetKeySemantics(hKey, lpSubKey, &keyinfo);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Use the information above to look in both user and machine
    // hives for the key to be opened
    //
    Status =  BaseRegOpenClassKeyFromLocation(
        &keyinfo,
        hKey,
        lpSubKey,
        samDesired,
        LOCATION_BOTH,
        phkResult);

    BaseRegReleaseKeySemantics(&keyinfo);

    return Status;
}



NTSTATUS BaseRegOpenClassKeyFromLocation(
    SKeySemantics*  pKeyInfo,
    HKEY            hKey,
    PUNICODE_STRING lpSubKey,
    REGSAM          samDesired,
    DWORD           dwLocation,
    HKEY*           phkResult)
/*++
Routine Description:

    This function will try to open a class registration key that has no link
    in the combined classes hive -- it does this by attempting to open the
    class registration in the machine hive.  If it succeeds, it also creates
    a link to the key in the combined classes hive

Arguments:

    pKeyInfo -- structure supplying information about a key

    hKey -- Supplies a handle to an open key.  The lpSubKey pathname
        parameter is relative to this key handle.

    lpSubKey -- Supplies the downward key path to the key to open.
        lpSubKey is always relative to the key specified by hKey.

    samDesired -- This access mask describes the desired security access
        for the key.

    phkResult -- Returns the handle to the newly opened key.  If NULL,
        no open key handle is returned.

    dwLocation -- set of flags that specify where to look for the key.
        If LOCATION_MACHINE is specified, the function looks in machine.
        If LOCATION_USER is specified, the function looks in user.  Both
        flags may be specified simultaneously, so that it will look in both
        places, or LOCATION_BOTH may be specified for this purpose.  If
        the function looks in both places, an existing key in the user hive
        takes precedence over one in the machine hive.

Return Value:

    Returns STATUS_SUCCESS if a key was successfully opened, otherwise it
        returns an NTSTATUS error code

    Note:

--*/
{
    WCHAR*              FullPathBuf;
    USHORT              NewPathLen;
    UNICODE_STRING      ClassRegkey;
    UNICODE_STRING      ClassRegSubkey;
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;
    USHORT              PrefixLen;

    //
    // Init locals
    //
    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    NewPathLen = (USHORT) pKeyInfo->_pFullPath->NameLength + REG_CLASSES_SUBTREE_PADDING;

    //
    // Allocate space for the remapped key -- note that if alloca
    // fails, it throws an exception, so we don't check for NULL return value
    //
    FullPathBuf = (WCHAR*) RegClassHeapAlloc(NewPathLen);

    if (!FullPathBuf) {
        return STATUS_NO_MEMORY;
    }

    //
    // Set up a unicode string to use this buffer
    //
    ClassRegkey.MaximumLength = NewPathLen;
    ClassRegkey.Buffer = FullPathBuf;

    ASSERT((dwLocation == LOCATION_USER) || (dwLocation == LOCATION_MACHINE) ||
           (dwLocation == LOCATION_BOTH));

    //
    // Opening the entire key is a two step process.  First, open
    // the class registration portion -- we need to do that from
    // either the machine or user location.  The second step
    // is to open everything after the class registration using the
    // key obtained in the first step.
    //

    //
    // Below we try to find a user or machine version of the
    // class registration
    //

    if ( LOCATION_USER & dwLocation ) {
        //
        // Try the user location -- first, move the key name to
        // the user hive's namespace
        //
        if( pKeyInfo->_fUser ) {
            //
            // in the user's hive we can try a relative open
            //
            InitializeObjectAttributes(
                &Obja,
                lpSubKey,
                OBJ_CASE_INSENSITIVE,
                hKey, // relative path
                NULL);
        } else {
            //
            // we need to do an absolute path open
            //
            Status = BaseRegTranslateToUserClassKey(
                pKeyInfo,
                &ClassRegkey,
                &PrefixLen);

            if (!NT_SUCCESS(Status)) {
                goto cleanup;
            }

            //
            // now try opening the key with the new HKCU string
            //
            InitializeObjectAttributes(
                &Obja,
                &ClassRegkey,
                OBJ_CASE_INSENSITIVE,
                NULL, // using absolute path, no hkey
                NULL);
        }

        Status = NtOpenKey(
            phkResult,
            samDesired,
            &Obja);
    }

    //
    // Only try machine if we failed to open user key above
    // (or didn't even try to open it)
    //
    if ((LOCATION_MACHINE & dwLocation) && !NT_SUCCESS(Status)) {

        //
        // Now try HKLM -- translate the key to the machine
        // namespace
        //
        if( pKeyInfo->_fMachine ) {
            //
            // in the machine hive we can try a relative open
            //
            InitializeObjectAttributes(
                &Obja,
                lpSubKey,
                OBJ_CASE_INSENSITIVE,
                hKey, // relative path
                NULL);
        } else {
            //
            // we need to do an absolute path open
            //
            Status = BaseRegTranslateToMachineClassKey(
                pKeyInfo,
                &ClassRegkey,
                &PrefixLen);

            if (!NT_SUCCESS(Status)) {
                goto cleanup;
            }

            //
            // now try opening the key with the new HKLM string
            //
            InitializeObjectAttributes(
                &Obja,
                &ClassRegkey,
                OBJ_CASE_INSENSITIVE,
                NULL, // using absolute path, no hkey
                NULL);
        }

        Status = NtOpenKey(
            phkResult,
            samDesired,
            &Obja);

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }
    }

    //
    // mark this key as a class key from HKCR
    //
    if (NT_SUCCESS(Status)) {
        *phkResult = REG_CLASS_SET_SPECIAL_KEY(*phkResult);
    }

cleanup:

    RegClassHeapFree(FullPathBuf);

    return Status;
}



NTSTATUS BaseRegConstructUserClassPrefix(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pUserClassPrefix)
/*++
Routine Description:

    This function creates a prefix for a class key that is in the user hive

Arguments:

    pKeyInfo         - pointer to struct containing key semantic information
    pUserClassPrefix - out param for the constructed prefix

    Returns: NT_SUCCESS If the function completed successfully.

    Notes:

--*/
{
    UNICODE_STRING UserKey;
    NTSTATUS       Status;

    //
    // The prefix looks like <sid>_Classes
    //

    //
    // First obtain the sid
    //
    if (pKeyInfo->_fUser) {

        UNICODE_STRING SidString;

        //
        // construct a string that contains the user's sid
        //
        KeySemanticsGetSid(pKeyInfo, &SidString);

        RtlInitUnicodeString(&UserKey, REG_USER_HIVE_NAME);

        //
        // create a string that starts with the HKU prefix
        //
        RtlCopyUnicodeString(pUserClassPrefix, &UserKey);

        //
        // append the sid to the user prefix
        //
        Status = RtlAppendUnicodeStringToString(pUserClassPrefix, &SidString);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

    } else {

        UNICODE_STRING          UsersHive;

        //
        // This will only happen if a special key has been deleted from
        // the user hive
        //
        Status = RtlFormatCurrentUserKeyPath( &UsersHive );

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        RtlCopyUnicodeString(pUserClassPrefix, &UsersHive );

        RtlFreeUnicodeString(&UsersHive);
    }

    //
    // Append the suffix to the sid
    //
    return RtlAppendUnicodeToString(pUserClassPrefix, REG_USER_HIVE_CLASSES_SUFFIX);
}


NTSTATUS BaseRegTranslateToMachineClassKey(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pMachineClassKey,
    USHORT*         pPrefixLen)
/*++
Routine Description:

    This function translates a class key rooted in HKCR to the machine hive

Arguments:

    pKeyInfo - pointer to struct containing key semantic information -- the
    pMachineClassKey - out param for result of translation
    pPrefixLen - out param for length of the prefix of the resulting translation

    Returns: NT_SUCCESS If the function completed successfully.

    Notes:

--*/
{
    UNICODE_STRING MachineKey;
    UNICODE_STRING ClassSubkey;

    RtlInitUnicodeString(&MachineKey, REG_MACHINE_CLASSES_HIVE_NAME);

    //
    // get the unique class key portion
    //
    KeySemanticsRemovePrefix(pKeyInfo, &ClassSubkey, REMOVEPREFIX_KEEP_INITIAL_PATHSEP);

    //
    // create a string that starts with the HKLM prefix and has the
    // desired class registration key as a subkey
    //
    RtlCopyUnicodeString(pMachineClassKey, &MachineKey);

    *pPrefixLen = REG_MACHINE_CLASSES_HIVE_NAMELEN;

    return RtlAppendUnicodeStringToString(pMachineClassKey, &ClassSubkey);
}


NTSTATUS BaseRegTranslateToUserClassKey(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pUserClassKey,
    USHORT*         pPrefixLen)
/*++
Routine Description:

    This function translates a class key rooted in HKCR to the user hive

Arguments:

    pKeyInfo - pointer to struct containing key semantic information -- the
    pUserClassKey - out param for result of translation
    pPrefixLen - out param for length of the prefix of the resulting translation

    Returns: NT_SUCCESS If the function completed successfully.

    Notes:

--*/
{
    UNICODE_STRING ClassSubkey;
    NTSTATUS       Status;

    //
    // get the unique class key portion
    //
    KeySemanticsRemovePrefix(pKeyInfo, &ClassSubkey, REMOVEPREFIX_KEEP_INITIAL_PATHSEP);

    if (!NT_SUCCESS(Status = BaseRegConstructUserClassPrefix(
        pKeyInfo,
        pUserClassKey))) {
        return Status;
    }

    *pPrefixLen = pUserClassKey->Length;

    //
    // finally, append the class key
    //
    return RtlAppendUnicodeStringToString(pUserClassKey, &ClassSubkey);
}



USHORT BaseRegGetUserPrefixLength(PUNICODE_STRING pFullPath)
/*++
Routine Description:

    This function is used to determine the length of the prefix
    \\Registry\\User\\<Sid>\\Software\Classes or \\Registry\\User\\\<Sid>_classes

Arguments:

    pFullPath          - full path of the registry, rooted at \\Registry

Return Value:

    Returns the length of the prefix (which must be nonzero), 0 if unsuccessful

--*/
{
    UNICODE_STRING UserHive;
    UNICODE_STRING FullPath;
    USHORT         ich;
    USHORT         ichMax;

    FullPath = *pFullPath;

    //
    // set ourselves up to look for the user hive portion
    // of the prefix
    //
    RtlInitUnicodeString(&UserHive, REG_USER_HIVE_NAME);

    if (FullPath.Length <= UserHive.Length) {
        return 0;
    }

    FullPath.Length = UserHive.Length;

    //
    // check for the user hive prefix, leave if not found
    //
    if (!RtlEqualUnicodeString(&UserHive, &FullPath, TRUE)) {
        return 0;
    }

    ichMax = pFullPath->Length / REG_CHAR_SIZE;

    //
    // before looking for the classes subtree, we must skip past
    // the user's sid -- the prefix is in the form
    // \\Registry\\User\\<sid>\\Software\\Classes or
    // \\Registyr\\User\\<sid>_Classes
    //
    for (ich = REG_USER_HIVE_NAMECCH + 1; ich < ichMax; ich++)
    {
        //
        // if we find a pathsep, we cannot be in the combined
        // classes hive or the user classes hive
        //
        if (pFullPath->Buffer[ich] == L'\\') {
            return 0;
        }

        //
        // if we find the underscore character, we are in the combined
        // classes hive or the user classes hive -- i.e. the prefix looks like
        // \\Registry\\User\\<sid>_Classes
        // -- use the underscore to distinguish from other cases
        //
        if (pFullPath->Buffer[ich] == L'_') {

            UNICODE_STRING Suffix;

            RtlInitUnicodeString(&Suffix, REG_USER_HIVE_CLASSES_SUFFIX);

            FullPath.Length = Suffix.Length;
            FullPath.Buffer = &(pFullPath->Buffer[ich]);

            // look for the user classes suffix in the user hive
            if (RtlEqualUnicodeString(&FullPath, &Suffix, TRUE)) {

                return ich + REG_USER_HIVE_CLASSES_SUFFIXCCH;
            }

            return 0;
        }
    }

    return 0;
}



USHORT BaseRegCchSpecialKeyLen(
    PUNICODE_STRING pFullPath,
    USHORT          ichSpecialKeyStart,
    SKeySemantics*  pKeySemantics)
/*++
Routine Description:

    This function is used to determine the length of a special subkey contained
    on the pSpecialKey parameter.  If the entire pFullPath is a special key,
    a flag in pKeySemantics will be set to TRUE

Arguments:

    pFullPath          - full path of the registry, rooted at \\Registry
    ichSpecialKeyStart - index in the full path of the start of the special key path
    pKeySemantics      - pointer to structure which stores semantics information about a key

Return Value:

    Returns the length of the special key if there is a special key in the pSpecialKey
        path, 0 if there is none

    Notes:

    This function depends on the gSpecialSubtree array being a *sorted* list of special
        key names.

--*/
{
    WCHAR* wszSpecialKey;
    USHORT ichSpecialKeyLen;

    ASSERT(pFullPath->Length / REG_CHAR_SIZE >= ichSpecialKeyStart);

    //
    // For hkcr itself, there is no ancestor -- detect this special
    // case and return
    //
    if (pFullPath->Length / REG_CHAR_SIZE == ichSpecialKeyStart) {
        pKeySemantics->_fClassRegParent = TRUE;
        return ichSpecialKeyStart;
    }

    //
    // The special key is now just the parent of this key -- find
    // the immediate ancestor of this key
    //
    wszSpecialKey = wcsrchr(&(pFullPath->Buffer[ichSpecialKeyStart]), L'\\');

    ASSERT(wszSpecialKey);

    //
    // The length of the special key is the difference
    // between the '\' at the end of the special key and the start
    // of the string
    //
    ichSpecialKeyLen = (USHORT)(wszSpecialKey - pFullPath->Buffer);

    //
    // Store the length of the special key name by itself as well
    //
    pKeySemantics->_cbSpecialKey = ichSpecialKeyLen - ichSpecialKeyStart;

    return ichSpecialKeyLen;
}


NTSTATUS BaseRegOpenClassKeyRoot(
    SKeySemantics*  pKeyInfo,
    PHKEY           phkClassRoot,
    PUNICODE_STRING pClassKeyPath,
    BOOL            fMachine)
/*++
Routine Description:

    This function will try to open the class root key appropriate to
    a given key being opened from HKEY_CLASSES_ROOT. The key opened is either
    HKEY_USERS\<Sid>_Classes or HKLM\Software\Classes. If the key exists
    in the user portion, then that the user key will be opened.  Otherwise,
    the machine key is returned. It also returns the unicode string
    subkey name used to open the key specified in
    pKeyInfo relative to the class root key returned in phkClassRoot.

Arguments:

    pKeyInfo -- structure supplying information about a key

    phkClassRoot -- out param for the class root key result of the function

    pClassKeyPath -- Supplies the downward key path to the key to open.
        pClassKeyPath is always relative to the key specified by hKey.

    pfMachine -- out param flag that indicates that whether or not
        this key was opened in the machine hive.

Return Value:

    Returns STATUS_SUCCESS if a key was successfully deleted, otherwise it
        returns an NTSTATUS error code

    Note:

--*/
{
    NTSTATUS Status;
    USHORT   PrefixLen;
    UNICODE_STRING NewFullPath;

    //
    // Allocate space for a full path -- note that
    // we don't check the return value since alloca throws
    // an exception if it fails
    //
    NewFullPath.Buffer = alloca(pClassKeyPath->MaximumLength);
    NewFullPath.MaximumLength = pClassKeyPath->MaximumLength;

    //
    // Translate to appropriate location
    //
    if (fMachine) {

        Status = BaseRegTranslateToMachineClassKey(
            pKeyInfo,
            &NewFullPath,
            &PrefixLen);
    } else {

        Status = BaseRegTranslateToUserClassKey(
            pKeyInfo,
            &NewFullPath,
            &PrefixLen);
    }

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Open the prefix
    //
    {
        UNICODE_STRING RootKey;
        OBJECT_ATTRIBUTES Obja;

        RootKey.Buffer = NewFullPath.Buffer;

        //
        // Calculate the length of the prefix
        //
        RootKey.Length = PrefixLen;

        //
        // now, get ready to open it
        //
        InitializeObjectAttributes(&Obja,
                                   &RootKey,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL, // full path, no hkey
                                   NULL);

        Status =  NtOpenKey(
            phkClassRoot,
            MAXIMUM_ALLOWED,
            &Obja);
    }

    if (NT_SUCCESS(Status)) {

        //
        // Skip past the prefix
        //
        NewFullPath.Buffer += (PrefixLen / REG_CHAR_SIZE);
        NewFullPath.Length -= PrefixLen;

        if (L'\\' == NewFullPath.Buffer[0]) {
            NewFullPath.Length -= REG_CHAR_SIZE;
            NewFullPath.Buffer ++;
        }

        //
        // Copy everything after the prefix
        //
        RtlCopyUnicodeString(pClassKeyPath, &NewFullPath);
    }

    return Status;
}


NTSTATUS
BaseRegMapClassRegistrationKey(
    HKEY              hKey,
    PUNICODE_STRING   pSubKey,
    SKeySemantics*    pKeyInfo,
    PUNICODE_STRING   pDestSubKey,
    BOOL*             pfRetryOnAccessDenied,
    PHKEY             phkDestResult,
    PUNICODE_STRING*  ppSubKeyResult)
/*++
Routine Description:

    This function will map a key from HKEY_CLASSES_ROOT into either the
    user hive or machine hive.  The remapped key is returned in the
    (*phkDestResult, *ppSubKeyResult) pair.

Arguments:

    hKey    -- root of key to remap

    pSubKey -- Supplies the downward key path to the key to remap.
        pSubKey is always relative to the key specified by hKey.

    pKeyInfo -- structure supplying information about a key

    pDestSubKey -- unicode string in which to store result data
        if the key gets remapped

    pfRetryOnAccessDenied -- out param flag to set indicating whether
        failure to open the remapped key because of access denied should
        be retried

    phkDestResult -- out param for root of remapped key

    ppSubKeyResult -- out param for remainder of path of remapped key

Return Value:

    Returns STATUS_SUCCESS if a key was successfully deleted, otherwise it
        returns an NTSTATUS error code

    Note:

--*/
{
    BOOL           fMachine;
    UNICODE_STRING ClassKeyPath;
    NTSTATUS       Status;
    HKEY           hkUser;

    //
    // by default, use machine
    //
    fMachine = TRUE;


    //
    // Check for existence of the key in the
    // user hive
    //
    Status =  BaseRegOpenClassKeyFromLocation(
        pKeyInfo,
        hKey,
        pSubKey,
        MAXIMUM_ALLOWED,
        LOCATION_USER,
        &hkUser);

    if (!NT_SUCCESS(Status)) {

        //
        // a not found error is fine -- this just means that
        // neither key exists already -- in this case we
        // choose to use machine
        //
        if (STATUS_OBJECT_NAME_NOT_FOUND != Status) {
            return Status;
        }

    } else {

        //
        // The user key exists, we choose it over
        // the machine key
        //
        fMachine = FALSE;

        NtClose(hkUser);
    }

    //
    // Get a buffer for the new path
    //
    ClassKeyPath.Buffer = (WCHAR*) RegClassHeapAlloc(
        ClassKeyPath.MaximumLength = ((USHORT) pKeyInfo->_pFullPath->NameLength +
        REG_CLASSES_SUBTREE_PADDING));

    if (!(ClassKeyPath.Buffer)) {
        return STATUS_NO_MEMORY;
    }

    //
    // Remap the key
    //
    Status = BaseRegOpenClassKeyRoot(
        pKeyInfo,
        phkDestResult,
        &ClassKeyPath,
        fMachine);

    if (!NT_SUCCESS(Status)) {

        RegClassHeapFree(ClassKeyPath.Buffer);

        return Status;
    }

    //
    // If the remapped key is in the machine hive, set the flag so that
    // retries are not permitted.
    //
    if (*pfRetryOnAccessDenied && !fMachine) {
        *pfRetryOnAccessDenied = FALSE;
    }

    //
    // phkDestResult, the root portion of the remapped key, was set above.
    // now set the subkey portion and leave
    //
    *pDestSubKey = ClassKeyPath;
    *ppSubKeyResult = pDestSubKey;

    return STATUS_SUCCESS;
}


NTSTATUS BaseRegGetUserAndMachineClass(
    SKeySemantics* pKeySemantics,
    HKEY           hKey,
    REGSAM         samDesired,
    PHKEY          phkMachine,
    PHKEY          phkUser)
/*++
Routine Description:

    This function will return kernel objects corresponding to the user
    and machine components of a given kernel object.

Arguments:

    pKeySemantics -- supplies information about hKey.  This is optional --
        if the caller does not supply it, the function will query for the information.
        This is an optimization for callers that already have this info
        and can save us the time of

    hKey -- key for which to open user and machine versions

    samDesired -- security access mask for one of the returned keys -- see
        note below for important info on this

    phkMachine -- out param for machine version of key

    phkUser -- out param for user version of key

Return Value:

    Returns STATUS_SUCCESS if a key was successfully deleted, otherwise it
        returns an NTSTATUS error code

Notes:

***VERY IMPORTANT!!!***

    One of the two returned keys will alias hKey -- this way we only open
    one object (one trip to the kernel) instead of two.  This means that the caller
    should not blindly call NtClose on the two returned objects -- a == comparison
    between one of the keys and hKey should be made to determine if it that key is
    the alias -- if it is, you should *NOT* call NtClose on it because otherwise the
    owner of hKey will call NtClose on the same handle value after your call to close
    that handle which will cause an exception.  You *should* close the handle that does not
    alias hKey -- if you don't you'll get a handle leak.

    Another important note -- only the new key (non-aliased) will have the access mask
    specified in samDesired -- the aliased key is just hKey, so it has the same access
    mask.  If you want to ensure the correct access on that key, you'll need to explicitly
    duplicate or open that key with the correct access.

--*/
{
    NTSTATUS       Status;
    SKeySemantics  keyinfo;
    SKeySemantics* pKeyInfo;
    UNICODE_STRING EmptyString = {0, 0, 0};
    BYTE           rgNameBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE + sizeof(KEY_NAME_INFORMATION)];
    DWORD          dwLocation;
    PHKEY          phkNew;

    //
    // Clear out parameters
    //
    *phkMachine = NULL;
    *phkUser = NULL;

    //
    // Try to use caller supplied key information
    //
    if (pKeySemantics) {
        pKeyInfo = pKeySemantics;
    } else {

        //
        // Set buffer to store info about this key
        //
        keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameBuf;
        keyinfo._cbFullPath = sizeof(rgNameBuf);
        keyinfo._fAllocedNameBuf = FALSE;

        //
        // get information about this key
        //
        Status = BaseRegGetKeySemantics(hKey, &EmptyString, &keyinfo);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        pKeyInfo = &keyinfo;
    }

    if (pKeyInfo->_fMachine) {

        *phkMachine = hKey;
        dwLocation = LOCATION_USER;
        phkNew = phkUser;

    } else {

        *phkUser = hKey;
        dwLocation = LOCATION_MACHINE;
        phkNew = phkMachine;

    }

    (void) BaseRegOpenClassKeyFromLocation(
        pKeyInfo,
        hKey,
        &EmptyString,
        (samDesired & KEY_WOW64_RES) | MAXIMUM_ALLOWED,
        dwLocation,
        phkNew);

    if (!pKeySemantics) {
        BaseRegReleaseKeySemantics(&keyinfo);
    }

    return STATUS_SUCCESS;
}


NTSTATUS GetFixedKeyInfo(
    HKEY     hkUser,
    HKEY     hkMachine,
    LPDWORD  pdwUserValues,
    LPDWORD  pdwMachineValues,
    LPDWORD  pdwUserMaxDataLen,
    LPDWORD  pdwMachineMaxDataLen,
    LPDWORD  pdwMaxValueNameLen)
{

    NTSTATUS                Status;
    DWORD                   cUserValues;
    DWORD                   cMachineValues;
    KEY_CACHED_INFORMATION  KeyInfo;
    DWORD                   dwRead;
    DWORD                   cbMaxNameLen;
    DWORD                   cbUserMaxDataLen;
    DWORD                   cbMachineMaxDataLen;

    //
    // Init locals
    //
    cUserValues = 0;
    cMachineValues = 0;
    cbMaxNameLen = 0;
    cbUserMaxDataLen = 0;
    cbMachineMaxDataLen = 0;

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    //
    // Init out params
    //
    if (pdwUserValues) {
        *pdwUserValues = 0;
    }

    if (pdwMachineValues) {
        *pdwMachineValues = 0;
    }

    if (pdwMaxValueNameLen) {
        *pdwMaxValueNameLen = 0;
    }

    if (pdwUserMaxDataLen) {
        *pdwUserMaxDataLen = 0;
    }

    if (pdwMachineMaxDataLen) {
        *pdwMachineMaxDataLen = 0;
    }

    //
    // Get user information
    //
    if (hkUser) {

        Status = NtQueryKey(
            hkUser,
            KeyCachedInformation,
            &KeyInfo,
            sizeof(KeyInfo),
            &dwRead);

        //
        // KEY_CACHED_INFORMATION is a fixed struct !!!
        //
        ASSERT( Status != STATUS_BUFFER_OVERFLOW);
        //if (STATUS_BUFFER_OVERFLOW == Status) {
        //  Status = STATUS_SUCCESS;
        //}

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        cUserValues = KeyInfo.Values;
        cbMaxNameLen = KeyInfo.MaxValueNameLen;
        cbUserMaxDataLen = KeyInfo.MaxValueDataLen;
    }

    //
    // Get machine information
    //
    if (hkMachine) {

        Status = NtQueryKey(
            hkMachine,
            KeyCachedInformation,
            &KeyInfo,
            sizeof(KeyInfo),
            &dwRead);

        //
        // KEY_CACHED_INFORMATION is a fixed struct !!!
        //
        ASSERT( Status != STATUS_BUFFER_OVERFLOW);
        //if (STATUS_BUFFER_OVERFLOW == Status) {
        //  Status = STATUS_SUCCESS;
        //}

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        cMachineValues = KeyInfo.Values;
        cbMachineMaxDataLen = KeyInfo.MaxValueDataLen;

        if (KeyInfo.MaxValueNameLen > cbMaxNameLen) {
            cbMaxNameLen = KeyInfo.MaxValueNameLen;
        }
    }

    if (pdwUserValues) {
        *pdwUserValues = cUserValues;
    }

    if (pdwMachineValues) {
        *pdwMachineValues = cMachineValues;
    }

    if (pdwMaxValueNameLen) {
        *pdwMaxValueNameLen = cbMaxNameLen;
    }

    if (pdwUserMaxDataLen) {
        *pdwUserMaxDataLen = cbUserMaxDataLen;
    }

    if (pdwMachineMaxDataLen) {
        *pdwMachineMaxDataLen = cbMachineMaxDataLen;
    }

    return Status;
}


//#ifdef CLASSES_RETRY_ON_ACCESS_DENIED


NTSTATUS
BaseRegMapClassOnAccessDenied(
    SKeySemantics*    pKeySemantics,
    PHKEY             phkDest,
    PUNICODE_STRING   pDestSubKey,
    BOOL*             pfRetryOnAccessDenied)
/*++
Routine Description:

    This function will remap a key to the user hive when an access denied
    error is encountered creating it in the machine hive

Arguments:

    pKeySemantics -- structure supplying information about a key

    phkDest -- out param for root of remapped key

    pDestSubKey -- out param for remainder of path of remapped key

    pfRetryOnAccessDenied -- in / out param.  If true, we can
      remap it.  On return this value indicates whether or not
      we can do another retry

Return Value:

    Returns STATUS_SUCCESS if a key was successfully deleted, otherwise it
        returns an NTSTATUS error code

    Note:

--*/
{
    NTSTATUS Status;
    UNICODE_STRING NewFullPath;

    Status = STATUS_ACCESS_DENIED;
    NewFullPath.Buffer=NULL;

    if (pKeySemantics->_fCombinedClasses &&
        *pfRetryOnAccessDenied) {

        USHORT         PrefixLen;

        //
        // Close the original key -- we don't need it anymore.
        //
        if(*phkDest) {
            NtClose(*phkDest);
            *phkDest = NULL;
        }


        //
        // No more retries permitted for this key
        //
        *pfRetryOnAccessDenied = FALSE;

        //
        // Get space for the new path -- we will free this below.
        // We avoid using alloca because of stack overflows
        //
        NewFullPath.MaximumLength = (USHORT)(pKeySemantics->_pFullPath->NameLength) + REG_CLASSES_SUBTREE_PADDING;

        NewFullPath.Buffer = RegClassHeapAlloc(NewFullPath.MaximumLength);

        if (!(NewFullPath.Buffer)) {
            return STATUS_NO_MEMORY;
        }

        //
        // Translate this key to the user hive
        //
        Status = BaseRegTranslateToUserClassKey(
            pKeySemantics,
            &NewFullPath,
            &PrefixLen);

        if (NT_SUCCESS(Status)) {

            UNICODE_STRING    Prefix;
            OBJECT_ATTRIBUTES Obja;

            //
            // Allocate space for the new key name to give back to the caller
            //
            pDestSubKey->MaximumLength = NewFullPath.MaximumLength - PrefixLen + 1;
            pDestSubKey->Buffer = (WCHAR*) RegClassHeapAlloc(pDestSubKey->MaximumLength);

            if (!(pDestSubKey->Buffer)) {
                Status = STATUS_NO_MEMORY;
                goto cleanup;
            }

            //
            // Make a string which strips off every thing after the prefix --
            // we will open up to the prefix
            //
            Prefix.Buffer = NewFullPath.Buffer;
            Prefix.Length = PrefixLen;

            //
            // Move our full path past the prefix
            //
            NewFullPath.Buffer += (PrefixLen + REG_CHAR_SIZE) / REG_CHAR_SIZE;
            NewFullPath.Length -= (PrefixLen + REG_CHAR_SIZE);
            //
            // Copy everything after the prefix to the subkey path
            // that we're returning to the caller
            //
            RtlCopyUnicodeString(pDestSubKey, &NewFullPath);

            //
            //Get the original pointer back so we could free it!
            //
            NewFullPath.Buffer -= (PrefixLen + REG_CHAR_SIZE) / REG_CHAR_SIZE;
            NewFullPath.Length += (PrefixLen + REG_CHAR_SIZE);
            //
            // Now open the root for the caller
            //
            InitializeObjectAttributes(&Obja,
                                       &Prefix,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL, // full path, no hkey
                                       NULL);

            Status = NtOpenKey(
                phkDest,
                MAXIMUM_ALLOWED,
                &Obja);

            if(!NT_SUCCESS(Status)) {
                RegClassHeapFree(pDestSubKey->Buffer);
                pDestSubKey->Buffer=NULL;
            }
        }
    }

cleanup:

    //
    // Free the buffer we allocated above
    //
    if(NewFullPath.Buffer) {
        RegClassHeapFree(NewFullPath.Buffer);
    }

    return Status;
}

//#endif // CLASSES_RETRY_ON_ACCESS_DENIED

NTSTATUS
CreateMultipartUserClassKey(
    IN HKEY hKey,
    OUT PHKEY phkResult)
/*++

Routine Description:

    This function creates HKCU\Software\Classes\... subkey
    corresponding to given HKLM\Software\Classes\... subkey

Arguments:

    IN HKEY hKey - handle of HKLM\Software\Classes\... subkey
    OUT PHKEY phkResult - handle of HKCU\Software\Classes\... subkey

Return Value:

    Returns STATUS_SUCCESS on success, other NTSTATUS if failed.

--*/
{
    LPWSTR            KeyBuffer;
    ULONG             NumberOfSubKeys;
    LPWSTR            p;
    ULONG             i;
    LPWSTR            Token;
    UNICODE_STRING    KeyName;
    HANDLE            TempHandle1;
    HANDLE            TempHandle2;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS          Status;

    ////////////////////////////////////////////////////////////////////////////
    BYTE                rgNameInfoBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE];
    SKeySemantics       keyinfo;
    UNICODE_STRING      EmptyString= {0, 0, 0};
    HKEY                hkDestKey=NULL;
    UNICODE_STRING      DestSubkey;
    BOOL                fRetryOnAccessDenied=TRUE;
    //
    // Set up the buffer that will hold the name of the key
    //
    keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameInfoBuf;
    keyinfo._cbFullPath = sizeof(rgNameInfoBuf);
    keyinfo._fAllocedNameBuf = FALSE;

    //
    // get information about this key
    //
    Status = BaseRegGetKeySemantics(hKey, &EmptyString, &keyinfo);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    DestSubkey.Buffer=NULL;

    //
    //Remap key to the user hive.
    //
    Status = BaseRegMapClassOnAccessDenied(
                &keyinfo,
                &hkDestKey,
                &DestSubkey,
                &fRetryOnAccessDenied);

    BaseRegReleaseKeySemantics(&keyinfo);

    if(!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    //If we've opened new hkDestKey we must close it.
    //
    if( hkDestKey != hKey ) {
        TempHandle1 = hkDestKey;
    } else {
        TempHandle1 = NULL;
    }

    //
    // Initialize the buffer to be tokenized.
    //

    KeyBuffer = DestSubkey.Buffer;

    //
    //  Find out the number of subkeys to be created
    //
    NumberOfSubKeys = 1;
    p = KeyBuffer;
    while ( ( p = wcschr( p, ( WCHAR )'\\' ) ) != NULL ) {
        p++;
        NumberOfSubKeys++;
    }

    for( i = 0, Token = KeyBuffer; i < NumberOfSubKeys; i++ ) {

        ASSERT(Token != NULL);

        if( ( *Token == ( WCHAR )'\\' ) &&
            ( i != NumberOfSubKeys - 1 ) ) {
            //
            //  If the first character of the key name is '\', and the key
            //  is not the last to be created, then ignore this key name.
            //  This condition can happen if the key name contains
            //  consecutive '\'.
            //  This behavior is consistent with the one we had in the past
            //  when the API used wcstok() to get the key names.
            //  Note that if the key name is an empty string, we return a handle
            //  that is different than hKey, even though both point to the same
            //  key. This is by design.
            //
            Token++;
            continue;
        }

        //
        // Convert the token to a counted Unicode string.
        //
        KeyName.Buffer = Token;
        if (i == NumberOfSubKeys - 1) {
            KeyName.Length = wcslen(Token)*sizeof(WCHAR);
        } else {
            KeyName.Length = (USHORT)(wcschr(Token, ( WCHAR )'\\') - Token)*sizeof(WCHAR);
        }

        //
        // Remember the intermediate handle (NULL the first time through).
        //

        TempHandle2 = TempHandle1;

        //
        // Initialize the OBJECT_ATTRIBUTES structure, close the
        // intermediate key and create or open the key.
        //

        InitializeObjectAttributes(
                &Obja,
                &KeyName,
                OBJ_CASE_INSENSITIVE,
                hkDestKey,
                NULL
                );

        Status = NtCreateKey(
                &TempHandle1,
                MAXIMUM_ALLOWED,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

        //
        // Initialize the next object directory (i.e. parent key) handle.
        //

        hkDestKey = TempHandle1;

        //
        // Close the intermediate key.
        // This fails the first time through the loop since the
        // handle is NULL.
        //

        if( TempHandle2 != NULL ) {
            NtClose( TempHandle2 );
        }

        //
        // If creating the key failed, return the error.
        //

        if( ! NT_SUCCESS( Status )) {
            break;
        }

        Token = wcschr( Token, ( WCHAR )'\\') + 1;

    }

    if(DestSubkey.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, DestSubkey.Buffer);
    }

    //
    // Only set the return value once we know we've
    // succeeded.
    //
    if( NT_SUCCESS( Status )) {
        *phkResult = hkDestKey;
    }

    return Status;
}


#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)

BOOL InitializeInstrumentedRegClassHeap()
{
    NTSTATUS Status;

    Status = RtlInitializeCriticalSection(
                    &(gRegClassHeapCritSect));

    return NT_SUCCESS(Status);
}

BOOL CleanupInstrumentedRegClassHeap()
{
    NTSTATUS Status;

    Status = RtlDeleteCriticalSection(
                    &(gRegClassHeapCritSect));

    DbgPrint("WINREG: Instrumented memory data for process id 0x%x\n", NtCurrentTeb()->ClientId.UniqueProcess);
    DbgPrint("WINREG: Classes Heap Maximum Allocated: 0x%x\n", gcbMaxAllocated);
    DbgPrint("WINREG: Classes Heap Maximum Outstanding Allocs: 0x%x\n", gcMaxAllocs);

    if (gcbAllocated || gcAllocs) {

        DbgPrint("WINREG: Classes Heap ERROR!\n");
        DbgPrint("WINREG: Classes Heap not completely freed!\n");
        DbgPrint("WINREG: Classes Heap Leaked 0x%x bytes\n", gcbAllocated);
        DbgPrint("WINREG: Classes Heap Outstanding Allocs: 0x%x\n", gcAllocs);

        DbgBreakPoint();
    } else {
        DbgPrint("WINREG: Classes Heap is OK.\n");
    }

    return NT_SUCCESS(Status);
}


#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

/*++

Routine Description:

    Replaces HKLM\Software\Classes\<something> path with HKCR\<something>

Arguments:

    phKey        - The pointer to the handle of the key to map
    lpSubKey    - The key that is to be opened/created/deleted


Return Value:

    If the [phKey] is in an interesting area return TRUE

    If not, or if an error occurs, return FALSE.

--*/

BOOL
ExtractClassKey(
        IN OUT HKEY *phKey,
        IN OUT PUNICODE_STRING lpSubKey)
{

#define STR_CLASSES1 L"Classes\\"
#define STR_CLASSES2 L"Software\\Classes\\"
#define STR_MACHINE1 L"\\Registry\\Machine\\Software"
#define STR_MACHINE2 L"\\Registry\\Machine"

    static const WCHAR *szCmpStr1[2]={STR_CLASSES1,STR_CLASSES2};
    static const WCHAR *szCmpStr2[2]={STR_MACHINE1,STR_MACHINE2};
    static const USHORT SizeCmpStr1[2]={sizeof(STR_CLASSES1)/sizeof(WCHAR)-2,
                                        sizeof(STR_CLASSES2)/sizeof(WCHAR)-2};
    static const USHORT SizeCmpStr2[2]={sizeof(STR_MACHINE1)/sizeof(WCHAR)-1,
                                        sizeof(STR_MACHINE2)/sizeof(WCHAR)-1};
    static const USHORT LengthCmpStr1[2]={sizeof(STR_CLASSES1)-2*sizeof(WCHAR),
                                          sizeof(STR_CLASSES2)-2*sizeof(WCHAR)};
    static const USHORT LengthCmpStr2[2]={sizeof(STR_MACHINE1)-sizeof(WCHAR),
                                          sizeof(STR_MACHINE2)-sizeof(WCHAR)};

    static const USHORT offset[2]={sizeof(STR_CLASSES1)-sizeof(WCHAR),
                                   sizeof(STR_CLASSES2)-sizeof(WCHAR)};

    static BYTE pBuff[sizeof(STR_MACHINE1)+sizeof(KEY_NAME_INFORMATION)];

    PKEY_NAME_INFORMATION    pNameInfo = (PKEY_NAME_INFORMATION)pBuff;
    ULONG ResultLength;
    NTSTATUS Status;

    int index = 0;



    //if length of the subkey name is less than "Classes" this is
    //not the key we are interested in.
    if(lpSubKey->Length < LengthCmpStr1[index]) {

        return FALSE;
    }

    //see if subkey name starts with "Classes"
    //If length of the subkey name is longer than "Classes",
    //see if we have '\\' in the right place
    //(because it could be something like "ClassesSomething").
    if(_wcsnicmp(lpSubKey->Buffer,szCmpStr1[index],SizeCmpStr1[index]) ||
        (lpSubKey->Length > LengthCmpStr1[index] &&
        lpSubKey->Buffer[SizeCmpStr1[index]] != L'\\')) {

        index = 1;

        //if length of the subkey name is less than "Software\\Classes" this is
        //not the key we are interested in.
        if(lpSubKey->Length < LengthCmpStr1[index]) {

            return FALSE;
        }

        //see if subkey name starts with "Software\\Classes"
        //If length of the subkey name is longer than "Software\\Classes",
        //see if we have '\\' in the right place
        //(because it could be something like "Software\\ClassesSomething").
        if(_wcsnicmp(lpSubKey->Buffer,szCmpStr1[index],SizeCmpStr1[index]) ||
            (lpSubKey->Length > LengthCmpStr1[index] &&
            lpSubKey->Buffer[SizeCmpStr1[index]] != L'\\')) {

            return FALSE;
        }
    }

    //Get the parent key name
    Status = NtQueryKey(
                *phKey,
                KeyNameInformation,
                pNameInfo,
                sizeof(pBuff),
                &ResultLength);

    if (!NT_SUCCESS(Status)) {

        return FALSE;
    }

    if(pNameInfo->NameLength != LengthCmpStr2[index] ||
        _wcsnicmp(pNameInfo->Name,szCmpStr2[index],SizeCmpStr2[index])) {

        return FALSE;
    }

    //Get handle to HKCR
    if( !HKEY_ClassesRoot ) {

        if( LocalOpenClassesRoot(NULL, MAXIMUM_ALLOWED, &HKEY_ClassesRoot) != ERROR_SUCCESS ) {

            return FALSE;
        }
    }


    // cut "Classes\\" or "Software\\Classes\\" from lpSubKey
    if(lpSubKey->Length <= offset[index] ) {
        //user tries to access HKLM\Software\Classes[\]"
        //we will just return him handle to HKCR.
        lpSubKey->Length = 0;

    } else {
        //move pointer after "Classes\\" or "Software\\Classes\\"
        //it will be restored by caller
        lpSubKey->Length -= offset[index];
        lpSubKey->MaximumLength -= offset[index];
        lpSubKey->Buffer += offset[index]/sizeof(WCHAR);
    }

    //replace hKey with HKCR
    *phKey = HKEY_ClassesRoot;

    return TRUE;
}

#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\localreg.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Localreg.h

Abstract:

    This file is used to make small changes to the Winreg Base entry
    points so that they compile as local or remote functions.

Author:

    David J. Gilman (davegi) 26-Aug-1992

Notes:

    The mapping from BaseRegNotifyChangeKeyValue to
    LocalBaseRegNotifyChangeKeyValue is missing because in the
    local case the call to NJt is made by the client.


--*/

#if defined( LOCAL )

//
// Change the 'server' enrty point names for the local functions.
//

//
// Base functions.
//

#define BaseRegDeleteKey                LocalBaseRegDeleteKey
#define BaseRegDeleteValue              LocalBaseRegDeleteValue
#define BaseRegEnumKey                  LocalBaseRegEnumKey
#define BaseRegEnumValue                LocalBaseRegEnumValue
#define BaseRegCloseKey                 LocalBaseRegCloseKey
#define BaseRegCreateKey                LocalBaseRegCreateKey
#define BaseRegFlushKey                 LocalBaseRegFlushKey
#define BaseRegOpenKey                  LocalBaseRegOpenKey
#define BaseRegLoadKey                  LocalBaseRegLoadKey
#define BaseRegUnLoadKey                LocalBaseRegUnLoadKey
#define BaseRegReplaceKey               LocalBaseRegReplaceKey
#define BaseRegQueryInfoKey             LocalBaseRegQueryInfoKey
#define BaseRegQueryValue               LocalBaseRegQueryValue
#define BaseRegGetKeySecurity           LocalBaseRegGetKeySecurity
#define BaseRegSetKeySecurity           LocalBaseRegSetKeySecurity
#define BaseRegRestoreKey               LocalBaseRegRestoreKey
#define BaseRegSaveKey                  LocalBaseRegSaveKey
#define BaseRegSaveKeyEx                LocalBaseRegSaveKeyEx
#define BaseRegSetValue                 LocalBaseRegSetValue
#define BaseRegQueryMultipleValues      LocalBaseRegQueryMultipleValues
#define BaseRegGetVersion               LocalBaseRegGetVersion


//
// Predefined handle functions.
//

#define OpenClassesRoot                 LocalOpenClassesRoot
#define OpenCurrentUser                 LocalOpenCurrentUser
#define OpenLocalMachine                LocalOpenLocalMachine
#define OpenUsers                       LocalOpenUsers
#define OpenPerformanceData             LocalOpenPerformanceData
#define OpenPerformanceText             LocalOpenPerformanceText
#define OpenPerformanceNlsText          LocalOpenPerformanceNlsText
#define OpenCurrentConfig               LocalOpenCurrentConfig
#define OpenDynData                     LocalOpenDynData


//
// Initialization and cleanup functions.
//

#define InitializeRegCreateKey          LocalInitializeRegCreateKey
#define CleanupRegCreateKey             LocalCleanupRegCreateKey


//
// No RPC Impersonation needed in the local case.
//

#define RPC_IMPERSONATE_CLIENT( Handle ) 
#define RPC_REVERT_TO_SELF()

#define REGSEC_CHECK_HANDLE( Handle )           ( 0 )
#define REGSEC_FLAG_HANDLE( Handle, Flag )      ( Handle )
#define REGSEC_TEST_HANDLE( Handle, Flag )      ( Handle )
#define REGSEC_CLEAR_HANDLE( Handle )           ( Handle )
#define REGSEC_CHECK_REMOTE( Key )              ( 1 )
#define REGSEC_CHECK_PATH( Key, Path )          ( 1 )

#else


//
// Impersonate the client.
//

#define RPC_IMPERSONATE_CLIENT( Handle )                        \
    {                                                           \
        RPC_STATUS _rpcstatus = RpcImpersonateClient( NULL );   \
        if (_rpcstatus != ERROR_SUCCESS) {                      \
            return(_rpcstatus);                                 \
        }                                                       \
    }

#define RPC_REVERT_TO_SELF() RpcRevertToSelf()

#define CHECK_MACHINE_PATHS     0x00000001
#define CHECK_USER_PATHS        0x00000002

#define REGSEC_CHECK_HANDLE( Handle )   ((LONG)(ULONG_PTR) (Handle) & (CHECK_MACHINE_PATHS | CHECK_USER_PATHS))
#define REGSEC_FLAG_HANDLE( Handle, Flag )    LongToHandle(HandleToLong(Handle) | Flag)
#define REGSEC_TEST_HANDLE( Handle, Flag )  ((LONG)(ULONG_PTR) (Handle) & Flag )
#define REGSEC_CLEAR_HANDLE( Handle )   LongToHandle(HandleToLong(Handle) & ~(CHECK_MACHINE_PATHS | CHECK_USER_PATHS))
#define REGSEC_CHECK_REMOTE( Key )              ( RegSecCheckRemoteAccess( Key ) )
#define REGSEC_CHECK_PATH( Key, Path )          ( RegSecCheckPath( Key, Path ) )


#endif // LOCAL

NTSTATUS RelinkMachineKey( 
   LPWSTR lpSubDirName, 
   PUNICODE_STRING lpSubKey,
   HKEY  hKey );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regclass.h ===
/*++


Copyright (c) 1992  Microsoft Corporation

Module Name:

    regclass.h

Abstract:

    This file contains declarations needed for manipulating
    the portion of the registry that contains class registrations

Author:

    Adam Edwards (adamed) 14-Nov-1997

Notes:

--*/

#if defined( LOCAL )

//
// Declarations
//

#define LENGTH( str )   ( sizeof( str ) - sizeof( UNICODE_NULL ))
#define INIT_SPECIALKEY(x) {LENGTH(x), LENGTH(x), x}

#define REG_CLASSES_FIRST_DISTINCT_ICH 10

#define REG_CHAR_SIZE sizeof(WCHAR)

#define REG_USER_HIVE_NAME L"\\Registry\\User"
#define REG_USER_HIVE_NAMELEN LENGTH(REG_USER_HIVE_NAME)
#define REG_USER_HIVE_NAMECCH (REG_USER_HIVE_NAMELEN / REG_CHAR_SIZE)

#define REG_USER_HIVE_CLASSES_SUFFIX L"_Classes"
#define REG_USER_HIVE_CLASSES_SUFFIXLEN LENGTH(REG_USER_HIVE_CLASSES_SUFFIX)
#define REG_USER_HIVE_CLASSES_SUFFIXCCH (REG_USER_HIVE_CLASSES_SUFFIXLEN / REG_CHAR_SIZE)

#define REG_MACHINE_CLASSES_HIVE_NAME L"\\Registry\\Machine\\Software\\Classes"
#define REG_MACHINE_CLASSES_HIVE_NAMELEN LENGTH(REG_MACHINE_CLASSES_HIVE_NAME)
#define REG_MACHINE_CLASSES_HIVE_NAMECCH (REG_MACHINE_CLASSES_HIVE_NAMELEN / REG_CHAR_SIZE)

#define REG_USER_HIVE_LINK_TREE L"\\Software\\Classes"

#define REG_CLASSES_HIVE_MIN_NAMELEN REG_USER_HIVE_CLASSES_SUFFIXLEN + REG_USER_HIVE_NAMELEN

//
// The difference between these two paths
// \Registry\User\<sid>_Classes and
// \Registry\User\<siid>\Software\Classes
//
// plus extra for the translation from machine to user -- take into account the sid
//
#define REG_CLASSES_SUBTREE_PADDING 128

#define REG_MAX_CLASSKEY_LEN 384
#define REG_MAX_CLASSKEY_CCH (REG_MAX_CLASSKEY_LEN / REG_CHAR_SIZE)

#define REG_MAX_KEY_LEN 512
#define REG_MAX_KEY_CCH (REG_MAX_KEY_LEN / REG_CHAR_SIZE)

#define REG_MAX_KEY_PATHLEN 65535


//
// HKCR Handle Tags for Per-user Class Registration.
//
// Subkeys of HKCR up to and including a class registration parent key are tagged
// by setting two free bits in their handle value (the lower two bits of a handle
// are free to be used as tags).  This makes it easy to tell if a key is in
// HKCR and needs special treatment.  After the class registration part of a path,
// this marker is not needed since such keys do not require special treatment
// for enumeration, opening, and deletion.
//

//
// Note that for the sake of speed we are using 1 bit instead of a specific pattern of
// two bits.  Currently, bit 0 is used to mark remote handles.  Bit 2 is used in the
// server only to mark restricted keys.  Locally, we use it to mark hkcr keys.  More
// Here is a list of valid combinations -- unused bits must be 0. Invalid means that
// in the current implementation, you should never see it in that part of the registry.
//

//
//  Local                       Server                               Client (application sees these)
//  00  (non HKCR, unused)      00 (unrestricted, unused)            00 (non HKCR, local)
//  01  Invalid (HKCR, unused)  01 Invalid (unrestricted, unused)    01 (non HKCR, remote)
//  10  (HKCR, unused)          10 (restricted, unused)              10 (HKCR, local)
//  11  Invalid (HKCR, unused)  11 Invalid (restricted, unused)      11 Invalid (HKCR, remote)
//

//
//  Note that we could use either 10 or 11 to mark HKCR handles -- we chose 10 for simplicity's
//  sake since it simply involves oring in a bit. This can be changed in the future
//  if yet another bit pattern is needed. Otherwise, clients never see 11 -- they only see
//  00, 01, and 10. Note that these bits must be propagated to the local portion. This is done
//  simply by leaving the bits as-is, because local doesn't use any of the bits.  Note that
//  we would be broken if the bits needed to propagate to server for some reason, since it
//  is using bit 2 already.  We do not allow HKCR as a remote handle, however, so this is
//  not a problem.
//

#define REG_CLASS_HANDLE_MASK 0x3

#define REG_CLASS_HANDLE_VALUE 0x2
#define REG_CLASS_IS_SPECIAL_KEY( Handle )     ( (LONG) ( ( (ULONG_PTR) (Handle) ) & REG_CLASS_HANDLE_VALUE ) )
#define REG_CLASS_SET_SPECIAL_KEY( Handle )    ( (HANDLE) ( (  (ULONG_PTR) (Handle) ) | \
                                                            REG_CLASS_HANDLE_VALUE ) )

#define REG_CLASS_RESET_SPECIAL_KEY( Handle )  ( (HANDLE) ( ( ( (ULONG_PTR) (Handle) ) & ~REG_CLASS_HANDLE_MASK )))

#if defined(_REGCLASS_MALLOC_INSTRUMENTED_)

extern RTL_CRITICAL_SECTION gRegClassHeapCritSect;
extern DWORD                gcbAllocated;
extern DWORD                gcAllocs;
extern DWORD                gcbMaxAllocated;
extern DWORD                gcMaxAllocs;
extern PVOID                gpvAllocs;

__inline PVOID RegClassHeapAlloc(SIZE_T cbSize)
{
    PVOID pvAllocation;

    pvAllocation = RtlAllocateHeap(RtlProcessHeap(), 0, cbSize + sizeof(SIZE_T));

    RtlEnterCriticalSection(&gRegClassHeapCritSect);

    if (pvAllocation) {
        gcbAllocated += cbSize;
        gcAllocs ++;
        (ULONG_PTR) gpvAllocs ^= (ULONG_PTR) pvAllocation;

        if (gcAllocs > gcMaxAllocs) {
            gcMaxAllocs = gcAllocs;
        }

        if (gcbAllocated > gcbMaxAllocated) {
            gcbMaxAllocated = gcbAllocated;
        }
    }

    RtlLeaveCriticalSection(&gRegClassHeapCritSect);

    *((SIZE_T*) pvAllocation) = cbSize;

    ((SIZE_T*) pvAllocation) ++;

    return pvAllocation;
}

__inline BOOLEAN RegClassHeapFree(PVOID pvAllocation)
{
    BOOLEAN bRetVal;
    SIZE_T  cbSize;

    ((SIZE_T*) pvAllocation) --;

    cbSize = *((SIZE_T*) pvAllocation);

    bRetVal = RtlFreeHeap(RtlProcessHeap(), 0, pvAllocation);

    RtlEnterCriticalSection(&gRegClassHeapCritSect);

    gcbAllocated -= cbSize;
    gcAllocs --;

    (ULONG_PTR) gpvAllocs ^= (ULONG_PTR) pvAllocation;

    RtlLeaveCriticalSection(&gRegClassHeapCritSect);

    if (!bRetVal) {
        DbgBreakPoint();
    }

    return bRetVal;
}

#else // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

#define RegClassHeapAlloc(x) RtlAllocateHeap(RtlProcessHeap(), 0, x)
#define RegClassHeapFree(x) RtlFreeHeap(RtlProcessHeap(), 0, x)

#endif // defined(_REGCLASS_MALLOC_INSTRUMENTED_)

enum
{
    LOCATION_MACHINE =     0x1,
    LOCATION_USER =        0x2,
    LOCATION_BOTH =        0x3
};


//
// SKeySemantics
//
// This structure is the result of parsing a registry key full path
//
// ATTENTION: This structure, along with the current parsing code, needs to
// be overhauled.  Originally, it was designed to do one thing. Now, it
// identifies several parts of keys.  The original goal was speed --
// we attempted to touch the least amount of string (memory) possible.
// As more functionality was added to the parser, this became more complex.
// A better solution would pay more attention to a generic, straightforward
// way of parsing the key -- things have become far too convoluted in
// an attempt to be fast.
//

typedef struct _SKeySemantics
{
    /* out */     unsigned _fUser              : 1;     // this key is rooted in the user hive
    /* out */     unsigned _fMachine           : 1;     // this key is rooted in the machine hive
    /* out */     unsigned _fCombinedClasses   : 1;     // this key is rooted in the combined classes hive
    /* out */     unsigned _fClassRegistration : 1;     // this key is a class registration key
    /* out */     unsigned _fClassRegParent    : 1;     // this key is a special key (parent of a class reg key)
    /* out */     unsigned _fAllocedNameBuf    : 1;     // nonzero if _pFullPath was realloc'd and needs to be freed
    /* out */     USHORT   _ichKeyStart;                // index to start of a class reg after
                                                        //     \\software\\classes in the returned full path
    /* out */     USHORT   _cbPrefixLen;                // length of prefix
    /* out */     USHORT   _cbSpecialKey;               // length of special key
    /* out */     USHORT   _cbClassRegKey;              // length of class reg key name
    /* in, out */ ULONG    _cbFullPath;                 // size of the KEY_NAME_INFORMATION passed in
    /* out */     PKEY_NAME_INFORMATION _pFullPath;     // address of an OBJECT_NAME_INFORMATION structure
} SKeySemantics;


//
// External Prototypes
//

//
// Opens the HKCR predefined handle with the combined view
//
error_status_t OpenCombinedClassesRoot(
    IN REGSAM samDesired,
    OUT HANDLE * phKey);

//
// Parses a registry key and returns results
//
NTSTATUS BaseRegGetKeySemantics(
    HKEY hkParent,
    PUNICODE_STRING pSubKey,
    SKeySemantics* pKeySemantics);
//
// Frees resources associated with an SKeySemantics structure
//
void BaseRegReleaseKeySemantics(SKeySemantics* pKeySemantics);

//
// Opens a class key that exists in either
// HKLM or HKCU
//
NTSTATUS BaseRegOpenClassKey(
    HKEY            hKey,
    PUNICODE_STRING lpSubKey,
    DWORD           dwOptions,
    REGSAM          samDesired,
    PHKEY           phkResult);

//
// Opens a class key from a specified set
// of locations
//
NTSTATUS BaseRegOpenClassKeyFromLocation(
    SKeySemantics*  pKeyInfo,
    HKEY            hKey,
    PUNICODE_STRING lpSubKey,
    REGSAM          samDesired,
    DWORD           dwLocation,
    HKEY*           phkResult);

//
// Returns key objects for the user and machine
// versions of a key
//
NTSTATUS BaseRegGetUserAndMachineClass(
    SKeySemantics*  pKeySemantics,
    HKEY            Key,
    REGSAM          samDesired,
    PHKEY           phkMachine,
    PHKEY           phkUser);


//
// Internal Prototypes
//

USHORT BaseRegGetUserPrefixLength(
    PUNICODE_STRING pFullPath);

USHORT BaseRegCchSpecialKeyLen(
    PUNICODE_STRING pFullPath,
    USHORT          ichSpecialKeyStart,
    SKeySemantics*  pKeySemantics);

NTSTATUS BaseRegTranslateToMachineClassKey(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pMachineClassKey,
    USHORT*         pPrefixLen);

NTSTATUS BaseRegTranslateToUserClassKey(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pUserClassKey,
    USHORT*         pPrefixLen);

NTSTATUS BaseRegOpenClassKeyRoot(
    SKeySemantics*  pKeyInfo,
    PHKEY           phkClassRoot,
    PUNICODE_STRING pClassKeyPath,
    BOOL            fMachine);

NTSTATUS BaseRegMapClassRegistrationKey(
    HKEY              hKey,
    PUNICODE_STRING   pSubKey,
    SKeySemantics*    pKeyInfo,
    PUNICODE_STRING   pDestSubKey,
    BOOL*             pfRetryOnAccessDenied,
    PHKEY             phkDestResult,
    PUNICODE_STRING*  ppSubKeyResult);

NTSTATUS BaseRegMapClassOnAccessDenied(
    SKeySemantics*    pKeySemantics,
    PHKEY             phkDest,
    PUNICODE_STRING   pDestSubKey,
    BOOL*             pfRetryOnAccessDenied);

NTSTATUS CreateMultipartUserClassKey(
    IN HKEY hKey,
    OUT PHKEY phkResult);

NTSTATUS GetFixedKeyInfo(
    HKEY     hkUser,
    HKEY     hkMachine,
    LPDWORD  pdwUserValues,
    LPDWORD  pdwMachineValues,
    LPDWORD  pdwUserMaxDataLen,
    LPDWORD  pdwMachineMaxDataLen,
    LPDWORD  pdwMaxValueNameLen);

BOOL InitializeClassesNameSpace();

extern BOOL gbCombinedClasses;


//
// Inline functions
//

enum
{
    REMOVEPREFIX_DISCARD_INITIAL_PATHSEP = 0,
    REMOVEPREFIX_KEEP_INITIAL_PATHSEP = 1
};

__inline void KeySemanticsRemovePrefix(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pDestination,
    DWORD           dwFlags)
{
    BOOL fMoveBack;

    fMoveBack = (dwFlags & REMOVEPREFIX_KEEP_INITIAL_PATHSEP) &&
        (pKeyInfo->_pFullPath->Name[pKeyInfo->_ichKeyStart]);

    pDestination->Buffer = &(pKeyInfo->_pFullPath->Name[pKeyInfo->_ichKeyStart -
                                                              (fMoveBack ? 1 : 0)]);

    pDestination->Length = (USHORT) pKeyInfo->_pFullPath->NameLength -
        ((pKeyInfo->_ichKeyStart - (fMoveBack ? 1 : 0))  * REG_CHAR_SIZE);
}

__inline void KeySemanticsGetSid(
    SKeySemantics*  pKeyInfo,
    PUNICODE_STRING pSidString)
{
    pSidString->Buffer = &(pKeyInfo->_pFullPath->Name[REG_USER_HIVE_NAMECCH]);

    pSidString->Length = pKeyInfo->_cbPrefixLen -
            (REG_USER_HIVE_CLASSES_SUFFIXLEN + REG_USER_HIVE_NAMELEN);
}

__inline void KeySemanticsTruncatePrefixToClassReg(
    SKeySemantics*  pKeyInfo,
    USHORT          PrefixLen,
    PUNICODE_STRING pDestination)
{
    pDestination->Length = PrefixLen + (pKeyInfo->_fClassRegistration ? REG_CHAR_SIZE : 0) +
        pKeyInfo->_cbSpecialKey + pKeyInfo->_cbClassRegKey;
}

BOOL
ExtractClassKey(
        IN OUT HKEY *phKey,
        IN OUT PUNICODE_STRING lpSubKey);

#else // LOCAL

#define REG_CLASS_IS_SPECIAL_KEY( Handle )     0
#define REG_CLASS_SET_SPECIAL_KEY( Handle )    (Handle)
#define REG_CLASS_RESET_SPECIAL_KEY( Handle )  (Handle)

#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\predefh.c ===
/*++


Copyright (c) 1991 Microsoft Corporation

Module Name:

    Predefh.c

Abstract:

    This module contains routines for opening the Win32 Registry API's
    predefined handles.

    A predefined handle is used as a root to an absolute or relative
    sub-tree in the real Nt Registry. An absolute predefined handle maps
    to a specific key within the Registry. A relative predefined handle
    maps to a key relative to some additional information such as the
    current user.

    Predefined handles are strictly part of the Win32 Registry API. The
    Nt Registry API knows nothing about them.

    A predefined handle can be used anywhere that a non-predefined handle
    (i.e. one returned from RegCreateKey(), RegOpenKey() or
    RegConnectRegistry()) can be used.

Author:

    David J. Gilman (davegi) 15-Nov-1991

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "ntconreg.h"
#include "regsec.h"
#ifdef LOCAL
#include "tsappcmp.h"

#if defined(LEAK_TRACK) 
#include "regleak.h"
#endif // LEAK_TRACK
#endif

//
// Determine the length of a Unicode string w/o the trailing NULL.
//

#define LENGTH( str )   ( sizeof( str ) - sizeof( UNICODE_NULL ))

//
// Nt Registry name space.
//

#define MACHINE         L"\\REGISTRY\\MACHINE"

#define USER            L"\\REGISTRY\\USER"

#define CLASSES         L"\\REGISTRY\\MACHINE\\SOFTWARE\\CLASSES"

#define CLASSES_SUFFIX  L"\\SOFTWARE\\CLASSES"

#define CURRENTCONFIG   L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\HARDWARE PROFILES\\CURRENT"



UNICODE_STRING          MachineStringKey = {
                            LENGTH( MACHINE ),
                            LENGTH( MACHINE ),
                            MACHINE
                            };

UNICODE_STRING          UserStringKey = {
                            LENGTH( USER ),
                            LENGTH( USER ),
                            USER
                        };

UNICODE_STRING          ClassesStringKey = {
                            LENGTH( CLASSES ),
                            LENGTH( CLASSES ),
                            CLASSES
                        };

UNICODE_STRING          CurrentConfigStringKey = {
                            LENGTH( CURRENTCONFIG ),
                            LENGTH( CURRENTCONFIG ),
                            CURRENTCONFIG
                        };


NTSTATUS
InitSecurityAcls(PSECURITY_DESCRIPTOR *SecurityDescriptor)
/*++

Routine Description:

    Gives GENERIC_ALL to admins and denies WRITE_OWNER | WRITE_DAC  from everyone

Arguments:


Return Value:


--*/
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID                        BuiltInAdministrators = NULL;
    PSID                        Everyone = NULL;
    NTSTATUS                    Status;
    ULONG                       AclSize;
    ACL                         *Acl;

    *SecurityDescriptor = NULL;

    Status = RtlAllocateAndInitializeSid(
              &WorldAuthority,
              1,
              SECURITY_WORLD_RID,
              0,0,0,0,0,0,0,
              &Everyone );
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = RtlAllocateAndInitializeSid(
              &NtAuthority,
              2,
              SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS,
              0,0,0,0,0,0,
              &BuiltInAdministrators );

    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }



    AclSize = sizeof (ACL) +
        (2 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
        GetLengthSid(BuiltInAdministrators) +
        GetLengthSid(Everyone);

    *SecurityDescriptor = (PSECURITY_DESCRIPTOR)RtlAllocateHeap( RtlProcessHeap(), 0, SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);
    if (!*SecurityDescriptor) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    } 

    Acl = (ACL *)((BYTE *)(*SecurityDescriptor) + SECURITY_DESCRIPTOR_MIN_LENGTH);

    Status = RtlCreateAcl(  Acl,
                            AclSize,
                            ACL_REVISION);
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = RtlAddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    (KEY_ALL_ACCESS & ~(WRITE_OWNER | WRITE_DAC)),
                                    Everyone);
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = RtlAddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    GENERIC_ALL,
                                    BuiltInAdministrators);
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = RtlCreateSecurityDescriptor(
                *SecurityDescriptor,
                SECURITY_DESCRIPTOR_REVISION
                );
    if( !NT_SUCCESS(Status) ) {
        goto Exit;
    }

    Status = RtlSetDaclSecurityDescriptor(  *SecurityDescriptor,
                                            TRUE,
                                            Acl,
                                            FALSE);

Exit:
    if( Everyone ) {
        RtlFreeSid( Everyone );
    }
    
    if( BuiltInAdministrators ) {
        RtlFreeSid( BuiltInAdministrators );
    }

    return Status;
}


error_status_t
OpenClassesRoot(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_CLASSES_ROOT predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\MACHINE\SOFTWARE\CLASSES.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    PSECURITY_DESCRIPTOR     SecurityDescriptor = NULL;
    OBJECT_ATTRIBUTES       Obja;
    NTSTATUS                Status;
    UNICODE_STRING          UsersHive;
    UNICODE_STRING          UsersMergedHive;
    error_status_t          Res;

    UNREFERENCED_PARAMETER( ServerName );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

#ifdef LOCAL
    //
    // Multiuser CLASSES key so each user has their own key.  If opening
    // CLASSES in execute mode - open it under HKEY_CURRENT_USER else
    // just let it fall thru here and open the global one.
    //
    if (gpfnTermsrvOpenUserClasses) {
        Status = gpfnTermsrvOpenUserClasses(samDesired,phKey);
    } else {
        *phKey = NULL;
    }
    if (!(*phKey)) {
#endif // LOCAL


    //
    // Initialize the SECURITY_DESCRIPTOR.
    //
    Status = InitSecurityAcls(&SecurityDescriptor);

    if( ! NT_SUCCESS( Status )) {
        goto error_exit;
    }


#ifdef LOCAL

    if (gbCombinedClasses) {
        // first try for a per-user HKCR
        Res = OpenCombinedClassesRoot( samDesired, phKey );

        if ( NT_SUCCESS( Res ) ) {
            goto error_exit;
        }
    }
#endif

    //
    // Initialize the OBJECT_ATTRIBUTES structure so that it creates
    // (opens) the key "\REGISTRY\MACHINE\SOFTWARE\CLASSES" with a Security
    // Descriptor that allows everyone complete access.
    //

    InitializeObjectAttributes(
        &Obja,
        &ClassesStringKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        SecurityDescriptor
        );

    Status = NtCreateKey(
                phKey,
                samDesired, // MAXIMUM_ALLOWED,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );
#ifdef LOCAL
    }
#endif // LOCAL

#if DBG
        if( ! NT_SUCCESS( Status )) {
            DbgPrint(
                "Winreg Server: "
                "Creating HKEY_CLASSES_ROOT failed, status = 0x%x\n",
                Status
                );
        }
#endif

error_exit:
    
    if( SecurityDescriptor != NULL ) {
	RtlFreeHeap( RtlProcessHeap(), 0, SecurityDescriptor );
    }
    RPC_REVERT_TO_SELF();
    return (error_status_t)RtlNtStatusToDosError( Status );
}

error_status_t
OpenCurrentUser(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_CURRENT_USER predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\USER\*.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    NTSTATUS            Status;

    UNREFERENCED_PARAMETER( ServerName );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    // Open the registry key.
    //

    Status = RtlOpenCurrentUser( samDesired, /* MAXIMUM_ALLOWED, */ phKey );

    RPC_REVERT_TO_SELF();
    //
    // Map the returned status
    //

    return (error_status_t)RtlNtStatusToDosError( Status );
}

error_status_t
OpenLocalMachine(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempt to open the the HKEY_LOCAL_MACHINE predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\MACHINE.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;

    UNREFERENCED_PARAMETER( ServerName );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    InitializeObjectAttributes(
        &Obja,
        &MachineStringKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(
                phKey,
                samDesired, // MAXIMUM_ALLOWED,
                &Obja
                );
#if DBG
        if( ! NT_SUCCESS( Status )) {
            DbgPrint(
                "Winreg Server: "
                "Opening HKEY_LOCAL_MACHINE failed, status = 0x%x\n",
                Status
                );
        }
#endif

    if ( NT_SUCCESS( Status ) )
    {
        if (! REGSEC_CHECK_REMOTE( phKey ) )
        {
            *phKey = REGSEC_FLAG_HANDLE( *phKey, CHECK_MACHINE_PATHS );
        }
    }

    RPC_REVERT_TO_SELF();

    return (error_status_t)RtlNtStatusToDosError( Status );
}

error_status_t
OpenUsers(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_USERS predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\USER.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;

    UNREFERENCED_PARAMETER( ServerName );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    InitializeObjectAttributes(
        &Obja,
        &UserStringKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(
                phKey,
                samDesired, // MAXIMUM_ALLOWED,
                &Obja
                );
#if DBG
        if( ! NT_SUCCESS( Status )) {
            DbgPrint(
                "Winreg Server: "
                "Opening HKEY_USERS failed, status = 0x%x\n",
                Status
                );
        }
#endif

    if ( NT_SUCCESS( Status ) )
    {
        if (! REGSEC_CHECK_REMOTE( phKey ) )
        {
            *phKey = REGSEC_FLAG_HANDLE( *phKey, CHECK_USER_PATHS );
        }
    }

    RPC_REVERT_TO_SELF();

    return (error_status_t)RtlNtStatusToDosError( Status );
}

error_status_t
OpenCurrentConfig(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_CURRENT_CONFIG predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\HARDWARE PROFILES\CURRENT

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status;

    UNREFERENCED_PARAMETER( ServerName );

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    InitializeObjectAttributes(
        &Obja,
        &CurrentConfigStringKey,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(
                phKey,
                samDesired, // MAXIMUM_ALLOWED,
                &Obja
                );
#if DBG
        if( ! NT_SUCCESS( Status )) {
            DbgPrint(
                "Winreg Server: "
                "Opening HKEY_CURRENT_CONFIG failed, status = 0x%x\n",
                Status
                );
        }
#endif
    RPC_REVERT_TO_SELF();

    return (error_status_t)RtlNtStatusToDosError( Status );
}
error_status_t
OpenPerformanceData(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_PERFORMANCE_DATA predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - Not used.
    phKey - Returns a the predefined handle HKEY_PERFORMANCE_DATA.

Return Value:

    Returns ERROR_SUCCESS (0) for success;
    or a DOS (not NT) error-code for failure.

--*/

{
    IO_STATUS_BLOCK IoStatusBlock;
    RTL_RELATIVE_NAME RelativeName;
    UNICODE_STRING DeviceNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING DeviceName;
    NTSTATUS status;

    if ( 0 ) {
        DBG_UNREFERENCED_PARAMETER(ServerName);
        DBG_UNREFERENCED_PARAMETER(samDesired);
    }

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    if ( ! REGSEC_CHECK_REMOTE( phKey ) )
    {
        RPC_REVERT_TO_SELF();
        return( ERROR_ACCESS_DENIED );
    }

    // check if we are in the middle of Lodctr/unlodctr.
    // if so, don't open the performance data stuff.
    {
    HANDLE  hFileMapping = NULL;
    WCHAR MapFileName[] = L"Perflib Busy";
    DWORD             *lpData;
    BOOL    bBusy = FALSE;

    hFileMapping = OpenFileMappingW (FILE_MAP_READ, TRUE, (LPCWSTR)MapFileName);
    if (hFileMapping) {
        // someone is running lodctr perhaps find out by reading the first DWORD
        lpData = MapViewOfFile (hFileMapping,
                FILE_MAP_READ, 0L, 0L, 0L);
        if (lpData) {
             // successfully mapped so read it
             // 1 = busy, 0 = not
             bBusy = (BOOL)(*lpData);
             UnmapViewOfFile (lpData);
        }
        CloseHandle (hFileMapping);
        if (bBusy) {
            *phKey = (RPC_HKEY) HKEY_PERFORMANCE_DATA;
            RPC_REVERT_TO_SELF();
            return ERROR_SUCCESS;
        }
    } else {
        // no lodctr so continue
    }
    }
    status  = PerfOpenKey();

    RPC_REVERT_TO_SELF();

    *phKey = (RPC_HKEY) HKEY_PERFORMANCE_DATA;
    return ERROR_SUCCESS;

    RPC_REVERT_TO_SELF();
    return status;
}

error_status_t
OpenPerformanceText(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_PERFORMANCE_TEXT predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - Not used.
    phKey - Returns the predefined handle HKEY_PERFORMANCE_TEXT.

Return Value:

    Returns ERROR_SUCCESS (0) for success;
    or a DOS (not NT) error-code for failure.

--*/

{
    error_status_t Status = ERROR_SUCCESS;

// No need to call OpenPerformanceData for getting text (HWC 4/1994)
//    Status = OpenPerformanceData(ServerName, samDesired, phKey);
//    if (Status==ERROR_SUCCESS) {
        *phKey = HKEY_PERFORMANCE_TEXT;
//    }
    return(Status);
}

error_status_t
OpenPerformanceNlsText(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )

/*++

Routine Description:

    Attempts to open the the HKEY_PERFORMANCE_TEXT predefined handle.

Arguments:

    ServerName - Not used.
    samDesired - Not used.
    phKey - Returns the predefined handle HKEY_PERFORMANCE_NLSTEXT.

Return Value:

    Returns ERROR_SUCCESS (0) for success;
    or a DOS (not NT) error-code for failure.

--*/

{
    error_status_t Status = ERROR_SUCCESS;

// No need to call OpenPerformanceData for getting text (HWC 4/1994)
//    Status = OpenPerformanceData(ServerName, samDesired, phKey);
//    if (Status==ERROR_SUCCESS) {
        *phKey = HKEY_PERFORMANCE_NLSTEXT;
//    }
    return(Status);
}


error_status_t
OpenDynData(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN REGSAM samDesired,
    OUT PRPC_HKEY phKey
    )
/*++

Routine Description:

    Attempts to open the the HKEY_DYN_DATA predefined handle.

    There is currently no HKEY_DYN_DATA on NT, thus this
    function always returns ERROR_CALL_NOT_IMPLEMENTED.

Arguments:

    ServerName - Not used.
    samDesired - This access mask describes the desired security access
                 for the key.
    phKey - Returns a handle to the key HKEY_DYN_DATA

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    return((error_status_t)ERROR_CALL_NOT_IMPLEMENTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regdval.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regdval.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry API to delete values from keys. That is:

        - BaseRegDeleteValue

Author:

    David J. Gilman (davegi) 15-Nov-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#ifdef LOCAL
#include "tsappcmp.h"
#include "regclass.h"
#endif


error_status_t
BaseRegDeleteValue (
    HKEY hKey,
    PUNICODE_STRING lpValueName
    )

/*++

Routine Description:

    Remove the named value from the specified key.

Arguments:

    hKey - Supplies a handle to the open key.

    lpValueName - Supplies the name of the value to remove.  lpValueName
        may be NULL.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    hKey must have been opened for KEY_SET_VALUE.

--*/

{
    HKEY                            hkDelete;
    NTSTATUS                        Status;
#ifdef LOCAL

    HKEY                            hkUserClasses;
    HKEY                            hkMachineClasses;

    hkUserClasses = NULL;
    hkMachineClasses = NULL;

#endif

    hkDelete = hKey;

    //
    //  Subtract the NULL from the string length. This was added
    //  by the client so that RPC would transmit the whole thing.
    //
    lpValueName->Length -= sizeof( UNICODE_NULL );

    //
    // Call the Nt Api to delete the value, map the NTSTATUS code to a
    // Win32 Registry error code and return.
    //

#ifdef LOCAL
    if (gpfnTermsrvDeleteValue) {
        //
        // Remove the value from the Terminal Server registry tracking database
        //
        gpfnTermsrvDeleteValue(hKey, lpValueName);
    }
#endif

#ifdef LOCAL
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

        Status = BaseRegGetUserAndMachineClass(
            NULL,
            hkDelete,
            MAXIMUM_ALLOWED,
            &hkMachineClasses,
            &hkUserClasses);

        if (!NT_SUCCESS(Status)) {
            return (error_status_t)RtlNtStatusToDosError(Status);
        }
    }

    if (hkUserClasses && hkMachineClasses) {
        hkDelete = hkUserClasses;
    }
#endif

    Status = NtDeleteValueKey(
        hkDelete,
        lpValueName
        );

#ifdef LOCAL
    
    //
    // For class keys, try again with machine if there were
    // two keys of the same name
    //
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {
        
        if ((STATUS_OBJECT_NAME_NOT_FOUND == Status) && 
            (hkUserClasses && hkMachineClasses)) {

            Status = NtDeleteValueKey(
                hkMachineClasses,
                lpValueName
                );
        }
    }

    if (hkUserClasses && hkMachineClasses) {
        if (hkUserClasses != hKey) {
            NtClose(hkUserClasses);
        } else {
            NtClose(hkMachineClasses);
        }
    }
#endif // LOCAL

    return (error_status_t)RtlNtStatusToDosError(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regekey.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regekey.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry API to enumerate keys.  That is:

        - BaseRegEnumKey

Author:

    David J. Gilman (davegi) 23-Dec-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regecls.h"
#include <malloc.h>

#define DEFAULT_KEY_NAME_SIZE         128
#define DEFAULT_CLASS_SIZE            128



error_status_t
BaseRegEnumKey (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpName,
    OUT PUNICODE_STRING lpClass OPTIONAL,
    OUT PFILETIME lpftLastWriteTime OPTIONAL
    )

/*++

Routine Description:

    Used to enumerate subkeys of an open key.  This function copies the
    dwIndex-th subkey of hKey.

Arguments:

    hKey - A handle to the open key.  The keys returned are relative to
        the key pointed to by this key handle.  Any of the predefined reserved
        handles or a previously opened key handle may be used for hKey.

    dwIndex - The index of the subkey to return.  Note that this is for
        convenience, subkeys are not ordered (a new subkey has an arbitrary
        index).  Indexes start at 0.

    lpName - Provides a pointer to a buffer to receive the name of the
        key.

    lpClass - If present, provides a pointer to a buffer to receive the
        class of the key.

    lpftLastWriteTime - The time when the value was last written (set or
        created).

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    This function is guaranteed to operate correctly only if dwIndex
    starts at 0 and is incremented on successive calls without intervening
    calls to other registration APIs that will change the key.
    KEY_ENUMERATE_SUB_KEYS access is required.


--*/

{
    NTSTATUS                        Status;
    ULONG                           BufferLength;
    KEY_INFORMATION_CLASS           KeyInformationClass;
    PVOID                           KeyInformation;
    ULONG                           ResultLength;
    BOOL                            fClassKey;

    BYTE         PrivateKeyInformation[ sizeof( KEY_NODE_INFORMATION ) +
                                        DEFAULT_KEY_NAME_SIZE +
                                        DEFAULT_CLASS_SIZE ];

    ASSERT( lpName != NULL );

    //
    // Protect ourselves against malicious callers passing NULL
    // pointers.
    //
    if (lpClass == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Call out to Perflib if the HKEY is HKEY_PERFOMANCE_DATA or
    // HKEY_PERFORMANCE_TEXT or HKEY_PERFORMANCE_NLSTEXT

    if (hKey == HKEY_PERFORMANCE_DATA ||
        hKey == HKEY_PERFORMANCE_TEXT ||
        hKey == HKEY_PERFORMANCE_NLSTEXT ) {
//    if( hKey == HKEY_PERFORMANCE_DATA ) {
        return (error_status_t)PerfRegEnumKey (
                                        hKey,
                                        dwIndex,
                                        lpName,
                                        NULL,
                                        lpClass,
                                        lpftLastWriteTime
                                        );
    }


    //
    //  First we assume that the information we want will fit on
    //  PrivateKeyValueInformattion
    //

    KeyInformationClass = (ARGUMENT_PRESENT( lpClass->Buffer ))?
                               KeyNodeInformation :
                               KeyBasicInformation;


    KeyInformation = PrivateKeyInformation;
    BufferLength = sizeof( PrivateKeyInformation );

    fClassKey = FALSE;
    Status = STATUS_SUCCESS;

    //
    // Query for the necessary information about the supplied key.
    //

#ifdef LOCAL
    //
    // For hkcr, we need to do special enumeration
    //
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {
        
        Status = EnumTableGetNextEnum( &gClassesEnumTable,
                                       hKey,
                                       dwIndex,
                                       KeyInformationClass,
                                       KeyInformation,
                                       BufferLength,
                                       &ResultLength);

        if (!NT_SUCCESS(Status) || (NT_SUCCESS(Status) && ResultLength)) {
            fClassKey = TRUE;
        }
    }
#endif // LOCAL

    if (!fClassKey) {

        Status = NtEnumerateKey( hKey,
                                 dwIndex,
                                 KeyInformationClass,
                                 KeyInformation,
                                 BufferLength,
                                 &ResultLength
            );
    }

    //
    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
    // was not enough room for even the fixed portions of the structure.
    //

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );


    if( Status == STATUS_BUFFER_OVERFLOW ) {
        //
        //  The buffer defined in the stack wasn't big enough to hold
        //  the Key information.
        //  If the caller's buffer are big enough to hold the key name
        //  and key class, then allocate a new buffer, and call the
        //  NT API again.
        //
        if( ( ( KeyInformationClass == KeyBasicInformation ) &&
              ( (ULONG)( lpName->MaximumLength ) >=
                 (( PKEY_BASIC_INFORMATION )
                 KeyInformation )->NameLength + sizeof(UNICODE_NULL)
              )
            ) ||
            ( ( KeyInformationClass == KeyNodeInformation ) &&
              ( (ULONG)(lpName->MaximumLength) >=
                 (( PKEY_NODE_INFORMATION )
                 KeyInformation )->NameLength + sizeof(UNICODE_NULL)
              ) &&
              (
                ARGUMENT_PRESENT( lpClass->Buffer )
              ) &&
              (
                (ULONG)(lpClass->MaximumLength) >= (( PKEY_NODE_INFORMATION )
                        KeyInformation )->ClassLength + sizeof(UNICODE_NULL)
              )
            )
          ) {
            BufferLength = ResultLength;

            KeyInformation = RtlAllocateHeap( RtlProcessHeap( ), 0,
                                              BufferLength
                                            );
            //
            // If the memory allocation fails, return a Registry error.
            //

            if( ! KeyInformation ) {
                return ERROR_OUTOFMEMORY;
            }

            //
            // Query for the necessary information about the supplied key.
            // This may or may not include the class depending on lpClass->Buffer
            // as determined above.
            //

#ifdef LOCAL
            if (fClassKey) {
                //
                // For hkcr, we need to do special enumeration
                //
                Status = EnumTableGetNextEnum( &gClassesEnumTable,
                                               hKey,
                                               dwIndex,
                                               KeyInformationClass,
                                               KeyInformation,
                                               BufferLength,
                                               &ResultLength);

            } else
#endif // LOCAL
            {
                Status = NtEnumerateKey( hKey,
                                         dwIndex,
                                         KeyInformationClass,
                                         KeyInformation,
                                         BufferLength,
                                         &ResultLength
                    );
            }

        }
    }

    if( NT_SUCCESS( Status ) ) {
        //
        //  Copy key name
        //

        if( KeyInformationClass == KeyBasicInformation ) {
            //
            // Return the name length and the name of the key.
            // Note that the NUL byte is included so that RPC copies the
            // correct number of bytes. It is decremented on the client
            // side.
            //

            if( (ULONG)(lpName->MaximumLength) >=
                 (( PKEY_BASIC_INFORMATION )
                  KeyInformation )->NameLength + sizeof( UNICODE_NULL ) ) {

                lpName->Length = ( USHORT )
                                 (( PKEY_BASIC_INFORMATION )
                                 KeyInformation )->NameLength;

                RtlMoveMemory( lpName->Buffer,
                               (( PKEY_BASIC_INFORMATION )
                               KeyInformation )->Name,
                               lpName->Length
                             );

                //
                // NUL terminate the value name.
                //

                lpName->Buffer[ lpName->Length >> 1 ] = UNICODE_NULL;
                lpName->Length += sizeof( UNICODE_NULL );

            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }

            //
            // If requested, return the last write time.
            //

            if( ARGUMENT_PRESENT( lpftLastWriteTime )) {

                *lpftLastWriteTime
                = *( PFILETIME )
                &(( PKEY_BASIC_INFORMATION ) KeyInformation )
                ->LastWriteTime;
            }

        } else {
            //
            // Return the name length and the name of the key.
            // Note that the NUL byte is included so that RPC copies the
            // correct number of bytes. It is decremented on the client
            // side.
            //

            if( ( (ULONG)(lpName->MaximumLength) >=
                  (( PKEY_NODE_INFORMATION )
                   KeyInformation )->NameLength + sizeof( UNICODE_NULL ) ) &&
                ( (ULONG)(lpClass->MaximumLength) >=
                  (( PKEY_NODE_INFORMATION )
                   KeyInformation )->ClassLength + sizeof( UNICODE_NULL) )
              ) {
                //
                //  Copy the key name
                //
                lpName->Length = ( USHORT )
                                 (( PKEY_NODE_INFORMATION )
                                 KeyInformation )->NameLength;

                RtlMoveMemory( lpName->Buffer,
                               (( PKEY_NODE_INFORMATION )
                               KeyInformation )->Name,
                               lpName->Length
                             );

                //
                // NUL terminate the key name.
                //

                lpName->Buffer[ lpName->Length >> 1 ] = UNICODE_NULL;
                lpName->Length += sizeof( UNICODE_NULL );


                //
                //  Copy the key class
                //

                lpClass->Length = (USHORT)
                    ((( PKEY_NODE_INFORMATION ) KeyInformation )->ClassLength );

                RtlMoveMemory(
                    lpClass->Buffer,
                    ( PBYTE ) KeyInformation
                    + (( PKEY_NODE_INFORMATION ) KeyInformation )->ClassOffset,
                    (( PKEY_NODE_INFORMATION ) KeyInformation )->ClassLength
                    );

                //
                // NUL terminate the class.
                //

                lpClass->Buffer[ lpClass->Length >> 1 ] = UNICODE_NULL;

                lpClass->Length += sizeof( UNICODE_NULL );


            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }

            //
            // If requested, return the last write time.
            //

            if( ARGUMENT_PRESENT( lpftLastWriteTime )) {

                *lpftLastWriteTime
                = *( PFILETIME )
                &(( PKEY_NODE_INFORMATION ) KeyInformation )
                ->LastWriteTime;
            }

        }

    }

    if( KeyInformation != PrivateKeyInformation ) {
        //
        // Free the buffer allocated.
        //

        RtlFreeHeap( RtlProcessHeap( ), 0, KeyInformation );
    }

    return (error_status_t)RtlNtStatusToDosError( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regecls.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regecls.h

Abstract:

    This file contains declarations for data structures
    needed for enumerating keys under HKEY_CLASSES_ROOT

Author:

    Adam Edwards (adamed) 14-Nov-1997

Notes:

--*/

#ifdef LOCAL

#if !defined(_REGECLS_H_)
#define _REGECLS_H_

#include "regstate.h"

#define ENUM_DEFAULT_KEY_NAME_SIZE         128
#define ENUM_DEFAULT_CLASS_SIZE            128

//
// Constants for controlling the direction of enumeration
//
enum
{
    ENUM_DIRECTION_BACKWARD = 0,
    ENUM_DIRECTION_FORWARD = 1,
    ENUM_DIRECTION_IGNORE = 2
};

//
// Constants specifying the physical location of a key being
// enumerated
//
enum 
{
    ENUM_LOCATION_USER = 1,
    ENUM_LOCATION_MACHINE = 2,
    ENUM_LOCATION_NONE = 3
};

//
// Structure for holding the state of an enumeration on a 
// user or machine subtree
//
typedef struct _EnumSubtreeState {
    PKEY_NODE_INFORMATION  pKeyInfo;  // structure holding information about a key
    ULONG                  cbKeyInfo; // size of pKeyInfo
    DWORD                  iSubKey;   // which key we need to ask the kernel for
    BOOL                   Finished;  // TRUE means we are done enumerating this subtree
    union {
        KEY_NODE_INFORMATION;         // Force the buffer to be aligned.
        BYTE                   KeyInfoBuffer[ sizeof( KEY_NODE_INFORMATION ) +
                                            ENUM_DEFAULT_KEY_NAME_SIZE +
                                            ENUM_DEFAULT_CLASS_SIZE ];

    };
} EnumSubtreeState;

//
// Structure for holding the state of enumeration for a registry key
// This structure persists in between calls to RegEnumKeyEx
//
typedef struct _EnumState {

    StateObject            Object;
    unsigned               Direction : 1;
    unsigned               LastLocation : 2;
    unsigned               fClassesRoot : 1;
    HKEY                   hKey;
    HKEY                   hkUserKey;
    HKEY                   hkMachineKey;
    DWORD                  dwLastRequest;
    DWORD                  dwThreadId;
    EnumSubtreeState       UserState;
    EnumSubtreeState       MachineState;

} EnumState;

typedef struct _KeyStateList {

    StateObject     Object;
    StateObjectList StateList;
    EnumState       RootState;

} KeyStateList;

typedef StateObjectList ThreadList;

VOID KeyStateListInit(KeyStateList* pStateList);
VOID KeyStateListDestroy(StateObject* pObject); 

//
// Hash table for storing enumeration states.  This table is indexed
// by (key handle, thread id).
//
typedef struct _EnumTable {

    BOOLEAN                bCriticalSectionInitialized;
    RTL_CRITICAL_SECTION   CriticalSection;
    ThreadList             ThreadEnumList;

} EnumTable;    

//
// Declaration of instance of enumeration table
//
extern EnumTable gClassesEnumTable;

//
// Prototypes for winreg client -- cleanup, init
//
BOOL InitializeClassesEnumTable();
BOOL CleanupClassesEnumTable(BOOL fThisThreadOnly);


//
// functions for managing enumeration state table
//
NTSTATUS EnumTableInit(EnumTable* pEnumTable);

enum
{
    ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD = 1,
    ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD = 2
};

NTSTATUS EnumTableClear(EnumTable* pEnumTable, DWORD dwCriteria);

DWORD EnumTableHashKey(
    EnumTable* pEnumTable,
    HKEY       hKey);

NTSTATUS EnumTableAddKey(
    EnumTable* pEnumTable,
    HKEY       hKey,
    DWORD      dwFirstSubKey,
    EnumState** ppEnumState,
    EnumState** ppRootState);

NTSTATUS EnumTableRemoveKey(
    EnumTable* pEnumTable,
    HKEY       hKey,
    DWORD      dwCriteria);

NTSTATUS EnumTableGetNextEnum(
    EnumTable*            pEnumTable,
    HKEY                  hKey,
    DWORD                 dwSubkey,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID                 pKeyInfo,
    DWORD                 cbKeyInfo,
    LPDWORD               pcbKeyInfo);

NTSTATUS EnumTableGetKeyState(
    EnumTable*  pEnumTable,
    HKEY        hKey,
    DWORD       dwSubkey,
    EnumState** ppEnumState,
    EnumState** ppRootState,
    LPDWORD     pcbKeyInfo);

NTSTATUS EnumTableFindKeyState(
    EnumTable*     pEnumTable,
    HKEY           hKey,
    EnumState**    ppEnumState);

void EnumTableUpdateRootState(
    EnumTable* pEnumTable,
    EnumState* pRootState,
    EnumState* pEnumState,
    BOOL       fResetState);

NTSTATUS EnumTableGetRootState(
    EnumTable*  pEnumTable,
    EnumState** ppRootState);


//
// functions to manage enumeration subtrees
//
void EnumSubtreeStateClear(EnumSubtreeState* pTreeState);

NTSTATUS EnumSubtreeStateCopyKeyInfo(
    EnumSubtreeState*     pTreeState,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID                 pDestKeyinfo,
    ULONG                 cbDestKeyInfo,
    PULONG                pcbResult);

//
// functions for managing key enumeration state
//
NTSTATUS EnumStateInit(
    EnumState*     pEnumState,
    HKEY           hKey,
    DWORD          dwFirstSubKey,
    DWORD          dwDirection,
    SKeySemantics* pKeySemantics);

NTSTATUS EnumStateGetNextEnum(
    EnumState*            pEnumState,
    DWORD                 dwSubkey,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID                 pKeyInfo,
    DWORD                 cbKeyInfo,
    LPDWORD               pcbKeyInfo,
    BOOL*                 pfFreeState);

NTSTATUS EnumStateSetLimits(
    EnumState* pEnumState,
    DWORD      dwSubKey,
    LPDWORD    pdwStart,
    LPDWORD    pdwLimit,
    PLONG      plIncrement);

NTSTATUS EnumStateChooseNext(
    EnumState*         pEnumState,
    DWORD              dwSubKey,
    DWORD              dwStart,
    DWORD              dwLimit,
    LONG               lIncrement,
    EnumSubtreeState** ppTreeState);

NTSTATUS EnumStateCompareSubtrees(
    EnumState*         pEnumState,
    LONG               lIncrement,
    EnumSubtreeState** ppSubtree);

VOID EnumStateClear(EnumState* pEnumState);
VOID EnumStateDestroy(StateObject* pObject);

BOOL EnumStateIsEmpty(EnumState* pEnumState);

NTSTATUS EnumStateCopy(
    EnumState*            pDestState,
    EnumState*            pEnumState);

//
// Utility functions
//    
NTSTATUS EnumClassKey(
    HKEY              hKey,
    EnumSubtreeState* pTreeState);

NTSTATUS GetSubKeyCount(
    HKEY    hkClassKey,
    LPDWORD pdwUserSubKeys);

NTSTATUS ClassKeyCountSubKeys(
    HKEY    hKey,
    HKEY    hkUser,
    HKEY    hkMachine,
    DWORD   cMax,
    LPDWORD pcSubKeys);

__inline BOOL IsRootKey(SKeySemantics* pKeySemantics)
{
    return pKeySemantics->_fClassRegParent;
}

#endif // !defined(_REGECLS_H_)

#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regecls.c ===
/*++



Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegeCls.c

Abstract:

    This module contains helper functions for enumerating
    class registrations via the win32 RegEnumKeyEx api

Author:

    Adam Edwards (adamed) 06-May-1998

Key Functions:

    EnumTableGetNextEnum
    EnumTableRemoveKey
    InitializeClassesEnumTable
    ClassKeyCountSubKeys

Notes:

    Starting with NT5, the HKEY_CLASSES_ROOT key is per-user
    instead of per-machine -- previously, HKCR was an alias for
    HKLM\Software\Classes.  Please see regclass.c for more information
    on this functionality.

    This feature complicates registry key enumeration because certain keys,
    such as CLSID, can have some subkeys that come from HKLM\Software\Classes, and
    other subkeys that come from HKCU\Software\Classes.  Since the feature is
    implemented in user mode, the kernel mode apis know nothing of this.  When it's
    time to enumerate keys, the kernel doesn't know that it should enumerate keys from
    two different parent keys.

    The key problem is that keys with the same name can exist in the user and machine portions.
    When this happens, we choose the user portion is belonging to HKCR -- the other
    one does not exist -- it is "overridden" by the user version. This means that
    we cannot simply enumerate from both places and return the results -- we would
    get duplicates in this case.  Thus, we have to do work in user mode to make
    sure duplicates are not returned.

    This module provides the user mode implementation for enumerating class
    registration keys in HKEY_CLASSES_ROOT.

    The general method is to maintain state between each call to RegEnumKeyEx.  The
    state is kept in a global table indexed by registry key handle and thread id. The
    state allows the api to remember where it is in the enumeration.  The rest of the code
    handles finding the next key, which is accomplished by retrieving keys from both user
    and machine locations.  Since the kernel returns keys from either of these locations in
    sorted order, we can compare the key names and return whichever one is less or greater,
    depending on if we're enumerating upward or downward.  We keep track of where
    we are for both user and machine locations, so we know which key to enumerate
    next and when to stop.

**************************
    IMPORTANT ASSUMPTIONS:
**************************

    This code assumes that the caller has both query permission and enumerate subkey 
    permission in the registry key's acl -- some calls may fail with access denied if the
    acl denies access to the caller.

--*/


#ifdef LOCAL

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regecls.h"
#include <malloc.h>


NTSTATUS QueryKeyInfo(
    HKEY                    hKey,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   *ppKeyInfo,
    ULONG                   BufferLength,
    BOOL                    fClass,
    USHORT                  MaxClassLength);

//
// Global table of registry key enumeration state.  This is initialized
// at dll initialize time.
//
EnumTable gClassesEnumTable;

//
// Global indicating need for calling thread detach routines
//
BOOL gbDllHasThreadState = FALSE;

BOOL InitializeClassesEnumTable()
/*++

Routine Description:

    Initializes the global classes enumeration table when
    advapi32.dll is initialized.

Arguments:

Return Value:

    Returns TRUE for success, FALSE for failure

Notes:
    This recordset merging is all in user mode -- 
    should be moved to the kernel for perf and other reasons ??

--*/
{
    NTSTATUS Status;

    //
    // Init the classes enumeration table
    //
    Status = EnumTableInit(&gClassesEnumTable);

    return NT_SUCCESS(Status);
}

BOOL CleanupClassesEnumTable(BOOL fThisThreadOnly)
/*++

Routine Description:

    Uninitializes the global classes enumeration table when
    advapi32.dll is unloaded -- this frees all
    heap associated with the enumeration table, including
    that for keys which have not been closed. Other resources
    required for the table are also freed.

Arguments:

    dwCriteria - if this is ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD,
       then only the table entries concerning this thread are cleaned up.
       If it is ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD, the table entries
       for all threads in the process are cleaned up.

Return Value:

    TRUE for success, FALSE otherwise.

Notes:

--*/
{
    NTSTATUS Status;
    DWORD    dwCriteria;

    dwCriteria = fThisThreadOnly ? ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD :
        ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD;

    //
    // Clear our enumeration table
    //
    Status = EnumTableClear(&gClassesEnumTable, dwCriteria);

    return NT_SUCCESS(Status);
}

NTSTATUS EnumTableInit(EnumTable* pEnumTable)
/*++

Routine Description:

    Initializes an enumeration state table

Arguments:

    pEnumTable - table to initialize

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    NTSTATUS   Status;
    EnumState* rgNewState;

#if defined(_REGCLASS_ENUMTABLE_INSTRUMENTED_)
    DbgPrint("WINREG: Instrumented enum table data for process id 0x%x\n", NtCurrentTeb()->ClientId.UniqueProcess);
    DbgPrint("WINREG: EnumTableInit subtree state size %d\n", sizeof(rgNewState->UserState));
    DbgPrint("WINREG: EnumTableInit state size %d\n", sizeof(*rgNewState));
    DbgPrint("WINREG: EnumTableInit initial table size %d\n", sizeof(*pEnumTable));
#endif // _REGCLASS_ENUMTABLE_INSTRUMENTED_

    //
    // Initialize the thread list
    //
    StateObjectListInit(
        &(pEnumTable->ThreadEnumList),
        0);

    //
    // We have not initialized the critical section
    // for this table yet -- remember this.
    //
    pEnumTable->bCriticalSectionInitialized = FALSE;

    //
    // Initialize the critical section that will be used to
    // synchronize access to this table
    //
    Status = RtlInitializeCriticalSection(
                    &(pEnumTable->CriticalSection));

    //
    // Remember that we have initialized this critical section
    // so we can remember to delete it.
    //
    pEnumTable->bCriticalSectionInitialized = NT_SUCCESS(Status);

    return Status;
}


NTSTATUS EnumTableClear(EnumTable* pEnumTable, DWORD dwCriteria)
/*++

Routine Description:

    Clears all state in an enumeration table --
    frees all state (memory, resources) memory associated
    with the enumeration table.

Arguments:

    pEnumTable - table to clear
    
    dwCriteria - if this is ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD,
       enumeration states are removed for this thread only.
       If it is ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD, enumeration
       states are removed for all threads in the process.

Return Value:

    none

Notes:

--*/
{
    NTSTATUS    Status;
    BOOL        fThisThreadOnly;
    DWORD       dwThreadId;

#if defined(_REGCLASS_ENUMTABLE_INSTRUMENTED_)
    DWORD        cOrphanedStates = 0;        
#endif // _REGCLASS_ENUMTABLE_INSTRUMENTED_


    ASSERT((ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD == dwCriteria) ||
           (ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD == dwCriteria));

    Status = STATUS_SUCCESS;

    //
    // we assume that if we are called with ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD
    // that we are being called at process detach to remove all keys from the
    // table and free the table itself -- this means that we are the only
    // thread executing this code.
    //

    //
    // Protect ourselves while modifying the table
    //
    if (dwCriteria != ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD) {

        Status = RtlEnterCriticalSection(&(pEnumTable->CriticalSection));

        ASSERT( NT_SUCCESS( Status ) );
        if ( !NT_SUCCESS( Status ) ) {
#if DBG
            DbgPrint( "WINREG: RtlEnterCriticalSection() in EnumTableRemoveKey() failed. Status = %lx \n", Status );
#endif
            return Status;
        }
    }

    fThisThreadOnly = (ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD == dwCriteria);

    //
    // Find our thread id if the caller wants to remove
    // state for just this thread
    //
    if (fThisThreadOnly) {
        
        KeyStateList* pStateList;

        dwThreadId = GetCurrentThreadId();

        pStateList = (KeyStateList*) StateObjectListRemove(
            &(pEnumTable->ThreadEnumList),
            ULongToPtr((const unsigned long)dwThreadId));

        //
        // Announce that this dll no longer stores state for any
        // threads -- used to avoid calls to dll thread
        // detach routines when there's no state to clean up.
        //
        if (StateObjectListIsEmpty(&(pEnumTable->ThreadEnumList))) {
            gbDllHasThreadState = FALSE;
        }

        if (pStateList) {
            KeyStateListDestroy((StateObject*) pStateList);
        }
            
    } else {

        //
        // If we're clearing all threads, just destroy this list
        //
        StateObjectListClear(&(pEnumTable->ThreadEnumList),
                             KeyStateListDestroy);

        gbDllHasThreadState = FALSE;

    }

    //
    // It's safe to unlock the table
    //
    if (dwCriteria != ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD) {

        Status = RtlLeaveCriticalSection(&(pEnumTable->CriticalSection));

        ASSERT( NT_SUCCESS( Status ) );
#if DBG
        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "WINREG: RtlLeaveCriticalSection() in EnumTableClear() failed. Status = %lx \n", Status );
        }
#endif
    }

    if (pEnumTable->bCriticalSectionInitialized && !fThisThreadOnly) {

        Status = RtlDeleteCriticalSection(&(pEnumTable->CriticalSection));

        ASSERT(NT_SUCCESS(Status));

#if DBG
        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "WINREG: RtlDeleteCriticalSection() in EnumTableClear() failed. Status = %lx \n", Status );
        }
#endif

    }

#if defined(_REGCLASS_ENUMTABLE_INSTRUMENTED_)
    if (!fThisThreadOnly) {
        DbgPrint("WINREG: EnumTableClear() deleted %d unfreed states.\n", cOrphanedStates);
        DbgPrint("WINREG: If the number of unfreed states is > 1, either the\n"
                 "WINREG: process terminated a thread with TerminateThread, the process\n"
                 "WINREG: didn't close all registry handles before exiting,\n"
                 "WINREG: or there's a winreg bug in the classes enumeration code\n");
    }
#endif // _REGCLASS_ENUMTABLE_INSTRUMENTED_

    return Status;
}


NTSTATUS EnumTableFindKeyState(
    EnumTable*     pEnumTable,
    HKEY           hKey,
    EnumState**    ppEnumState)
/*++

Routine Description:

   Searches for the state for a registry key in
   an enumeration table

Arguments:

    pEnumTable - table in which to search

    hKey - key for whose state we're searching

    ppEnumState - out param for result of search

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    KeyStateList* pStateList;

    pStateList = (KeyStateList*) StateObjectListFind(
        &(pEnumTable->ThreadEnumList),
        ULongToPtr((const unsigned long)GetCurrentThreadId()));

    if (!pStateList) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    } else {

        *ppEnumState = (EnumState*) StateObjectListFind(
            (StateObjectList*) pStateList,
            hKey);
        
        if (!*ppEnumState) {
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS EnumTableAddKey(
    EnumTable*         pEnumTable,
    HKEY               hKey,
    DWORD              dwFirstSubKey,
    EnumState**        ppEnumState,
    EnumState**        ppRootState)
/*++

Routine Description:

   Adds an enumeration state to
   an enumeration table for a given key.

Arguments:

    pEnumTable - table in which to add state

    hKey - key for whom we want to add state

    dwFirstSubKey - index of first subkey requested by caller
        for enumeration

    ppEnumState - out param for result of search or add

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    EnumState*    pEnumState;
    KeyStateList* pStateList;
    NTSTATUS      Status;
    
    pEnumState = NULL;

    //
    // Announce that this dll has thread state so it will
    // be properly cleaned up by dll thread detach routines
    //
    gbDllHasThreadState = TRUE;

    pStateList = (KeyStateList*) StateObjectListFind(
        (StateObjectList*) &(pEnumTable->ThreadEnumList),
        ULongToPtr((const unsigned long)GetCurrentThreadId()));

    if (!pStateList) {
        
        pStateList = RegClassHeapAlloc(sizeof(*pStateList));

        if (!pStateList) {
            return STATUS_NO_MEMORY;
        }

        KeyStateListInit(pStateList);

        StateObjectListAdd(
            &(pEnumTable->ThreadEnumList),
            (StateObject*) pStateList);
    }

    pEnumState = RegClassHeapAlloc(sizeof(*pEnumState));

    if (!pEnumState) {
        return STATUS_NO_MEMORY;
    }
    
    RtlZeroMemory(pEnumState, sizeof(*pEnumState));

    {
        SKeySemantics  keyinfo;
        UNICODE_STRING EmptyString = {0, 0, 0};
        BYTE           rgNameBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE + sizeof(KEY_NAME_INFORMATION)];
    
        //
        // Set buffer to store info about this key
        //
        RtlZeroMemory(&keyinfo, sizeof(keyinfo));

        keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameBuf;
        keyinfo._cbFullPath = sizeof(rgNameBuf);
        keyinfo._fAllocedNameBuf = FALSE;

        //
        // get information about this key
        //
        Status = BaseRegGetKeySemantics(hKey, &EmptyString, &keyinfo);

        if (!NT_SUCCESS(Status)) {
            goto error_exit;
        }

        //
        // initialize the empty spot
        //
        Status = EnumStateInit(
            pEnumState,
            hKey,
            dwFirstSubKey,
            dwFirstSubKey ? ENUM_DIRECTION_BACKWARD : ENUM_DIRECTION_FORWARD,
            &keyinfo);

        BaseRegReleaseKeySemantics(&keyinfo);

        if (!NT_SUCCESS(Status)) {
            goto error_exit;
        }

        if (IsRootKey(&keyinfo)) {

            NTSTATUS   RootStatus;

            //
            // If this fails, it is not fatal -- it just means
            // we may miss out on an optimization.  This can 
            // fail due to out of memory, so it is possible
            // that it may fail and we would still want to continue
            //
            RootStatus = EnumTableGetRootState(pEnumTable, ppRootState);

#if DBG
            if (!NT_SUCCESS(RootStatus)) {
                DbgPrint( "WINREG: EnumTableAddKey failed to get classes root state. Status = %lx \n", RootStatus );
            }
#endif // DBG


            if (NT_SUCCESS(RootStatus)) {

                RootStatus = EnumStateCopy(
                    pEnumState,
                    *ppRootState);

#if DBG
                if (!NT_SUCCESS(RootStatus)) {
                    DbgPrint( "WINREG: EnumTableAddKey failed to copy key state. Status = %lx \n", RootStatus );
                }
#endif // DBG
            }
        }
    }

    //
    // set the out parameter for the caller
    //
    *ppEnumState = pEnumState;

    StateObjectListAdd(
        (StateObjectList*) pStateList,
        (StateObject*) pEnumState);
    
    Status = STATUS_SUCCESS;

error_exit:

    if (!NT_SUCCESS(Status) && pEnumState) {
        RegClassHeapFree(pEnumState);
    }

    return Status;
}

NTSTATUS EnumTableRemoveKey(
    EnumTable* pEnumTable,
    HKEY       hKey,
    DWORD      dwCriteria)
/*++

Routine Description:

   remove an enumeration state from
   an enumeration table for a given key.

Arguments:

    pEnumTable - table in which to remove state

    hKey - key whose state we wish to remove

    dwCriteria - if this is ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD,
       the enumeration state for hkey is removed for this thread only.
       If it is ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD, the enumeration
       state for hkey is removed for all threads in the
       process.

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    KeyStateList* pStateList;
    EnumState*    pEnumState;
    BOOL          fThisThreadOnly;
    NTSTATUS      Status;

    //
    // Protect ourselves while modifying the table
    //
    Status = RtlEnterCriticalSection(&(pEnumTable->CriticalSection));

    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() in EnumTableRemoveKey() failed. Status = %lx \n", Status );
#endif
        return Status;
    }

    Status = STATUS_OBJECT_NAME_NOT_FOUND;

    fThisThreadOnly = (ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD == dwCriteria);

    {
        KeyStateList* pNext;

        pNext = NULL;

        for (pStateList = (KeyStateList*) (pEnumTable->ThreadEnumList.pHead);
             pStateList != NULL;
             pStateList = NULL)
        {
            EnumState* pEnumState;

            if (fThisThreadOnly) {

                pStateList = (KeyStateList*) StateObjectListFind(
                    (StateObjectList*) &(pEnumTable->ThreadEnumList),
                    ULongToPtr((const unsigned long)GetCurrentThreadId()));

                if (!pStateList) {
                    break;
                }

            } else {
                pNext = (KeyStateList*) (pStateList->Object.Links.Flink);
            }

            pEnumState = (EnumState*) StateObjectListRemove(
                (StateObjectList*) pStateList,
                hKey);

            if (pEnumState) {

                Status = STATUS_SUCCESS;

                EnumStateDestroy((StateObject*) pEnumState);

                //
                // Note the state list might be empty for a given thread,
                // but we will not destroy this list in order to avoid
                // excessive heap calls
                //
            }
        }
    }

    //
    // It's safe to unlock the table
    //
    Status = RtlLeaveCriticalSection(&(pEnumTable->CriticalSection));

    ASSERT( NT_SUCCESS( Status ) );
#if DBG
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "WINREG: RtlLeaveCriticalSection() in EnumTableRemoveKey() failed. Status = %lx \n", Status );
    }
#endif

    return Status;
}


NTSTATUS EnumTableGetNextEnum(
    EnumTable* pEnumTable,
    HKEY hKey,
    DWORD dwSubkey,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID pKeyInfo,
    DWORD cbKeyInfo,
    LPDWORD pcbKeyInfo)
/*++

Routine Description:

   Gets the next enumerated subkey for a
   particular subkey

Arguments:

    pEnumTable - table that holds state of
       registry key enumerations

    hKey - key for whom we want to add state

    dwSubKey - index of subkey requested by caller
        for enumeration

    KeyInformationClass - the type of key information data
        requested by caller

    pKeyInfo - out param -- buffer for key information data for caller

    cbKeyInfo - size of pKeyInfo buffer

    pcbKeyInfo - out param -- size of key information returned to caller

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    EnumState* pEnumState;
    EnumState* pRootState;
    NTSTATUS   Status;
    BOOL       fFreeState;

    //
    // Protect ourselves while we enumerate
    //
    Status = RtlEnterCriticalSection(&(pEnumTable->CriticalSection));

    //
    // Very big -- unlikely to happen unless there's a runaway enumeration
    // due to a bug in this module.
    //
    // ASSERT(dwSubkey < 16383);

    ASSERT( NT_SUCCESS( Status ) );
    if ( !NT_SUCCESS( Status ) ) {
#if DBG
        DbgPrint( "WINREG: RtlEnterCriticalSection() in EnumTableGetNextENUm() failed. Status = %lx \n", Status );
#endif
        return Status;
    }

    //
    // Find the enumeration state for the requested key.  Note that even if this
    // function fails to find an existing state, which case it returns a failure code
    // it can still return an empty pEnumState for that hKey so it can be added later
    //
    Status = EnumTableGetKeyState(pEnumTable, hKey, dwSubkey, &pEnumState, &pRootState, pcbKeyInfo);

    if (!NT_SUCCESS(Status) || !pEnumState) {
        goto cleanup;
    }

    //
    // We have a state for this key, now we can use it to enumerate the next key
    //
    Status = EnumStateGetNextEnum(pEnumState, dwSubkey, KeyInformationClass, pKeyInfo, cbKeyInfo, pcbKeyInfo, &fFreeState);

    //
    // Below is an optimization for apps that enumerate HKEY_CLASSES_ROOT but close the handle and reopen it each
    // time before they call the registry enumeration api.  This is a very bad way to use the api (that's two extra
    // kernel calls for the open and close per enumeration), but existing applications do this and 
    // without the optimization, their enumeration times can go from 3 seconds to 1 or more minutes.  With this optimization,
    // the time gets back down to a few seconds.  This happened because we lost state after the close -- when the new
    // key was opened, we had to call the kernel to enumerate all the keys up to the requested index since we had no
    // previous state to go by -- this ends up making the entire enumeration an O(n^2) operation instead of O(n) as it
    // had been when callers didn't close the key during the enumeration. Here, n is a kernel trap to enumerate a key.
    //

    //
    // Above, we retrieved an enumeration state for the root of classes -- this state reflects the enumeration state
    // of the last handle that was used to enumerate the root on this thread.  This way, when a new handle is opened
    // to enumerate the root, we start with this state which will most likely be right at the index before the requested
    // index.  Instead of making i calls to NtEnumerateKey where i is the index of enumeration requested by the caller,
    // we make 1 or at most 2 calls.
    //

    //
    // Here, we update the root state to match the recently enumerated state.  Note that this only happens
    // if the key being enumerated refers to HKEY_CLASSES_ROOT since pRootState is only non-NULL in this
    // case.
    //
    if (pRootState) {
        EnumTableUpdateRootState(pEnumTable, pRootState, pEnumState, fFreeState);
    }

    if (fFreeState) {

        NTSTATUS RemoveStatus;

        //
        // For whatever reason, we've been told to free the enumeration state for this key.
        // This could be due to an error, or it could be a normal situation such as reaching
        // the end of an enumeration.
        //

        RemoveStatus = EnumTableRemoveKey(pEnumTable, hKey, ENUM_TABLE_REMOVEKEY_CRITERIA_THISTHREAD);

        ASSERT(NT_SUCCESS(RemoveStatus));
    }

cleanup:

    //
    // It's safe to unlock the table now.
    //
    {
        NTSTATUS CriticalSectionStatus;

        CriticalSectionStatus = RtlLeaveCriticalSection(&(pEnumTable->CriticalSection));

        ASSERT( NT_SUCCESS( CriticalSectionStatus ) );
#if DBG
        if ( !NT_SUCCESS( CriticalSectionStatus ) ) {
            DbgPrint( "WINREG: RtlLeaveCriticalSection() in EnumTableGetNextEnum() failed. Status = %lx \n",
                      CriticalSectionStatus );
        }
#endif
    }

    return Status;
}


NTSTATUS EnumTableGetKeyState(
    EnumTable*  pEnumTable,
    HKEY        hKey,
    DWORD       dwSubkey,
    EnumState** ppEnumState,
    EnumState** ppRootState,
    LPDWORD     pcbKeyInfo)
/*++

Routine Description:

    Finds a key state for hKey -- creates a new state for hkey if 
    there is no existing state

Arguments:

    pEnumTable - enumeration table in which to find key's state
    hKey - handle to registry key for which to find state
    dwSubkey - subkey that we're trying to enumerate -- needed in
        case we need to create a new state
    ppEnumState - pointer to where we should return address of 
        the retrieved state,
    ppRootState - if the retrieved state is the root of the classes
        tree, this address will point to a known state for the root
        that's good across all hkey's enumerated on this thread
    pcbKeyInfo - stores size of key information on return

Return Value:

    STATUS_SUCCESS for success, other error code on error

Notes:

--*/
{
    NTSTATUS Status;

    if (ppRootState) {
        *ppRootState = NULL;
    }

    //
    // Find the enumeration state for the requested key.  Note that even if this
    // function fails to find an existing state, in which case it returns a failure code
    // it can still return an empty pEnumState for that hKey so it can be added later
    //
    Status = EnumTableFindKeyState(pEnumTable, hKey, ppEnumState);

    if (!NT_SUCCESS(Status)) {

        if (STATUS_OBJECT_NAME_NOT_FOUND == Status) {

            //
            // This means the key didn't exist, already, so we'll add it
            //
            Status = EnumTableAddKey(pEnumTable, hKey, dwSubkey, ppEnumState, ppRootState);

            if (!NT_SUCCESS(Status)) {
                return Status;
            }

            //
            // The above function can succeed but return a NULL pEnumState -- this
            // happens if it turns out this key is not a "special key" -- i.e. this key's
            // parents exist in only one hive, not two, so we don't need to do anything here
            // and regular enumeration will suffice.
            //
            if (!(*ppEnumState)) {
                //
                // We set this value to let our caller know that this isn't a class key
                //
                *pcbKeyInfo = 0;
            }
        }
    } else {

        if ((*ppEnumState)->fClassesRoot) {
            Status = EnumTableGetRootState(pEnumTable, ppRootState);
        }
    }

    return Status;
}


NTSTATUS EnumTableGetRootState(
    EnumTable*  pEnumTable,
    EnumState** ppRootState)
/*++

Routine Description:

    

Arguments:

    pEnumTable - enumeration table in which to find the root
        state
    ppRootState - points to address of root state on return

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    DWORD         cbKeyInfo;
    KeyStateList* pStateList;
    
    //
    // We assume the caller has made sure that a state list
    // for this thread exists -- this should never, ever fail
    //
    pStateList = (KeyStateList*) StateObjectListFind(
        &(pEnumTable->ThreadEnumList),
        ULongToPtr((const unsigned long)GetCurrentThreadId()));

    ASSERT(pStateList);

    *ppRootState = &(pStateList->RootState);

    return STATUS_SUCCESS;
}


void EnumTableUpdateRootState(
    EnumTable* pEnumTable,
    EnumState* pRootState,
    EnumState* pEnumState,
    BOOL       fResetState)
/*++

Routine Description:

    Updates the state of the classes root for this thread -- this
    allows us to optimize for apps that close handles when enumerating
    hkcr -- we use this classes root state when no existing state is
    found for an hkey that refers to hkcr, and we update this state
    after enumerating an hkcr key on this thread so that it will
    be up to date.

Arguments:

    pEnumTable - enumeration table in which the classes root state resides

    pRootState - classes root state that should be updated

    ppEnumState - state that contains the data with which pRootState should
        be updated

    fResetState - if TRUE, this flag means we should not update the root state
        with pEnumState's data, just reset it.  If FALSE, we update the root
        with pEnumState's data.

Return Value:

     None.

Notes:

--*/
{
    NTSTATUS Status;

    //
    // See if we need to merely reset the root or actually
    // update it with another state
    //
    if (!fResetState) {

        //
        // Don't reset -- copy over the state from pEnumState to the
        // root state -- the root's state will be the same as pEnumState's
        // after this copy
        //
        Status = EnumStateCopy(pRootState, pEnumState);

    } else {

        //
        // Just clear out the state -- caller didn't request that we
        // use pEnumState.
        //
        Status = EnumStateInit(
            pRootState,
            0,
            0,
            ENUM_DIRECTION_FORWARD,
            NULL);
    }

    //
    // If there's a failure, it must be out-of-memory, so we should get rid
    // of this state since we can't make it accurately reflect the true
    // enumeration state
    //
    if (!NT_SUCCESS(Status)) {

#if DBG
        DbgPrint( "WINREG: failure in UpdateRootState. Status = %lx \n", Status );
#endif

        ASSERT(STATUS_NO_MEMORY == Status);

        EnumStateClear(pRootState);
    }
}


VOID KeyStateListInit(KeyStateList* pStateList)
/*++

Routine Description:

    Initializes a state list

Arguments:

    pObject -- pointer to KeyStateList object to destroy

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    //
    // First initialize the base object
    //
    StateObjectListInit((StateObjectList*) pStateList,
                        ULongToPtr((const unsigned long)GetCurrentThreadId()));

    //
    // Now do KeyStateList specific init
    //
    (void) EnumStateInit(
        &(pStateList->RootState),
        NULL,
        0,
        ENUM_DIRECTION_FORWARD,
        NULL);
}

VOID KeyStateListDestroy(StateObject* pObject)
/*++

Routine Description:

    Destroys an KeyStateList, freeing its resources such
        as memory or kernel object handles

Arguments:

    pObject -- pointer to KeyStateList object to destroy

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    KeyStateList* pThisList;

    pThisList = (KeyStateList*) pObject;

    //
    // Destroy all states in this list
    //
    StateObjectListClear(
        (StateObjectList*) pObject,
        EnumStateDestroy);

    //
    // Free resources associated with the root state
    //
    EnumStateClear(&(pThisList->RootState));

    //
    // Free the data structure for this object
    //
    RegClassHeapFree(pThisList);
} 


NTSTATUS EnumStateInit(
    EnumState*     pEnumState,
    HKEY           hKey,
    DWORD          dwFirstSubKey,
    DWORD          dwDirection,
    SKeySemantics* pKeySemantics)
/*++

Routine Description:

    Initializes enumeration state

Arguments:

    pEnumState - enumeration state to initialize
    hKey       - registry key to which this state refers
    dwFirstSubKey - index of the first subkey which this state will enumerate
    dwDirection - direction through which we should enumerate -- either
        ENUM_DIRECTION_FORWARD or ENUM_DIRECTION_BACKWARD
    pKeySemantics - structure containing information about hKey

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

--*/
{
    NTSTATUS Status;
    ULONG    cMachineKeys;
    ULONG    cUserKeys;
    HKEY     hkOther;

    ASSERT((ENUM_DIRECTION_FORWARD == dwDirection) || (ENUM_DIRECTION_BACKWARD == dwDirection) ||
        (ENUM_DIRECTION_IGNORE == dwDirection));

    ASSERT((ENUM_DIRECTION_IGNORE == dwDirection) ? hKey == NULL : TRUE);

    Status = STATUS_SUCCESS;

    hkOther = NULL;

    //
    // If no hkey is specified, this is an init of a blank enum
    // state, so clear everything
    //
    if (!hKey) {
        memset(pEnumState, 0, sizeof(*pEnumState));
    }

    //
    // Clear each subtree
    //
    EnumSubtreeStateClear(&(pEnumState->UserState));
    EnumSubtreeStateClear(&(pEnumState->MachineState));

    //
    // Reset each subtree
    //
    pEnumState->UserState.Finished = FALSE;
    pEnumState->MachineState.Finished = FALSE;

    pEnumState->UserState.iSubKey = 0;
    pEnumState->MachineState.iSubKey = 0;

    cUserKeys = 0;
    cMachineKeys = 0;

    if (pKeySemantics) {
        StateObjectInit((StateObject*) &(pEnumState->Object), hKey);
    }

    if (hKey) {

        if (pKeySemantics) {
            pEnumState->fClassesRoot = IsRootKey(pKeySemantics);
        }

        //
        // open the other key if we have enough info to do so --
        //
        if (pKeySemantics) {

            //
            // Remember, only one of the handles returned below
            // is new -- the other is simply hKey
            //
            Status = BaseRegGetUserAndMachineClass(
                pKeySemantics,
                hKey,
                MAXIMUM_ALLOWED,
                &(pEnumState->hkMachineKey),
                &(pEnumState->hkUserKey));

            if (!NT_SUCCESS(Status)) {
                return Status;
            }
        }
         
        //
        // for backwards enumerations
        //
        if (ENUM_DIRECTION_BACKWARD == dwDirection) {

            ULONG             cMachineKeys;
            ULONG             cUserKeys;
            HKEY              hkUser;
            HKEY              hkMachine;
            
            cMachineKeys = 0;
            cUserKeys = 0;
            
            hkMachine = pEnumState->hkMachineKey;
            hkUser = pEnumState->hkUserKey;

            //
            // In order to query for subkey counts, we should
            // to get a new handle since the caller supplied handle
            // may not have enough permissions
            //
            {
                HKEY   hkSource;
                HANDLE hCurrentProcess;

                hCurrentProcess = NtCurrentProcess();

                hkSource = (hkMachine == hKey) ? hkMachine : hkUser;
                
                Status = NtDuplicateObject(
                    hCurrentProcess,
                    hkSource,
                    hCurrentProcess,
                    &hkOther,
                    KEY_QUERY_VALUE,
                    FALSE,
                    0);

                if (!NT_SUCCESS(Status)) {
                    goto error_exit;
                }

                if (hkSource == hkUser) {
                    hkUser = hkOther;
                } else {
                    hkMachine = hkOther;
                }
            }

            //
            // find new start -- query for index of last subkey in
            // each hive 
            //
            if (hkMachine) {

                Status = GetSubKeyCount(hkMachine, &cMachineKeys);
            
                if (!NT_SUCCESS(Status)) {
                    goto error_exit;
                }
            }

            if (hkUser) {

                Status = GetSubKeyCount(hkUser, &cUserKeys);
                
                if (!NT_SUCCESS(Status)) {
                    goto error_exit;
                }
            }

            //
            // If either subtree has no subkeys, we're done enumerating that
            // subtree
            //
            if (!cUserKeys) {
                pEnumState->UserState.Finished = TRUE;
            } else {
                pEnumState->UserState.iSubKey = cUserKeys - 1;
            }

            if (!cMachineKeys) {
                pEnumState->MachineState.Finished = TRUE;
            } else {
                pEnumState->MachineState.iSubKey = cMachineKeys - 1;
            }
        }
    }
  
    //
    // Set members of this structure
    //
        
    pEnumState->dwThreadId = GetCurrentThreadId();
    pEnumState->Direction = dwDirection;
    pEnumState->dwLastRequest = dwFirstSubKey;
    pEnumState->LastLocation = ENUM_LOCATION_NONE;
        
    pEnumState->hKey = hKey;

error_exit:

    if (!NT_SUCCESS(Status)) {
        EnumSubtreeStateClear(&(pEnumState->MachineState));
        EnumSubtreeStateClear(&(pEnumState->UserState));
    }

    if (hkOther) {
        NtClose(hkOther);
    }

    return Status;
}


NTSTATUS EnumStateGetNextEnum(
    EnumState*            pEnumState,
    DWORD                 dwSubKey,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID                 pKeyInfo,
    DWORD                 cbKeyInfo,
    LPDWORD               pcbKeyInfo,
    BOOL*                 pfFreeState)
/*++

Routine Description:

    Gets the next key in an enumeration based on the current state.

Arguments:

    pEnumState - enumeration state on which to base our search
                 for the next key
    dwSubKey   - index of key to enumerate
    KeyInformationClass - enum for what sort of information to retrieve in the
         enumeration -- Basic Information or Node Information

    pKeyInfo   - location to store retrieved data for caller
    cbKeyInfo  - size of caller's info buffer
    pcbKeyInfo - size of data this function writes to buffer on return.
    pfFreeState - out param -- if set to TRUE, caller should free pEnumState.

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

    This function essentially enumerates from the previous index requested
    by the caller of RegEnumKeyEx to the new one. In most cases, this just
    means one trip to the kernel -- i.e. if a caller goes from index 2 to 3,
    or from 3 to 2, this is one trip to the kernel.  However, if the caller goes
    from 2 to 5, we'll have to do several enumerations on the way from 2 to 5.
    Also, if the caller switches direction (i.e. starts off 0,1,2,3 and then
    requests 1), a large penalty may be incurred.  When switching from ascending
    to descending, we have to enumerate all keys to the end and then before we
    can then enumerate down to the caller's requested index.  Switching from
    descending to ascending is less expensive -- we know that the beginning
    is at 0 for both user and machine keys, so we can simply set our indices to
    0 without enumerating anything.  However, we must then enumerate to the
    caller's requested index.  Note that for all descending enumerations, we
    must enumerate all the way to the end first before returning anything to the
    caller.

--*/
{
    NTSTATUS          Status;
    LONG              lIncrement;
    DWORD             dwStart;
    DWORD             dwLimit;
    EnumSubtreeState* pTreeState;

    //
    // If anything bad happens, this state should be freed
    //
    *pfFreeState = TRUE;

    //
    // Find out the limits (start, finish, increment) for
    // our enumeration. The increment is either 1 or -1,
    // depending on whether this is an ascending or descending
    // enumeration.  EnumStateSetLimits will take into account
    // any changes in direction and set dwStart and dwLimit
    // accordingly.
    //
    Status = EnumStateSetLimits(
        pEnumState,
        dwSubKey,
        &dwStart,
        &dwLimit,
        &lIncrement);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Get the next enum to give back to the caller
    //
    Status = EnumStateChooseNext(
        pEnumState,
        dwSubKey,
        dwStart,
        dwLimit,
        lIncrement,
        &pTreeState);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // We have retrieved information, so we should
    // not free this state
    //
    if (!(pEnumState->UserState.Finished && pEnumState->MachineState.Finished)) {
        *pfFreeState = FALSE;
    }

    //
    // Remember the last key we enumerated
    //
    pEnumState->dwLastRequest = dwSubKey;

    //
    // Copy the retrieved information to the user's
    // buffer.
    //
    Status = EnumSubtreeStateCopyKeyInfo(
        pTreeState,
        KeyInformationClass,
        pKeyInfo,
        cbKeyInfo,
        pcbKeyInfo);

    //
    // The copy could fail if the user's buffer isn't big enough --
    // if it succeeds, clear the name information for the subkey from
    // which we retrieved the data so that the next time we're called
    // we'll get the next subkey for that subtree.
    //
    if (NT_SUCCESS(Status)) {
        EnumSubtreeStateClear(pTreeState);
    }

    return Status;
}


NTSTATUS EnumStateSetLimits(
    EnumState*   pEnumState,
    DWORD        dwSubKey,
    LPDWORD      pdwStart,
    LPDWORD      pdwLimit,
    PLONG        plIncrement)
/*++

Routine Description:

    Gets the limits (start, finish, increment) for enumerating a given
    subkey index

Arguments:

    pEnumState - enumeration state on which to base our limits

    dwSubKey   - index of key which caller wants enumerated

    pdwStart   - out param -- result is the place at which to start
                 enumerating in order to find dwSubKey

    pdwLimit   - out param -- result is the place at which to stop
                 enumerating when looking for dwSubKey

    plIncrement - out param -- increment to use for enumeration. It will
               be set to 1 if the enumeration is upward (0,1,2...) or
               -1 if it is downard (3,2,1,...).

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    LONG     lNewIncrement;
    NTSTATUS Status;
    BOOL     fSameKey;

    //
    // set our increment to the direction which our state remembers
    //
    *plIncrement = pEnumState->Direction == ENUM_DIRECTION_FORWARD ? 1 : -1;

    fSameKey = FALSE;

    //
    // Figure out what the new direction should be
    // This is done by comparing the current request
    // with the last request.
    //
    if (dwSubKey > pEnumState->dwLastRequest) {
        lNewIncrement = 1;
    } else if (dwSubKey < pEnumState->dwLastRequest) {
        lNewIncrement = -1;
    } else {
        //
        // We are enumerating a key that may already
        // have been enumerated
        //
        fSameKey = TRUE;
        lNewIncrement = *plIncrement;
    }

    //
    // See if we've changed direction
    //
    if (lNewIncrement != *plIncrement) {

        //
        // If so, we should throw away all existing state and start from scratch
        //
        Status = EnumStateInit(
            pEnumState,
            pEnumState->hKey,
            (-1 == lNewIncrement) ? dwSubKey : 0,
            (-1 == lNewIncrement) ? ENUM_DIRECTION_BACKWARD : ENUM_DIRECTION_FORWARD,
            NULL);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // By default, we start enumerating where we left off
    //
    *pdwStart = pEnumState->dwLastRequest;

    //
    // for state for which we have previously enumerated a key
    //
    if (ENUM_LOCATION_NONE != pEnumState->LastLocation) {

        //
        // We're going in the same direction as on the
        // previous call. We should start
        // one past our previous position.  Note that we
        // only start there if this is a different key --
        // if we've already enumerated it we start at the
        // same spot.
        //
        if (!fSameKey) {
            *pdwStart += *plIncrement;
        } else {
            
            // 
            // If we're being asked for the same index
            // multiple times they're probably deleting
            // keys -- we should reset ourselves to
            // the beginning so their enum will hit
            // all the keys
            //

            //
            // We're starting at zero, so set ourselves
            // to start at the beginning
            //
            Status = EnumStateInit(
                pEnumState,
                pEnumState->hKey,
                0,
                ENUM_DIRECTION_FORWARD,
                NULL);
            
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
            
            *plIncrement = 1;
            pEnumState->Direction = ENUM_DIRECTION_FORWARD;
            *pdwStart = 0;
        }

    } else {

        //
        // No previous calls were made for this state
        //
        if (ENUM_DIRECTION_BACKWARD == pEnumState->Direction) {

            //
            // For backwards enumerations, we want to get an
            // accurate count of total subkeys and start there
            //
            Status = ClassKeyCountSubKeys(
                pEnumState->hKey,
                pEnumState->hkUserKey,
                pEnumState->hkMachineKey,
                0,
                pdwStart);

            if (!NT_SUCCESS(Status)) {
                return Status;
            }

            //
            // Make sure we don't go past the end
            //
            if (dwSubKey >= *pdwStart) {
                return STATUS_NO_MORE_ENTRIES;
            }

            //
            // This is a zero-based index, so to
            // put our start at the very end we must
            // be one less than the number of keys
            //
            (*pdwStart)--;

            *plIncrement = -1;

        } else {
            *plIncrement = 1;
        }
    }

    //
    // Set limit to be one past requested subkey
    //
    *pdwLimit = dwSubKey + *plIncrement;

    return STATUS_SUCCESS;
}


NTSTATUS EnumStateChooseNext(
    EnumState*         pEnumState,
    DWORD              dwSubKey,
    DWORD              dwStart,
    DWORD              dwLimit,
    LONG               lIncrement,
    EnumSubtreeState** ppTreeState)
/*++

Routine Description:

    Iterates through registry keys to get the key requested by the caller

Arguments:

    pEnumState - enumeration state on which to base our search

    dwSubKey   - index of key which caller wants enumerated

    dwStart   - The place at which to start
                enumerating in order to find dwSubKey

    dwLimit   - The place at which to stop
                enumerating when looking for dwSubKey

    lIncrement - Increment to use for enumeration. It will
               be set to 1 if the enumeration is upward (0,1,2...) or
               -1 if it is downard (3,2,1,...).

    ppTreeState - out param -- pointer to address of subtree state in which this regkey
                  was found -- each EnumState has two EnumSubtreeState's -- one for user
                  and one for machine.

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    DWORD    iCurrent;
    NTSTATUS Status;
    BOOL     fClearLast;

    Status = STATUS_NO_MORE_ENTRIES;

    fClearLast = FALSE;

    //
    // We will now iterate from dwStart to dwLimit so that we can find the key
    // requested by the caller
    //
    for (iCurrent = dwStart; iCurrent != dwLimit; iCurrent += lIncrement) {

        BOOL fFoundKey;
        BOOL fIgnoreFailure;

        fFoundKey = FALSE;

        fIgnoreFailure = FALSE;

        Status = STATUS_NO_MORE_ENTRIES;

        //
        // Clear last subtree
        //
        if (fClearLast) {
            EnumSubtreeStateClear(*ppTreeState);
        }

        //
        // if key names aren't present, alloc space and get names
        //
        if (pEnumState->hkUserKey) {
            if (pEnumState->UserState.pKeyInfo) {
                fFoundKey = TRUE;
            } else if (!(pEnumState->UserState.Finished)) {

                // get user key info
                Status = EnumClassKey(
                    pEnumState->hkUserKey,
                    &(pEnumState->UserState));

                fFoundKey = NT_SUCCESS(Status);

                //
                // If there are no more subkeys for this subtree,
                // mark it as finished
                //
                if (!NT_SUCCESS(Status)) {

                    if (STATUS_NO_MORE_ENTRIES != Status) {
                        return Status;
                    }

                    if (lIncrement > 0) {
                        pEnumState->UserState.Finished = TRUE;
                    } else {

                        pEnumState->UserState.iSubKey += lIncrement;
                        fIgnoreFailure = TRUE;
                    }
                }
            }
        }

        if (pEnumState->hkMachineKey) {

            if (pEnumState->MachineState.pKeyInfo) {
                fFoundKey = TRUE;
            } else if (!(pEnumState->MachineState.Finished)) {

                // get machine key info
                Status = EnumClassKey(
                    pEnumState->hkMachineKey,
                    &(pEnumState->MachineState));

                //
                // If there are no more subkeys for this subtree,
                // mark it as finished
                //
                if (NT_SUCCESS(Status)) {
                    fFoundKey = TRUE;
                } else if (STATUS_NO_MORE_ENTRIES == Status) {

                    if (lIncrement > 0) {
                        pEnumState->MachineState.Finished = TRUE;
                    } else {
                        pEnumState->MachineState.iSubKey += lIncrement;
                        fIgnoreFailure = TRUE;
                    }
                }
            }
        }

        //
        // If we found no keys in either user or machine locations, there are
        // no more keys.
        //
        if (!fFoundKey) {

            //
            // For descending enumerations, we ignore STATUS_NO_MORE_ENTRIES
            // and keep going until we find one.
            //
            if (fIgnoreFailure) {
                continue;
            }

            return Status;
        }

        //
        // If we already hit the bottom, skip to the end
        //
        if ((pEnumState->UserState.iSubKey == 0) &&
            (pEnumState->MachineState.iSubKey == 0) &&
            (lIncrement < 0)) {
            
            iCurrent = dwLimit - lIncrement;
        }

        //
        // Now we need to choose between keys in the machine hive and user hives --
        // this call will choose which key to use.
        //
        Status = EnumStateCompareSubtrees(pEnumState, lIncrement, ppTreeState);

        if (!NT_SUCCESS(Status)) {

            pEnumState->dwLastRequest = dwSubKey;

            return Status;
        }
        
        fClearLast = TRUE;

    }

    return Status;
}


NTSTATUS EnumStateCompareSubtrees(
    EnumState*         pEnumState,
    LONG               lIncrement,
    EnumSubtreeState** ppSubtree)
/*++

Routine Description:

    Compares the user and machine subtrees of an enumeration state
    to see which of the two current keys in each hive should be
    returned as the next key in an enumeration

Arguments:

    pEnumState - enumeration state on which to base our search

    lIncrement - Increment to use for enumeration. It will
               be set to 1 if the enumeration is upward (0,1,2...) or
               -1 if it is downard (3,2,1,...).

    ppSubtree - out param -- pointer to address of subtree state where
                key was found -- the name of the key can be extracted from it.

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    //
    // If both subtrees have a current subkey name, we'll need to compare
    // the names
    //
    if (pEnumState->MachineState.pKeyInfo && pEnumState->UserState.pKeyInfo) {

        UNICODE_STRING MachineKeyName;
        UNICODE_STRING UserKeyName;
        LONG           lCompareResult;

        MachineKeyName.Buffer = pEnumState->MachineState.pKeyInfo->Name;
        MachineKeyName.Length = (USHORT) pEnumState->MachineState.pKeyInfo->NameLength;

        UserKeyName.Buffer = pEnumState->UserState.pKeyInfo->Name;
        UserKeyName.Length = (USHORT) pEnumState->UserState.pKeyInfo->NameLength;

        //
        // Do the comparison
        //
        lCompareResult =
            RtlCompareUnicodeString(&UserKeyName, &MachineKeyName, TRUE) * lIncrement;

        //
        // User wins comparison
        //
        if (lCompareResult < 0) {
            // choose user
            *ppSubtree = &(pEnumState->UserState);
            pEnumState->LastLocation = ENUM_LOCATION_USER;

        } else if (lCompareResult > 0) {

            //
            // Machine wins choose machine
            //
            *ppSubtree = &(pEnumState->MachineState);
            pEnumState->LastLocation = ENUM_LOCATION_MACHINE;

        } else {

            //
            // Comparison returned equality -- the keys have the same
            // name.  This means the same key name exists in both machine and
            // user, so we need to make a choice about which one we will enumerate.
            // Policy for per-user class registration enumeration is to choose user, just
            // as we do for other api's such as RegOpenKeyEx and RegCreateKeyEx.
            //
            if (!((pEnumState->MachineState.iSubKey == 0) && (lIncrement < 0))) {
                pEnumState->MachineState.iSubKey += lIncrement;
            } else {
                pEnumState->MachineState.Finished = TRUE;
            }

            //
            // Clear the machine state and move it to the next index -- we don't
            // have to clear the user state yet because the state of whichever subtree
            // was selected is cleared down below
            //
            EnumSubtreeStateClear(&(pEnumState->MachineState));
            pEnumState->LastLocation = ENUM_LOCATION_USER;
            *ppSubtree = &(pEnumState->UserState);
        }

    } else if (!(pEnumState->UserState.pKeyInfo) && !(pEnumState->MachineState.pKeyInfo)) {
        //
        // Neither subtree state has a subkey, so there are no subkeys
        //
        return STATUS_NO_MORE_ENTRIES;

    } else if (pEnumState->MachineState.pKeyInfo) {

        //
        // Only machine has a subkey
        //
        *ppSubtree = &(pEnumState->MachineState);
        pEnumState->LastLocation = ENUM_LOCATION_MACHINE;

    } else {

        //
        // only user has a subkey
        //
        *ppSubtree = &(pEnumState->UserState);
        pEnumState->LastLocation = ENUM_LOCATION_USER;
    }

    //
    // change the state of the subtree which we selected
    //
    if (!(((*ppSubtree)->iSubKey == 0) && (lIncrement < 0))) {
        (*ppSubtree)->iSubKey += lIncrement;
    } else {
        (*ppSubtree)->Finished = TRUE;
    }

    return STATUS_SUCCESS;
}

void EnumStateDestroy(StateObject* pObject)
{
    EnumStateClear((EnumState*) pObject);

    RegClassHeapFree(pObject);
}

VOID EnumStateClear(EnumState* pEnumState)
/*++

Routine Description:

    Clears the enumeration state

Arguments:

    pEnumState - enumeration state to clear

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    //
    // Close an existing reference to a second key
    //
    if (pEnumState->hkMachineKey && (pEnumState->hKey != pEnumState->hkMachineKey)) {

        NtClose(pEnumState->hkMachineKey);

    } else if (pEnumState->hkUserKey && (pEnumState->hKey != pEnumState->hkUserKey)) {
        
        NtClose(pEnumState->hkUserKey);
    }

    //
    // Free any heap memory held by our subtrees
    //
    EnumSubtreeStateClear(&(pEnumState->UserState));
    EnumSubtreeStateClear(&(pEnumState->MachineState));

    //
    // reset everything in this state
    //
    memset(pEnumState, 0, sizeof(*pEnumState));
}


BOOL EnumStateIsEmpty(EnumState* pEnumState)
/*++

Routine Description:

    Returns whether or not an enumeration state is empty.
    An enumeration state is empty if it is not associated
    with any particular registry key handle

Arguments:

    pEnumState - enumeration state to clear

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    return pEnumState->hKey == NULL;
}

NTSTATUS EnumStateCopy(
    EnumState*            pDestState,
    EnumState*            pEnumState)
/*++

Routine Description:

    Copies an enumeration state for one hkey
    to the state for another hkey -- note that it the 
    does not change the hkey referred to by the destination
    state, it just makes pDestState->hKey's state the
    same as pEnumState's

Arguments:

    pDestState - enumeration state which is destination
        of the copy
    pEnumState - source enumeration for the copy

Return Value:

    STATUS_SUCCESS for success, other error code on error

Notes:

--*/
{
    NTSTATUS Status;

    PKEY_NODE_INFORMATION pKeyInfoUser;
    PKEY_NODE_INFORMATION pKeyInfoMachine;

    Status = STATUS_SUCCESS;

    //
    // Copy simple data
    //
    pDestState->Direction = pEnumState->Direction;
    pDestState->LastLocation = pEnumState->LastLocation;

    pDestState->dwLastRequest = pEnumState->dwLastRequest;
    pDestState->dwThreadId = pEnumState->dwThreadId;

    //
    // Free existing data before we overwrite it -- note that the pKeyInfo can point to a fixed buffer inside the state or 
    // a heap allocated buffer, so we must see which one it points to before we decide to free it
    //
    if (pDestState->UserState.pKeyInfo &&
        (pDestState->UserState.pKeyInfo != (PKEY_NODE_INFORMATION) pDestState->UserState.KeyInfoBuffer)) {
        RegClassHeapFree(pDestState->UserState.pKeyInfo);
        pDestState->UserState.pKeyInfo = NULL;
    }

    if (pDestState->MachineState.pKeyInfo &&
        (pDestState->MachineState.pKeyInfo != (PKEY_NODE_INFORMATION) pDestState->MachineState.KeyInfoBuffer)) {
        RegClassHeapFree(pDestState->MachineState.pKeyInfo);
        pDestState->MachineState.pKeyInfo = NULL;
    }

    //
    // easy way to copy states -- we'll have to fix up below though since pKeyInfo can be
    // self-referential.
    //
    memcpy(&(pDestState->UserState), &(pEnumState->UserState), sizeof(pEnumState->UserState));
    memcpy(&(pDestState->MachineState), &(pEnumState->MachineState), sizeof(pEnumState->MachineState));

    pKeyInfoUser = NULL;
    pKeyInfoMachine = NULL;
        
    //
    // Copy new data -- as above, keep in mind that pKeyInfo can be self-referential, so check
    // for that before deciding whether to allocate heap or use the internal fixed buffer of the
    // structure.
    //
    if (pEnumState->UserState.pKeyInfo &&
        ((pEnumState->UserState.pKeyInfo != (PKEY_NODE_INFORMATION) pEnumState->UserState.KeyInfoBuffer))) {

        pKeyInfoUser = (PKEY_NODE_INFORMATION) 
            RegClassHeapAlloc(pEnumState->UserState.cbKeyInfo);

        if (!pKeyInfoUser) {
            Status = STATUS_NO_MEMORY;
        }

        pDestState->UserState.pKeyInfo = pKeyInfoUser;

        RtlCopyMemory(pDestState->UserState.pKeyInfo,
                      pEnumState->UserState.pKeyInfo,
                      pEnumState->UserState.cbKeyInfo);
    } else {
        if (pDestState->UserState.pKeyInfo) {
            pDestState->UserState.pKeyInfo = (PKEY_NODE_INFORMATION) pDestState->UserState.KeyInfoBuffer;
        }
    }
    
    if (pEnumState->MachineState.pKeyInfo &&
        ((pEnumState->MachineState.pKeyInfo != (PKEY_NODE_INFORMATION) pEnumState->MachineState.KeyInfoBuffer))) {
      
        pKeyInfoMachine = (PKEY_NODE_INFORMATION) 
            RegClassHeapAlloc(pEnumState->MachineState.cbKeyInfo);

        if (!pKeyInfoMachine) {
            Status = STATUS_NO_MEMORY;
        }

        pDestState->MachineState.pKeyInfo = pKeyInfoMachine;

        RtlCopyMemory(pDestState->MachineState.pKeyInfo,
                      pEnumState->MachineState.pKeyInfo,
                      pEnumState->MachineState.cbKeyInfo);
    } else {
        if (pDestState->MachineState.pKeyInfo) {
            pDestState->MachineState.pKeyInfo = (PKEY_NODE_INFORMATION) pDestState->MachineState.KeyInfoBuffer;
        }
    }

    //
    // On error, make sure we clean up.
    // 
    if (!NT_SUCCESS(Status)) {

        if (pKeyInfoUser) {
            RegClassHeapFree(pKeyInfoUser);
        }

        if (pKeyInfoMachine) {
            RegClassHeapFree(pKeyInfoMachine);
        }
    }

    return Status;
}


void EnumSubtreeStateClear(EnumSubtreeState* pTreeState)
/*++
Routine Description:

    This function frees the key data associated with this
    subtree state

Arguments:

    pTreeState -- tree state to clear

Return Value: None.

    Note:

--*/

{
    //
    // see if we're using pre-alloced buffer -- if not, free it
    //
    if (pTreeState->pKeyInfo && (((LPBYTE) pTreeState->pKeyInfo) != pTreeState->KeyInfoBuffer)) {

        RegClassHeapFree(pTreeState->pKeyInfo);
    }

    pTreeState->pKeyInfo = NULL;
}

NTSTATUS EnumSubtreeStateCopyKeyInfo(
    EnumSubtreeState* pTreeState,
    KEY_INFORMATION_CLASS KeyInformationClass,
    PVOID pDestKeyInfo,
    ULONG cbDestKeyInfo,
    PULONG pcbResult)
/*++

Routine Description:

    Copies information about a key into a buffer supplied by the caller

Arguments:

    pTreeState - subtree tate from which to copy

    KeyInformationClass - the type of buffer supplied by the caller -- either
        a KEY_NODE_INFORMATION or KEY_BASIC_INFORMATION structure

    pDestKeyInfo - caller's buffer for key information

    cbDestKeyInfo - size of caller's buffer

    pcbResult - out param -- amount of data to be written to caller's buffer

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    ULONG cbNeeded;

    ASSERT((KeyInformationClass == KeyNodeInformation) ||
           (KeyInformationClass == KeyBasicInformation));

    //
    // Find out how big the caller's buffer needs to be.  This
    // depends on whether the caller specified full or node information
    // as well as the size of the variable size members of those
    // structures
    //

    if (KeyNodeInformation == KeyInformationClass) {

        PKEY_NODE_INFORMATION pNodeInformation;

        //
        // Copy fixed length pieces first -- caller expects them to
        // be set even when the variable length members are not large enough
        //

        //
        // Set ourselves to point to caller's buffer
        //
        pNodeInformation = (PKEY_NODE_INFORMATION) pDestKeyInfo;

        //
        // Copy all fixed-length pieces of structure
        //
        pNodeInformation->LastWriteTime = pTreeState->pKeyInfo->LastWriteTime;
        pNodeInformation->TitleIndex = pTreeState->pKeyInfo->TitleIndex;
        pNodeInformation->ClassOffset = pTreeState->pKeyInfo->ClassOffset;
        pNodeInformation->ClassLength = pTreeState->pKeyInfo->ClassLength;
        pNodeInformation->NameLength = pTreeState->pKeyInfo->NameLength;

        //
        // Take care of the size of the node information structure
        //
        cbNeeded = sizeof(KEY_NODE_INFORMATION);

        if (cbDestKeyInfo < cbNeeded) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Add in the size of the variable length members
        //
        cbNeeded += pTreeState->pKeyInfo->NameLength;
        cbNeeded += pTreeState->pKeyInfo->ClassLength;
        cbNeeded -= sizeof(WCHAR); // the structure's Name member is already set to 1,
                                   // so that one has already been accounted for in
                                   // the size of the structure

    } else {

        PKEY_BASIC_INFORMATION pBasicInformation;

        //
        // Copy fixed length pieces first -- caller expects them to
        // be set even when the variable length members are not large enough
        //

        //
        // Set ourselves to point to caller's buffer
        //
        pBasicInformation = (PKEY_BASIC_INFORMATION) pDestKeyInfo;

        //
        // Copy all fixed-length pieces of structure
        //
        pBasicInformation->LastWriteTime = pTreeState->pKeyInfo->LastWriteTime;
        pBasicInformation->TitleIndex = pTreeState->pKeyInfo->TitleIndex;
        pBasicInformation->NameLength = pTreeState->pKeyInfo->NameLength;


        cbNeeded = sizeof(KEY_BASIC_INFORMATION);

        //
        // Take care of the size of the basic information structure
        //
        if (cbDestKeyInfo < cbNeeded) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Add in the size of the variable length members
        //
        cbNeeded += pTreeState->pKeyInfo->NameLength;
        cbNeeded -= sizeof(WCHAR); // the structure's Name member is already set to 1,
                                   // so that one has already been accounted for in
                                   // the size of the structure
    }

    //
    // Store the amount needed for the caller
    //
    *pcbResult = cbNeeded;

    //
    // See if the caller supplied enough buffer -- leave if not
    //
    if (cbDestKeyInfo < cbNeeded) {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // We copy variable-length information differently depending
    // on which type of structure was passsed in
    //
    if (KeyNodeInformation == KeyInformationClass) {

        PBYTE                 pDestClass;
        PBYTE                 pSrcClass;
        PKEY_NODE_INFORMATION pNodeInformation;

        pNodeInformation = (PKEY_NODE_INFORMATION) pDestKeyInfo;

        //
        // Copy variable length pieces such as name and class
        //
        RtlCopyMemory(pNodeInformation->Name,
                      pTreeState->pKeyInfo->Name,
                      pTreeState->pKeyInfo->NameLength);

        //
        // Only copy the class if it exists
        //
        if (((LONG)pTreeState->pKeyInfo->ClassOffset) >= 0) {
            pDestClass = ((PBYTE) pNodeInformation) + pTreeState->pKeyInfo->ClassOffset;
            pSrcClass = ((PBYTE) pTreeState->pKeyInfo) + pTreeState->pKeyInfo->ClassOffset;
            RtlCopyMemory(pDestClass, pSrcClass, pTreeState->pKeyInfo->ClassLength);
        }

    } else {

        PKEY_BASIC_INFORMATION pBasicInformation;

        //
        // Set ourselves to point to caller's buffer
        //
        pBasicInformation = (PKEY_BASIC_INFORMATION) pDestKeyInfo;

        //
        // Copy variable length pieces -- only name is variable length
        //
        RtlCopyMemory(pBasicInformation->Name,
                      pTreeState->pKeyInfo->Name,
                      pTreeState->pKeyInfo->NameLength);

    }

    return STATUS_SUCCESS;
}



NTSTATUS EnumClassKey(
    HKEY              hKey,
    EnumSubtreeState* pTreeState)
/*++

Routine Description:

    Enumerates a subkey for a subtree state -- calls the kernel

Arguments:

    hKey - key we want the kernel to enumerate
    pTreeState - subtree state -- either a user or machine subtree

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    PKEY_NODE_INFORMATION pCurrentKeyInfo;
    NTSTATUS Status;

    ASSERT(!(pTreeState->pKeyInfo));

    //
    // First try to use the buffer built in to the subtree state
    //
    pCurrentKeyInfo = (PKEY_NODE_INFORMATION) pTreeState->KeyInfoBuffer;

    //
    // Query for the necessary information about the supplied key.
    //

    Status = NtEnumerateKey( hKey,
                             pTreeState->iSubKey,
                             KeyNodeInformation,
                             pCurrentKeyInfo,
                             sizeof(pTreeState->KeyInfoBuffer),
                             &(pTreeState->cbKeyInfo));

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

    //
    // If the subtree state's buffer isn't big enough, we'll have
    // to ask the heap to give us one.
    //
    if (STATUS_BUFFER_OVERFLOW == Status) {

        pCurrentKeyInfo = RegClassHeapAlloc(pTreeState->cbKeyInfo);
        //
        // If the memory allocation fails, return a Registry Status.
        //
        if( ! pCurrentKeyInfo ) {
            return STATUS_NO_MEMORY;
        }

        //
        // Query for the necessary information about the supplied key.
        //

        Status = NtEnumerateKey( hKey,
                                 pTreeState->iSubKey,
                                 KeyNodeInformation,
                                 pCurrentKeyInfo,
                                 pTreeState->cbKeyInfo,
                                 &(pTreeState->cbKeyInfo));

    }

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // set the subtree state's reference to point
    // to the location of the data
    //
    pTreeState->pKeyInfo = pCurrentKeyInfo;

    return STATUS_SUCCESS;
}


NTSTATUS GetSubKeyCount(
    HKEY    hkClassKey,
    LPDWORD pdwUserSubKeys)
/*++

Routine Description:

    Counts the number of subkeys under a key

Arguments:

    hkClassKey - key whose subkeys we wish to count
    pdwUserSubKeys - out param for number of subkeys

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    NTSTATUS                Status;
    PKEY_CACHED_INFORMATION  KeyCachedInfo;
    ULONG                   BufferLength;
    BYTE                    PrivateKeyCachedInfo[ sizeof( KEY_CACHED_INFORMATION ) ];

    //
    // Initialize out params
    //
    *pdwUserSubKeys = 0;

    //
    // Set up to query kernel for subkey information
    //
    KeyCachedInfo = (PKEY_CACHED_INFORMATION) PrivateKeyCachedInfo;
    BufferLength = sizeof(PrivateKeyCachedInfo);

    Status = QueryKeyInfo(
                hkClassKey,
                KeyCachedInformation,
                &KeyCachedInfo,
                BufferLength,
                FALSE,
                0
                );

    if (NT_SUCCESS(Status)) {
        //
        // set the out param with the subkey data from the kernel call
        //
        *pdwUserSubKeys = KeyCachedInfo->SubKeys;

        ASSERT( KeyCachedInfo == ( PKEY_CACHED_INFORMATION )PrivateKeyCachedInfo );
    }

    return Status;

}


NTSTATUS ClassKeyCountSubKeys(
    HKEY    hKey,
    HKEY    hkUser,
    HKEY    hkMachine,
    DWORD   cMax,
    LPDWORD pcSubKeys)
/*++

Routine Description:

    Counts the total number of subkeys of a special key -- i.e.
    the sum of the subkeys in the user and machine portions
    of that special key minus duplicates.

Arguments:

    hkUser - user part of special key

    hkMachine - machine part of special key

    cMax - Maximum number of keys to count -- if
        zero, this is ignored

    pcSubKeys - out param -- count of subkeys

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

    This is INCREDIBLY expensive if either hkUser or hkMachine
    has more than a few subkeys.  It essentially merges two
    sorted lists by enumerating in both the user and machine
    locations, and viewing them as a merged list by doing
    comparisons betweens items in each list --
    separate user and machine pointers are advanced according
    to the results of the comparison. This means that if there are
    N keys under hkUser and M keys under hkMachine, this function
    will make N+M calls to the kernel to enumerate the keys.

    This is currently the only way to do this -- before, an approximation
    was used in which the sum of the number of subkeys in the
    user and machine versions was returned.  This method didn't take
    duplicates into account, and so it overestimated the number of keys.
    This was not thought to be a problem since there is no guarantee
    to callers that the number they receive is completely up to date,
    but it turns out that there are applications that make that assumption
    (such as regedt32) that do not function properly unless the
    exact number is returned.

--*/
{
    NTSTATUS          Status;
    BOOL              fCheckUser;
    BOOL              fCheckMachine;
    EnumSubtreeState  UserTree;
    EnumSubtreeState  MachineTree;
    DWORD             cMachineKeys;
    DWORD             cUserKeys;
    OBJECT_ATTRIBUTES Obja;
    HKEY              hkUserCount;
    HKEY              hkMachineCount;
    HKEY              hkNewKey;

    UNICODE_STRING EmptyString = {0, 0, 0};

    Status = STATUS_SUCCESS;

    hkNewKey = NULL;

    cMachineKeys = 0;
    cUserKeys = 0;

    //
    // Initialize ourselves to check in both the user
    // and machine hives for subkeys
    //
    fCheckUser = (hkUser != NULL);
    fCheckMachine = (hkMachine != NULL);

    memset(&UserTree, 0, sizeof(UserTree));
    memset(&MachineTree, 0, sizeof(MachineTree));

    //
    // We can't be sure that the user key was opened
    // with the right permissions so we'll open
    // a version that has the correct permissions
    //
    if (fCheckUser && (hkUser == hKey)) {
     
        InitializeObjectAttributes(
            &Obja,
            &EmptyString,
            OBJ_CASE_INSENSITIVE,
            hkUser,
            NULL);

        Status = NtOpenKey(
            &hkNewKey,
            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
            &Obja);
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        hkUserCount = hkNewKey;
    } else {
        hkUserCount = hkUser;
    }

    if (fCheckMachine && (hkMachine == hKey)) {
     
        InitializeObjectAttributes(
            &Obja,
            &EmptyString,
            OBJ_CASE_INSENSITIVE,
            hkMachine,
            NULL);

        Status = NtOpenKey(
            &hkNewKey,
            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
            &Obja);
        
        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        hkMachineCount = hkNewKey;
    } else {
        hkMachineCount = hkMachine;
    }

    //
    // Now check to see how many keys are in the user subtree
    //
    if (fCheckUser) {
        Status = GetSubKeyCount(hkUserCount, &cUserKeys);

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

        //
        // We only need to enumerate the user portion if it has subkeys
        //
        fCheckUser = (cUserKeys != 0);
    }

    //
    // Now check to see how many keys are in the user subtree
    //
    if (fCheckMachine) {
        Status = GetSubKeyCount(hkMachineCount, &cMachineKeys);

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

        //
        // We only need to enumerate the machine portion if it has subkeys
        //
        fCheckMachine = (cMachineKeys != 0);
    }

    if (!fCheckUser) {

        *pcSubKeys = cMachineKeys;

        Status = STATUS_SUCCESS;
        
        goto cleanup;
    }

    if (!fCheckMachine) {

        *pcSubKeys = cUserKeys;

        Status = STATUS_SUCCESS;

        goto cleanup;
    }

    ASSERT(fCheckMachine && fCheckUser);

    *pcSubKeys = 0;

    //
    // Keep enumerating subkeys until one of the locations
    // runs out of keys
    //
    for (;;) {

        NTSTATUS EnumStatus;

        //
        // If we can still check in the user hive and we
        // are missing user key info, query the kernel for it
        //
        if (!(UserTree.pKeyInfo)) {
            EnumStatus = EnumClassKey(
                hkUserCount,
                &UserTree);

            //
            // If there are no more user subkeys, set our
            // flag so that we no longer look in the user portion
            // for subkeys
            //
            if (!NT_SUCCESS(EnumStatus)) {
                if (STATUS_NO_MORE_ENTRIES == EnumStatus) {

                    *pcSubKeys += cMachineKeys;
                    Status = STATUS_SUCCESS;
                    break;

                } else {
                    Status = EnumStatus;
                    break;
                }
            }
        }

        //
        // if we can still check in the machine hive and
        // we are missing machine info, query for it
        //
        if (!(MachineTree.pKeyInfo)) {

            EnumStatus = EnumClassKey(
                hkMachineCount,
                &MachineTree);

            //
            // Turn off checking in machine if there are
            // no more machine keys
            //
            if (!NT_SUCCESS(EnumStatus)) {
                if (STATUS_NO_MORE_ENTRIES == EnumStatus) {

                    *pcSubKeys += cUserKeys;
                    Status = STATUS_SUCCESS;
                    break;

                } else {
                    Status = EnumStatus;
                    break;
                }
            }
        }

        //
        // If we have keys in both user and machine, we need to compare
        // the key names to see when to advance our subtree pointers
        //
        {

            LONG lCompare;

            UNICODE_STRING MachineKeyName;
            UNICODE_STRING UserKeyName;

            MachineKeyName.Buffer = MachineTree.pKeyInfo->Name;
            MachineKeyName.Length = (USHORT) MachineTree.pKeyInfo->NameLength;

            UserKeyName.Buffer = UserTree.pKeyInfo->Name;
            UserKeyName.Length = (USHORT) UserTree.pKeyInfo->NameLength;

            //
            // Do the comparison of user and machine keys
            //
            lCompare =
                RtlCompareUnicodeString(&UserKeyName, &MachineKeyName, TRUE);

            //
            // User is smaller, so move our user pointer up and clear it
            // so we'll query for user data next time
            //
            if (lCompare <= 0) {
                EnumSubtreeStateClear(&UserTree);
                UserTree.iSubKey++;
                cUserKeys--;
            }

            //
            // Machine is smaller, so move our user pointer up and clear it
            // so we'll query for machine data next time
            //
            if (lCompare >= 0) {
                EnumSubtreeStateClear(&MachineTree);
                MachineTree.iSubKey++;
                cMachineKeys--;
            }

            //
            // Increase the total number of subkeys
            //
            (*pcSubKeys)++;

        }

        //
        // Only enumerate up to max -- the caller
        // doesn't need to go all the way to the end
        //
        if (cMax && (*pcSubKeys > cMax)) {
            break;
        }
    }

    //
    // Free any buffer held by these subtree states
    //
    EnumSubtreeStateClear(&UserTree);
    EnumSubtreeStateClear(&MachineTree);

cleanup:

    if (hkNewKey) {
        NtClose(hkNewKey);
    }

    return Status;
}

#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regeval.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regeval.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry API to enumerate values. That is:

        - BaseRegEnumValue

Author:

    David J. Gilman (davegi) 23-Dec-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regvcls.h"

#define DEFAULT_VALUE_SIZE          128
#define DEFAULT_VALUE_NAME_SIZE     64


error_status_t
BaseRegEnumValue(
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT PUNICODE_STRING lpValueName,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE lpData OPTIONAL,
    IN OUT LPDWORD lpcbData OPTIONAL,
    IN OUT LPDWORD lpcbLen  OPTIONAL
    )

/*++

Routine Description:

    Used to enumerate the ValueNames of an open key.  This function copies
    the dwIndex-th ValueName of hKey.  This function is guaranteed to
    operate correctly only if dwIndex starts at 0 and is incremented on
    successive calls without intervening calls to other registration APIs
    that will change the key.  The ValueName (only the ValueName, not the
    full path) is copied to lpBuffer.  The size of lpBuffer is specified
    by dwBufferSize.

Arguments:

    hKey - A handle to the open key.  The value entries returned are
        contained in the key pointed to by this key handle.  Any of the
        predefined reserved handles or a previously opened key handle may be
        used for hKey.

    dwIndex - The index of the ValueName to return.  Note that this is for
        convenience, ValueNames are not ordered (a new ValueName has an
        arbitrary index).  Indexes start at 0.

    lpValueName - Provides a pointer to a buffer to receive the name of
        the value (it's Id)

    lpType - If present, supplies pointer to variable to receive the type
        code of value entry.

    lpData - If present, provides a pointer to a buffer to receive the
        data of the value entry.

    lpcbData - Must be present if lpDatais.  Provides pointer to a
        variable which on input contains the size of the buffer lpDatapoints
        to.  On output, the variable will receive the number of bytes returned
        in lpData.

    lpcbLen - Return the number of bytes to transmit to the client (used
        by RPC).


Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    hKey must have been opened for KEY_QUERY_VALUE access.


--*/

{
    NTSTATUS                        Status;
    ULONG                           BufferLength;
    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;
    PVOID                           KeyValueInformation;
    ULONG                           ResultLength;

    BYTE    PrivateKeyValueInformation[ sizeof( KEY_VALUE_FULL_INFORMATION ) +
                                        DEFAULT_VALUE_NAME_SIZE +
                                        sizeof(UNICODE_NULL) +
                                        DEFAULT_VALUE_SIZE +
                                        sizeof(UNICODE_NULL) ];
    HKEY                            hkEnum;
#ifdef LOCAL
    ValueState*                     pValState;

    pValState = NULL;
#endif // LOCAL    
    hkEnum = hKey;

    //
    //  If the client gave us a bogus size, patch it.
    //
    if ( ARGUMENT_PRESENT( lpcbData ) && !ARGUMENT_PRESENT( lpData ) ) {
        *lpcbData = 0;
    }

    //
    // Call out to Perflib if the HKEY is HKEY_PERFOMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {

        return (error_status_t)PerfRegEnumValue (
                                    hKey,
                                    dwIndex,
                                    lpValueName,
                                    NULL,
                                    lpType,
                                    lpData,
                                    lpcbData,
                                    lpcbLen
                                    );
    }

#ifdef LOCAL
    //
    // If we are in HKEY_CLASSES_ROOT, then we need to remap
    // the key / index pair to take into account merging
    //

    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {
        
        //
        // Find a key state for this key
        //
        Status = BaseRegGetClassKeyValueState(
            hKey,
            dwIndex,
            &pValState);

        if (!NT_SUCCESS(Status)) {
            return (error_status_t)RtlNtStatusToDosError(Status);
        }

        //
        // Now remap to the appropriate key / index 
        //
        ValStateGetPhysicalIndexFromLogical(
            pValState,
            hKey,
            dwIndex,
            &hkEnum,
            &dwIndex);

    }
#endif // LOCAL

    //
    //  First we assume that the information we want will fit on
    //  PrivateKeyValueInformattion
    //

    KeyValueInformationClass = ( ARGUMENT_PRESENT( lpcbData ))?
                               KeyValueFullInformation :
                               KeyValueBasicInformation;


    KeyValueInformation = PrivateKeyValueInformation;
    BufferLength = sizeof( PrivateKeyValueInformation );

    //
    // Query for the necessary information about the supplied value.
    //

    Status = NtEnumerateValueKey( hkEnum,
                                  dwIndex,
                                  KeyValueInformationClass,
                                  KeyValueInformation,
                                  BufferLength,
                                  &ResultLength
                                );

    //
    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
    // was not enough room for even the known (i.e. fixed length portion)
    // of the structure.
    //

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );


    if( Status == STATUS_BUFFER_OVERFLOW ) {
        //
        //  The buffer defined in the stack wasn't big enough to hold
        //  the Value information.
        //  If the caller's buffer are big enough to hold the value name
        //  and value data, then allocate a new buffer, and call the
        //  NT API again.
        //
        if( ( ( KeyValueInformationClass == KeyValueBasicInformation ) &&
              ( (ULONG)(lpValueName->MaximumLength) >=
                 (( PKEY_VALUE_BASIC_INFORMATION )
                 KeyValueInformation )->NameLength + sizeof(UNICODE_NULL)
              )
            ) ||
            ( ( KeyValueInformationClass == KeyValueFullInformation ) &&
              ( (ULONG)(lpValueName->MaximumLength) >=
                 (( PKEY_VALUE_FULL_INFORMATION )
                 KeyValueInformation )->NameLength + sizeof(UNICODE_NULL)
              ) &&
              ( !ARGUMENT_PRESENT( lpData ) ||
                ( ARGUMENT_PRESENT( lpData ) &&
                  ARGUMENT_PRESENT( lpcbData ) &&
                  ( *lpcbData >= (( PKEY_VALUE_FULL_INFORMATION )
                        KeyValueInformation )->DataLength
                  )
                )
              )
            )
          ) {
            BufferLength = ResultLength;

            KeyValueInformation = RtlAllocateHeap( RtlProcessHeap( ), 0,
                                                   BufferLength
                                                 );
            //
            // If the memory allocation fails, return a Registry error.
            //

            if( ! KeyValueInformation ) {
#ifdef LOCAL
                ValStateRelease(pValState);
#endif // LOCAL
                return ERROR_OUTOFMEMORY;
            }

            //
            // Query for the necessary information about the supplied value. This
            // may or may not include the data depending on lpcbData as determined
            // above.
            //

            Status = NtEnumerateValueKey( hkEnum,
                                          dwIndex,
                                          KeyValueInformationClass,
                                          KeyValueInformation,
                                          BufferLength,
                                          &ResultLength
                                        );
        }
    }

#ifdef LOCAL
    ValStateRelease(pValState);
#endif // LOCAL

    //
    //  If the API succeeded, try to copy the value name to the client's buffer
    //

    if( NT_SUCCESS( Status ) ) {
        //
        //  Copy value name
        //

        if( KeyValueInformationClass == KeyValueBasicInformation ) {
            //
            // Return the name length and the name of the value.
            // Note that the NUL byte is included so that RPC copies the
            // correct number of bytes. It is decremented on the client
            // side.
            //

            if( (ULONG)(lpValueName->MaximumLength) >=
                 (( PKEY_VALUE_BASIC_INFORMATION )
                  KeyValueInformation )->NameLength + sizeof( UNICODE_NULL )) {

                //
                // If client's buffer is big enough for the name,
                // copy the value name and NUL terminate it
                //
                lpValueName->Length = ( USHORT )
                                      (( PKEY_VALUE_BASIC_INFORMATION )
                                          KeyValueInformation )->NameLength;

                RtlMoveMemory( lpValueName->Buffer,
                               (( PKEY_VALUE_BASIC_INFORMATION )
                               KeyValueInformation )->Name,
                               lpValueName->Length
                             );

                lpValueName->Buffer[ lpValueName->Length >> 1 ] = UNICODE_NULL;

                //
                // Value name length must include size of UNICODE_NULL.
                // It will be decremented in the client side
                //

                lpValueName->Length += sizeof( UNICODE_NULL );

            } else {
                //
                //  If the client's buffer for the value name is not big
                //  enough, then set status to STATUS_BUFFER_OVERFLOW.
                //
                //  Note that in the remote case, RPC will transmit garbage
                //  in the buffer back to the client.
                //  We cannot set the buffer to prevent this transmission,
                //  because in the local case we would be destroying the
                //  buffer in the &NtCurrectTeb->StaticUnicodeString.
                //

                Status = STATUS_BUFFER_OVERFLOW;
            }

        } else {
            //
            // Here if KeyValueInformation == KeyValueFullInformation
            //
            // Return the name length and the name of the value.
            // Note that the NUL byte is included so that RPC copies the
            // correct number of bytes. It is decremented on the client
            // side.
            //

            if( (ULONG)(lpValueName->MaximumLength) >=
                 (( PKEY_VALUE_FULL_INFORMATION )
                  KeyValueInformation )->NameLength + sizeof( UNICODE_NULL )) {

                //
                // If client's buffer is big enough for the name,
                // copy the value name and NUL terminate it
                //
                lpValueName->Length = ( USHORT )
                                      (( PKEY_VALUE_FULL_INFORMATION )
                                          KeyValueInformation )->NameLength;

                RtlMoveMemory( lpValueName->Buffer,
                               (( PKEY_VALUE_FULL_INFORMATION )
                               KeyValueInformation )->Name,
                               lpValueName->Length
                             );

                lpValueName->Buffer[ lpValueName->Length >> 1 ] = UNICODE_NULL;

                //
                // Value name length must include size of UNICODE_NULL.
                // It will be decremented in the client side
                //

                lpValueName->Length += sizeof( UNICODE_NULL );

            } else {
                //
                //  If the client's buffer for the value name is not big
                //  enough, then set status to STATUS_BUFFER_OVERFLOW.
                //
                //  Note that in the remote case, RPC will transmit garbage
                //  in the buffer back to the client.
                //  We cannot set the buffer to prevent this transmission,
                //  because in the local case we would be destroying the
                //  buffer in the &NtCurrectTeb->StaticUnicodeString.
                //

                Status = STATUS_BUFFER_OVERFLOW;
            }

        }
    }



    if( NT_SUCCESS( Status ) &&
        ARGUMENT_PRESENT( lpData ) ) {

        //
        //  If we were able to copy the value name to the client's buffer
        //  and the value data is also requested, then try to copy it
        //  to the client's buffer
        //

        if( *lpcbData >= (( PKEY_VALUE_FULL_INFORMATION )
                           KeyValueInformation )->DataLength ) {
            //
            // If the buffer is big enough to hold the data, copy the data
            //
            RtlMoveMemory( lpData,
                           ( PBYTE ) KeyValueInformation
                             + (( PKEY_VALUE_FULL_INFORMATION )
                                KeyValueInformation )->DataOffset,
                           (( PKEY_VALUE_FULL_INFORMATION )
                                     KeyValueInformation )->DataLength
                         );
        } else {
            //
            // If buffer is not big enough to hold the data, then return
            // STATUS_BUFFER_OVERFLOW.
            //
            //  Note that in the remote case, RPC will transmit garbage
            //  in the buffer back to the client.
            //  We cannot set the buffer to prevent this transmission,
            //  because in the local case we would be destroying the
            //  buffer in the &NtCurrectTeb->StaticUnicodeString.
            //
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }



    //
    // Certain information is returned on success or in the case of
    // NtEnumerateValueKey returning STATUS_BUFFER_OVERFLOW.  This information
    // is always available because we always pass the minimum size required for
    // the NtEnumerateValueKey API.
    //

    if( NT_SUCCESS( Status ) ||
        ( Status == STATUS_BUFFER_OVERFLOW ) ) {

        if( KeyValueInformationClass == KeyValueBasicInformation ) {

            //
            // If requested, return the value type.
            //

            if( ARGUMENT_PRESENT( lpType )) {

                *lpType = (( PKEY_VALUE_BASIC_INFORMATION )
                            KeyValueInformation )->Type;
            }

//            lpValueName->Length
//                = ( USHORT ) ((( PKEY_VALUE_BASIC_INFORMATION )
//                KeyValueInformation )->NameLength + sizeof( UNICODE_NULL ) );

        } else {
            //
            // Here if KeyValueInformationClass == KeyValueFullInformation
            //

            //
            // If requested, return the value type.
            //

            if( ARGUMENT_PRESENT( lpType )) {

                *lpType = (( PKEY_VALUE_FULL_INFORMATION )
                            KeyValueInformation )->Type;
            }

//            lpValueName->Length
//                = ( USHORT ) ((( PKEY_VALUE_FULL_INFORMATION )
//                KeyValueInformation )->NameLength + sizeof( UNICODE_NULL ) );

            *lpcbData = (( PKEY_VALUE_FULL_INFORMATION )
                            KeyValueInformation )->DataLength;
        }
    }

    //
    // Transmit all of the value data back to the client.
    //

    if( NT_SUCCESS( Status ) ) {
        if( ARGUMENT_PRESENT( lpcbLen  ) &&
            ARGUMENT_PRESENT( lpcbData ) ) {
            *lpcbLen = *lpcbData;
        }
    } else {
        //
        // If something failed, don't transmit any data back to the client
        //
        if( ARGUMENT_PRESENT( lpcbLen ) ) {
            *lpcbLen = 0;
        }
    }

    //
    //  Free memory if it was allocated
    //
    if( KeyValueInformation != PrivateKeyValueInformation ) {

        RtlFreeHeap( RtlProcessHeap( ), 0, KeyValueInformation );

    }

    return (error_status_t)RtlNtStatusToDosError( Status );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regkey.c ===
/*++



Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regkey.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry APIs to open, create, flush and close keys.  That is:

        - BaseRegCloseKey
        - BaseRegCreateKey
        - BaseRegFlushKey
        - BaseRegOpenKey

Author:

    David J. Gilman (davegi) 15-Nov-1991

Notes:

    These notes apply to the Win32 Registry API implementation as a whole
    and not just to this module.

    On the client side, modules contain RPC wrappers for both the new
    Win32 and compatible Win 3.1 APIs.  The Win 3.1 wrappers generally
    supply default parameters before calling the Win32 wrappers.  In some
    cases they may need to call multiple Win32 wrappers in order to
    function correctly (e.g.  RegSetValue sometimes needs to call
    RegCreateKeyEx).  The Win32 wrappers are quite thin and usually do
    nothing more than map a predefined handle to a real handle and perform
    ANSI<->Unicode translations.  In some cases (e.g.  RegCreateKeyEx) the
    wrapper also converts some argument (e.g.  SECURITY_ATTRIBUTES) to an
    RPCable representation.  In both the Win 3.1 and Win32 cases ANSI and
    Unicode implementations are provided.

    On the server side, there is one entry point for each of the Win32
    APIs.  Each contains an identical interface with the client side
    wrapper with the exception that all string / count arguments are
    passed as a single counted Unicode string.  Pictorially, for an API
    named "F":

                RegWin31FA()          RegWin31FW()      (client side)

                    |                     |
                    |                     |
                    |                     |
                    |                     |
                    V                     V

                RegWin32FExA()        RegWin32FExW()

                    |                     |
                    ^                     ^
                    v                     v             (RPC)
                    |                     |
                    |                     |
                    +----> BaseRegF() <---+             (server side)


    This yields smaller code (as the string conversion is done only once
    per API) at the cost of slightly higher maintenance (i.e. Win 3.1
    default parameter replacement and Win32 string conversions must be
    manually kept in synch).

    Another option would be to have a calling sequence that looks like,

                RegWin31FA()          RegWin31FW()

                    |                     |
                    |                     |
                    |                     |
                    V                     V

                RegWin32FExA() -----> RegWin32FExW()

    and have the RegWin32FExW() API perform all of the actual work.  This
    method is generally less efficient.  It requires the RegWin32FExA()
    API to convert its ANSI string arguments to counted Unicode strings,
    extract the buffers to call the RegWin32FExW() API only to have it
    rebuild a counted Unicode string.  However in some cases (e.g.
    RegConnectRegistry) where a counted Unicode string was not needed in
    the Unicode API this method is used.

    Details of an API's functionality, arguments and return value can be
    found in the base implementations (e.g.  BaseRegF()).  All other
    function headers contain only minimal routine descriptions and no
    descriptions of their arguments or return value.

    The comment string "Win3.1ism" indicates special code for Win 3.1
    compatability.

    Throughout the implementation the following variable names are used
    and always refer to the same thing:

        Obja        - An OBJECT_ATTRIBUTES structure.
        Status      - A NTSTATUS value.
        Error       - A Win32 Registry error code (n.b. one of the error
                      values is ERROR_SUCCESS).

--*/

#include <rpc.h>
#include <string.h>
#include <wchar.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regecls.h"
#include "regsec.h"
#include <malloc.h>

#ifdef LOCAL
#include "tsappcmp.h"

#ifdef LEAK_TRACK
#include "regleak.h"
#endif // LEAK_TRACK

#endif

NTSTATUS
BaseRegCreateMultipartKey(
    IN HKEY hkDestKey,
    IN PUNICODE_STRING pDestSubKey,
    IN PUNICODE_STRING lpClass OPTIONAL,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN PRPC_SECURITY_ATTRIBUTES pRpcSecurityAttributes OPTIONAL,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition OPTIONAL,
    ULONG             Attributes);



BOOL
InitializeRegCreateKey(
    )

/*++

Routine Description:

    This function was used to initialize a critical section that no longer
    exists. This critical section was used when a key name '\', and multiple
    multiple keys were to be created. The API used the wcstok defined in the
    kernel, which was not multi-threaded safe.

    This function now will always return TRUE. It will not be removed from the code
    to avoid change in the rpc interface.

Arguments:

    None.

Return Value:

    Returns TRUE always.

--*/

{
    return( TRUE );

}



BOOL
CleanupRegCreateKey(
    )

/*++

Routine Description:

    This function was used to clean up a critical section that no longer
    exists. This critical section was used when a key name '\', and multiple
    multiple keys were to be created. The API used the wcstok defined in the
    kernel, which was not multi-threaded safe.

    This function now will always return TRUE. It will not be removed from the code
    to avoid change in the rpc interface.



Arguments:

    None.

Return Value:

    Returns TRUE if the cleanup succeeds.

--*/

{
    return( TRUE );
}



error_status_t
BaseRegCloseKeyInternal(
    IN OUT PHKEY phKey
    )

/*++

Routine Description:

    Closes a key handle.

Arguments:

    phKey - Supplies a handle to an open key to be closed.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    NTSTATUS Status;
#if defined(LEAK_TRACK)
    BOOL fTrack;
#endif // defined(LEAK_TRACK)

    //
    // Call out to Perflib if the HKEY is HKEY_PERFOMANCE_DATA.
    //

    if(( *phKey == HKEY_PERFORMANCE_DATA ) ||
       ( *phKey == HKEY_PERFORMANCE_TEXT ) ||
       ( *phKey == HKEY_PERFORMANCE_NLSTEXT )) {

        Status = PerfRegCloseKey( phKey );
        return (error_status_t)Status;
    }

    ASSERT( IsPredefinedRegistryHandle( *phKey ) == FALSE );

#ifdef LOCAL
    //
    // now we need to remove any state for registry key enumeration associated
    // with this key if it's a class registration parent
    //
    if (REG_CLASS_IS_SPECIAL_KEY(*phKey)) {

        // this may not succeed since someone could have already removed this key
        (void) EnumTableRemoveKey(
            &gClassesEnumTable,
            *phKey,
            ENUM_TABLE_REMOVEKEY_CRITERIA_ANYTHREAD);
    }

#if defined(LEAK_TRACK)

    if (g_RegLeakTraceInfo.bEnableLeakTrack) {
        fTrack = RegLeakTableIsTrackedObject(&gLeakTable, *phKey);
    }

#endif // defined(LEAK_TRACK)

#endif // LOCAL


    Status = NtClose( *phKey );

    if( NT_SUCCESS( Status )) {

#ifdef LOCAL
#if defined(LEAK_TRACK)

        if (g_RegLeakTraceInfo.bEnableLeakTrack) {
            if (fTrack) {
                (void) UnTrackObject(*phKey);
            }
        }

#endif // defined(LEAK_TRACK)
#endif // LOCAL

        //
        // Set the handle to NULL so that RPC knows that it has been closed.
        //
        *phKey = NULL;

        return ERROR_SUCCESS;

    } else {

        return (error_status_t)RtlNtStatusToDosError( Status );
    }
}



error_status_t
BaseRegCloseKey(
    IN OUT PHKEY phKey
    )

/*++

Routine Description:

    Closes a key handle.

Arguments:

    phKey - Supplies a handle to an open key to be closed.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    error_status_t Error;

#ifndef LOCAL
    RPC_STATUS _rpcstatus = RpcImpersonateClient( NULL );
#if DBG
    if( _rpcstatus != ERROR_SUCCESS ) {
        DbgPrint("WINREG: BaseRegCloseKey: Failed to impersonate in process %p, thread %p, for handle %p \n",NtCurrentProcess(),NtCurrentThread(),*phKey);
    }
#endif
#endif //LOCAL

    Error = BaseRegCloseKeyInternal(phKey);

#ifndef LOCAL

#if DBG
    if( _rpcstatus != ERROR_SUCCESS ) {
        DbgPrint("WINREG: BaseRegCloseKeyInternal without impersonation returned %lx\n",Error);
    }
#endif

    if (_rpcstatus == ERROR_SUCCESS) {
        RpcRevertToSelf();
    }
#endif

    return Error;
}


error_status_t
BaseRegCreateKey(
    IN HKEY hKey,
    IN PUNICODE_STRING lpSubKey,
    IN PUNICODE_STRING lpClass OPTIONAL,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN PRPC_SECURITY_ATTRIBUTES pRpcSecurityAttributes OPTIONAL,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition OPTIONAL
    )

/*++

Routine Description:

    Create a new key, with the specified name, or open an already existing
    key.  RegCreateKeyExW is atomic, meaning that one can use it to create
    a key as a lock.  If a second caller creates the same key, the call
    will return a value that says whether the key already existed or not,
    and thus whether the caller "owns" the "lock" or not.  RegCreateKeyExW
    does NOT truncate an existing entry, so the lock entry may contain
    data.

Arguments:

    hKey - Supplies a handle to an open key.  The lpSubKey key path
        parameter is relative to this key handle.  Any of the predefined
        reserved handle values or a previously opened key handle may be used
        for hKey.

    lpSubKey - Supplies the downward key path to the key to create.
        lpSubKey is always relative to the key specified by hKey.
        This parameter may not be NULL.

    lpClass - Supplies the class (object type) of this key.  Ignored if
        the key already exists.  No class is associated with this key if
        this parameter is NULL.

    dwOptions - Supplies special options.  Only one is currently defined:

        REG_VOLATILE -  Specifies that this key should not be preserved
            across reboot.  The default is not volatile.  This is ignored
            if the key already exists.

        WARNING: All descendent keys of a volatile key are also volatile.

    samDesired - Supplies the requested security access mask.  This
        access mask describes the desired security access to the newly
        created key.

    lpSecurityAttributes - Supplies a pointer to a SECURITY_ATTRIBUTES
        structure for the newly created key. This parameter is ignored
        if NULL or not supported by the OS.

    phkResult - Returns an open handle to the newly created key.

    lpdwDisposition - Returns the disposition state, which can be one of:

            REG_CREATED_NEW_KEY - the key did not exist and was created.

            REG_OPENED_EXISTING_KEY - the key already existed, and was simply
                opened without being changed.

        This parameter is ignored if NULL.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

    If successful, RegCreateKeyEx creates the new key (or opens the key if
    it already exists), and returns an open handle to the newly created
    key in phkResult.  Newly created keys have no value; RegSetValue, or
    RegSetValueEx must be called to set values.  hKey must have been
    opened for KEY_CREATE_SUB_KEY access.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    ULONG               Attributes;
    NTSTATUS            Status;
#if DBG
    HANDLE              DebugKey = hKey;
#endif
    HKEY                hkDestKey;
    UNICODE_STRING      DestClassSubkey;
    PUNICODE_STRING     pDestSubkey;
    DWORD               dwDisposition;
    BOOL                fRetryOnAccessDenied;
    BOOL                fRetried;
    BOOL                fTrySingleCreate;
#if LOCAL
    SKeySemantics       keyinfo;
    BYTE                rgNameInfoBuf[REG_MAX_CLASSKEY_LEN];
    REGSAM              OriginalSam = samDesired;
    UNICODE_STRING      TmpStr = *lpSubKey; //used to keep original SubKey string


    memset(&keyinfo, 0, sizeof(keyinfo));
#endif

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );
    ASSERT( lpSubKey->Length > 0 );

    DestClassSubkey.Buffer = NULL;

    //
    // For class registrations, retry on access denied in machine hive --
    // if we do retry, this will be set to FALSE so we only retry once
    //
    fRetryOnAccessDenied = TRUE;
    fRetried = FALSE;

    //
    // First attempt should do create with a single ntcreatekey call
    // If that doesn't work, this gets set to false so we remember if we
    // have to retry for access denied in the machine hive
    //
    fTrySingleCreate = TRUE;

    hkDestKey = NULL;
    pDestSubkey = NULL;


    //
    // Quick check for a "restricted" handle
    //

    if ( REGSEC_CHECK_HANDLE( hKey ) )
    {
        if ( ! REGSEC_CHECK_PATH( hKey, lpSubKey ) )
        {
            return( ERROR_ACCESS_DENIED );
        }

        hKey = REGSEC_CLEAR_HANDLE( hKey );
    }

    //
    // Check for malformed arguments from malicious clients
    //

    if ((lpSubKey->Length < sizeof(UNICODE_NULL)) ||
        (lpSubKey->Buffer == NULL) ||
        ((lpSubKey->Length % sizeof(WCHAR)) != 0) ||
        (lpSubKey->Buffer[lpSubKey->Length / sizeof(WCHAR) - 1] != L'\0')) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Initialize the variable that will contain the handle to NULL
    //  to ensure that in case of error the API will not return a
    //  bogus handle. This is required otherwise RPC will get confused.
    //  Note that RPC should have already initialized it to 0.
    //
    *phkResult = NULL;

    //
    //  Subtract the NULLs from the Length of the provided strings.
    //  These were added on the client side so that the NULLs were
    //  transmitted by RPC.
    //
    lpSubKey->Length -= sizeof( UNICODE_NULL );

    if( lpSubKey->Buffer[0] == ( WCHAR )'\\' ) {
        //
        // Do not accept a key name that starts with '\', even though
        // the code below would handle it. This is to ensure that
        // RegCreateKeyEx and RegOpenKeyEx will behave in the same way
        // when they get a key name that starts with '\'.
        //
        Status = STATUS_OBJECT_PATH_INVALID;
        goto cleanup;
    }

    if ( lpClass->Length > 0 ) {
        lpClass->Length -= sizeof( UNICODE_NULL );
    }

    //
    // Determine the correct set of attributes.
    //

    Attributes = OBJ_CASE_INSENSITIVE;

    if( ARGUMENT_PRESENT( pRpcSecurityAttributes )) {

        if( pRpcSecurityAttributes->bInheritHandle ) {

            Attributes |= OBJ_INHERIT;
        }
    }

    if (dwOptions & REG_OPTION_OPEN_LINK) {
        Attributes |= OBJ_OPENLINK;
    }

#ifdef LOCAL
    if (REG_CLASS_IS_SPECIAL_KEY(hKey) ||
        ( (gdwRegistryExtensionFlags & TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION ) 
             && ExtractClassKey(&hKey,lpSubKey) ) ) {

        //
        // Find more information
        // about this key -- the most important piece of information
        // is whether it's a class registration key
        //
        keyinfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameInfoBuf;
        keyinfo._cbFullPath = sizeof(rgNameInfoBuf);
        keyinfo._fAllocedNameBuf = FALSE;

        //
        // see if this is a class registration
        //
        Status = BaseRegGetKeySemantics(hKey, lpSubKey, &keyinfo);

        // if we can't determine what type of key this is, leave
        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

        Status = BaseRegMapClassRegistrationKey(
            hKey,
            lpSubKey,
            &keyinfo,
            &DestClassSubkey,
            &fRetryOnAccessDenied,
            &hkDestKey,
            &pDestSubkey);

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

    } else
#endif // LOCAL
    {
#ifdef LOCAL
        memset(&keyinfo, 0, sizeof(keyinfo));
#endif // LOCAL

        hkDestKey = hKey;
        pDestSubkey = lpSubKey;
    }


    for (;;) {

#ifdef LOCAL

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

        if (fTrySingleCreate)
        {
#endif

            //
            // Validate the security descriptor.
            //
            if( ARGUMENT_PRESENT( pRpcSecurityAttributes ) &&
                (pRpcSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor ||
                 pRpcSecurityAttributes->RpcSecurityDescriptor.cbInSecurityDescriptor))
            {
                if( !RtlValidRelativeSecurityDescriptor((PSECURITY_DESCRIPTOR)(pRpcSecurityAttributes->RpcSecurityDescriptor.lpSecurityDescriptor),
                                                        pRpcSecurityAttributes->RpcSecurityDescriptor.cbInSecurityDescriptor,
                                                        0 )) {
                    //
                    //  We were passed a bogus security descriptor to set.  Bail out
                    //

                    Status = STATUS_INVALID_PARAMETER;
                    goto cleanup;
                }
            }

            //
            // Try to create the specified key. This will work if there is only
            // one key being created or if the key already exists. If more than
            // one key needs to be created, this will fail and we will have to
            // do all the complicated stuff to create each intermediate key.
            //
            InitializeObjectAttributes(&Obja,
                                       pDestSubkey,
                                       Attributes,
                                       hkDestKey,
                                       ARGUMENT_PRESENT( pRpcSecurityAttributes )
                                       ? pRpcSecurityAttributes
                                       ->RpcSecurityDescriptor.lpSecurityDescriptor
                                       : NULL);
            Status = NtCreateKey(phkResult,
                                 samDesired,
                                 &Obja,
                                 0,
                                 lpClass,
                                 dwOptions,
                                 &dwDisposition);


#ifdef LOCAL
            if (gpfnTermsrvCreateRegEntry && NT_SUCCESS(Status) && (dwDisposition == REG_CREATED_NEW_KEY)) {
                //
                // Terminal Server application compatiblity
                // Store the newly created key in the Terminal Server registry tracking database
                //

                gpfnTermsrvCreateRegEntry(*phkResult,
                                          &Obja,
                                          0,
                                          lpClass,
                                          dwOptions);
            }

        }

#ifdef CLASSES_RETRY_ON_ACCESS_DENIED
        if (fTrySingleCreate && (STATUS_ACCESS_DENIED == Status) && keyinfo._fCombinedClasses &&
            fRetryOnAccessDenied ) {

            Status = BaseRegMapClassOnAccessDenied(
                    &keyinfo,
                    &hkDestKey,
                    pDestSubkey,
                    &fRetryOnAccessDenied);

            if (NT_SUCCESS(Status)) {
                fRetried = TRUE;
                continue;
            }

            // we failed for some reason -- exit
            break;

        }
#else
        //if (it's terminal server; we're trying to create single key;
        //we've got ASSESS_DENIED trying to create key
        //a key we want to create is HKCR subkey(keyinfo._fCombinedClasses!=0);
        //Registry flag is set to allow per user classes redirection.
        //(fRetryOnAccessDenied !=0 - means that parent key is not in the user hive))
        //then try to create the key in the user hive.
        if ( (gdwRegistryExtensionFlags & TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION) 
             && fTrySingleCreate && (STATUS_ACCESS_DENIED == Status)
                && keyinfo._fCombinedClasses && fRetryOnAccessDenied 
           ) {


                if (DestClassSubkey.Buffer) {
                    RegClassHeapFree(DestClassSubkey.Buffer);
                    DestClassSubkey.Buffer=NULL;
                }

                Status = BaseRegMapClassOnAccessDenied(
                        &keyinfo,
                        &hkDestKey,
                        pDestSubkey,
                        &fRetryOnAccessDenied);

                if (NT_SUCCESS(Status)) {
                    fRetried = TRUE;
                    continue;
                }

            // we failed for some reason -- exit
            break;

        }
#endif // CLASSES_RETRY_ON_ACCESS_DENIED
#endif // LOCAL

        fTrySingleCreate = FALSE;

        if (NT_SUCCESS(Status)) {

            if (lpdwDisposition) {
                *lpdwDisposition = dwDisposition;
            }

        } else {

            Status = BaseRegCreateMultipartKey(
                hkDestKey,
                pDestSubkey,
                lpClass,
                dwOptions,
                samDesired,
                pRpcSecurityAttributes,
                phkResult,
                lpdwDisposition,
                Attributes);
        }

#ifdef LOCAL
#ifdef CLASSES_RETRY_ON_ACCESS_DENIED
        if ((STATUS_ACCESS_DENIED == Status) && keyinfo._fCombinedClasses &&
            fRetryOnAccessDenied ) {

            Status = BaseRegMapClassOnAccessDenied(
                    &keyinfo,
                    &hkDestKey,
                    pDestSubkey,
                    &fRetryOnAccessDenied);

            if (NT_SUCCESS(Status)) {
                fRetried = TRUE;
                continue;
            }

            break;

        }
#else
        //We've tried to create single key and failed (Status !=STATUS_ACCESS_DENIED)
        //then we tried to create multipart key and got access denied
        //thus we've got here
        if ( (gdwRegistryExtensionFlags & TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION) 
             && (STATUS_ACCESS_DENIED == Status) 
             && keyinfo._fCombinedClasses && fRetryOnAccessDenied 
           ) {

            if (DestClassSubkey.Buffer) {
                RegClassHeapFree(DestClassSubkey.Buffer);
                DestClassSubkey.Buffer=NULL;
            }

            Status = BaseRegMapClassOnAccessDenied(
                    &keyinfo,
                    &hkDestKey,
                    pDestSubkey,
                    &fRetryOnAccessDenied);

            if (NT_SUCCESS(Status)) {
                fRetried = TRUE;
                continue;
            }

            break;

        }
#endif //  CLASSES_RETRY_ON_ACCESS_DENIED

        if (NT_SUCCESS(Status)) {
            if (keyinfo._fCombinedClasses) {
                // mark this key as part of hkcr
                *phkResult = REG_CLASS_SET_SPECIAL_KEY(*phkResult);
            }
        }

#endif // LOCAL

        break;
    }

cleanup:


#ifdef CLASSES_RETRY_ON_ACCESS_DENIED
    //
    // Memory was allocated if we retried, so free it
    //
    if (fRetried && pDestSubkey->Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, pDestSubkey->Buffer);
        pDestSubkey->Buffer = NULL;
    }
#endif // CLASSES_RETRY_ON_ACCESS_DENIED

    if (hkDestKey && (hkDestKey != hKey)) {
        NtClose(hkDestKey);
    }

#ifdef LOCAL
    if (DestClassSubkey.Buffer) {
        RegClassHeapFree(DestClassSubkey.Buffer);
    }

    BaseRegReleaseKeySemantics(&keyinfo);

    *lpSubKey = TmpStr; //restore original SubKey string
#endif // LOCAL

    if (NT_SUCCESS(Status)) {
#ifdef LOCAL
#if defined(LEAK_TRACK)

        if (g_RegLeakTraceInfo.bEnableLeakTrack) {
            (void) TrackObject(*phkResult);
        }

#endif // defined(LEAK_TRACK)
#endif LOCAL
        // disabled, for the case where we specifically close a predefined key inside 
		// RegOpenKeyExA and RegOpenKeyExW
		//ASSERT( *phkResult != DebugKey );
    }

    RPC_REVERT_TO_SELF();

    return (error_status_t)RtlNtStatusToDosError( Status );

}



NTSTATUS
BaseRegCreateMultipartKey(
    IN HKEY hkDestKey,
    IN PUNICODE_STRING pDestSubKey,
    IN PUNICODE_STRING lpClass OPTIONAL,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN PRPC_SECURITY_ATTRIBUTES pRpcSecurityAttributes OPTIONAL,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition OPTIONAL,
    ULONG             Attributes)
/*++

Routine Description:

    This function creates registry keys for which multiple path components
    are nonexistent.  It parses the key path and creates each intermediate
    subkey.

Arguments:

    See BaseRegCreateKey.

Return Value:

    Returns STATUS_SUCCESS on success, other NTSTATUS if failed.

--*/
{
    LPWSTR            KeyBuffer;
    ULONG             NumberOfSubKeys;
    LPWSTR            p;
    ULONG             i;
    LPWSTR            Token;
    UNICODE_STRING    KeyName;
    HANDLE            TempHandle1;
    HANDLE            TempHandle2;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS          Status;
    DWORD             dwDisposition;
#ifdef LOCAL
    REGSAM            OriginalSam = samDesired;
#endif // LOCAL

    dwDisposition = REG_OPENED_EXISTING_KEY;
    TempHandle1 = NULL;

    //
    // Win3.1ism - Loop through each '\' separated component in the
    // supplied sub key and create a key for each component. This is
    // guaranteed to work at least once because lpSubKey was validated
    // on the client side.
    //


    //
    // Initialize the buffer to be tokenized.
    //

    KeyBuffer = pDestSubKey->Buffer;

    //
    //  Find out the number of subkeys to be created
    //
    NumberOfSubKeys = 1;
    p = KeyBuffer;
    while ( ( p = wcschr( p, ( WCHAR )'\\' ) ) != NULL ) {
        p++;
        NumberOfSubKeys++;
    }

    for( i = 0, Token = KeyBuffer; i < NumberOfSubKeys; i++ ) {

        ASSERT(Token != NULL);

        if( ( *Token == ( WCHAR )'\\' ) &&
            ( i != NumberOfSubKeys - 1 ) ) {
            //
            //  If the first character of the key name is '\', and the key
            //  is not the last to be created, then ignore this key name.
            //  This condition can happen if the key name contains
            //  consecutive '\'.
            //  This behavior is consistent with the one we had in the past
            //  when the API used wcstok() to get the key names.
            //  Note that if the key name is an empty string, we return a handle
            //  that is different than hKey, even though both point to the same
            //  key. This is by design.
            //
            Token++;
            continue;
        }

        //
        // Convert the token to a counted Unicode string.
        //
        KeyName.Buffer = Token;
        if (i == NumberOfSubKeys - 1) {
            KeyName.Length = wcslen(Token)*sizeof(WCHAR);
        } else {
            KeyName.Length = (USHORT)(wcschr(Token, ( WCHAR )'\\') - Token)*sizeof(WCHAR);
        }

        //
        // Remember the intermediate handle (NULL the first time through).
        //

        TempHandle2 = TempHandle1;

        {
            //
            // Initialize the OBJECT_ATTRIBUTES structure, close the
            // intermediate key and create or open the key.
            //

            InitializeObjectAttributes(
                &Obja,
                &KeyName,
                Attributes,
                hkDestKey,
                ARGUMENT_PRESENT( pRpcSecurityAttributes )
                ? pRpcSecurityAttributes
                ->RpcSecurityDescriptor.lpSecurityDescriptor
                : NULL
                );

            Status = NtCreateKey(
                &TempHandle1,
                ( i == NumberOfSubKeys - 1 )? samDesired : 
                    (samDesired & KEY_WOW64_RES) | MAXIMUM_ALLOWED,
                &Obja,
                0,
                lpClass,
                dwOptions,
                &dwDisposition
                );

            if (NT_SUCCESS(Status) && lpdwDisposition) {
                *lpdwDisposition = dwDisposition;
            }

#ifdef LOCAL
            // This code is in Hydra 4. We have disabled this for NT 5
            // for now till we are sure that its needed to get some imporatant
            // app to work on Hydra 5. Otherwise this should be removed
            if ( gdwRegistryExtensionFlags & TERMSRV_ENABLE_ACCESS_FLAG_MODIFICATION ) {

                // For Terminal Server only.
                // Some apps try to create/open the key with all of the access bits
                // turned on.  We'll mask off the ones they don't have access to by
                // default, (at least under HKEY_LOCAL_MACHINE\Software) and try to
                // open the key again.
                if (Status == STATUS_ACCESS_DENIED) {
                    //MAXIMUM_ALLOWED does not include ACCESS_SYSTEM_SECURITY
                    //so if user asks for this permission, we need to add it.
                    //It could result in ACCESS_DENIED error but for 
                    //TS App. Compat. it is not important.
                    Status = NtCreateKey(
                            &TempHandle1,
                            (samDesired & (KEY_WOW64_RES | ACCESS_SYSTEM_SECURITY) ) | MAXIMUM_ALLOWED,
                            &Obja,
                            0,
                            lpClass,
                            dwOptions,
                            &dwDisposition);

                        // Give app back the original error
                        if (!NT_SUCCESS(Status)) {
                            Status = STATUS_ACCESS_DENIED;
                        }

                        if (lpdwDisposition) {
                             *lpdwDisposition = dwDisposition;
                        }
                }
            }


            if (gpfnTermsrvCreateRegEntry && NT_SUCCESS(Status) && (dwDisposition == REG_CREATED_NEW_KEY)) {

                //
                // Terminal Server application compatiblity
                // Store the newly created key in the Terminal Server registry tracking database
                //
                gpfnTermsrvCreateRegEntry(TempHandle1,
                                          &Obja,
                                          0,
                                          lpClass,
                                          dwOptions);
            }
#endif
        }

        //
        // Initialize the next object directory (i.e. parent key) handle.
        //

        hkDestKey = TempHandle1;

        //
        // Close the intermediate key.
        // This fails the first time through the loop since the
        // handle is NULL.
        //

        if( TempHandle2 != NULL ) {
            NtClose( TempHandle2 );
        }

        //
        // If creating the key failed, map and return the error.
        //

        if( ! NT_SUCCESS( Status )) {
            return Status;
        }

        Token = wcschr( Token, ( WCHAR )'\\') + 1;

    }

    //
    // Only set the return value once we know we've
    // succeeded.
    //
    *phkResult = hkDestKey;

    return STATUS_SUCCESS;
}



error_status_t
BaseRegFlushKey(
    IN HKEY hKey
    )

/*++

Routine Description:

    Flush changes to backing store.  Flush will not return until the data
    has been written to backing store.  It will flush all the attributes
    of a single key.  Closing a key without flushing it will NOT abort
    changes.

Arguments:

    hKey - Supplies a handle to the open key.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

    If successful, RegFlushKey will flush to backing store any changes
    made to the key.

Notes:

    RegFlushKey may also flush other data in the Registry, and therefore
    can be expensive, it should not be called gratuitously.

--*/

{
    if ((hKey == HKEY_PERFORMANCE_DATA) ||
        (hKey == HKEY_PERFORMANCE_TEXT) ||
        (hKey == HKEY_PERFORMANCE_NLSTEXT)) {
        return(ERROR_SUCCESS);
    }

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );


    //
    // Call the Nt Api to flush the key, map the NTSTATUS code to a
    // Win32 Registry error code and return.
    //

    return (error_status_t)RtlNtStatusToDosError( NtFlushKey( hKey ));
}

error_status_t
BaseRegOpenKey(
    IN HKEY hKey,
    IN PUNICODE_STRING lpSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )

/*++

Routine Description:

    Open a key for access, returning a handle to the key.  If the key is
    not present, it is not created (see RegCreateKeyExW).

Arguments:

    hKey - Supplies a handle to an open key.  The lpSubKey pathname
        parameter is relative to this key handle.  Any of the predefined
        reserved handle values or a previously opened key handle may be used
        for hKey.  NULL is not permitted.

    lpSubKey - Supplies the downward key path to the key to open.
        lpSubKey is always relative to the key specified by hKey.

    dwOptions -- reserved.

    samDesired -- This access mask describes the desired security access
        for the key.

    phkResult -- Returns the handle to the newly opened key.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

    If successful, RegOpenKeyEx will return the handle to the newly opened
    key in phkResult.

--*/

{
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            Status = STATUS_OBJECT_NAME_NOT_FOUND;
    error_status_t      ret = ERROR_SUCCESS;
#ifdef LOCAL
    UNICODE_STRING      TmpStr = *lpSubKey; //used to keep original SubKey string
#endif

    UNREFERENCED_PARAMETER( dwOptions );

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );

    //
    // Need to NULL this out param for compat with NT4, even though SDK
    // does not define this out param on api failure -- bad apps were written
    // which rely on this.  Used to get NULLed by call to NtOpenKey, but since
    // we don't always call that now, we need to do this here in user mode.  Also
    // need an exception wrapper since NtOpenKey would simply return an error if
    // the pointer were invalid, whereas in user mode we access violate if we simply
    // assign -- yet another fix needed for app compatibility as some apps on NT 4
    // were actually passing in a bad pointer and ignoring the error returned
    // by the api as part of their normal operation.
    //

    __try {

        *phkResult = NULL;

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();

#if DBG
        DbgPrint( "WINREG Error: Exception %x in BaseRegOpenKey\n",
                  Status );
#endif
        ret = RtlNtStatusToDosError( Status );
    }

    //
    // This will only be true if there was an exception above --
    // return the exception code as an error
    //

    if (ERROR_SUCCESS != ret) {
        return ret;
    }

    //
    // Quick check for a "restricted" handle
    //

    if ( REGSEC_CHECK_HANDLE( hKey ) )
    {
        if ( ! REGSEC_CHECK_PATH( hKey, lpSubKey ) )
        {
            return( ERROR_ACCESS_DENIED );
        }

        hKey = REGSEC_CLEAR_HANDLE( hKey );
    }

    //
    // Impersonate the client.
    //

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Subtract the NULLs from the Length of the provided string.
    //  This was added on the client side so that the NULL was
    //  transmited by RPC.
    //
    lpSubKey->Length -= sizeof( UNICODE_NULL );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        lpSubKey,
        dwOptions & REG_OPTION_OPEN_LINK ? (OBJ_OPENLINK | OBJ_CASE_INSENSITIVE)
        : OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

#ifdef LOCAL
    if ( REG_CLASS_IS_SPECIAL_KEY(hKey) ||
        ( (gdwRegistryExtensionFlags & TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION)
          && ExtractClassKey(&hKey,lpSubKey) ) ) {
        Status = BaseRegOpenClassKey(
            hKey,
            lpSubKey,
            dwOptions,
            samDesired,
            phkResult);

    } else
#endif // LOCAL
    {
        //
        // Obja was initialized above
        //

        Status = NtOpenKey(
            phkResult,
            samDesired,
            &Obja);
    }

    RPC_REVERT_TO_SELF();

    ret = (error_status_t)RtlNtStatusToDosError( Status );

#ifdef LOCAL
    if (STATUS_ACCESS_DENIED == Status)
    {
        //If key could not be opened with SamDesired access
        //open it with MAXIMUM_ALLOWED.
        //do it only if it's terminal server and proper
        //flag is set in the registry.
        if ( gdwRegistryExtensionFlags & TERMSRV_ENABLE_ACCESS_FLAG_MODIFICATION )
        {
            {
                //MAXIMUM_ALLOWED does not include ACCESS_SYSTEM_SECURITY
                //so if user asks for this permission, we need to add it.
                //It could result in ACCESS_DENIED error but for 
                //TS App. Compat. it is not important.
                if(REG_CLASS_IS_SPECIAL_KEY(hKey))
                {
                    Status = BaseRegOpenClassKey(
                                hKey,
                                lpSubKey,
                                dwOptions,
                                (samDesired & (KEY_WOW64_RES | ACCESS_SYSTEM_SECURITY)) | MAXIMUM_ALLOWED,
                                phkResult);
                }
                else
                {
                    Status = NtOpenKey(
                            phkResult,
                            (samDesired & (KEY_WOW64_RES | ACCESS_SYSTEM_SECURITY)) | MAXIMUM_ALLOWED,
                            &Obja); 
                }


                // Give app back the original error
                if (!NT_SUCCESS(Status)) {
                    Status = STATUS_ACCESS_DENIED;
                }
                ret = (error_status_t)RtlNtStatusToDosError( Status );
            }

        }
    }


    if ((!REG_CLASS_IS_SPECIAL_KEY(hKey)) && !NT_SUCCESS(Status) && gpfnTermsrvOpenRegEntry) {

        //
        // Obja was initialized above
        //

        if (gpfnTermsrvOpenRegEntry(phkResult,
                                    samDesired,
                                    &Obja)) {
            Status = STATUS_SUCCESS;
            ret = (error_status_t)RtlNtStatusToDosError( Status );
        }
    }
#if defined(LEAK_TRACK)

    if (g_RegLeakTraceInfo.bEnableLeakTrack) {
        if (ERROR_SUCCESS == ret) {
            (void) TrackObject(*phkResult);
        }
    }

#endif (LEAK_TRACK)

    *lpSubKey = TmpStr; //Restore original SubKey string

#endif // LOCAL

    return ret;
}

//
// BaseRegGetVersion - new for Chicago to determine what version a registry
//                                              key is connected to.
//

error_status_t
BaseRegGetVersion(
    IN HKEY hKey,
    OUT LPDWORD lpdwVersion
    )
/*++

Routine Description:

    New for Win95, allows a caller to determine what version a registry
    key is connected to.

Arguments:

    hKey - Supplies a handle to an open key.

    lpdwVersion - Returns the registry version.

Return Value:

    Returns ERROR_SUCCESS (0) for success;

    If successful, BaseRegGetVersion returns the registry version in lpdwVersion

--*/
{
    if (lpdwVersion != NULL) {
        *lpdwVersion = REMOTE_REGISTRY_VERSION;
        return(ERROR_SUCCESS);
    }
    //
    // ERROR_NOACCESS is kind of a weird thing to return,
    // but we want to return something different in the
    // NULL case because that is how we tell whether we
    // are talking to a Win95 machine. Win95's implementation
    // of BaseRegGetVersion does not actually fill in the
    // version. It just returns ERROR_SUCCESS or
    // ERROR_INVALID_PARAMETER.
    //
    return(ERROR_NOACCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\reglukey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Reglukey.c

Abstract:

    This module contains the server side Win32 Registry
    APIs to load, unload and replace keys. That is:

        - BaseRegLoadKeyA
        - BaseRegLoadKeyW
        - BaseRegUnLoadKeyA
        - BaseRegUnLoadKeyW
        - BaseRegReplaceKeyA
        - BaseRegReplaceKeyW

Author:


    Ramon J. San Andres (ramonsa) 16-Apr-1992



--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"

error_status_t
BaseRegLoadKey(
    IN  HKEY            hKey,
    IN  PUNICODE_STRING lpSubKey OPTIONAL,
    IN  PUNICODE_STRING lpFile
    )

/*++

Routine Description:

    Load the tree in the supplied file into the key referenced by the
    supplied key handle and sub-key.  The loaded tree will overwrite all
    of the contents of the supplied sub-key except for its name.
    Pictorially, if the file contains:

                    A
                   / \
                  /   \
                 B     C

    and the supplied key refers to a key name X, the resultant tree would
    look like:

                    X
                   / \
                  /   \
                 B     C

Arguments:

    hKey - Supplies the predefined handle HKEY_USERS or HKEY_LOCAL_MACHINE.
        lpSubKey is relative to this handle.

    lpSubKey - Supplies a path name to a new (i.e.  non-existant) key
        where the supplied file will be loaded.

    lpFile - Supplies a pointer to an existing file name whose contents was
        created with RegSaveKey. The file name may not have an extension.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    The difference between RegRestoreKey and RegLoadKey is that in the
    latter case the supplied file is used as the actual backing store
    whereas in the former case the information in the file is copied into
    the Registry.

    RegLoadKey requires SeRestorePrivilege.

--*/

{
    OBJECT_ATTRIBUTES   ObjaKey;
    OBJECT_ATTRIBUTES   ObjaFile;
    BOOLEAN             ErrorFlag;
    UNICODE_STRING      FileName;
    RTL_RELATIVE_NAME   RelativeName;
    PVOID               FreeBuffer;
    NTSTATUS            NtStatus;
    PUNICODE_STRING     SubKey;

#if DBG
    //OutputDebugString( "WINREG: Entering BaseRegLoadKey\n" );
#endif


    ASSERT( (hKey != NULL) && (lpFile != NULL) && (lpFile->Buffer != NULL));
    if ( (hKey == NULL) || (lpFile == NULL) || (lpFile->Buffer == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // check for oddly formed UNICODE_STRINGs passed by malicious clients
    // check also for zero-length strings
    //
    if ((!lpFile->Length)    ||
        (lpFile->Length & 1) ||
        (lpFile->Buffer[(lpFile->Length-1)/sizeof(WCHAR)] != UNICODE_NULL)) {
        return ERROR_INVALID_PARAMETER;
    }

    if ((lpSubKey) &&
        ((!lpSubKey->Length)    ||
         (lpSubKey->Length & 1) ||
         (lpSubKey->Buffer[(lpSubKey->Length-1)/sizeof(WCHAR)] != UNICODE_NULL))) {
        return ERROR_INVALID_PARAMETER;
    }

    RPC_IMPERSONATE_CLIENT( NULL );


    //
    //  Remove terminating NULLs from Length counts. These were added
    //  on the client side so that RPC would transmit the whole thing.
    //
    if ( lpSubKey && lpSubKey->Length > 0 ) {
        lpSubKey->Length -= sizeof( UNICODE_NULL );
        SubKey = lpSubKey;
    } else {
        SubKey = NULL;
    }

    if ( lpFile->Length > 0 ) {
        lpFile->Length -= sizeof( UNICODE_NULL );
    }


    InitializeObjectAttributes(
                &ObjaKey,
                SubKey,
                OBJ_CASE_INSENSITIVE,
                hKey,
                NULL
                );

    //
    // Convert the DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToNtPathName_U(
                    lpFile->Buffer,
                    &FileName,
                    NULL,
                    &RelativeName
                    );

    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if ( !ErrorFlag ) {
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remember the buffer allocatted by RtlDosPathNameToNtPathName_U.
    //
    FreeBuffer = FileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( RelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        FileName = *( PUNICODE_STRING ) &RelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        RelativeName.ContainingDirectory = NULL;
    }

    //
    // Initialize the Obja structure for the file.
    //
    InitializeObjectAttributes(
            &ObjaFile,
            &FileName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );

#if DBG
    //OutputDebugString( "WINREG: Before NtLoadKey\n" );
#endif


    NtStatus = NtLoadKey(
                    &ObjaKey,
                    &ObjaFile
                    );

#if DBG
    //OutputDebugString( "WINREG: After RegLoadKey\n" );
#endif

    RPC_REVERT_TO_SELF();

    //
    // Free the buffer allocatted by RtlDosPathNameToNtPathName_U.
    //
    RtlFreeHeap( RtlProcessHeap( ), 0, FreeBuffer );

#if DBG
    //OutputDebugString( "WINREG: Leaving BaseRegLoadKey\n" );
#endif

    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}




error_status_t
BaseRegUnLoadKey(
    IN  HKEY            hKey,
    IN  PUNICODE_STRING lpSubKey OPTIONAL
    )

/*++

Routine Description:

    Unload the specified tree (hive) from the Registry.

Arguments:

    hKey - Supplies a handle to an open key. lpSubKey is relative to this
        handle.

    lpSubKey - Supplies a path name to the key that is to be unloaded.
        The combination of hKey and lpSubKey must refer to a hive in the
        Registry created with RegRestoreKey or RegLoadKey.  This parameter may
        be NULL.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

    RegUnLoadKey requires SeRestorePrivilege.

--*/

{

    OBJECT_ATTRIBUTES   ObjaKey;
    NTSTATUS            NtStatus;


    ASSERT( hKey != NULL );
    if ( hKey == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }


    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Remove terminating NULLs from Length counts. These were added
    //  on the client side so that RPC would transmit the whole thing.
    //
    if ( lpSubKey && lpSubKey->Length > 0 ) {
        lpSubKey->Length -= sizeof( UNICODE_NULL );
    }


    InitializeObjectAttributes(
                &ObjaKey,
                lpSubKey,
                OBJ_CASE_INSENSITIVE,
                hKey,
                NULL
                );

    NtStatus = NtUnloadKey( &ObjaKey );

    RPC_REVERT_TO_SELF();
    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}









error_status_t
BaseRegReplaceKey(
    HKEY             hKey,
    PUNICODE_STRING  lpSubKey,
    PUNICODE_STRING  lpNewFile,
    PUNICODE_STRING  lpOldFile
    )

/*++

Routine Description:

    Replace an existing tree (hive) in the Registry. The new tree will
    take effect the next time the system is rebooted.

Arguments:

    hKey - Supplies a handle to an open key. lpSubKey is relative to this
        handle.

    lpSubKey - Supplies a path name to the key that is to be replaced.
        The combination of hKey and lpSubKey must refer to a hive in the
        Registry.  This parameter may be NULL.

    lpNewFile - Supplies a file name for the new hive file.

    lpOldFile - Supplies a backup file name for the old (existing) hive file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    lpNewFile will remain open until after the system is rebooted.

    RegUnLoadKey requires SeRestorePrivilege.

--*/

{

    UNICODE_STRING      NewFileName;
    UNICODE_STRING      OldFileName;
    RTL_RELATIVE_NAME   RelativeName;
    PVOID               NewFreeBuffer;
    PVOID               OldFreeBuffer;
    HANDLE              HiveHandle;
    OBJECT_ATTRIBUTES   ObjaKey;
    OBJECT_ATTRIBUTES   ObjaNewFile;
    OBJECT_ATTRIBUTES   ObjaOldFile;
    BOOLEAN             ErrorFlag;
    NTSTATUS            NtStatus;


    ErrorFlag = (BOOLEAN)( (hKey   == NULL)            ||
                           (lpNewFile == NULL)         ||
                           (lpNewFile->Buffer == NULL) ||
                           (lpOldFile == NULL)         ||
                           (lpOldFile->Buffer == NULL) );

    ASSERT( !ErrorFlag );

    if ( ErrorFlag ) {
        return ERROR_INVALID_PARAMETER;
    }


    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Remove terminating NULLs from Length counts. These were added
    //  on the client side so that RPC would transmit the whole thing.
    //
    if ( lpSubKey && lpSubKey->Length > 0 ) {
        lpSubKey->Length -= sizeof( UNICODE_NULL );
    }

    if ( lpNewFile->Length > 0 ) {
        lpNewFile->Length -= sizeof( UNICODE_NULL );
    }

    if ( lpOldFile->Length > 0 ) {
        lpOldFile->Length -= sizeof( UNICODE_NULL );
    }


    InitializeObjectAttributes(
                &ObjaKey,
                lpSubKey,
                OBJ_CASE_INSENSITIVE,
                hKey,
                NULL
                );

    //
    //  Get a handle to the hive root
    //
    NtStatus = NtCreateKey(
                    &HiveHandle,
                    MAXIMUM_ALLOWED,
                    &ObjaKey,
                    0,
                    NULL,
                    REG_OPTION_BACKUP_RESTORE,
                    NULL
                    );


    if ( !NT_SUCCESS( NtStatus ) ) {
        RPC_REVERT_TO_SELF();
        return (error_status_t)RtlNtStatusToDosError( NtStatus );
    }



    //
    // Convert the new DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToNtPathName_U(
                    lpNewFile->Buffer,
                    &NewFileName,
                    NULL,
                    &RelativeName
                    );

    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if ( !ErrorFlag ) {
        NtClose( HiveHandle );
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remember the buffer allocatted by RtlDosPathNameToNtPathName_U.
    //
    NewFreeBuffer = NewFileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( RelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        NewFileName = *( PUNICODE_STRING ) &RelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        RelativeName.ContainingDirectory = NULL;
    }

    //
    // Initialize the Obja structure for the new file.
    //
    InitializeObjectAttributes(
            &ObjaNewFile,
            &NewFileName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );


    //
    // Convert the old DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToNtPathName_U(
                    lpOldFile->Buffer,
                    &OldFileName,
                    NULL,
                    &RelativeName
                    );

    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if ( !ErrorFlag ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, NewFreeBuffer );
        NtClose( HiveHandle );
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remember the buffer allocatted by RtlDosPathNameToNtPathName_U.
    //
    OldFreeBuffer = OldFileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( RelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        OldFileName = *( PUNICODE_STRING ) &RelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        RelativeName.ContainingDirectory = NULL;
    }

    //
    // Initialize the Obja structure for the new file.
    //
    InitializeObjectAttributes(
            &ObjaOldFile,
            &OldFileName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );


    NtStatus = NtReplaceKey(
                    &ObjaNewFile,
                    HiveHandle,
                    &ObjaOldFile
                    );

    //
    // Free the buffers allocatted by RtlDosPathNameToNtPathName_U.
    //
    RtlFreeHeap( RtlProcessHeap( ), 0, NewFreeBuffer );
    RtlFreeHeap( RtlProcessHeap( ), 0, OldFreeBuffer );

    NtClose( HiveHandle );

    RPC_REVERT_TO_SELF();
    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regnccls.h ===
/*++




Copyright (c) 1992  Microsoft Corporation

Module Name:

    regnccls.h

Abstract:

    This file contains declarations needed for handling 
    change notifications in the classes portion of the registry

Author:

    Adam Edwards (adamed) 19-Aug-1998

Notes:

--*/

#if defined( LOCAL )

NTSTATUS BaseRegNotifyClassKey(
    IN  HKEY                     hKey,
    IN  HANDLE                   hEvent,
    IN  PIO_STATUS_BLOCK         pLocalIoStatusBlock,
    IN  DWORD                    dwNotifyFilter,
    IN  BOOLEAN                  fWatchSubtree,
    IN  BOOLEAN                  fAsynchronous);

NTSTATUS BaseRegGetBestAncestor(
    IN SKeySemantics*     pKeySemantics,
    IN HKEY               hkUser,
    IN HKEY               hkMachine,
    IN POBJECT_ATTRIBUTES pObja);


#endif // defined( LOCAL )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regnccls.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regnccls.c

Abstract:

    This file contains functions needed for handling 
    change notifications in the classes portion of the registry

Author:

    Adam P. Edwards     (adamed)  14-Nov-1997

Key Functions:

    BaseRegNotifyClassKey

Notes:

--*/


#ifdef LOCAL

#include <rpc.h>
#include <string.h>
#include <wchar.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regnccls.h"
#include <malloc.h>

NTSTATUS BaseRegNotifyClassKey(
    IN  HKEY                     hKey,
    IN  HANDLE                   hEvent,
    IN  PIO_STATUS_BLOCK         pLocalIoStatusBlock,
    IN  DWORD                    dwNotifyFilter,
    IN  BOOLEAN                  fWatchSubtree,
    IN  BOOLEAN                  fAsynchronous)
{
    NTSTATUS           Status;
    HKEY               hkUser;
    HKEY               hkMachine;
    SKeySemantics      KeyInfo;
    UNICODE_STRING     EmptyString = {0, 0, 0};
    BYTE               rgNameBuf[REG_MAX_CLASSKEY_LEN + REG_CHAR_SIZE + sizeof(OBJECT_NAME_INFORMATION)];
    OBJECT_ATTRIBUTES  Obja;
    BOOL               fAllocatedPath;

    //
    // Set buffer to store info about this key
    //
    KeyInfo._pFullPath = (PKEY_NAME_INFORMATION) rgNameBuf;
    KeyInfo._cbFullPath = sizeof(rgNameBuf);
    KeyInfo._fAllocedNameBuf = FALSE;

    //
    // get information about this key
    //
    Status = BaseRegGetKeySemantics(hKey, &EmptyString, &KeyInfo);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Initialize conditionally freed resources
    //
    hkUser = NULL;
    hkMachine = NULL;

    fAllocatedPath = FALSE;
    Obja.ObjectName = NULL;

    //
    // Now get handles for both user and machine versions of the key
    //
    Status = BaseRegGetUserAndMachineClass(
        &KeyInfo,
        hKey,
        KEY_NOTIFY,
        &hkUser,
        &hkMachine);

    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    if (fWatchSubtree || (hkUser && hkMachine)) {

        //
        // This will return the closest ancestor to the
        // nonexistent translated key -- note that it allocates memory
        // to the Obja.ObjectName member, so we need to free that on
        // success
        //
        Status = BaseRegGetBestAncestor(
            &KeyInfo,
            hkUser,
            hkMachine,
            &Obja);

        fAllocatedPath = Obja.ObjectName != NULL;

        if (!NT_SUCCESS(Status)) {
            goto cleanup;
        }

        //
        // Ask for the notify on both user and machine keys (or
        // the closest approximation).  Note that we pass a full path --
        // if we used an relative path with an object handle instead, we
        // would never have an opportunity to close the object, so we would
        // leak objects
        // 
        //
        Status = NtNotifyChangeMultipleKeys(
            hKey,
            1,
            &Obja,
            hEvent,
            NULL,
            NULL,
            pLocalIoStatusBlock,
            dwNotifyFilter,
            fWatchSubtree,
            NULL,
            0,
            fAsynchronous
            );

    } else {

        Status = NtNotifyChangeKey(
            hkUser ? hkUser : hkMachine,
            hEvent,
            NULL,
            NULL,
            pLocalIoStatusBlock,
            dwNotifyFilter,
            fWatchSubtree,
            NULL,
            0,
            fAsynchronous
            );
    }

cleanup:

    //if (!NT_SUCCESS(Status)) {
        
        if (hkUser && (hkUser != hKey)) {
            NtClose(hkUser);
        }

        if (hkMachine && (hkMachine != hKey)) {
            NtClose(hkMachine);
        }
    //}

    if (fAllocatedPath) {
        RegClassHeapFree(Obja.ObjectName);
    }

    return Status;
}

NTSTATUS BaseRegGetBestAncestor(
    IN SKeySemantics*      pKeySemantics,
    IN HKEY                hkUser,
    IN HKEY                hkMachine,
    IN POBJECT_ATTRIBUTES  pObja)
/*++

Routine Description:

    Finds a full object path for the closest ancestor for a key
    described by a key semantics structure


Arguments:
    
    pKeySemantics - contains information about a registry key
    hkUser        - handle to a user class version of the key above
    hkMachine     - handle to a machine class version of the key above
    pObja         - Object Attributes structure to initialize with a full
                    object path for the closest ancestor -- not that memory
                    is allocated for the ObjectName member of the structure
                    which must be freed by the caller -- caller should
                    check this member to see if it's non-NULL, regardless
                    of success code returned by function

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/
{
    USHORT             PrefixLen;
    NTSTATUS           Status;
    PUNICODE_STRING    pKeyPath;
    USHORT             uMaxLen;

    //
    // Allocate memory for the Obja's ObjectName member
    //
    uMaxLen = (USHORT) pKeySemantics->_pFullPath->NameLength +  REG_CLASSES_SUBTREE_PADDING;

    pKeyPath = RegClassHeapAlloc(uMaxLen + sizeof(*pKeyPath));

    if (!(pKeyPath)) {
        return STATUS_NO_MEMORY;
    }

    //
    // Now initialize the structure
    //
    pKeyPath->MaximumLength = uMaxLen;
    pKeyPath->Buffer = (WCHAR*) (((PBYTE) pKeyPath) + sizeof(*pKeyPath));

    //
    // Now form a version of this key path in the opposite tree
    //
    if (pKeySemantics->_fUser) {
            
        Status = BaseRegTranslateToMachineClassKey(
            pKeySemantics,
            pKeyPath,
            &PrefixLen);

    } else {

        Status = BaseRegTranslateToUserClassKey(
            pKeySemantics,
            pKeyPath,
            &PrefixLen);
    }
    
    //
    // Make sure the caller has a reference to allocated memory
    //
    pObja->ObjectName = pKeyPath;

    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    //
    // Set up the object attributes with this translated key so 
    // we can use the structure to notify keys
    //
    InitializeObjectAttributes(
        pObja,
        pKeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL, // using absolute path, no hkey
        NULL);

    //
    // If we were supplied both keys, then they both exist,
    // so we can simply use the translated path above
    //
    if (hkUser && hkMachine) {
        goto cleanup;
    }

    //
    // At this point, we know the translated path doesn't exist,
    // since we only have a handle for one of the paths.  Therefore
    // we will attempt to find an approximation.  Note that the 
    // manipulation of KeyPath below affects the Obja passed in since
    // the Obja struct references KeyPath
    //
    do
    {
        WCHAR* pBufferEnd;
        HKEY   hkExistingKey;

        //
        // Find the last pathsep in the current key path
        //
        pBufferEnd = wcsrchr(pKeyPath->Buffer, L'\\');

        //
        // We should never get NULL here, because all keys
        // have the ancestory \Registry\User or \Registry\Machine,
        // each which have two pathseps to spare -- the loop
        // terminates once that path is shorter than those prefixes,
        // so we should never encounter this situation
        //
        ASSERT(pBufferEnd);

        //
        // Now truncate the string
        //
        *pBufferEnd = L'\0';

        //
        // Adjust the unicode string structure to conform
        // to the truncated string
        //
        RtlInitUnicodeString(pKeyPath, pKeyPath->Buffer);

        //
        // Now attempt to open with this truncated path
        //
        Status = NtOpenKey(
            &hkExistingKey,
            KEY_NOTIFY,
            pObja);

        //
        // If we do open it, we will close it and not pass this object
        // since we want our obja to use a full path and not a relative
        // path off a kernel object
        //
        if (NT_SUCCESS(Status)) {
            NtClose(hkExistingKey);
            break;
        }

        //
        // If we get any error besides a key not found error, then our reason
        // for failing the open is not because the key did not exist, but because
        // of some other error, most likely access denied.
        //
        if (STATUS_OBJECT_NAME_NOT_FOUND != Status) {
            break;
        }

    } while (pKeyPath->Length > PrefixLen);

cleanup:

    return Status;
    
}


#endif // defined ( LOCAL )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regqkey.c ===
/*++




Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regqkey.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry query key API. That is:

        - BaseRegQueryInfoKey

Author:

    David J. Gilman (davegi) 27-Nov-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regecls.h"
#include "regvcls.h"
#include <malloc.h>

#define DEFAULT_CLASS_SIZE          128

//
// Internal prototypes
//

NTSTATUS QueryKeyInfo(
    HKEY                    hKey,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   *ppKeyInfo,
    ULONG                   BufferLength,
    BOOL                    fClass,
    USHORT                  MaxClassLength);

void CombineKeyInfo(
    PVOID                   KeyInfo,
    PVOID                   MachineClassKeyInfo,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    DWORD                   dwTotalSubKeys,
    DWORD                   dwTotalValues);



error_status_t
BaseRegQueryInfoKey(
    IN HKEY hKey,
    OUT PUNICODE_STRING lpClass,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcbMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    RegQueryInfoKey returns pertinent information about the key
    corresponding to a given key handle.

Arguments:

    hKey - A handle to an open key.

    lpClass - Returns the Class string for the key.

    lpcSubKeys - Returns the number of subkeys for this key .

    lpcbMaxSubKeyLen - Returns the length of the longest subkey name.

    lpcbMaxClassLen  - Returns length of longest subkey class string.

    lpcValues - Returns the number of ValueNames for this key.

    lpcbMaxValueNameLen - Returns the length of the longest ValueName.

    lpcbMaxValueLen - Returns the length of the longest value entry's data
        field.

    lpcbSecurityDescriptor - Returns the length of this key's
        SECURITY_DESCRIPTOR.

    lpftLastWriteTime - Returns the last time that the key or any of its
        value entries was modified.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.


--*/

{
    NTSTATUS                Status;
    ULONG                   BufferLength;
    PVOID                   KeyInfo;
    PVOID                   ClassKeyInfo;
    KEY_INFORMATION_CLASS   KeyInformationClass;
    SECURITY_DESCRIPTOR     SecurityDescriptor;
    ULONG                   SecurityDescriptorLength;
    LONG                    Error;
    PDWORD                  pCbMaxClassLen = NULL;
    PDWORD                  pCbSecurityDescriptor = NULL;

    BYTE    PrivateKeyFullInfo[ sizeof( KEY_FULL_INFORMATION ) +
                                        DEFAULT_CLASS_SIZE ];

    BYTE    PrivateClassKeyInfo[ sizeof( KEY_FULL_INFORMATION ) +
                               DEFAULT_CLASS_SIZE ];

    ASSERT( lpClass                 != NULL );
    ASSERT( lpcSubKeys              != NULL );
    ASSERT( lpcbMaxSubKeyLen        != NULL );
    ASSERT( lpcValues               != NULL );
    ASSERT( lpcbMaxValueNameLen     != NULL );
    ASSERT( lpcbMaxValueLen         != NULL );
    ASSERT( lpftLastWriteTime       != NULL );

    ASSERT( sizeof(KEY_FULL_INFORMATION) >= sizeof(KEY_CACHED_INFORMATION) );

    if( lpcbMaxClassLen != NULL ) {
        pCbMaxClassLen = lpcbMaxClassLen;
    }

    if( lpcbSecurityDescriptor != NULL ) {
        pCbSecurityDescriptor = lpcbSecurityDescriptor;
    }

    //
    // Call out to Perflib if the HKEY is HKEY_PERFORMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT )) {

        DWORD                   cbMaxClassLen;
        DWORD                   cbSecurityDescriptor;
        //
        // Impersonate the client.
        //

        RPC_IMPERSONATE_CLIENT( NULL );

        // 
        // don't mess with Perf stuff
        //
        if( pCbMaxClassLen == NULL ) {
            pCbMaxClassLen = &cbMaxClassLen;
        }
        if( pCbSecurityDescriptor == NULL ) {
            pCbSecurityDescriptor = &cbSecurityDescriptor;
        }

        Error = PerfRegQueryInfoKey (
                                    hKey,
                                    lpClass,
                                    NULL,
                                    lpcSubKeys,
                                    lpcbMaxSubKeyLen,
                                    pCbMaxClassLen,
                                    lpcValues,
                                    lpcbMaxValueNameLen,
                                    lpcbMaxValueLen,
                                    pCbSecurityDescriptor,
                                    lpftLastWriteTime
                                    );
        RPC_REVERT_TO_SELF();

        return (error_status_t)Error;

    }

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );


    //
    //  First we assume that the information we want will fit on
    //  PrivateKeyFullInformattion
    //

    if( (lpClass->Buffer == NULL) && (pCbMaxClassLen == NULL) ) {
        KeyInformationClass = KeyCachedInformation;
    } else {
        KeyInformationClass = KeyFullInformation;
    }

    ClassKeyInfo = (PVOID)PrivateClassKeyInfo;
    KeyInfo = (PVOID)PrivateKeyFullInfo;
    BufferLength = sizeof( PrivateKeyFullInfo );


    //
    // Ask Nt for all the meta information about this key.
    //

    Status = QueryKeyInfo(
                hKey,
                KeyInformationClass,
                &KeyInfo,
                BufferLength,
                lpClass->Buffer ? TRUE : FALSE,
                lpClass->MaximumLength
                );


    if( (NT_SUCCESS( Status ) ||
        ( Status == STATUS_BUFFER_OVERFLOW ) ) &&
        (KeyInformationClass == KeyFullInformation)
      ) {

        lpClass->Length = ( USHORT )
                          ( (( PKEY_FULL_INFORMATION )KeyInfo)->ClassLength
                            + sizeof( UNICODE_NULL )
                          );
    }


    if ( NT_SUCCESS( Status )) {

#ifdef LOCAL

        //
        // For special keys in HKCR, we can't just take the information
        // from the kernel -- these keys have properties that come from
        // both the user and machine versions of their keys. To find out
        // if it's a special key, we get more information below
        //
        if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

            {
                HKEY    hkMachineClass;
                HKEY    hkUserClass;

                BufferLength = sizeof( PrivateClassKeyInfo );

                //
                // we will now need information from both the user
                // and machine locations to find the number of
                // subkeys under this special key -- the machine
                // key is not open yet, so we open it below
                //

                //
                // Open the other key
                //
                Status = BaseRegGetUserAndMachineClass(
                    NULL,
                    hKey,
                    MAXIMUM_ALLOWED,
                    &hkMachineClass,
                    &hkUserClass);

                if (NT_SUCCESS(Status) && (hkUserClass && hkMachineClass)) {

                    DWORD dwTotalSubKeys;
                    HKEY  hkQuery;

                    if (hkUserClass == hKey) {
                        hkQuery = hkMachineClass;
                    } else {
                        hkQuery = hkUserClass;
                    }

                    //
                    // Still need to do this query to find out
                    // the largest subkey in the machine part
                    // as well as other information about the
                    // key such as its largest subkey
                    //
                    Status = QueryKeyInfo(
                        hkQuery,
                        KeyInformationClass,
                        &ClassKeyInfo,
                        BufferLength,
                        FALSE,
                        lpClass->MaximumLength);

                    //
                    // Now we will count the keys
                    //
                    if (NT_SUCCESS(Status)) {

                        Status = ClassKeyCountSubKeys(
                            hKey,
                            hkUserClass,
                            hkMachineClass,
                            0,
                            &dwTotalSubKeys);
                    }

                    NtClose(hkQuery);

                    //
                    // Do not let inability to query information for
                    // machine key cause a complete failure -- we'll
                    // just use the user key's information
                    //
                    if (!NT_SUCCESS(Status)) {

                        //
                        // this key may not exist in the machine hive
                        //
                        if (STATUS_OBJECT_NAME_NOT_FOUND == Status) {
                            Status = STATUS_SUCCESS;
                        }

                        if (STATUS_BUFFER_OVERFLOW  == Status) {
                            Status = STATUS_SUCCESS;
                        }
                    } else {

                        ValueState* pValState;

                        //
                        // Find out how many values we have
                        //
                        Status = KeyStateGetValueState(
                            hKey,
                            &pValState);

                        if (NT_SUCCESS(Status)) {

                            //
                            // Combine the information from the two
                            // trees
                            //
                            CombineKeyInfo(
                                KeyInfo,
                                ClassKeyInfo,
                                KeyInformationClass,
                                dwTotalSubKeys,
                                pValState ? pValState->cValues : 0);
                            
                            ValStateRelease(pValState);
                        }
                    }
                }
            }
        }
#endif // LOCAL
    }

    if( NT_SUCCESS( Status )) {

        //
        // don't bother if the caller is not interested in this
        //
        if( pCbSecurityDescriptor != NULL ) {
            ASSERT( lpcbSecurityDescriptor != NULL );
            //
            // Get the size of the key's SECURITY_DESCRIPTOR for OWNER, GROUP
            // and DACL. These three are always accessible (or inaccesible)
            // as a set.
            //

            Status = NtQuerySecurityObject(
                        hKey,
                        OWNER_SECURITY_INFORMATION
                        | GROUP_SECURITY_INFORMATION
                        | DACL_SECURITY_INFORMATION,
                        &SecurityDescriptor,
                        0,
                        lpcbSecurityDescriptor
                        );

            //
            // If getting the size of the SECURITY_DESCRIPTOR failed (probably
            // due to the lack of READ_CONTROL access) return zero.
            //

            if( Status != STATUS_BUFFER_TOO_SMALL ) {

                *lpcbSecurityDescriptor = 0;

            } else {

                //
                // Try again to get the size of the key's SECURITY_DESCRIPTOR,
                // this time asking for SACL as well. This should normally
                // fail but may succeed if the caller has SACL access.
                //

                Status = NtQuerySecurityObject(
                            hKey,
                            OWNER_SECURITY_INFORMATION
                            | GROUP_SECURITY_INFORMATION
                            | DACL_SECURITY_INFORMATION
                            | SACL_SECURITY_INFORMATION,
                            &SecurityDescriptor,
                            0,
                            &SecurityDescriptorLength
                            );


                if( Status == STATUS_BUFFER_TOO_SMALL ) {

                    //
                    // The caller had SACL access so update the returned
                    // length.
                    //

                    *lpcbSecurityDescriptor = SecurityDescriptorLength;
                }
            }
        }


        if( KeyInformationClass == KeyCachedInformation ) {
            ASSERT( pCbMaxClassLen == NULL );
            *lpcSubKeys             = ((PKEY_CACHED_INFORMATION)KeyInfo)->SubKeys;
            *lpcbMaxSubKeyLen       = ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxNameLen;
            *lpcValues              = ((PKEY_CACHED_INFORMATION)KeyInfo)->Values;
            *lpcbMaxValueNameLen    = ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueNameLen;
            *lpcbMaxValueLen        = ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueDataLen;
            *lpftLastWriteTime      = *( PFILETIME ) &((PKEY_CACHED_INFORMATION)KeyInfo)->LastWriteTime;
            Error = ERROR_SUCCESS;
        } else {
            *lpcSubKeys             = ((PKEY_FULL_INFORMATION)KeyInfo)->SubKeys;
            if( pCbMaxClassLen != NULL ) {
                *lpcbMaxClassLen        = ((PKEY_FULL_INFORMATION)KeyInfo)->MaxClassLen;
                ASSERT( pCbMaxClassLen == lpcbMaxClassLen );
            }
            *lpcbMaxSubKeyLen       = ((PKEY_FULL_INFORMATION)KeyInfo)->MaxNameLen;
            *lpcValues              = ((PKEY_FULL_INFORMATION)KeyInfo)->Values;
            *lpcbMaxValueNameLen    = ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueNameLen;
            *lpcbMaxValueLen        = ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueDataLen;
            *lpftLastWriteTime      = *( PFILETIME ) &((PKEY_FULL_INFORMATION)KeyInfo)->LastWriteTime;



            //
            // Copy/assign remaining output parameters.
            //
            if ( lpClass->Length > lpClass->MaximumLength ) {

                if( lpClass->Buffer != NULL ) {
                    lpClass->Buffer = NULL;
                    Error = (error_status_t)RtlNtStatusToDosError( STATUS_BUFFER_TOO_SMALL );
                } else {
                    //
                    // Caller is not iterest in Class, so return its size only.
                    //
                    Error = ERROR_SUCCESS;
                }

            } else {

                if( ((PKEY_FULL_INFORMATION)KeyInfo)->ClassLength != 0 ) {

                    ASSERT( lpClass->Buffer != NULL );
                    RtlMoveMemory(
                        lpClass->Buffer,
                        ((PKEY_FULL_INFORMATION)KeyInfo)->Class,
                        ((PKEY_FULL_INFORMATION)KeyInfo)->ClassLength
                        );
                }

                //
                // NUL terminate the class name.
                //

                lpClass->Buffer[ ((PKEY_FULL_INFORMATION)KeyInfo)->ClassLength >> 1 ] = UNICODE_NULL;

                Error = ERROR_SUCCESS;
            }
        }

    } else if( Status == STATUS_BUFFER_OVERFLOW ) {

        //
        // A return value of STATUS_BUFFER_OVERFLOW means that the user did
        // not supply enough space for the class. The required space has
        // already been assigned above.
        //
        lpClass->Buffer = NULL;
        Error = ERROR_INVALID_PARAMETER;

    } else {

        //
        // Some other error occurred.
        //

        Error = RtlNtStatusToDosError( Status );
    }

    if( KeyInfo != ( PVOID )PrivateKeyFullInfo ) {

        //
        // Free the buffer and return the Registry return value.
        //

        RtlFreeHeap( RtlProcessHeap( ), 0, KeyInfo );
    }

    if( ClassKeyInfo != ( PVOID )PrivateClassKeyInfo ) {

        //
        // Free the buffer and return the Registry return value.
        //

        RtlFreeHeap( RtlProcessHeap( ), 0, ClassKeyInfo );
    }

    return (error_status_t)Error;
}

NTSTATUS QueryKeyInfo(
    HKEY                    hKey,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    PVOID                   *ppKeyInfo,
    ULONG                   BufferLength,
    BOOL                    fClass,
    USHORT                  MaxClassLength)
/*++

Routine Description:

    Queries the kernel for key information.

Arguments:

    hKey - handle of key for which to query info

    KeyInformationClass - type of info required from the kernel

    KeyInfo - pointer to address of
           buffer for information about key

    BufferLength - size of KeyFullInfo buffer

    fClass - flag set to TRUE if the class for this
        key should be rerieved

    MaxClassLength - maximum size for class data that a caller
        is willing to support. The ppKeyFullInfo buffer may
        point to the address of a buffer that can handle the
        class size of the key, but the caller may want the class
        to fit in some smaller buffer later, so this param lets
        the caller limit that size.  It is ignored if fClass
        is FALSE.

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    NTSTATUS Status;
    ULONG Result;

    ASSERT( KeyInformationClass == KeyFullInformation ||
            KeyInformationClass == KeyCachedInformation );

    Status = NtQueryKey(
                hKey,
                KeyInformationClass,
                *ppKeyInfo,
                BufferLength,
                &Result);

    //
    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
    // was not enough room for even the fixed portion of the structure.
    //

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

    if ( Status == STATUS_BUFFER_OVERFLOW ) {

        // we cannot hit this on a CachedInfo fixed structure

        ASSERT( KeyInformationClass == KeyFullInformation );
        //
        //  The buffer defined in the stack wasn't big enough to hold
        //  the Key Information.
        //
        //  If the fClass flag is not set, then the caller does not do the
        //  check for the caller specified maximum class length below
        //  and requeries happily.  If the flag is set, we do the check, and
        //  if the class size is bigger than what the caller specified as
        //  the max, we return STATUS_BUFFER_OVERFLOW.
        //

        if ( !fClass || ((ULONG)(MaxClassLength) >=
              (( PKEY_FULL_INFORMATION )*ppKeyInfo )->ClassLength + sizeof( UNICODE_NULL )) ) {

                //
                // Required length is stored in Result -- set our length
                // to the required length and allocate memory for it.
                //

                BufferLength = Result;

                *ppKeyInfo = RtlAllocateHeap( RtlProcessHeap( ), 0,
                                                  BufferLength );
                //
                // If the memory allocation fails, return a Registry error.
                //

                if( ! *ppKeyInfo ) {
                    return STATUS_NO_MEMORY;
                }

                //
                // Query for the necessary information about the supplied key.
                //

                Status = NtQueryKey( hKey,
                                     KeyFullInformation,
                                     *ppKeyInfo,
                                     BufferLength,
                                     &Result
                                   );
        }
    }

    return Status;
}

void CombineKeyInfo(
    PVOID                   KeyInfo,
    PVOID                   MachineClassKeyInfo,
    KEY_INFORMATION_CLASS   KeyInformationClass,
    DWORD                   dwTotalSubKeys,
    DWORD                   dwTotalValues)
/*++

Routine Description:

    Combine the information from the user and machine hives
    for a special key

Arguments:

    Status -

    KeyInfo - buffer for  information about user key

    MachineClassKeyInfo - buffer for information about machine key

    KeyClassInformation - type of information present in buffers

    dwTotalSubKeys - total number of subkeys for the two
        in each hive

Return Value:

    Returns NT_SUCCESS (0) for success; error-code for failure.

Notes:

--*/
{
    ASSERT( KeyInformationClass == KeyCachedInformation ||
            KeyInformationClass == KeyFullInformation );

    if( KeyInformationClass == KeyCachedInformation ) {
        //
        // Set the number of keys to be the total between the
        // two versions in each hive
        //
        ((PKEY_CACHED_INFORMATION)KeyInfo)->SubKeys = dwTotalSubKeys;
        ((PKEY_CACHED_INFORMATION)KeyInfo)->Values = dwTotalValues;

        //
        // Set our max namelen to the namelen of whichever is biggest
        // between the two hives. Same for class.
        //

        if (((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxNameLen > ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxNameLen) {
            ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxNameLen = ((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxNameLen;
        }
   
        //
        // Since we also merge values, we must set the value information as well
        //
        if (((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxValueNameLen > ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueNameLen) {
            ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueNameLen = ((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxValueNameLen;
        }

        if (((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxValueDataLen > ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueDataLen) {
            ((PKEY_CACHED_INFORMATION)KeyInfo)->MaxValueDataLen = ((PKEY_CACHED_INFORMATION)MachineClassKeyInfo)->MaxValueDataLen;
        }
    } else {
        //
        // Set the number of keys to be the total between the
        // two versions in each hive
        //
        ((PKEY_FULL_INFORMATION)KeyInfo)->SubKeys = dwTotalSubKeys;
        ((PKEY_FULL_INFORMATION)KeyInfo)->Values = dwTotalValues;

        //
        // Set our max namelen to the namelen of whichever is biggest
        // between the two hives. Same for class.
        //

        if (((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxNameLen > ((PKEY_FULL_INFORMATION)KeyInfo)->MaxNameLen) {
            ((PKEY_FULL_INFORMATION)KeyInfo)->MaxNameLen = ((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxNameLen;
        }

        if (((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxClassLen > ((PKEY_FULL_INFORMATION)KeyInfo)->MaxClassLen) {
            ((PKEY_FULL_INFORMATION)KeyInfo)->MaxClassLen = ((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxClassLen;
        }
    
        //
        // Since we also merge values, we must set the value information as well
        //
        if (((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxValueNameLen > ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueNameLen) {
            ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueNameLen = ((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxValueNameLen;
        }

        if (((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxValueDataLen > ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueDataLen) {
            ((PKEY_FULL_INFORMATION)KeyInfo)->MaxValueDataLen = ((PKEY_FULL_INFORMATION)MachineClassKeyInfo)->MaxValueDataLen;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regsckey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regsckey.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry APIs to set and get the SECURITY_DESCRIPTOR for a key.  That
    is:

        - BaseRegGetKeySecurity
        - BaseRegSetKeySecurity

Author:

    David J. Gilman (davegi) 10-Feb-1992

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#ifdef LOCAL
#include "tsappcmp.h"
#endif


error_status_t
BaseRegGetKeySecurity(
    HKEY hKey,
    SECURITY_INFORMATION RequestedInformation,
    PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor
    )

/*++

Routine Description:

    This API returns a copy of the security descriptor protecting a
    previously opened key.  Based on the caller's access rights and
    privileges, this API returns a security descriptor containing the
    requested security descriptor fields.  To read the supplied key's
    security descriptor the caller must be granted READ_CONTROL access or
    be the owner of the object.  In addition, the caller must have
    SeSecurityPrivilege privilege to read the system ACL.


Arguments:

    hKey - Supplies a handle to a previously opened key.

    SecurityInformation - Supplies the information needed to determine
        the type of security returned in the SECURITY_DESCRIPTOR.

    pSecurityDescriptor - Supplies a pointer to a buffer where the
        requested SECURITY_DESCRIPTOR will be written.

    lpcbSecurityDescriptor - Supplies a pointer to a DWORD which on input
        contains the size, in bytes, of the supplied SECURITY_DESCRIPTOR
        buffer. On output it contains the actual number of bytes required
        by the SECURITY_DESCRIPTOR.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    If the buffer size passed in is too small, the correct value will be
    returned through lpcbSecurityDescriptor and the API will return,
    ERROR_INVALID_PARAMETER.

--*/

{
    NTSTATUS                Status;
    PSECURITY_DESCRIPTOR    lpSD;
    DWORD                   cbLen;
    DWORD                   Error = ERROR_SUCCESS;
    HKEY                    hPerflibKey = 0;
    OBJECT_ATTRIBUTES       Obja;

    if (hKey == HKEY_PERFORMANCE_DATA ||
        hKey == HKEY_PERFORMANCE_TEXT ||
        hKey == HKEY_PERFORMANCE_NLSTEXT ) {
        //
        // For these special cases, get the hKey for Perflib
        // and return the Perflib's Security Info
        //
        UNICODE_STRING  PerflibSubKeyString;
        BOOL            bNeedSACL;

        bNeedSACL = RequestedInformation & SACL_SECURITY_INFORMATION;

        RtlInitUnicodeString (
            &PerflibSubKeyString,
            L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");


        //
        // Initialize the OBJECT_ATTRIBUTES structure and open the key.
        //
        InitializeObjectAttributes(
            &Obja,
            &PerflibSubKeyString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );


        Status = NtOpenKey(
                &hPerflibKey,
                bNeedSACL ?
                    MAXIMUM_ALLOWED | ACCESS_SYSTEM_SECURITY :
                    MAXIMUM_ALLOWED,
                &Obja
                );

        if ( ! NT_SUCCESS( Status )) {

            Error = RtlNtStatusToDosError( Status );
            pRpcSecurityDescriptor->cbInSecurityDescriptor  = 0;
            pRpcSecurityDescriptor->cbOutSecurityDescriptor = 0;
            return (error_status_t)Error;
        }

        hKey = hPerflibKey;

    } else {
        ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );
    }

    //
    //  Allocate space for the security descriptor
    //
    lpSD = (PSECURITY_DESCRIPTOR)
                RtlAllocateHeap(
                        RtlProcessHeap(), 0,
                        pRpcSecurityDescriptor->cbInSecurityDescriptor
                        );

    if ( !lpSD ) {

        Error = ERROR_OUTOFMEMORY;

    } else {

        Status = NtQuerySecurityObject(
                     hKey,
                     RequestedInformation,
                     lpSD,
                     pRpcSecurityDescriptor->cbInSecurityDescriptor,
                     &cbLen
                     );

        //
        // If the call fails, set the size of the buffer to zero so RPC
        // won't copy any data.
        //
        if( ! NT_SUCCESS( Status )) {

            Error = RtlNtStatusToDosError( Status );

        } else {

            //
            //  Convert the security descriptor to a Self-relative form
            //
            Error = MapSDToRpcSD (
                        lpSD,
                        pRpcSecurityDescriptor
                        );
        }

        if ( Error != ERROR_SUCCESS ) {
            pRpcSecurityDescriptor->cbInSecurityDescriptor  = cbLen;
            pRpcSecurityDescriptor->cbOutSecurityDescriptor = 0;
        }

        //
        //  Free the buffer that we allocated for the security descriptor
        //
        RtlFreeHeap(
                RtlProcessHeap(), 0,
                lpSD
                );
    }

    if (hPerflibKey) {
        // Close the Perflib that was created in the special cases
        NtClose(hPerflibKey);
    }

    return (error_status_t)Error;
}

error_status_t
BaseRegSetKeySecurity(
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PRPC_SECURITY_DESCRIPTOR pRpcSecurityDescriptor
    )

/*++

Routine Description:

    This API can be used to set the security of a previously opened key.
    This call is only successful if the following conditions are met:

    o If the key's owner or group is to be set, the caller must
      have WRITE_OWNER permission or have SeTakeOwnershipPrivilege.

    o If the key's DACL is to be set, the caller must have
      WRITE_DAC permission or be the object's owner.

    o If the key's SACL is to be set, the caller must have
      SeSecurityPrivilege.

Arguments:

    hKey - Supplies a handle to a previously opened key.

    SecurityInformation - Supplies a pointer to a SECURITY_INFORMATION
        structure that specifies the contents of the supplied
        SECURITY_DESCRIPTOR.

    pSecurityDescriptor - Supplies a pointer to the SECURITY_DESCRIPTOR
        to set on the supplied key.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    NTSTATUS    Status;

    if (hKey == HKEY_PERFORMANCE_DATA ||
        hKey == HKEY_PERFORMANCE_TEXT ||
        hKey == HKEY_PERFORMANCE_NLSTEXT ) {
        //
        // these keys get their security descriptor from
        // other "real" registry keys.
        //
        Status = STATUS_INVALID_HANDLE;
    } else {
        ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );

        RPC_IMPERSONATE_CLIENT( NULL );

        //
        // Validate the security descriptor.
        //
        if( RtlValidRelativeSecurityDescriptor((PSECURITY_DESCRIPTOR)(pRpcSecurityDescriptor->lpSecurityDescriptor),
                                                pRpcSecurityDescriptor->cbInSecurityDescriptor,
                                                SecurityInformation )) {
            Status = NtSetSecurityObject(
                        hKey,
                        SecurityInformation,
                        pRpcSecurityDescriptor->lpSecurityDescriptor
                        );
        } else {
            //
            //  We were passed a bogus security descriptor to set.  Bail out
            //

            Status = STATUS_INVALID_PARAMETER;
        }

        RPC_REVERT_TO_SELF();
    }

#ifdef LOCAL
    if (NT_SUCCESS(Status) && gpfnTermsrvSetKeySecurity) {
        gpfnTermsrvSetKeySecurity(hKey,
                                  SecurityInformation,
                                  pRpcSecurityDescriptor->lpSecurityDescriptor);
    }
#endif

    return (error_status_t)RtlNtStatusToDosError( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regqval.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regqval.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry query value API. That is:

        - BaseRegQueryValue
        - BaseRegQueryMultipleValues

Author:

    David J. Gilman (davegi) 27-Nov-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regvcls.h"


#define DEFAULT_VALUE_SIZE          128
#define DEFAULT_VALUE_NAME_SIZE     64


error_status_t
BaseRegQueryValue(
    IN HKEY hKey,
    IN PUNICODE_STRING lpValueName,
    OUT LPDWORD lpType OPTIONAL,
    OUT LPBYTE lpData OPTIONAL,
    OUT LPDWORD lpcbData  OPTIONAL,
    IN OUT LPDWORD lpcbLen  OPTIONAL
    )

/*++

Routine Description:

    For an open key, given the ID of the value to query, return
    the type, and value.

Arguments:

    hKey - Supplies a handle to the open key.  The value entries returned
        are contained in the key pointed to by this key handle.  Any of the
        predefined reserved handles or a previously opened key handle may be
        used for hKey.

    lpValueName - Supplies a pointer to the name of the value.

    lpType - If present, supplies a pointer to variable to receive the
        type code of value entry.

    lpData -If present, supplies a pointer to a buffer to receive the
        data of the value entry.

    lpcbData - Supplies a pointer to a variable which on input contains
        the size of the buffer lpData points to.  On output, the variable will
        receive the number of bytes returned in lpData.  It must be supplied
        if lpData is, it is ignored otherwise.

    lpcbLen - Return the number of bytes to transmit to the client (used
        by RPC).

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.


--*/

{
    NTSTATUS                        Status;
    ULONG                           BufferLength;
    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;
    PVOID                           KeyValueInformation;
    ULONG                           ResultLength;
    HKEY                            hkQueryKey;

    BYTE    PrivateKeyValueInformation[ sizeof( KEY_VALUE_PARTIAL_INFORMATION ) +
                                        DEFAULT_VALUE_SIZE ];
#ifdef LOCAL
    HKEY                            hkUserClasses;
    HKEY                            hkMachineClasses;

    hkUserClasses = NULL;
    hkMachineClasses = NULL;
#endif LOCAL
    hkQueryKey = hKey;

    //
    //  If the client gave us a bogus size, patch it.
    //
    if ( ARGUMENT_PRESENT( lpcbData ) && !ARGUMENT_PRESENT( lpData ) ) {
        *lpcbData = 0;
    }


    //
    // Call out to Perflib if the HKEY is HKEY_PERFOMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT)) {
        error_status_t Error;

        //
        // Impersonate the client.
        //

        RPC_IMPERSONATE_CLIENT( NULL );

        Error = (error_status_t)PerfRegQueryValue (
                            hKey,
                            lpValueName,
                            NULL,
                            lpType,
                            lpData,
                            lpcbData,
                            lpcbLen
                            );
        RPC_REVERT_TO_SELF();
        return(Error);
    }

    ASSERT( IsPredefinedRegistryHandle( hKey ) == FALSE );

    //
    //  Subtract the NULL from the Length. This was added on
    //  the client side so that RPC would transmit it.
    //
    if ( lpValueName->Length > 0 ) {
        lpValueName->Length -= sizeof( UNICODE_NULL );
    }

    //
    //  First we assume that the information we want will fit on
    //  PrivateKeyValueInformattion
    //

    KeyValueInformationClass = ( ARGUMENT_PRESENT( lpcbData ))?
                               KeyValuePartialInformation :
                               KeyValueBasicInformation;


    KeyValueInformation = PrivateKeyValueInformation;
    BufferLength = sizeof( PrivateKeyValueInformation );

    //
    // Query for the necessary information about the supplied value. This
    // may or may not include the data depending on lpcbData as determined
    // above.
    //
#ifdef LOCAL
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

        Status = BaseRegGetUserAndMachineClass(
            NULL,
            hKey,
            MAXIMUM_ALLOWED,
            &hkMachineClasses,
            &hkUserClasses);

        if (!NT_SUCCESS(Status)) {
            return (error_status_t) RtlNtStatusToDosError(Status);
        }
    }

    if (hkUserClasses && hkMachineClasses) {
        hkQueryKey = hkUserClasses;
    }

    for (;;) {
#endif

        Status = NtQueryValueKey( hkQueryKey,
                                  lpValueName,
                                  KeyValueInformationClass,
                                  KeyValueInformation,
                                  BufferLength,
                                  &ResultLength
            );
#ifdef LOCAL
        //
        // If we don't have two classes keys to worry about,
        // just continue as we normally would
        //
        if (!hkUserClasses || !hkMachineClasses) {
            break;
        }
        
        //
        // If we're using machine, then we don't want to repeat
        // since machine is the last resort
        //
        if (hkQueryKey == hkMachineClasses) {
            break;
        }

        //
        // If the key doesn't exist in user, then let's try
        // again in machine
        //
        if (STATUS_OBJECT_NAME_NOT_FOUND == Status) {
            hkQueryKey = hkMachineClasses;
            continue;
        }

        break;
    }
#endif

    //
    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
    // was not enough room for even the known (i.e. fixed length portion)
    // of the structure.
    //

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

    if( ( Status == STATUS_BUFFER_OVERFLOW ) &&
        ( !ARGUMENT_PRESENT( lpData ) ) ) {
        //
        //  STATUS_BUFFER_OVERFLOW means that the API returned all the
        //  information in the fixed portion of the structure
        //  KEY_VALUE_BASIC_INFORMATION or KEY_VALUE_PARTIAL_INFORMATION,
        //  but not the value name or the value data.
        //
        //  If KeyValueInformationClass is equal to KeyValueBasicInformation
        //  then the API would return the value name. But since we are not
        //  interested in the value name (it was supplied by the client), we
        //  can assume that the API succeeded.
        //
        //  If KeyValueInformationClass is equal to KeyValuePartialInformation
        //  then the API would return the value data. But lpData == NULL
        //  means that the client is not interested on the value data, but
        //  just on its size. For this reason, we can also assume that the
        //  API succeeded.
        //

        Status = STATUS_SUCCESS;
    }

    if( Status == STATUS_BUFFER_OVERFLOW ) {
        //
        //  The buffer defined in the stack wasn't big enough to hold
        //  the Value information.
        //  If the caller's buffer is big enough to hold the value data
        //  then allocate a new buffer, and call the NT API again.
        //
        if( ( ( KeyValueInformationClass == KeyValuePartialInformation ) &&
              ( ARGUMENT_PRESENT( lpData ) ) &&
              ( *lpcbData >=
                 (( PKEY_VALUE_PARTIAL_INFORMATION )
                 KeyValueInformation )->DataLength
              )
            )
          ) {
            BufferLength = ResultLength;

            KeyValueInformation = RtlAllocateHeap( RtlProcessHeap( ), 0,
                                                   BufferLength
                                                 );
            //
            // If the memory allocation fails, return a Registry error.
            //

            if( ! KeyValueInformation ) {
                return ERROR_OUTOFMEMORY;
            }

            //
            // Query for the necessary information about the supplied value.
            //

            Status = NtQueryValueKey( hkQueryKey,
                                      lpValueName,
                                      KeyValueInformationClass,
                                      KeyValueInformation,
                                      BufferLength,
                                      &ResultLength
                                    );
        }
    }

#ifdef LOCAL
    if (hkUserClasses && hkMachineClasses) {
        if (hkUserClasses != hKey) {
            NtClose(hkUserClasses);
        } else {
            NtClose(hkMachineClasses);
        }
    }
#endif // LOCAL

    if( NT_SUCCESS( Status ) &&
        ARGUMENT_PRESENT( lpData ) ) {
        //
        //  If requested, copy the value data
        //
        if( *lpcbData >= (( PKEY_VALUE_PARTIAL_INFORMATION )
                            KeyValueInformation )->DataLength ) {

            RtlMoveMemory( lpData,
                           (( PKEY_VALUE_PARTIAL_INFORMATION )
                                KeyValueInformation )->Data,
                           (( PKEY_VALUE_PARTIAL_INFORMATION )
                                KeyValueInformation )->DataLength
                         );
        } else {
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }


    //
    // Certain information is returned on success or in the case of
    // NtQueryValueKey returning STATUS_BUFFER_OVERFLOW.  This information
    // is always available because we always pass the minimum size required for
    // the NtQueryValueKey API.
    //

    if( NT_SUCCESS( Status ) ||
        ( Status == STATUS_BUFFER_OVERFLOW ) ) {

        if( KeyValueInformationClass == KeyValueBasicInformation ) {

            //
            // If requested, return the value type.
            //

            if( ARGUMENT_PRESENT( lpType )) {

                *lpType = (( PKEY_VALUE_BASIC_INFORMATION )
                            KeyValueInformation )->Type;
            }

        } else {

            //
            // If requested, return the value type.
            //

            if( ARGUMENT_PRESENT( lpType )) {

                *lpType = (( PKEY_VALUE_PARTIAL_INFORMATION )
                            KeyValueInformation )->Type;
            }

            //
            // Return the value data size
            //
            *lpcbData = (( PKEY_VALUE_PARTIAL_INFORMATION )
                            KeyValueInformation )->DataLength;
        }
    }

    //
    // Transmit all of the data back to the client.
    //

    if( ARGUMENT_PRESENT( lpcbLen ) ) {
        if( NT_SUCCESS( Status ) &&
            ARGUMENT_PRESENT( lpData ) ) {
            *lpcbLen = (( PKEY_VALUE_PARTIAL_INFORMATION )
                        KeyValueInformation )->DataLength;
        } else {
            //
            // The API failed, so make sure that no data is transmitted back
            // to the client. This ensures that the client stub will not
            // attempt to unmarshall data that doesn't exist.
            //

            *lpcbLen = 0;
        }
    }

    //
    //  If memory was allocated, then free it
    //
    if( KeyValueInformation != PrivateKeyValueInformation ) {

        RtlFreeHeap( RtlProcessHeap( ), 0, KeyValueInformation );
    }
    return (error_status_t)RtlNtStatusToDosError( Status );
}

error_status_t
BaseRegQueryMultipleValues(
    IN HKEY hKey,
    IN OUT PRVALENT val_list,
    IN DWORD num_vals,
    OUT LPSTR lpvalueBuf,
    IN OUT LPDWORD ldwTotsize
    )
/*++

Routine Description:

    For an open key, atomically queries a set of values.

Arguments:

    hKey - Supplies a handle to the open key. The value entries returned
           are contained in the key pointed to by this key handle. Any of
           the predefined reserved handles or a previously opened key handle
           may be used for hKey.

    val_list - Supplies a pointer to an array of RVALENT structures, one for
           each value to be queried.

    num_vals - Supplies the size in bytes of the val_list array.

    lpValueBuf - Returns the data for each value

    ldwTotsize - Supplies the length of lpValueBuf. Returns the number of bytes
                 written into lpValueBuf. If lpValueBuf is not large enough to
                 contain all the data, returns the size of lpValueBuf required
                 to return all the requested data.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/
{
    NTSTATUS Status;
    ULONG RequiredLength;
    ULONG i;

    //
    // Call out to Perflib if the HKEY is HKEY_PERFOMANCE_DATA.
    //

    if(( hKey == HKEY_PERFORMANCE_DATA ) ||
       ( hKey == HKEY_PERFORMANCE_TEXT ) ||
       ( hKey == HKEY_PERFORMANCE_NLSTEXT)) {

        return((error_status_t)ERROR_CALL_NOT_IMPLEMENTED);
    }

    //
    //  Subtract the NULLs from the Length. This was added on
    //  the client side so that RPC would transmit it.
    //
    for (i=0; i<num_vals; i++) {
        if (val_list[i].rv_valuename->Length > 0) {
            val_list[i].rv_valuename->Length -= sizeof( UNICODE_NULL );
        }
    }

#ifdef LOCAL

    //
    // For class keys in hkcr, we need to merge the data
    //
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

        Status = BaseRegQueryMultipleClassKeyValues(
            hKey,
            val_list,
            num_vals,
            lpvalueBuf,
            ldwTotsize,
            &RequiredLength);

    } else {

#endif // LOCAL

    Status = NtQueryMultipleValueKey(hKey,
                                     (PKEY_VALUE_ENTRY)val_list,
                                     num_vals,
                                     lpvalueBuf,
                                     ldwTotsize,
                                     &RequiredLength);

#ifdef LOCAL

    }

#endif // LOCAL

    if (Status == STATUS_BUFFER_OVERFLOW) {
        *ldwTotsize = RequiredLength;
    } else if (!NT_SUCCESS(Status)) {
        //
        // The API failed, so make sure that no data is transmitted back
        // to the client. This ensures that the client stub will not
        // attempt to unmarshall data that doesn't exist.
        //

        *ldwTotsize = 0;
    }

    return(error_status_t)RtlNtStatusToDosError(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regnckey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regnckey.c

Abstract:

    This module contains the Win32 Registry APIs to notify a caller about
    a changed Key value. That is:

        - RegNotifyChangeKey

Author:

    David J. Gilman (davegi) 10-Feb-1992


Notes:


    The RegNotifyChangeKey server creates an event and calls
    NtNotifyChangeKey asynchronously with that event.  It then
    places the event (plus some other client information, such
    as a named pipe and a client event) in a "Notification List"
    and returns to the client.

    A Notification List is a list of events controled by a
    handler thread. The handler thread waits on the events in
    the list. When an event is signaled the handler thread
    identifies the client to which the event belongs, and
    gives the client (via named pipe) the corresponding client
    event.

    Since there is a limit on the number of events on which a
    thread can wait, there may be several Notification Lists.

    Since all the calls to RegNotifyChangeKey in a client
    process use the same named pipe, we maintain only one copy
    of each pipe. Pipe information is maintained in a symbol table
    for fast lookup.



Revision History:

    02-Apr-1992     Ramon J. San Andres (ramonsa)
                    Changed to use RPC.


--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include <string.h>


#ifndef REMOTE_NOTIFICATION_DISABLED
//
//  Strings used for generating named pipe names
//
#define NAMED_PIPE_HERE     L"\\Device\\NamedPipe\\"
#define NAMED_PIPE_THERE    L"\\DosDevices\\UNC\\"


//
//  Pipe names are maintained in a symbol table. The symbol table has
//  one entry for each different pipe given by a client.  The entry
//  is maintained for as long as there is at least one entry in a
//  Notification List referencing it.
//
typedef struct _PIPE_ENTRY *PPIPE_ENTRY;

typedef struct _PIPE_ENTRY {

    PPIPE_ENTRY             Previous;
    PPIPE_ENTRY             Next;
    UNICODE_STRING          PipeName;
    DWORD                   ReferenceCount;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;

} PIPE_ENTRY;




//
//  The PIPE_SYMBOL_TABLE structure contains the symbol table for
//  all the pipes being used by the clients of
//  RegNotifyChangeKey
//
#define BUCKETS_IN_SYMBOL_TABLE     211

typedef struct _PIPE_SYMBOL_TABLE   *PPIPE_SYMBOL_TABLE;

typedef struct _PIPE_SYMBOL_TABLE {

    PPIPE_ENTRY             Bucket[ BUCKETS_IN_SYMBOL_TABLE ];

} PIPE_SYMBOL_TABLE;




//
//  Information about a pending event is maintained in a
//  NOTIFICATION_ENTRY structure.
//
typedef struct _NOTIFICATION_ENTRY *PNOTIFICATION_ENTRY;

typedef struct _NOTIFICATION_ENTRY {

    DWORD                   ClientEvent;    //  Event in client side
    HANDLE                  hKey;           //  Key handle
    DWORD                   Flags;          //  Misc. flags
    PPIPE_ENTRY             PipeEntry;      //  Pipe Entry

} NOTIFICATION_ENTRY;


//
//  Flag values
//
#define CLIENT_IS_DEAD       0x00000001
#define MUST_NOTIFY          0x00000002
#define NOTIFICATION_FAILED  0x00000004



//
//  The pending events are maintained in notification lists. Each
//  notification list contains:
//
//  Previous        -   Previous in chain
//  Next            -   Next in chain
//  EventsInUse     -   Number of entries being used in this list
//  EventHandle     -   Array of event handles
//  ClientEvent     -   Array of events in client
//  PipeEntry       -   Array of pointers to pipe entries in symbol table
//
//
//  The first event in the EventHandle list is the event used to wake
//  up the thread whenever we add new entries to the list.
//
//  The array entries 0..EventsInUse-1 contain the pending events.
//  New events are always added at position EventsInUse. When removing
//  an event, all the arrays are shifted.
//
//  Whenever EventsInUse == 1, the list is empty of client events and
//  it can be removed (together with its thread).
//
//
//  Notification Lists are kept in a doubly-linked list. A new
//  Notification List is created and added to the chain whenever an
//  event is added and all the existing lists are full.  Notification
//  lists are deleted when the last event in the list is signaled.
//
//
typedef struct _NOTIFICATION_LIST *PNOTIFICATION_LIST;

typedef struct _NOTIFICATION_LIST {

    PNOTIFICATION_LIST      Previous;
    PNOTIFICATION_LIST      Next;
    DWORD                   EventsInUse;
    HANDLE                  HandlerThread;
    CLIENT_ID               HandlerClientId;
    DWORD                   PendingNotifications;
    HANDLE                  EventHandle[ MAXIMUM_WAIT_OBJECTS ];
    NOTIFICATION_ENTRY      Event[ MAXIMUM_WAIT_OBJECTS ];
    DWORD                   TimeOutCount;
    BOOLEAN                 ResetCount;

} NOTIFICATION_LIST;

#define MAX_TIMEOUT_COUNT   128


#if DBG
    #define BIGDBG 0
#else
    #define BIGDBG 0
#endif

#define HASH(a,b)   Hash(a,b)



// *****************************************************************
//
//                    Static Variables
//
// *****************************************************************



//
//  Head of chain of Notification lists
//
PNOTIFICATION_LIST      NotificationListChainHead;

//
//  The critical sesction protects all the global structures.
//
RTL_CRITICAL_SECTION    NotificationCriticalSection;

//
//  Symbol table for named pipes in use.
//
PIPE_SYMBOL_TABLE       PipeSymbolTable;

//
//  Our machine name is used for determining if requests are local
//  or remote.
//
WCHAR                   OurMachineNameBuffer[ MAX_PATH ];
UNICODE_STRING          OurMachineName;

//
//  The I/O Status Block is updated by the NtNotifyChangeKey API
//  upon notification.  We cannot put this structure on the stack
//  because at notification time this stack might belong to someone
//  else. We can use a single variable because we don't care about
//  its contents so it's ok if several people mess with it at the
//  same time.
//
IO_STATUS_BLOCK         IoStatusBlock;





// *****************************************************************
//
//                    Local Prototypes
//
// *****************************************************************



LONG
CreateNotificationList (
    OUT PNOTIFICATION_LIST  *NotificationListUsed
    );

LONG
DeleteNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

LONG
AddEvent (
    IN  HKEY                     hKey,
    IN  HANDLE                   EventHandle,
    IN  DWORD                    ClientEvent,
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa OPTIONAL,
    OUT PNOTIFICATION_LIST      *NotificationListUsed
    );

LONG
RemoveEvent (
    IN      HANDLE              EventHandle,
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

LONG
GetAvailableNotificationList (
    OUT PNOTIFICATION_LIST  *NotificationListUsed
    );

LONG
AddEntryToNotificationList(
    IN OUT  PNOTIFICATION_LIST       NotificationList,
    IN      HKEY                     hKey,
    IN      HANDLE                   EventHandle,
    IN      DWORD                    ClientEvent,
    IN      PUNICODE_STRING          PipeName,
    IN      PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL
    );

LONG
RemoveEntryFromNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList,
    IN      DWORD               EntryIndex
    );

LONG
CompactNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

VOID
AddNotificationListToChain(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

VOID
RemoveNotificationListFromChain(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

LONG
GetFullPipeName(
    IN      PUNICODE_STRING         MachineName,
    IN      PUNICODE_STRING         PipeName,
    IN OUT  PUNICODE_STRING         FullPipeName
    );

LONG
CreatePipeEntry (
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL,
    OUT PPIPE_ENTRY              *PipeEntryUsed
    );

LONG
DeletePipeEntry(
    IN OUT PPIPE_ENTRY  PipeEntry
    );

LONG
AddPipe(
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL,
    OUT PPIPE_ENTRY              *PipeEntryUsed
    );

LONG
RemovePipe(
    IN OUT PPIPE_ENTRY  PipeEntry
    );

LONG
AddPipeEntryToSymbolTable(
    IN OUT  PPIPE_ENTRY PipeEntry
    );

LONG
RemovePipeEntryFromSymbolTable(
    IN OUT  PPIPE_ENTRY PipeEntry
    );

LONG
LookForPipeEntryInSymbolTable(
    IN  PUNICODE_STRING PipeName,
    OUT PPIPE_ENTRY     *PipeEntryUsed
    );

DWORD
Hash(
    IN  PUNICODE_STRING  Symbol,
    IN  DWORD            Buckets
    );

VOID
NotificationHandler(
    IN  PNOTIFICATION_LIST  NotificationList
    );

DWORD
NotificationListMaintenance(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    );

LONG
SendEventToClient(
    IN  DWORD           ClientEvent,
    IN  PPIPE_ENTRY     PipeEntry
    );

#if BIGDBG
VOID
DumpNotificationLists(
    );

VOID
DumpPipeTable(
    );

#endif

#endif // REMOTE_NOTIFICATION_DISABLED



// *****************************************************************
//
//                    BaseRegNotifyChangeKeyValue
//
// *****************************************************************





BOOL
InitializeRegNotifyChangeKeyValue(
    )
/*++

Routine Description:


    Initializes the static data structures used by the
    RegNotifyChangeKeyValue server. Called once at program
    initialization.

Arguments:

    None

Return Value:

    BOOLEAN -   TRUE if successful.


--*/

{
#ifdef REMOTE_NOTIFICATION_DISABLED

    return( TRUE );

#else   // REMOTE_NOTIFICATION_DISABLED

    NTSTATUS        NtStatus;
    DWORD           Bucket;
    DWORD           MachineNameLength;


    NotificationListChainHead = NULL;

    //
    //  Determine our machine name
    //
    MachineNameLength = MAX_PATH;
    if ( !GetComputerNameW( OurMachineNameBuffer, &MachineNameLength ) ) {
        return FALSE;
    }

    OurMachineName.Buffer        = OurMachineNameBuffer;
    OurMachineName.Length        = (USHORT)(MachineNameLength * sizeof(WCHAR));
    OurMachineName.MaximumLength = (USHORT)(MAX_PATH * sizeof(WCHAR));


    //
    //  Initialize Notification critical section
    //
    NtStatus = RtlInitializeCriticalSection(
                    &NotificationCriticalSection
                    );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return FALSE;
    }


    //
    //  Initialize the pipe symbol table
    //
    for ( Bucket = 0; Bucket < BUCKETS_IN_SYMBOL_TABLE; Bucket++ ) {
        PipeSymbolTable.Bucket[Bucket] = NULL;
    }

    return TRUE;
#endif   // REMOTE_NOTIFICATION_DISABLED
}




error_status_t
BaseRegNotifyChangeKeyValue(
    IN  HKEY                     hKey,
    IN  BOOLEAN                  fWatchSubtree,
    IN  DWORD                    dwNotifyFilter,
    IN  DWORD                    hEvent,
    IN  PUNICODE_STRING          MachineName,
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa OPTIONAL
    )

/*++

Routine Description:

    This API is used to watch a key or sub-tree for changes. It is
    asynchronous. It is possible to filter the criteria by which the
    notification occurs.


Arguments:

    hKey - Supplies a handle to a key that has been previously opened with
        KEY_NOTIFY access.

    fWatchSubtree - Supplies a boolean value that if TRUE causes the
        system to monitor the key and all of its decsendants.  A value of
        FALSE causes the system to monitor only the specified key.

    dwNotifyFilter - Supplies a set of flags that specify the filter
        conditions the system uses to satisfy a change notification.

        REG_NOTIFY_CHANGE_KEYNAME - Any key name changes that occur
            in a key or subtree being watched will satisfy a
            change notification wait.  This includes creations
            and deletions.

        REG_NOTIFY_CHANGE_ATTRIBUTES - Any attribute changes that occur
            in a key or subtree being watched will satisfy a
            change notification.

        REG_NOTIFY_CHANGE_LAST_WRITE - Any last write time changes that
            occur in a key or subtree being watched will satisfy a
            change notification.

        REG_NOTIFY_CHANGE_SECURITY - Any security descriptor changes
            that occur in a key or subtree being watched will
            satisfy a change notification.


    hEvent - Supplies a DWORD which represents an event that will have to
             be communicated to the client (via named pipe) when a key
             has to be notified.


    PipeName - Supplies the name of the pipe used for communicating
            the notification to the client.

    pRpcSa - Supplies the optional security attributes of the named
            pipe.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

#ifdef REMOTE_NOTIFICATION_DISABLED

    return ERROR_INVALID_PARAMETER;

#else   // REMOTE_NOTIFICATION_DISABLED

    NTSTATUS            NtStatus;
    HANDLE              EventHandle;
    PNOTIFICATION_LIST  NotificationList;
    LONG                Error;
    UNICODE_STRING      FullPipeName;


    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Enter the critical section
    //
    NtStatus = RtlEnterCriticalSection( &NotificationCriticalSection );
    if ( !NT_SUCCESS( NtStatus ) ) {
        return (error_status_t)RtlNtStatusToDosError( NtStatus );
    }

    try {

#if BIGDBG
        DbgPrint( "WINREG: RegNotify entered\n" );

        //DbgPrint( "WINREG: Notification requested. HKEY 0x%x, Client 0x%x, pipe %wZ\n",
        //           hKey, hEvent, PipeName );
        //DbgPrint( "       Watch subtree: 0x%x, filter 0x%x\n", fWatchSubtree, dwNotifyFilter );

#endif


        //
        //  Subtract the NULL from the Length of all the strings.
        //  This was added by the client so that RPC would transmit
        //  the whole thing.
        //
        if ( MachineName->Length > 0 ) {
            MachineName->Length -= sizeof(UNICODE_NULL );
        }
        if ( PipeName->Length > 0 ) {
            PipeName->Length -= sizeof(UNICODE_NULL );
        }

        //
        //  Construct the full pipe name based on the machine name
        //  and the pipe name given.
        //
        FullPipeName.Buffer = RtlAllocateHeap(
                                RtlProcessHeap( ), 0,
                                MAX_PATH * sizeof(WCHAR)
                                );

        if ( !FullPipeName.Buffer ) {

            Error = ERROR_OUTOFMEMORY;

        } else {


            FullPipeName.Length         = 0;
            FullPipeName.MaximumLength  = MAX_PATH * sizeof(WCHAR);


            Error = GetFullPipeName(
                        MachineName,
                        PipeName,
                        &FullPipeName
                        );

            if ( Error == ERROR_SUCCESS ) {

                //
                //  Create an event on which we will wait for completion of
                //  the API.
                //
                NtStatus = NtCreateEvent(
                                &EventHandle,
                                (ACCESS_MASK)EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE
                                );

                if ( NT_SUCCESS( NtStatus ) ) {

                    //
                    //  Add the event to a Notification List
                    //
                    Error = AddEvent(
                                hKey,
                                EventHandle,
                                hEvent,
                                &FullPipeName,
                                pRpcSa,
                                &NotificationList
                                );

                    if ( Error == ERROR_SUCCESS ) {

                        //
                        //  Call the NT API
                        //
                        NtStatus = NtNotifyChangeKey(
                                        hKey,
                                        EventHandle,
                                        NULL,
                                        NULL,
                                        &IoStatusBlock,
                                        dwNotifyFilter,
                                        ( BOOLEAN ) fWatchSubtree,
                                        NULL,
                                        0,
                                        TRUE
                                        );

                        if ( NT_SUCCESS( NtStatus ) ||
                             (NtStatus == STATUS_PENDING) ) {

                            Error = ERROR_SUCCESS;

                        } else {

                            //
                            //  Could not request notification, remove the
                            //  event from the notification list.
                            //
                            Error = RemoveEvent(
                                        EventHandle,
                                        NotificationList
                                        );

                            ASSERT( Error == ERROR_SUCCESS );

                            Error = RtlNtStatusToDosError( NtStatus );
                        }

                    } else {

                        //
                        //  Could not add the event to any notification
                        //  list.
                        //
                        NtStatus = NtClose( EventHandle );
                        ASSERT( NT_SUCCESS( NtStatus ) );
                    }

                } else {

                    Error = RtlNtStatusToDosError( NtStatus );
                }
            }

            RtlFreeHeap(
                RtlProcessHeap( ), 0,
                FullPipeName.Buffer
                );
        }

    } except ( NtStatus = GetExceptionCode() ) {

#if DBG
        DbgPrint( "WINREG Error: Exception %x in BaseRegNotifyChangeKeyValue\n",
                  NtStatus );
        DbgBreakPoint();
#endif
        Error = RtlNtStatusToDosError( NtStatus );

    }

#if BIGDBG
    DbgPrint( "WINREG: RegNotify left\n" );
#endif

    NtStatus = RtlLeaveCriticalSection( &NotificationCriticalSection );
    ASSERT( NT_SUCCESS( NtStatus ) );

    RPC_REVERT_TO_SELF();
    return (error_status_t)Error;
#endif   // REMOTE_NOTIFICATION_DISABLED
}




BOOL
CleanDeadClientInfo(
    HKEY    hKey
    )
/*++

Routine Description:

    When a client dies, this function searches the notification lists to
    see if we the client has some pending notifications. We flag the
    entries in the notification lists and signal the events so that
    the notification handler can get rid of these orphans.

Arguments:

    hKey    -   Client's hKey

Return Value:

    BOOL - Returns TRUE unless something REALLY weird happened.


--*/

{
#ifdef REMOTE_NOTIFICATION_DISABLED

    return( TRUE );

#else // REMOTE_NOTIFICATION_DISABLED

    NTSTATUS            NtStatus;
    PNOTIFICATION_LIST  NotificationList;
    PNOTIFICATION_ENTRY Event;
    DWORD               Index;
    BOOL                Ok               = TRUE;
    BOOL                FoundDeadClients;

    //
    //  Enter the critical section
    //
    NtStatus = RtlEnterCriticalSection( &NotificationCriticalSection );
    if ( !NT_SUCCESS( NtStatus ) ) {
        return FALSE;
    }

#if BIGDBG
    DbgPrint( "WINREG: Dead client, hKey 0x%x\n", hKey );
#endif

    try {

        //
        //  Traverse all the lists looking for orphans.
        //
        for ( NotificationList = NotificationListChainHead;
              NotificationList;
              NotificationList = NotificationList->Next ) {

            FoundDeadClients = FALSE;
            Event = NotificationList->Event;

            //
            //  Examine all the entries of the list to see if any
            //  entry is an orphan.
            //
            for ( Index = 1;
                  Index < NotificationList->EventsInUse;
                  Index++ ) {

                //
                //  If this entry is an orphan, flag it as such and
                //  signal the event so that the notification handler
                //  can clean it up.
                //
                if ( Event->hKey == hKey ) {

#if BIGDBG
                    DbgPrint( "WINREG:  Found notification orphan, hKey 0x%x Client 0x%x\n",
                              hKey, Event->ClientEvent );
#endif
                    Event->Flags |= CLIENT_IS_DEAD;

                    FoundDeadClients = TRUE;
                }

                Event++;
            }

            if ( FoundDeadClients ) {
                NtStatus = NtSetEvent( NotificationList->EventHandle[0], NULL );
                ASSERT( NT_SUCCESS( NtStatus ) );
            }
        }

    } except ( NtStatus = GetExceptionCode() ) {

#if DBG
        DbgPrint( "WINREG Error: Exception %x in CleanDeadClientInfo\n",
                  NtStatus );
        DbgBreakPoint();
#endif

        Ok = FALSE;

    }

#if BIGDBG
    DbgPrint( "WINREG: Dead client left\n" );
#endif

    NtStatus = RtlLeaveCriticalSection( &NotificationCriticalSection );
    ASSERT( NT_SUCCESS( NtStatus ) );

    return Ok;
#endif // REMOTE_NOTIFICATION_DISABLED
}


// *****************************************************************
//
//                  Notification List funcions
//
// *****************************************************************



#ifndef REMOTE_NOTIFICATION_DISABLED

LONG
CreateNotificationList (
    OUT PNOTIFICATION_LIST  *NotificationListUsed
    )
/*++

Routine Description:

    Creates a new Notification List and its handler thread.

Arguments:

    NotificationListUsed    -   Supplies pointer to pointer to Notification List

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

    PNOTIFICATION_LIST  NotificationList;
    DWORD               Index;
    NTSTATUS            NtStatus;
    LONG                Error;

#if BIGDBG
    DbgPrint( "WINREG: Creating new notification list\n" );
#endif

    //
    //  Allocate memory for the new Notification List
    //
    NotificationList = RtlAllocateHeap(
                            RtlProcessHeap( ), 0,
                            sizeof( NOTIFICATION_LIST )
                            );

    if ( !NotificationList ) {
        return ERROR_OUTOFMEMORY;
    }


    //
    //  Create the "Wake up" event handle, which is used to wake
    //  up the handler thread whenever new events are added to
    //  the notification list.
    //
    NtStatus = NtCreateEvent(
                    &(NotificationList->EventHandle[0] ),
                    (ACCESS_MASK)EVENT_ALL_ACCESS,
                    NULL,
                    SynchronizationEvent,
                    FALSE
                    );

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        //  Mark rest of entries as "available"
        //
        for ( Index = 1; Index < MAXIMUM_WAIT_OBJECTS; Index++ ) {
            NotificationList->EventHandle[Index] = NULL;
        }

        //
        //  Set initial number of EventInUse to 1 (which is the
        //  index to the next available spot in the list).
        //
        NotificationList->EventsInUse = 1;

        //
        //  Set chain links
        //
        NotificationList->Previous  = NULL;
        NotificationList->Next      = NULL;

        NotificationList->PendingNotifications = 0;

        //
        //  Now that everything has been initialized, create the
        //  handler thread for the list.
        //
        NotificationList->HandlerThread =
                                CreateThread(
                                        NULL,
                                        (32 * 1024),
                                        (LPTHREAD_START_ROUTINE)NotificationHandler,
                                        NotificationList,
                                        0,
                                        (LPDWORD)&(NotificationList->HandlerClientId)
                                        );

        if ( NotificationList->HandlerThread != NULL ) {

            *NotificationListUsed = NotificationList;

            Error = ERROR_SUCCESS;

        } else {

            //
            //  Could not create thread, close the event that we just
            //  created.
            //
            Error = GetLastError();

#if DBG
            DbgPrint( "WINREG Error: Cannot create notification thread, error %d\n",
                      Error );
            DbgBreakPoint();
#endif

            NtStatus = NtClose( NotificationList->EventHandle[0] );

            ASSERT( NT_SUCCESS( NtStatus ) );
        }

    } else {

#if DBG
        DbgPrint( "WINREG Error: Cannot create notification event, status 0x%x\n",
                  NtStatus );
        DbgBreakPoint();
#endif

        Error = RtlNtStatusToDosError( NtStatus );
    }

    //
    //  If something went wrong, free up the notification list
    //
    if ( Error != ERROR_SUCCESS ) {
        RtlFreeHeap(
            RtlProcessHeap( ), 0,
            NotificationList
            );
        *NotificationListUsed = NULL;
    }

    return Error;
}




LONG
DeleteNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )
/*++

Routine Description:

    Deletes a Notification List. The handler thread is not terminated
    because it is the handler thread who deletes notification lists,
    commiting suicide afterwards.

Arguments:

    NotificationList    -   Supplies pointer to Notification List

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    NTSTATUS    NtStatus;

#if BIGDBG
    DbgPrint( "WINREG: Removing empty notification list\n" );
#endif

    //
    //  The only event in the list must be the "wakeup" event
    //
    ASSERT( NotificationList->EventsInUse == 1 );

    //
    //  Delete the "wake up" event
    //
    NtStatus = NtClose( NotificationList->EventHandle[0] );
    ASSERT( NT_SUCCESS( NtStatus ) );

    //
    //  Free up the heap used by the Notification List
    //
    RtlFreeHeap(
         RtlProcessHeap( ), 0,
         NotificationList
         );

    return ERROR_SUCCESS;
}




LONG
AddEvent (
    IN  HKEY                     hKey,
    IN  HANDLE                   EventHandle,
    IN  DWORD                    ClientEvent,
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa OPTIONAL,
    OUT PNOTIFICATION_LIST      *NotificationListUsed
    )
/*++

Routine Description:

    Adds an event to the first notification list with an available slot.

    If no notification list has an available slot, a new notification list
    (an its handler thread) is created.


Arguments:

    hKey        -   Supplies registry key handle

    EventHandle -   Supplies an event on which the handler thread of the
                    Notification List has to wait.

    ClientEvent -   Supplies the event which has to be communicated to the
                    client when out EventHandle is signaled. This event is
                    communicated to the client via named pipe.

    PipeNameU   -   Supplies the name of the pipe for communicating with the
                    client.

    pRpcSa      -   Supplies the optional security attributes of the named
                    pipe.

    NotificationListused -   Supplies a pointer where the address of the
                             Notification List in which the event is put
                             is placed.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    PNOTIFICATION_LIST  NotificationList;
    LONG                Error;
    NTSTATUS            NtStatus;

    ASSERT( EventHandle != NULL );
    ASSERT( PipeName && PipeName->Buffer );
    ASSERT( NotificationListUsed );


    //
    //  Get a Notification List with an available entry.
    //
    Error = GetAvailableNotificationList(
                    &NotificationList
                    );

    if ( Error == ERROR_SUCCESS ) {

        //
        //  Add the entry
        //
        Error = AddEntryToNotificationList(
                        NotificationList,
                        hKey,
                        EventHandle,
                        ClientEvent,
                        PipeName,
                        pRpcSa
                        );

        if ( Error == ERROR_SUCCESS ) {

            //
            //  A new entry has been added, we have to wake up the
            //  handler thread so that it will wait on the newly added
            //  event.
            //
            NtStatus = NtSetEvent( NotificationList->EventHandle[0], NULL );
            ASSERT( NT_SUCCESS( NtStatus ) );

            *NotificationListUsed = NotificationList;

        } else {

#if DBG
            DbgPrint( "WINREG: Could not add notification entry! Error %d\n ", Error);
#endif
        }

    } else {

#if DBG
        DbgPrint( "WINREG: Could not get a notification list! Error %d\n ", Error);
#endif

    }

    return Error;
}




LONG
RemoveEvent (
    IN      HANDLE              EventHandle,
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )

/*++

Routine Description:

    Removes an event from the notification list. The caller must
    make sure that the event handle given does live in the
    Notification List specified.

    This function is called if the notification is aborted for some
    reason (e.g. the NT notification API fails).

Arguments:

    EventHandle         -   Supplies the event to remove.

    NotificationList    -   Supplies the Notification List in which
                            the event lives.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    LONG        Error;
    DWORD       EntryIndex;

    //
    //  Search for the entry that we have to remove.
    //
    for ( EntryIndex = 1;
          EntryIndex < NotificationList->EventsInUse;
          EntryIndex++ ) {

        if ( EventHandle == NotificationList->EventHandle[ EntryIndex ] ) {
            break;
        }
    }

    ASSERT( EntryIndex < NotificationList->EventsInUse );

    if ( EntryIndex < NotificationList->EventsInUse ) {

        //
        //  Found entry, remove it
        //
        Error = RemoveEntryFromNotificationList(
                    NotificationList,
                    EntryIndex
                    );

        //
        //  Note that we are leaving a hole in the Notification list,
        //  the handler will eventually compact it.
        //

    } else {

        Error = ERROR_ARENA_TRASHED;

    }

    return Error;
}




LONG
GetAvailableNotificationList (
    OUT PNOTIFICATION_LIST  *NotificationListUsed
    )
/*++

Routine Description:

    Gets a Notification List with an available entry.

Arguments:

    NotificationList    -   Supplies pointer to where the Notification
                            List pointer will be placed.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/
{
    LONG                Error = ERROR_SUCCESS;
    PNOTIFICATION_LIST  NotificationList;

    //
    //  Traverse the chain of Notification lists until we find a Notification
    //  list with an available entry.
    //
    for ( NotificationList = NotificationListChainHead;
          NotificationList && NotificationList->EventsInUse >= MAXIMUM_WAIT_OBJECTS;
          NotificationList = NotificationList->Next );


    //
    //  If we did not find a Notification List with an available spot,
    //  create a new Notification List and add it to the chain.
    //
    if ( !NotificationList ) {

        Error = CreateNotificationList( &NotificationList );

        if ( Error == ERROR_SUCCESS ) {

            ASSERT( NotificationList );

            AddNotificationListToChain( NotificationList );
        }
    }

    *NotificationListUsed = NotificationList;

    return Error;
}




LONG
AddEntryToNotificationList(
        IN OUT  PNOTIFICATION_LIST       NotificationList,
        IN      HKEY                     hKey,
        IN      HANDLE                   EventHandle,
        IN      DWORD                    ClientEvent,
        IN      PUNICODE_STRING          PipeName,
        IN      PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL
        )
/*++

Routine Description:

    Adds an entry to a notification list.

    Calls to this function must be protected by the critical
    section of the Notification List.


Arguments:

    NotificationList    -   Supplies pointer to Notification List

    hKey                -   Supplies registry key handle

    EventHandle         -   Supplies the event handle

    ClientEvent         -   Supplies the client's event

    PipeName            -   Supplies name of pipe.

    pRpcSa              -   Supplies security attributes for the pipe

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/
{
    LONG                Error;
    PPIPE_ENTRY         PipeEntry;
    DWORD               Index;
    PNOTIFICATION_ENTRY Event;


    //
    //  Add the pipe information to the pipe symbol table
    //
    Error = AddPipe( PipeName, pRpcSa, &PipeEntry );

    if ( Error == ERROR_SUCCESS ) {

        //
        //  Add the event in the next available spot in the list,
        //  and increment the number of events in use by the
        //  list.
        //
        Index = NotificationList->EventsInUse++;

        Event = &(NotificationList->Event[ Index ]);

        NotificationList->EventHandle[ Index ] = EventHandle;

        Event->ClientEvent = ClientEvent;
        Event->hKey        = hKey;
        Event->Flags       = 0;
        Event->PipeEntry   = PipeEntry;

    } else {

#if BIGDBG
        DbgPrint( "WINREG: Could not create pipe entry for %wZ\n",
                  PipeName );
#endif

    }

    return Error;
}




LONG
RemoveEntryFromNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList,
    IN      DWORD               EntryIndex
    )
/*++

Routine Description:


    Removes an entry from a Notification List. It leaves a hole
    in the list, i.e. the list is not compacted.

Arguments:

    NotificationList    -   Supplies pointer to Notification List.

    EntryIndex          -   Supplies index of entry to remove.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    LONG    Error;

    ASSERT( EntryIndex < NotificationList->EventsInUse );
    ASSERT( NotificationList->EventHandle[ EntryIndex ] != NULL );

    //
    //  Remove the entry from the pipe symbol table.
    //
    Error = RemovePipe( NotificationList->Event[ EntryIndex ].PipeEntry );

    if ( Error == ERROR_SUCCESS ) {

        //
        //  We "remove" the entry from the notification list by
        //  invalidating its handle. Note that we don't decrement
        //  the counter of entries in the notification list because
        //  that is used for indexing the next available entry.
        //  The counter will be fixed by the compaction function.
        //
        NotificationList->EventHandle[ EntryIndex ]     = NULL;
        NotificationList->Event[ EntryIndex ].PipeEntry = NULL;
    }

    return Error;
}




LONG
CompactNotificationList (
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )
/*++

Routine Description:


    Compacts (i.e. removes holes from) a Notification List.

Arguments:

    NotificationList    -   Supplies pointer to Notification List.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    DWORD   ToIndex;
    DWORD   FromIndex;
    DWORD   Index;
    DWORD   EntriesToMove;
    PVOID   Src;
    PVOID   Dst;

#if BIGDBG
    DbgPrint( "    * Compacting notification list\n" );
#endif

    for ( ToIndex = 1; ToIndex < NotificationList->EventsInUse; ToIndex++ ) {

#if BIGDBG
        DbgPrint( "        - %d\n", ToIndex );
#endif
        //
        //  If we find a hole, we compact the arrays i.e. shift them to
        //  remove the hole.
        //
        if ( NotificationList->EventHandle[ ToIndex ] == NULL ) {

            //
            //  Found the beginning of a hole, search for the next
            //  entry in use.
            //
            for ( FromIndex = ToIndex+1;
                  (FromIndex < NotificationList->EventsInUse) &&
                  (NotificationList->EventHandle[ FromIndex ] == NULL );
                  FromIndex++ ) {
            }

            //
            //  If there is something to shift, shift it
            //
            if ( FromIndex < NotificationList->EventsInUse ) {

                EntriesToMove = NotificationList->EventsInUse - FromIndex;

                Src = (PVOID)&(NotificationList->EventHandle[ FromIndex ] );
                Dst = (PVOID)&(NotificationList->EventHandle[ ToIndex ] );

                RtlMoveMemory(
                         Dst,
                         Src,
                         EntriesToMove * sizeof( HANDLE )
                         );

                Src = &(NotificationList->Event[ FromIndex ] );
                Dst = &(NotificationList->Event[ ToIndex ] );

                RtlMoveMemory(
                         Dst,
                         Src,
                         EntriesToMove * sizeof( NOTIFICATION_ENTRY )
                         );

                //
                //  Clear the rest of the entries, just to keep things
                //  clean.
                //
                for ( Index = ToIndex + EntriesToMove;
                      Index < NotificationList->EventsInUse;
                      Index++ ) {

                    NotificationList->EventHandle[ Index ] = NULL;
                }

                NotificationList->EventsInUse -= (FromIndex - ToIndex);


            } else {

                //
                //  Nothing to shift, this will become the
                //  first available entry of the list.
                //
                NotificationList->EventsInUse = ToIndex;
            }
        }
    }

#if BIGDBG
    DbgPrint( "    * Compacted.\n" );
#endif


    return ERROR_SUCCESS;
}





VOID
AddNotificationListToChain(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )

/*++

Routine Description:

    Adds a Notification list to the chain of Notification Lists.

    The new list is put at the head of the chain.

Arguments:

    NotificationList    -   Supplies the Notification list to add


Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

    NotificationList->Previous = NULL;
    NotificationList->Next     = NotificationListChainHead;

    if ( NotificationListChainHead ) {
        NotificationListChainHead->Previous = NotificationList;
    }

    NotificationListChainHead = NotificationList;
}




VOID
RemoveNotificationListFromChain(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )
/*++

Routine Description:

    Removes a Notification list from the chain


Arguments:

    NotificationList    -   Supplies the Notification list to remove


Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

    if ( NotificationList->Previous ) {
        (NotificationList->Previous)->Next = NotificationList->Next;
    }

    if ( NotificationList->Next ) {
        (NotificationList->Next)->Previous = NotificationList->Previous;
    }


    //
    //  If this is at the head of the chain, Let the next
    //  list be the new head.
    //
    if ( NotificationListChainHead == NotificationList ) {
        NotificationListChainHead = NotificationList->Next;
    }
}



// *****************************************************************
//
//                  Pipe Symbol Table functions
//
// *****************************************************************


LONG
GetFullPipeName (
    IN  PUNICODE_STRING          MachineName,
    IN  PUNICODE_STRING          PipeName,
    OUT PUNICODE_STRING          FullPipeName
    )
/*++

Routine Description:

    Makes a fully qualified pipe name from the supplied machine
    name and pipe name.

Arguments:

    PipeName        -   Supplies the pipe name

    MachineName     -   Supplies the client's machine name

    FullPipeName    -   Supplies the full pipe name

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    LONG            Error = ERROR_SUCCESS;
    NTSTATUS        NtStatus;

    ASSERT( PipeName->Buffer     && MachineName->Buffer &&
            PipeName->Length > 0 && MachineName->Length > 0 );

    if( !PipeName->Buffer     || !MachineName->Buffer ||
        PipeName->Length == 0 || MachineName->Length == 0 ) {
        Error =  ERROR_INVALID_PARAMETER;
    }

    if ( Error == ERROR_SUCCESS ) {

        //
        //  If the client's machine name and our machine name match,
        //  then we form a local named pipe path, otherwise we
        //  form a remote named pipe path.
        //
        if ( RtlEqualUnicodeString(
                        MachineName,
                        &OurMachineName,
                        TRUE
                        ) ) {


            //
            //  Pipe is local
            //
            RtlMoveMemory(
                    FullPipeName->Buffer,
                    NAMED_PIPE_HERE,
                    sizeof( NAMED_PIPE_HERE )
                    );

            FullPipeName->Length = sizeof( NAMED_PIPE_HERE ) - sizeof(UNICODE_NULL);


        } else {

            //
            //  Pipe is remote
            //
            RtlMoveMemory(
                    FullPipeName->Buffer,
                    NAMED_PIPE_THERE,
                    sizeof( NAMED_PIPE_THERE )
                    );

            FullPipeName->Length = sizeof( NAMED_PIPE_THERE ) - sizeof(UNICODE_NULL);

            NtStatus = RtlAppendUnicodeStringToString(
                                FullPipeName,
                                MachineName
                                );

            ASSERT( NT_SUCCESS( NtStatus ) );

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = RtlAppendUnicodeToString(
                                    FullPipeName,
                                    L"\\Pipe\\"
                                    );

                ASSERT( NT_SUCCESS( NtStatus ) );

                if ( !NT_SUCCESS( NtStatus ) ) {
                    Error = RtlNtStatusToDosError( NtStatus );
                }

            } else {

                Error = RtlNtStatusToDosError( NtStatus );
            }
        }

        if ( Error == ERROR_SUCCESS ) {

            NtStatus = RtlAppendUnicodeStringToString(
                                FullPipeName,
                                PipeName
                                );

            ASSERT( NT_SUCCESS( NtStatus ) );

            if ( !NT_SUCCESS( NtStatus ) ) {
                Error = RtlNtStatusToDosError( NtStatus );
            }
        }
    }

    return Error;
}






LONG
CreatePipeEntry (
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL,
    OUT PPIPE_ENTRY              *PipeEntryUsed
    )
/*++

Routine Description:

    Creates a pipe entry

Arguments:

    PipeName    -   Supplies the pipe name

    pRpcSa      -   Supplies the optional security attributes for the pipe

    PipeEntry   -   Supplies pointer to pointer to pipe entry.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

    PPIPE_ENTRY PipeEntry;
    LONG        Error;
    ULONG       LengthSd;

    ASSERT( PipeName && PipeName->Buffer );

    //
    //  Validate the security descriptor if one was provided
    //
    if ( pRpcSa ) {
        if ( !RtlValidSecurityDescriptor(
                pRpcSa->RpcSecurityDescriptor.lpSecurityDescriptor
                ) ) {

            return ERROR_INVALID_PARAMETER;
        }
    }


    //
    //  Allocate space for the Pipe Entry
    //
    PipeEntry = RtlAllocateHeap(
                    RtlProcessHeap( ), 0,
                    sizeof( PIPE_ENTRY )
                    );

    if ( !PipeEntry ) {
        return ERROR_OUTOFMEMORY;
    }


    //
    //  Allocate space for the pipe's name
    //
    PipeEntry->PipeName.Buffer = RtlAllocateHeap(
                                    RtlProcessHeap( ), 0,
                                    PipeName->Length + sizeof( UNICODE_NULL )
                                    );

    PipeEntry->PipeName.MaximumLength = PipeName->Length + (USHORT)sizeof( UNICODE_NULL );

    if ( PipeEntry->PipeName.Buffer ) {

        //
        //  Copy the pipe name
        //
        RtlCopyUnicodeString(
                &(PipeEntry->PipeName),
                PipeName
                );

        PipeEntry->Previous = NULL;
        PipeEntry->Next     = NULL;

        PipeEntry->ReferenceCount = 0;

        //
        //  Allocate space for the security descriptor if one
        //  is provided.
        //
        if ( pRpcSa ) {

            LengthSd = RtlLengthSecurityDescriptor(
                            pRpcSa->RpcSecurityDescriptor.lpSecurityDescriptor
                            );

            PipeEntry->SecurityDescriptor = RtlAllocateHeap(
                                                RtlProcessHeap( ), 0,
                                                LengthSd
                                                );


            if ( PipeEntry->SecurityDescriptor ) {

                //
                //  Copy the security descriptor
                //
                RtlMoveMemory (
                        PipeEntry->SecurityDescriptor,
                        pRpcSa->RpcSecurityDescriptor.lpSecurityDescriptor,
                        LengthSd
                        );

                *PipeEntryUsed = PipeEntry;

                return ERROR_SUCCESS;

            } else {

                Error = ERROR_OUTOFMEMORY;
            }

            RtlFreeHeap(
                 RtlProcessHeap( ), 0,
                 PipeEntry->PipeName.Buffer
                 );

        } else {

            PipeEntry->SecurityDescriptor = NULL;

            *PipeEntryUsed = PipeEntry;

            return ERROR_SUCCESS;
        }

    } else {

        Error = ERROR_OUTOFMEMORY;
    }


    RtlFreeHeap(
         RtlProcessHeap( ), 0,
         PipeEntry
         );

    return Error;
}



LONG
DeletePipeEntry(
    IN OUT PPIPE_ENTRY  PipeEntry
    )

/*++

Routine Description:


    Deletes a pipe entry

Arguments:

    PipeEntry   -   Supplies pointer to pipe entry

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

#if BIGDBG
    DbgPrint( "    * In DeletePipeEntry\n" );
#endif

    ASSERT( PipeEntry );
    ASSERT( PipeEntry->PipeName.Buffer );

    if ( PipeEntry->PipeName.Buffer ) {
        RtlFreeHeap(
             RtlProcessHeap( ), 0,
            PipeEntry->PipeName.Buffer
            );
    }

    if ( PipeEntry->SecurityDescriptor != NULL ) {
        RtlFreeHeap(
             RtlProcessHeap( ), 0,
             PipeEntry->SecurityDescriptor
             );
    }

    RtlFreeHeap(
         RtlProcessHeap( ), 0,
         PipeEntry
         );


#if BIGDBG
    DbgPrint( "    * Deleted PipeEntry.\n" );
#endif

    return ERROR_SUCCESS;
}




LONG
AddPipe(
    IN  PUNICODE_STRING          PipeName,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSa     OPTIONAL,
    OUT PPIPE_ENTRY              *PipeEntryUsed
    )

/*++

Routine Description:

    Adds a new entry to the pipe symbol table

Arguments:

    PipeName    -   Supplies the pipe name

    pRpcSa      -   Supplies the optional security attributes for the pipe

    PipeEntry   -   Supplies pointer to pointer to pipe entry in the
                    symbol table.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    PPIPE_ENTRY PipeEntry;
    LONG        Error;


    //
    //  Look for the pipe name in the symbol table
    //
    Error  = LookForPipeEntryInSymbolTable( PipeName, &PipeEntry );

    if ( Error == ERROR_SUCCESS ) {

        //
        //  If the pipe is not in the symbol table, add it
        //
        if ( !PipeEntry ) {

            //
            //  Create a new pipe entry
            //
            Error = CreatePipeEntry(
                        PipeName,
                        pRpcSa,
                        &PipeEntry
                        );

            if ( Error == ERROR_SUCCESS ) {

                //
                //  Add the entry to the symbol table
                //
                Error = AddPipeEntryToSymbolTable(
                            PipeEntry
                            );

                if ( Error != ERROR_SUCCESS ) {

                    //
                    //  Could not add pipe entry, delete it.
                    //
                    DeletePipeEntry( PipeEntry );
                    PipeEntry = NULL;
                }
            }
        }

        //
        //  If got a pipe entry, increment its reference count
        //
        if ( PipeEntry ) {

            PipeEntry->ReferenceCount++;
            *PipeEntryUsed = PipeEntry;
        }
    }

#if BIGDBG
        DbgPrint( "Added Pipe %Z:\n", PipeName );
        DumpPipeTable();
#endif

    return Error;
}




LONG
RemovePipe(
    IN OUT PPIPE_ENTRY  PipeEntry
    )

/*++

Routine Description:

    Decrements the reference count of a pipe entry and removes the
    entry if the reference count reaches zero.

Arguments:

    PipeEntry   -   Supplies pointer to pipe entry in the symbol table

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{

    LONG        Error = ERROR_SUCCESS;
    PPIPE_ENTRY Entry = PipeEntry;

    ASSERT( Entry );
    ASSERT( Entry->ReferenceCount > 0 );

#if BIGDBG
    DbgPrint( "    * In RemovePipe - Ref. count %d\n", Entry->ReferenceCount );
#endif

    //
    //  Decrement the reference count
    //
    Entry->ReferenceCount--;

    //
    //  If the reference count is zero, we can delete the
    //  entry
    //
    if ( Entry->ReferenceCount == 0 ) {

        //
        //  Remove the pipe entry from the symbol table
        //
        Error = RemovePipeEntryFromSymbolTable(
                    Entry
                    );

        if ( Error == ERROR_SUCCESS ) {

            //
            //  Delete the pipe entry
            //
            ASSERT( PipeEntry > (PPIPE_ENTRY)0x100 );
            Error = DeletePipeEntry( Entry );
        }
    }

#if BIGDBG
    DbgPrint( "    * Pipe Removed.\n" );
#endif

    return Error;
}



LONG
AddPipeEntryToSymbolTable(
    IN OUT  PPIPE_ENTRY PipeEntry
    )

/*++

Routine Description:


    Adds a pipe entry to the symbol table at the specified bucket.

    Entries are always added at the head of the chain.

    Calls to this function must be protected by the critical section
    of the pipe symbol table.

Arguments:

    PipeEntry   -   Supplies pointer to pipe entry

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    DWORD   Bucket;

    Bucket = HASH( &(PipeEntry->PipeName), BUCKETS_IN_SYMBOL_TABLE );

    PipeEntry->Previous = NULL;
    PipeEntry->Next     = PipeSymbolTable.Bucket[ Bucket ];

    if ( PipeSymbolTable.Bucket[ Bucket ] ) {
        (PipeSymbolTable.Bucket[ Bucket ])->Previous = PipeEntry;
    }

    PipeSymbolTable.Bucket[ Bucket ] = PipeEntry;

    return ERROR_SUCCESS;
}




LONG
RemovePipeEntryFromSymbolTable(
    IN OUT  PPIPE_ENTRY PipeEntry
    )

/*++

Routine Description:


    Removes a pipe entry from the symbol table at the specified bucket

    Calls to this function must be protected by the critical section
    of the pipe symbol table.

Arguments:

    PipeEntry   -   Supplies pointer to pipe entry

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/

{
    DWORD   Bucket;

#if BIGDBG
    DbgPrint( "    * In RemovePipeEntryFromSymbolTable\n" );
#endif

    ASSERT( PipeEntry > (PPIPE_ENTRY)0x100 );

    Bucket = HASH( &(PipeEntry->PipeName), BUCKETS_IN_SYMBOL_TABLE );

    ASSERT( PipeEntry > (PPIPE_ENTRY)0x100 );
    ASSERT( Bucket < BUCKETS_IN_SYMBOL_TABLE );

    //
    //  Remove the entry from the chain
    //
    if ( PipeEntry->Previous ) {
        (PipeEntry->Previous)->Next = PipeEntry->Next;
    }

    if ( PipeEntry->Next ) {
        (PipeEntry->Next)->Previous = PipeEntry->Previous;
    }


    //
    //  If this entry is at the head of the chain, Let the next
    //  entry be the new head.
    //
    ASSERT( PipeSymbolTable.Bucket[ Bucket ] != NULL );
    if ( PipeSymbolTable.Bucket[ Bucket ] == PipeEntry ) {
        PipeSymbolTable.Bucket[ Bucket ] = PipeEntry->Next;
    }

    PipeEntry->Next     = NULL;
    PipeEntry->Previous = NULL;

    ASSERT( PipeEntry > (PPIPE_ENTRY)0x100 );

#if BIGDBG
    DbgPrint( "    * Piped entry removed from symbol table.\n" );
#endif

    return ERROR_SUCCESS;
}




LONG
LookForPipeEntryInSymbolTable(
    IN  PUNICODE_STRING PipeName,
    OUT PPIPE_ENTRY     *PipeEntryUsed
    )
/*++

Routine Description:

    Looks for an entry corresponding to the given name in a particular
    bucket of the pipe symbol table.

    Note that this function always returns ERROR_SUCCESS. To find out
    if the pipe is in the chain or not the returned parameter has to
    be checked.

    Calls to this function must be protected by the critical section
    of the pipe symbol table.

Arguments:

    PipeName    -   Supplies the pipe name

    Bucket      -   Supplies the bucket

    PipeEntry   -   Supplies pointer to pointer to pipe entry.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/
{
    PPIPE_ENTRY  PipeEntry;
    DWORD        Bucket;

    Bucket = HASH( PipeName, BUCKETS_IN_SYMBOL_TABLE );

    //
    //  Look for the entry
    //
    for ( PipeEntry = PipeSymbolTable.Bucket[ Bucket ];
          PipeEntry && !RtlEqualUnicodeString( PipeName, &(PipeEntry->PipeName), TRUE);
          PipeEntry = PipeEntry->Next );


    *PipeEntryUsed = PipeEntry;

    return ERROR_SUCCESS;
}




DWORD
Hash(
    IN  PUNICODE_STRING  Symbol,
    IN  DWORD            Buckets
    )
/*++

Routine Description:


    Obtains a hash value for a given symbol

Arguments:


    Symbol      -   Supplies the symbol to hash

    Buckets     -   Supplies the number of buckets in the sybol table.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.


--*/
{
    DWORD   n;
    DWORD   HashValue;
    WCHAR   c;
    LPWSTR  s;

#if BIGDBG
    DbgPrint( "    * Hashing\n" );
#endif

    n         = Symbol->Length/sizeof(WCHAR);
    s         = Symbol->Buffer;
    HashValue = 0;

    while (n--) {

        c = *s++;

        HashValue = HashValue + (c << 1) + (c >> 1) + c;
    }

    return HashValue % Buckets;

}







// *****************************************************************
//
//                  Notification List Handler
//
// *****************************************************************



VOID
NotificationHandler(
    IN  PNOTIFICATION_LIST  NotificationList
    )

/*++

Routine Description:

    Handler of a Notification List.

Arguments:


    NotificationList    -   Supplies pointer to the Notification List
                            to handle.

Return Value:

    None

--*/

{

    NTSTATUS        NtStatus;
    DWORD           NumberOfEvents;
    HANDLE          Thread;
    BOOLEAN         KeepOnGoing = TRUE;
    DWORD           Index;
    LARGE_INTEGER   TimeOut;


    ASSERT( NotificationList );

    //
    //  Initially we'll wait on only one event, i.e. the
    //  "wake up" event
    //
    NumberOfEvents = 1;
    NotificationList->TimeOutCount = 0;
    NotificationList->ResetCount = FALSE;

    while ( KeepOnGoing ) {

        TimeOut.QuadPart = Int32x32To64( -10000,
                                         5000*NotificationList->TimeOutCount );

        //
        //  Wait for some event
        //
        NtStatus = NtWaitForMultipleObjects(
                        (CHAR)NumberOfEvents,
                        NotificationList->EventHandle,
                        WaitAny,
                        FALSE,
                        (NotificationList->PendingNotifications > 0) ?
                            &TimeOut : NULL
                        );

        Index = (DWORD)NtStatus;

        if ( (Index < 0) || (Index >= NumberOfEvents) ) {
            Index = 0;
        }

        ASSERT( Index < NumberOfEvents );

        NtStatus = RtlEnterCriticalSection( &NotificationCriticalSection );
        ASSERT( NT_SUCCESS( NtStatus ) );

#if BIGDBG
        DbgPrint( "WINREG: Notification handler signaled, Index %d\n", Index );
#endif

        try {

            //
            //  If an event was triggered, mark it as a pending notification so
            //  that the NotificationListMaintenance function will notify
            //  the client.
            //
            if ( Index > 0 ) {
                NotificationList->PendingNotifications++;
                NotificationList->Event[Index].Flags |= MUST_NOTIFY;
            }

            //
            //  Notify all the clients with pending notifications and
            //  remove entries for dead clients.
            //
            NumberOfEvents = NotificationListMaintenance( NotificationList );

            if( NotificationList->PendingNotifications != 0 ) {
                if( NotificationList->ResetCount ) {
                    NotificationList->TimeOutCount = 1;
                    NotificationList->ResetCount = FALSE;
                } else {
                    if( NotificationList->TimeOutCount == 0 ) {
                        NotificationList->TimeOutCount = 1;
                    } else {
                        if( NotificationList->TimeOutCount != MAX_TIMEOUT_COUNT ) {
                            NotificationList->TimeOutCount =
                                          NotificationList->TimeOutCount << 1;
                        }
                    }
                }
            } else {
                NotificationList->TimeOutCount = 0;
            }

            //
            //  If the list is empty, then try to take it out of the chain, and
            //  if successful, our job is done.
            //
            if ( NumberOfEvents == 1 ) {

#if BIGDBG
                DbgPrint( "    * Removing the notification list!\n" );
#endif
                //
                //  Make sure that the list is empty.
                //
                ASSERT( NotificationList->EventsInUse == 1 );
                if (NotificationList->EventsInUse == 1) {

                    //
                    //  The list is empty, remove the list from the chain
                    //  and delete it.
                    //
                    RemoveNotificationListFromChain( NotificationList );
                    Thread = NotificationList->HandlerThread;
                    DeleteNotificationList( NotificationList );

                    //
                    //  The list is gone, we can die.
                    //
                    KeepOnGoing = FALSE;
                }
            }

        } except ( NtStatus = GetExceptionCode() ) {

#if DBG
            DbgPrint( "WINREG Error: Exception %x in NotificationHandler\n",
                      NtStatus );
            DbgBreakPoint();
#endif

        }


#if BIGDBG
        if ( KeepOnGoing ) {
            DbgPrint( "WINREG: Notification handler waiting...\n" );
        } else {
            DbgPrint( "WINREG: Notification handler dying...\n" );
        }
#endif

        NtStatus = RtlLeaveCriticalSection( &NotificationCriticalSection );
        ASSERT( NT_SUCCESS( NtStatus ) );

    }

    //
    //  The list is gone, and so must we.
    //
    ExitThread( 0 );

    ASSERT( FALSE );

}



DWORD
NotificationListMaintenance(
    IN OUT  PNOTIFICATION_LIST  NotificationList
    )
/*++

Routine Description:

    Performs all the maintenance necessary in the notification list.
    The maintenance consists of:

    - Notifying all clients with pending notifications.

    - Removing entries in the list for dead clients.

    - Compacting the notification list.

Arguments:


    NotificationList    -   Supplies pointer to the Notification List

Return Value:

    DWORD   -   The new number of events in the list

--*/

{

    LONG                Error;
    DWORD               NumberOfEvents;
    DWORD               Index;
    BOOLEAN             Remove;
    PNOTIFICATION_ENTRY Event;
    NTSTATUS            NtStatus;
    PPIPE_ENTRY         PipeEntry;

#if BIGDBG
    DbgPrint( "    * In NotificationListMaintenance\n" );
    DumpNotificationLists();
#endif

    //
    //  Traverse the list notifying clients if necessary and removing
    //  events that are no longer needed, either because they have
    //  already been notified or because the client is dead.
    //
    for (Index = 1; Index < NotificationList->EventsInUse; Index++ ) {

#if BIGDBG
        DbgPrint( "      - %d\n", Index );
#endif
        Remove = FALSE;
        Event  = &(NotificationList->Event[ Index ]);

        if ( Event->Flags & CLIENT_IS_DEAD ) {

            //
            //  No client, must remove the entry.
            //
            Remove = TRUE;

        } else if ( Event->Flags & MUST_NOTIFY ) {

            //
            //  Must notify this client
            //
            Error = SendEventToClient(
                        Event->ClientEvent,
                        Event->PipeEntry
                        );

            if (Error == ERROR_SUCCESS) {
                //
                //  If successfully notified, remove the entry.
                //
                Remove = TRUE;
                Event->Flags &= ~NOTIFICATION_FAILED;
            } else {
                //
                //  If couldn't notify, set ResetCount if the notification
                //  failed for the first time
                //
                if( ( Event->Flags & NOTIFICATION_FAILED ) == 0 ) {
                    NotificationList->ResetCount = TRUE;
                    Event->Flags |= NOTIFICATION_FAILED;
                }
            }
        }

        //
        //  Remove the entry if no longer needed.
        //
        if ( Remove ) {

            //
            //  Remove the pipe entry
            //
            PipeEntry = Event->PipeEntry;
            RemovePipe( PipeEntry );

            Event->PipeEntry = NULL;

            //
            //  Remove the event
            //
#if BIGDBG
            DbgPrint( "        Cleanup\n" );
#endif

            NtStatus = NtClose( NotificationList->EventHandle[ Index ] );
            ASSERT( NT_SUCCESS( NtStatus ) );
            NotificationList->EventHandle[ Index ] = NULL;

            //
            //  If this was a pending notification, decrement the
            //  counter.
            //
            if ( Event->Flags & MUST_NOTIFY ) {
                NotificationList->PendingNotifications--;
            }
        }
    }


    //
    //  Compact the list.
    //
    Error = CompactNotificationList( NotificationList );

    ASSERT( Error == ERROR_SUCCESS );

    //
    //  Get the new number of entries in the list
    //
    NumberOfEvents = NotificationList->EventsInUse;

#if BIGDBG
    DbgPrint( "    * Maintenance Done (%d)\n", NumberOfEvents );
#endif

    return NumberOfEvents;
}





LONG
SendEventToClient(
    IN  DWORD           ClientEvent,
    IN  PPIPE_ENTRY     PipeEntry
    )
/*++

Routine Description:

    Sends an event to the client via the client's named pipe

Arguments:


    PipeEntry       -   Supplies the pipe entry for the client's named
                        pipe.

    ClientEvent     -   Supplies the event that has to be sent to the
                        client.

Return Value:

    LONG -  Returns ERROR_SUCCESS (0); error-code for failure.

--*/

{

    HANDLE              Handle;
    LONG                Error = ERROR_SUCCESS;
    OBJECT_ATTRIBUTES   Obja;
    NTSTATUS            NtStatus;

    ASSERT( PipeEntry != NULL );
    ASSERT( PipeEntry->PipeName.Buffer != NULL );

    //
    // Initialize the Obja structure for the named pipe
    //
    InitializeObjectAttributes(
        &Obja,
        &(PipeEntry->PipeName),
        OBJ_CASE_INSENSITIVE,
        NULL,
        PipeEntry->SecurityDescriptor
        );


    //
    // Open our side of the pipe
    //
    NtStatus = NtOpenFile(
                    &Handle,
                    GENERIC_WRITE | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_WRITE,
                    FILE_NON_DIRECTORY_FILE
                    );


    if ( NT_SUCCESS( NtStatus ) ) {

        //
        //  Write the event
        //
        NtStatus = NtWriteFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        &ClientEvent,
                        sizeof(ClientEvent),
                        NULL,
                        NULL
                        );

        if ( NtStatus == STATUS_PENDING ) {
            NtStatus = NtWaitForSingleObject(
                            Handle,
                            FALSE,
                            NULL );
        }

        if ( NT_SUCCESS( NtStatus ) ) {
#if BIGDBG
            DbgPrint( "    --> Client Notified, Event 0x%x\n", ClientEvent );
#endif
            Error = ERROR_SUCCESS;
        } else {
            Error = RtlNtStatusToDosError( NtStatus );
        }


        //
        //  Close our side of the pipe
        //
        NtStatus = NtClose( Handle );
        ASSERT( NT_SUCCESS( NtStatus ) );

    } else {

        //
        //  If we couldn't open the pipe because the pipe does
        //  not exist, there's no point in keep trying.
        //
        if ( NtStatus == STATUS_OBJECT_NAME_NOT_FOUND ) {
            Error = ERROR_SUCCESS;
        } else {
            Error = RtlNtStatusToDosError( NtStatus );
#if DBG
            DbgPrint( "WINREG: Cannot Open pipe %Z, event %x, status %x\n",
                  &(PipeEntry->PipeName), ClientEvent, NtStatus );
#endif
        }
    }

#if DBG
    if (Error != ERROR_SUCCESS ) {
        DbgPrint( "WINREG: Could not notify client, Error %d\n", Error );
    }
#endif

    return Error;
}


#if BIGDBG

// *****************************************************************
//
//                      Debug Stuff
//
// *****************************************************************


VOID
DumpNotificationLists(
    )
/*++

Routine Description:

    Dumps the notification lists

Arguments:


    None

Return Value:

    None

--*/

{
    PNOTIFICATION_LIST  NotificationList;
    PNOTIFICATION_ENTRY Event;
    DWORD               Index;

    DbgPrint( "        Notification list dump: \n\n" );

    for ( NotificationList = NotificationListChainHead;
          NotificationList;
          NotificationList = NotificationList->Next ) {

        DbgPrint( "        Notification List at 0x%x\n", NotificationList );
        DbgPrint( "        Pending notifications: %d\n", NotificationList->PendingNotifications );

        Event = &(NotificationList->Event[1]);

        for ( Index = 1; Index < NotificationList->EventsInUse; Index++ ) {

            DbgPrint( "          Event %d EventHandle 0x%x Client 0x%x",
                            Index,
                            NotificationList->EventHandle[ Index ],
                            Event->ClientEvent );

            if ( Event->Flags & CLIENT_IS_DEAD ) {
                DbgPrint( " (Dead)\n" );
            } else if ( Event->Flags & MUST_NOTIFY ) {
                DbgPrint( " (Notify)\n" );
            } else {
                DbgPrint( "\n" );
            }

            Event++;
        }

        DbgPrint( "\n");
    }

    DbgPrint( "\n");
}


VOID
DumpPipeTable(
    )
/*++

Routine Description:

    Dumps the pipe table

Arguments:


    None

Return Value:

    None

--*/

{
    DWORD       i;
    PPIPE_ENTRY Entry;

    DbgPrint( "\n\n      Pipes:\n\n" );

    for ( i=0; i < BUCKETS_IN_SYMBOL_TABLE; i++ ) {

        Entry = PipeSymbolTable.Bucket[i];
        if ( Entry ) {
            DbgPrint( "        Bucket %d:\n",i );
            while ( Entry ) {
                DbgPrint( "        %Z (%d)\n", &(Entry->PipeName), Entry->ReferenceCount );
                Entry = Entry->Next;
            }
        }
    }

    DbgPrint( "\n" );
}


#endif  // BIGDBG

#endif   // REMOTE_NOTIFICATION_DISABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regsec.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       regsec.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5-16-96   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __REGSEC_H__
#define __REGSEC_H__


BOOL
RegSecCheckRemoteAccess(
    PRPC_HKEY   phKey);

BOOL
RegSecCheckPath(
    HKEY                hKey,
    PUNICODE_STRING     pSubKey);

BOOL
InitializeRemoteSecurity(
    VOID
    );

#endif // __REGSEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regsec.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegSec.c

Abstract:

    This module contains code to apply security to the otherwise unsecured
    top level keys, in fashion that will allow existing consumers access to
    the keys that they need (print, srvmgr, etc.).


Author:

    Richard Ward (richardw) 15 May 1996

Notes:

--*/


#include <rpc.h>
#include <string.h>
#include <wchar.h>
#include "regrpc.h"
#include "localreg.h"
#include "regsec.h"

#define REGSEC_READ     1
#define REGSEC_WRITE    2


WCHAR                   RemoteRegistryKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SecurePipeServers\\winreg";
WCHAR                   AllowedPathsKey[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SecurePipeServers\\winreg\\AllowedPaths";
WCHAR                   MachineValue[] = L"Machine";
WCHAR                   UsersValue[] = L"Users";
PSECURITY_DESCRIPTOR    RemoteRegistrySD;
PUNICODE_STRING         MachineAllowedPaths;
PUCHAR                  MachineAllowedPathsBase;
ULONG                   MachineAllowedPathsCount;
PUNICODE_STRING         UsersAllowedPaths;
PUCHAR                  UsersAllowedPathsBase;
ULONG                   UsersAllowedPathsCount;
GENERIC_MAPPING         RemoteRegistryMappings;

LARGE_INTEGER           WinregChange ;
LARGE_INTEGER           AllowedPathsChange ;
RTL_RESOURCE            RegSecReloadLock ;





NTSTATUS
RegSecReadSDFromRegistry(
    IN  HANDLE  hKey,
    OUT PSECURITY_DESCRIPTOR *  pSDToUse)
/*++

Routine Description:

    This function checks the registry in the magic place to see if an extra
    ACL has been defined for the pipe being passed in.  If there is one, it
    is translated to a NP acl, then returned.  If there isn't one, or if
    something goes wrong, an NULL acl is returned.

Arguments:

    InterfaceName   name of the pipe to check for, e.g. winreg, etc.

    pSDToUse        returned a pointer to the security decriptor to use.

Return Value:

    STATUS_SUCCESS,
    STATUS_NO_MEMORY,
    Possible other errors from registry apis.


--*/
{
    NTSTATUS                Status ;
    PSECURITY_DESCRIPTOR    pSD;
    ULONG                   cbNeeded;
    ACL_SIZE_INFORMATION    AclSize;
    ULONG                   AceIndex;
    ACCESS_MASK             NewMask;
    PACCESS_ALLOWED_ACE     pAce;
    PACL                    pAcl;
    BOOLEAN                 DaclPresent;
    BOOLEAN                 DaclDefaulted;
    UNICODE_STRING          Interface;
    UNICODE_STRING          Allowed;
    ULONG                   i;
    BOOLEAN                 PipeNameOk;
    PSECURITY_DESCRIPTOR    pNewSD;
    PACL                    pNewAcl;
    PSID                    pSid;
    PSID                    pSidCopy;
    BOOLEAN                 Defaulted;
    PACL                    Acl;
    PSID                    AdminSid = NULL ;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY ;
    ULONG                   SizeOfAcl ;

    *pSDToUse = NULL;


    //
    // Son of a gun, someone has established security for this pipe.
    //

    pSD = NULL;

    cbNeeded = 0;
    Status = NtQuerySecurityObject(
                    hKey,
                    DACL_SECURITY_INFORMATION |
                        OWNER_SECURITY_INFORMATION |
                        GROUP_SECURITY_INFORMATION,
                    NULL,
                    0,
                    &cbNeeded );

    if (Status == STATUS_BUFFER_TOO_SMALL)
    {
        pSD = RtlAllocateHeap(RtlProcessHeap(), 0, cbNeeded);
        if (pSD)
        {
            Status = NtQuerySecurityObject(
                        hKey,
                        DACL_SECURITY_INFORMATION |
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION,
                        pSD,
                        cbNeeded,
                        &cbNeeded );


            if (NT_SUCCESS(Status))
            {
                //
                // Now, the tricky part.  There is no 1-1 mapping of Key
                // permissions to Pipe permissions.  So, we do it here.
                // We walk the DACL, and examine each ACE.  We build a new
                // access mask for each ACE, and set the flags as follows:
                //
                //  if (KEY_READ) GENERIC_READ
                //  if (KEY_WRITE) GENERIC_WRITE
                //

                Status = RtlGetDaclSecurityDescriptor(
                                        pSD,
                                        &DaclPresent,
                                        &pAcl,
                                        &DaclDefaulted);


                //
                // If this failed, or there is no DACL present, then
                // we're in trouble.
                //

                if (!NT_SUCCESS(Status) || !DaclPresent || !pAcl)
                {
                    goto GetSDFromKey_BadAcl;
                }


                Status = RtlQueryInformationAcl(pAcl,
                                                &AclSize,
                                                sizeof(AclSize),
                                                AclSizeInformation);

                if (!NT_SUCCESS(Status))
                {
                    goto GetSDFromKey_BadAcl;
                }

                for (AceIndex = 0; AceIndex < AclSize.AceCount ; AceIndex++ )
                {
                    NewMask = 0;
                    Status = RtlGetAce( pAcl,
                                        AceIndex,
                                        & pAce);

                    //
                    // We don't care what kind of ACE it is, since we
                    // are just mapping the access types, and the access
                    // mask is always at a constant position.
                    //

                    if (NT_SUCCESS(Status))
                    {
                        if ((pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) &&
                            (pAce->Header.AceType != ACCESS_DENIED_ACE_TYPE))
                        {
                            //
                            // Must be an audit or random ACE type.  Skip it.
                            //

                            continue;

                        }


                        if (pAce->Mask & KEY_READ)
                        {
                            NewMask |= REGSEC_READ;
                        }

                        if (pAce->Mask & KEY_WRITE)
                        {
                            NewMask |= REGSEC_WRITE;
                        }

                        pAce->Mask = NewMask;
                    }
                    else
                    {
                        //
                        // Panic:  Bad ACL?
                        //

                        goto GetSDFromKey_BadAcl;
                    }

                }

                //
                // RPC does not understand self-relative SDs, so
                // we have to turn this into an absolute for them to turn
                // back into a self relative.
                //

                pNewSD = RtlAllocateHeap(RtlProcessHeap(), 0, cbNeeded);
                if (!pNewSD)
                {
                    goto GetSDFromKey_BadAcl;
                }

                InitializeSecurityDescriptor(   pNewSD,
                                                SECURITY_DESCRIPTOR_REVISION);

                pNewAcl = (PACL) (((PUCHAR) pNewSD) +
                                    sizeof(SECURITY_DESCRIPTOR) );

                RtlCopyMemory(pNewAcl, pAcl, AclSize.AclBytesInUse);

                SetSecurityDescriptorDacl(pNewSD, TRUE, pNewAcl, FALSE);

                Status = RtlGetOwnerSecurityDescriptor( pSD, &pSid, &Defaulted );

                if ( NT_SUCCESS( Status ) )
                {
                    pSidCopy = RtlAllocateHeap( RtlProcessHeap(),
                                                0,
                                                RtlLengthSid( pSid ) );

                    if ( pSidCopy )
                    {
                        RtlCopyMemory( pSidCopy, pSid, RtlLengthSid( pSid ) );
                    }

                    RtlSetOwnerSecurityDescriptor( pNewSD, pSidCopy, FALSE );
                }

                Status = RtlGetGroupSecurityDescriptor( pSD, &pSid, &Defaulted );

                if ( NT_SUCCESS( Status ) )
                {
                    pSidCopy = RtlAllocateHeap( RtlProcessHeap(),
                                                0,
                                                RtlLengthSid( pSid ) );

                    if ( pSidCopy )
                    {
                        RtlCopyMemory( pSidCopy, pSid, RtlLengthSid( pSid ) );
                    }

                    RtlSetGroupSecurityDescriptor( pNewSD, pSidCopy, FALSE );
                }

                RtlFreeHeap(RtlProcessHeap(), 0, pSD);

                *pSDToUse = pNewSD;
                return(Status);
            }
        }
        return(STATUS_NO_MEMORY);
    }
    else
    {


GetSDFromKey_BadAcl:

        //
        // Free the SD that we have allocated
        //

        if (pSD)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, pSD);
        }

        //
        // Key exists, but there is no security descriptor, or it is unreadable
        // for whatever reason.
        //

        pSD = RtlAllocateHeap(RtlProcessHeap(), 0,
                                sizeof(SECURITY_DESCRIPTOR) );
        if (pSD)
        {
            InitializeSecurityDescriptor( pSD,
                                          SECURITY_DESCRIPTOR_REVISION );

            Status = RtlAllocateAndInitializeSid(
                        &NtAuthority,
                        2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0, 0, 0, 0, 0, 0,
                        &AdminSid );


            SizeOfAcl = sizeof( ACL ) + sizeof( ACL ) + sizeof( ACE_HEADER ) + 
                        RtlLengthRequiredSid( 2 );

            Acl = RtlAllocateHeap( RtlProcessHeap(), 0, SizeOfAcl );

            if ( NT_SUCCESS( Status ) &&
                 (Acl != NULL ))
            {
                (VOID) RtlCreateAcl(Acl, 
                                    SizeOfAcl,
                                    ACL_REVISION );

                Status = RtlAddAccessAllowedAce(
                            Acl,
                            ACL_REVISION,
                            REGSEC_READ | REGSEC_WRITE,
                            AdminSid );
                
                if ( NT_SUCCESS( Status ) )
                {
                    Status = RtlSetDaclSecurityDescriptor(
                                pSD,
                                TRUE,
                                Acl,
                                FALSE );
                    
                    if ( NT_SUCCESS( Status ) )
                    {
                        RtlFreeSid( AdminSid );

                        *pSDToUse = pSD;

                        return STATUS_SUCCESS ;
                    }

                }


            }

            if ( AdminSid )
            {
                RtlFreeSid( AdminSid );
            }

            if ( NT_SUCCESS( Status ) )
            {
                Status = STATUS_NO_MEMORY ;
            }
    

        }
        return(STATUS_NO_MEMORY);

    }

    return Status ;


}

NTSTATUS
RegSecCheckIfAclValid(
    VOID
    )
/*++

Routine Description:

    Checks if the local copy of the ACL from the registry is still valid (that is,
    no one has changed it.  If it is gone, the ACL is destroyed.

Arguments:

    None.

Returns:

    STATUS_SUCCESS if the state of the ACL is valid (whether it is present or not),
    other error    if an error occurred.

--*/

{
    HANDLE                  hKey;
    OBJECT_ATTRIBUTES       ObjAttr;
    UNICODE_STRING          UniString;
    PKEY_BASIC_INFORMATION  KeyInfo ;
    HANDLE                  Token ;
    HANDLE                  NullHandle ;
    UCHAR                   Buffer[ sizeof( KEY_BASIC_INFORMATION ) +
                                sizeof( RemoteRegistryKey ) + 16 ];
    NTSTATUS Status ;
    ULONG BufferSize ;


    RtlInitUnicodeString( &UniString, RemoteRegistryKey );

    InitializeObjectAttributes( &ObjAttr,
                                &UniString,
                                OBJ_CASE_INSENSITIVE,
                                NULL, NULL);

    //
    // Open the thread token.  If we're in the middle of an RPC call, we won't be
    // able to open the key (necessarily).  So, revert to local system in order to
    // open successfully.

    Status = NtOpenThreadToken( NtCurrentThread(),
                                MAXIMUM_ALLOWED,
                                TRUE,
                                &Token );

    if ( ( Status == STATUS_NO_IMPERSONATION_TOKEN ) ||
         ( Status == STATUS_NO_TOKEN ) )
    {
        Token = NULL ;
    }
    else if ( Status == STATUS_SUCCESS )
    {
        NullHandle = NULL ;

        Status = NtSetInformationThread( NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID) &NullHandle,
                                (ULONG) sizeof( NullHandle ) );


    }
    else
    {
        return Status ;
    }


    Status = NtOpenKey( &hKey,
                        KEY_READ,
                        &ObjAttr);

    if ( Token )
    {
        NTSTATUS RestoreStatus;

        RestoreStatus = NtSetInformationThread( NtCurrentThread(),
                                                ThreadImpersonationToken,
                                                (PVOID) &Token,
                                                sizeof( NullHandle ) );

        NtClose( Token );

        if ( !NT_SUCCESS( RestoreStatus ) )
        {
            Status = RestoreStatus ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        if ( ( Status == STATUS_OBJECT_PATH_NOT_FOUND ) ||
             ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) )
        {
            //
            // The key is not present.  Either, the key has never been present,
            // in which case we're essentially done, or the key has been deleted.
            // If the key is deleted, we need to get rid of the remote acl.
            //

            if ( WinregChange.QuadPart )
            {
                //
                // Ok, the key has been deleted.  Get the exclusive lock and get to work.
                //

                RtlAcquireResourceExclusive( &RegSecReloadLock, TRUE );

                //
                // Make sure no one else got through and deleted it already:
                //

                if ( WinregChange.QuadPart )
                {

                    RtlFreeHeap( RtlProcessHeap(), 0, RemoteRegistrySD );

                    RemoteRegistrySD = NULL ;

                    WinregChange.QuadPart = 0 ;

                }

                RtlReleaseResource( &RegSecReloadLock );

            }

            Status = STATUS_SUCCESS ;
        }

        return Status ;
    }

    Status = NtQueryKey( hKey,
                         KeyBasicInformation,
                         Buffer,
                         sizeof( Buffer ),
                         & BufferSize );

    if ( !NT_SUCCESS( Status ) )
    {

        NtClose( hKey );

        return Status ;
    }

    KeyInfo = (PKEY_BASIC_INFORMATION) Buffer ;

    //
    // See if it has changed
    //

    if ( KeyInfo->LastWriteTime.QuadPart > WinregChange.QuadPart )
    {
        RtlAcquireResourceExclusive( &RegSecReloadLock, TRUE );

        //
        // Since the last check was not safe, try again.  Another thread
        // may have updated things already.
        //

        if ( KeyInfo->LastWriteTime.QuadPart > WinregChange.QuadPart )
        {

            //
            // Ok, this one is out of date.  If there is already an SD
            // allocated, free it.  We can do that, since every other thread
            // either is waiting for a shared access, or has also noticed that
            // it is out of date, and waiting for exclusive access.
            //

            if ( RemoteRegistrySD )
            {
                RtlFreeHeap( RtlProcessHeap(), 0, RemoteRegistrySD );

                RemoteRegistrySD = NULL ;
            }

            Status = RegSecReadSDFromRegistry( hKey, &RemoteRegistrySD );

            if ( NT_SUCCESS( Status ) )
            {
                WinregChange.QuadPart = KeyInfo->LastWriteTime.QuadPart ;
            }
        }

        RtlReleaseResource( &RegSecReloadLock );
    }

    NtClose( hKey );

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSecReadAllowedPath
//
//  Synopsis:   Pull the Allowed paths out of the registry, and set up a
//              table for searching later.  This is a flat list, since the
//              number of elements by default is 2, and shouldn't grow much
//              bigger.
//
//  Arguments:  [hKey]      --
//              [Value]     --
//              [List]      --
//              [ListBase]  --
//              [ListCount] --
//
//  History:    5-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
RegSecReadAllowedPath(
    HANDLE              hKey,
    PWSTR               Value,
    PUNICODE_STRING *   List,
    PUCHAR *            ListBase,
    PULONG              ListCount)
{
    NTSTATUS                Status;
    UNICODE_STRING          UniString;
    PKEY_VALUE_PARTIAL_INFORMATION  pValue;
    ULONG                   Size;
    PWSTR                   Scan;
    ULONG                   StringCount;
    PUNICODE_STRING         Paths;

    //
    // Read the value size:
    //

    RtlInitUnicodeString( &UniString, Value );

    Status = NtQueryValueKey(   hKey,
                                &UniString,
                                KeyValuePartialInformation,
                                NULL,
                                0,
                                &Size );

    if ( !NT_SUCCESS( Status ) && (Status != STATUS_BUFFER_TOO_SMALL))
    {
        if ( (Status == STATUS_OBJECT_PATH_NOT_FOUND) ||
             (Status == STATUS_OBJECT_NAME_NOT_FOUND) )
        {
            return( TRUE );
        }

        return FALSE ;
    }

    //
    // Allocate enough:
    //

    pValue = RtlAllocateHeap( RtlProcessHeap(), 0, Size );

    if ( pValue )
    {
        Status = NtQueryValueKey(   hKey,
                                    &UniString,
                                    KeyValuePartialInformation,
                                    pValue,
                                    Size,
                                    &Size );
    }


    if ( !pValue )
    {
        return( FALSE );
    }


    //
    // Okay, we should have a multi-valued set of paths that we can
    // allow access to despite the access control.
    //

    if ( pValue->Type != REG_MULTI_SZ )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pValue );
        return( FALSE );
    }

    //
    // Scan list, determine how many strings:
    //

    Scan = (PWSTR) pValue->Data;

    StringCount = 0;

    while ( *Scan )
    {
        while ( *Scan )
        {
            Scan ++;
        }

        StringCount ++;

        Scan ++;
    }

    //
    // Allocate enough UNICODE_STRING structs to point to each string
    //

    Paths = RtlAllocateHeap( RtlProcessHeap(), 0,
                                        StringCount * sizeof(UNICODE_STRING) );

    if ( !Paths )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pValue );
        return( FALSE );
    }

    Scan = ( PWSTR ) pValue->Data;

    *ListCount = StringCount;

    StringCount = 0;

    //
    // Set up one UNICODE_STRING per string in the multi_sz,
    //

    while ( *Scan )
    {
        RtlInitUnicodeString( &Paths[ StringCount ],
                              Scan );

        while ( *Scan)
        {
            Scan ++;
        }

        StringCount ++;

        Scan ++;
    }

    //
    // And pass the list back.
    //

    *ListBase = (PUCHAR) pValue;
    *List = Paths;

    return( TRUE );

}

//+---------------------------------------------------------------------------
//
//  Function:   RegSecReadAllowedPaths
//
//  Synopsis:   Reads the allowed paths out of the registry
//
//  Arguments:  (none)
//
//  History:    5-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
RegSecCheckAllowedPaths(
    VOID
    )
{
    HANDLE                  hKey;
    OBJECT_ATTRIBUTES       ObjAttr;
    UNICODE_STRING          UniString;
    NTSTATUS                Status;
    HANDLE                  Token ;
    HANDLE                  NullHandle ;
    PKEY_BASIC_INFORMATION  KeyInfo ;
    UCHAR                   Buffer[ sizeof( KEY_BASIC_INFORMATION ) +
                                sizeof( AllowedPathsKey ) + 16 ];
    ULONG                   BufferSize ;

    RtlInitUnicodeString(&UniString, AllowedPathsKey);

    InitializeObjectAttributes( &ObjAttr,
                                &UniString,
                                OBJ_CASE_INSENSITIVE,
                                NULL, NULL);

    //
    // Open the thread token.  If we're in the middle of an RPC call, we won't be
    // able to open the key (necessarily).  So, revert to local system in order to
    // open successfully.

    Status = NtOpenThreadToken( NtCurrentThread(),
                                MAXIMUM_ALLOWED,
                                TRUE,
                                &Token );

    if ( ( Status == STATUS_NO_IMPERSONATION_TOKEN ) ||
         ( Status == STATUS_NO_TOKEN ) )
    {
        Token = NULL ;
    }
    else if ( Status == STATUS_SUCCESS )
    {
        NullHandle = NULL ;

        Status = NtSetInformationThread( NtCurrentThread(),
                                ThreadImpersonationToken,
                                (PVOID) &NullHandle,
                                (ULONG) sizeof( NullHandle ) );


    }
    else
    {
        return Status ;
    }

    //
    // Open the key in local system context
    //

    Status = NtOpenKey( &hKey,
                        KEY_READ,
                        &ObjAttr);

    //
    // Immediately restore back to the client token.
    //

    if ( Token )
    {
        NTSTATUS RestoreStatus;

        RestoreStatus = NtSetInformationThread( NtCurrentThread(),
                                                ThreadImpersonationToken,
                                                (PVOID) &Token,
                                                sizeof( NullHandle ) );

        NtClose( Token );

        if ( !NT_SUCCESS( RestoreStatus ) )
        {
            Status = RestoreStatus ;
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        if ( ( Status == STATUS_OBJECT_PATH_NOT_FOUND ) ||
             ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) )
        {
            //
            // The key is not present.  Either, the key has never been present,
            // in which case we're essentially done, or the key has been deleted.
            // If the key is deleted, we need to get rid of the remote acl.
            //

            if ( AllowedPathsChange.QuadPart )
            {
                //
                // Ok, the key has been deleted.  Get the exclusive lock and get to work.
                //

                RtlAcquireResourceExclusive( &RegSecReloadLock, TRUE );

                //
                // Make sure no one else has freed it already:
                //

                if ( AllowedPathsChange.QuadPart )
                {
                    if ( MachineAllowedPaths )
                    {

                        RtlFreeHeap( RtlProcessHeap(), 0, MachineAllowedPaths );

                        RtlFreeHeap( RtlProcessHeap(), 0, MachineAllowedPathsBase );

                        MachineAllowedPaths = NULL ;

                        MachineAllowedPathsBase = NULL ;

                    }

                    if ( UsersAllowedPaths )
                    {
                        RtlFreeHeap( RtlProcessHeap(), 0, UsersAllowedPaths );

                        RtlFreeHeap( RtlProcessHeap(), 0, UsersAllowedPathsBase );

                        UsersAllowedPaths = NULL ;

                        UsersAllowedPathsBase = NULL ;
                    }

                    AllowedPathsChange.QuadPart = 0;

                }

                RtlReleaseResource( &RegSecReloadLock );

            }

            Status = STATUS_SUCCESS ;
        }

        return Status ;
    }

    Status = NtQueryKey( hKey,
                         KeyBasicInformation,
                         Buffer,
                         sizeof( Buffer ),
                         & BufferSize );

    if ( !NT_SUCCESS( Status ) )
    {

        NtClose( hKey );

        return Status ;
    }

    KeyInfo = (PKEY_BASIC_INFORMATION) Buffer ;

    //
    // See if it has changed
    //

    if ( KeyInfo->LastWriteTime.QuadPart > AllowedPathsChange.QuadPart )
    {
        //
        // Well, it changed.  So, we need to flush out the old (familiar?) stuff,
        // and reload with the new stuff.  So, back to the synchronization games.
        //

        RtlAcquireResourceExclusive( &RegSecReloadLock, TRUE );

        //
        // Make sure no one else beat us to it
        //

        if ( KeyInfo->LastWriteTime.QuadPart > AllowedPathsChange.QuadPart )
        {
            if ( MachineAllowedPaths )
            {

                RtlFreeHeap( RtlProcessHeap(), 0, MachineAllowedPaths );

                RtlFreeHeap( RtlProcessHeap(), 0, MachineAllowedPathsBase );

                MachineAllowedPaths = NULL ;

                MachineAllowedPathsBase = NULL ;

            }

            if ( UsersAllowedPaths )
            {
                RtlFreeHeap( RtlProcessHeap(), 0, UsersAllowedPaths );

                RtlFreeHeap( RtlProcessHeap(), 0, UsersAllowedPathsBase );

                UsersAllowedPaths = NULL ;

                UsersAllowedPathsBase = NULL ;
            }

            //
            // Read in the paths allowed:
            //

            RegSecReadAllowedPath(  hKey,
                                    MachineValue,
                                    &MachineAllowedPaths,
                                    &MachineAllowedPathsBase,
                                    &MachineAllowedPathsCount
                                    );

            RegSecReadAllowedPath(  hKey,
                                    UsersValue,
                                    &UsersAllowedPaths,
                                    &UsersAllowedPathsBase,
                                    &UsersAllowedPathsCount
                                    );

        }

        RtlReleaseResource( &RegSecReloadLock );
    }


    NtClose( hKey );

    return STATUS_SUCCESS ;

}


//+---------------------------------------------------------------------------
//
//  Function:   InitializeRemoteSecurity
//
//  Synopsis:   Hook to initialize our look-aside stuff
//
//  Arguments:  (none)
//
//  History:    5-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
InitializeRemoteSecurity(
    VOID
    )
{
    NTSTATUS Status ;

    try 
    {
        RtlInitializeResource( &RegSecReloadLock );
        Status = STATUS_SUCCESS ;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    RemoteRegistryMappings.GenericRead = REGSEC_READ;
    RemoteRegistryMappings.GenericWrite = REGSEC_WRITE;
    RemoteRegistryMappings.GenericExecute = REGSEC_READ;
    RemoteRegistryMappings.GenericAll = REGSEC_READ | REGSEC_WRITE;

    WinregChange.QuadPart = 0 ;
    AllowedPathsChange.QuadPart = 0 ;

    return( TRUE );
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSecCheckRemoteAccess
//
//  Synopsis:   Check remote access against the security descriptor we built
//              on the side.
//
//  Arguments:  [phKey] --
//
//  History:    5-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
RegSecCheckRemoteAccess(
    PRPC_HKEY   phKey)
{
    NTSTATUS    Status;
    ACCESS_MASK Mask;
    NTSTATUS    AccessStatus;
    HANDLE      Token;
    ULONG       Size;
    UCHAR       QuickBuffer[sizeof(PRIVILEGE_SET) + 4 * sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET  PrivSet;
    ULONG       PrivilegeSetLen;

    Status = RegSecCheckIfAclValid();

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    RtlAcquireResourceShared( &RegSecReloadLock, TRUE );

    if ( RemoteRegistrySD )
    {

        //
        // Capture the thread's token
        //

        Status = NtOpenThreadToken(
                                NtCurrentThread(),
                                MAXIMUM_ALLOWED,
                                TRUE,
                                &Token );

        if ( !NT_SUCCESS(Status) )
        {
            RtlReleaseResource( &RegSecReloadLock );

            return( FALSE );
        }

        PrivSet = (PPRIVILEGE_SET) QuickBuffer;

        PrivilegeSetLen = sizeof( QuickBuffer );

        //
        // Do the access check.
        //

        Status = NtAccessCheck( RemoteRegistrySD,
                                Token,
                                MAXIMUM_ALLOWED,
                                &RemoteRegistryMappings,
                                PrivSet,
                                &PrivilegeSetLen,
                                &Mask,
                                &AccessStatus );

        RtlReleaseResource( &RegSecReloadLock );

        (void) NtClose( Token );

        if ( NT_SUCCESS( Status ) )
        {
            if ( NT_SUCCESS( AccessStatus ) &&
                (Mask & (REGSEC_READ | REGSEC_WRITE)) )
            {
                return( TRUE );
            }

            return( FALSE );

        }
        else 
        {
            return FALSE ;
        }

    }

    RtlReleaseResource( &RegSecReloadLock );

    return( TRUE );

}


//+---------------------------------------------------------------------------
//
//  Function:   RegSecCheckPath
//
//  Synopsis:   Check a specific key path if we should ignore the current
//              ACL.
//
//  Arguments:  [hKey]    --
//              [pSubKey] --
//
//  History:    5-17-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
RegSecCheckPath(
    HKEY                hKey,
    PUNICODE_STRING     pSubKey)

{
    UNICODE_STRING  Comparator;
    UNICODE_STRING  String;
    ULONG           i;
    ULONG           Count = 0;
    PUNICODE_STRING List;
    BOOL            Success ;
    NTSTATUS        Status ;

    Status = RegSecCheckAllowedPaths();

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    if ( (pSubKey->Buffer == NULL) ||
         (pSubKey->Length == 0 ) ||
         (pSubKey->MaximumLength == 0 ) )
    {
        return FALSE ;
    }

    RtlAcquireResourceShared( &RegSecReloadLock, TRUE );

    if ( REGSEC_TEST_HANDLE( hKey, CHECK_USER_PATHS ) )
    {
        Count = UsersAllowedPathsCount;
        List = UsersAllowedPaths;
    }
    if ( REGSEC_TEST_HANDLE( hKey, CHECK_MACHINE_PATHS ) )
    {
        Count = MachineAllowedPathsCount;
        List = MachineAllowedPaths;
    }

    Success = FALSE ;

    for ( i = 0 ; i < Count ; i++ )
    {
        String = *pSubKey;

        //
        // Ah ha, RPC strings often have the NULL included in the length.
        // touch that up.
        //

        while ( (String.Length != 0) && (String.Buffer[ (String.Length / sizeof(WCHAR)) - 1] == L'\0') )
        {
            String.Length -= sizeof(WCHAR) ;
        }


        Comparator = List[ i ];

        //
        // If the Comparator is a prefix of the sub key, allow it (for spooler)
        //

        if ( String.Length > Comparator.Length )
        {
            if ( String.Buffer[ Comparator.Length / sizeof(WCHAR) ] == L'\\' )
            {
                //
                // Length-wise, it could be an ancestor
                //

                String.Length = Comparator.Length;

            }
        }

        //
        // If it matches, let it go...
        //

        if ( RtlCompareUnicodeString( &String, &Comparator, TRUE ) == 0 )
        {
            Success = TRUE ;

            break;
        }
    }

    RtlReleaseResource( &RegSecReloadLock ) ;

    return( Success );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\shutinit.c ===
#include <shutinit_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regsrkey.c ===
/*++


Copyright (c) 1992  Microsoft Corporation

Module Name:

    Regsrkey.c

Abstract:

    This module contains the save\restore key APIs, that is:

        - RegRestoreKeyW
        - RegSaveKeyW

Author:

    David J. Gilman (davegi) 23-Jan-1992

Notes:



Revision History:

    25-Mar-1992     Ramon J. San Andres (ramonsa)
                    Changed to use RPC.

--*/


#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#ifdef LOCAL
#include "tsappcmp.h"
#include "regclass.h"
#endif


error_status_t
BaseRegRestoreKey(
    IN  HKEY            hKey,
    IN  PUNICODE_STRING lpFile,
    IN  DWORD           dwFlags
    )

/*++

Routine Description:

    Restore the tree in the supplied file onto the key referenced by the
    supplied key handle. The restored tree will overwrite all of the
    contents of the supplied hKey except for its name. Pictorially, if
    the file contains:

                    A
                   / \
                  /   \
                 B     C

    and the supplied key refers to a key name X, the resultant tree would
    look like:

                    X
                   / \
                  /   \
                 B     C

Arguments:

    hKey - Supplies a handle to the key where the file is to be restored.

    lpFile - Supplies a pointer to an existing file name whose contents was
        created with RegSaveKey.

    dwFlags - Supplies an optional flag argument which can be:

                - REG_WHOLE_HIVE_VOLATILE

                    If specified this flag causes a new, volatile
                    (i.e. memory only) hive to be created. In this case
                    the hKey can only refer to a child of HKEY_USERS or
                    HKEY_LOCAL_MACHINE.

                    If not specified, hKey can refer to any key in the
                    Registry.


Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    UNICODE_STRING      FileName;
    RTL_RELATIVE_NAME   RelativeName;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    PVOID               FreeBuffer;
    BOOLEAN             ErrorFlag;
    NTSTATUS            NtStatus;
    NTSTATUS            NtStatus1;
    HANDLE              Handle;


    ASSERT( (hKey != NULL) && (lpFile != NULL) && (lpFile->Buffer != NULL));
    if ( (hKey == NULL) || (lpFile == NULL) || (lpFile->Buffer == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Remove the NULL from the Length. This was added by the client
    //  so that RPC would transmit the entire thing.
    //
    if ( lpFile->Length > 0 ) {
        lpFile->Length -= sizeof( UNICODE_NULL );
    }


    //
    // Convert the DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToNtPathName_U(
                    lpFile->Buffer,
                    &FileName,
                    NULL,
                    &RelativeName
                    );


    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if ( !ErrorFlag ) {
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Remember the buffer allocated by RtlDosPathNameToNtPathName_U.
    //
    FreeBuffer = FileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( RelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        FileName = *( PUNICODE_STRING ) &RelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        RelativeName.ContainingDirectory = NULL;
    }


    //
    // Initialize the Obja structure for the save file.
    //
    InitializeObjectAttributes(
            &Obja,
            &FileName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );


    //
    // Open the existing file.
    //
    NtStatus = NtOpenFile(
                    &Handle,
                    GENERIC_READ | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ,
                    FILE_SYNCHRONOUS_IO_NONALERT
                    );

    //
    // Free the buffer allocated by RtlDosPathNameToNtPathName_U.
    //
    RtlFreeHeap( RtlProcessHeap( ), 0, FreeBuffer );

    //
    // Check the results of the NtOpenFile.
    //
    if( NT_SUCCESS( NtStatus )) {

#ifdef LOCAL
        if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

            HKEY           hkRestoreKey;
            UNICODE_STRING EmptyString = {0, 0, NULL};

            //
            // We need to restore to to user if it exists, 
            // machine if not
            //
            NtStatus = BaseRegOpenClassKey(
                hKey,
                &EmptyString,
                0,
                MAXIMUM_ALLOWED,
                &hkRestoreKey);
            
            if (NT_SUCCESS(NtStatus)) {

                //
                // Now restore to the highest precedence key
                //
                NtStatus = NtRestoreKey( hkRestoreKey, Handle, dwFlags );

                NtClose(hkRestoreKey);
            }
        } else {
            //
            // If this isn't in hkcr, then just restore to the supplied object
            //
            NtStatus = NtRestoreKey( hKey, Handle, dwFlags );
        }

#else // LOCAL
        //
        //  Now call the NT API
        //
        NtStatus = NtRestoreKey( hKey, Handle, dwFlags );
#endif // LOCAL

        //
        // Close the file.
        //
        NtStatus1 = NtClose(Handle);
        ASSERT( NT_SUCCESS( NtStatus1 ));

    }

    RPC_REVERT_TO_SELF();

#ifdef LOCAL
    if (NT_SUCCESS(NtStatus) && !(dwFlags & REG_WHOLE_HIVE_VOLATILE) && gpfnTermsrvRestoreKey) {
        gpfnTermsrvRestoreKey(hKey, Handle, dwFlags); 
    }
#endif

    //
    // Map the result of NtRestoreKey and return.
    //
    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}



error_status_t
BaseRegSaveKey(
    IN  HKEY                     hKey,
    IN  PUNICODE_STRING          lpFile,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSecurityAttributes OPTIONAL
    )
/*++

Routine Description:

    Saves the given key to the specified file.

Arguments:

    hKey                    -   Supplies a handle to the open key.

    lpFile                  -   Supplies the name of the file to save the key to.

    pRpcSecurityAttributes  -   Supplies the security attributes of
                                the file.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.



--*/
{

    BOOLEAN             ErrorFlag;
    UNICODE_STRING      FileName;
    RTL_RELATIVE_NAME   RelativeName;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    PVOID               FreeBuffer;
    NTSTATUS            NtStatus;
    NTSTATUS            NtStatus1;
    HANDLE              Handle;

    ASSERT( (hKey != NULL) && (lpFile != NULL) && (lpFile->Buffer != NULL));
    if ( (hKey == NULL) || (lpFile == NULL) || (lpFile->Buffer == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Remove the NULL from the Length. This was added by the client
    //  so that RPC would transmit the entire thing.
    //
    if ( lpFile->Length > 0 ) {
        lpFile->Length -= sizeof( UNICODE_NULL );
    }

    //
    // Convert the DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToNtPathName_U(
                    lpFile->Buffer,
                    &FileName,
                    NULL,
                    &RelativeName
                    );

    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if( ! ErrorFlag ) {
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remember the buffer allocatted by RtlDosPathNameToNtPathName_U.
    //
    FreeBuffer = FileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( RelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        RelativeName.ContainingDirectory = NULL;
    }

    //
    // Initialize the Obja structure for the save file.
    //
    InitializeObjectAttributes(
                &Obja,
                &FileName,
                OBJ_CASE_INSENSITIVE,
                RelativeName.ContainingDirectory,
                ARGUMENT_PRESENT( pRpcSecurityAttributes )
                        ? pRpcSecurityAttributes
                                ->RpcSecurityDescriptor.lpSecurityDescriptor
                        : NULL
                );



    //
    // Create the file - fail if the file exists.
    //
    NtStatus = NtCreateFile(
                    &Handle,
                    GENERIC_WRITE | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_CREATE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                    NULL,
                    0
                    );

    //
    // Free the buffer allocated by RtlDosPathNameToNtPathName_U.
    //
    RtlFreeHeap( RtlProcessHeap( ), 0, FreeBuffer );

    //
    // Check the results of the NtCreateFile.
    //
    if ( NT_SUCCESS( NtStatus )) {

#ifdef LOCAL

        if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

            HKEY hkMachineClass;
            HKEY hkUserClass;

            NtStatus = BaseRegGetUserAndMachineClass(
                NULL,
                hKey,
                MAXIMUM_ALLOWED,
                &hkMachineClass,
                &hkUserClass);

            if (NT_SUCCESS(NtStatus)) {

                //
                // We only need to merge keys if we have
                // more than one key
                //
                if (hkMachineClass && hkUserClass) {
                
                    NtStatus = NtSaveMergedKeys(
                        hkUserClass,
                        hkMachineClass,
                        Handle);

                    //
                    // Clean up the extra handle we opened
                    //
                    if (hkUserClass != hKey) {
                        NtClose(hkUserClass);
                    } else {
                        NtClose(hkMachineClass);
                    }

                } else {
                    //
                    // If there's only one key, use the regular
                    // api
                    //
                    NtStatus = NtSaveKey( hKey, Handle );
                }
            }
        } else {
            //
            // If this isn't in hkcr, just save the regular way
            //
            NtStatus = NtSaveKey( hKey, Handle );
        }
#else // LOCAL
        NtStatus = NtSaveKey( hKey, Handle );
#endif // LOCAL

        //
        // Close the file.
        //
        NtStatus1 = NtClose( Handle );
        ASSERT( NT_SUCCESS( NtStatus1 ));

    }

    RPC_REVERT_TO_SELF();

    //
    // Map the result of NtSaveKey and return.
    //
    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}

error_status_t
BaseRegSaveKeyEx(
    IN  HKEY                     hKey,
    IN  PUNICODE_STRING          lpFile,
    IN  PRPC_SECURITY_ATTRIBUTES pRpcSecurityAttributes OPTIONAL,
    IN  DWORD                    Flags
    )
/*++

Routine Description:

    Saves the given key to the specified file.

Arguments:

    hKey                    -   Supplies a handle to the open key.

    lpFile                  -   Supplies the name of the file to save the key to.

    pRpcSecurityAttributes  -   Supplies the security attributes of
                                the file.

    Flags                   -   Specifies the format the target registry hive will
                                be saved on.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.



--*/
{

    BOOLEAN             ErrorFlag;
    UNICODE_STRING      FileName;
    RTL_RELATIVE_NAME   RelativeName;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    PVOID               FreeBuffer;
    NTSTATUS            NtStatus;
    NTSTATUS            NtStatus1;
    HANDLE              Handle;

    ASSERT( (hKey != NULL) && (lpFile != NULL) && (lpFile->Buffer != NULL));
    if ( (hKey == NULL) || (lpFile == NULL) || (lpFile->Buffer == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    RPC_IMPERSONATE_CLIENT( NULL );

    //
    //  Remove the NULL from the Length. This was added by the client
    //  so that RPC would transmit the entire thing.
    //
    if ( lpFile->Length > 0 ) {
        lpFile->Length -= sizeof( UNICODE_NULL );
    }

    //
    // Convert the DOS path name to a canonical Nt path name.
    //
    ErrorFlag = RtlDosPathNameToNtPathName_U(
                    lpFile->Buffer,
                    &FileName,
                    NULL,
                    &RelativeName
                    );

    //
    // If the name was not succesfully converted assume it was invalid.
    //
    if( ! ErrorFlag ) {
        RPC_REVERT_TO_SELF();
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Remember the buffer allocatted by RtlDosPathNameToNtPathName_U.
    //
    FreeBuffer = FileName.Buffer;

    //
    // If a relative name and directory handle will work, use those.
    //
    if ( RelativeName.RelativeName.Length ) {

        //
        // Replace the full path with the relative path.
        //
        FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;

    } else {

        //
        // Using the full path - no containing directory.
        //
        RelativeName.ContainingDirectory = NULL;
    }

    //
    // Initialize the Obja structure for the save file.
    //
    InitializeObjectAttributes(
                &Obja,
                &FileName,
                OBJ_CASE_INSENSITIVE,
                RelativeName.ContainingDirectory,
                ARGUMENT_PRESENT( pRpcSecurityAttributes )
                        ? pRpcSecurityAttributes
                                ->RpcSecurityDescriptor.lpSecurityDescriptor
                        : NULL
                );



    //
    // Create the file - fail if the file exists.
    //
    NtStatus = NtCreateFile(
                    &Handle,
                    GENERIC_WRITE | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_CREATE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                    NULL,
                    0
                    );

    //
    // Free the buffer allocated by RtlDosPathNameToNtPathName_U.
    //
    RtlFreeHeap( RtlProcessHeap( ), 0, FreeBuffer );

    //
    // Check the results of the NtCreateFile.
    //
    if ( NT_SUCCESS( NtStatus )) {

#ifdef LOCAL

        if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {
            //
            // not supported on merged hives just yet
            //
            NtStatus = STATUS_INVALID_PARAMETER;
        } else {
            //
            // If this isn't in hkcr, just save the regular way
            //
            NtStatus = NtSaveKeyEx( hKey, Handle, Flags );
        }
#else // LOCAL
        NtStatus = NtSaveKeyEx( hKey, Handle, Flags );
#endif // LOCAL

        //
        // Close the file.
        //
        NtStatus1 = NtClose( Handle );
        ASSERT( NT_SUCCESS( NtStatus1 ));

    }

    RPC_REVERT_TO_SELF();

    //
    // Map the result of NtSaveKey and return.
    //
    return (error_status_t)RtlNtStatusToDosError( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regstate.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regstate.h

Abstract:

    This file contains declarations for data structures
    needed for maintaining state for registry key objects

Author:

    Adam Edwards (adamed) 14-Nov-1997

Notes:

    This file contains declarations for an object which
    can be stored in a collection.  The collection is a linked
    list, whose most frequently accessed members are at the
    front of the list.  Thus it is optimized for situations
    in which the same object may be asked for repeatedly.

    To use this list, you should create structures which
    inherit from the base object (StateObject).  Each object
    has a key which must be specified when you create a new
    object.  The key is used in searches and removes.  The objects
    must all have disinct keys, but this is not enforced by the list --
    the caller should be sure to avoid duplicates.

    Note that the list does not allocate or free objects --
    it simply allows them to be added, removed, and searched
    for in the list.  You will need to initialize any object
    before putting it into the list with the StateObjectInit
    function.

--*/

#ifdef LOCAL

#if !defined(_REGSTATE_H_)
#define _REGSTATE_H_


//
// Data types
//

//
// StateObject
//
// This is the base type -- any object used with the list must
// inherit from this object
//
typedef struct _StateObject
{
    LIST_ENTRY Links;
    PVOID      pvKey;
} StateObject;

//
// Pointer type for a caller supplied function used to
// destroy objects (de-allocate memory, free resources, etc)
//
typedef VOID (*PFNDestroyObject) (StateObject* pObject);


//
// StateObjectList
//
// This is a linked list of StateObjects, with the most frequently accessed
// elements at the front of the list.  If the same item is
// accessed repeatedly, it is found immediately in search
// operations.  Note that the list is itself a StateObject, so
// the list type can be composed with itself.
//
typedef struct _StateObjectList 
{
    StateObject  Object;
    StateObject* pHead;
} StateObjectList;


//
// Exported prototypes
//

//
// Initializes a StateObject -- must be called before
// the object is used
//
VOID StateObjectInit(
    StateObject* pObject,
    PVOID        pvKey);


//
// Initializes a StateObjectList -- must be called before
// the list is used
//
VOID StateObjectListInit(
    StateObjectList* pList,
    PVOID            pvKey);

//
// Tells whether or not a list is empty
//
BOOL StateObjectListIsEmpty(StateObjectList* pList);

//
// Removes an object from the list
//
StateObject*  StateObjectListRemove(
    StateObjectList* pList,
    PVOID            pvKey);

//
// Finds an object in the list
//
StateObject* StateObjectListFind(
    StateObjectList* pList,
    PVOID            pvKey);

//
// Adds an object to the list
//
VOID StateObjectListAdd(
    StateObjectList* pList,
    StateObject*     pObject);

//
// Removes all objects from the list and 
// destroys them.
//
VOID StateObjectListClear(
    StateObjectList* pList,
    PFNDestroyObject pfnDestroy);
                          

#endif // _REGSTATE_H_

#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regvcls.h ===
/*++









Copyright (c) 1992  Microsoft Corporation

Module Name:

    regvcls.h

Abstract:

    This file contains declarations for data structures
    needed for enumerating values under HKEY_CLASSES_ROOT

Author:

    Adam Edwards (adamed) 14-Nov-1997

Notes:

--*/

#ifdef LOCAL

#if !defined(_REGVCLS_H_)
#define _REGVCLS_H_

#include "regecls.h"

#define DEFAULT_VALUESTATE_SUBKEY_ALLOC 1

//
// Data types
//

typedef struct _ValueLocation {
    DWORD  dwOffset;
    BOOL   fUser;
} ValueLocation;

typedef struct _ValueState {

    HKEY                            hkLogical;
    HKEY                            hkUser;
    HKEY                            hkMachine;
    DWORD                           dwCurrent;
    DWORD                           cValues;
    unsigned                        fIgnoreResetOnRetry : 1;
    unsigned                        fDelete : 1;
    ValueLocation*                  rgIndex;

} ValueState;

//
// Value enumeration methods
//

void ValStateGetPhysicalIndexFromLogical(
    ValueState* pValState,
    HKEY        hkLogicalKey,
    DWORD       dwLogicalIndex,
    PHKEY       phkPhysicalKey,
    DWORD*      pdwPhysicalIndex);

NTSTATUS ValStateSetPhysicalIndexFromLogical(
    ValueState*                     pValState,
    DWORD                           dwLogicalIndex);

void ValStateRelease(ValueState* pValState);

void ValStateReleaseValues(
    PKEY_VALUE_BASIC_INFORMATION* ppValueInfo,
    DWORD                         cMaxValues);

NTSTATUS ValStateUpdate(ValueState* pValState);

NTSTATUS ValStateInitialize( 
    ValueState** ppValState,
    HKEY         hKey);

BOOL ValStateAddValueToSortedValues(
    PKEY_VALUE_BASIC_INFORMATION* ppValueInfo,
    LONG                          lNewValue);

NTSTATUS KeyStateGetValueState(
    HKEY         hKey,
    ValueState** ppValState);

NTSTATUS BaseRegGetClassKeyValueState(
    HKEY         hKey,
    DWORD        dwLogicalIndex,
    ValueState** ppValueState);

NTSTATUS EnumerateValue(
    HKEY                            hKey,
    DWORD                           dwValue,
    PKEY_VALUE_BASIC_INFORMATION    pSuggestedBuffer,
    DWORD                           dwSuggestedBufferLength,
    PKEY_VALUE_BASIC_INFORMATION*   ppResult);

//
// Multiple value query routines
//
NTSTATUS BaseRegQueryMultipleClassKeyValues(
    HKEY     hKey,
    PRVALENT val_list,
    DWORD    num_vals,
    LPSTR    lpvalueBuf,
    LPDWORD  ldwTotsize,
    PULONG   ldwRequiredLength);

NTSTATUS BaseRegQueryAndMergeValues(
    HKEY     hkUser,
    HKEY     hkMachine,
    PRVALENT val_list,
    DWORD    num_vals,
    LPSTR    lpvalueBuf,
    LPDWORD  ldwTotsize,
    PULONG   ldwRequiredLength);

#endif // !defined(_REGVCLS_H_)
#endif LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regsval.c ===
//depot/Lab04_N/Base/screg/winreg/server/regsval.c#3 - edit change 1053 (text)
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    Regsval.c

Abstract:

    This module contains the server side implementation for the Win32
    Registry set value API.  That is:

        - BaseRegSetValue
Author:

    David J. Gilman (davegi) 27-Nov-1991

Notes:

    See the Notes in Regkey.c.

--*/

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#ifdef LOCAL
#include "tsappcmp.h"
#include "regclass.h"
#endif


error_status_t
BaseRegSetValue(
    HKEY hKey,
    PUNICODE_STRING lpValueName,
    DWORD dwType,
    LPBYTE lpData,
    DWORD cbData
    )

/*++

Routine Description:

    Set the type and value of an open key.  Changes are not committed
    until the key is flushed.  By "committed" we mean written to disk.
    Changes will be seen by subsequent queries as soon as this call
    returns.

Arguments:

    hKey - Supplies a handle to the open key.  Any of the predefined
        reserved handles or a previously opened key handle may be used for
        hKey.

    lpValueName - Supplies the name of the value to set.  If the ValueName
        is not present, it is added to the key.

    dwType - Supplies the type of information to be stored: REG_SZ, etc.

    lpData - supplies a pointer to a buffer containing the data to set for
        the value entry.

    cbData - Supplies the length (in bytes) of the information to be stored.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

Notes:

    A set may fail due to memory limits - any config entry must fit in
    main memory.  If successful, RegSetValue will set the type, contents,
    and length of the information stored at the specified key.
    KEY_SET_VALUE access is required.

--*/

{
    NTSTATUS   Status;    
    HKEY  hkSet;

#ifdef LOCAL
    PVOID     PreSetData  = NULL;

    HKEY                            hkUserClasses;
    HKEY                            hkMachineClasses;

    hkUserClasses = NULL;
    hkMachineClasses = NULL;

#endif


    hkSet = hKey;

    //
    //  Subtract the NULL from the Length. This was added on the
    //  client side so that RPC would transmit it.
    //

    if ( lpValueName->Length > 0 ) {
        lpValueName->Length -= sizeof( UNICODE_NULL );
    }
    if ((hKey == HKEY_PERFORMANCE_DATA) ||
        (hKey==HKEY_PERFORMANCE_TEXT) ||
        (hKey==HKEY_PERFORMANCE_NLSTEXT)) {
        return(PerfRegSetValue(hKey,
                               lpValueName->Buffer,
                               0,
                               dwType,
                               lpData,
                               cbData));
    }

#ifdef LOCAL

    if (gpfnTermsrvSetValueKey && gpfnTermsrvGetPreSetValue ) {

        //
        // Find any pre-set values
        //
        
        Status = gpfnTermsrvGetPreSetValue( hKey,
                                            lpValueName,
                                            dwType,
                                            &PreSetData
                                            );
        
        //
        // Use the pre-set values if they exists
        //
        
        if ( NT_SUCCESS(Status) ) {
            lpData = (( PKEY_VALUE_PARTIAL_INFORMATION ) PreSetData )->Data;
            cbData = (( PKEY_VALUE_PARTIAL_INFORMATION ) PreSetData )->DataLength;
        }
        else {
            PreSetData = NULL;
        }
        
        //
        // Save the Master Copy
        //
        gpfnTermsrvSetValueKey(hKey,
                             lpValueName,
                             0,
                             dwType,
                             lpData,
                             cbData);
            
    }

    if ( PreSetData ) {

        //
        //  Set the value and free any data
        //

        Status = NtSetValueKey(
                       hKey,
                       lpValueName,
                       0,
                       dwType,
                       lpData,
                       cbData
                 );

        RtlFreeHeap( RtlProcessHeap( ), 0, PreSetData );

        return (error_status_t)RtlNtStatusToDosError( Status );
    }
    else
        //
        // No pre-set values, just do original code
        //

#endif

    //
    // Call the Nt API to set the value, map the NTSTATUS code to a
    // Win32 Registry error code and return.
    //

#ifdef LOCAL
    if (REG_CLASS_IS_SPECIAL_KEY(hKey)) {

        Status = BaseRegGetUserAndMachineClass(
            NULL,
            hkSet,
            MAXIMUM_ALLOWED,
            &hkMachineClasses,
            &hkUserClasses);

        if (!NT_SUCCESS(Status)) {
            return (error_status_t)RtlNtStatusToDosError(Status);
        }
    }

    if (hkUserClasses && hkMachineClasses) {
        hkSet = hkUserClasses;
    }
#endif

    Status = NtSetValueKey(
        hkSet,
        lpValueName,
        0,
        dwType,
        lpData,
        cbData
        );

#ifdef LOCAL

    if (hkUserClasses && hkMachineClasses) {
        if (hkUserClasses != hKey) {
            NtClose(hkUserClasses);
        } else {
            NtClose(hkMachineClasses);
        }
    }

    //if it is a HKLM\Software\Classes subkey and we get ACCDENIED try to create the
    //key in HKCU\Software\Classes and set value there
    if( (gdwRegistryExtensionFlags & TERMSRV_ENABLE_ACCESS_FLAG_MODIFICATION )  
        && STATUS_ACCESS_DENIED == Status 
        && hkSet == hkMachineClasses 
        && REG_CLASS_IS_SPECIAL_KEY(hKey) ) {
        
        Status = CreateMultipartUserClassKey( hKey, &hkSet );

        if(!NT_SUCCESS(Status)) {
            return ERROR_ACCESS_DENIED;
        }

        Status = NtSetValueKey(
                        hkSet,
                        lpValueName,
                        0,
                        dwType,
                        lpData,
                        cbData
                        );
        
        NtClose(hkSet);

        if(!NT_SUCCESS(Status)) {
            return ERROR_ACCESS_DENIED;
        }
        
    }

#endif // LOCAL

    return (error_status_t) RtlNtStatusToDosError(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regvcls.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegvCls.c

Abstract:

    This module contains helper functions for enumerating, 
    setting, and querying registry values in win32

Author:

    Adam Edwards (adamed) 06-May-1998

Key Functions:

Notes:


--*/


#ifdef LOCAL

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regclass.h"
#include "regvcls.h"
#include <malloc.h>



void ValStateGetPhysicalIndexFromLogical(
    ValueState* pValState,
    HKEY        hkLogicalKey,
    DWORD       dwLogicalIndex,
    PHKEY       phkPhysicalKey,
    DWORD*      pdwPhysicalIndex)
/*++

Routine Description:

    Retrieves a logical index for a value to a physical index

Arguments:

    pValState - value state containing values for a logical key
    hkLogicalKey - logical key we wish to index
    dwLogicalIndex - logical index to map
    phkPhysicalKey - handle to key where value is physically located
    pdwPhysicalIndex - index of value in physical key

Return Value:

    None.

Notes:

--*/
{
    //
    // If no value state is supplied, this means no merging is necessary
    // and we can return the supplied logical index as the correct
    // physical index
    //
    if (!pValState) {
        *pdwPhysicalIndex = dwLogicalIndex;
        *phkPhysicalKey = hkLogicalKey;
    } else {
        *pdwPhysicalIndex = pValState->rgIndex[dwLogicalIndex].dwOffset;
        *phkPhysicalKey = pValState->rgIndex[dwLogicalIndex].fUser ?
            pValState->hkUser :
            pValState->hkMachine;
    }
}


NTSTATUS ValStateSetPhysicalIndexFromLogical(
    ValueState*                     pValState,
    DWORD                           dwLogicalIndex)
/*++

Routine Description:

    Updates a state's mapping of logical indexes to physical indexes

Arguments:

    pValState - value state containing values for a logical key
    dwLogicalIndex - logical index used as a clue for whether
        or not we can used cached values or need to refresh the state -- 
        gives us an idea of what index the caller will be interested in 
        mapping after this call.

Return Value:

    None.

Notes:

--*/
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    //
    // If no value state is supplied, this means no merging is necessary
    // and we can return the supplied logical index as the correct
    // physical index
    //
    if (!pValState) {
        return STATUS_SUCCESS;
    }

    if (dwLogicalIndex >= pValState->cValues) {
        
        pValState->fDelete = TRUE;
        return STATUS_NO_MORE_ENTRIES;
    }

    //
    // Always reset if they try to go backward, or
    // if they skip by more than 1, or if they
    // ask for the same index twice and we're
    // not expecting it
    //
    if ((dwLogicalIndex < pValState->dwCurrent) || 
        (dwLogicalIndex > (pValState->dwCurrent + 1)) ||
        ((dwLogicalIndex == pValState->dwCurrent) && !(pValState->fIgnoreResetOnRetry))) {
    
        Status = ValStateUpdate(pValState);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        pValState->fIgnoreResetOnRetry = FALSE;
    }

    return Status;
}


void ValStateRelease(
    ValueState* pValState)
/*++

Routine Description:

    Frees resources (handles, memory) associated with a value state

Arguments:

    pValState - value state containing values for a logical key

Return Value:

    None.

Notes:

--*/
{
    if (!pValState) {
        return; 
    }

    if (pValState->hkUser && (pValState->hkUser != pValState->hkLogical)) {
        NtClose(pValState->hkUser);
    }

    if (pValState->hkMachine && (pValState->hkMachine != pValState->hkLogical)) {
        NtClose(pValState->hkMachine);
    }

    if (pValState->rgIndex) {
        RegClassHeapFree(pValState->rgIndex);
    }

    RegClassHeapFree(pValState);
}


NTSTATUS ValStateUpdate(ValueState* pValState)
/*++

Routine Description:

    Updates the value state to reflect the current state
        of the logical key's physical state -- it retrieves
        the names of the values for the logical key from
        the kernel, and re-indexes the table to properly
        merge user and machine state

Arguments:

    pValState - value state containing values for a logical key

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

--*/
{
    NTSTATUS             Status;
    DWORD                cUserValues;
    DWORD                cMachineValues;
    DWORD                cMaxValues;
    DWORD                cbMaxNameLen;
    DWORD                cbMaxDataLen;
    DWORD                cbBufferLen;
    ValueLocation*       rgIndex;
    PKEY_VALUE_BASIC_INFORMATION* ppValueInfo;

    //
    // Init locals
    //
    cUserValues = 0;
    cMachineValues = 0;
    cbMaxNameLen = 0;
    rgIndex = NULL;

    pValState->cValues = 0;

    //
    // Get information about this value
    //
    Status = GetFixedKeyInfo(
        pValState->hkUser,
        pValState->hkMachine,
        &cUserValues,
        &cMachineValues,
        NULL,
        NULL,
        &cbMaxNameLen);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    cMaxValues = cUserValues + cMachineValues;

    //
    // Nothing to do if there are no Values
    //
    if (!cMaxValues) {
        return STATUS_SUCCESS;
    }

    //
    // Now allocate necessary memory
    // First get memory for index vector
    //
    rgIndex = (ValueLocation*) RegClassHeapAlloc(cMaxValues * sizeof(*rgIndex));

    if (!rgIndex) {
        return STATUS_NO_MEMORY;
    }

    //
    // Now get memory for retrieving names -- first allocate an array 
    // of pointers to values
    //
    ppValueInfo = (PKEY_VALUE_BASIC_INFORMATION*) RegClassHeapAlloc(
        sizeof(*ppValueInfo) * cMaxValues);

    if (!ppValueInfo) {

        RegClassHeapFree(rgIndex);

        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(ppValueInfo, sizeof(*ppValueInfo) * cMaxValues);

    cbBufferLen = sizeof(**ppValueInfo) + cbMaxNameLen;

    //
    // Now allocate each individual value
    //
    {
        DWORD dwValue;

        for (dwValue = 0; dwValue < cMaxValues; dwValue++) 
        {
            ppValueInfo[dwValue] = (PKEY_VALUE_BASIC_INFORMATION) RegClassHeapAlloc(
                cbBufferLen);

            if (!(ppValueInfo)[dwValue]) {
                Status = STATUS_NO_MEMORY;
                break;
            }
        }
    }

    //
    // Now fetch the values.  From this point on we are assuming success
    // and updating the index table
    // 
    {

        HKEY  hKeyPhysical;
        DWORD dwLimit;
        DWORD dwLogical;
        BOOL  fUser;

        //
        // Free the existing index table
        //
        if (pValState->rgIndex) {
            RegClassHeapFree(pValState->rgIndex);
        }

        pValState->rgIndex = rgIndex;

        dwLogical = 0;

        for( hKeyPhysical = pValState->hkUser, fUser = TRUE,
                 dwLimit = cUserValues;
             ;
             hKeyPhysical = pValState->hkMachine, fUser = FALSE,
                 dwLimit = cMachineValues)
        {
            DWORD dwPhysical;

            for (dwPhysical = 0; dwPhysical < dwLimit; dwPhysical++) 
            {
                BOOL fNewValue;

                //
                // Ask the kernel for the value
                //
                Status = EnumerateValue(
                    hKeyPhysical,
                    dwPhysical,
                    ppValueInfo[dwLogical],
                    cbBufferLen,
                    NULL);

                //
                // If we encounter an error, just keep going and try to get
                // as many values as we can
                //
                if (!NT_SUCCESS(Status)) {
                    continue;
                }

                //
                // Mark certain attributes about this value that will
                // be important later
                //
                ppValueInfo[dwLogical]->TitleIndex = dwPhysical;
                ppValueInfo[dwLogical]->Type = fUser;
                

                //
                // This will add the value to our sorted list.  Since
                // the list is sorted, it is easy to eliminated duplicates --
                // don't add duplicates -- since we add 
                // user keys first, this allows us to give user values precedence
                // over machine values of the same name.  The logical key
                // index is also incremented if a key is added.
                //
                fNewValue = ValStateAddValueToSortedValues(
                    ppValueInfo,
                    dwLogical);

                if (fNewValue) {
                    dwLogical++;
                }
            }

            //
            // Break out of this loop if we just added the user values
            // since those are the last values we add
            //
            if (!fUser) {
                break;
            }
        }

        pValState->cValues = dwLogical;
    }

    //
    // Now copy the results back to the state's index array
    //
    {

        DWORD dwLogical;

        for (dwLogical = 0; dwLogical < pValState->cValues; dwLogical++)
        {
    
            pValState->rgIndex[dwLogical].dwOffset = 
                ppValueInfo[dwLogical]->TitleIndex;
            
            pValState->rgIndex[dwLogical].fUser =
                ppValueInfo[dwLogical]->Type;
        }
    }

    //
    // Release this
    //
    ValStateReleaseValues(
        ppValueInfo,
        cMaxValues);

    return STATUS_SUCCESS;
}


void ValStateReleaseValues(
    PKEY_VALUE_BASIC_INFORMATION* ppValueInfo,
    DWORD                         cMaxValues)
/*++

Routine Description:

    Releases resources associated with the values stored
        in the value state.

Arguments:

    pValState - value state containing values for a logical key

Return Value:

    None.

Notes:

--*/
{
    DWORD dwValue;

    //
    // First, free each individual value
    //
    for (dwValue = 0; dwValue < cMaxValues; dwValue++) 
    {
        //
        // Free memory for this value
        //
        if (ppValueInfo[dwValue]) {
            RegClassHeapFree(ppValueInfo[dwValue]);
        }
    }
    
    //
    // Now free the array that held all the values
    //
    RegClassHeapFree(ppValueInfo);
}



NTSTATUS ValStateInitialize( 
    ValueState** ppValState,
    HKEY         hKey)
/*++

Routine Description:

    Initializes a value state 

Arguments:

    pValState - value state containing values for a logical key
    hKey - logical key whose state this value state will represent

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

--*/
{
    NTSTATUS    Status;
    ValueState* pValState;
    HKEY        hkUser;
    HKEY        hkMachine;

    //
    // Initialize conditionally freed resources
    //
    hkUser = NULL;
    hkMachine = NULL;

    pValState = NULL;

    //
    // Get the user and machine keys
    //
    Status = BaseRegGetUserAndMachineClass(
        NULL,
        hKey,
        MAXIMUM_ALLOWED,
        &hkMachine,
        &hkUser);

    if (NT_SUCCESS(Status)) {

        ASSERT(hkUser || hkMachine);

        //
        // We only need to create a state if there are
        // two keys -- if only one exists, we don't
        // need to do merging
        //
        if (!hkUser || !hkMachine) {
            *ppValState = NULL;
            
            return STATUS_SUCCESS;
        }

        //
        // Get memory for the value state
        //
        pValState = RegClassHeapAlloc( sizeof(*pValState) + 
                                   sizeof(DWORD) * DEFAULT_VALUESTATE_SUBKEY_ALLOC );

        //
        // Be sure to release acquired resources on failure
        //
        if (!pValState) {

            if (hkUser != hKey) {
                NtClose(hkUser);
            } else {
                NtClose(hkMachine);
            }

            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory(pValState, sizeof(*pValState));

        pValState->hkUser = hkUser;
        pValState->hkMachine = hkMachine;
        pValState->hkLogical = hKey;
        pValState->fIgnoreResetOnRetry = TRUE;

        //
        // Now update the state to reflect the current registry
        //
        Status = ValStateUpdate(pValState);
    } 

    //
    // On success, set our out param
    //
    if (NT_SUCCESS(Status)) {
        *ppValState = pValState;
    } else {

        if (pValState) {
            ValStateRelease(pValState);
        }
    }

    return Status;

}


BOOL ValStateAddValueToSortedValues(
    PKEY_VALUE_BASIC_INFORMATION* ppValueInfo,
    LONG                          lNewValue)
/*++

Routine Description:

    Inserts a retrieved value into the sorted list
        of values in a value state

Arguments:

    pValState - value state containing values for a logical key
    lNewValue - index of newly added value in the sorted list --
        this value needs to be moved elsewhere in the list to maintain
        the sorted nature of the list

Return Value:

    TRUE if the state was added, FALSE if not.

Notes:

--*/
{
    PKEY_VALUE_BASIC_INFORMATION pNewValue;
    LONG                         lFinalSpot;
    LONG                         lCurrent;
    UNICODE_STRING               NewKeyName;

    lFinalSpot = 0;

    pNewValue = ppValueInfo[lNewValue];
            
    NewKeyName.Buffer = pNewValue->Name;
    NewKeyName.Length = (USHORT) pNewValue->NameLength;

    for (lCurrent = lNewValue - 1; lCurrent >= 0; lCurrent--) 
    {
        UNICODE_STRING               CurrentValueName;
        PKEY_VALUE_BASIC_INFORMATION pCurrentValue;
        LONG                         lCompareResult;

        pCurrentValue = ppValueInfo[lCurrent];

        CurrentValueName.Buffer = pCurrentValue->Name;
        CurrentValueName.Length = (USHORT) pCurrentValue->NameLength;

        lCompareResult = RtlCompareUnicodeString(
            &NewKeyName,
            &CurrentValueName,
            TRUE);

        if (lCompareResult < 0) {

            continue;

        } else if (0 == lCompareResult) {
            //
            // If it's a duplicate, don't add it
            //
            return FALSE;
            
        } else {

            lFinalSpot = lCurrent + 1;

            break;
        }
    }

    //
    // Now we know the final spot, add the value
    //
    
    //
    // Move everything up to make room for the new value
    //
    for (lCurrent = lNewValue - 1; lCurrent >= lFinalSpot; lCurrent--) 
    {
        //
        // Move the current value up one
        //
        ppValueInfo[lCurrent + 1] = ppValueInfo[lCurrent];
    }

    //
    // Copy the value to its final destination
    //
    ppValueInfo[lFinalSpot] = pNewValue;

    //
    // This means we've found no duplicate value
    // so we add it
    //
    return TRUE;
}


NTSTATUS KeyStateGetValueState(
    HKEY         hKey,
    ValueState** ppValState)
/*++

Routine Description:

    Gets the value state for a particular key

Arguments:

    hKey - key whose state we need to retrieve
    ppValState - out param pointing to a pointer to the
        retrieved state.

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

    ATENTION: Right now, this always creates a new state -- in the future,
    we may want to change this to be cached in a table to avoid reconstructing
    on every call.

--*/
{
    //
    // Now build the value state
    //
    return ValStateInitialize(
        ppValState,
        hKey);
}


NTSTATUS BaseRegGetClassKeyValueState(
    HKEY         hKey,
    DWORD        dwLogicalIndex,
    ValueState** ppValState)
/*++

Routine Description:

    Gets the value state for a particular key and optimizes
        it for a given index

Arguments:

    hKey - key whose state we need to retrieve
    dwLogicalIndex - hint that helps us to optimize the state for this
        index so the caller's use of the state is more efficient
    ppValState - out param pointing to a pointer to the
        retrieved state.

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

--*/
{
    NTSTATUS    Status;
    ValueState* pValState;

    //
    // First retrieve the state for this key
    // 
    Status = KeyStateGetValueState(hKey, &pValState);

    if (NT_SUCCESS(Status)) {

        //
        // Now map the logical index to a physical one
        //
        Status = ValStateSetPhysicalIndexFromLogical(pValState, dwLogicalIndex);

        if (!NT_SUCCESS(Status)) {
            ValStateRelease(pValState);
        } else {
            *ppValState = pValState;
        }

    }

    return Status;
}


NTSTATUS EnumerateValue(
    HKEY                            hKey,
    DWORD                           dwValue,
    PKEY_VALUE_BASIC_INFORMATION    pSuggestedBuffer,
    DWORD                           dwSuggestedBufferLength,
    PKEY_VALUE_BASIC_INFORMATION*   ppResult)
/*++

Routine Description:

    Retrieves a value for a physical key from the kernel

Arguments:

    hKey - physical key for which we're trying to read a value
    dwValue - physical index of value to read
    pSuggestedBuffer - basinc info buffer to use by default, may not be large enough
    dwSuggestedBufferLength - size of suggested buffer
    ppResult - pointer to result basic info -- may be allocated by this function if
        suggested buffer was insufficient, which means caller will have to free
        this if it is not the same as the suggested buffer

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

--*/
{
    NTSTATUS                        Status;
    PKEY_VALUE_BASIC_INFORMATION    pKeyValueInformation;        
    DWORD                           dwResultLength;

    pKeyValueInformation = pSuggestedBuffer;

    //
    // Query for the necessary information about the supplied value.
    //
    Status = NtEnumerateValueKey( hKey,
                                  dwValue,
                                  KeyValueBasicInformation,
                                  pKeyValueInformation,
                                  dwSuggestedBufferLength,
                                  &dwResultLength);
    //
    // A return value of STATUS_BUFFER_TOO_SMALL would mean that there
    // was not enough room for even the known (i.e. fixed length portion)
    // of the structure.
    //

    ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

    if (ppResult && (STATUS_BUFFER_OVERFLOW == Status)) {

        pKeyValueInformation = (PKEY_VALUE_BASIC_INFORMATION) RegClassHeapAlloc(
            dwResultLength);

        if (!pKeyValueInformation) {
            return STATUS_NO_MEMORY;
        }

        //
        // Query for the necessary information about the supplied value.
        //
        Status = NtEnumerateValueKey( hKey,
                                      dwValue,
                                      KeyValueBasicInformation,
                                      pKeyValueInformation,
                                      dwResultLength,
                                      &dwResultLength);

        ASSERT( Status != STATUS_BUFFER_TOO_SMALL );

        if (!NT_SUCCESS(Status)) {
            RegClassHeapFree(pKeyValueInformation);
        }
    }

    if (NT_SUCCESS(Status) && ppResult) {
        *ppResult = pKeyValueInformation;
    }

    return Status;
}


NTSTATUS BaseRegQueryMultipleClassKeyValues(
    HKEY     hKey,
    PRVALENT val_list,
    DWORD    num_vals,
    LPSTR    lpvalueBuf,
    LPDWORD  ldwTotsize,
    PULONG   ldwRequiredLength)
/*++

Routine Description:

    Gets the value state for a particular key and optimizes
        it for a given index

Arguments:

    hKey - Supplies a handle to the open key. The value entries returned
           are contained in the key pointed to by this key handle. Any of
           the predefined reserved handles or a previously opened key handle
           may be used for hKey.

    val_list - Supplies a pointer to an array of RVALENT structures, one for
           each value to be queried.

    num_vals - Supplies the size in bytes of the val_list array.

    lpValueBuf - Returns the data for each value

    ldwTotsize - Supplies the length of lpValueBuf. Returns the number of bytes
                 written into lpValueBuf. 

    ldwRequiredLength - If lpValueBuf is not large enough to
                 contain all the data, returns the size of lpValueBuf required
                 to return all the requested data.

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

--*/
{
    NTSTATUS    Status;
    HKEY        hkUser;
    HKEY        hkMachine;
    HKEY        hkQuery;

    //
    // Initialize conditionally freed resources
    //
    hkUser = NULL;
    hkMachine = NULL;

    //
    // First, get both user and machine keys
    //
    Status = BaseRegGetUserAndMachineClass(
        NULL,
        hKey,
        MAXIMUM_ALLOWED,
        &hkMachine,
        &hkUser);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // If we have both, we call a routine
    // to merge the values
    //
    if (hkMachine && hkUser) {

        Status = BaseRegQueryAndMergeValues(
            hkUser,
            hkMachine,
            val_list,
            num_vals,
            lpvalueBuf,
            ldwTotsize,
            ldwRequiredLength);

        goto cleanup;
    }

    //
    // We have only one key -- query the one with the 
    // highest precedence
    //
    hkQuery = hkUser ? hkUser : hkMachine;

    Status = NtQueryMultipleValueKey(hkQuery,
                                     (PKEY_VALUE_ENTRY)val_list,
                                     num_vals,
                                     lpvalueBuf,
                                     ldwTotsize,
                                     ldwRequiredLength);

cleanup:

    //
    // Close extra kernel object
    //
    if (hKey != hkUser) {
        NtClose(hkUser);
    } else {
        NtClose(hkMachine);
    }

    return Status;
}


NTSTATUS BaseRegQueryAndMergeValues(
    HKEY     hkUser,
    HKEY     hkMachine,
    PRVALENT val_list,
    DWORD    num_vals,
    LPSTR    lpvalueBuf,
    LPDWORD  ldwTotsize,
    PULONG   ldwRequiredLength)
/*++

Routine Description:

    Gets the value state for a particular key and optimizes
        it for a given index

Arguments:

    hkUser - user key to query for values
    hkMachine - machine key to query for values

    val_list - Supplies a pointer to an array of RVALENT structures, one for
           each value to be queried.

    num_vals - Supplies the size in bytes of the val_list array.

    lpValueBuf - Returns the data for each value

    ldwTotsize - Supplies the length of lpValueBuf. Returns the number of bytes
                 written into lpValueBuf. 

    ldwRequiredLength - If lpValueBuf is not large enough to
                 contain all the data, returns the size of lpValueBuf required
                 to return all the requested data.

Return Value:

    STATUS_SUCCESS for success, error code otherwise.

Notes:

    ATTENTION: this is non-atomic, unlike the regular RegQueryMultipleValues
    call.  In the future, implementing this in the kernel would make this
    atomic again. 

--*/
{
    NTSTATUS Status;
    DWORD    dwVal;
    BOOL     fOverflow;
    DWORD    dwBufferLength;
    DWORD    dwRequired;
    DWORD    dwKeyInfoLength;
    DWORD    dwBufferUsed;

    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;

    //
    // Initialize locals
    //
    dwBufferLength = *ldwTotsize;
    dwRequired = 0;
    dwBufferUsed = 0;

    fOverflow = FALSE;

    //
    // Validate out params -- we assume that ldwTotsize and
    // ldwRequiredLength were given to us by winreg client,
    // so they should be safe to read / write from. lpValueBuf
    // comes from the caller of the win32 api, so we need to
    // validate it -- in previous versions of NT, this parameter
    // went straight to the kernel, which did the validation and
    // returned an error if it was pointing to inaccessible memory.
    // Since we're accessing it here in user mode, we need to do 
    // our own validation
    //
    if (IsBadWritePtr( lpvalueBuf, dwBufferLength)) 
    {
        return STATUS_ACCESS_VIOLATION;
    }
        
    //
    // First, we need to allocate enough memory to retrieve
    // all the values -- we can't just use lpvalueBuf 
    // because it doesn't include the overhead of the
    // KEY_VALUE_PARTIAL_INFORMATION structure.  If we allocate
    // for the size of lpvalueBuf + the structure overhead,
    // we will always have enough for our queries.
    //
    dwKeyInfoLength = sizeof(*pKeyInfo) * num_vals + *ldwTotsize;
    
    pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
        RegClassHeapAlloc( dwKeyInfoLength);

    if (!pKeyInfo) {
        return STATUS_NO_MEMORY;
    }

    //
    // For each value requested by the caller, try 
    // to retrieve it from user or machine
    //
    for (dwVal = 0; dwVal < num_vals; dwVal++)
    {
        DWORD dwResultLength;
        
        //
        // Round up the used and required lengths to a ULONG boundary --
        // this means that the required size returned to the caller of the win32
        // api can be an overestimation, as much as 3 bytes per requested value.
        // We could do some work to avoid this, but since the kernel returns a rounded
        // up value in dwResultLength, the kernel api is itself overestimating, although
        // it only overestimates by at most 3 bytes over all the values.  We could avoid
        // this by allocating enough memory ahead of time to query the largest value, either
        // as one large preallocation or continually allocating and reallocating, but this will
        // be slower and / or consume more memory
        //
        dwBufferUsed = (dwBufferUsed + sizeof(ULONG)-1) & ~(sizeof(ULONG)-1);
        dwRequired = (dwRequired + sizeof(ULONG)-1) & ~(sizeof(ULONG)-1);

        //
        // Query the user key first since it has highest precedence
        //
        Status = NtQueryValueKey(
            hkUser,
            val_list[dwVal].rv_valuename,
            KeyValuePartialInformation,
            pKeyInfo,
            dwKeyInfoLength,
            &dwResultLength);

        //
        // Check for errors -- if the value didn't exist, we'll look
        // in machine -- for buffer overflow, we'll proceed as if
        // this succeeded so that we can calculate the required
        // buffer size
        //
        if (!NT_SUCCESS(Status) && 
            (STATUS_BUFFER_OVERFLOW != Status)) {
            
            if (STATUS_OBJECT_NAME_NOT_FOUND != Status) {
                goto cleanup;
            }
            
            //
            // If there is no user value, query the machine key
            //
            Status = NtQueryValueKey(
                hkMachine,
                val_list[dwVal].rv_valuename,
                KeyValuePartialInformation,
                pKeyInfo,
                dwKeyInfoLength,
                &dwResultLength);
            
            //
            // Similar error handling to above -- if we don't have enough
            // buffer, pretend we've succeeded so we can calc the required size
            //
            if (!NT_SUCCESS(Status) &&
                (STATUS_BUFFER_OVERFLOW != Status)) {
                goto cleanup;
            }
        }
        
        ASSERT(NT_SUCCESS(Status) || (STATUS_BUFFER_OVERFLOW == Status));
        
        if (NT_SUCCESS(Status)) {
            dwResultLength = pKeyInfo->DataLength;
        }
        
        //
        // Check for buffer overflow
        //
        if ( ( (dwBufferUsed + pKeyInfo->DataLength) <= dwBufferLength) && !fOverflow) {
            
            ASSERT(NT_SUCCESS(Status));
            
            //
            // Copy the data to the fixed part of the client's structure
            //
            val_list[dwVal].rv_valuelen = dwResultLength;
            val_list[dwVal].rv_valueptr = dwRequired;
            val_list[dwVal].rv_type = pKeyInfo->Type;

            //
            // We didn't overflow, so we still have enough room to copy
            // the latest value
            //
            RtlCopyMemory(
                (BYTE*)lpvalueBuf + val_list[dwVal].rv_valueptr,
                &(pKeyInfo->Data),
                dwResultLength);
            
            dwBufferUsed += pKeyInfo->DataLength;
            
        } else {
            //
            // We're out of buffer -- set this flag to
            // signal this state
            //
            fOverflow = TRUE;            
        }
        
        //
        // Update our required length with the size
        // of the data from the current value
        //
        dwRequired += dwResultLength;
    }

    //
    // At this point, we've succeeded in the sense that
    // we've copied all the data or we couldn't due to
    // insufficient buffer but we were able to calculate
    // the required size
    //
    Status = STATUS_SUCCESS;

cleanup:

    //
    // Free the allocated memory
    // 
    RegClassHeapFree(pKeyInfo);

    //
    // If we succeeded, this means we've either copied
    // the data or overflowed and copied the size -- handle
    // both below
    //
    if (NT_SUCCESS(Status)) {

        //
        // Always set this so the caller knows how much
        // was copied or needs to be allocated
        //
        *ldwRequiredLength = dwRequired;
        
        //
        // Return the appropriate error if we overflowed
        //
        if (fOverflow) {
            return STATUS_BUFFER_OVERFLOW;
        }

        //
        // Setting this, although winreg client actually
        // ignores this quantity
        //
        *ldwTotsize = dwBufferUsed;
    }

    return Status;
}

#endif LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\regstate.c ===
/*++



Copyright (c) 1991  Microsoft Corporation

Module Name:

    RegState.c

Abstract:

    This module contains helper functions for maintaining
    user mode state for registry objects

Author:

    Adam Edwards (adamed) 06-May-1998

Key Functions:

StateObjectInit

StateObjectListInit
StateObjectListIsEmpty
StateObjectListRemove
StateObjectListFind
StateObjectListAdd
StateObjectListClear

Notes:

    The StateObjectList stores the most frequently accessed
    objects at the head of the list for quick retrieval.  All
    objects in the list must inherit from StateObject, and must
    be distinguishable by a unique 32-bit key.  Duplicate
    objects are not supported, so the client must take care
    not to store duplicates (two objects with the same key) in
    the list.

--*/



#ifdef LOCAL

#include <rpc.h>
#include "regrpc.h"
#include "localreg.h"
#include "regstate.h"
#include <malloc.h>


VOID StateObjectInit(
    StateObject* pObject,
    PVOID        pvKey)
/*++
Routine Description:

    This function will initialize a StateObject.  All objects
    which inherit from this must call this function before doing
    any custom initialization.

Arguments:

    pObject -- the object to initialize.

    pvKey -- a unique key for the object used for searches and comparisons
        between objects.

Return Value:

    None -- the function does nothing which could fail.

--*/
{
    RtlZeroMemory(pObject, sizeof(*pObject));

    pObject->pvKey = pvKey;
}


VOID StateObjectListInit(
    StateObjectList* pList,
    PVOID            pvKey)
/*++
Routine Description:

    This function will initialize a StateObjectList.  All objects
    which inherit from this must call this function before doing
    any custom initialization.

Arguments:

    pList -- pointer to list to initialize.

    pvKey -- a unique key that identifies the list.  This parameter is
        necessary since the list itself is a StateObject, which requires a 
        key.  It can be set to 0 if this list will not be searched for
        as part of another list, but should be set otherwise to a unique
        value.

Return Value:

    None -- the function does nothing which could fail.

--*/
{
    StateObjectInit(
        (StateObject*) pList,
        pvKey);

    pList->pHead = NULL;
}


BOOL StateObjectListIsEmpty(StateObjectList* pList)
/*++
Routine Description:

    This function returns information on whether or not this
    list is empty.

Arguments:

    pList -- pointer to list in question

Return Value:

    TRUE if the list is empty,
    FALSE if not.

--*/
{
    return NULL == pList->pHead;
}


StateObject* StateObjectListRemove(
    StateObjectList* pList,
    PVOID            pvKey)
/*++
Routine Description:

    This function will remove an object from the list --
    it does *not* destroy the object.

Arguments:

    pList -- the list to remove the object from

    pvKey -- a unique key identifying the object to remove

Return Value:

    a pointer to the removed object if successful,
    NULL otherwise

--*/
{
    StateObject* pObject;

    //
    // First, we need to find an object with the desired key
    //

    pObject = StateObjectListFind(
        pList,
        pvKey);

    if (!pObject) {
        return NULL;
    }

    //
    // Now that we've executed the find, the object is at the front
    // of the list -- we can remove it by setting the head to the
    // next object in the list
    //
    pList->pHead = (StateObject*) (pObject->Links.Flink);

    //
    // Make sure the new head's previous pointer is NULL since it
    // has no predecessor
    //
    if (pList->pHead) {
        pList->pHead->Links.Blink  = NULL;
    }

    return pObject;
}

StateObject* StateObjectListFind(
    StateObjectList* pList,
    PVOID            pvKey)
/*++
Routine Description:

    This function will find an object in the list

Arguments:

    pList -- the list in which to search

    pvKey -- a unique key identifying the object sought

Return Value:

    a pointer to the object if an object with a key matching pvKey is found,
    NULL otherwise

--*/
{
    StateObject* pCurrent;

    //
    // Loop through all objects in the list until we get to the end
    //
    for (pCurrent = pList->pHead;
         pCurrent != NULL;
         pCurrent = (StateObject*) pCurrent->Links.Flink)
    {
        //
        // See if this object's key matches the desired key
        //
        if (pvKey == pCurrent->pvKey) {
            
            PLIST_ENTRY pFlink;
            PLIST_ENTRY pBlink;

            //
            // If the desired object is at the front, this is a no op --
            // we don't have to move anything, just return the object
            //
            if (pCurrent == pList->pHead) {
                return pCurrent;
            }
    
            //
            // We need to move the found object to the front of the list
            //

            //
            // Remove the object from its current position
            // by severing its links
            //
            pBlink = pCurrent->Links.Blink;
            pFlink = pCurrent->Links.Flink;

            if (pBlink) {
                pBlink->Flink = pFlink;
            }

            if (pFlink) {
                pFlink->Blink = pBlink;
            }

            //
            // Re-add it to the front
            //
            StateObjectListAdd(
                pList,
                pCurrent);

            return pCurrent;
        }
    }

    //
    // We never found an object with the desired key above, so its
    // not in the list
    //
    return NULL;
}


VOID StateObjectListAdd(
    StateObjectList* pList,
    StateObject*     pObject)
/*++
Routine Description:

    This function will add an object to the list

Arguments:

    pList -- the list in which to add the object

    pObject -- pointer to an object which has been initialized
        with StateObjectInit; this object will be stored in the list.

Return Value:

    None -- this function does nothing which could fail.

Note:

    Only one object with a particular key should exist in the list.  This
    requirement is not enforced by this function or the list itself, so
    clients need to ensure that they follow this rule.

--*/
{
    //
    // Create the links between the object and what's currently 
    // at the front of the list
    //
    if (pList->pHead) {
        pObject->Links.Flink = (PLIST_ENTRY) pList->pHead;
        pList->pHead->Links.Blink = (PLIST_ENTRY) pObject;
    }

    //
    // Put the object at the front of the list
    //
    pList->pHead = pObject;
    pList->pHead->Links.Blink = NULL;
}


VOID StateObjectListClear(
    StateObjectList* pList,
    PFNDestroyObject pfnDestroy)
/*++
Routine Description:

    This function will remove and destroy all objects
        in the list.

Arguments:

    pList -- the list to clear

    pfnDestroy -- pointer to a function which will be called for
        each object in order to destroy (free resources such as memory,
        kernel objects, etc) it.

Return Value:

    None -- this function does nothing which could fail.

--*/
{
    StateObject* pCurrent;

    //
    // Keep removing objects until the list is empty
    //
    while (!StateObjectListIsEmpty(pList))
    {
        StateObject* pObject;
        
        //
        // Remove whatever's at the front of the list
        //
        pObject = StateObjectListRemove(
            pList,
            pList->pHead->pvKey);

        ASSERT(pObject);

        //
        // Destroy the removed object
        //
        pfnDestroy(pObject);
    }
}


#endif // LOCAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\shutdown.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Shutdown.c

Abstract:

    This module contains the server side implementation for the Win32 remote
    shutdown APIs, that is:

        - BaseInitiateSystemShutdown
        - BaseAbortSystemShutdown
        - BaseInitiateSystemShutdownEx

Author:

    Dragos C. Sambotin 18-May-1999

Notes:
    
    These server side APIs are just stubs RPCalling in the winlogon's shutdown
    interface. They are provided only for backward compatibility. When support 
    for older versions is dropped, these stubs can be removed.

Revision History:

--*/


#define UNICODE

#include <rpc.h>
#include "regrpc.h"
#include "shutinit.h"
#include "..\regconn\regconn.h"


ULONG
BaseInitiateSystemShutdown(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN PUNICODE_STRING lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOLEAN bForceAppsClosed,
    IN BOOLEAN bRebootAfterShutdown
    )
/*++

Routine Description:

    This routine is provided for backward compatibility. It does nothing    

Arguments:

    ServerName - Name of machine this server code is running on. (Ignored)

    lpMessage - message to display during shutdown timeout period.

    dwTimeout - number of seconds to delay before shutting down

    bForceAppsClosed - Normally applications may prevent system shutdown.
              - If this true, all applications are terminated unconditionally.

    bRebootAfterShutdown - TRUE if the system should reboot. FALSE if it should
              - be left in a shutdown state.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    DWORD Result;
    SHUTDOWN_CONTEXT ShutdownContext;
    RPC_STATUS RpcStatus ;

    //
    // If we are here, we have been called by an NT4 or Win9x machine
    // which doesn't know about the new interface
    //

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(ServerName)) {
        return ERROR_SUCCESS;
    }

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != 0 )
    {
        return RpcStatus ;
    }

    //
    // do it locally
    //
    ServerName = L"";
    ShutdownContext.dwTimeout = dwTimeout;
    ShutdownContext.bForceAppsClosed = (bForceAppsClosed != 0);
    ShutdownContext.bRebootAfterShutdown = (bRebootAfterShutdown != 0);

    //
    // delegate the call to the new interface
    //
    
    Result = BaseBindToMachineShutdownInterface(ServerName,
                                                NewShutdownCallback,
                                                lpMessage,
                                                &ShutdownContext);
    
    RevertToSelf();
    
    return Result;
}

ULONG
BaseInitiateSystemShutdownEx(
    IN PREGISTRY_SERVER_NAME ServerName,
    IN PUNICODE_STRING lpMessage OPTIONAL,
    IN DWORD dwTimeout,
    IN BOOLEAN bForceAppsClosed,
    IN BOOLEAN bRebootAfterShutdown,
    IN DWORD dwReason
    )
/*++

Routine Description:

    This routine is provided for backward compatibility. It does nothing    

Arguments:

    ServerName - Name of machine this server code is running on. (Ignored)

    lpMessage - message to display during shutdown timeout period.

    dwTimeout - number of seconds to delay before shutting down

    bForceAppsClosed - Normally applications may prevent system shutdown.
              - If this true, all applications are terminated unconditionally.

    bRebootAfterShutdown - TRUE if the system should reboot. FALSE if it should
              - be left in a shutdown state.

    dwReason    - Reason for initiating the shutdown.  This reason is logged
                        in the eventlog #6006 event.

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    DWORD Result;
    SHUTDOWN_CONTEXTEX ShutdownContext;
    RPC_STATUS RpcStatus ;

    //
    // If we are here, we have been called by an NT4 or Win9x machine
    // which doesn't know about the new interface
    //

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(ServerName)) {
        return ERROR_SUCCESS;
    }

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != 0 )
    {
        return RpcStatus ;
    }

    // do it locally
    ServerName = L"";
    ShutdownContext.dwTimeout = dwTimeout;
    ShutdownContext.bForceAppsClosed = (bForceAppsClosed != 0);
    ShutdownContext.bRebootAfterShutdown = (bRebootAfterShutdown != 0);
    ShutdownContext.dwReason = dwReason;

    //
    // delegate the call to the new interface
    //

    Result = BaseBindToMachineShutdownInterface(ServerName,
                                                NewShutdownCallbackEx,
                                                lpMessage,
                                                &ShutdownContext);

    RevertToSelf();
    
    return Result;
}

ULONG
BaseAbortSystemShutdown(
    IN PREGISTRY_SERVER_NAME ServerName
    )
/*++

Routine Description:

    This routine is provided for backward compatibility. It does nothing    

Arguments:

    ServerName - Name of machine this server code is running on. (Ignored)

Return Value:

    Returns ERROR_SUCCESS (0) for success; error-code for failure.

--*/

{
    DWORD Result;
    RPC_BINDING_HANDLE binding;
    RPC_STATUS RpcStatus ;

    //
    // If we are here, we have been called by an NT4 or Win9x machine
    // which doesn't know about the new interface
    //

    //
    // Explicitly bind to the given server.
    //
    if (!ARGUMENT_PRESENT(ServerName)) {
        return ERROR_SUCCESS;
    }

    //
    // Call the server
    //

    RpcStatus = RpcImpersonateClient( NULL );

    if ( RpcStatus != 0 )
    {
        return RpcStatus ;
    }

    // do it locally
    ServerName = L"";

    //
    // delegate the call to the new interface
    //
    Result = BaseBindToMachineShutdownInterface(ServerName,
                                                NewAbortShutdownCallback,
                                                NULL,
                                                NULL);

    RevertToSelf();
    
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\apitest\tshutdwn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Tshutwnd.c

Abstract:

    This module contains the function test for the System Shutdown APIs

Author:

    Dave Chalmers (davidc) 30-Apr-1992

Environment:

    Windows, Crt - User Mode

Notes:

    Since this is a test program it relies on assertions for error checking
    rather than a more robust mechanism.

--*/

#define MAX_STRING_LENGTH   80

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#ifdef UNICODE
#error This module was designed to be built as ansi only
#endif


VOID
main(
    INT     argc,
    PCHAR   argv[ ]
    )

{
    LPTSTR  MachineName = NULL;
    WCHAR   UnicodeMachineName[MAX_STRING_LENGTH];
    PWCHAR  pUnicodeMachineName = NULL;
    BOOL    Result;
    BOOL    Failed = FALSE;
    DWORD   Error;

    //
    // Initialize options based on the command line.
    //

    while( *++argv ) {

        MachineName = *argv;
    }

    //
    // Get the machine name in unicode
    //

    if (MachineName != NULL) {

        MultiByteToWideChar(0,
                            MachineName, -1,
                            UnicodeMachineName, sizeof(UnicodeMachineName),
                            MB_PRECOMPOSED);

        pUnicodeMachineName = UnicodeMachineName;

        printf("Machine Name(a) = <%s>\n", MachineName);
        printf("Machine Name(u) = <%ws>\n", UnicodeMachineName);

    }


    //
    // Start the test
    //

    printf("Running test again machine <%s>\n\n", MachineName);




    //
    // InitiateSystemShutdown (Ansi)
    //



    printf("Test InitiateSystemShutdown (Ansi)...");


    Result = InitiateSystemShutdownA(
                    MachineName,
                    NULL,           // No message
                    0,              // Timeout
                    FALSE,          // Force
                    FALSE           // Reboot
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }


    Result = InitiateSystemShutdownA(
                    MachineName,
                    "A shutdown message",
                    0,              // Timeout
                    FALSE,          // Force
                    FALSE           // Reboot
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }

    if (Failed) {
        return;
    }

    printf("Succeeded.\n");





    //
    // InitiateSystemShutdown (Unicode)
    //



    printf("Test InitiateSystemShutdown (Unicode)...");


    Result = InitiateSystemShutdownW(
                    pUnicodeMachineName,
                    NULL,           // No message
                    0,              // Timeout
                    FALSE,          // Force
                    FALSE           // Reboot
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }


    Result = InitiateSystemShutdownW(
                    pUnicodeMachineName,
                    L"A shutdown message",
                    0,              // Timeout
                    FALSE,          // Force
                    FALSE           // Reboot
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }

    if (Failed) {
        return;
    }

    printf("Succeeded.\n");





    //
    // AbortSystemShutdown (Ansi)
    //



    printf("Test AbortSystemShutdown (Ansi)...");


    Result = AbortSystemShutdownA(
                    MachineName
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }

    if (Failed) {
        return;
    }

    printf("Succeeded.\n");


    //
    // AbortSystemShutdown (Unicode)
    //



    printf("Test AbortSystemShutdown (Unicode)...");


    Result = AbortSystemShutdownW(
                    pUnicodeMachineName
                    );

    if (Result == FALSE) {

        Error = GetLastError();

        if (Error != ERROR_CALL_NOT_IMPLEMENTED) {

            printf("Failed.\n");
            printf("Call failed as expected but last error is incorrect\n");
            printf("LastError() returned %d, expected %d\n", Error, ERROR_CALL_NOT_IMPLEMENTED);
            Failed = TRUE;
        }

    } else {
        printf("Failed.\n");
        printf("Call succeeded, expected it to fail.\n");
        Failed = TRUE;
    }

    if (Failed) {
        return;
    }

    printf("Succeeded.\n");

    return;


    UNREFERENCED_PARAMETER(argc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\server\support.c ===
/*++


Copyright (c) 1992  Microsoft Corporation

Module Name:

    Support.c

Abstract:

    This module contains support functions for the server side of the
    Win32 Registry APIs. That is:

        - PRPC_HKEY_rundown

Author:

    David J. Gilman (davegi) 21-Mar-1992

--*/

#include <rpc.h>
#include "regrpc.h"

error_status_t
BaseRegCloseKeyInternal(
    IN OUT PHKEY phKey 
    );


VOID
RPC_HKEY_rundown (
    IN RPC_HKEY hKey
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{   LONG    Error;

    ASSERT( ((hKey == HKEY_PERFORMANCE_DATA) ||
             (hKey == HKEY_PERFORMANCE_TEXT) ||
             (hKey == HKEY_PERFORMANCE_NLSTEXT)) ||
            !IsPredefinedRegistryHandle( hKey ) );

    CleanDeadClientInfo( hKey );

    Error = BaseRegCloseKeyInternal( &hKey );

    ASSERT( Error == ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\apitest\apitest.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Apitest.c

Abstract:

    This module contains the function test for the Win32 Registry API.

Author:

    David J. Gilman (davegi) 28-Dec-1991

Environment:

    Windows, Crt - User Mode

Notes:

    This test can be compiled for Unicode by defining the compiler symbol
    UNICODE.

    Since this is a test program it relies on assertions for error checking
    rather than a more robust mechanism.

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include "crtools.h"



#define HKEY_ROOT                       HKEY_CURRENT_USER
#define SAVE_RESTORE_FILE               TEXT( "srkey.reg" )
#define KEY_PATH                        \
        TEXT( "TestUser1\\TestUser1_1\\TestUser1_2" )


#define PREDEFINED_HANDLE               HKEY_USERS
#define PREDEFINED_HANDLE_STRING        \
        TEXT( "HKEY_USERS\\.Default\\TestUser1" )


#define KEY_NAME_1                      TEXT( "TestUser1" )
#define KEY_NAME_1_TITLE_INDEX          ( 0 )
#define KEY_NAME_1_CLASS                TEXT( "Test User Class" )
#define KEY_NAME_1_CLASS_LENGTH         LENGTH( KEY_NAME_1_CLASS )

#define KEY_NAME_1_1                    TEXT( "TestUser1_1" )
#define KEY_NAME_1_1_LENGTH             LENGTH( KEY_NAME_1_1 )
#define KEY_NAME_1_1_TITLE_INDEX        ( 0 )
#define KEY_NAME_1_1_CLASS              TEXT( "Test User Class" )
#define KEY_NAME_1_1_CLASS_LENGTH       LENGTH( KEY_NAME_1_1_CLASS )

#define KEY_NAME_1_2                    TEXT( "TestUser1_2" )
#define KEY_NAME_1_2_LENGTH             LENGTH( KEY_NAME_1_2 )
#define KEY_NAME_1_2_TITLE_INDEX        (0 )
#define KEY_NAME_1_2_CLASS              TEXT( "Test User Class" )
#define KEY_NAME_1_2_CLASS_LENGTH       LENGTH( KEY_NAME_1_2_CLASS )

#define VALUE_NAME_1                    TEXT( "One" )
#define VALUE_NAME_1_LENGTH             LENGTH( VALUE_NAME_1 )
#define VALUE_NAME_1_TITLE_INDEX        0
#define VALUE_DATA_1                    "Number One"
#define VALUE_DATA_1_LENGTH             11
#define VALUE_DATA_1_TYPE               REG_SZ

#define VALUE_NAME_2                    TEXT( "Second" )
#define VALUE_NAME_2_LENGTH             LENGTH( VALUE_NAME_2 )
#define VALUE_NAME_2_TITLE_INDEX        ( 0 )
#define VALUE_DATA_2                    ( 2 )
#define VALUE_DATA_2_LENGTH             ( sizeof( VALUE_DATA_2 ))
#define VALUE_DATA_2_TYPE               REG_DWORD

#define MAX_DATA_LENGTH                 ( 32 )

//
// Root handle for apitest's nodes.
//

HKEY    RootHandle;

//
// Error and informational messages.
//

PSTR    UsageMessage =

    "Usage: apitest [-?] [-q] [\\machinename]\n";

PSTR    HelpMessage =

    "\n  where:\n"                                                          \
      "    -?           - display this message.\n"                          \
      "    -q           - quiet - suppresses all output\n"                  \
      "    machinename  - remote machine.\n";

PSTR    InvalidSwitchMessage =

    "Invalid switch - %s\n";

PSTR    InvalidMachineNameMessage =

    "Invalid machine name - %s\n";

//
// Event handle used for synchronization.
//

HANDLE  _EventHandle;
HANDLE  _EventHandle1;
HANDLE  _EventHandle2;

BOOL    Quiet;



VOID
DeleteTree(
    IN HKEY KeyHandle
    )

{
    LONG        Error;
    DWORD       Index;
    HKEY        ChildHandle;


    TSTR        KeyName[ MAX_PATH ];
    DWORD       KeyNameLength;
    TSTR        ClassName[ MAX_PATH ];
    DWORD       ClassNameLength;
    DWORD       TitleIndex;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;

    ClassNameLength = MAX_PATH;

    Error = RegQueryInfoKey(
                KeyHandle,
                ClassName,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );
    REG_API_SUCCESS( RegQueryInfoKey );

    for( Index = 0; Index < NumberOfSubKeys; Index++ ) {

        KeyNameLength = MAX_PATH;

        Error = RegEnumKey(
                    KeyHandle,
                    0,
                    // Index,
                    KeyName,
                    KeyNameLength
                    );
        REG_API_SUCCESS( RegEnumKey );

        Error = RegOpenKey(
                    KeyHandle,
                    KeyName,
                    &ChildHandle
                    );

        REG_API_SUCCESS( RegOpenKey );

        DeleteTree( ChildHandle );

        Error = RegCloseKey(
                    ChildHandle
                    );
        REG_API_SUCCESS( RegCloseKey );

        Error = RegDeleteKey(
                    KeyHandle,
                    KeyName
                    );
        REG_API_SUCCESS( RegDeleteKey );
    }
}
VOID
DeleteTestTree(
    )

{
    LONG    Error;
    HKEY    KeyHandle;

    Error = RegOpenKey(
                RootHandle,
                KEY_NAME_1,
                &KeyHandle
                );

    if( Error == ERROR_SUCCESS ) {

        DeleteTree( KeyHandle );

        Error = RegCloseKey(
                    KeyHandle
                    );
        REG_API_SUCCESS( RegCloseKey );

        Error = RegDeleteKey(
                    RootHandle,
                    KEY_NAME_1
                    );
        REG_API_SUCCESS( RegDeleteKey );
    }
}

DWORD
NotifyThread(
    LPVOID  Parameters
    )

{
    LONG        Error;
    BOOL        ErrorFlag;
    HANDLE      EventHandle;

    UNREFERENCED_PARAMETER( Parameters );

    //
    // Create the notification event.
    //

    EventHandle = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL
                    );
    ASSERT( EventHandle != NULL );

    //
    // Set-up an asynchronous notify.
    //

    Error = RegNotifyChangeKeyValue(
                RootHandle,
                FALSE,
                REG_LEGAL_CHANGE_FILTER,
                EventHandle,
                TRUE
                );
    REG_API_SUCCESS( RegNotifyChangeKeyValue );

    //
    // Release the main thread.
    //

    ErrorFlag = SetEvent( _EventHandle );
    ASSERT( ErrorFlag == TRUE );

    //
    // Wait for a notification.
    //

    Error = (LONG)WaitForSingleObject( EventHandle, (DWORD)-1 );
    ASSERT( Error == 0 );

    if( ! Quiet ) {
        printf( "First notification triggered\n" );
    }

    CloseHandle( EventHandle );

    EventHandle = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL
                    );
    ASSERT( EventHandle != NULL );

    //
    // Set-up an asynchronous notify.
    //

    Error = RegNotifyChangeKeyValue(
                RootHandle,
                FALSE,
                REG_LEGAL_CHANGE_FILTER,
                EventHandle,
                TRUE
                );
    REG_API_SUCCESS( RegNotifyChangeKeyValue );

    //
    // Release the main thread.
    //

    ErrorFlag = SetEvent( _EventHandle1 );
    ASSERT( ErrorFlag == TRUE );

    //
    // Wait for a notification.
    //

    Error = (LONG)WaitForSingleObject( EventHandle, (DWORD)-1 );
    ASSERT( Error == 0 );

    if( ! Quiet ) {
        printf( "Second notification triggered\n" );
    }

    CloseHandle( EventHandle );
    ErrorFlag = SetEvent( _EventHandle2 );
    ASSERT( ErrorFlag == TRUE );




#endif



    return ( DWORD ) TRUE;
}

VOID
main(
    INT     argc,
    PCHAR   argv[ ]
    )

{
    LONG                    Error;
    BOOL                    ErrorFlag;
    DWORD                   Index;

    PTSTR                   MachineName;

    PKEY                    Key;
    TSTR                    NameString[ MAX_PATH ];

    HANDLE                  NotifyThreadHandle;
    DWORD                   ThreadID;

    HKEY                    PredefinedHandle;
    HKEY                    Handle1;
    HKEY                    Handle1_1;
    HKEY                    Handle1_2;

    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    SECURITY_ATTRIBUTES     SecurityAttributes;

    DWORD                   Disposition;
    TSTR                    KeyName[ MAX_PATH ];
    DWORD                   KeyNameLength;
    TSTR                    ClassName[ MAX_PATH ];
    DWORD                   ClassNameLength;
    DWORD                   NumberOfSubKeys;
    DWORD                   MaxSubKeyLength;
    DWORD                   MaxClassLength;
    DWORD                   NumberOfValues;
    DWORD                   MaxValueNameLength;
    DWORD                   MaxValueDataLength;
    DWORD                   SecurityDescriptorLength;
    FILETIME                LastWriteTime;


    TSTR                    ValueName[ MAX_PATH ];
    DWORD                   ValueNameLength;

    BYTE                    Data[ MAX_DATA_LENGTH ];
    DWORD                   DataLength;

    BYTE                    Data_1[ ]   = VALUE_DATA_1;
    DWORD                   Data_2      = VALUE_DATA_2;

    DWORD                   TitleIndex;
    DWORD                   Type;


    UNREFERENCED_PARAMETER( argc );

    //
    // By default, be verbose and operate on the local machine.
    //

    Quiet       = FALSE;
    MachineName = NULL;

    //
    // Initialize options based on the command line.
    //

    while( *++argv ) {

        //
        // If the command line argument is a switch character...
        //

        if( isswitch(( *argv )[ 0 ] )) {

            switch( tolower(( *argv )[ 1 ] )) {

            //
            // Display the detailed help message and quit.
            //

            case '?':

                DisplayMessage( FALSE, UsageMessage );
                DisplayMessage( TRUE, HelpMessage );
                break;

            //
            // Quiet - no output.
            //

            case 'q':

                Quiet = TRUE;
                break;

            //
            // Display invalid switch message and quit.
            //

            default:

                DisplayMessage( FALSE, InvalidSwitchMessage, *argv );
                DisplayMessage( TRUE, UsageMessage );
            }
        } else {

            MachineName = *argv;
        }
    }

    //
    // If a machine name was passed on the command line, connect to
    // the Registry on that machine else use the local Registry.
    // In either case construct a string representation of the
    // test's main key (i.e. \\machine\HKEY_USERS\.Default\TestUser1 or
    // HKEY_USERS\.Default\TestUser1.
    //

    if( MachineName ) {

        Error = RegConnectRegistry(
                    MachineName,
                    PREDEFINED_HANDLE,
                    &PredefinedHandle
                    );

        REG_API_SUCCESS( RegConnectRegistry );

        strcpy( NameString, MachineName );
        strcat( NameString, "\\\\" );
        strcat( NameString, PREDEFINED_HANDLE_STRING );

    } else {

        PredefinedHandle = PREDEFINED_HANDLE;
        strcpy( NameString, PREDEFINED_HANDLE_STRING );
    }

    //
    // Open ".Default" key as the root for the remainder of the test.
    //

    Error = RegOpenKeyEx(
                PredefinedHandle,
                ".Default",
                REG_OPTION_RESERVED,
                MAXIMUM_ALLOWED,
                &RootHandle
                );
    REG_API_SUCCESS( RegOpenKeyEx );

    //
    // Predefined handle is no longer needed.
    //

    Error = RegCloseKey(
                PredefinedHandle
                );
    REG_API_SUCCESS( RegCloseKey );

    //
    // Delete the save / restore file (in case it exists from a previous
    // run of the test) as RegSaveKey requires a new file.
    //

    DeleteFile( SAVE_RESTORE_FILE );

    //
    // Remove any leftover keys from previous runs of this test.
    //

    DeleteTestTree( );

    //
    // Use the Win 3.1 API (which calls the Win32 API) to create a path.
    //

    Error = RegCreateKey(
                RootHandle,
                KEY_PATH,
                &Handle1
                );
    REG_API_SUCCESS( RegCreateKey );

    //
    // Close the key so the delete (DeleteTestTree) will work.
    //

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );

    //
    // Remove the path.
    //

    DeleteTestTree( );

    //
    // Create the synchronization event.
    //

    _EventHandle = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL
                    );
    ASSERT( _EventHandle != NULL );

    _EventHandle1 = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL
                    );
    ASSERT( _EventHandle1 != NULL );

    _EventHandle2 = CreateEvent(
                    NULL,
                    FALSE,
                    FALSE,
                    NULL
                    );
    ASSERT( _EventHandle2 != NULL );

    //
    // Create the notify thread.
    //

    NotifyThreadHandle = CreateThread(
                            NULL,
                            0,
                            NotifyThread,
                            NULL,
                            0,
                            &ThreadID
                            );
    ASSERT( NotifyThreadHandle != NULL );

    //
    // Wait for the notify thread to create its event.
    //

    Error = (LONG)WaitForSingleObject( _EventHandle, (DWORD)-1 );
    ASSERT( Error == 0 );

    //
    // Use Win 3.1 compatible APIs to create/close, open/close and delete
    // the key TestUser1.
    //

    Error = RegCreateKey(
                RootHandle,
                KEY_NAME_1,
                &Handle1
                );
    REG_API_SUCCESS( RegCreateKey );

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );

    //
    // Wait for the notify thread to create its event.
    //

    Error = (LONG)WaitForSingleObject( _EventHandle1, (DWORD)-1 );
    ASSERT( Error == 0 );

    Error = RegOpenKey(
                RootHandle,
                KEY_NAME_1,
                &Handle1
                );
    REG_API_SUCCESS( RegOpenKey );

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );

    Error = RegDeleteKey(
                RootHandle,
                KEY_NAME_1
                );
    REG_API_SUCCESS( RegDeleteKey );

    //
    // Use Win32 APIs to create/close, open/close and create (open) the
    // key TestUser1.
    //

    //
    // Allocate and initialize the SecurityDescriptor.
    //

    SecurityDescriptor = malloc( sizeof( SECURITY_DESCRIPTOR ));
    ASSERT( SecurityDescriptor != NULL );
    ErrorFlag = InitializeSecurityDescriptor(
                    SecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );
    ASSERT( ErrorFlag == TRUE );

    SecurityAttributes.nLength              = sizeof( SECURITY_ATTRIBUTES );
    SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
    SecurityAttributes.bInheritHandle       = FALSE;

    Error = RegCreateKeyEx(
                RootHandle,
                KEY_NAME_1,
                0,
                KEY_NAME_1_CLASS,
                REG_OPTION_RESERVED,
                KEY_ALL_ACCESS,
                &SecurityAttributes,
                &Handle1,
                &Disposition
                );
    REG_API_SUCCESS( RegCreateKeyEx );

    ASSERT( Disposition == REG_CREATED_NEW_KEY );

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );


    //
    // Wait for the notify thread to create its event.
    //

    Error = RegOpenKeyEx(
                RootHandle,
                KEY_NAME_1,
                REG_OPTION_RESERVED,
                KEY_ALL_ACCESS,
                &Handle1
                );
    REG_API_SUCCESS( RegOpenKeyEx );

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );

    Error = RegCreateKeyEx(
                RootHandle,
                KEY_NAME_1,
                0,
                KEY_NAME_1_CLASS,
                REG_OPTION_RESERVED,
                KEY_ALL_ACCESS,
                NULL,
                &Handle1,
                &Disposition
                );
    REG_API_SUCCESS( RegCreateKeyEx );

    ASSERT( Disposition == REG_OPENED_EXISTING_KEY );

    //
    // Get and set the key's SECURITY_DESCRIPTOR. Setting will trigger
    // a notification.
    //

    SecurityDescriptorLength = 0;

    //
    // Get the SECURITY_DESCRIPTOR's length.
    //

    Error = RegGetKeySecurity(
                Handle1,
                OWNER_SECURITY_INFORMATION
                | GROUP_SECURITY_INFORMATION
                | DACL_SECURITY_INFORMATION,
                SecurityDescriptor,
                &SecurityDescriptorLength
                );
    ASSERT( Error == ERROR_INSUFFICIENT_BUFFER );

    SecurityDescriptor = realloc(
                            SecurityDescriptor,
                            SecurityDescriptorLength
                            );
    ASSERT( SecurityDescriptor != NULL );
    ErrorFlag = InitializeSecurityDescriptor(
                    SecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );
    ASSERT( ErrorFlag == TRUE );

    Error = RegSetKeySecurity(
                Handle1,
                OWNER_SECURITY_INFORMATION
                | GROUP_SECURITY_INFORMATION
                | DACL_SECURITY_INFORMATION,
                SecurityDescriptor
                );
    REG_API_SUCCESS( RegSetKeySecurity );

    Error = (LONG)WaitForSingleObject( _EventHandle2, (DWORD)-1 );
    ASSERT( Error == 0 );

    //
    // Reinitialize after the realloc.
    //

    SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;

    //
    // Create two sub-keys.
    //

    Error = RegCreateKeyEx(
                Handle1,
                KEY_NAME_1_1,
                0,
                KEY_NAME_1_1_CLASS,
                REG_OPTION_RESERVED,
                KEY_ALL_ACCESS,
                &SecurityAttributes,
                &Handle1_1,
                &Disposition
                );
    REG_API_SUCCESS( RegCreateKeyEx );

    ASSERT( Disposition == REG_CREATED_NEW_KEY );

    Error = RegCreateKeyEx(
                Handle1,
                KEY_NAME_1_2,
                0,
                KEY_NAME_1_2_CLASS,
                0,
                KEY_ALL_ACCESS,
                &SecurityAttributes,
                &Handle1_2,
                &Disposition
                );
    REG_API_SUCCESS( RegCreateKeyEx );

    ASSERT( Disposition == REG_CREATED_NEW_KEY );

    //
    // Enumerate the two sub-keys using the Win 3.1 and the the Win32
    // enumeration APIs.
    //

    KeyNameLength = MAX_PATH;

    Error = RegEnumKey(
                Handle1,
                0,
                KeyName,
                KeyNameLength
                );
    REG_API_SUCCESS( RegEnumKey );

    ASSERT( Compare( KeyName, KEY_NAME_1_1, KEY_NAME_1_1_LENGTH ));

    KeyNameLength   = MAX_PATH;
    ClassNameLength = MAX_PATH;

    Error = RegEnumKeyEx(
                Handle1,
                1,
                KeyName,
                &KeyNameLength,
                NULL,
                ClassName,
                &ClassNameLength,
                &LastWriteTime
                );
    REG_API_SUCCESS( RegEnumKeyEx );

    ASSERT( Compare( KeyName, KEY_NAME_1_2, KEY_NAME_1_2_LENGTH ));
    ASSERT( KeyNameLength == KEY_NAME_1_2_LENGTH );
    //ASSERT( TitleIndex == KEY_NAME_1_2_TITLE_INDEX );
    ASSERT( Compare( ClassName, KEY_NAME_1_2_CLASS, KEY_NAME_1_2_CLASS_LENGTH ));
    ASSERT( ClassNameLength == KEY_NAME_1_2_CLASS_LENGTH );

    //
    // If the Quiet command line option wasn't set, display the TestUser1 key.
    //

    if( ! Quiet ) {
        Key = ParseKey( NameString );
        REG_API_SUCCESS( Key != NULL );
        DisplayKeys( Key, TRUE, TRUE, TRUE );
        FreeKey( Key );
    }

    //
    // Close the two sub-keys.
    //

    Error = RegCloseKey(
                Handle1_1
                );
    REG_API_SUCCESS( RegCloseKey );

    Error = RegCloseKey(
                Handle1_2
                );
    REG_API_SUCCESS( RegCloseKey );

    Error = RegFlushKey(
                Handle1
                );

    REG_API_SUCCESS( RegFlushKey );

    //
    // Save the TestUser1 tree to a file.
    //
#if 0
    Error = RegSaveKey(
                Handle1,
                SAVE_RESTORE_FILE,
                SecurityDescriptor
                );
    REG_API_SUCCESS( RegSaveKey );

    RegCloseKey( Handle1 );

    //
    // Delete the TestUser1 tree.
    //

    DeleteTestTree( );


    //
    //  Load TestUser1 from the file
    //
    Error = RegLoadKey(
                RootHandle,
                KEY_NAME_1,
                SAVE_RESTORE_FILE
                );
    REG_API_SUCCESS( RegLoadKey );

    //
    //  Unload TestUser1
    //
    Error = RegUnLoadKey(
                RootHandle,
                KEY_NAME_1
                );
    REG_API_SUCCESS( RegUnLoadKey );


    //
    // Restore the TestUser1 tree from a file.
    //

    Error = RegCreateKey(
                RootHandle,
                KEY_NAME_1,
                &Handle1
                );
    REG_API_SUCCESS( RegCreateKey );

    Error = RegRestoreKey(
                Handle1,
                SAVE_RESTORE_FILE,
                0
                );
    REG_API_SUCCESS( RegRestoreKey );
#endif

    //
    // Delete the two sub-keys.
    //

    Error = RegDeleteKey(
                Handle1,
                KEY_NAME_1_1
                );
    REG_API_SUCCESS( RegDeleteKey );

    Error = RegDeleteKey(
                Handle1,
                KEY_NAME_1_2
                );
    REG_API_SUCCESS( RegDeleteKey );

    //
    // Set a value in the TestUser1 key using the Win 3.1 compatible API.
    //

    Error = RegSetValue(
                RootHandle,
                KEY_NAME_1,
                VALUE_DATA_1_TYPE,
                Data_1,
                VALUE_DATA_1_LENGTH
                );
    REG_API_SUCCESS( RegSetValue );

    //
    // Set a value in the TestUser1 key using the Win32 API.
    //
    Error = RegSetValueEx(
                Handle1,
                VALUE_NAME_2,
                0,
                VALUE_DATA_2_TYPE,
                ( PVOID ) &Data_2,
                VALUE_DATA_2_LENGTH
                );
    REG_API_SUCCESS( RegSetValueEx );

    //
    // Commit the Key to the Registry.
    //

    Error = RegFlushKey(
                Handle1
                );
    REG_API_SUCCESS( RegFlushKey );

    //
    // If the Quiet command line option wasn't set, display the TestUser1 key.
    //

    if( ! Quiet ) {
        Key = ParseKey( NameString );
        REG_API_SUCCESS( Key != NULL );
        DisplayKeys( Key, TRUE, TRUE, TRUE );
        FreeKey( Key );
    }

    //
    // Query a value in the TestUser1 key using the Win 3.1 compatible API.
    //

    DataLength = MAX_DATA_LENGTH;

    Error = RegQueryValue(
                RootHandle,
                KEY_NAME_1,
                Data,
                &DataLength
                );
    REG_API_SUCCESS( RegQueryValue );

    ASSERT( Compare( Data, &Data_1, VALUE_DATA_1_LENGTH ));
    ASSERT( DataLength == VALUE_DATA_1_LENGTH );

    //
    // Query a value in the TestUser1 key using the Win32 API.
    //

    DataLength = MAX_DATA_LENGTH;

    Error = RegQueryValueEx(
                Handle1,
                VALUE_NAME_2,
                NULL,
                &Type,
                Data,
                &DataLength
                );
    REG_API_SUCCESS( RegQueryValueEx );

    //ASSERT( TitleIndex == VALUE_NAME_2_TITLE_INDEX );
    ASSERT( Type == VALUE_DATA_2_TYPE );
    ASSERT(( DWORD ) Data[ 0 ] == Data_2 );
    ASSERT( DataLength == VALUE_DATA_2_LENGTH );

    //
    // Query information about the key.
    //

    ClassNameLength = MAX_PATH;

    Error = RegQueryInfoKey(
                Handle1,
                ClassName,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );
    REG_API_SUCCESS( RegQueryInfoKey );

    ASSERT( Compare( ClassName, KEY_NAME_1_CLASS, KEY_NAME_1_CLASS_LENGTH ));
    ASSERT( ClassNameLength == KEY_NAME_1_CLASS_LENGTH );
    //ASSERT( TitleIndex == KEY_NAME_1_TITLE_INDEX );
    ASSERT( NumberOfSubKeys == 0 );

    ASSERT( MaxSubKeyLength == 0 );
    ASSERT( MaxClassLength == 0 );


    ASSERT( NumberOfValues == 2 );

    ASSERT( MaxValueNameLength == VALUE_NAME_2_LENGTH * sizeof(WCHAR) );
    ASSERT( MaxValueDataLength == VALUE_DATA_1_LENGTH * sizeof(WCHAR) );

    //
    // Enumerate the values.
    //

    for( Index = 0; Index < 2; Index++ ) {

        ValueNameLength = MAX_PATH;
        DataLength      = MAX_DATA_LENGTH;

        Error = RegEnumValue(
                    Handle1,
                    Index,
                    ValueName,
                    &ValueNameLength,
                    NULL,
                    &Type,
                    Data,
                    &DataLength
                    );
        REG_API_SUCCESS( RegEnumValue );

        //
        // Check specifics depending on the value being queried.
        //

        switch( Index ) {

        case 0:

            //
            // No name - win 3.1 compatible value.
            //

            ASSERT( ValueNameLength == 0 );
            //ASSERT( TitleIndex == VALUE_NAME_1_TITLE_INDEX );
            ASSERT( Type == VALUE_DATA_1_TYPE );
            ASSERT( Compare( Data, Data_1, VALUE_DATA_1_LENGTH ));
            ASSERT( DataLength == VALUE_DATA_1_LENGTH );
            break;

        case 1:

            ASSERT( Compare( ValueName, VALUE_NAME_2, VALUE_NAME_2_LENGTH ));
            ASSERT( ValueNameLength == VALUE_NAME_2_LENGTH );
            //ASSERT( TitleIndex == VALUE_NAME_2_TITLE_INDEX );
            ASSERT( Type == VALUE_DATA_2_TYPE );
            ASSERT(( DWORD ) Data[ 0 ] == Data_2 );
            ASSERT( DataLength == VALUE_DATA_2_LENGTH );
            break;

        default:

            ASSERT_MESSAGE( FALSE, "Valid value enumeration index - " );
        }
    }

    //
    // All done! Get rid of the key and close it.
    //

    Error = RegDeleteKey(
                RootHandle,
                KEY_NAME_1
                );
    REG_API_SUCCESS( RegDeleteKey );

    Error = RegCloseKey(
                Handle1
                );
    REG_API_SUCCESS( RegCloseKey );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\crdel\crdel.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Crdel.c

Abstract:

Author:

    David J. Gilman (davegi) 20-Dec-1991

Environment:

    Windows, Crt - User Mode

--*/

#include <ctype.h>
#include <stdlib.h>
#include <windows.h>

#include "crtools.h"

//
// KEY_ELEMENT is used to maintain a list of KEYs.
//

typedef struct _KEY_ELEMENT
    KEY_ELEMENT,
    *PKEY_ELEMENT;

struct _KEY_ELEMENT {
    PKEY            Key;
    PKEY_ELEMENT    NextKeyElement;
    };

//
// Error and informational messages.
//

PSTR    UsageMessage =

    "Usage: crdel [-?] [-q] key...\n";

PSTR    HelpMessage =

    "\n  where:\n"                                                          \
      "    -?   - display this message.\n"                                  \
      "    -q   - quiet mode\n"                                             \
      "    key  - name(s) of the key(s) to dump.\n"                         \
    "\n  A key is formed by specifying one of the predefined handles:\n"    \
    "\n         - HKEY_LOCAL_MACHINE\n"                                     \
      "         - HKEY_CLASSES_ROOT\n"                                      \
      "         - HKEY_CURRENT_USER\n"                                      \
      "         - HKEY_USERS\n"                                             \
    "\n  followed by a sub-key name.\n"                                     \
    "\n  An environment variable can be used as shorthand for the\n"        \
    "  predefined handles.  For example,\n"                                 \
    "\n    crdel HKEY_USERS\\davegi\n"                                      \
    "\n  is equivalent to\n"                                                \
    "\n    set HKEY_USERS=hu\n"                                             \
      "    crdel hu\\davegi\n";


PSTR    InvalidKeyMessage =

    "Invalid key - %s\n";

PSTR    InvalidSwitchMessage =

    "Invalid switch - %s\n";

PSTR    DeletingTreeMessage =

    "Deleteing tree %s\n";

VOID
DeleteTree(
    IN HKEY KeyHandle
    )

{
    LONG        Error;
    DWORD       Index;
    HKEY        ChildHandle;


    TSTR        KeyName[ MAX_PATH ];
    DWORD       KeyNameLength;
    TSTR        ClassName[ MAX_PATH ];
    DWORD       ClassNameLength;
    DWORD       TitleIndex;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;

    ClassNameLength = MAX_PATH;

    Error = RegQueryInfoKey(
                KeyHandle,
                ClassName,
                &ClassNameLength,
                &TitleIndex,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );
    REG_API_SUCCESS( RegQueryInfoKey );

    for( Index = 0; Index < NumberOfSubKeys; Index++ ) {

        KeyNameLength = MAX_PATH;

        Error = RegEnumKey(
                    KeyHandle,
                    0,
                    KeyName,
                    KeyNameLength
                    );
        REG_API_SUCCESS( RegEnumKey );

        Error = RegOpenKeyEx(
                    KeyHandle,
                    KeyName,
                    REG_OPTION_RESERVED,
                    KEY_ALL_ACCESS,
                    &ChildHandle
                    );
        REG_API_SUCCESS( RegOpenKey );

        DeleteTree( ChildHandle );

        Error = RegCloseKey(
                    ChildHandle
                    );
        REG_API_SUCCESS( RegCloseKey );

        Error = RegDeleteKey(
                    KeyHandle,
                    KeyName
                    );
        REG_API_SUCCESS( RegDeleteKey );
    }
}
VOID
DeleteKey(
    IN PKEY     Key
    )

{
    LONG    Error;

    ASSERT( Key != NULL );
    ASSERT( Key->KeyHandle != NULL );

    DeleteTree( Key->KeyHandle );

    Error = RegDeleteKey(
                Key->Parent->KeyHandle,
                Key->SubKeyName
                );
    REG_API_SUCCESS( RegDeleteKey );
}

VOID
main(
    INT     argc,
    PCHAR   argv[ ]
    )

/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/

{
    BOOL            Quiet;
    PKEY            ParsedKey;
    PKEY_ELEMENT    ParsedKeyElement;
    PKEY_ELEMENT    ParsedKeysHead;
    PKEY_ELEMENT    ParsedKeysTail;
    KEY_ELEMENT     Dummy = { NULL, NULL };

    //
    // If CrDel is invoked without any command line options, display
    // the usage message.
    //

    if( argc < 2 ) {

        DisplayMessage( TRUE, UsageMessage );
    }

    //
    // By default the user is prompted.
    //

    Quiet   = FALSE;

    //
    // Use a Dummy KEY structure to simplify the list management.
    // Initialize the head and tail pointers to point to the Dummy.
    //

    ParsedKeysHead = &Dummy;
    ParsedKeysTail = &Dummy;

    //
    // Initialize options based on the command line.
    //

    while( *++argv ) {

        //
        // If the command line argument is a switch character...
        //

        if( isswitch(( *argv )[ 0 ] )) {

            switch( tolower(( *argv )[ 1 ] )) {

            //
            // Display the detailed help message and quit.
            //

            case '?':

                DisplayMessage( FALSE, UsageMessage );
                DisplayMessage( TRUE, HelpMessage );
                break;

            //
            // Do not prompt user for delete.
            //

            case 'q':

                Quiet = TRUE;
                break;

            //
            // Display invalid switch message and quit.
            //

            default:

                DisplayMessage( FALSE, InvalidSwitchMessage, *argv );
                DisplayMessage( TRUE, UsageMessage );
            }
        } else {

            //
            // The command line argument was not a switch so attempt to parse
            // it into a predefined handle and a sub key.
            //

            ParsedKey = ParseKey( *argv );

            if( ParsedKey ) {

                //
                // If the command line argument was succesfully parsed,
                // allocate and initialize a KEY_ELEMENT, add it to the
                // list and update the tail pointer.
                //

                ParsedKeyElement = ( PKEY_ELEMENT ) malloc(
                                    sizeof( KEY_ELEMENT )
                                    );
                ASSERT( ParsedKeyElement );

                ParsedKeyElement->Key               = ParsedKey;
                ParsedKeyElement->NextKeyElement    = NULL;

                ParsedKeysTail->NextKeyElement = ParsedKeyElement;
                ParsedKeysTail = ParsedKeyElement;


            } else {

                //
                // The command line argument was not succesfully parsed,
                // so display an invalid key message and continue.
                //

                DisplayMessage( FALSE, InvalidKeyMessage, *argv );
            }
        }
    }

    //
    // Command line parsing is complete. Delete the requested keys
    // skipping the Dummy KEY_ELEMENT structure.
    //

    while( ParsedKeysHead = ParsedKeysHead->NextKeyElement ) {

        if( ! Quiet ) {

            DisplayMessage(
                FALSE,
                DeletingTreeMessage,
                ParsedKeysHead->Key->SubKeyFullName
                );
        }

        DeleteKey( ParsedKeysHead->Key );

        //
        // Once the KEY structure's Key is deleted both the KEY and
        // KEY_ELEMENT can be freed.
        //

        FreeKey( ParsedKeysHead->Key );
        free( ParsedKeysHead );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\crdump\crdump.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Crdump.c

Abstract:

Author:

    David J. Gilman (davegi) 20-Dec-1991

Environment:

    Windows, Crt - User Mode

--*/

#include <ctype.h>
#include <stdlib.h>
#include <windows.h>

#include "crtools.h"

//
// KEY_ELEMENT is used to maintain a list of KEYs.
//

typedef struct _KEY_ELEMENT
    KEY_ELEMENT,
    *PKEY_ELEMENT;

struct _KEY_ELEMENT {
    PKEY            Key;
    PKEY_ELEMENT    NextKeyElement;
    };

//
// Error and informational messages.
//

PSTR    UsageMessage =

    "Usage: crdump [-?] [-d] [-v] [-r] key...\n";

PSTR    HelpMessage =

    "\n  where:\n"                                                          \
      "    -?   - display this message.\n"                                  \
      "    -d   - dump all data (implies -v).\n"                            \
      "    -v   - dump all values.\n"                                       \
      "    -r   - recurse through sub keys.\n"                              \
      "    key  - name(s) of the key(s) to dump.\n"                         \
    "\n  A key is formed by specifying one of the predefined handles:\n"    \
    "\n         - HKEY_LOCAL_MACHINE\n"                                     \
      "         - HKEY_CLASSES_ROOT\n"                                      \
      "         - HKEY_CURRENT_USER\n"                                      \
      "         - HKEY_USERS\n"                                             \
    "\n  followed by a sub-key name.\n"                                     \
    "\n  An environment variable can be used as shorthand for the\n"        \
    "  predefined handles.  For example,\n"                                 \
    "\n    crdump HKEY_USERS\\davegi\n"                                     \
    "\n  is equivalent to\n"                                                \
    "\n    set HKEY_USERS=hu\n"                                             \
      "    crdump hu\\davegi\n";


PSTR    InvalidKeyMessage =

    "Invalid key - %s\n";

PSTR    InvalidSwitchMessage =

    "Invalid switch - %s\n";

PSTR    DisplayKeyFailMessage =

    "Could not display key %s\n";

VOID
main(
    INT     argc,
    PCHAR   argv[ ]
    )

/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/

{
    BOOL            Values;
    BOOL            Data;
    BOOL            Recurse;
    PKEY            ParsedKey;
    PKEY_ELEMENT    ParsedKeyElement;
    PKEY_ELEMENT    ParsedKeysHead;
    PKEY_ELEMENT    ParsedKeysTail;
    KEY_ELEMENT     Dummy = { NULL, NULL };

    //
    // If CrDump is invoked without any command line options, display
    // the usage message.
    //

    if( argc < 2 ) {

        DisplayMessage( TRUE, UsageMessage );
    }

    //
    // By default, no sub keys, values or data are displayed.
    //

    Recurse = FALSE;
    Values  = FALSE;
    Data    = FALSE;

    //
    // Use a Dummy KEY structure to simplify the list management.
    // Initialize the head and tail pointers to point to the Dummy.
    //

    ParsedKeysHead = &Dummy;
    ParsedKeysTail = &Dummy;

    //
    // Initialize options based on the command line.
    //

    while( *++argv ) {

        //
        // If the command line argument is a switch character...
        //

        if( isswitch(( *argv )[ 0 ] )) {

            switch( tolower(( *argv )[ 1 ] )) {

            //
            // Display the detailed help message and quit.
            //

            case '?':

                DisplayMessage( FALSE, UsageMessage );
                DisplayMessage( TRUE, HelpMessage );
                break;

            //
            // Display data - implies display values.

            case 'd':

                Values  = TRUE;
                Data    = TRUE;
                break;

            //
            // Display sub keys.
            //

            case 'r':

                Recurse = TRUE;
                break;

            //
            // Display values.
            //

            case 'v':

                Values = TRUE;
                break;

            //
            // Display invalid switch message and quit.
            //

            default:

                DisplayMessage( FALSE, InvalidSwitchMessage, *argv );
                DisplayMessage( TRUE, UsageMessage );
            }
        } else {

            //
            // The command line argument was not a switch so attempt to parse
            // it into a predefined handle and a sub key.
            //

            ParsedKey = ParseKey( *argv );

            if( ParsedKey ) {

                //
                // If the command line argument was succesfully parsed,
                // allocate and initialize a KEY_ELEMENT, add it to the
                // list and update the tail pointer.
                //

                ParsedKeyElement = ( PKEY_ELEMENT ) malloc(
                                    sizeof( KEY_ELEMENT )
                                    );
                ASSERT( ParsedKeyElement );

                ParsedKeyElement->Key               = ParsedKey;
                ParsedKeyElement->NextKeyElement    = NULL;

                ParsedKeysTail->NextKeyElement = ParsedKeyElement;
                ParsedKeysTail = ParsedKeyElement;


            } else {

                //
                // The command line argument was not succesfully parsed,
                // so display an invalid key message and continue.
                //

                DisplayMessage( FALSE, InvalidKeyMessage, *argv );
            }
        }
    }

    //
    // Command line parsing is complete. Display the requested keys
    // skipping the Dummy KEY_ELEMENT structure.
    //

    while( ParsedKeysHead = ParsedKeysHead->NextKeyElement ) {

        DisplayKeys( ParsedKeysHead->Key, Values, Data, Recurse );

        //
        // Once the KEY structure's Key is displayed both the KEY and
        // KEY_ELEMENT can be freed.
        //

        FreeKey( ParsedKeysHead->Key );
        free( ParsedKeysHead );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\inc\crtools.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Crtools.h

Abstract:

    This module is the master header file for the Configuration Registry
    Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <windows.h>
#include <winreg.h>


//
// Additional type to declare string arrays.
//

//
// Assertion/debug macros/functions.
//


#ifdef UNICODE

#define NUL_SIZE    ( 2 )
typedef WCHAR       TSTR;

#else

#define NUL_SIZE    ( 1 )
typedef char        TSTR;

#endif // UNICODE

#if DBG

VOID
CrAssert(
    IN PSTR FailedAssertion,
    IN PSTR FileName,
    IN DWORD LineNumber,
    IN PSTR Message OPTIONAL
    );

#define ASSERT( exp )                                                   \
    if( !( exp ))                                                       \
        CrAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERT_MESSAGE( exp, msg )                                      \
    if( !( exp ))                                                       \
        CrAssert( #exp, __FILE__, __LINE__, msg )

#define ASSERT_IS_KEY( Key )                                            \
    ASSERT( ARGUMENT_PRESENT( Key ));                                   \
    ASSERT( Key->Signature == KEY_SIGNATURE );

#else

#define ASSERT( exp )

#define ASSERT_MESSAGE( msg, exp )

#define ASSERT_IS_KEY( Key )

#endif // DBG


//
// Macro to check for a switch character.
//

#define isswitch( s )                                                   \
    ((( s ) == '-' ) || (( s ) == '/' ))
//
// Macro to check if an argument is present (i.e. non-NULL).
//

#define ARGUMENT_PRESENT( arg )                                         \
    ((( PVOID ) arg ) != (( PVOID ) NULL ))

//
//  Compare two blocks of memory for equality.
//
//  BOOL
//  Compare(
//      IN PVOID Block1,
//      IN PVOID Block2,
//      IN DWORD NumberOfBytes
//      );
//

#define Compare( s1, s2, c )                                            \
    ( memcmp(( PVOID )( s1 ), ( PVOID )( s2 ), ( size_t )( c )) == 0 )

//
// Compute the length (in bytes) of a Unicode string w/o the trailing NUL.
//

#define LENGTH( str )   ( sizeof( str ) -  NUL_SIZE )

//
// Check the success of a Win32 Registry API.
//

#define REG_API_SUCCESS( api )                                          \
    ASSERT_MESSAGE( Error == ERROR_SUCCESS, #api )

//
//
// A KEY structure is used to hold information about a Registry Key.
//

typedef struct _KEY
    KEY,
    *PKEY;

struct _KEY {
    PKEY        Parent;
    HKEY        KeyHandle;
    PSTR        SubKeyName;
    PSTR        SubKeyFullName;
    PSTR        ClassName;
    DWORD       ClassLength;
    DWORD       TitleIndex;
    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyNameLength;
    DWORD       MaxSubKeyClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;

#if DBG

    DWORD       Signature;

#endif

};

#define FILE_TIME_STRING_LENGTH     ( 25 * sizeof( TCHAR ))
#define KEY_SIGNATURE               ( 0xABBABAAB )

#define HKEY_CLASSES_ROOT_STRING    "HKEY_CLASSES_ROOT"
#define HKEY_CURRENT_USER_STRING    "HKEY_CURRENT_USER"
#define HKEY_LOCAL_MACHINE_STRING   "HKEY_LOCAL_MACHINE"
#define HKEY_USERS_STRING           "HKEY_USERS"

extern KEY  KeyClassesRoot;
extern KEY  KeyCurrentUser;
extern KEY  KeyLocalMachine;
extern KEY  KeyUsers;


PKEY
AllocateKey(
    IN PSTR MachineName,
    IN PKEY Parent,
    IN PSTR SubKeyName
    );

VOID
DisplayData(
    IN PBYTE ValueData,
    IN DWORD ValueDataLength
    );

VOID
DisplayKey(
    IN PKEY Key,
    IN BOOL Values,
    IN BOOL Data
    );

VOID
DisplayKeys(
    IN PKEY Key,
    IN BOOL Values,
    IN BOOL Data,
    IN BOOL Recurse
    );

VOID
DisplayKeyInformation(
    IN PKEY Key
    );

VOID
DisplayMessage(
    IN BOOL Terminate,
    IN PSTR Format,
    IN ...
    );

VOID
DisplayValues(
    IN PKEY Key,
    IN BOOL Data
    );

PSTR
FormatFileTime(
    IN PFILETIME FileTime OPTIONAL,
    IN PSTR Buffer OPTIONAL
    );

VOID
FreeKey(
    IN PKEY Key
    );

PKEY
ParseKey(
    IN PSTR SubKeyName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\allockey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Allockey.c

Abstract:

    This module contains the AllocateKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdlib.h>

#include "crtools.h"

PKEY
AllocateKey(
    IN PSTR MachineName,
    IN PKEY Parent,
    IN PSTR SubKeyName
    )


/*++

Routine Description:

    Allocates memory for a KEY structure and initializes it with the
    supplied parent PKEY and a copy of the sub key name.

Arguments:

    Parent - Supplies a PKEY which is the parent of the new Key.

    SubKeyName - Supplies a pointer to a string which is the name of this
        sub key. If the pointer is NULL then Parent refers to a predefined
        key.

    MachineName - Supplies an optional machine name whose Registry is to
        be accessed.

Return Value:

    PKEY - Returns a pointer to the newly allocated and initialized
        sub-key.

--*/

{
    LONG    Error;
    PKEY    Key;
    HKEY    Handle;

    ASSERT( ARGUMENT_PRESENT( Parent ));

    //
    // If a machine name was supplied, connect to that machine and replace
    // the predefined handle with the remote handle.
    //

    if( ARGUMENT_PRESENT( MachineName )) {

        Error = RegConnectRegistry(
                    MachineName,
                    Parent->KeyHandle,
                    &Parent->KeyHandle
                    );

        if( Error != ERROR_SUCCESS ) {

            ASSERT_MESSAGE( FALSE, "RegConnectRegistry - " );
            return FALSE;
        }
    }

    //
    // Check for a NULL sub key name and a parent that is a predefined key.
    //

    if( SubKeyName == NULL ) {
#if 0
    if((( SubKeyName == NULL )
        && (( Parent->KeyHandle == HKEY_CLASSES_ROOT )
        ||  ( Parent->KeyHandle == HKEY_CURRENT_USER )
        ||  ( Parent->KeyHandle == HKEY_LOCAL_MACHINE )
        ||  ( Parent->KeyHandle == HKEY_USERS )))) {
#endif
        //
        // There is no sub-key so the handle to open and the KEY object
        // to return is the parent.
        //

        Handle = Parent->KeyHandle;
        Key = Parent;

    } else {


        //
        // Allocate space for the new KEY.
        //

        Key = ( PKEY ) malloc( sizeof( KEY ));

        if( Key == NULL ) {
            ASSERT_MESSAGE( FALSE, "malloc of Key - " );
            return NULL;
        }

        //
        // Allocate space for the new KEY's full name.
        //

        Key->SubKeyFullName = ( PSTR ) malloc(
                                    strlen( SubKeyName ) + 1
                                    + strlen( Parent->SubKeyFullName )
                                    + sizeof(( TCHAR ) '\\' )
                                    );

        if( Key->SubKeyFullName == NULL ) {
            ASSERT_MESSAGE( FALSE, "malloc of SubKeyFullName - " );
            return NULL;
        }

        //
        // Capture the full name.
        //

        strcpy( Key->SubKeyFullName, Parent->SubKeyFullName );
        strcat( Key->SubKeyFullName, "\\" );
        strcat( Key->SubKeyFullName, SubKeyName );

        //
        // Allocate space for the new KEY's name.
        //

        Key->SubKeyName = ( PSTR ) malloc( strlen( SubKeyName ) + 1 );

        if( Key->SubKeyName == NULL ) {
            ASSERT_MESSAGE( FALSE, "malloc of SubKeyName - " );
            return NULL;
        }

        //
        // Capture the name.
        //

        strcpy( Key->SubKeyName, SubKeyName );

        //
        // Initialize the KEY's parent.
        //

        Key->Parent = Parent;

        //
        // Initialize the KEY's signature if under DBG control.
        //

#if DBG

        Key->Signature = KEY_SIGNATURE;

#endif // DBG

        //
        // Attempt to open the sub key.
        //

        Error = RegOpenKeyEx(
            Parent->KeyHandle,
            Key->SubKeyName,
            0,
            KEY_READ,
            &Key->KeyHandle
            );

        if( Error != ERROR_SUCCESS ) {

            ASSERT_MESSAGE( FALSE, "RegOpenKey - " );
            return FALSE;
        }

        //
        // Record the handle so that the following query works for either
        // the parent or the child.
        //

        Handle = Key->KeyHandle;
    }

    //
    // At this point Key/Handle either both refer to the Parent or to the
    // newly created subkey.
    //

    ASSERT( Handle == Key->KeyHandle );

    //
    // Query how many bytes are need for the class string. The expected
    // result is to get an ERROR_INVALID_PARAMETER error returned with
    // the ClassLength parameter filled in.
    //

    Key->ClassLength = 0;

    Error = RegQueryInfoKey(
        Handle,
        Key->ClassName,
        &Key->ClassLength,
        NULL,
        &Key->NumberOfSubKeys,
        &Key->MaxSubKeyNameLength,
        &Key->MaxSubKeyClassLength,
        &Key->NumberOfValues,
        &Key->MaxValueNameLength,
        &Key->MaxValueDataLength,
        &Key->SecurityDescriptorLength,
        &Key->LastWriteTime
        );

    //
    // If there is no class string set it to NULL.
    //

    if( Key->ClassLength == 0 ) {

        Key->ClassName = NULL;

    } else {

        //
        // Allocate space for the class string and get all of the info
        // for this key.
        //

        Key->ClassLength++;
        Key->ClassName = ( PSTR ) malloc( Key->ClassLength );

        if( Key->ClassName == NULL ) {

            ASSERT_MESSAGE( FALSE, "malloc of ClassName - " );
            return FALSE;
        }

        Error = RegQueryInfoKey(
            Key->KeyHandle,
            Key->ClassName,
            &Key->ClassLength,
            NULL,
            &Key->NumberOfSubKeys,
            &Key->MaxSubKeyNameLength,
            &Key->MaxSubKeyClassLength,
            &Key->NumberOfValues,
            &Key->MaxValueNameLength,
            &Key->MaxValueDataLength,
            &Key->SecurityDescriptorLength,
            &Key->LastWriteTime
            );

        if( Error != ERROR_SUCCESS ) {

            ASSERT_MESSAGE( FALSE, "Could not query all info the sub key" );
            return FALSE;
        }
    }

    return Key;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\dispkey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Dispkey.c

Abstract:

    This module contains the DisplayKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

Notes:

    Following is a sample display of a key:


----------------------------------

Key Name:        blech
Class Name:      foobar
Title Index:     12345678
Last Write Time: Wed 08-Jan-1992 11:19:43

Value 1
  Name:          bar
  Title Index:   12345678
  Type:          Double Word (2)
  Data:

00000000   42 55 49 4c 44 3a 20 43 - 6f 6d 70 69 6c 69 6e 67  BUILD: Compiling
00000010   20 64 3a 5c 6e 74 5c 70 - 72 69 76 61 74 65 5c 77   d:\nt\private\w
00000020   69 62 0a 0a 53 74 6f 70 - 2e 20 0a                 ib..Stop. .

Value 2
  Name:          foo
  Title Index:   12345678
  Type:          String (1)
  Data:

00000000   42 55 49 4c 44 3a 20 43 - 6f 6d 70 69 6c 69 6e 67  BUILD: Compiling
00000010   20 64 3a 5c 6e 74 5c 70 - 72 69 76 61 74 65 5c 77   d:\nt\private\w
00000020   69 62 0a 0a 53 74 6f 70 - 2e 20 0a                 ib..Stop. .

----------------------------------

    The first block ("Key Name:...11:19:43") is displayed by DisplayKey
    (dispkey.c).  The second block ("Value 1...Word (2)") is displayed by
    DisplayValues (disval.c) and the third block ("00000000...Stop. .")
    is displayed by DisplayData (dispdata.c).

--*/

#include <stdio.h>

#include "crtools.h"

VOID
DisplayKey(
    IN PKEY Key,
    IN BOOL Values,
    IN BOOL Data
    )

/*++

Routine Description:

    Display (on stdout) information about a Key and optionally about its
    values and data.

Arguments:

    Key - Supplies a pointer to a KEY structure which contains the
        HKEY and sub key name to display.

    Values - Supplies a flag which if TRUE causes all of the Key's values
        to be displayed.

    Data - Supplies a flag which if TRUE causes all of the Key's data
        to be displayed.

Return Value:

    None.

--*/

{
    ASSERT( ARGUMENT_PRESENT( Key ));

    DisplayKeyInformation( Key );

    if( Values ) {

        DisplayValues( Key, Data );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\dispkeys.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Dispkeys.c

Abstract:

    This module contains the DisplayKeys function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 08-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdlib.h>
#include "crtools.h"

VOID
DisplayKeys(
    IN PKEY Key,
    IN BOOL Values,
    IN BOOL Data,
    IN BOOL Recurse
    )

/*++

Routine Description:

    Display (on stdout) information about a Key, and optionally about
    its/there values, data and decendants.  Decendants are displayed using
    a deapth first traversal.

Arguments:

    Key - Supplies a pointer to a KEY structure which contains the
        HKEY and sub key name to display.

    Values - Supplies a flag which if TRUE causes all of the Key's values
        to be displayed.

    Data - Supplies a flag which if TRUE causes all of the Key's data
        to be displayed.

    Recurse - Supplies a flag which if TRUE causes all of the Key's sub-keys
        to be displayed.

Return Value:

    None.

--*/

{
    LONG        Error;
    PKEY        ChildKey;
    PSTR        ChildSubKeyName;
    DWORD       ChildSubKeyNameLength;
    DWORD       NumberOfSubKeys;

    ASSERT( ARGUMENT_PRESENT( Key ));

    //
    // Display the key.
    //

    DisplayKey( Key, Values, Data );

    //
    // If requested display all of the Key's children, their children etc.
    //

    if( Recurse ) {

        //
        // Allocate space for the largest sub-key name.
        //

        ChildSubKeyName = ( PSTR ) malloc( Key->MaxSubKeyNameLength + 1 );
        if( ! ChildSubKeyName ) {

            ASSERT_MESSAGE( FALSE, "ChildSubKeyName allocated - " );
            return;
        }

        //
        // For each immediate child key, retrieve its name, create a KEY
        // object and recursively call DisplayKeys.
        //

        for(
            NumberOfSubKeys = 0;
            NumberOfSubKeys < Key->NumberOfSubKeys;
            NumberOfSubKeys++ ) {

            ChildSubKeyNameLength = Key->MaxSubKeyNameLength + 1;

            //
            // Retrieve the child's name.
            //

            Error = RegEnumKey(
                        Key->KeyHandle,
                        NumberOfSubKeys,
                        ChildSubKeyName,
                        ChildSubKeyNameLength
                        );

            if( Error != ERROR_SUCCESS ) {

                ASSERT_MESSAGE( FALSE, "RegEnumKey suceeded - " );
                return;
            }

            //
            // Allocate a KEY object.
            //

            ChildKey = AllocateKey( NULL, Key, ChildSubKeyName );

            if( ! ChildKey ) {

                ASSERT_MESSAGE( FALSE, "AllocateKey suceeded - " );
                return;
            }

            DisplayKeys( ChildKey, Values, Data, Recurse );
            FreeKey( ChildKey );
        }

        //
        // Release the child name buffer.
        //

        free( ChildSubKeyName );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\dispkeyi.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Dispkeyi.c

Abstract:

    This module contains the DisplayKeyInformation function which is part
    of the Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdio.h>
#include <stdlib.h>

#include "crtools.h"

VOID
DisplayKeyInformation(
    IN PKEY Key
    )

/*++

Routine Description:

    Display (on stdout) meta information about a Key.

Arguments:

    Key - Supplies a pointer to a KEY for which information is to be
        displayed.
Return Value:

    None.

--*/

{
    ASSERT( ARGUMENT_PRESENT( Key ));

    printf( "\n"
            "Key Name:          %s\n"
            "Class Name:        %s\n"
            // "Title Index:       %ld\n"
            "Last Write Time:   %s\n",
            Key->SubKeyFullName,
            ( Key->ClassName == NULL ) ? "<NONE>" : Key->ClassName,
            // Key->TitleIndex,
            FormatFileTime( &Key->LastWriteTime, NULL )
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\dispmsg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Dispmsg.c

Abstract:

    This module contains the DisplayKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 08-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include "crtools.h"

VOID
DisplayMessage(
    IN BOOL Terminate,
    IN PSTR Format,
    IN ...
    )

/*++

Routine Description:

    Displays a message on the standard error stream and optionally
    terminates the program.

Arguments:

    Terminate - Supplies a flag which if TRUE causes DisplayMessage to
        terminate the program.

    Format - Supplies a printf style format string.

    ... - Supplies optional arguments, one for each format specifier in
        Format.

Return Value:

    None.

--*/

{
    va_list marker;

    ASSERT( ARGUMENT_PRESENT( Format ));

    va_start( marker, Format );

    vfprintf( stderr, Format, marker );

    va_end( marker );

    if( Terminate ) {
        exit( -1 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\assert.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Assert.c

Abstract:

    This module contains the CruAssert function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <conio.h>
#include <stdio.h>

#include "crtools.h"

VOID
CrAssert(
    IN PSTR FailedAssertion,
    IN PSTR FileName,
    IN DWORD LineNumber,
    IN PSTR Message OPTIONAL
    )

/*++

Routine Description:

    Display (on stderr) a string representing the failed assertion. Then
    prompt the user for the appropriate action. An optional message can
    also be displayed.

Arguments:

    FailedAssertion - Supplies the string representing the failed
        assertion.

    FileName - Supplies the string containing the file name of the failed
        assertion.

    LineNumber - Supplies the line number within the file that contains
        the failed assertion.

    Message - Supplies an optional message to be displayed along with the
        failed assertion.

Return Value:

    None.

--*/


{
    int Response;

    while( 1 ) {

        fprintf( stderr,
            "\n*** Assertion failed: %s %s\n***"
            "   Source File: %s, line %ld\n\n",
              Message ? Message : "",
              FailedAssertion,
              FileName,
              LineNumber
            );

        fprintf( stderr,
            "Break, Ignore, Exit Process or Exit Thread (bipt)? "
            );

        Response = getche( );
        fprintf( stderr, "\n\n" );

        switch( Response ) {

            case 'B':
            case 'b':
                DebugBreak( );
                break;

            case 'I':
            case 'i':
                return;

            case 'P':
            case 'p':
                ExitProcess( -1 );
                break;

            case 'T':
            case 't':
                ExitThread( -1 );
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\dispdata.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Dispdata.c

Abstract:

    This module contains the DisplayData function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <ctype.h>
#include <stdio.h>

#include "crtools.h"

VOID
DisplayData(
    IN PBYTE ValueData,
    IN DWORD ValueDataLength
    )

/*++

Routine Description:

    Display (on stdout) the supplied data in hex and ascii formats, in
    16 byte chunks.

Arguments:

    ValueData - Supplies a pointer to the data to display.

    ValueDataLength - Supplies the number of bytes of data to display.

Return Value:

    None.

--*/

{
    DWORD       DataIndex;
    DWORD       DataIndex2;
    WORD        SeperatorChars;

    ASSERT( ARGUMENT_PRESENT( ValueData ));

    //
    // DataIndex2 tracks multiples of 16.
    //

    DataIndex2 = 0;

    //
    // Display label.
    //

    printf( "Data:\n\n" );

    //
    // Display rows of 16 bytes of data.
    //

    for(
        DataIndex = 0;
        DataIndex < ( ValueDataLength >> 4 );
        DataIndex++,
        DataIndex2 = DataIndex << 4 ) {

        printf( "%08x   "
                "%02x %02x %02x %02x %02x %02x %02x %02x - "
                "%02x %02x %02x %02x %02x %02x %02x %02x  "
                "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",
                DataIndex2,
                ValueData[ DataIndex2 + 0  ],
                ValueData[ DataIndex2 + 1  ],
                ValueData[ DataIndex2 + 2  ],
                ValueData[ DataIndex2 + 3  ],
                ValueData[ DataIndex2 + 4  ],
                ValueData[ DataIndex2 + 5  ],
                ValueData[ DataIndex2 + 6  ],
                ValueData[ DataIndex2 + 7  ],
                ValueData[ DataIndex2 + 8  ],
                ValueData[ DataIndex2 + 9  ],
                ValueData[ DataIndex2 + 10 ],
                ValueData[ DataIndex2 + 11 ],
                ValueData[ DataIndex2 + 12 ],
                ValueData[ DataIndex2 + 13 ],
                ValueData[ DataIndex2 + 14 ],
                ValueData[ DataIndex2 + 15 ],
                isprint( ValueData[ DataIndex2 + 0  ] )
                    ? ValueData[ DataIndex2 + 0  ]  : '.',
                isprint( ValueData[ DataIndex2 + 1  ] )
                    ? ValueData[ DataIndex2 + 1  ]  : '.',
                isprint( ValueData[ DataIndex2 + 2  ] )
                    ? ValueData[ DataIndex2 + 2  ]  : '.',
                isprint( ValueData[ DataIndex2 + 3  ] )
                    ? ValueData[ DataIndex2 + 3  ]  : '.',
                isprint( ValueData[ DataIndex2 + 4  ] )
                    ? ValueData[ DataIndex2 + 4  ]  : '.',
                isprint( ValueData[ DataIndex2 + 5  ] )
                    ? ValueData[ DataIndex2 + 5  ]  : '.',
                isprint( ValueData[ DataIndex2 + 6  ] )
                    ? ValueData[ DataIndex2 + 6  ]  : '.',
                isprint( ValueData[ DataIndex2 + 7  ] )
                    ? ValueData[ DataIndex2 + 7  ]  : '.',
                isprint( ValueData[ DataIndex2 + 8  ] )
                    ? ValueData[ DataIndex2 + 8  ]  : '.',
                isprint( ValueData[ DataIndex2 + 9  ] )
                    ? ValueData[ DataIndex2 + 9  ]  : '.',
                isprint( ValueData[ DataIndex2 + 10 ] )
                    ? ValueData[ DataIndex2 + 10 ]  : '.',
                isprint( ValueData[ DataIndex2 + 11 ] )
                    ? ValueData[ DataIndex2 + 11 ]  : '.',
                isprint( ValueData[ DataIndex2 + 12 ] )
                    ? ValueData[ DataIndex2 + 12 ]  : '.',
                isprint( ValueData[ DataIndex2 + 13 ] )
                    ? ValueData[ DataIndex2 + 13 ]  : '.',
                isprint( ValueData[ DataIndex2 + 14 ] )
                    ? ValueData[ DataIndex2 + 14 ]  : '.',
                isprint( ValueData[ DataIndex2 + 15 ] )
                    ? ValueData[ DataIndex2 + 15 ]  : '.'
                );
    }

    //
    // If the ValueDataLength is not an even multiple of 16
    // then there is one additonal line of data to display.
    //

    if( ValueDataLength % 16 != 0 ) {

        //
        // No seperator characters displayed so far.
        //

        SeperatorChars = 0;

        printf( "%08x   ", DataIndex << 4 );

        //
        // Display the remaining data, one byte at a time in hex.
        //

        for(
            DataIndex = DataIndex2;
            DataIndex < ValueDataLength;
            DataIndex++ ) {

            printf( "%02x ", ValueData[ DataIndex ] );

            //
            // If eight data values have been displayed, print
            // the seperator.
            //

            if( DataIndex % 8 == 7 ) {

                printf( "- " );

                //
                // Remember that two seperator characters were
                // displayed.
                //

                SeperatorChars = 2;
            }
        }

        //
        // Fill with blanks to the printable characters position.
        // That is position 63 less 8 spaces for the 'address',
        // 3 blanks, 3 spaces for each value displayed, possibly
        // two for the seperator plus two blanks at the end.
        //

        printf( "%*c",
                64
                - ( 8 + 3
                + (( DataIndex % 16 ) * 3 )
                + SeperatorChars
                + 2 ), ' ' );

        //
        // Display the remaining data, one byte at a time as
        // printable characters.
        //

        for(
            DataIndex = DataIndex2;
            DataIndex < ValueDataLength;
            DataIndex++ ) {

            printf( "%c",
                isprint( ValueData[ DataIndex ] )
                    ? ValueData[ DataIndex ] : '.'
                );

        }
        printf( "\n" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\fmtft.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Fmtft.c

Abstract:

    This module contains the FormatFileTime function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdio.h>

#include "crtools.h"

PSTR
FormatFileTime(
    IN PFILETIME FileTime OPTIONAL,
    IN PSTR Buffer OPTIONAL
    )

/*++

Routine Description:

    Format the supplied FILETIME argument into a string. If the FILETIME
    is not supplied, format the current time.

Arguments:

    FileTime - Supplies an optional pointer to the FILETIME to be
        formatted.

    Buffer - Supplies an optional buffer to put the formatted time. This
        buffer nust be at least FILE_TIME_STRING_LENGTH bytes in length.

Return Value:

    PSTR - Returns a pointer to a string containg the formatted time.

Notes:

    If the Buffer is not supplied an static buffer used to store the formatted
    time. Therefore each call to FormatFileTime will overwrite the previous
    results.

--*/
{
    SYSTEMTIME  SystemTime;
    PSTR        BufferPtr;

    static PSTR Months[ ] = {
                            "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
                            };

    static PSTR Days[ ]   = {
                            "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
                            };

    static TSTR StaticBuffer[ FILE_TIME_STRING_LENGTH ];

    //
    // If the FileTime is supplied format that, otherwise format the
    // current time.
    //

    if( ARGUMENT_PRESENT( FileTime )) {

        //
        // Check that the supplied time was a valid FILETIME.
        //

        if( ! FileTimeToSystemTime( FileTime, &SystemTime )) {

            ASSERT_MESSAGE( FALSE, "Invalid FILETIME" );
            return NULL;
        }
    } else {

        GetSystemTime( &SystemTime );
    }

    //
    // If Buffer is supplied use it, otherwise use the static buffer.
    //

    BufferPtr = ( ARGUMENT_PRESENT( Buffer )) ? Buffer : StaticBuffer;

    //
    // DDD dd-MMM-yyyy hh:mm:ss
    //

    //
    // Check that there is room for the formatted string.
    //

    ASSERT( strlen( "DDD dd-MMM-yyyy hh:mm:ss" ) < FILE_TIME_STRING_LENGTH );

    sprintf( BufferPtr,
        "%s %02d-%s-%4d %02d:%02d:%02d",
        Days[ SystemTime.wDayOfWeek ],
        SystemTime.wDay,
        Months[ SystemTime.wMonth - 1 ],
        SystemTime.wYear,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond
        );

    return BufferPtr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\dispval.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Dispkey.c

Abstract:

    This module contains the DisplayKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdio.h>
#include <stdlib.h>

#include "crtools.h"

//
// Ensure that ValueTypeStrings table is correct.
//

//
// Maximum number of registry types.
//

#define NUMBER_OF_REG_TYPES     ( 9 )

#if (  (REG_NONE             != ( 0 )) \
    || (REG_SZ               != ( 1 )) \
    || (REG_EXPAND_SZ        != ( 2 )) \
    || (REG_BINARY           != ( 3 )) \
    || (REG_DWORD            != ( 4 )) \
    || (REG_DWORD_BIG_ENDIAN != ( 5 )) \
    || (REG_LINK             != ( 6 )) \
    || (REG_MULTI_SZ         != ( 7 )) \
    || (REG_RESOURCE_LIST    != ( 8 )))



#error REG_* does not map ValueTypeStrings correctly.

#endif

VOID
DisplayValues(
    IN PKEY Key,
    IN BOOL Data
    )

/*++

Routine Description:

    Display (on stdout) information about a Key's values and optionally
    its data.

Arguments:

    KeyHandle - Supplies a HKEY for which meta information is to be
        displayed.

    Key - Supplies a pointer to a KEY structure where the meta information
        is stored.

    Data - Supplies a flag which if TRUE causes all of the Key's data
        to be displayed.

Return Value:

    BOOL

--*/

{
    static PSTR ValueTypeStrings[ ] =   {
                                            TEXT( "None" ),
                                            TEXT( "String" ),
                                            TEXT( "Binary" ),
                                            TEXT( "Double Word" ),
                                            TEXT( "Double Word (big endian)" ),
                                            TEXT( "Symbolic link" ),
                                            TEXT( "Multi-SZ" ),
                                            TEXT( "Resource list" ),
                                            TEXT( "Unknown" )
                                        };


    LONG        Error;
    DWORD       Index;

    PSTR        ValueName;
    DWORD       ValueNameLength;
    DWORD       ValueTitleIndex;
    DWORD       ValueType;
    PBYTE       ValueData;
    DWORD       ValueDataLength;

    ASSERT( ARGUMENT_PRESENT( Key ));

    // Attempt to allocate memory for the largest possible value name.
    //

    ValueName = ( PSTR ) malloc( Key->MaxValueNameLength + 1 );
    if( ValueName == NULL ) {

        ASSERT_MESSAGE( FALSE, "Value name memory allocation - " );
        return;
    }

    //
    // If data is requested, attempt to allocate memory for the largest amount
    // of data.
    //

    if( Data ) {

        ValueData = ( PBYTE ) malloc( Key->MaxValueDataLength + 1 );
        if( ValueData == NULL ) {

            ASSERT_MESSAGE( FALSE, "Value data memory allocation - " );
            return;
        }

    } else {

        ValueData = NULL;
    }

    //
    // For each value in the sub key, enumerate and display its
    // details.
    //

    for( Index = 0; Index < Key->NumberOfValues; Index++ ) {

        //
        // Can't use the Key->Max*Length variables as they will be
        // overwritten by the RegEnumValue API.
        //

        ValueNameLength = Key->MaxValueNameLength + 1;
        ValueDataLength = Key->MaxValueDataLength;

        //
        // Get the name, title index, type and data for the
        // current value.
        //

        Error = RegEnumValue(
                    Key->KeyHandle,
                    Index,
                    ValueName,
                    &ValueNameLength,
                    NULL,
                    &ValueType,
                    ValueData,
                    &ValueDataLength
                    );

        if( Error != ERROR_SUCCESS ) {
            ASSERT_MESSAGE( FALSE, "RegEnumValue - " );
            return;
        }

        //
        // Display the value information.
        //

        printf( "\n"
                "Value %d\n"
                "Name:              %.*s\n"
                // "Title Index:       %ld\n"
                "Type:              %s (%ld)\n"
                "Data Length:       %ld\n",
                Index + 1,
                ( ValueNameLength == 0 ) ? 80 : ValueNameLength,
                ( ValueNameLength == 0 ) ? "<NONE>" : ValueName,
                // ValueTitleIndex,
                ValueTypeStrings[( ValueType < NUMBER_OF_REG_TYPES )
                                ? ValueType
                                : NUMBER_OF_REG_TYPES ],
                ValueType,
                ValueDataLength
                );

        if( Data ) {

            ASSERT( ValueData != NULL );
            DisplayData( ValueData, ValueDataLength );
        }
    }

    //
    // Release the buffers.
    //

    free( ValueName );

    if( ValueData != NULL ) {

        free( ValueData );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\pdkeys.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pdkeys.c

Abstract:

    This module contains the KEY definitions for the the predefined Key
    handles.  It is part of the Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 09-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include "crtools.h"

KEY  KeyClassesRoot     =   {
                            NULL,
                            HKEY_CLASSES_ROOT,
                            HKEY_CLASSES_ROOT_STRING,
                            HKEY_CLASSES_ROOT_STRING,
                            NULL,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            { 0, 0 }
#if DBG
                            , KEY_SIGNATURE
#endif
                        };



KEY  KeyCurrentUser     =   {
                            NULL,
                            HKEY_CURRENT_USER,
                            HKEY_CURRENT_USER_STRING,
                            HKEY_CURRENT_USER_STRING,
                            NULL,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            { 0, 0 }
#if DBG
                            , KEY_SIGNATURE
#endif
                        };

KEY  KeyLocalMachine    =   {
                            NULL,
                            HKEY_LOCAL_MACHINE,
                            HKEY_LOCAL_MACHINE_STRING,
                            HKEY_LOCAL_MACHINE_STRING,
                            NULL,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            { 0, 0 }
#if DBG
                            , KEY_SIGNATURE
#endif
                        };

KEY  KeyUsers           =   {
                            NULL,
                            HKEY_USERS,
                            HKEY_USERS_STRING,
                            HKEY_USERS_STRING,
                            NULL,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            { 0, 0 }
#if DBG
                            , KEY_SIGNATURE
#endif
                        };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\seaudit\msaudite\makefile.inc ===
MSAUDITE=$(SDK_INC_PATH)\msaudite.h \
         msaudite.h \
         msg00001.bin \
         msaudite.rc 

TARGETMOVED=$(BASEDIR)\private\ntos\seaudit\msaudite\msaudite.h \
            $(BASEDIR)\private\ntos\seaudit\msaudite\msaudite.rc \
            $(BASEDIR)\private\ntos\seaudit\msaudite\msg00001.bin
         
clean:  
       del /Q /F $(MSAUDITE)
       del /Q /F $(TARGETMOVED)

$(SDK_INC_PATH)\msaudite.h: msaudite.h 
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\strsafe\strsafe\strsafe.c ===
#include <stdio.h>

#define STRSAFE_LIB_IMPL
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\seaudit\msobjs\makefile.inc ===
MSOBJS=  $(SDK_INC_PATH)\msobjs.h \
         msobjs.h \
	 msg00001.bin \
         msobjs.rc 

TARGETMOVED=$(BASEDIR)\private\ntos\seaudit\msobjs\msobjs.h \
            $(BASEDIR)\private\ntos\seaudit\msobjs\msobjs.rc \
            $(BASEDIR)\private\ntos\seaudit\msobjs\msg00001.bin

clean:  
    del /Q /F $(MSOBJS) 
    del /Q /F $(TARGETMOVED)

$(SDK_INC_PATH)\msobjs.h: msobjs.h
   copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\parsekey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Parsekey.c

Abstract:

    This module contains the ParseKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdlib.h>
#include <string.h>

#include "crtools.h"

//
// PREDEFINED_HANDLE_ENTRYs are used to map strings on the command line
// to real predefined handles.
//

typedef struct _PREDEFINED_HANDLE_ENTRY
    PREDEFINED_HANDLE_ENTRY,
    *PPREDEFINED_HANDLE_ENTRY;

struct _PREDEFINED_HANDLE_ENTRY {
    PKEY        PredefinedKey;
    PSTR        PredefinedHandleName;
};

PKEY
ParseKey(
    IN PSTR SubKeyName
    )

/*++

Routine Description:

    Attempts to parse the supplied Key (string) into a predefined handle
    and a sub key.  If succesful it allocates and returns a KEY structure.

    The form of the supplied Key should be:

       \\machine_name\<predefined_key_name>\sub-key

    where "\\machine_name\" is optional.

Arguments:

    SubKeyName - Supplies the string which contains the key to parse.

Return Value:

    PKEY - Returns a pointer to a KEY structure if the supplied SubKeyName
        was succesfully parsed.

--*/


{

    static PREDEFINED_HANDLE_ENTRY      PredefinedHandleTable[ ] = {
                                &KeyClassesRoot,  HKEY_CLASSES_ROOT_STRING,
                                &KeyCurrentUser,  HKEY_CURRENT_USER_STRING,
                                &KeyLocalMachine, HKEY_LOCAL_MACHINE_STRING,
                                &KeyUsers,        HKEY_USERS_STRING
                            };
    PSTR    Token;
    PSTR    Name;
    PSTR    StrPtr;
    PSTR    MachineNamePtr;
    TSTR    MachineName[ MAX_PATH ];
    WORD    i;
    PKEY    ParsedKey;


    ASSERT( ARGUMENT_PRESENT( SubKeyName ));

    //
    // See if the SubKeyName contains a \\machine name.
    //

    if(( SubKeyName[ 0 ] == '\\' ) && ( SubKeyName[ 1 ] == '\\' )) {

        //
        // Find the end of the machine name.
        //

        StrPtr = strchr( &SubKeyName[ 2 ], '\\' );

        //
        // If the SubKeyName only contained a machine name, its invalid.
        //

        if( *StrPtr == '\0' ) {

            ASSERT_MESSAGE( FALSE, "SubKeyName - " );
            return NULL;

        } else {

            //
            // Copy and NUL terminate the machine name and bump over the '\'
            // that seperates the machine name from predefined handle.
            //

            strncpy( MachineName, SubKeyName, StrPtr - SubKeyName );
            MachineName[ StrPtr - SubKeyName ] = '\0';
            StrPtr++;
            MachineNamePtr = MachineName;
        }

    } else {

        //
        // There is no machine name so parse the string from the beginning.
        //

        StrPtr = SubKeyName;
        MachineNamePtr = NULL;
    }

    //
    // Get the predefined handle from the string (this may be at the
    // beginning of the string or after the machine name).
    //

    Token = strtok( StrPtr, "\\\0" );

    //
    // For each predefined handle, search the table to determine which
    // handle is being referenced.
    //

    for(
        i = 0;
        i < sizeof( PredefinedHandleTable ) / sizeof( PREDEFINED_HANDLE_ENTRY );
        i++ ) {

        //
        // See if the predefined handle name has been mapped in
        // the environment.
        //

        Name = getenv( PredefinedHandleTable[ i ].PredefinedHandleName );

        //
        // If it hasn't been mapped, use the default.
        //

        if( Name == NULL ) {

            Name = PredefinedHandleTable[ i ].PredefinedHandleName;
        }

        //
        // If the Token matches one of the prefined handle names, allocate
        // a KEY structure.
        //

        if( _stricmp( Name, Token ) == 0 ) {

            ParsedKey = AllocateKey(
                            MachineNamePtr,
                            PredefinedHandleTable[ i ].PredefinedKey,
                            strtok( NULL, "\0" )
                            );

            if( ParsedKey != NULL ) {

                return ParsedKey;

            } else {

                ASSERT_MESSAGE( FALSE, "AllocateKey - " );
                return NULL;
            }
        }
    }

    //
    // The supplied Key could not be parsed. That is the first token
    // was not one of the predefined handle names.
    //

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\stublibs\sources.inc ===
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..

SOURCES=$(TARGETNAME).c
PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(PUBLISH_PATH)\amd64\$(TARGETNAME).lib}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\screg\winreg\tools\lib\src\freekey.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Freekey.c

Abstract:

    This module contains the FreeKey function which is part of the
    Configuration Registry Tools (CRTools) library.

Author:

    David J. Gilman (davegi) 02-Jan-1992

Environment:

    Windows, Crt - User Mode

--*/

#include <stdlib.h>

#include "crtools.h"

VOID
FreeKey(
    IN PKEY Key
    )

/*++

Routine Description:

    Frees all memory associated with the supplied Key.

Arguments:

    Key - Supplies a pointer to the KEY structure to be freed.

Return Value:

    None.

--*/

{
    LONG    Error;

    ASSERT_IS_KEY( Key );

    //
    // Don't free/closee predefined handles.
    //

    if(
            ( Key->KeyHandle == HKEY_CLASSES_ROOT )
        ||  ( Key->KeyHandle == HKEY_CURRENT_USER )
        ||  ( Key->KeyHandle == HKEY_LOCAL_MACHINE )
        ||  ( Key->KeyHandle == HKEY_USERS )) {

        return;

    }

    Error = RegCloseKey( Key->KeyHandle );
    ASSERT( Error == ERROR_SUCCESS );

    free( Key->ClassName );
    free( Key->SubKeyName );
    free( Key->SubKeyFullName );
    free( Key );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\strsafe\ntstrsafe\ntstrsafe.c ===
#include <excpt.h>
#include <ntdef.h>
#include <ntstatus.h>

#define NTSTRSAFE_LIB_IMPL
#include <ntstrsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\stublibs\stublib.h ===
#define EX(x)    \
void             \
x(void) {        \
    return;      \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\stublibs\delay\delayimp.cpp ===
#include "windows.h"
#include "delayimp.h"

PUnloadInfo __puiHead;

extern "C"
void
__delayLoadHelper2 (
    void
    )

{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\stublibs\rsa32\rsa32.c ===
#include <stublib.h>

EX(A_SHAFinal)
EX(A_SHAFinalNS)
EX(A_SHAInit)
EX(A_SHAUpdate)
EX(A_SHAUpdateNS)
EX(DES_ECB_LM)
EX(MD4Final)
EX(MD4Init)
EX(MD4Update)
EX(MD5Final)
EX(MD5Init)
EX(MD5Update)
EX(rc4)
EX(rc4_key)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\csrdebug.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    csrdebug.c

Abstract:

    This module implements CSR Debug Services.

Author:

    Mark Lucovsky (markl) 02-Apr-1991


Revision History:

--*/

#include "csrsrv.h"

#if defined(_WIN64)
#include <wow64t.h>
#endif

PIMAGE_DEBUG_DIRECTORY
CsrpLocateDebugSection(
    IN HANDLE ProcessHandle,
    IN PVOID Base
    );

NTSTATUS
CsrDebugProcess(
    IN ULONG TargetProcessId,
    IN PCLIENT_ID DebugUserInterface,
    IN PCSR_ATTACH_COMPLETE_ROUTINE AttachCompleteRoutine
    )
{
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
CsrDebugProcessStop(
    IN ULONG TargetProcessId,
    IN PCLIENT_ID DebugUserInterface)
/*++

Routine Description:

    This procedure stops debugging a process

Arguments:

    ProcessId - Supplies the address of the process being debugged.
    DebugUserInterface - Client that issued the call

Return Value:

    NTSTATUS

--*/
{
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\apiinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    apiinit.c

Abstract:

    This module contains the code to initialize the ApiPort of the
    Server side of the Client-Server Runtime Subsystem to the Session
    Manager SubSystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Environment:

    User Mode Only

Revision History:

--*/

#include "csrsrv.h"

static SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY NtAuthority       = SECURITY_NT_AUTHORITY;

NTSTATUS
CsrApiPortInitialize( VOID )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Thread;
    CLIENT_ID ClientId;
    PLIST_ENTRY ListHead, ListNext;
    PCSR_THREAD ServerThread;
    HANDLE EventHandle;
    ULONG Length;
    PSID SeWorldSid;
    PSID SeRestrictedSid; 
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Dacl;

	// Though this function does not seem to cleanup on failure, failure
	// will cause Csrss to exit, so any allocated memory will be freed and
	// any open handle will be closed.


    Length = CsrDirectoryName.Length +
             sizeof( CSR_API_PORT_NAME ) +
             sizeof( OBJ_NAME_PATH_SEPARATOR );
    CsrApiPortName.Buffer = RtlAllocateHeap( CsrHeap, MAKE_TAG( INIT_TAG ), Length );
    if (CsrApiPortName.Buffer == NULL) {
        return( STATUS_NO_MEMORY );
        }
    CsrApiPortName.Length = 0;
    CsrApiPortName.MaximumLength = (USHORT)Length;
    RtlAppendUnicodeStringToString( &CsrApiPortName, &CsrDirectoryName );
    RtlAppendUnicodeToString( &CsrApiPortName, L"\\" );
    RtlAppendUnicodeToString( &CsrApiPortName, CSR_API_PORT_NAME );

    IF_CSR_DEBUG( INIT ) {
        DbgPrint( "CSRSS: Creating %wZ port and associated threads\n",
                  &CsrApiPortName );
        DbgPrint( "CSRSS: sizeof( CONNECTINFO ) == %ld  sizeof( API_MSG ) == %ld\n",
                  sizeof( CSR_API_CONNECTINFO ),
                  sizeof( CSR_API_MSG )
                );
        }

    //
    // create a security descriptor that allows all access
    //

    SeWorldSid = RtlAllocateHeap( CsrHeap, MAKE_TAG( TMP_TAG ), RtlLengthRequiredSid( 1 ) );
    if (SeWorldSid == NULL) {
        return( STATUS_NO_MEMORY );
        }

    RtlInitializeSid( SeWorldSid, &WorldSidAuthority, 1 );
    *(RtlSubAuthoritySid( SeWorldSid, 0 )) = SECURITY_WORLD_RID;

    Status = RtlAllocateAndInitializeSid(&NtAuthority ,
								         1,
                                         SECURITY_RESTRICTED_CODE_RID,
                                         0, 0, 0, 0, 0, 0, 0,
                                         &SeRestrictedSid);
	if (!NT_SUCCESS(Status)){
		return Status;
	}

    Length = SECURITY_DESCRIPTOR_MIN_LENGTH +
             (ULONG)sizeof(ACL) +
             2 * (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
             RtlLengthSid( SeWorldSid ) +
             RtlLengthSid( SeRestrictedSid ) +
             8; // The 8 is just for good measure
    SecurityDescriptor = RtlAllocateHeap( CsrHeap, MAKE_TAG( TMP_TAG ), Length);
    if (SecurityDescriptor == NULL) {
        return( STATUS_NO_MEMORY );
        }

    Dacl = (PACL)((PCHAR)SecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);

    RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
    RtlCreateAcl( Dacl, Length - SECURITY_DESCRIPTOR_MIN_LENGTH, ACL_REVISION2);

    RtlAddAccessAllowedAce (
                 Dacl,
                 ACL_REVISION2,
                 PORT_ALL_ACCESS,
                 SeWorldSid
                 );

    RtlAddAccessAllowedAce (
                 Dacl,
                 ACL_REVISION2,
                 PORT_ALL_ACCESS,
                 SeRestrictedSid
                 );

    RtlSetDaclSecurityDescriptor (
                 SecurityDescriptor,
                 TRUE,
                 Dacl,
                 FALSE
                 );

    InitializeObjectAttributes( &ObjectAttributes, &CsrApiPortName, 0,
                                NULL, SecurityDescriptor );
    Status = NtCreatePort( &CsrApiPort,
                           &ObjectAttributes,
                           sizeof( CSR_API_CONNECTINFO ),
                           sizeof( CSR_API_MSG ),
                           4096 * 16
                         );
	if (!NT_SUCCESS(Status)){
		return Status;
	}
    //
    // clean up security stuff
    //

    RtlFreeHeap( CsrHeap, 0, SeWorldSid );
    RtlFreeHeap( CsrHeap, 0, SeRestrictedSid );
    RtlFreeHeap( CsrHeap, 0, SecurityDescriptor );

    Status = NtCreateEvent(&EventHandle,
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE
                           );
	if (!NT_SUCCESS(Status)){
		return Status;
	}
    //
    // Create the inital request thread
    //

    Status = RtlCreateUserThread( NtCurrentProcess(),
                                  NULL,
                                  TRUE,
                                  0,
                                  0,
                                  0,
                                  CsrApiRequestThread,
                                  (PVOID)EventHandle,
                                  &Thread,
                                  &ClientId
                                );
	if (!NT_SUCCESS(Status)){
		return Status;
	}

    CsrAddStaticServerThread(Thread,&ClientId,CSR_STATIC_API_THREAD);

    ListHead = &CsrRootProcess->ThreadList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ServerThread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
        Status = NtResumeThread( ServerThread->ThreadHandle, NULL );
        if (ServerThread->Flags & CSR_STATIC_API_THREAD) {
            Status = NtWaitForSingleObject(EventHandle,FALSE,NULL);
            ASSERT( NT_SUCCESS( Status ) );
            }
        ListNext = ListNext->Flink;
        }
    NtClose(EventHandle);


    return( Status );
}

HANDLE
CsrQueryApiPort(VOID)
{
    return CsrApiPort;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\apireqst.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    apireqst.c

Abstract:

    This module contains the Request thread procedure for the Server side
    of the Client-Server Runtime Subsystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

#include "csrsrv.h"
#include <ntos.h>

NTSTATUS
CsrApiHandleConnectionRequest(
    IN PCSR_API_MSG Message
    );

EXCEPTION_DISPOSITION
CsrUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

ULONG CsrpDynamicThreadTotal;
ULONG CsrpStaticThreadCount;

PCSR_THREAD CsrConnectToUser( VOID )
{
    static BOOLEAN (*ClientThreadSetupRoutine)(VOID) = NULL;
    NTSTATUS Status;
    ANSI_STRING DllName;
    UNICODE_STRING DllName_U;
    STRING ProcedureName;
    HANDLE UserClientModuleHandle;
    PTEB Teb;
    PCSR_THREAD Thread;
    BOOLEAN fConnected;

    if (ClientThreadSetupRoutine == NULL) {
        RtlInitAnsiString(&DllName, "user32");
        Status = RtlAnsiStringToUnicodeString(&DllName_U, &DllName, TRUE);
        if (!NT_SUCCESS(Status)) {
			return NULL;
		};

        Status = LdrGetDllHandle(
                    UNICODE_NULL,
                    NULL,
                    &DllName_U,
                    (PVOID *)&UserClientModuleHandle
                    );

        RtlFreeUnicodeString(&DllName_U);

        if ( NT_SUCCESS(Status) ) {
            RtlInitString(&ProcedureName,"ClientThreadSetup");
            Status = LdrGetProcedureAddress(
                            UserClientModuleHandle,
                            &ProcedureName,
                            0L,
                            (PVOID *)&ClientThreadSetupRoutine
                            );
            if (!NT_SUCCESS(Status)){
				return NULL;
			};
        } else {
			return NULL;
		}
    }

    try {
        fConnected = ClientThreadSetupRoutine();
    } except (EXCEPTION_EXECUTE_HANDLER) {
        fConnected = FALSE;
    }
    if (!fConnected) {
            IF_DEBUG {
            DbgPrint("CSRSS: CsrConnectToUser failed\n");
                }
        return NULL;
    }

    /*
     * Set up CSR_THREAD pointer in the TEB
     */
    Teb = NtCurrentTeb();
    AcquireProcessStructureLock();
    Thread = CsrLocateThreadInProcess(NULL, &Teb->ClientId);
    ReleaseProcessStructureLock();
    if (Thread) {
        Teb->CsrClientThread = Thread;
    }

    return Thread;
}

NTSTATUS
CsrpCheckRequestThreads(VOID)
{
    //
    // See if we need to create a new thread for api requests.
    //
    // Don't create a thread if we're in the middle of debugger
    // initialization, which would cause the thread to be
    // lost to the debugger.
    //
    // If we are not a dynamic api request thread, then decrement
    // the static thread count. If it underflows, then create a temporary
    // request thread
    //

    if (!InterlockedDecrement(&CsrpStaticThreadCount)) {

        if ( CsrpDynamicThreadTotal < CsrMaxApiRequestThreads ) {

            HANDLE QuickThread;
            CLIENT_ID ClientId;
            NTSTATUS CreateStatus;

            //
            // If we are ready to create quick threads, then create one
            //

            CreateStatus = RtlCreateUserThread(
                                            NtCurrentProcess(),
                                            NULL,
                                            TRUE,
                                            0,
                                            0,
                                            0,
                                            CsrApiRequestThread,
                                            NULL,
                                            &QuickThread,
                                            &ClientId
                                        );

            if ( NT_SUCCESS(CreateStatus) ) {
                InterlockedIncrement(&CsrpStaticThreadCount);
                InterlockedIncrement(&CsrpDynamicThreadTotal);
                if ( CsrAddStaticServerThread(QuickThread,&ClientId,CSR_STATIC_API_THREAD) ) {
                    NtResumeThread(QuickThread,NULL);
                    }
                else {
                    InterlockedDecrement(&CsrpStaticThreadCount);
                    InterlockedDecrement(&CsrpDynamicThreadTotal);
                    NtTerminateThread(QuickThread,0);
                    NtClose(QuickThread);
                    return STATUS_UNSUCCESSFUL;
                    }
                }
            }
        }

    return STATUS_SUCCESS;
}

NTSTATUS
CsrApiRequestThread(
    IN PVOID Parameter
    )
{
    NTSTATUS Status;
    PCSR_PROCESS Process;
    PCSR_THREAD Thread;
    PCSR_THREAD MyThread;
    CSR_API_MSG ReceiveMsg;
    PCSR_API_MSG ReplyMsg;
    HANDLE ReplyPortHandle;
    PCSR_SERVER_DLL LoadedServerDll;
    PTEB Teb;
    ULONG ServerDllIndex;
    ULONG ApiTableIndex;
    CSR_REPLY_STATUS ReplyStatus;
    ULONG i;
    PVOID PortContext;
    USHORT MessageType;
    ULONG  ApiNumber;
    PLPC_CLIENT_DIED_MSG CdMsg;

    Teb = NtCurrentTeb();
    ReplyMsg = NULL;
    ReplyPortHandle = CsrApiPort;

    //
    // Try to connect to USER.
    //

    while (!CsrConnectToUser()) {
        LARGE_INTEGER TimeOut;

        //
        // The connect failed.  The best thing to do is sleep for
        // 30 seconds and retry the connect.  Clear the
        // initialized bit in the TEB so the retry can
        // succeed.
        //

        Teb->Win32ClientInfo[0] = 0;
        TimeOut.QuadPart = Int32x32To64(30000, -10000);
        NtDelayExecution(FALSE, &TimeOut);
    }
    MyThread = Teb->CsrClientThread;

    if ( Parameter ) {
        Status = NtSetEvent((HANDLE)Parameter,NULL);
        ASSERT( NT_SUCCESS( Status ) );
        InterlockedIncrement(&CsrpStaticThreadCount);
        InterlockedIncrement(&CsrpDynamicThreadTotal);
        }

    while (TRUE) {
        NtCurrentTeb()->RealClientId = NtCurrentTeb()->ClientId;
#if DBG
        if ( NtCurrentTeb()->CountOfOwnedCriticalSections != 0 ) {
            DbgPrint("CSRSRV: FATAL ERROR. CsrThread is Idle while holding %lu critical sections\n",
                     NtCurrentTeb()->CountOfOwnedCriticalSections
                    );
            DbgPrint("CSRSRV: Last Receive Message %p ReplyMessage %p\n",&ReceiveMsg,ReplyMsg);
            DbgBreakPoint();
            }

#endif // DBG

        Status = NtReplyWaitReceivePort( CsrApiPort,
                                         &PortContext,
                                         (PPORT_MESSAGE)ReplyMsg,
                                         (PPORT_MESSAGE)&ReceiveMsg
                                       );

        if (Status != STATUS_SUCCESS) {
            if (NT_SUCCESS( Status )) {
#if DBG
                DbgPrint("NtReplyWaitReceivePort returned \"success\" status 0x%x\n", Status);
#endif
                continue;       // Try again if alerted or a failure
                }

            IF_DEBUG {
                if (Status == STATUS_INVALID_CID ||
                    Status == STATUS_UNSUCCESSFUL ||
                    (Status == STATUS_INVALID_HANDLE &&
                     ReplyPortHandle != CsrApiPort
                    )
                   ) {
                    }
                else {
                    DbgPrint( "CSRSS: ReceivePort failed - Status == %X\n", Status );
                    DbgPrint( "CSRSS: ReplyPortHandle %lx CsrApiPort %lx\n", ReplyPortHandle, CsrApiPort );
                    }
                }

            //
            // Ignore if client went away.
            //

            ReplyMsg = NULL;
            ReplyPortHandle = CsrApiPort;
            continue;
            }

        NtCurrentTeb()->RealClientId = ReceiveMsg.h.ClientId;
        MessageType = ReceiveMsg.h.u2.s2.Type;

        //
        // Check to see if this is a connection request and handle
        //

        if (MessageType == LPC_CONNECTION_REQUEST) {
            CsrApiHandleConnectionRequest( &ReceiveMsg );
            ReplyPortHandle = CsrApiPort;
            ReplyMsg = NULL;
            continue;
            }


        //
        // We must acquire the process structure lock before we look up
        // the API thread.
        //

        AcquireProcessStructureLock();

        //
        // Lookup the client thread structure using the client id
        //

        Thread = CsrLocateThreadByClientId( &Process,
                                            &ReceiveMsg.h.ClientId
                                          );

        if (!Thread) {
            ReleaseProcessStructureLock();
            if ( MessageType == LPC_EXCEPTION ) {
                ReplyMsg = &ReceiveMsg;
                ReplyPortHandle = CsrApiPort;
                ReplyMsg->ReturnValue = DBG_CONTINUE;
                }
            else
            if ( MessageType == LPC_CLIENT_DIED ||
                 MessageType == LPC_PORT_CLOSED
               ) {
                ReplyPortHandle = CsrApiPort;
                ReplyMsg = NULL;
                }
            else {

                //
                // This must be a non-csr thread calling us. Tell it
                // to get lost. (unless this is a hard error)
                //

                if (MessageType == LPC_ERROR_EVENT) {
                    PHARDERROR_MSG m;

                    m = (PHARDERROR_MSG)&ReceiveMsg;
                    m->Response = (ULONG)ResponseNotHandled;

                    //
                    // Only call the handler if there are other
                    // request threads available to handle
                    // message processing.
                    //

                    CsrpCheckRequestThreads();
                    if (CsrpStaticThreadCount > 0) {
                        for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
                            LoadedServerDll = CsrLoadedServerDll[ i ];
                            if (LoadedServerDll && LoadedServerDll->HardErrorRoutine) {

                                (*LoadedServerDll->HardErrorRoutine)( Thread,
                                                                    m );
                                if (m->Response != (ULONG)ResponseNotHandled)
                                    break;
                                }
                            }
                        }
                    InterlockedIncrement(&CsrpStaticThreadCount);

                    if (m->Response == (ULONG)-1) {

                        //
                        // Hard error handler will directly reply to the client
                        //

                        ReplyPortHandle = CsrApiPort;
                        ReplyMsg = NULL;
                        }
                    else {
                        ReplyPortHandle = CsrApiPort;
                        ReplyMsg = &ReceiveMsg;
                        }

                    }
                else {
                    ReplyPortHandle = CsrApiPort;
                    if ( MessageType == LPC_REQUEST ) {
                        ReplyMsg = &ReceiveMsg;
                        ReplyMsg->ReturnValue = (ULONG)STATUS_ILLEGAL_FUNCTION;
                        }
                    else if (MessageType == LPC_DATAGRAM) {
                        //
                        // If this is a datagram, make the api call
                        //
                        ApiNumber = ReceiveMsg.ApiNumber;
                        ServerDllIndex =
                            CSR_APINUMBER_TO_SERVERDLLINDEX( ApiNumber );
                        if (ServerDllIndex >= CSR_MAX_SERVER_DLL ||
                            (LoadedServerDll = CsrLoadedServerDll[ ServerDllIndex ]) == NULL
                        ) {
                            IF_DEBUG {
                                DbgPrint( "CSRSS: %lx is invalid ServerDllIndex (%08x)\n",
                                        ServerDllIndex, LoadedServerDll
                                        );
                                DbgBreakPoint();
                                }

                            ReplyPortHandle = CsrApiPort;
                            ReplyMsg = NULL;
                            continue;
                            }
                        else {
                            ApiTableIndex =
                                CSR_APINUMBER_TO_APITABLEINDEX( ApiNumber ) -
                                LoadedServerDll->ApiNumberBase;
                            if (ApiTableIndex >= LoadedServerDll->MaxApiNumber - LoadedServerDll->ApiNumberBase) {
                                IF_DEBUG {
                                    DbgPrint( "CSRSS: %lx is invalid ApiTableIndex for %Z\n",
                                            LoadedServerDll->ApiNumberBase + ApiTableIndex,
                                            &LoadedServerDll->ModuleName
                                            );
                                    }

                                ReplyPortHandle = CsrApiPort;
                                ReplyMsg = NULL;
                                continue;
                                }
                            }

#if DBG
                        IF_CSR_DEBUG( LPC ) {
                            DbgPrint( "[%02x] CSRSS: [%02x,%02x] - %s Api called from %08x\n",
                                    NtCurrentTeb()->ClientId.UniqueThread,
                                    ReceiveMsg.h.ClientId.UniqueProcess,
                                    ReceiveMsg.h.ClientId.UniqueThread,
                                    LoadedServerDll->ApiNameTable[ ApiTableIndex ],
                                    Thread
                                    );
                            }
#endif // DBG

                        ReceiveMsg.ReturnValue = (ULONG)STATUS_SUCCESS;

                        try {

                            CsrpCheckRequestThreads();

                            ReplyPortHandle = CsrApiPort;
                            ReplyMsg = NULL;

                            (*(LoadedServerDll->ApiDispatchTable[ ApiTableIndex ]))(
                                    &ReceiveMsg,
                                    &ReplyStatus
                                    );
                            InterlockedIncrement(&CsrpStaticThreadCount);
                            }
                        except ( CsrUnhandledExceptionFilter( GetExceptionInformation() ) ){
                            ReplyPortHandle = CsrApiPort;
                            ReplyMsg = NULL;
                            }
                        }
                    else {
                        ReplyMsg = NULL;
                        }
                    }
                }
            continue;
            }

        //
        // See if this is a client died message. If so,
        // callout and then teardown thread/process structures.
        // this is how ExitThread is seen by CSR.
        //
        // LPC_CLIENT_DIED is caused by ExitProcess.  ExitProcess
        // calls TerminateProcess, which terminates all of the process's
        // threads except the caller.  this termination generates
        // LPC_CLIENT_DIED.
        //

        ReplyPortHandle = CsrApiPort;

        if (MessageType != LPC_REQUEST) {

            if (MessageType == LPC_CLIENT_DIED) {

                CdMsg = (PLPC_CLIENT_DIED_MSG)&ReceiveMsg;
                if (CdMsg->CreateTime.QuadPart == Thread->CreateTime.QuadPart) {
                    ReplyPortHandle = Thread->Process->ClientPort;

                    CsrLockedReferenceThread(Thread);
                    Status = CsrDestroyThread( &ReceiveMsg.h.ClientId );

                    //
                    // if this thread is it, then we also need to dereference
                    // the process since it will not be going through the
                    // normal destroy process path.
                    //

                    if ( Process->ThreadCount == 1 ) {
                        CsrDestroyProcess(&Thread->ClientId,0);
                        }
                    CsrLockedDereferenceThread(Thread);
                    }
                ReleaseProcessStructureLock();
                ReplyPortHandle = CsrApiPort;
                ReplyMsg = NULL;
                continue;
                }

            CsrLockedReferenceThread(Thread);
            ReleaseProcessStructureLock();

            //
            //  if this is an exception message, terminate the process
            //

            if (MessageType == LPC_EXCEPTION) {
                PDBGKM_APIMSG m;

                NtTerminateProcess(Process->ProcessHandle,STATUS_ABANDONED);
                Status = CsrDestroyProcess( &ReceiveMsg.h.ClientId,STATUS_ABANDONED );
                m = (PDBGKM_APIMSG)&ReceiveMsg;
                m->ReturnedStatus = DBG_CONTINUE;
                ReplyPortHandle = CsrApiPort;
                ReplyMsg = &ReceiveMsg;
                CsrDereferenceThread(Thread);
                continue;
                }

            //
            // If this is a hard error message, return return to caller
            //

            if (MessageType == LPC_ERROR_EVENT) {
                PHARDERROR_MSG m;

                m = (PHARDERROR_MSG)&ReceiveMsg;
                m->Response = (ULONG)ResponseNotHandled;

                //
                // Only call the handler if there are other
                // request threads available to handle
                // message processing.
                //

                CsrpCheckRequestThreads();
                if (CsrpStaticThreadCount > 0) {
                    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
                        LoadedServerDll = CsrLoadedServerDll[ i ];
                        if (LoadedServerDll && LoadedServerDll->HardErrorRoutine) {

                            (*LoadedServerDll->HardErrorRoutine)( Thread,
                                                                m );
                            if (m->Response != (ULONG)ResponseNotHandled) {
                                break;
                                }
                            }
                        }
                    }
                InterlockedIncrement(&CsrpStaticThreadCount);

                if (m->Response == (ULONG)-1) {

                    //
                    // Hard error handler will directly reply to the client
                    //

                    ReplyPortHandle = CsrApiPort;
                    ReplyMsg = NULL;
                    }
                else {
                    CsrDereferenceThread(Thread);
                    ReplyPortHandle = CsrApiPort;
                    ReplyMsg = &ReceiveMsg;
                    }
                continue;
                }

            CsrDereferenceThread(Thread);
            ReplyPortHandle = CsrApiPort;
            ReplyMsg = NULL;
            continue;
            }

        CsrLockedReferenceThread(Thread);
        ReleaseProcessStructureLock();

        ApiNumber = ReceiveMsg.ApiNumber;
        ServerDllIndex =
            CSR_APINUMBER_TO_SERVERDLLINDEX( ApiNumber );
        if (ServerDllIndex >= CSR_MAX_SERVER_DLL ||
            (LoadedServerDll = CsrLoadedServerDll[ ServerDllIndex ]) == NULL
           ) {
            IF_DEBUG {
                DbgPrint( "CSRSS: %lx is invalid ServerDllIndex (%08x)\n",
                          ServerDllIndex, LoadedServerDll
                        );
                SafeBreakPoint();
                }

            ReplyMsg = &ReceiveMsg;
            ReplyPortHandle = CsrApiPort;
            ReplyMsg->ReturnValue = (ULONG)STATUS_ILLEGAL_FUNCTION;
            CsrDereferenceThread(Thread);
            continue;
            }
        else {
            ApiTableIndex =
                CSR_APINUMBER_TO_APITABLEINDEX( ApiNumber ) -
                LoadedServerDll->ApiNumberBase;
            if (ApiTableIndex >= LoadedServerDll->MaxApiNumber - LoadedServerDll->ApiNumberBase) {
                IF_DEBUG {
                    DbgPrint( "CSRSS: %lx is invalid ApiTableIndex for %Z\n",
                              LoadedServerDll->ApiNumberBase + ApiTableIndex,
                              &LoadedServerDll->ModuleName
                            );
                    SafeBreakPoint();
                    }

                ReplyMsg = &ReceiveMsg;
                ReplyPortHandle = CsrApiPort;
                ReplyMsg->ReturnValue = (ULONG)STATUS_ILLEGAL_FUNCTION;
                CsrDereferenceThread(Thread);
                continue;
                }
            }

#if DBG
        IF_CSR_DEBUG( LPC ) {
            DbgPrint( "[%02x] CSRSS: [%02x,%02x] - %s Api called from %08x\n",
                      NtCurrentTeb()->ClientId.UniqueThread,
                      ReceiveMsg.h.ClientId.UniqueProcess,
                      ReceiveMsg.h.ClientId.UniqueThread,
                      LoadedServerDll->ApiNameTable[ ApiTableIndex ],
                      Thread
                    );
            }
#endif // DBG

        ReplyMsg = &ReceiveMsg;
        ReplyPortHandle = Thread->Process->ClientPort;

        ReceiveMsg.ReturnValue = (ULONG)STATUS_SUCCESS;
        if (ReceiveMsg.CaptureBuffer != NULL) {
            if (!CsrCaptureArguments( Thread, &ReceiveMsg )) {
                CsrDereferenceThread(Thread);
                goto failit;
                }
            }

        try {

            CsrpCheckRequestThreads();

            Teb->CsrClientThread = (PVOID)Thread;

            ReplyStatus = CsrReplyImmediate;
            ReplyMsg->ReturnValue =
                (*(LoadedServerDll->ApiDispatchTable[ ApiTableIndex ]))(
                    &ReceiveMsg,
                    &ReplyStatus
                    );
            InterlockedIncrement(&CsrpStaticThreadCount);

            Teb->CsrClientThread = (PVOID)MyThread;

            if (ReplyStatus == CsrReplyImmediate) {
                //
                // free captured arguments if a capture buffer was allocated
                // AND we're replying to the message now (no wait block has
                // been created).
                //

                if (ReplyMsg && ReceiveMsg.CaptureBuffer != NULL) {
                    CsrReleaseCapturedArguments( &ReceiveMsg );
                    }
                CsrDereferenceThread(Thread);
                }
            else if (ReplyStatus == CsrClientDied) {
                    NtReplyPort( ReplyPortHandle,
                                 (PPORT_MESSAGE)ReplyMsg
                               );
                    ReplyPortHandle = CsrApiPort;
                    ReplyMsg = NULL;
                    CsrDereferenceThread(Thread);
                    }
            else if (ReplyStatus == CsrReplyPending) {
                    ReplyPortHandle = CsrApiPort;
                    ReplyMsg = NULL;
                    }
            else if (ReplyStatus == CsrServerReplied) {
                    if (ReplyMsg && ReceiveMsg.CaptureBuffer != NULL) {
                        CsrReleaseCapturedArguments( &ReceiveMsg );
                        }
                    ReplyPortHandle = CsrApiPort;
                    ReplyMsg = NULL;
                    CsrDereferenceThread(Thread);
                    }
            else {
                if (ReplyMsg && ReceiveMsg.CaptureBuffer != NULL) {
                    CsrReleaseCapturedArguments( &ReceiveMsg );
                    }
                CsrDereferenceThread(Thread);
                }

            }
        except ( CsrUnhandledExceptionFilter( GetExceptionInformation() ) ){
            ReplyPortHandle = CsrApiPort;
            ReplyMsg = NULL;
            }
failit:
        ;
        }

    NtTerminateThread( NtCurrentThread(), Status );
    return( Status );
}

NTSTATUS
CsrCallServerFromServer(
    PCSR_API_MSG ReceiveMsg,
    PCSR_API_MSG ReplyMsg
    )

/*++

Routine Description:

    This function dispatches an API call the same way CsrApiRequestThread
    does, but it does it as a direct call, not an LPC connect.  It is used
    by the csr dll when the server is calling a dll function.  We don't
    worry about process serialization here because none of the process APIs
    can be called from the server.

Arguments:

    ReceiveMessage - Pointer to the API request message received.

    ReplyMessage - Pointer to the API request message to return.

Return Value:

    Status Code

--*/

{

    ULONG ServerDllIndex;
    ULONG ApiTableIndex;
    PCSR_SERVER_DLL LoadedServerDll;
    CSR_REPLY_STATUS ReplyStatus;

    ServerDllIndex =
        CSR_APINUMBER_TO_SERVERDLLINDEX( ReceiveMsg->ApiNumber );
    if (ServerDllIndex >= CSR_MAX_SERVER_DLL ||
        (LoadedServerDll = CsrLoadedServerDll[ ServerDllIndex ]) == NULL
       ) {
        IF_DEBUG {
            DbgPrint( "CSRSS: %lx is invalid ServerDllIndex (%08x)\n",
                      ServerDllIndex, LoadedServerDll
                    );
            // DbgBreakPoint();
            }

        ReplyMsg->ReturnValue = (ULONG)STATUS_ILLEGAL_FUNCTION;
        return STATUS_ILLEGAL_FUNCTION;
        }
    else {
        ApiTableIndex =
            CSR_APINUMBER_TO_APITABLEINDEX( ReceiveMsg->ApiNumber ) -
            LoadedServerDll->ApiNumberBase;
        if (ApiTableIndex >= LoadedServerDll->MaxApiNumber - LoadedServerDll->ApiNumberBase ||
            (LoadedServerDll->ApiServerValidTable &&
            !LoadedServerDll->ApiServerValidTable[ ApiTableIndex ])) {
            IF_DEBUG {
                DbgPrint( "CSRSS: %lx (%s) is invalid ApiTableIndex for %Z or is an invalid API to call from the server.\n",
                          LoadedServerDll->ApiNumberBase + ApiTableIndex,
                          (LoadedServerDll->ApiNameTable &&
                           LoadedServerDll->ApiNameTable[ ApiTableIndex ]
                          ) ? LoadedServerDll->ApiNameTable[ ApiTableIndex ]
                            : "*** UNKNOWN ***",
                          &LoadedServerDll->ModuleName
                        );
                DbgBreakPoint();
                }

            ReplyMsg->ReturnValue = (ULONG)STATUS_ILLEGAL_FUNCTION;
            return STATUS_ILLEGAL_FUNCTION;
            }
        }

#if DBG
    IF_CSR_DEBUG( LPC ) {
        DbgPrint( "CSRSS: %s Api Request received from server process\n",
                  LoadedServerDll->ApiNameTable[ ApiTableIndex ]
                );
        }
#endif // DBG
    try {
        ReplyMsg->ReturnValue =
            (*(LoadedServerDll->ApiDispatchTable[ ApiTableIndex ]))(
                ReceiveMsg,
                &ReplyStatus
                );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        ReplyMsg->ReturnValue = (ULONG)STATUS_ACCESS_VIOLATION;
        }

    return STATUS_SUCCESS;
}

BOOLEAN
CsrCaptureArguments(
    IN PCSR_THREAD t,
    IN PCSR_API_MSG m
    )
{
    PCSR_CAPTURE_HEADER ClientCaptureBuffer;
    PCSR_CAPTURE_HEADER ServerCaptureBuffer;
    PULONG_PTR PointerOffsets;
    ULONG Length, CountPointers;
    ULONG_PTR PointerDelta, Pointer;

    try {
        ClientCaptureBuffer = m->CaptureBuffer;
        Length = ClientCaptureBuffer->Length;

        if ((PCH)ClientCaptureBuffer < t->Process->ClientViewBase ||
            (PCH)ClientCaptureBuffer > (t->Process->ClientViewBounds - sizeof(CSR_CAPTURE_HEADER)) ||
            ((PCH)ClientCaptureBuffer + Length) < (PCH)ClientCaptureBuffer ||
            ((PCH)ClientCaptureBuffer + Length) > t->Process->ClientViewBounds
           ) {
            IF_DEBUG {
                DbgPrint( "*** CSRSS: CaptureBuffer outside of ClientView\n" );
                }

            m->ReturnValue = (ULONG)STATUS_INVALID_PARAMETER;
            return( FALSE );
            }

        CountPointers = ClientCaptureBuffer->CountMessagePointers;
        if (Length < FIELD_OFFSET(CSR_CAPTURE_HEADER, MessagePointerOffsets) + CountPointers * sizeof(PVOID) ||
            ClientCaptureBuffer->CountMessagePointers > MAXUSHORT
           ) {
            IF_DEBUG {
                DbgPrint( "*** CSRSS: CaptureBuffer %p has bad length\n", ClientCaptureBuffer );
                DbgBreakPoint();
                }

            m->ReturnValue = (ULONG)STATUS_INVALID_PARAMETER;
            return( FALSE );
            }
        }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        m->ReturnValue = (ULONG)STATUS_INVALID_PARAMETER;
        return( FALSE );
        }

    ServerCaptureBuffer = RtlAllocateHeap( CsrHeap, MAKE_TAG( CAPTURE_TAG ), Length );
    if (ServerCaptureBuffer == NULL) {
        m->ReturnValue = (ULONG)STATUS_NO_MEMORY;
        return( FALSE );
        }

    RtlMoveMemory( ServerCaptureBuffer, ClientCaptureBuffer, Length );
    ServerCaptureBuffer->Length = Length;
    PointerDelta = (ULONG_PTR)ServerCaptureBuffer - (ULONG_PTR)ClientCaptureBuffer;

    PointerOffsets = ServerCaptureBuffer->MessagePointerOffsets;
    CountPointers = ServerCaptureBuffer->CountMessagePointers;
    while (CountPointers--) {
        Pointer = *PointerOffsets++;
        if (Pointer != 0) {
            Pointer += (ULONG_PTR)m;
            if ((PCH)*(PULONG_PTR)Pointer >= t->Process->ClientViewBase &&
                (PCH)*(PULONG_PTR)Pointer < t->Process->ClientViewBounds
               ) {
                *(PULONG_PTR)Pointer += PointerDelta;
                }
            else {
                IF_DEBUG {
                    DbgPrint( "*** CSRSS: CaptureBuffer MessagePointer outside of ClientView\n" );
                    DbgBreakPoint();
                    }
                m->ReturnValue = (ULONG)STATUS_INVALID_PARAMETER;
                }
            }
        }

    if (m->ReturnValue != STATUS_SUCCESS) {
        RtlFreeHeap( CsrHeap, 0, ServerCaptureBuffer );
        return( FALSE );
        }
    else {
        ServerCaptureBuffer->RelatedCaptureBuffer = ClientCaptureBuffer;
        m->CaptureBuffer = ServerCaptureBuffer;
        return( TRUE );
        }
}

VOID
CsrReleaseCapturedArguments(
    IN PCSR_API_MSG m
    )
{
    PCSR_CAPTURE_HEADER ClientCaptureBuffer;
    PCSR_CAPTURE_HEADER ServerCaptureBuffer;
    PULONG_PTR PointerOffsets;
    ULONG CountPointers;
    ULONG_PTR PointerDelta, Pointer;

    ServerCaptureBuffer = m->CaptureBuffer;
    ClientCaptureBuffer = ServerCaptureBuffer->RelatedCaptureBuffer;
    if (ServerCaptureBuffer == NULL) {
        return;
        }
    ServerCaptureBuffer->RelatedCaptureBuffer = NULL;

    PointerDelta = (ULONG_PTR)ClientCaptureBuffer - (ULONG_PTR)ServerCaptureBuffer;

    PointerOffsets = ServerCaptureBuffer->MessagePointerOffsets;
    CountPointers = ServerCaptureBuffer->CountMessagePointers;
    while (CountPointers--) {
        Pointer = *PointerOffsets++;
        if (Pointer != 0) {
            Pointer += (ULONG_PTR)m;
            *(PULONG_PTR)Pointer += PointerDelta;
            }
        }

    RtlMoveMemory( ClientCaptureBuffer,
                   ServerCaptureBuffer,
                   ServerCaptureBuffer->Length
                 );

    RtlFreeHeap( CsrHeap, 0, ServerCaptureBuffer );
}



BOOLEAN
CsrValidateMessageBuffer(
    IN CONST CSR_API_MSG* m,
    IN VOID CONST * CONST * Buffer,
    IN ULONG Count,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine validates the given message buffer within the capture
    buffer of the CSR_API_MSG structure. The message buffer must be valid
    and of the correct size. This function should be called to validate
    any buffer allocated through CsrCaptureMessageBuffer.

Arguments:

    m - Pointer to CSR_API_MSG.

    Buffer - Pointer to message buffer.

    Count - number of elements in buffer.

    Size - size of each element in buffer.

Return Value:

    TRUE  - if message buffer is valid and of correct size.
    FALSE - otherwise.

--*/

{
    ULONG i;
    ULONG_PTR Length;
    ULONG_PTR EndOfBuffer;
    ULONG_PTR Offset;
    PCSR_CAPTURE_HEADER CaptureBuffer = m->CaptureBuffer;

    //
    // Check for buffer length overflow. Also, Size should not be 0.
    //

    if (Size && Count <= MAXULONG / Size) {

        //
        // If buffer is empty, we're done
        //

        Length = Count * Size;
        if (*Buffer == NULL && Length == 0) {
            return TRUE;
        }

        //
        // Make sure we have a capture area
        //

        if (CaptureBuffer) {

            //
            // Check for buffer length exceeding capture area size
            //

            EndOfBuffer = (ULONG_PTR)CaptureBuffer + CaptureBuffer->Length;;
            if (Length <= (EndOfBuffer - (ULONG_PTR)(*Buffer))) {

                //
                // Search for buffer in capture area
                //

                Offset = (ULONG_PTR)Buffer - (ULONG_PTR)m;
                for (i = 0; i < CaptureBuffer->CountMessagePointers; i++) {
                    if (CaptureBuffer->MessagePointerOffsets[i] == Offset) {
                        return TRUE;
                    }
                }
            }
        } else {
            //
            // If this is called from the CSRSS process vis CsrCallServerFromServer,
            // then CaptureBuffer is NULL.  Verify that the caller is the CSRSS process.
            //
            if (m->h.ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) {
                return TRUE;
            }
        }
    }


    IF_DEBUG {
        DbgPrint("CSRSRV: Bad message buffer %p\n", m);
        SafeBreakPoint();
        }

    return FALSE;
}


BOOLEAN
CsrValidateMessageString(
    IN CONST CSR_API_MSG* m,
    IN CONST PCWSTR *Buffer
    ) {
    PCSR_CAPTURE_HEADER CaptureBuffer = m->CaptureBuffer;
    ULONG_PTR EndOfBuffer;
    ULONG_PTR Offset;
    ULONG i;
    ULONG_PTR Length;

    //
    // Make sure we have a capture area
    //

    if (*Buffer == NULL) {
        return TRUE;
    }

    try {
        Length = (wcslen(*Buffer)+1)*sizeof(WCHAR);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrint(("CSRSRV: Bad message string %p\n", m));
        ASSERT(FALSE);
        return FALSE;
    }
    if (CaptureBuffer) {

        //
        // Check for buffer length exceeding capture area size
        //

        EndOfBuffer = (ULONG_PTR)CaptureBuffer + CaptureBuffer->Length;;
        if (Length <= (EndOfBuffer - (ULONG_PTR)(*Buffer))) {

            //
            // Search for buffer in capture area
            //

            Offset = (ULONG_PTR)Buffer - (ULONG_PTR)m;
            for (i = 0; i < CaptureBuffer->CountMessagePointers; i++) {
                if (CaptureBuffer->MessagePointerOffsets[i] == Offset) {
                    return TRUE;
                }
            }
        }
    } else {
        //
        // If this is called from the CSRSS process vis CsrCallServerFromServer,
        // then CaptureBuffer is NULL.  Verify that the caller is the CSRSS process.
        //
        if (m->h.ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) {
            return TRUE;
        }
    }

    KdPrint(("CSRSRV: Bad message string %p\n", m));
    ASSERT(FALSE);

    return FALSE;
}

NTSTATUS
CsrApiHandleConnectionRequest(
    IN PCSR_API_MSG Message
    )
{
    NTSTATUS Status;
    REMOTE_PORT_VIEW ClientView;
    BOOLEAN AcceptConnection;
    HANDLE PortHandle;
    PCSR_PROCESS Process;
    PCSR_THREAD Thread;
    PCSR_API_CONNECTINFO ConnectionInformation;

    ConnectionInformation = &Message->ConnectionRequest;
    AcceptConnection = FALSE;

    AcquireProcessStructureLock();
    Thread = CsrLocateThreadByClientId( NULL, &Message->h.ClientId );
    if (Thread != NULL && (Process = Thread->Process) != NULL) {
        CsrLockedReferenceProcess(Process);
        ReleaseProcessStructureLock();
        Status = NtDuplicateObject( NtCurrentProcess(),
                                    CsrObjectDirectory,
                                    Process->ProcessHandle,
                                    &ConnectionInformation->ObjectDirectory,
                                    0,
                                    0,
                                    DUPLICATE_SAME_ACCESS |
                                    DUPLICATE_SAME_ATTRIBUTES
                                  );
        AcquireProcessStructureLock();
        if (NT_SUCCESS( Status )) {
            Status = CsrSrvAttachSharedSection( Process,
                                                ConnectionInformation
                                              );
            if (NT_SUCCESS( Status )) {

#if DBG
                ConnectionInformation->DebugFlags = CsrDebug;
#endif
                AcceptConnection = TRUE;
                }
            }
        CsrLockedDereferenceProcess(Process);
        }

    ReleaseProcessStructureLock();

    ClientView.Length = sizeof( ClientView );
    ClientView.ViewSize = 0;
    ClientView.ViewBase = 0;
    ConnectionInformation->ServerProcessId = NtCurrentTeb()->ClientId.UniqueProcess;
    Status = NtAcceptConnectPort( &PortHandle,
                                  AcceptConnection ? (PVOID)UlongToPtr(Process->SequenceNumber) : 0,
                                  &Message->h,
                                  AcceptConnection,
                                  NULL,
                                  &ClientView
                                );
    if (NT_SUCCESS( Status ) && AcceptConnection) {
        IF_CSR_DEBUG( LPC ) {
            DbgPrint( "CSRSS: ClientId: %lx.%lx has ClientView: Base=%p, Size=%lx\n",
                      Message->h.ClientId.UniqueProcess,
                      Message->h.ClientId.UniqueThread,
                      ClientView.ViewBase,
                      ClientView.ViewSize
                    );
            }

        Process->ClientPort = PortHandle;
        Process->ClientViewBase = (PCH)ClientView.ViewBase;
        Process->ClientViewBounds = (PCH)ClientView.ViewBase +
                                         ClientView.ViewSize;
        Status = NtCompleteConnectPort( PortHandle );
        if (!NT_SUCCESS( Status )) {
            IF_DEBUG {
                DbgPrint( "CSRSS: NtCompleteConnectPort - failed.  Status == %X\n",
                          Status
                        );
                }
            // FIX, FIX - need to destroy Session
            }
        }
    else {
        if (!NT_SUCCESS( Status )) {
            IF_DEBUG {
                DbgPrint( "CSRSS: NtAcceptConnectPort - failed.  Status == %X\n",
                          Status
                        );
                }
            }
        else {
            IF_DEBUG {
                DbgPrint( "CSRSS: Rejecting Connection Request from ClientId: %lx.%lx\n",
                          Message->h.ClientId.UniqueProcess,
                          Message->h.ClientId.UniqueThread
                        );
                }
            }
        }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\stublibs\rsa32k\rsa32k.c ===
#include <stublib.h>

EX(A_SHAFinal)
EX(A_SHAFinalNS)
EX(A_SHAInit)
EX(A_SHAUpdate)
EX(A_SHAUpdateNS)
EX(CBC)
EX(DES_ECB_LM)
EX(HMACMD5Final)
EX(HMACMD5Init)
EX(HMACMD5Update)
EX(MD4Final)
EX(MD4Init)
EX(MD4Update)
EX(MD5Final)
EX(MD5Init)
EX(MD5Update)
EX(des)
EX(desexpand128to192)
EX(deskey)
EX(desx)
EX(desxkey)
EX(rc4)
EX(rc4_key)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\csrss\csrss.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    csrss.c

Abstract:

    This is the main startup module for the Server side of the Client
    Server Runtime Subsystem (CSRSS)

Author:

    Steve Wood (stevewo) 8-Oct-1990

Environment:

    User Mode Only

Revision History:

--*/

#include "csrsrv.h"

VOID
DisableErrorPopups(
    VOID
    )
{

    ULONG NewMode;

    NewMode = 0;
    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessDefaultHardErrorMode,
        (PVOID) &NewMode,
        sizeof(NewMode)
        );
}

int
_cdecl
main(
    IN ULONG argc,
    IN PCH argv[],
    IN PCH envp[],
    IN ULONG DebugFlag OPTIONAL
    )
{
    NTSTATUS status;
    ULONG ErrorResponse;
    KPRIORITY SetBasePriority;

    //
    // Force early creation of critical section events
    //
//    RtlEnableEarlyCriticalSectionEventCreation (); // Looping inside resource package now
    SetBasePriority = FOREGROUND_BASE_PRIORITY + 4;
    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );

    //
    // Give IOPL to the server so GDI and the display drivers can access the
    // video registers.
    //

    status = NtSetInformationProcess( NtCurrentProcess(),
				      ProcessUserModeIOPL,
				      NULL,
				      0 );

    if (!NT_SUCCESS( status )) {

	IF_DEBUG {

	    DbgPrint( "CSRSS: Unable to give IOPL to the server.  status == %X\n",
		      status);
	}

	status = NtRaiseHardError( (NTSTATUS)STATUS_IO_PRIVILEGE_FAILED,
				   0,
				   0,
				   NULL,
				   OptionOk,
				   &ErrorResponse
				   );
    }

    status = CsrServerInitialization( argc, argv );

    if (!NT_SUCCESS( status )) {
        IF_DEBUG {
	    DbgPrint( "CSRSS: Unable to initialize server.  status == %X\n",
		      status
                    );
            }

	NtTerminateProcess( NtCurrentProcess(), status );
        }
    DisableErrorPopups();

    if (NtCurrentPeb()->SessionId == 0) {
        //
        // Make terminating the root csrss fatal
        //
        RtlSetProcessIsCritical(TRUE, NULL, FALSE);
    }

    NtTerminateThread( NtCurrentThread(), status );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\sbapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sbapi.c

Abstract:

    This module contains the implementations of the Sb API calls exported
    by the Server side of the Client-Server Runtime Subsystem to the
    Session Manager SubSystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

#include "csrsrv.h"


BOOLEAN
CsrSbCreateSession(
    IN PSBAPIMSG Msg
    )
{
    PSBCREATESESSION a = &Msg->u.CreateSession;
    PCSR_PROCESS Process;
    PCSR_THREAD Thread;
    PVOID ProcessDataPtr;
    ULONG i;
    NTSTATUS Status;
    HANDLE ProcessHandle;
    HANDLE ThreadHandle;
    KERNEL_USER_TIMES TimeInfo;


    ProcessHandle = a->ProcessInformation.Process;
    ThreadHandle = a->ProcessInformation.Thread;

    AcquireProcessStructureLock();
    Process = CsrAllocateProcess();
    if (Process == NULL) {
        Msg->ReturnedStatus = STATUS_NO_MEMORY;
        ReleaseProcessStructureLock();
        return( TRUE );
        }

    Status = NtSetInformationProcess(
                ProcessHandle,
                ProcessExceptionPort,
                &CsrApiPort,
                sizeof(HANDLE)
                );
    if ( !NT_SUCCESS(Status) ) {
        CsrDeallocateProcess( Process );
        ReleaseProcessStructureLock();
        return( (BOOLEAN)STATUS_NO_MEMORY );
        }

    //
    // capture the thread's createtime so that we can use
    // this as a sequence number
    //

    Status = NtQueryInformationThread(
                ThreadHandle,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        CsrDeallocateProcess( Process );
        ReleaseProcessStructureLock();
        return( (BOOLEAN)Status );
        }

    Thread = CsrAllocateThread( Process );
    if (Thread == NULL) {
        CsrDeallocateProcess( Process );
        Msg->ReturnedStatus = STATUS_NO_MEMORY;
        ReleaseProcessStructureLock();
        return( TRUE );
        }

    Thread->CreateTime = TimeInfo.CreateTime;
    Thread->ClientId = a->ProcessInformation.ClientId;
    Thread->ThreadHandle = a->ProcessInformation.Thread;

ProtectHandle(Thread->ThreadHandle);

    Thread->Flags = 0;
    CsrInsertThread( Process, Thread );

    //
    // this needs a little more thought
    //
    Process->NtSession = CsrAllocateNtSession( a->SessionId );

    Process->ClientId = a->ProcessInformation.ClientId;
    Process->ProcessHandle = a->ProcessInformation.Process;

    CsrSetBackgroundPriority(Process);

    //
    // initialize each DLL's per process data area.
    //

    ProcessDataPtr = (PVOID)QUAD_ALIGN(&Process->ServerDllPerProcessData[CSR_MAX_SERVER_DLL]);
    for (i=0;i<CSR_MAX_SERVER_DLL;i++) {
        if (CsrLoadedServerDll[i] != NULL && CsrLoadedServerDll[i]->PerProcessDataLength) {
            Process->ServerDllPerProcessData[i] = ProcessDataPtr;
            ProcessDataPtr = (PVOID)QUAD_ALIGN((PCHAR)ProcessDataPtr + CsrLoadedServerDll[i]->PerProcessDataLength);
        }
        else {
            Process->ServerDllPerProcessData[i] = NULL;
        }
    }

    CsrInsertProcess( NULL, NULL, Process );
    Msg->ReturnedStatus = NtResumeThread( a->ProcessInformation.Thread,
                                          NULL
                                        );
    ReleaseProcessStructureLock();
    return( TRUE );
}

BOOLEAN
CsrSbTerminateSession(
    IN PSBAPIMSG Msg
    )
{
    PSBTERMINATESESSION a = &Msg->u.TerminateSession;

    Msg->ReturnedStatus = STATUS_NOT_IMPLEMENTED;
    return( TRUE );
}

BOOLEAN
CsrSbForeignSessionComplete(
    IN PSBAPIMSG Msg
    )
{
    PSBFOREIGNSESSIONCOMPLETE a = &Msg->u.ForeignSessionComplete;

    Msg->ReturnedStatus = STATUS_NOT_IMPLEMENTED;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\csrsrv.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    csrsrv.h

Abstract:

    Main include file for Server side of the Client Server Runtime (CSR)

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

//
// Include definitions common between the Client and Server portions.
//

#include "csr.h"

//
// Include definitions specific to the Server portion.
//

#include "ntcsrsrv.h"

#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"

//
// Define debugging flags and macro for testing them.  All debug code
// should be contained within a IF_CSR_DEBUG macro call so that when
// the system is compiled with debug code disabled, none of the code
// is generated.
//

#if DBG
#define CSR_DEBUG_INIT              0x00000001
#define CSR_DEBUG_LPC               0x00000002
#define CSR_DEBUG_FLAG3             0x00000004
#define CSR_DEBUG_FLAG4             0x00000008
#define CSR_DEBUG_FLAG5             0x00000010
#define CSR_DEBUG_FLAG6             0x00000020
#define CSR_DEBUG_FLAG7             0x00000040
#define CSR_DEBUG_FLAG8             0x00000080
#define CSR_DEBUG_FLAG9             0x00000100
#define CSR_DEBUG_FLAG10            0x00000200
#define CSR_DEBUG_FLAG11            0x00000400
#define CSR_DEBUG_FLAG12            0x00000800
#define CSR_DEBUG_FLAG13            0x00001000
#define CSR_DEBUG_FLAG14            0x00002000
#define CSR_DEBUG_FLAG15            0x00004000
#define CSR_DEBUG_FLAG16            0x00008000
#define CSR_DEBUG_FLAG17            0x00010000
#define CSR_DEBUG_FLAG18            0x00020000
#define CSR_DEBUG_FLAG19            0x00040000
#define CSR_DEBUG_FLAG20            0x00080000
#define CSR_DEBUG_FLAG21            0x00100000
#define CSR_DEBUG_FLAG22            0x00200000
#define CSR_DEBUG_FLAG23            0x00400000
#define CSR_DEBUG_FLAG24            0x00800000
#define CSR_DEBUG_FLAG25            0x01000000
#define CSR_DEBUG_FLAG26            0x02000000
#define CSR_DEBUG_FLAG27            0x04000000
#define CSR_DEBUG_FLAG28            0x08000000
#define CSR_DEBUG_FLAG29            0x10000000
#define CSR_DEBUG_FLAG30            0x20000000
#define CSR_DEBUG_FLAG31            0x40000000
#define CSR_DEBUG_FLAG32            0x80000000

ULONG CsrDebug;

#define IF_CSR_DEBUG( ComponentFlag ) \
    if (CsrDebug & (CSR_DEBUG_ ## ComponentFlag))

#define SafeBreakPoint()                    \
    if (NtCurrentPeb()->BeingDebugged) {    \
        DbgBreakPoint();                    \
    }

#else
#define IF_CSR_DEBUG( ComponentFlag ) if (FALSE)

#define SafeBreakPoint()

#endif

#if DBG

#define CSRSS_PROTECT_HANDLES 1

BOOLEAN
ProtectHandle(
    HANDLE hObject
    );

BOOLEAN
UnProtectHandle(
    HANDLE hObject
    );

#else

#define CSRSS_PROTECT_HANDLES 0

#define ProtectHandle( hObject )
#define UnProtectHandle( hObject )

#endif


//
// Event indicating the csr server has completed initialization.
//

HANDLE CsrInitializationEvent;

//
// Include NT Session Manager and Debug SubSystem Interfaces

#include <ntsm.h>
typedef BOOLEAN (*PSB_API_ROUTINE)( IN PSBAPIMSG SbApiMsg );

//
// Global data accessed by Client-Server Runtime Server
//

PVOID CsrHeap;

HANDLE CsrObjectDirectory;

#define CSR_SBAPI_PORT_NAME L"SbApiPort"

UNICODE_STRING CsrDirectoryName;
UNICODE_STRING CsrApiPortName;
UNICODE_STRING CsrSbApiPortName;

HANDLE CsrApiPort;
HANDLE CsrSbApiPort;
HANDLE CsrSmApiPort;

ULONG CsrMaxApiRequestThreads;

#define CSR_MAX_THREADS 16

#define CSR_STATIC_API_THREAD    0x00000010

PCSR_THREAD CsrSbApiRequestThreadPtr;

#define FIRST_SEQUENCE_COUNT   5

//
// Routines defined in srvinit.c
//


//
// Hydra Specific Globals and prototypes
//

#define SESSION_ROOT    L"\\Sessions"
#define DOSDEVICES      L"\\DosDevices"
#define MAX_SESSION_PATH   256
ULONG SessionId;
HANDLE SessionObjectDirectory;
HANDLE DosDevicesDirectory;
HANDLE BNOLinksDirectory;
HANDLE SessionsObjectDirectory;

NTSTATUS
CsrCreateSessionObjectDirectory( ULONG SessionID );

//
// The CsrNtSysInfo global variable contains NT specific constants of
// interest, such as page size, allocation granularity, etc.  It is filled
// in once during process initialization.
//

SYSTEM_BASIC_INFORMATION CsrNtSysInfo;

#define ROUND_UP_TO_PAGES(SIZE) (((ULONG)(SIZE) + CsrNtSysInfo.PageSize - 1) & ~(CsrNtSysInfo.PageSize - 1))
#define ROUND_DOWN_TO_PAGES(SIZE) (((ULONG)(SIZE)) & ~(CsrNtSysInfo.PageSize - 1))

#define QUAD_ALIGN(VALUE) ( ((ULONG_PTR)(VALUE) + 7) & ~7 )

NTSTATUS
CsrParseServerCommandLine(
    IN ULONG argc,
    IN PCH argv[]
    );

NTSTATUS
CsrServerDllInitialization(
    IN PCSR_SERVER_DLL LoadedServerDll
    );

NTSTATUS
CsrSrvUnusedFunction(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
CsrEnablePrivileges(
    VOID
    );


//
// Routines define in srvdebug.c
//

#if DBG

#else

#endif // DBG



//
// Routines defined in sbinit.c
//

NTSTATUS
CsrSbApiPortInitialize( VOID );


VOID
CsrSbApiPortTerminate(
    NTSTATUS Status
    );

//
// Routines defined in sbreqst.c
//

NTSTATUS
CsrSbApiRequestThread(
    IN PVOID Parameter
    );

//
// Routines defined in sbapi.c
//

BOOLEAN
CsrSbCreateSession(
    IN PSBAPIMSG Msg
    );

BOOLEAN
CsrSbTerminateSession(
    IN PSBAPIMSG Msg
    );

BOOLEAN
CsrSbForeignSessionComplete(
    IN PSBAPIMSG Msg
    );

//
// Routines defined in session.c
//

RTL_CRITICAL_SECTION CsrNtSessionLock;
LIST_ENTRY CsrNtSessionList;

#define LockNtSessionList() RtlEnterCriticalSection( &CsrNtSessionLock )
#define UnlockNtSessionList() RtlLeaveCriticalSection( &CsrNtSessionLock )

NTSTATUS
CsrInitializeNtSessionList( VOID );

PCSR_NT_SESSION
CsrAllocateNtSession(
    ULONG SessionId
    );

VOID
CsrReferenceNtSession(
    PCSR_NT_SESSION Session
    );

VOID
CsrDereferenceNtSession(
    PCSR_NT_SESSION Session,
    NTSTATUS ExitStatus
    );


//
// Routines defined in apiinit.c
//

NTSTATUS
CsrApiPortInitialize( VOID );


//
// Routines defined in apireqst.c
//

NTSTATUS
CsrApiRequestThread(
    IN PVOID Parameter
    );

BOOLEAN
CsrCaptureArguments(
    IN PCSR_THREAD t,
    IN PCSR_API_MSG m
    );

VOID
CsrReleaseCapturedArguments(
    IN PCSR_API_MSG m
    );

ULONG
CsrSrvNullApiCall(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


//
// Routines and data defined in srvloadr.c
//

#define CSR_MAX_SERVER_DLL 4

PCSR_SERVER_DLL CsrLoadedServerDll[ CSR_MAX_SERVER_DLL ];

ULONG CsrTotalPerProcessDataLength;
HANDLE CsrSrvSharedSection;
ULONG CsrSrvSharedSectionSize;
PVOID CsrSrvSharedSectionBase;
PVOID CsrSrvSharedSectionHeap;
PVOID *CsrSrvSharedStaticServerData;

#define CSR_BASE_PATH   L"\\REGISTRY\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\Subsystems\\CSRSS"
#define IsTerminalServer() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))


NTSTATUS
CsrLoadServerDll(
    IN PCH ModuleName,
    IN PCH InitRoutineString,
    IN ULONG ServerDllIndex
    );

ULONG
CsrSrvClientConnect(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


NTSTATUS
CsrSrvCreateSharedSection(
    IN PCH SizeParameter
    );


NTSTATUS
CsrSrvAttachSharedSection(
    IN PCSR_PROCESS Process OPTIONAL,
    OUT PCSR_API_CONNECTINFO p
    );

//
// Routines and data defined in process.c
//

//
// The CsrProcessStructureLock critical section protects all of the link
// fields of the Windows Process objects.  You must own this lock to examine
// or modify any of the following fields of the CSR_PROCESS structure:
//
//      ListLink
//
//  It also protects the following variables:
//
//      CsrRootProcess
//

RTL_CRITICAL_SECTION CsrProcessStructureLock;
#define AcquireProcessStructureLock() RtlEnterCriticalSection( &CsrProcessStructureLock )
#define ReleaseProcessStructureLock() RtlLeaveCriticalSection( &CsrProcessStructureLock )
#define ProcessStructureListLocked() \
    (CsrProcessStructureLock.OwningThread == NtCurrentTeb()->ClientId.UniqueThread)

//
// The following is a dummy process that acts as the root of the Windows Process
// Structure.  It has a ClientId of -1.-1 so it does not conflict with actual
// Windows Processes.  All processes created via the session manager are children
// of this process, as are all orphaned processes.  The ListLink field of this
// process is the head of a list of all Windows Processes.
//

PCSR_PROCESS CsrRootProcess;

//
// reference/dereference thread are public in ntcsrsrv.h
//

VOID
CsrLockedReferenceProcess(
    PCSR_PROCESS p
    );

VOID
CsrLockedReferenceThread(
    PCSR_THREAD t
    );

VOID
CsrLockedDereferenceProcess(
    PCSR_PROCESS p
    );

VOID
CsrLockedDereferenceThread(
    PCSR_THREAD t
    );

NTSTATUS
CsrInitializeProcessStructure( VOID );

PCSR_PROCESS
CsrAllocateProcess( VOID );

VOID
CsrDeallocateProcess(
    IN PCSR_PROCESS Process
    );

VOID
CsrInsertProcess(
    IN PCSR_PROCESS ParentProcess,
    IN PCSR_PROCESS CallingProcess,
    IN PCSR_PROCESS Process
    );

VOID
CsrRemoveProcess(
    IN PCSR_PROCESS Process
    );

PCSR_THREAD
CsrAllocateThread(
    IN PCSR_PROCESS Process
    );

VOID
CsrDeallocateThread(
    IN PCSR_THREAD Thread
    );

VOID
CsrInsertThread(
    IN PCSR_PROCESS Process,
    IN PCSR_THREAD Thread
    );

VOID
CsrRemoveThread(
    IN PCSR_THREAD Thread
    );

PCSR_THREAD
CsrLocateThreadByClientId(
    OUT PCSR_PROCESS *Process,
    IN PCLIENT_ID ClientId
    );

NTSTATUS
CsrUiLookup(
    IN PCLIENT_ID AppClientId,
    OUT PCLIENT_ID DebugUiClientId
    );

NTSTATUS
CsrSrvIdentifyAlertableThread(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
CsrSrvSetPriorityClass(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

//
// Routines and data defined in csrdebug.c
//

VOID
CsrSuspendProcess(
    IN PCSR_PROCESS Process
    );

VOID
CsrResumeProcess(
    IN PCSR_PROCESS Process
    );


//
// Routines and data defined in wait.c
//

#define AcquireWaitListsLock() RtlEnterCriticalSection( &CsrWaitListsLock )
#define ReleaseWaitListsLock() RtlLeaveCriticalSection( &CsrWaitListsLock )

RTL_CRITICAL_SECTION CsrWaitListsLock;

BOOLEAN
CsrInitializeWait(
    IN CSR_WAIT_ROUTINE WaitRoutine,
    IN PCSR_THREAD WaitingThread,
    IN OUT PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    OUT PCSR_WAIT_BLOCK *WaitBlockPtr
    );

BOOLEAN
CsrNotifyWaitBlock(
    IN PCSR_WAIT_BLOCK WaitBlock,
    IN PLIST_ENTRY WaitQueue,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags,
    IN BOOLEAN DereferenceThread
    );


ULONG CsrBaseTag;
ULONG CsrSharedBaseTag;

#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( CsrBaseTag, t ))

#define TMP_TAG 0
#define INIT_TAG 1
#define CAPTURE_TAG 2
#define PROCESS_TAG 3
#define THREAD_TAG 4
#define SECURITY_TAG 5
#define SESSION_TAG 6
#define WAIT_TAG 7

#define MAKE_SHARED_TAG( t ) (RTL_HEAP_MAKE_TAG( CsrSharedBaseTag, t ))
#define SHR_INIT_TAG 0

//
// Routines and data defined in process.c
//

BOOLEAN
CsrSbCreateProcess(
    IN OUT PSBAPIMSG m
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\sbinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sbinit.c

Abstract:

    This module contains the code to initialize the SbApiPort of the
    Server side of the Client-Server Runtime Subsystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Environment:

    User Mode Only

Revision History:

--*/

#include "csrsrv.h"

NTSTATUS
CsrCreateLocalSystemSD( PSECURITY_DESCRIPTOR *ppSD )
{
    NTSTATUS Status;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID pLocalSystemSid;
    ULONG Length;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pDacl;

    Status = RtlAllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0, 0, 0, 0, 0, 0, 0,
                &pLocalSystemSid
             );

    if (!NT_SUCCESS(Status)){
        pLocalSystemSid = NULL;
        goto CSR_CREATE_LOCAL_SYSTEM_SD_ERROR;
    }

    Length = SECURITY_DESCRIPTOR_MIN_LENGTH +
             (ULONG)sizeof(ACL) +
             (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
             RtlLengthSid( pLocalSystemSid );

    pSD = RtlAllocateHeap( CsrHeap, MAKE_TAG( TMP_TAG ), Length);

    if (pSD == NULL) {
        Status = STATUS_NO_MEMORY;
        goto CSR_CREATE_LOCAL_SYSTEM_SD_ERROR;
    }

    pDacl = (PACL)((PCHAR)pSD + SECURITY_DESCRIPTOR_MIN_LENGTH);

    Status = RtlCreateSecurityDescriptor(
                pSD,
                SECURITY_DESCRIPTOR_REVISION
             );

    if (!NT_SUCCESS(Status)){
        goto CSR_CREATE_LOCAL_SYSTEM_SD_ERROR;
    }

    Status = RtlCreateAcl(
                pDacl,
                Length - SECURITY_DESCRIPTOR_MIN_LENGTH,
                ACL_REVISION2
             );

    if (!NT_SUCCESS(Status)){
        goto CSR_CREATE_LOCAL_SYSTEM_SD_ERROR;
    }

    Status = RtlAddAccessAllowedAce (
                 pDacl,
                 ACL_REVISION2,
                 PORT_ALL_ACCESS,
                 pLocalSystemSid
             );

    if (!NT_SUCCESS(Status)){
        goto CSR_CREATE_LOCAL_SYSTEM_SD_ERROR;
    }

    Status = RtlSetDaclSecurityDescriptor (
                 pSD,
                 TRUE,
                 pDacl,
                 FALSE
             );

    if (NT_SUCCESS(Status)){
        *ppSD = pSD;
        goto CSR_CREATE_LOCAL_SYSTEM_SD_EXIT;
    }

CSR_CREATE_LOCAL_SYSTEM_SD_ERROR:

    if (pSD != NULL) {
        RtlFreeHeap( CsrHeap, 0, pSD );
    }

CSR_CREATE_LOCAL_SYSTEM_SD_EXIT:

    if (pLocalSystemSid != NULL) {
        RtlFreeSid( pLocalSystemSid );
    }

    return Status;
}

NTSTATUS
CsrSbApiPortInitialize( VOID )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Thread;
    CLIENT_ID ClientId;
    ULONG n;
    PSECURITY_DESCRIPTOR pCsrSbApiPortSD;

    n = CsrDirectoryName.Length +
        sizeof( CSR_SBAPI_PORT_NAME ) +
        sizeof( OBJ_NAME_PATH_SEPARATOR );
    CsrSbApiPortName.Buffer = RtlAllocateHeap( CsrHeap, MAKE_TAG( INIT_TAG ), n );
    if (CsrSbApiPortName.Buffer == NULL) {
        return( STATUS_NO_MEMORY );
        }
    CsrSbApiPortName.Length = 0;
    CsrSbApiPortName.MaximumLength = (USHORT)n;
    RtlAppendUnicodeStringToString( &CsrSbApiPortName, &CsrDirectoryName );
    RtlAppendUnicodeToString( &CsrSbApiPortName, L"\\" );
    RtlAppendUnicodeToString( &CsrSbApiPortName, CSR_SBAPI_PORT_NAME );

    IF_CSR_DEBUG( LPC ) {
        DbgPrint( "CSRSS: Creating %wZ port and associated thread\n",
                  &CsrSbApiPortName );
        }

    Status = CsrCreateLocalSystemSD( &pCsrSbApiPortSD );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    InitializeObjectAttributes( &ObjectAttributes, &CsrSbApiPortName, 0,
                                NULL, pCsrSbApiPortSD );
    Status = NtCreatePort( &CsrSbApiPort,
                           &ObjectAttributes,
                           sizeof( SBCONNECTINFO ),
                           sizeof( SBAPIMSG ),
                           sizeof( SBAPIMSG ) * 32
                         );

    if (pCsrSbApiPortSD != NULL) {
        RtlFreeHeap( CsrHeap, 0, pCsrSbApiPortSD );
    }

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = RtlCreateUserThread( NtCurrentProcess(),
                                  NULL,
                                  TRUE,
                                  0,
                                  0,
                                  0,
                                  CsrSbApiRequestThread,
                                  NULL,
                                  &Thread,
                                  &ClientId
                                );

    if (!NT_SUCCESS(Status)) {
        return Status;
    }


    CsrSbApiRequestThreadPtr = CsrAddStaticServerThread(Thread,&ClientId,0);

    Status = NtResumeThread( Thread, NULL );

    return( Status );
}


VOID
CsrSbApiPortTerminate(
    NTSTATUS Status
    )
{
    IF_CSR_DEBUG( LPC ) {
        DbgPrint( "CSRSS: Closing Sb port and associated thread\n" );
        }
    NtTerminateThread( CsrSbApiRequestThreadPtr->ThreadHandle,
                       Status
                     );

    NtClose( CsrSbApiPort );
    NtClose( CsrSmApiPort );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\srvinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvinit.c

Abstract:

    This is the main initialization module for the Server side of the Client
    Server Runtime Subsystem (CSRSS)

Author:

    Steve Wood (stevewo) 08-Oct-1990

Environment:

    User Mode Only

Revision History:

--*/

#include "csrsrv.h"
#include <windows.h>
#include <stdio.h>
#include <wow64reg.h>

PCSR_API_ROUTINE CsrServerApiDispatchTable[ CsrpMaxApiNumber ] = {
    (PCSR_API_ROUTINE)CsrSrvClientConnect,
    (PCSR_API_ROUTINE)CsrSrvUnusedFunction,
    (PCSR_API_ROUTINE)CsrSrvUnusedFunction,
    (PCSR_API_ROUTINE)CsrSrvIdentifyAlertableThread,
    (PCSR_API_ROUTINE)CsrSrvSetPriorityClass
};

BOOLEAN CsrServerApiServerValidTable[ CsrpMaxApiNumber ] = {
    TRUE,  // CsrSrvClientConnect,
    FALSE, // CsrSrvThreadConnect,
    TRUE,  // CsrSrvProfileControl,
    TRUE,  // CsrSrvIdentifyAlertableThread
    TRUE   // CsrSrvSetPriorityClass
};

#if DBG
PSZ CsrServerApiNameTable[ CsrpMaxApiNumber ] = {
    "ClientConnect",
    "ThreadConnect",
    "ProfileControl",
    "IdentifyAlertableThread",
    "SetPriorityClass"
};
#endif // DBG

NTSTATUS
CsrSetProcessSecurity(
    VOID
    );

NTSTATUS
CsrSetDirectorySecurity(
    IN HANDLE DirectoryHandle
    );

NTSTATUS
GetDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

VOID
FreeDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
CsrPopulateDosDevicesDirectory(
    HANDLE NewDirectoryHandle,
    PPROCESS_DEVICEMAP_INFORMATION pGlobalProcessDeviceMapInfo
    );



NTSTATUS
CsrServerInitialization(
    IN ULONG argc,
    IN PCH argv[]
    )
{
    NTSTATUS Status;
    ULONG i;
    PVOID ProcessDataPtr;
    PCSR_SERVER_DLL LoadedServerDll;
#if DBG
        BOOLEAN bIsRemoteSession =  NtCurrentPeb()->SessionId != 0;
#endif


        //
        // Initialize Wow64 stuffs
        //
#ifdef _WIN64
        InitializeWow64OnBoot(1);
#endif
        
        // Though this function does not seem to cleanup on failure, failure
        // will cause Csrss to exit, so any allocated memory will be freed and
        // any open handle will be closed.

    Status = NtCreateEvent(&CsrInitializationEvent,
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE
                           );
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }
    //
    // Save away system information in a global variable
    //

    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &CsrNtSysInfo,
                                       sizeof( CsrNtSysInfo ),
                                       NULL
                                     );
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }

    //
    // Use the process heap for memory allocation.
    //

    CsrHeap = RtlProcessHeap();
    CsrBaseTag = RtlCreateTagHeap( CsrHeap,
                                   0,
                                   L"CSRSS!",
                                   L"TMP\0"
                                   L"INIT\0"
                                   L"CAPTURE\0"
                                   L"PROCESS\0"
                                   L"THREAD\0"
                                   L"SECURITY\0"
                                   L"SESSION\0"
                                   L"WAIT\0"
                                 );


    //
    // Set up CSRSS process security
    //

    Status = CsrSetProcessSecurity();
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }

    //
    // Initialize the Session List
    //

    Status = CsrInitializeNtSessionList();
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }

    //
    // Initialize the Process List
    //

    Status = CsrInitializeProcessStructure();
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }

    //
    // Process the command line arguments
    //

    Status = CsrParseServerCommandLine( argc, argv );
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }


    //
    // Fix up per-process data for root process
    //

    ProcessDataPtr = (PCSR_PROCESS)RtlAllocateHeap( CsrHeap,
                                                    MAKE_TAG( PROCESS_TAG ) | HEAP_ZERO_MEMORY,
                                                    CsrTotalPerProcessDataLength
                                                  );

    if (ProcessDataPtr == NULL) {
                return STATUS_NO_MEMORY;
    }

    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
        LoadedServerDll = CsrLoadedServerDll[ i ];
        if (LoadedServerDll && LoadedServerDll->PerProcessDataLength) {
            CsrRootProcess->ServerDllPerProcessData[i] = ProcessDataPtr;
            ProcessDataPtr = (PVOID)QUAD_ALIGN((PCHAR)ProcessDataPtr + LoadedServerDll->PerProcessDataLength);
        }
        else {
            CsrRootProcess->ServerDllPerProcessData[i] = NULL;
        }
    }

    //
    // Let server dlls know about the root process.
    //

    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
        LoadedServerDll = CsrLoadedServerDll[ i ];
        if (LoadedServerDll && LoadedServerDll->AddProcessRoutine) {
            (*LoadedServerDll->AddProcessRoutine)( NULL, CsrRootProcess );
            }
        }

    //
    // Initialize the Windows Server API Port, and one or more
    // request threads.
    //

    Status = CsrApiPortInitialize();
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }

    //
    // Initialize the Server Session Manager API Port and one
    // request thread.
    //

    Status = CsrSbApiPortInitialize();
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession);
    if (!NT_SUCCESS( Status )) {
                return Status;

        }

    //
    // Connect to the session manager so we can start foreign sessions
    //

    Status = SmConnectToSm( &CsrSbApiPortName,
                            CsrSbApiPort,
                            IMAGE_SUBSYSTEM_WINDOWS_GUI,
                            &CsrSmApiPort
                          );
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }

    Status = NtSetEvent(CsrInitializationEvent,NULL);
    ASSERT( NT_SUCCESS( Status ) || bIsRemoteSession );
    if (!NT_SUCCESS( Status )) {
                return Status;

        }
    NtClose(CsrInitializationEvent);

    //
    //  Only on Console (HYDRA)
    //
    if (NtCurrentPeb()->SessionId == 0)
        Status = NtSetDefaultHardErrorPort(CsrApiPort);

    return( Status );
}

NTSTATUS
CsrParseServerCommandLine(
    IN ULONG argc,
    IN PCH argv[]
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG i, ServerDllIndex;
    PCH KeyName, KeyValue, s;
    PCH InitRoutine;

    CsrTotalPerProcessDataLength = 0;
    CsrObjectDirectory = NULL;
    CsrMaxApiRequestThreads = CSR_MAX_THREADS;


    SessionId = NtCurrentPeb()->SessionId;


    //
    // Create session specific object directories
    //


    Status = CsrCreateSessionObjectDirectory ( SessionId );

    if (!NT_SUCCESS(Status)) {

       if (SessionId == 0) {
           ASSERT( NT_SUCCESS( Status ) );
           DbgPrint("CSRSS: CsrCreateSessionObjectDirectory failed status = %lx\n", Status);
       } else {
           DbgPrint("CSRSS: CsrCreateSessionObjectDirectory failed status = %lx\n", Status);
           return Status;
       }
    }


    for (i=1; i<argc ; i++) {
        KeyName = argv[ i ];
        KeyValue = NULL;
        while (*KeyName) {
            if (*KeyName == '=') {
                *KeyName++ = '\0';
                KeyValue = KeyName;
                break;
                }

            KeyName++;
            }
        KeyName = argv[ i ];

        if (!_stricmp( KeyName, "ObjectDirectory" )) {
            ANSI_STRING AnsiString;
            ULONG attributes;
            CHAR SessionDirectory[MAX_SESSION_PATH];


            if (SessionId != 0) {

               //
               // Non-Console session
               //

              sprintf(SessionDirectory,"%ws\\%ld",SESSION_ROOT,SessionId);
              strcat(SessionDirectory,KeyValue);

            }

            //
            // Create an object directory in the object name space with the
            // name specified.   It will be the root for all object names
            // created by the Server side of the Client Server Runtime
            // SubSystem.
            //
            attributes =  OBJ_OPENIF | OBJ_CASE_INSENSITIVE;

            if (SessionId == 0) {
               attributes |= OBJ_PERMANENT;
               RtlInitString( &AnsiString, KeyValue );
            } else {
               RtlInitString( &AnsiString, SessionDirectory );
            }

            Status = RtlAnsiStringToUnicodeString( &CsrDirectoryName, &AnsiString, TRUE );
            ASSERT(NT_SUCCESS(Status) || SessionId != 0);
            if (!NT_SUCCESS( Status )) {
                break;
            }
            InitializeObjectAttributes( &ObjectAttributes,
                                        &CsrDirectoryName,
                                        attributes,
                                        NULL,
                                        NULL
                                      );
            Status = NtCreateDirectoryObject( &CsrObjectDirectory,
                                              DIRECTORY_ALL_ACCESS,
                                              &ObjectAttributes
                                            );
            if (!NT_SUCCESS( Status )) {
                break;
                }
            Status = CsrSetDirectorySecurity( CsrObjectDirectory );
            if (!NT_SUCCESS( Status )) {
                break;
                }
            }
        else
        if (!_stricmp( KeyName, "SubSystemType" )) {
            }
        else
        if (!_stricmp( KeyName, "MaxRequestThreads" )) {
            Status = RtlCharToInteger( KeyValue,
                                       0,
                                       &CsrMaxApiRequestThreads
                                     );
            }
        else
        if (!_stricmp( KeyName, "RequestThreads" )) {
#if 0
            Status = RtlCharToInteger( KeyValue,
                                       0,
                                       &CsrNumberApiRequestThreads
                                     );
#else
            //
            // wait until hive change !
            //

            Status = STATUS_SUCCESS;

#endif
            }
        else
        if (!_stricmp( KeyName, "ProfileControl" )) {
            }
        else
        if (!_stricmp( KeyName, "SharedSection" )) {
            Status = CsrSrvCreateSharedSection( KeyValue );
            if (!NT_SUCCESS( Status )) {
                IF_DEBUG {
                    DbgPrint( "CSRSS: *** Invalid syntax for %s=%s (Status == %X)\n",
                              KeyName,
                              KeyValue,
                              Status
                            );
                    }
                                return Status;
                }
            Status = CsrLoadServerDll( "CSRSS", NULL, CSRSRV_SERVERDLL_INDEX );
            }
        else
        if (!_stricmp( KeyName, "ServerDLL" )) {
            s = KeyValue;
            InitRoutine = NULL;

            Status = STATUS_INVALID_PARAMETER;
            while (*s) {
                if ((*s == ':') && (InitRoutine == NULL)) {
                    *s++ = '\0';
                    InitRoutine = s;
                }

                if (*s++ == ',') {
                    Status = RtlCharToInteger ( s, 10, &ServerDllIndex );
                    if (NT_SUCCESS( Status )) {
                        s[ -1 ] = '\0';
                        }

                    break;
                    }
                }

            if (!NT_SUCCESS( Status )) {
                IF_DEBUG {
                    DbgPrint( "CSRSS: *** Invalid syntax for ServerDll=%s (Status == %X)\n",
                              KeyValue,
                              Status
                            );
                    }
                }
            else {
                IF_CSR_DEBUG( INIT) {
                    DbgPrint( "CSRSS: Loading ServerDll=%s:%s\n", KeyValue, InitRoutine );
                    }

                Status = CsrLoadServerDll( KeyValue, InitRoutine, ServerDllIndex);

                if (!NT_SUCCESS( Status )) {
                    IF_DEBUG {
                        DbgPrint( "CSRSS: *** Failed loading ServerDll=%s (Status == 0x%x)\n",
                                  KeyValue,
                                  Status
                                );
                        }
                    return Status;
                    }
                }
            }
        else
        //
        // This is a temporary hack until Windows & Console are friends.
        //
        if (!_stricmp( KeyName, "Windows" )) {
            }
        else {
            Status = STATUS_INVALID_PARAMETER;
            }
        }

    return( Status );
}


NTSTATUS
CsrServerDllInitialization(
    IN PCSR_SERVER_DLL LoadedServerDll
    )
{
    LoadedServerDll->ApiNumberBase = CSRSRV_FIRST_API_NUMBER;
    LoadedServerDll->MaxApiNumber = CsrpMaxApiNumber;
    LoadedServerDll->ApiDispatchTable = CsrServerApiDispatchTable;
    LoadedServerDll->ApiServerValidTable = CsrServerApiServerValidTable;
#if DBG
    LoadedServerDll->ApiNameTable = CsrServerApiNameTable;
#else
    LoadedServerDll->ApiNameTable = NULL;
#endif
    LoadedServerDll->PerProcessDataLength = 0;
    LoadedServerDll->ConnectRoutine = NULL;
    LoadedServerDll->DisconnectRoutine = NULL;

    return( STATUS_SUCCESS );
}

NTSTATUS
CsrSrvUnusedFunction(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    IF_DEBUG {
        DbgPrint("CSRSS: Calling obsolete function %x\n", m->ApiNumber);
        }
    return STATUS_INVALID_PARAMETER;
}


NTSTATUS
CsrSetProcessSecurity(
    VOID
    )
{
    HANDLE Token;
    NTSTATUS Status;
    PTOKEN_USER User = NULL;
    ULONG LengthSid, Length;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    PACL Dacl;

    //
    // Open the token and get the system sid
    //

    Status = NtOpenProcessToken( NtCurrentProcess(),
                                 TOKEN_QUERY,
                                 &Token
                               );
    if (!NT_SUCCESS(Status)) {
        return Status;
        }

    NtQueryInformationToken( Token,
                             TokenUser,
                             NULL,
                             0,
                             &Length
                           );
    User = (PTOKEN_USER)RtlAllocateHeap( CsrHeap,
                                         MAKE_TAG( SECURITY_TAG ) | HEAP_ZERO_MEMORY,
                                         Length
                                       );
        if (User == NULL) {
                Status = STATUS_NO_MEMORY;
                goto error_cleanup;
        }
    Status = NtQueryInformationToken( Token,
                                      TokenUser,
                                      User,
                                      Length,
                                      &Length
                                    );

    NtClose( Token );
    if (!NT_SUCCESS(Status)) {
        RtlFreeHeap( CsrHeap, 0, User );
        return Status;
        }
    LengthSid = RtlLengthSid( User->User.Sid );

    //
    // Allocate a buffer to hold the SD
    //

    SecurityDescriptor = RtlAllocateHeap( CsrHeap,
                                          MAKE_TAG( SECURITY_TAG ) | HEAP_ZERO_MEMORY,
                                          SECURITY_DESCRIPTOR_MIN_LENGTH +
                                          sizeof(ACL) + LengthSid +
                                          sizeof(ACCESS_ALLOWED_ACE)
                                        );
        if (SecurityDescriptor == NULL) {
                Status = STATUS_NO_MEMORY;
                goto error_cleanup;
        }

    Dacl = (PACL)((PCHAR)SecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);


    //
    // Create the SD
    //

    Status = RtlCreateSecurityDescriptor(SecurityDescriptor,
                                         SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: SD creation failed - status = %lx\n", Status);
            }
        goto error_cleanup;
    }
    RtlCreateAcl( Dacl,
                  sizeof(ACL) + LengthSid + sizeof(ACCESS_ALLOWED_ACE),
                  ACL_REVISION2
                );
    Status = RtlAddAccessAllowedAce( Dacl,
                ACL_REVISION,
                ( PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION |
                  PROCESS_DUP_HANDLE | PROCESS_TERMINATE | PROCESS_SET_PORT |
                  READ_CONTROL | PROCESS_QUERY_INFORMATION ),
                User->User.Sid
                );
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: ACE creation failed - status = %lx\n", Status);
            }
        goto error_cleanup;
    }


    //
    // Set DACL to NULL to deny all access
    //

    Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor,
                                          TRUE,
                                          Dacl,
                                          FALSE);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: set DACL failed - status = %lx\n", Status);
            }
        goto error_cleanup;
    }

    //
    // Put the DACL onto the process
    //

    Status = NtSetSecurityObject(NtCurrentProcess(),
                                 DACL_SECURITY_INFORMATION,
                                 SecurityDescriptor);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: set process DACL failed - status = %lx\n", Status);
            }
    }

    //
    // Cleanup
    //

error_cleanup:
        if (SecurityDescriptor != NULL) {
        RtlFreeHeap( CsrHeap, 0, SecurityDescriptor );
        }
        if (User != NULL) {
        RtlFreeHeap( CsrHeap, 0, User );
        }

    return Status;
}

NTSTATUS
CsrSetDirectorySecurity(
    IN HANDLE DirectoryHandle
    )
{
    PSID WorldSid = NULL;
    PSID SystemSid = NULL;
    SID_IDENTIFIER_AUTHORITY WorldAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    ULONG AclLength;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    PACL Dacl;

    //
    // Get the SIDs for world and system
    //

    Status = RtlAllocateAndInitializeSid( &WorldAuthority,
                                          1,
                                          SECURITY_WORLD_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &WorldSid
                                        );
    if (!NT_SUCCESS(Status)) {
        goto error_cleanup;
        }

    Status = RtlAllocateAndInitializeSid( &NtAuthority,
                                          1,
                                          SECURITY_LOCAL_SYSTEM_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &SystemSid
                                        );
    if (!NT_SUCCESS(Status)) {
        goto error_cleanup;
        }

    //
    // Allocate a buffer to hold the SD
    //

    AclLength = sizeof(ACL) +
                RtlLengthSid( WorldSid ) +
                RtlLengthSid( SystemSid ) +
                2 * sizeof(ACCESS_ALLOWED_ACE);

    SecurityDescriptor = RtlAllocateHeap( CsrHeap,
                                          MAKE_TAG( SECURITY_TAG ) | HEAP_ZERO_MEMORY,
                                          SECURITY_DESCRIPTOR_MIN_LENGTH +
                                          AclLength
                                        );
    if (SecurityDescriptor == NULL) {
        Status = STATUS_NO_MEMORY;
        goto error_cleanup;
        }

    //
    // Create the SD
    //

    Status = RtlCreateSecurityDescriptor(SecurityDescriptor,
                                         SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: SD creation failed - status = %lx\n", Status);
            }
        goto error_cleanup;
    }

    //
    // Create the DACL
    //

    Dacl = (PACL)((PCHAR)SecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);

    RtlCreateAcl( Dacl,
                  AclLength,
                  ACL_REVISION
                );
    Status = RtlAddAccessAllowedAce( Dacl,
                ACL_REVISION,
                STANDARD_RIGHTS_READ | DIRECTORY_QUERY | DIRECTORY_TRAVERSE,
                WorldSid
                );
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: ACE creation failed - status = %lx\n", Status);
            }
        goto error_cleanup;
    }

    Status = RtlAddAccessAllowedAce( Dacl,
                ACL_REVISION,
                DIRECTORY_ALL_ACCESS,
                SystemSid
                );
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: ACE creation failed - status = %lx\n", Status);
            }
        goto error_cleanup;
    }

    //
    // Set DACL into the SD
    //

    Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor,
                                          TRUE,
                                          Dacl,
                                          FALSE);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: set DACL failed - status = %lx\n", Status);
            }
        goto error_cleanup;
    }

    //
    // Put the DACL onto the direcory
    //

    Status = NtSetSecurityObject(DirectoryHandle,
                                 DACL_SECURITY_INFORMATION,
                                 SecurityDescriptor);
    if (!NT_SUCCESS(Status)) {
        IF_DEBUG {
            DbgPrint("CSRSS: set directory DACL failed - status = %lx\n", Status);
            }
    }

    //
    // Cleanup
    //

error_cleanup:
    if (SecurityDescriptor != NULL) {
        RtlFreeHeap( CsrHeap, 0, SecurityDescriptor );
        }
    if (WorldSid != NULL) {
        RtlFreeSid( WorldSid );
        }
    if (SystemSid != NULL) {
        RtlFreeSid( SystemSid );
        }

    return Status;
}

/*******************************************************************************
 *
 *  CsrPopulateDosDevices
 *
 *  Populate the new session specific DosDevices Directory. This is an
 *  export called by ntuser\server when a connection is completed.
 *
 *  The security descriptor on the sessions \DosDevices should already
 *  have been set.
 *
 * ENTRY:
 *   HANDLE NewDosDevicesDirectory - Session specific DosDevices Directory
 *   PPROCESS_DEVICEMAP_INFORMATION pGlobalProcessDeviceMapInfo
 *
 * EXIT:
 *   STATUS_SUCCESS
 *
 ******************************************************************************/
NTSTATUS
CsrPopulateDosDevices(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;
    PROCESS_DEVICEMAP_INFORMATION GlobalProcessDeviceMapInfo;

    //
    // Get the global ProcessDeviceMap. We will use this to only add
    // non-network drive letters to the session specific dos devices
    // directory
    //

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessDeviceMap,
                                        &GlobalProcessDeviceMapInfo.Query,
                                        sizeof( GlobalProcessDeviceMapInfo.Query ),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtQueryInformationProcess failed in CsrPopulateDosDevices - status = %lx\n", Status);
       return Status;

    }

    //
    //  Set the CSRSS's ProcessDeviceMap to the newly created DosDevices Directory
    //

    ProcessDeviceMapInfo.Set.DirectoryHandle = DosDevicesDirectory;

    Status = NtSetInformationProcess( NtCurrentProcess(),
                                      ProcessDeviceMap,
                                      &ProcessDeviceMapInfo.Set,
                                      sizeof( ProcessDeviceMapInfo.Set )
                                    );
    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtSetInformationProcess failed in CsrPopulateDosDevices - status = %lx\n", Status);
       return Status;

    }

    //
    // Populate the session specfic DosDevices Directory
    //

    Status = CsrPopulateDosDevicesDirectory( DosDevicesDirectory, &GlobalProcessDeviceMapInfo );

    return Status;
}


/*******************************************************************************
 *
 *  CsrPopulateDosDevicesDirectory
 *
 *  Populate the new session specific DosDevices Direcotory
 *
 * ENTRY:
 *   HANDLE NewDosDevicesDirectory - Session specific DosDevices Directory
 *   PPROCESS_DEVICEMAP_INFORMATION pGlobalProcessDeviceMapInfo
 *
 * EXIT:
 *   STATUS_SUCCESS
 *
 ******************************************************************************/
NTSTATUS
CsrPopulateDosDevicesDirectory( HANDLE NewDirectoryHandle,
                                PPROCESS_DEVICEMAP_INFORMATION pGlobalProcessDeviceMapInfo )
{

    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING Target;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle = NULL;
    HANDLE LinkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    ULONG DirInfoBufferLength = 16384; //16K
    PVOID DirInfoBuffer = NULL;
    WCHAR lpTargetPath[ 4096 ];
    ULONG Context;
    ULONG ReturnedLength = 0;
    ULONG DosDeviceDriveIndex = 0;
    WCHAR DosDeviceDriveLetter;

    //
    // Open the global DosDevices Directory. This used to populate the
    // the session specific DosDevices Directory
    //
    RtlInitUnicodeString( &UnicodeString, L"\\GLOBAL??" );

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );
    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtOpenDirectoryObject failed in CsrPopulateDosDevicesDirectory - status = %lx\n", Status);
       return Status;
    }




Restart:

    Context = 0;

    DirInfoBuffer = RtlAllocateHeap( CsrHeap,
                                     MAKE_TAG( PROCESS_TAG ) | HEAP_ZERO_MEMORY,
                                     DirInfoBufferLength
                                     );

    if (DirInfoBuffer == NULL) {
       Status =  STATUS_NO_MEMORY;
       goto cleanup;
    }


    while (TRUE) {

       DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;

       Status = NtQueryDirectoryObject( DirectoryHandle,
                                       (PVOID)DirInfo,
                                       DirInfoBufferLength,
                                       FALSE,
                                       FALSE,
                                       &Context,
                                       &ReturnedLength
                                     );


       //
       //  Check the status of the operation.
       //

       if (!NT_SUCCESS( Status )) {
               if (Status == STATUS_BUFFER_TOO_SMALL) {
                    DirInfoBufferLength = ReturnedLength;
                    RtlFreeHeap( CsrHeap, 0, DirInfoBuffer );
                    goto Restart;
               }

               if (Status == STATUS_NO_MORE_ENTRIES) {
                   Status = STATUS_SUCCESS;
                   }

               break;
       }

       while (DirInfo->Name.Length != 0) {


           if (!wcscmp( DirInfo->TypeName.Buffer, L"SymbolicLink" )) {




              InitializeObjectAttributes( &Attributes,
                                          &DirInfo->Name,
                                          OBJ_CASE_INSENSITIVE,
                                          DirectoryHandle,
                                          NULL
                                        );

              Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                                 SYMBOLIC_LINK_QUERY,
                                                 &Attributes
                                               );
              if (NT_SUCCESS( Status )) {
                  Target.Buffer = lpTargetPath;
                  Target.Length = 0;
                  Target.MaximumLength = 4096;
                  ReturnedLength = 0;
                  Status = NtQuerySymbolicLinkObject( LinkHandle,
                                                      &Target,
                                                      &ReturnedLength
                                                    );
                  NtClose( LinkHandle );
                  if (NT_SUCCESS( Status )) {

                      //
                      // We only want to add Non-DOSDEVICE_DRIVE_REMOTE symbolic
                      // links to the session specific directory
                      //
                      if ((DirInfo->Name.Length == 2 * sizeof( WCHAR )) &&
                          (DirInfo->Name.Buffer[ 1 ] == L':')) {

                          DosDeviceDriveLetter = RtlUpcaseUnicodeChar( DirInfo->Name.Buffer[ 0 ] );

                          if ((DosDeviceDriveLetter >= L'A') && (DosDeviceDriveLetter <= L'Z')) {

                              DosDeviceDriveIndex = DosDeviceDriveLetter - L'A';
                              if ( (
                                       (pGlobalProcessDeviceMapInfo->Query.DriveType[DosDeviceDriveIndex] == DOSDEVICE_DRIVE_REMOTE)
                                       &&
                                       !(
                                           //Need to populate the Netware gateway drive
                                           ((Target.Length >= 13) && ((_wcsnicmp(Target.Buffer,L"\\Device\\NwRdr",13)==0)))
                                           &&
                                           ((Target.Length >= 16) && (Target.Buffer[15] != L':'))
                                       )
                                   )
                                   ||
                                   (
                                       (pGlobalProcessDeviceMapInfo->Query.DriveType[DosDeviceDriveIndex] == DOSDEVICE_DRIVE_CALCULATE)
                                       &&
                                       (
                                           ((Target.Length > 4) && (!_wcsnicmp(Target.Buffer,L"\\??\\",4)))
                                           ||
                                           ((Target.Length >= 14) && (!_wcsnicmp(Target.Buffer,L"\\Device\\WinDfs",14)))
                                       )
                                   )
                                 )

                              {
                                   //Skip remote drives and virtual drives (subst)
                                   DirInfo = (POBJECT_DIRECTORY_INFORMATION)(((PUCHAR) DirInfo) + sizeof(OBJECT_DIRECTORY_INFORMATION));
                                   continue;
                              }
                          }
                      }

                     //
                     // Create the new Symbolic Link
                     //
                     // The security on the new link is inherited
                     // from the parent directory, which is setup
                     // at create time.
                     //

                     InitializeObjectAttributes( &Attributes,
                                                 &DirInfo->Name,
                                                 0,
                                                 NewDirectoryHandle,
                                                 NULL // Default security
                                                 );

                     Target.MaximumLength = Target.Length + sizeof( WCHAR );

                     Attributes.Attributes |= OBJ_PERMANENT;

                     Status = NtCreateSymbolicLinkObject( &LinkHandle,
                                                          SYMBOLIC_LINK_ALL_ACCESS,
                                                          &Attributes,
                                                          &Target
                                                        );

                     Target.MaximumLength = 4096;

                     // Don't close the handles. Cleaned up when CSRSS goes away


                     if (!NT_SUCCESS( Status )) {
#if DBG
                            DbgPrint("CSRSS: Symbolic link creation failed in CsrPopulateDosDevicesDirectory for Name %ws and Target %ws- status = %lx for Session %ld\n", DirInfo->Name.Buffer, Target.Buffer, Status,NtCurrentPeb()->SessionId);
#endif
                            ASSERT(FALSE);
                     }
                     else {
                         NtClose( LinkHandle );
                     }

                  }
              }
           }

           DirInfo = (POBJECT_DIRECTORY_INFORMATION)(((PUCHAR) DirInfo) + sizeof(OBJECT_DIRECTORY_INFORMATION));
       }
    }

cleanup:

     if (DirectoryHandle) {
        NtClose(DirectoryHandle);
     }

     if (DirInfoBuffer) {
        RtlFreeHeap( CsrHeap, 0, DirInfoBuffer );
     }

     return Status;
}


/*******************************************************************************
 *
 *  CsrCreateSessionObjectDirectory
 *
 *  Creates \Sessions\<SessionId> and \Sessions\<SessionId>\DosDevices
 *  Object Directories
 *
 * ENTRY:
 *   ULONG SessionId
 *
 * EXIT:
 *   STATUS_SUCCESS
 *
 ******************************************************************************/
NTSTATUS
CsrCreateSessionObjectDirectory( ULONG SessionId )
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR szString[MAX_SESSION_PATH];
    WCHAR szTargetString[MAX_SESSION_PATH];
    UNICODE_STRING UnicodeString, LinkTarget;
    OBJECT_ATTRIBUTES Obja;
    HANDLE SymbolicLinkHandle;
    SECURITY_DESCRIPTOR DosDevicesSD;


    /*
     *   \Sessions\BNOLINKS\0 -> \BaseNamedObjects
     *   \Sessions\BNOLINKS\6 -> \Sessions\6\BaseNamedObjects
     *   \Sessions\BNOLINKS\7 -> \Sessions\7\BaseNamedObjects
     */


    //
    //Create/Open the \\Sessions\BNOLINKS directory
    //
    swprintf(szString,L"%ws\\BNOLINKS",SESSION_ROOT);

    RtlInitUnicodeString( &UnicodeString, szString );

    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                NULL,
                                NULL
                              );

    Status = NtCreateDirectoryObject( &BNOLinksDirectory,
                                      DIRECTORY_ALL_ACCESS,
                                      &Obja
                                    );

    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtCreateDirectoryObject failed in CsrCreateSessionObjectDirectory - status = %lx\n", Status);
       return Status;

    }

    //
    // Create a symbolic link \\Sessions\BNOLINKS\<sessionid> pointing
    // to the session specific BaseNamedObjects directory
    // This symbolic link will be used by proccesses that want to e.g. access a
    // event in another session. This will be done by using the following
    // naming convention : Session\\<sessionid>\\ObjectName
    //

    swprintf(szString,L"%ld",SessionId);

    RtlInitUnicodeString( &UnicodeString, szString );

    if (SessionId == 0) {

       RtlInitUnicodeString( &LinkTarget, L"\\BaseNamedObjects" );

    } else {

        swprintf(szTargetString,L"%ws\\%ld\\BaseNamedObjects",SESSION_ROOT,SessionId);
        RtlInitUnicodeString(&LinkTarget, szTargetString);

    }

    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                (HANDLE)BNOLinksDirectory,
                                NULL);

    Status = NtCreateSymbolicLinkObject( &SymbolicLinkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &Obja,
                                         &LinkTarget );

    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtCreateSymbolicLinkObject failed in CsrCreateSessionObjectDirectory - status = %lx\n", Status);
       return Status;

    }

    //
    //  Create the security descriptor to use for the object directories
    //

    Status = GetDosDevicesProtection( &DosDevicesSD );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    // Create the Sessions\\<sessionid directory
    //

    swprintf(szString,L"%ws\\%ld",SESSION_ROOT,SessionId);

    RtlInitUnicodeString( &UnicodeString, szString );

    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                NULL,
                                &DosDevicesSD
                              );

    Status = NtCreateDirectoryObject( &SessionObjectDirectory,
                                      DIRECTORY_ALL_ACCESS,
                                      &Obja
                                    );
    if (!NT_SUCCESS( Status )) {
       DbgPrint("CSRSS: NtCreateDirectoryObject failed in CsrCreateSessionObjectDirectory - status = %lx\n", Status);
       FreeDosDevicesProtection( &DosDevicesSD );
       return Status;

    }

    RtlInitUnicodeString( &UnicodeString, L"DosDevices" );

    InitializeObjectAttributes( &Obja,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                SessionObjectDirectory,
                                &DosDevicesSD
                              );

    //
    // Create the Session specific DosDevices Directory
    //

    Status = NtCreateDirectoryObject( &DosDevicesDirectory,
                                      DIRECTORY_ALL_ACCESS,
                                      &Obja
                                    );
    if (!NT_SUCCESS( Status )) {
         DbgPrint("CSRSS: NtCreateDirectoryObject failed in CsrCreateSessionObjectDirectory - status = %lx\n", Status);
         FreeDosDevicesProtection( &DosDevicesSD );
         return Status;

    }

    FreeDosDevicesProtection( &DosDevicesSD );
    return Status;
}


NTSTATUS
GetDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine builds a security descriptor for use in creating
    the \DosDevices object directory.  The protection of \DosDevices
    must establish inheritable protection which will dictate how
    dos devices created via the DefineDosDevice() and
    IoCreateUnprotectedSymbolicLink() apis can be managed.

    The protection assigned is dependent upon an administrable registry
    key:

        Key: \hkey_local_machine\System\CurrentControlSet\Control\Session Manager
        Value: [REG_DWORD] ProtectionMode

    If this value is 0x1, then

            Administrators may control all Dos devices,
            Anyone may create new Dos devices (such as net drives
                or additional printers),
            Anyone may use any Dos device,
            The creator of a Dos device may delete it.
            Note that this protects system-defined LPTs and COMs so that only
                administrators may redirect them.  However, anyone may add
                additional printers and direct them to wherever they would
                like.

           This is achieved with the following protection for the DosDevices
           Directory object:

                    Grant:  World:   Execute | Read | Write (No Inherit)
                    Grant:  System:  All Access             (No Inherit)
                    Grant:  World:   Execute                (Inherit Only)
                    Grant:  Admins:  All Access             (Inherit Only)
                    Grant:  System:  All Access             (Inherit Only)
                    Grant:  Owner:   All Access             (Inherit Only)

    If this value is 0x0, or not present, then

            Administrators may control all Dos devices,
            Anyone may create new Dos devices (such as net drives
                or additional printers),
            Anyone may use any Dos device,
            Anyone may delete Dos devices created with either DefineDosDevice()
                or IoCreateUnprotectedSymbolicLink().  This is how network drives
                and LPTs are created (but not COMs).

           This is achieved with the following protection for the DosDevices
           Directory object:

                    Grant:  World:   Execute | Read | Write (No Inherit)
                    Grant:  System:  All Access             (No Inherit)
                    Grant:  World:   All Access             (Inherit Only)


Arguments:

    SecurityDescriptor - The address of a security descriptor to be
        initialized and filled in.  When this security descriptor is no
        longer needed, you should call FreeDosDevicesProtection() to
        free the protection information.


Return Value:

    Returns one of the following status codes:

        STATUS_SUCCESS - normal, successful completion.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG aceIndex, aclLength;
    PACL dacl = NULL;
    PACE_HEADER ace;
    ACCESS_MASK accessMask;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID LocalSystemSid;
    PSID WorldSid;
    PSID CreatorOwnerSid;
    PSID AliasAdminsSid;
    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES Obja;
    ULONG ProtectionMode = 0;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    WCHAR ValueBuffer[ 32 ];
    ULONG ResultLength;
    HANDLE KeyHandle;

    UCHAR inheritOnlyFlags = (OBJECT_INHERIT_ACE    |
                              CONTAINER_INHERIT_ACE |
                              INHERIT_ONLY_ACE
                             );

    UCHAR inheritFlags = (OBJECT_INHERIT_ACE    |
                          CONTAINER_INHERIT_ACE
                         );


    Status = RtlCreateSecurityDescriptor( SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );

    if (!NT_SUCCESS( Status )) {
        ASSERT( NT_SUCCESS( Status ) );
        return( Status );
    }

    Status = RtlAllocateAndInitializeSid(
                 &NtAuthority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &LocalSystemSid
                 );

    if (!NT_SUCCESS( Status )) {
        ASSERT( NT_SUCCESS( Status ) );
        return( Status );
    }

    Status = RtlAllocateAndInitializeSid(
                 &WorldAuthority,
                 1,
                 SECURITY_WORLD_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &WorldSid
                 );

    if (!NT_SUCCESS( Status )) {
        RtlFreeSid( LocalSystemSid );
        ASSERT( NT_SUCCESS( Status ) );
        return( Status );
    }

    Status = RtlAllocateAndInitializeSid(
                 &NtAuthority,
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS,
                 0, 0, 0, 0, 0, 0,
                 &AliasAdminsSid
                 );

    if (!NT_SUCCESS( Status )) {
        RtlFreeSid( LocalSystemSid );
        RtlFreeSid( WorldSid );
        ASSERT( NT_SUCCESS( Status ) );
        return( Status );
    }


    Status = RtlAllocateAndInitializeSid(
                 &CreatorAuthority,
                 1,
                 SECURITY_CREATOR_OWNER_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &CreatorOwnerSid
                 );

    if (!NT_SUCCESS( Status )) {
        RtlFreeSid( LocalSystemSid );
        RtlFreeSid( WorldSid );
        RtlFreeSid( AliasAdminsSid );
        ASSERT( NT_SUCCESS( Status ) );
        return( Status );
    }

    RtlInitUnicodeString( &NameString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );

    InitializeObjectAttributes( &Obja,
                                &NameString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenKey( &KeyHandle,
                        KEY_READ,
                        &Obja
                      );

    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString( &NameString, L"ProtectionMode" );
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
        Status = NtQueryValueKey( KeyHandle,
                                  &NameString,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  sizeof( ValueBuffer ),
                                  &ResultLength
                                );

        if (NT_SUCCESS(Status)) {
            if (KeyValueInformation->Type == REG_DWORD &&
                *(PULONG)KeyValueInformation->Data) {
                ProtectionMode = *(PULONG)KeyValueInformation->Data;

             }
        }

        NtClose( KeyHandle );
    }



    if (ProtectionMode & 0x00000003) {

        //
        // If ProtectionMode is set to 1 or 2 Terminal Server
        // locks down sessions tight.
        //
        //  Dacl:
        //          Grant:  System:  All Access             (With Inherit)
        //          Grant:  Admins:  All Access             (With Inherit)
        //          Grant:  Owner:   All Access             (Inherit Only)
        //          Grant:  World:   No Access
        //

        aclLength = sizeof( ACL )                           +
                    3 * sizeof( ACCESS_ALLOWED_ACE )        +
                    RtlLengthSid( LocalSystemSid )          +
                    RtlLengthSid( AliasAdminsSid )          +
                    RtlLengthSid( CreatorOwnerSid );

        dacl = (PACL)RtlAllocateHeap( CsrHeap,
                                      MAKE_TAG( SECURITY_TAG ) | HEAP_ZERO_MEMORY,
                                      aclLength );

        if (dacl == NULL) {
            Status =  STATUS_NO_MEMORY;
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }

        Status = RtlCreateAcl( dacl, aclLength, ACL_REVISION2);
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }

        aceIndex = 0;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, LocalSystemSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }

        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }
        ace->AceFlags |= inheritFlags;

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, AliasAdminsSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }

        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }
        ace->AceFlags |= inheritFlags;

        //
        //  Inherit only ACE at the end of the ACL
        //          Owner
        //

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, CreatorOwnerSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }
        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
            goto cleanup;
        }
        ace->AceFlags |= inheritOnlyFlags;

        Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                               TRUE,               //DaclPresent,
                                               dacl,               //Dacl
                                               FALSE );            //!DaclDefaulted

        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }

    } else {

        //
        //  DACL:
        //          Grant:  World:   Execute | Read | Write (No Inherit)
        //          Grant:  System:  All Access             (No Inherit)
        //          Grant:  World:   All Access             (Inherit Only)
        //

        aclLength = sizeof( ACL )                           +
                    3 * sizeof( ACCESS_ALLOWED_ACE )        +
                    (2*RtlLengthSid( WorldSid ))            +
                    RtlLengthSid( LocalSystemSid );

        dacl = (PACL)RtlAllocateHeap( CsrHeap,
                                      MAKE_TAG( SECURITY_TAG ) | HEAP_ZERO_MEMORY,
                                      aclLength );

        if (dacl == NULL) {
            ASSERT( NT_SUCCESS( Status ) );
            Status =  STATUS_NO_MEMORY;
            goto cleanup;
        }

        Status = RtlCreateAcl( dacl, aclLength, ACL_REVISION2);
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }

        //
        //  Non-inheritable ACEs first
        //      World
        //      System
        //

        aceIndex = 0;
        accessMask = (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, WorldSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, LocalSystemSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }

        //
        //  Inheritable ACEs at the end of the ACL
        //          World
        //

        aceIndex++;
        accessMask = (GENERIC_ALL);
        Status = RtlAddAccessAllowedAce ( dacl, ACL_REVISION2, accessMask, WorldSid );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }
        Status = RtlGetAce( dacl, aceIndex, (PVOID)&ace );
        if (!NT_SUCCESS( Status )) {
            ASSERT( NT_SUCCESS( Status ) );
           goto cleanup;
        }
        ace->AceFlags |= inheritOnlyFlags;

        Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                               TRUE,               //DaclPresent,
                                               dacl,               //Dacl
                                               FALSE );            //!DaclDefaulted

       if (!NT_SUCCESS( Status )) {
          ASSERT( NT_SUCCESS( Status ) );
          goto cleanup;
       }
    }

cleanup:
    if (!NT_SUCCESS( Status ) && (dacl != NULL)) {
       RtlFreeHeap( CsrHeap, 0, dacl);
    }

    RtlFreeSid( LocalSystemSid );
    RtlFreeSid( WorldSid );
    RtlFreeSid( AliasAdminsSid );
    RtlFreeSid( CreatorOwnerSid );
    if (!NT_SUCCESS( Status )) {
         DbgPrint("CSRSS: GetDosDevicesProtection failed - status = %lx\n", Status);
         ASSERT( NT_SUCCESS( Status ) );
    }

    return Status;
}


VOID
FreeDosDevicesProtection (
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine frees memory allocated via GetDosDevicesProtection().

Arguments:

    SecurityDescriptor - The address of a security descriptor initialized by
        GetDosDevicesProtection().

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PACL Dacl = NULL;
    BOOLEAN DaclPresent, Defaulted;

    Status = RtlGetDaclSecurityDescriptor ( SecurityDescriptor,
                                            &DaclPresent,
                                            &Dacl,
                                            &Defaulted );

    ASSERT( NT_SUCCESS( Status ) );
    ASSERT( DaclPresent );
    ASSERT( Dacl != NULL );
    if ((NT_SUCCESS( Status ))  && (Dacl != NULL ) ) {
        RtlFreeHeap( CsrHeap, 0, Dacl);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\sbreqst.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sbreqst.c

Abstract:

    This module contains the Server Request thread procedure for the Sb
    API calls exported by the Server side of the Client-Server Runtime
    Subsystem to the Session Manager SubSystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

#include "csrsrv.h"

PSB_API_ROUTINE CsrServerSbApiDispatch[ SbMaxApiNumber+1 ] = {
    CsrSbCreateSession,
    CsrSbTerminateSession,
    CsrSbForeignSessionComplete,
    CsrSbCreateProcess,
    NULL
};

#if DBG
PSZ CsrServerSbApiName[ SbMaxApiNumber+1 ] = {
    "SbCreateSession",
    "SbTerminateSession",
    "SbForeignSessionComplete",
    "SbCreateProcess",
    "Unknown Csr Sb Api Number"
};
#endif // DBG


NTSTATUS
CsrSbApiHandleConnectionRequest(
    IN PSBAPIMSG Message
    );


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

NTSTATUS
CsrSbApiRequestThread(
    IN PVOID Parameter
    )
{
    NTSTATUS Status;
    SBAPIMSG ReceiveMsg;
    PSBAPIMSG ReplyMsg;
    HANDLE hConnectionPort;

    ReplyMsg = NULL;
    while (TRUE) {
        Status = NtReplyWaitReceivePort( CsrSbApiPort,
                                         (PVOID)(&hConnectionPort),
                                         (PPORT_MESSAGE)ReplyMsg,
                                         (PPORT_MESSAGE)&ReceiveMsg
                                       );

        if (Status != 0) {
            if (NT_SUCCESS( Status )) {
                continue;       // Try again if alerted or a failure
                }
            else {
                IF_DEBUG {
                    DbgPrint( "CSRSS: ReceivePort failed - Status == %X\n", Status );
                    }
                ReplyMsg = NULL;
                continue;
                }
            }

        //
        // Check to see if this is a connection request and handle
        //

        if (ReceiveMsg.h.u2.s2.Type == LPC_CONNECTION_REQUEST) {
            CsrSbApiHandleConnectionRequest( &ReceiveMsg );
            ReplyMsg = NULL;
            continue;
            }



        if (ReceiveMsg.h.u2.s2.Type == LPC_CLIENT_DIED ) {

            ReplyMsg = NULL;
            continue;
            }

        if (ReceiveMsg.h.u2.s2.Type == LPC_PORT_CLOSED ) {

            //
            // Close the handle to the connection's server communication port object
            //

            if (hConnectionPort != NULL) {
                NtClose( hConnectionPort );
                }
            ReplyMsg = NULL;
            continue;
            }

        if ((ULONG)ReceiveMsg.ApiNumber >= SbMaxApiNumber) {
            IF_DEBUG {
                DbgPrint( "CSRSS: %lx is invalid Sb ApiNumber\n",
                          ReceiveMsg.ApiNumber
                        );
                }

            ReceiveMsg.ApiNumber = SbMaxApiNumber;
            }


        ReplyMsg = &ReceiveMsg;
        if (ReceiveMsg.ApiNumber < SbMaxApiNumber) {
            if (!(*CsrServerSbApiDispatch[ ReceiveMsg.ApiNumber ])( &ReceiveMsg )) {
                ReplyMsg = NULL;
                }
            }
        else {
            ReplyMsg->ReturnedStatus = STATUS_NOT_IMPLEMENTED;
            }

        }

    NtTerminateThread( NtCurrentThread(), Status );

    return( Status );   // Remove no return value warning.
    Parameter;          // Remove unreferenced parameter warning.
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

NTSTATUS
CsrSbApiHandleConnectionRequest(
    IN PSBAPIMSG Message
    )
{
    NTSTATUS st;
    REMOTE_PORT_VIEW ClientView;
    HANDLE CommunicationPort;

    //
    // The protocol for a subsystem is to connect to the session manager,
    // then to listen and accept a connection from the session manager
    //

    ClientView.Length = sizeof(ClientView);
    st = NtAcceptConnectPort(
            &CommunicationPort,
            NULL,
            (PPORT_MESSAGE)Message,
            TRUE,
            NULL,
            &ClientView
            );

    if ( !NT_SUCCESS(st) ) {
        KdPrint(("CSRSS: Sb Accept Connection failed %lx\n",st));
        return st;
    }

    st = NtCompleteConnectPort(CommunicationPort);

    if ( !NT_SUCCESS(st) ) {
        KdPrint(("CSRSS: Sb Complete Connection failed %lx\n",st));
    }

    return st;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\session.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    session.c

Abstract:

    This module contains the worker routines called by the Sb API
    Request routines in sbapi.c to create and delete sessions.  Also
    called whenever an application process creates a new child process
    within the same session.

Author:

    Steve Wood (stevewo) 08-Oct-1990

Revision History:

--*/


#include "csrsrv.h"

NTSTATUS
CsrInitializeNtSessionList( VOID )
{
    NTSTATUS Status;

    InitializeListHead( &CsrNtSessionList );

    Status = RtlInitializeCriticalSection( &CsrNtSessionLock );
    return( Status );
}


PCSR_NT_SESSION
CsrAllocateNtSession(
    ULONG SessionId
    )
{
    PCSR_NT_SESSION Session;

    Session = RtlAllocateHeap( CsrHeap, MAKE_TAG( SESSION_TAG ), sizeof( CSR_NT_SESSION ) );
    ASSERT( Session != NULL );

    if (Session != NULL) {
        Session->SessionId = SessionId;
        Session->ReferenceCount = 1;
        LockNtSessionList();
        InsertHeadList( &CsrNtSessionList, &Session->SessionLink );
        UnlockNtSessionList();
        }

    return( Session );
}

VOID
CsrReferenceNtSession(
    PCSR_NT_SESSION Session
    )
{
    LockNtSessionList();

    ASSERT( !IsListEmpty( &Session->SessionLink ) );
    ASSERT( Session->SessionId != 0 );
    ASSERT( Session->ReferenceCount != 0 );
    Session->ReferenceCount++;
    UnlockNtSessionList();
}

VOID
CsrDereferenceNtSession(
    PCSR_NT_SESSION Session,
    NTSTATUS ExitStatus
    )
{
    LockNtSessionList();

    ASSERT( !IsListEmpty( &Session->SessionLink ) );
    ASSERT( Session->SessionId != 0 );
    ASSERT( Session->ReferenceCount != 0 );

    if (--Session->ReferenceCount == 0) {
        RemoveEntryList( &Session->SessionLink );
        UnlockNtSessionList();
        SmSessionComplete(CsrSmApiPort,Session->SessionId,ExitStatus);
        RtlFreeHeap( CsrHeap, 0, Session );
        }
    else {
        UnlockNtSessionList();
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\process.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module contains the worker routines called to create and
    maintain the application process structure for the Client-Server
    Runtime Subsystem to the Session Manager SubSystem.

Author:

    Steve Wood (stevewo) 10-Oct-1990

Revision History:

--*/


#include "csrsrv.h"
#include <stdio.h>
// ProcessSequenceCount will never be a value less than FIRST_SEQUENCE_COUNT
// currently GDI needs 0 - 4 to be reserved.

ULONG ProcessSequenceCount = FIRST_SEQUENCE_COUNT;

#define THREAD_HASH_SIZE 256
#define THREAD_ID_TO_HASH(id)   (HandleToUlong(id)&(THREAD_HASH_SIZE-1))
LIST_ENTRY CsrThreadHashTable[THREAD_HASH_SIZE];


SECURITY_QUALITY_OF_SERVICE CsrSecurityQos = {
    sizeof(SECURITY_QUALITY_OF_SERVICE), SecurityImpersonation,
    SECURITY_DYNAMIC_TRACKING, FALSE
};

PCSR_PROCESS
FindProcessForShutdown(
    PLUID CallerLuid
    );

NTSTATUS
ReadUnicodeString(HANDLE ProcessHandle,
                  PUNICODE_STRING RemoteString,
                  PUNICODE_STRING LocalString
                  );

VOID
CsrpSetToNormalPriority(
    VOID
    )
{

    KPRIORITY SetBasePriority;

    SetBasePriority = FOREGROUND_BASE_PRIORITY + 4;
    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );
}

VOID
CsrpSetToShutdownPriority(
    VOID
    )
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    KPRIORITY SetBasePriority;

    Status = RtlAdjustPrivilege(
                 SE_INC_BASE_PRIORITY_PRIVILEGE,
                 TRUE,
                 FALSE,
                 &WasEnabled);

    if (!NT_SUCCESS(Status))
        return;

    SetBasePriority = FOREGROUND_BASE_PRIORITY + 6;
    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );
}

VOID
CsrSetForegroundPriority(
    IN PCSR_PROCESS Process
    )
{
    PROCESS_FOREGROUND_BACKGROUND Fg;

    Fg.Foreground = TRUE;

    NtSetInformationProcess(
            Process->ProcessHandle,
            ProcessForegroundInformation,
            (PVOID)&Fg,
            sizeof(Fg)
            );
}

VOID
CsrSetBackgroundPriority(
    IN PCSR_PROCESS Process
    )
{
    PROCESS_FOREGROUND_BACKGROUND Fg;

    Fg.Foreground = FALSE;

    NtSetInformationProcess(
            Process->ProcessHandle,
            ProcessForegroundInformation,
            (PVOID)&Fg,
            sizeof(Fg)
            );
}


NTSTATUS
CsrInitializeProcessStructure( VOID )
{
    NTSTATUS Status;
    ULONG i;

    // Though this function does not seem to cleanup on failure, failure
    // will cause Csrss to exit, so any allocated memory will be freed and
    // any open handle will be closed.

    Status = RtlInitializeCriticalSection( &CsrProcessStructureLock );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    CsrRootProcess = NULL;
    CsrRootProcess = CsrAllocateProcess();

    if (CsrRootProcess == NULL) {
        return STATUS_NO_MEMORY;
    }

    InitializeListHead( &CsrRootProcess->ListLink );
    CsrRootProcess->ProcessHandle = (HANDLE) -1;
    CsrRootProcess->ClientId = NtCurrentTeb()->ClientId;
    for ( i=0; i<THREAD_HASH_SIZE; i++ ) {
        InitializeListHead(&CsrThreadHashTable[i]);
        }
    Status = RtlInitializeCriticalSection( &CsrWaitListsLock );
    ASSERT( NT_SUCCESS( Status ) );

    return( Status );
}


PCSR_PROCESS
CsrAllocateProcess( VOID )
{
    PCSR_PROCESS Process;
    ULONG ProcessSize;

    //
    // Allocate an Windows Process Object.  At the end of the process
    // structure is an array of pointers to each server DLL's per process
    // data.  The per process data is contained in the memory after the
    // array.
    //

    ProcessSize = (ULONG)QUAD_ALIGN(sizeof( CSR_PROCESS ) +
            (CSR_MAX_SERVER_DLL * sizeof(PVOID))) + CsrTotalPerProcessDataLength;
    Process = (PCSR_PROCESS)RtlAllocateHeap( CsrHeap, MAKE_TAG( PROCESS_TAG ),
                                             ProcessSize
                                           );
    if (Process == NULL) {
        return( NULL );
        }

    //
    // Initialize the fields of the process object
    //

    RtlZeroMemory( Process, ProcessSize);

    //
    // grab the ProcessSequenceNumber and increment it, making sure that it
    // is never less than FIRST_SEQUENCE_COUNT.
    //

    Process->SequenceNumber = ProcessSequenceCount++;

    if (ProcessSequenceCount < FIRST_SEQUENCE_COUNT)
        ProcessSequenceCount = FIRST_SEQUENCE_COUNT;

    CsrLockedReferenceProcess(Process);

    InitializeListHead( &Process->ThreadList );
    return( Process );
}


VOID
CsrDeallocateProcess(
    IN PCSR_PROCESS Process
    )
{
    RtlFreeHeap( CsrHeap, 0, Process );
}

//
// NOTE: The process structure lock must be held when calling this routine.
//
VOID
CsrInsertProcess(
    IN PCSR_PROCESS ParentProcess,
    IN PCSR_PROCESS CallingProcess,
    IN PCSR_PROCESS Process
    )
{
    PCSR_SERVER_DLL LoadedServerDll;
    ULONG i;

    ASSERT(ProcessStructureListLocked());

    Process->Parent = ParentProcess;
    InsertTailList( &CsrRootProcess->ListLink, &Process->ListLink );

    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
        LoadedServerDll = CsrLoadedServerDll[ i ];
        if (LoadedServerDll && LoadedServerDll->AddProcessRoutine) {
            (*LoadedServerDll->AddProcessRoutine)( CallingProcess, Process );
            }
        }
}


//
// NOTE: The process structure lock must be held when calling this routine.
//
VOID
CsrRemoveProcess(
    IN PCSR_PROCESS Process
    )
{
    PCSR_SERVER_DLL LoadedServerDll;
    ULONG i;

    ASSERT(ProcessStructureListLocked());

    RemoveEntryList( &Process->ListLink );
    ReleaseProcessStructureLock();

    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
        LoadedServerDll = CsrLoadedServerDll[ i ];
        if (LoadedServerDll && LoadedServerDll->DisconnectRoutine) {
            (LoadedServerDll->DisconnectRoutine)( Process );
            }
        }

}

NTSTATUS
CsrCreateProcess(
    IN HANDLE ProcessHandle,
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId,
    IN PCSR_NT_SESSION Session,
    IN ULONG DebugFlags,
    IN PCLIENT_ID DebugUserInterface OPTIONAL
    )
{
    PCSR_PROCESS Process;
    PCSR_THREAD Thread;
    NTSTATUS Status;
    ULONG i;
    PVOID ProcessDataPtr;
    CLIENT_ID CallingClientId;
    PCSR_THREAD CallingThread;
    PCSR_PROCESS CallingProcess;
    KERNEL_USER_TIMES TimeInfo;

    CallingThread = CSR_SERVER_QUERYCLIENTTHREAD();

    //
    // remember the client id of the calling process.
    //

    CallingClientId = CallingThread->ClientId;

    AcquireProcessStructureLock();

    //
    // look for calling thread.
    //

    CallingThread = CsrLocateThreadByClientId( &CallingProcess,
                                               &CallingClientId
                                             );
    if (CallingThread == NULL) {
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
    }

    Process = CsrAllocateProcess();
    if (Process == NULL) {
        Status = STATUS_NO_MEMORY;
        ReleaseProcessStructureLock();
        return( Status );
        }

    //
    // copy per-process data from parent to child
    //

    CallingProcess = (CSR_SERVER_QUERYCLIENTTHREAD())->Process;
    ProcessDataPtr = (PVOID)QUAD_ALIGN(&Process->ServerDllPerProcessData[CSR_MAX_SERVER_DLL]);
    for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
        if (CsrLoadedServerDll[i] != NULL && CsrLoadedServerDll[i]->PerProcessDataLength) {
            Process->ServerDllPerProcessData[i] = ProcessDataPtr;
            RtlMoveMemory(ProcessDataPtr,
                          CallingProcess->ServerDllPerProcessData[i],
                          CsrLoadedServerDll[i]->PerProcessDataLength
                         );
            ProcessDataPtr = (PVOID)QUAD_ALIGN((PCHAR)ProcessDataPtr + CsrLoadedServerDll[i]->PerProcessDataLength);
        }
        else {
            Process->ServerDllPerProcessData[i] = NULL;
        }
    }

    Status = NtSetInformationProcess(
                ProcessHandle,
                ProcessExceptionPort,
                (PVOID)&CsrApiPort,
                sizeof(HANDLE)
                );
    if ( !NT_SUCCESS(Status) ) {
        CsrDeallocateProcess( Process );
        ReleaseProcessStructureLock();
        return( STATUS_NO_MEMORY );
        }

    //
    // If we are creating a process group, the group leader has the same
    // process id and sequence number of itself. If the leader dies and
    // his pid is recycled, the sequence number mismatch will prevent it
    // from being viewed as a group leader.
    //

    if ( DebugFlags & CSR_CREATE_PROCESS_GROUP ) {
        Process->ProcessGroupId = HandleToUlong(ClientId->UniqueProcess);
        Process->ProcessGroupSequence = Process->SequenceNumber;
        }
    else {
        Process->ProcessGroupId = CallingProcess->ProcessGroupId;
        Process->ProcessGroupSequence = CallingProcess->ProcessGroupSequence;
        }

    if ( DebugFlags & CSR_PROCESS_CONSOLEAPP ) {
        Process->Flags |= CSR_PROCESS_CONSOLEAPP;
        }

    DebugFlags &= ~(CSR_PROCESS_CONSOLEAPP | CSR_NORMAL_PRIORITY_CLASS|CSR_IDLE_PRIORITY_CLASS|CSR_HIGH_PRIORITY_CLASS|CSR_REALTIME_PRIORITY_CLASS|CSR_CREATE_PROCESS_GROUP);

    if ( !DebugFlags && CallingProcess->DebugFlags & CSR_DEBUG_PROCESS_TREE ) {
        Process->DebugFlags = CSR_DEBUG_PROCESS_TREE;
        Process->DebugUserInterface = CallingProcess->DebugUserInterface;
        }
    if ( DebugFlags & (CSR_DEBUG_THIS_PROCESS | CSR_DEBUG_PROCESS_TREE) &&
         ARGUMENT_PRESENT(DebugUserInterface) ) {
        Process->DebugFlags = DebugFlags;
        Process->DebugUserInterface = *DebugUserInterface;
        }


    if ( Process->DebugFlags ) {

        //
        // Process is being debugged, so set up debug port
        //

        Status = NtSetInformationProcess(
                    ProcessHandle,
                    ProcessDebugPort,
                    (PVOID)&CsrApiPort,
                    sizeof(HANDLE)
                    );
        ASSERT(NT_SUCCESS(Status));
        if ( !NT_SUCCESS(Status) ) {
            CsrDeallocateProcess( Process );
            ReleaseProcessStructureLock();
            return( STATUS_NO_MEMORY );
            }
        }
    //
    // capture the thread's createtime so that we can use
    // this as a sequence number
    //

    Status = NtQueryInformationThread(
                ThreadHandle,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        CsrDeallocateProcess( Process );
        ReleaseProcessStructureLock();
        return( Status );
        }

    Thread = CsrAllocateThread( Process );
    if (Thread == NULL) {
        CsrDeallocateProcess( Process );
        ReleaseProcessStructureLock();
        return( STATUS_NO_MEMORY );
        }

    Thread->CreateTime = TimeInfo.CreateTime;

    Thread->ClientId = *ClientId;
    Thread->ThreadHandle = ThreadHandle;

    ProtectHandle(ThreadHandle);

    Thread->Flags = 0;
    CsrInsertThread( Process, Thread );

    CsrReferenceNtSession(Session);
    Process->NtSession = Session;

    Process->ClientId = *ClientId;
    Process->ProcessHandle = ProcessHandle;

    CsrSetBackgroundPriority(Process);

    Process->ShutdownLevel = 0x00000280;

    CsrInsertProcess( NULL, (CSR_SERVER_QUERYCLIENTTHREAD())->Process, Process );
    ReleaseProcessStructureLock();
    return STATUS_SUCCESS;
}


NTSTATUS
CsrDestroyProcess(
    IN PCLIENT_ID ClientId,
    IN NTSTATUS ExitStatus
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_THREAD DyingThread;
    PCSR_PROCESS DyingProcess;

    CLIENT_ID DyingClientId;

    DyingClientId = *ClientId;

    AcquireProcessStructureLock();


    DyingThread = CsrLocateThreadByClientId( &DyingProcess,
                                             &DyingClientId
                                           );
    if (DyingThread == NULL) {
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
    }

    //
    // prevent multiple destroys from causing problems. Scottlu and Markl
    // beleive all known race conditions are now fixed. This is simply a
    // precaution since we know that if this happens we process reference
    // count underflow
    //

    if ( DyingProcess->Flags & CSR_PROCESS_DESTROYED ) {
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
    }

    DyingProcess->Flags |= CSR_PROCESS_DESTROYED;

    ListHead = &DyingProcess->ThreadList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        DyingThread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
        if ( DyingThread->Flags & CSR_THREAD_DESTROYED ) {
            ListNext = ListNext->Flink;
            continue;
            }
        else {
            DyingThread->Flags |= CSR_THREAD_DESTROYED;
            }
        AcquireWaitListsLock();
        if (DyingThread->WaitBlock != NULL) {
            CsrNotifyWaitBlock(DyingThread->WaitBlock,
                               NULL,
                               NULL,
                               NULL,
                               CSR_PROCESS_TERMINATING,
                               TRUE
                              );
            }
        ReleaseWaitListsLock();
        CsrLockedDereferenceThread(DyingThread);
        ListNext = ListHead->Flink;
        }

    ReleaseProcessStructureLock();
    return STATUS_SUCCESS;
}


NTSTATUS
CsrCreateThread(
    IN PCSR_PROCESS Process,
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId,
    IN BOOLEAN ValidateCaller
    )
{
    PCSR_THREAD Thread;
    CLIENT_ID CallingClientId;
    PCSR_THREAD CallingThread;
    PCSR_PROCESS CallingProcess;
    KERNEL_USER_TIMES TimeInfo;
    NTSTATUS Status;

    if (ValidateCaller)
    {
        CallingThread = CSR_SERVER_QUERYCLIENTTHREAD();

        //
        // remember the client id of the calling process.
        //

        CallingClientId = CallingThread->ClientId;

        AcquireProcessStructureLock();

        //
        // look for calling thread.
        //

        CallingThread = CsrLocateThreadByClientId( &CallingProcess,
                                                   &CallingClientId
                                                 );
        if (CallingThread == NULL) {
            ReleaseProcessStructureLock();
            return STATUS_THREAD_IS_TERMINATING;
        }
    } else {
        AcquireProcessStructureLock();
	}
    
    Status = NtQueryInformationThread(
                ThreadHandle,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        ReleaseProcessStructureLock();
        return( Status );
        }

    if (Process->Flags & CSR_PROCESS_DESTROYED) {
        IF_DEBUG {
            DbgPrint("CSRSS: CsrCreateThread - process %p is destroyed\n", Process);
            }
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
        }

    Thread = CsrAllocateThread( Process );
    if (Thread == NULL) {
        ReleaseProcessStructureLock();
        return( STATUS_NO_MEMORY );
        }

    Thread->CreateTime = TimeInfo.CreateTime;

    Thread->ClientId = *ClientId;
    Thread->ThreadHandle = ThreadHandle;

    ProtectHandle(ThreadHandle);

    Thread->Flags = 0;
    CsrInsertThread( Process, Thread );
    ReleaseProcessStructureLock();
    return STATUS_SUCCESS;
}

NTSTATUS
CsrCreateRemoteThread(
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId
    )
{
    PCSR_THREAD Thread;
    PCSR_PROCESS Process;
    NTSTATUS Status;
    HANDLE hThread;
    KERNEL_USER_TIMES TimeInfo;

    Status = NtQueryInformationThread(
                ThreadHandle,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return( Status );
        }

    Status = CsrLockProcessByClientId( ClientId->UniqueProcess,
                                       &Process
                                     );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    //
    // Don't create the thread structure if the thread
    // has already terminated.
    //

    if ( TimeInfo.ExitTime.QuadPart != 0 ) {
        CsrUnlockProcess( Process );
        return( STATUS_THREAD_IS_TERMINATING );
    }

    Thread = CsrAllocateThread( Process );
    if (Thread == NULL) {
        CsrUnlockProcess( Process );
        return( STATUS_NO_MEMORY );
        }
    Status = NtDuplicateObject(
                NtCurrentProcess(),
                ThreadHandle,
                NtCurrentProcess(),
                &hThread,
                0L,
                0L,
                DUPLICATE_SAME_ACCESS
                );
    if (!NT_SUCCESS(Status)) {
        hThread = ThreadHandle;
    }

    Thread->CreateTime = TimeInfo.CreateTime;

    Thread->ClientId = *ClientId;
    Thread->ThreadHandle = hThread;

    ProtectHandle(hThread);

    Thread->Flags = 0;
    CsrInsertThread( Process, Thread );
    CsrUnlockProcess( Process );
    return STATUS_SUCCESS;
}


NTSTATUS
CsrDestroyThread(
    IN PCLIENT_ID ClientId
    )
{
    CLIENT_ID DyingClientId;
    PCSR_THREAD DyingThread;
    PCSR_PROCESS DyingProcess;

    DyingClientId = *ClientId;

    AcquireProcessStructureLock();

    DyingThread = CsrLocateThreadByClientId( &DyingProcess,
                                             &DyingClientId
                                           );
    if (DyingThread == NULL) {
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
    }

    if ( DyingThread->Flags & CSR_THREAD_DESTROYED ) {
        ReleaseProcessStructureLock();
        return STATUS_THREAD_IS_TERMINATING;
        }
    else {
        DyingThread->Flags |= CSR_THREAD_DESTROYED;
        }

    AcquireWaitListsLock();
    if (DyingThread->WaitBlock != NULL) {
        CsrNotifyWaitBlock(DyingThread->WaitBlock,
                           NULL,
                           NULL,
                           NULL,
                           CSR_PROCESS_TERMINATING,
                           TRUE
                          );
        }
    ReleaseWaitListsLock();
    CsrLockedDereferenceThread(DyingThread);

    ReleaseProcessStructureLock();
    return STATUS_SUCCESS;
}


PCSR_THREAD
CsrAllocateThread(
    IN PCSR_PROCESS Process
    )
{
    PCSR_THREAD Thread;
    ULONG ThreadSize;

    //
    // Allocate an Windows Thread Object.
    //

    ThreadSize = QUAD_ALIGN(sizeof( CSR_THREAD ));
    Thread = (PCSR_THREAD)RtlAllocateHeap( CsrHeap, MAKE_TAG( THREAD_TAG ),
                                           ThreadSize
                                         );
    if (Thread == NULL) {
        return( NULL );
        }

    //
    // Initialize the fields of the thread object
    //

    RtlZeroMemory( Thread, ThreadSize );

    CsrLockedReferenceThread(Thread);
    CsrLockedReferenceProcess(Process);
    Thread->Process = Process;

    return( Thread );
}


VOID
CsrDeallocateThread(
    IN PCSR_THREAD Thread
    )
{
    ASSERT (Thread->WaitBlock == NULL);
    RtlFreeHeap( CsrHeap, 0, Thread );
}


//
// NOTE: The process structure lock must be held while calling this routine.
//
VOID
CsrInsertThread(
    IN PCSR_PROCESS Process,
    IN PCSR_THREAD Thread
    )

{
    ULONG i;
    ASSERT(ProcessStructureListLocked());
    InsertTailList( &Process->ThreadList, &Thread->Link );
    Process->ThreadCount++;
    i = THREAD_ID_TO_HASH(Thread->ClientId.UniqueThread);
    InsertHeadList( &CsrThreadHashTable[i], &Thread->HashLinks);
}

VOID
CsrRemoveThread(
    IN PCSR_THREAD Thread
    )


{
    RemoveEntryList( &Thread->Link );
    Thread->Process->ThreadCount--;
    if (Thread->HashLinks.Flink)
        RemoveEntryList( &Thread->HashLinks );

    //
    // if this is the last thread, then make sure we undo the reference
    // that this thread had on the process.
    //

    if ( Thread->Process->ThreadCount == 0 ) {
        if ( !(Thread->Process->Flags & CSR_PROCESS_LASTTHREADOK) ) {
            Thread->Process->Flags |= CSR_PROCESS_LASTTHREADOK;
            CsrLockedDereferenceProcess(Thread->Process);
            }
        }

    Thread->Flags |= CSR_THREAD_TERMINATING;
}


NTSTATUS
CsrLockProcessByClientId(
    IN HANDLE UniqueProcessId,
    OUT PCSR_PROCESS *Process
    )
{
    NTSTATUS Status;
    PLIST_ENTRY ListHead, ListNext;
    PCSR_PROCESS ProcessPtr;


    AcquireProcessStructureLock();

    ASSERT( Process != NULL );
    *Process = NULL;

    Status = STATUS_UNSUCCESSFUL;
    ListHead = &CsrRootProcess->ListLink;
    ListNext = ListHead;
    do  {
        ProcessPtr = CONTAINING_RECORD( ListNext, CSR_PROCESS, ListLink );
        if (ProcessPtr->ClientId.UniqueProcess == UniqueProcessId) {
            Status = STATUS_SUCCESS;
            break;
            }
        ListNext = ListNext->Flink;
        } while (ListNext != ListHead);

    if (NT_SUCCESS( Status )) {
        CsrLockedReferenceProcess(ProcessPtr);
        *Process = ProcessPtr;
        }
    else {
        ReleaseProcessStructureLock();
        }

    return( Status );
}

NTSTATUS
CsrUnlockProcess(
    IN PCSR_PROCESS Process
    )
{
    CsrLockedDereferenceProcess( Process );
    ReleaseProcessStructureLock();
    return( STATUS_SUCCESS );
}

NTSTATUS
CsrLockThreadByClientId(
    IN HANDLE UniqueThreadId,
    OUT PCSR_THREAD *Thread
    )
{
    NTSTATUS Status;
    ULONG Index;
    PLIST_ENTRY ListHead, ListNext;
    PCSR_THREAD ThreadPtr;

    AcquireProcessStructureLock();

    ASSERT( Thread != NULL );
    *Thread = NULL;

    Index = THREAD_ID_TO_HASH(UniqueThreadId);

    ListHead = &CsrThreadHashTable[Index];
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ThreadPtr = CONTAINING_RECORD( ListNext, CSR_THREAD, HashLinks );
        if ( ThreadPtr->ClientId.UniqueThread == UniqueThreadId &&
             !(ThreadPtr->Flags & CSR_THREAD_DESTROYED) ) {
            break;
            }
        ListNext = ListNext->Flink;
        }
    if (ListNext == ListHead)
        ThreadPtr = NULL;

    if (ThreadPtr != NULL) {
        Status = STATUS_SUCCESS;
        CsrLockedReferenceThread(ThreadPtr);
        *Thread = ThreadPtr;
        }
    else {
        Status = STATUS_UNSUCCESSFUL;
        ReleaseProcessStructureLock();
        }

    return( Status );
}

//
// NOTE: The process structure lock must be held while calling this routine.
//
NTSTATUS
CsrUnlockThread(
    IN PCSR_THREAD Thread
    )
{
    ASSERT(ProcessStructureListLocked());
    CsrLockedDereferenceThread( Thread );
    ReleaseProcessStructureLock();
    return( STATUS_SUCCESS );
}

//
// NOTE: The process structure lock must be held while calling this routine.
//
PCSR_THREAD
CsrLocateThreadByClientId(
    OUT PCSR_PROCESS *Process OPTIONAL,
    IN PCLIENT_ID ClientId
    )
{
    ULONG Index;
    PLIST_ENTRY ListHead, ListNext;
    PCSR_THREAD Thread;

    ASSERT(ProcessStructureListLocked());
    Index = THREAD_ID_TO_HASH(ClientId->UniqueThread);

    if (ARGUMENT_PRESENT(Process)) {
        *Process = NULL;
    }
    ListHead = &CsrThreadHashTable[Index];
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, HashLinks );
        if ( Thread->ClientId.UniqueThread == ClientId->UniqueThread &&
             Thread->ClientId.UniqueProcess == ClientId->UniqueProcess ) {
            if (ARGUMENT_PRESENT(Process)) {
                *Process = Thread->Process;
                }
            return Thread;
            }
        ListNext = ListNext->Flink;
        }
    return NULL;
}

PCSR_THREAD
CsrLocateThreadInProcess(
    IN PCSR_PROCESS Process OPTIONAL,
    IN PCLIENT_ID ClientId
    )

// NOTE: process structure lock must be held while calling this routine

{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_THREAD Thread;

    if (Process == NULL)
        Process = CsrRootProcess;

    ListHead = &Process->ThreadList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
        if (Thread->ClientId.UniqueThread == ClientId->UniqueThread) {
            return( Thread );
            }

        ListNext = ListNext->Flink;
        }

    return( NULL );
}

BOOLEAN
CsrImpersonateClient(
    IN PCSR_THREAD Thread
    )
{
    NTSTATUS Status;
    PCSR_THREAD CallingThread;

    CallingThread = CSR_SERVER_QUERYCLIENTTHREAD();

    if (Thread == NULL) {
        Thread = CallingThread;
        }

    if (Thread == NULL) {
        return FALSE;
        }

    if (!NT_SUCCESS(Status = NtImpersonateThread(NtCurrentThread(),
            Thread->ThreadHandle, &CsrSecurityQos))) {
        IF_DEBUG {
            DbgPrint( "CSRSS: Can't impersonate client thread - Status = %lx\n",
                      Status
                    );
            if (Status != STATUS_BAD_IMPERSONATION_LEVEL)
                DbgBreakPoint();
            }
        return FALSE;
        }

    //
    // Keep track of recursion by printer drivers
    //

    if (CallingThread != NULL)
        ++CallingThread->ImpersonateCount;

    return TRUE;
}

BOOLEAN
CsrRevertToSelf( VOID )
{
    HANDLE NewToken;
    NTSTATUS Status;
    PCSR_THREAD CallingThread;

    CallingThread = CSR_SERVER_QUERYCLIENTTHREAD();

    //
    // Keep track of recursion by printer drivers
    //

    if (CallingThread != NULL) {
        if (CallingThread->ImpersonateCount == 0) {
            IF_DEBUG {
                DbgPrint( "CSRSS: CsrRevertToSelf called while not impersonating\n" );
                DbgBreakPoint();
                }
            return FALSE;
            }
        if (--CallingThread->ImpersonateCount > 0)
            return TRUE;
    }

    NewToken = NULL;
    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&NewToken,
                 (ULONG)sizeof(HANDLE)
                 );
    ASSERT( NT_SUCCESS(Status) );

    return NT_SUCCESS(Status);
}

NTSTATUS
CsrUiLookup(
    IN PCLIENT_ID AppClientId,
    OUT PCLIENT_ID DebugUiClientId
    )
{
    PCSR_THREAD Thread;
    NTSTATUS Status;

    Status = STATUS_UNSUCCESSFUL;
    AcquireProcessStructureLock();
    Thread = CsrLocateThreadByClientId( NULL, AppClientId );
    if ( Thread ) {
        if ( Thread->Process->DebugFlags ) {
            *DebugUiClientId = Thread->Process->DebugUserInterface;
            Status = STATUS_SUCCESS;
            }
        }
    ReleaseProcessStructureLock();
    return Status;
}


/*++

Routine Description:

    This function must be called by client DLL's whenever they create a
    thread that runs in the context of CSR.  This function is not called
    for server threads that are attached to a client in the "server
    handle" field.  This function replaces the old static thread tables.

Arguments:

    ThreadHandle - Supplies a handle to the thread.

    ClientId - Supplies the address of the thread's client id.

    Flags - Not Used.

Return Value:

    Returns the address of the static server thread created by this
    function.

--*/

PVOID
CsrAddStaticServerThread(
    IN HANDLE ThreadHandle,
    IN PCLIENT_ID ClientId,
    IN ULONG Flags
    )
{
    PCSR_THREAD Thread;

    AcquireProcessStructureLock();

    ASSERT(CsrRootProcess != NULL);
    Thread = CsrAllocateThread(CsrRootProcess);
    if (Thread) {
        Thread->ThreadHandle = ThreadHandle;

        ProtectHandle(ThreadHandle);

        Thread->ClientId = *ClientId;
        Thread->Flags = Flags;
        InsertTailList(&CsrRootProcess->ThreadList, &Thread->Link);
        CsrRootProcess->ThreadCount++;
    } else {
#if DBG
        DbgPrint("CsrAddStaticServerThread: alloc failed for thread 0x%x\n",
                 HandleToUlong(ThreadHandle));
#endif // DBG
    }

    ReleaseProcessStructureLock();
    return (PVOID)Thread;
}

NTSTATUS
CsrExecServerThread(
    IN PUSER_THREAD_START_ROUTINE StartAddress,
    IN ULONG Flags
    )
{
    PCSR_THREAD Thread;
    NTSTATUS Status;
    HANDLE ThreadHandle;
    CLIENT_ID ClientId;

    AcquireProcessStructureLock();

    ASSERT(CsrRootProcess != NULL);
    Thread = CsrAllocateThread(CsrRootProcess);
    if (Thread == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    Status = RtlCreateUserThread(NtCurrentProcess(),
                                 NULL,
                                 FALSE,
                                 0,
                                 0,
                                 0,
                                 (PUSER_THREAD_START_ROUTINE)StartAddress,
                                 NULL,
                                 &ThreadHandle,
                                 &ClientId);
    if (NT_SUCCESS(Status)) {
        Thread->ThreadHandle = ThreadHandle;

        ProtectHandle(ThreadHandle);

        Thread->ClientId = ClientId;
        Thread->Flags = Flags;
        InsertTailList(&CsrRootProcess->ThreadList, &Thread->Link);
        CsrRootProcess->ThreadCount++;
    } else {
        CsrDeallocateThread(Thread);
    }

Exit:
    ReleaseProcessStructureLock();
    return Status;
}


NTSTATUS
CsrSrvIdentifyAlertableThread(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCSR_THREAD t;

    UNREFERENCED_PARAMETER(m);
    UNREFERENCED_PARAMETER(ReplyStatus);

    t = CSR_SERVER_QUERYCLIENTTHREAD();
    t->Flags |= CSR_ALERTABLE_THREAD;
    return STATUS_SUCCESS;
}


NTSTATUS
CsrSrvSetPriorityClass(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    UNREFERENCED_PARAMETER(m);
    UNREFERENCED_PARAMETER(ReplyStatus);

    return STATUS_SUCCESS;
}


VOID
CsrReferenceThread(
    PCSR_THREAD t
    )
{
    AcquireProcessStructureLock();

    ASSERT((t->Flags & CSR_THREAD_DESTROYED) == 0);
    ASSERT(t->ReferenceCount != 0);

    t->ReferenceCount++;
    ReleaseProcessStructureLock();
}

VOID
CsrProcessRefcountZero(
    PCSR_PROCESS p
    )
{
    CsrRemoveProcess(p);
    if (p->NtSession) {
        CsrDereferenceNtSession(p->NtSession,0);
        }

    //
    // process might not have made it through dll init routine.
    //

    if ( p->ClientPort ) {
        NtClose(p->ClientPort);
        }
    NtClose(p->ProcessHandle );
    CsrDeallocateProcess(p);
}

VOID
CsrDereferenceProcess(
    PCSR_PROCESS p
    )
{
    LONG LockCount;
    AcquireProcessStructureLock();

    LockCount = --(p->ReferenceCount);

    ASSERT(LockCount >= 0);
    if ( !LockCount ) {
        CsrProcessRefcountZero(p);
        }
    else {
        ReleaseProcessStructureLock();
        }
}

VOID
CsrThreadRefcountZero(
    PCSR_THREAD t
    )
{
    PCSR_PROCESS p;
    NTSTATUS Status;

    p = t->Process;

    CsrRemoveThread(t);

    ReleaseProcessStructureLock();

    UnProtectHandle(t->ThreadHandle);
    Status = NtClose(t->ThreadHandle);
    ASSERT(NT_SUCCESS(Status));
    CsrDeallocateThread(t);

    CsrDereferenceProcess(p);
}

VOID
CsrDereferenceThread(
    PCSR_THREAD t
    )
{
    LONG LockCount;
    AcquireProcessStructureLock();

    LockCount = --(t->ReferenceCount);

    ASSERT(LockCount >= 0);
    if ( !LockCount ) {
        CsrThreadRefcountZero(t);
        }
    else {
        ReleaseProcessStructureLock();
        }
}

VOID
CsrLockedReferenceProcess(
    PCSR_PROCESS p
    )
{
    p->ReferenceCount++;

}

VOID
CsrLockedReferenceThread(
    PCSR_THREAD t
    )
{
    t->ReferenceCount++;
}

VOID
CsrLockedDereferenceProcess(
    PCSR_PROCESS p
    )
{
    LONG LockCount;

    LockCount = --(p->ReferenceCount);

    ASSERT(LockCount >= 0);
    if ( !LockCount ) {
        CsrProcessRefcountZero(p);
        AcquireProcessStructureLock();
        }
}

VOID
CsrLockedDereferenceThread(
    PCSR_THREAD t
    )
{
    LONG LockCount;

    LockCount = --(t->ReferenceCount);

    ASSERT(LockCount >= 0);
    if ( !LockCount ) {
        CsrThreadRefcountZero(t);
        AcquireProcessStructureLock();
        }
}

//
// This routine will shutdown processes so either a logoff or a shutdown can
// occur. This simply calls the shutdown process handlers for each .dll until
// one .dll recognizes this process and will shut it down. Only the processes
// with the passed sid are shutdown.
//

NTSTATUS
CsrShutdownProcesses(
    PLUID CallerLuid,
    ULONG Flags
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_PROCESS Process;
    ULONG i;
    PCSR_SERVER_DLL LoadedServerDll;
    ULONG Command;
    BOOLEAN fFirstPass;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    //
    // Question: how do we avoid processes starting when we're in shutdown
    // mode? Can't just set a global because this'll mean no processes can
    // start. Probably need to do it based on the security context of the
    // user shutting down.
    //

    AcquireProcessStructureLock();

    //
    // Mark the root process as system context.
    //

    CsrRootProcess->ShutdownFlags |= SHUTDOWN_SYSTEMCONTEXT;

    //
    // Clear all the bits indicating that shutdown has visited this process.
    //

    ListHead = &CsrRootProcess->ListLink;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Process = CONTAINING_RECORD(ListNext, CSR_PROCESS, ListLink);
        Process->Flags &= ~CSR_PROCESS_SHUTDOWNSKIP;
        Process->ShutdownFlags = 0;
        ListNext = ListNext->Flink;
        }
    try {
        CsrpSetToShutdownPriority();
        while (TRUE) {

            //
            // Find the next process to shutdown.
            //

            Process = FindProcessForShutdown(CallerLuid);

            if (Process == NULL) {
                ReleaseProcessStructureLock();
                Status = STATUS_SUCCESS;
                leave;
                }

            CsrLockedReferenceProcess(Process);

            fFirstPass = TRUE;
TryAgain:
            for (i=0; i<CSR_MAX_SERVER_DLL; i++) {
                LoadedServerDll = CsrLoadedServerDll[ i ];
                if (LoadedServerDll && LoadedServerDll->ShutdownProcessRoutine) {

                    //
                    // Release process structure lock before calling off.
                    // CSR_PROCESS structure is still reference counted.
                    //
                    ReleaseProcessStructureLock();
                    Command = (*LoadedServerDll->ShutdownProcessRoutine)(
                            Process, Flags, fFirstPass);
                    AcquireProcessStructureLock();

                    if (Command == SHUTDOWN_KNOWN_PROCESS) {
                        //
                        // Process structure is unlocked.
                        //
                        break;
                        }
                    if (Command == SHUTDOWN_UNKNOWN_PROCESS) {
                        //
                        // Process structure is locked.
                        //
                        continue;
                        }
                    if (Command == SHUTDOWN_CANCEL) {
#if DBG
                        if (Flags & 4) {
                            DbgPrint("Process %x cancelled forced shutdown (Dll = %d)\n",
                                    Process->ClientId.UniqueProcess, i);
                            DbgBreakPoint();
                        }
#endif
                        //
                        // Unlock process structure.
                        //
                        ReleaseProcessStructureLock();
                        Status = STATUS_CANCELLED;
                        leave;
                        }
                    }
                }

            //
            // No subsystem has an exact match. Now go through them again and
            // let them know there was no exact match. Some .dll should terminate
            // it for us (most likely, console).
            //

            if (fFirstPass && Command == SHUTDOWN_UNKNOWN_PROCESS) {
                fFirstPass = FALSE;
                goto TryAgain;
                }

            //
            // Dereference this process structure if nothing knows about it
            // we hit the end of our loop.
            //
            if (i == CSR_MAX_SERVER_DLL)
                CsrLockedDereferenceProcess(Process);

            }
        }
    finally {
        CsrpSetToNormalPriority();
        }
    return Status;
}

PCSR_PROCESS
FindProcessForShutdown(
    PLUID CallerLuid
    )
{
    LUID ProcessLuid;
    LUID SystemLuid = SYSTEM_LUID;
    PLIST_ENTRY ListHead, ListNext;
    PCSR_PROCESS Process;
    PCSR_PROCESS ProcessT;
    PCSR_THREAD Thread;
    ULONG dwLevel;
    BOOLEAN fEqual;
    NTSTATUS Status;

    ProcessT = NULL;
    dwLevel = 0;

    ListHead = &CsrRootProcess->ListLink;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Process = CONTAINING_RECORD(ListNext, CSR_PROCESS, ListLink);
        ListNext = ListNext->Flink;

        //
        // If we've visited this process already, then skip it.
        //

        if (Process->Flags & CSR_PROCESS_SHUTDOWNSKIP)
            continue;

        //
        // See if this process is running under the passed sid. If not, mark
        // it as visited and continue.
        //

        Status = CsrGetProcessLuid(Process->ProcessHandle, &ProcessLuid);
        if (Status == STATUS_ACCESS_DENIED && Process->ThreadCount > 0) {

            //
            // Impersonate one of the threads and try again.
            //
            Thread = CONTAINING_RECORD( Process->ThreadList.Flink,
                    CSR_THREAD, Link );
            if (CsrImpersonateClient(Thread)) {
                Status = CsrGetProcessLuid(NULL, &ProcessLuid);
                CsrRevertToSelf();
            } else {
                Status = STATUS_BAD_IMPERSONATION_LEVEL;
            }
        }
        if (!NT_SUCCESS(Status)) {

            //
            // We don't have access to this process' luid, so skip it
            //

            Process->Flags |= CSR_PROCESS_SHUTDOWNSKIP;
            continue;
            }

        //
        // is it equal to the system context luid? If so, we want to
        // remember this because we don't terminate this process:
        // we only notify them.
        //

        fEqual = RtlEqualLuid(&ProcessLuid,&SystemLuid);
        if (fEqual) {
            Process->ShutdownFlags |= SHUTDOWN_SYSTEMCONTEXT;
            }

        //
        // See if this process's luid is the same as the luid we're supposed
        // to shut down (CallerSid).
        //

        if (!fEqual) {
            fEqual = RtlEqualLuid(&ProcessLuid, CallerLuid);
            }

        //
        // If not equal to either, mark it as such and return
        //

        if (!fEqual) {
            Process->ShutdownFlags |= SHUTDOWN_OTHERCONTEXT;
            }

        if (Process->ShutdownLevel > dwLevel || ProcessT == NULL) {
            dwLevel = Process->ShutdownLevel;
            ProcessT = Process;
            }
        }

    if (ProcessT != NULL) {
        ProcessT->Flags |= CSR_PROCESS_SHUTDOWNSKIP;
        return ProcessT;
        }

    return NULL;
}

NTSTATUS
CsrGetProcessLuid(
    HANDLE ProcessHandle,
    PLUID LuidProcess
    )
{
    HANDLE UserToken = NULL;
    PTOKEN_STATISTICS pStats;
    ULONG BytesRequired;
    NTSTATUS Status, CloseStatus;

    if (ProcessHandle == NULL) {

        //
        // Check for a thread token first
        //

        Status = NtOpenThreadToken(NtCurrentThread(), TOKEN_QUERY, FALSE,
                &UserToken);

        if (!NT_SUCCESS(Status)) {
            if (Status != STATUS_NO_TOKEN)
                return Status;

            //
            // No thread token, go to the process
            //

            ProcessHandle = NtCurrentProcess();
            UserToken = NULL;
            }
        }

    if (UserToken == NULL) {
        Status = NtOpenProcessToken(ProcessHandle, TOKEN_QUERY, &UserToken);
        if (!NT_SUCCESS(Status))
            return Status;
        }

    Status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenStatistics,           // TokenInformationClass
                 NULL,                      // TokenInformation
                 0,                         // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        NtClose(UserToken);
        return Status;
        }

    //
    // Allocate space for the user info
    //

    pStats = (PTOKEN_STATISTICS)RtlAllocateHeap(CsrHeap, MAKE_TAG( TMP_TAG ), BytesRequired);
    if (pStats == NULL) {
        NtClose(UserToken);
        return Status;
        }

    //
    // Read in the user info
    //

    Status = NtQueryInformationToken(
                 UserToken,             // Handle
                 TokenStatistics,       // TokenInformationClass
                 pStats,                // TokenInformation
                 BytesRequired,         // TokenInformationLength
                 &BytesRequired         // ReturnLength
                 );

    //
    // We're finished with the token handle
    //

    CloseStatus = NtClose(UserToken);
    ASSERT(NT_SUCCESS(CloseStatus));

    //
    // Return the authentication LUID
    //

    *LuidProcess = pStats->AuthenticationId;

    RtlFreeHeap(CsrHeap, 0, pStats);
    return Status;
}

VOID
CsrSetCallingSpooler(
    BOOLEAN fSet)
{
    //
    // Obsolete function that may be called by third part drivers.
    //

    UNREFERENCED_PARAMETER(fSet);
}

//
// This routine creates a process based on a message passed in to sb port.
// Used by smss to have Posix and OS/2 apps created in the appropriate
// (terminal server) session.
//

BOOLEAN
CsrSbCreateProcess(
    IN OUT PSBAPIMSG m
    )
{
    NTSTATUS Status;
    RTL_USER_PROCESS_INFORMATION ProcessInformation;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PROCESS_SESSION_INFORMATION ProcessInfo;
    PSBCREATEPROCESS a = &(m->u.CreateProcess);
    HANDLE RemoteProcess = NULL;
    CLIENT_ID RemoteClientId;
    UNICODE_STRING ImageFileName, DefaultLibPath, CurrentDirectory, CommandLine;
    PVOID DefaultEnvironment = NULL;
    PROCESS_BASIC_INFORMATION ProcInfo;
    OBJECT_ATTRIBUTES ObjA;

    RtlInitUnicodeString(&ImageFileName,NULL);
    RtlInitUnicodeString(&DefaultLibPath,NULL);
    RtlInitUnicodeString(&CurrentDirectory,NULL);
    RtlInitUnicodeString(&CommandLine,NULL);

    Status = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessBasicInformation,
                                       &ProcInfo,
                                       sizeof(ProcInfo),
                                       NULL
                                       );

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: NtQueryInformationProcess failed - Status = %lx\n", Status );
        goto Done;
    }

    InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
    RemoteClientId.UniqueProcess = (HANDLE)ProcInfo.InheritedFromUniqueProcessId;
    RemoteClientId.UniqueThread = NULL;

    Status = NtOpenProcess(&RemoteProcess,
                           PROCESS_ALL_ACCESS,
                           &ObjA,
                           &RemoteClientId);

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: NtOpenProcess failed - Status = %lx\n", Status );
        goto Done;
    }

    //
    // Read pointer parameters from calling process's virtual memory
    //

    Status = ReadUnicodeString(RemoteProcess,a->i.ImageFileName,&ImageFileName);


    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: ReadUnicodeString ImageFileName failed - Status = %lx\n", Status );
        goto Done;
    }

    Status = ReadUnicodeString(RemoteProcess,a->i.DefaultLibPath,&DefaultLibPath);

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: ReadUnicodeString DefaultLibPath failed - Status = %lx\n", Status );
        goto Done;
    }

    Status = ReadUnicodeString(RemoteProcess,a->i.CurrentDirectory,&CurrentDirectory);

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: ReadUnicodeString CurrentDirectory failed - Status = %lx\n", Status );
        goto Done;
    }

    Status = ReadUnicodeString(RemoteProcess,a->i.CommandLine,&CommandLine);

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: ReadUnicodeString CommandLine failed - Status = %lx\n", Status );
        goto Done;
    }

    //
    // Copy our environment to be used by new process
    //
    Status = RtlCreateEnvironment(TRUE, &DefaultEnvironment);

    if (!NT_SUCCESS( Status )) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: Can't create environemnt\n");
        goto Done;
    }

    Status = RtlCreateProcessParameters( &ProcessParameters,
                                         &ImageFileName,
                                         DefaultLibPath.Length == 0 ?
                                            NULL : &DefaultLibPath,
                                         &CurrentDirectory,
                                         &CommandLine,
                                         DefaultEnvironment,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL
                                       );

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: RtlCreateProcessParameters failed - Status = %lx\n", Status );
        goto Done;
    }
    if (a->i.Flags & SMP_DEBUG_FLAG) {
        ProcessParameters->DebugFlags = TRUE;
        }
    else {
        ProcessParameters->DebugFlags = a->i.DefaultDebugFlags;
        }

    if ( a->i.Flags & SMP_SUBSYSTEM_FLAG ) {
        ProcessParameters->Flags |= RTL_USER_PROC_RESERVE_1MB;
        }

    ProcessInformation.Length = sizeof( RTL_USER_PROCESS_INFORMATION );
    Status = RtlCreateUserProcess( &ImageFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   ProcessParameters,
                                   NULL,
                                   NULL,
                                   RemoteProcess, // set smss as the parent
                                   FALSE,
                                   NULL,
                                   NULL,
                                   &ProcessInformation
                                 );

    RtlDestroyProcessParameters( ProcessParameters );

    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: RtlCreateUserProcess failed - Status = %lx\n", Status );
        goto Done;
    }

    if( IsTerminalServer() ) {

        //
        // Set the MuSessionId in the PEB of the new process
        //

       ProcessInfo.SessionId = NtCurrentPeb()->SessionId;
       if(ProcessInfo.SessionId){
          NTSTATUS Status = STATUS_SUCCESS;
          PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;
          UNICODE_STRING UnicodeString;
          OBJECT_ATTRIBUTES Attributes;
          HANDLE DirectoryHandle = NULL;
          WCHAR szSessionString[MAX_SESSION_PATH];

          //  Change the devmap of the process to per session
          //
          swprintf(szSessionString,L"%ws\\%ld%ws",SESSION_ROOT,NtCurrentPeb()->SessionId,DOSDEVICES);
          RtlInitUnicodeString( &UnicodeString, szSessionString );

          InitializeObjectAttributes( &Attributes,
                                      &UnicodeString,
                                      OBJ_CASE_INSENSITIVE,
                                      NULL,
                                      NULL
                                    );

          Status = NtOpenDirectoryObject( &DirectoryHandle,
                                          DIRECTORY_ALL_ACCESS,
                                          &Attributes
                                        );
          if (!NT_SUCCESS( Status )) {
             DbgPrint("CSRSS: NtOpenDirectoryObject failed in CsrSbCreateProcess - status = %lx\n", Status);
             goto Done;
          }

          ProcessDeviceMapInfo.Set.DirectoryHandle = DirectoryHandle;

          Status = NtSetInformationProcess( ProcessInformation.Process,
                                            ProcessDeviceMap,
                                            &ProcessDeviceMapInfo.Set,
                                            sizeof( ProcessDeviceMapInfo.Set )
                                          );
          if (!NT_SUCCESS( Status )) {
             DbgPrint("CSRSS: NtSetInformationProcess failed in CsrSbCreateProcess - status = %lx\n", Status);
             if (DirectoryHandle) {
                NtClose(DirectoryHandle);
             }
             goto Done;

          }

          if (DirectoryHandle) {
             NtClose(DirectoryHandle);
          }
        }

        Status = NtSetInformationProcess( ProcessInformation.Process,
                                          ProcessSessionInformation,
                                          &ProcessInfo, sizeof( ProcessInfo ));

        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "CSRSS: CsrSrvCreateProcess: NtSetInformationProcess failed - Status = %lx\n", Status );
            goto Done;
        }
    }

    if (!(a->i.Flags & SMP_DONT_START)) {
        if (ProcessInformation.ImageInformation.SubSystemType !=
            IMAGE_SUBSYSTEM_NATIVE
           ) {
            NtTerminateProcess( ProcessInformation.Process,
                                STATUS_INVALID_IMAGE_FORMAT
                              );

            NtWaitForSingleObject( ProcessInformation.Thread, FALSE, NULL );

            NtClose( ProcessInformation.Thread );
            NtClose( ProcessInformation.Process );

            Status = STATUS_INVALID_IMAGE_FORMAT;
            goto Done;
        }

        Status = NtResumeThread( ProcessInformation.Thread, NULL );
        if (!NT_SUCCESS(Status)) {
            DbgPrint( "CSRSS: CsrSrvCreateProcess - NtResumeThread failed Status %lx\n",Status );
            goto Done;
        }

        if (!(a->i.Flags & SMP_ASYNC_FLAG)) {
            NtWaitForSingleObject( ProcessInformation.Thread, FALSE, NULL );
        }

        NtClose( ProcessInformation.Thread );
        NtClose( ProcessInformation.Process );

    }

    //
    // Copy output parameters to message
    //
    a->o.SubSystemType = ProcessInformation.ImageInformation.SubSystemType;
    a->o.ClientId.UniqueProcess = ProcessInformation.ClientId.UniqueProcess;
    a->o.ClientId.UniqueThread = ProcessInformation.ClientId.UniqueThread;

    //
    // Convert handles to caller's process
    //

    Status = NtDuplicateObject( NtCurrentProcess(),
                                ProcessInformation.Process,
                                RemoteProcess,
                                &a->o.Process,
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS
                                );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: NtDuplicateObject failed for process - Status = %lx\n", Status );
        goto Done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                ProcessInformation.Thread,
                                RemoteProcess,
                                &a->o.Thread,
                                0,
                                FALSE,
                                DUPLICATE_SAME_ACCESS
                                );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint( "CSRSS: CsrSrvCreateProcess: NtDuplicateObject failed for thread - Status = %lx\n", Status );
        goto Done;
    }

Done:
    if (NULL != ImageFileName.Buffer)
        RtlFreeHeap(CsrHeap,0,ImageFileName.Buffer);
    if (NULL != DefaultLibPath.Buffer)
        RtlFreeHeap(CsrHeap,0,DefaultLibPath.Buffer);
    if (NULL != CurrentDirectory.Buffer)
        RtlFreeHeap(CsrHeap,0,CurrentDirectory.Buffer);
    if (NULL != CommandLine.Buffer)
        RtlFreeHeap(CsrHeap,0,CommandLine.Buffer);
    if (NULL != RemoteProcess)
        NtClose(RemoteProcess);

    m->ReturnedStatus = Status;
    return TRUE;
}

//
// This routine will copy a UNICODE_STRING from a remote process to this one
//
NTSTATUS
ReadUnicodeString(HANDLE ProcessHandle,
                  PUNICODE_STRING RemoteString,
                  PUNICODE_STRING LocalString
                  )
{
    PWSTR Buffer = NULL;
    NTSTATUS Status;

    RtlInitUnicodeString(LocalString, NULL);

    if (NULL != RemoteString) {
        Status = NtReadVirtualMemory(ProcessHandle,
                                     RemoteString,
                                     LocalString,
                                     sizeof(UNICODE_STRING),
                                     NULL);

        if ( !NT_SUCCESS( Status ) ) {
            DbgPrint( "CSRSS: ReadUnicodeString: NtReadVirtualMemory failed - Status = %lx\n", Status );
            return Status;
        }

        if ((0 != LocalString->Length) && (NULL != LocalString->Buffer)) {
            Buffer = RtlAllocateHeap( CsrHeap,
                                      MAKE_TAG( PROCESS_TAG ),
                                      LocalString->Length + sizeof(WCHAR)
                                      );

            if (Buffer == NULL) {
                return STATUS_NO_MEMORY;
            }

            Status = NtReadVirtualMemory(ProcessHandle,
                                         LocalString->Buffer,
                                         Buffer,
                                         LocalString->Length + sizeof(WCHAR),
                                         NULL);

            if ( !NT_SUCCESS( Status ) ) {
                DbgPrint( "CSRSS: ReadUnicodeString: NtReadVirtualMemory Buffer failed - Status = %lx\n", Status );

                RtlFreeHeap(CsrHeap,0,Buffer);
                LocalString->Buffer = NULL;   // don't want caller to free this

                return Status;
            }

            LocalString->Buffer = Buffer;
        }
    }

    return STATUS_SUCCESS;
}

#if CSRSS_PROTECT_HANDLES
BOOLEAN
ProtectHandle(
    HANDLE hObject
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        HandleInfo.ProtectFromClose = TRUE;

        Status = NtSetInformationObject( hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof( HandleInfo )
                                       );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        }

    return FALSE;
}


BOOLEAN
UnProtectHandle(
    HANDLE hObject
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        HandleInfo.ProtectFromClose = FALSE;

        Status = NtSetInformationObject( hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof( HandleInfo )
                                       );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        }

    return FALSE;
}
#endif // CSRSS_PROTECT_HANDLES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\srvloadr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    srvloadr.c

Abstract:

    This is the server DLL loader module for the Server side of the Client
    Server Runtime Subsystem (CSRSS)

Author:

    Steve Wood (stevewo) 08-Oct-1990

Environment:

    User Mode Only

Revision History:

--*/

#include "csrsrv.h"
#include "windows.h"

#ifdef _IA64_
#include <ntia64.h>
#endif // _IA64_

EXCEPTION_DISPOSITION
CsrUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    UNICODE_STRING UnicodeParameter;
    ULONG_PTR Parameters[ 4 ];
    ULONG Response;
    BOOLEAN WasEnabled;
    NTSTATUS Status;
    LONG lReturn = EXCEPTION_EXECUTE_HANDLER;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;

    //
    // Terminating will cause sm's wait to sense that we crashed. This will
    // result in a clean shutdown due to sm's hard error logic
    //

    Status = NtQuerySystemInformation( SystemKernelDebuggerInformation,
                               &KernelDebuggerInfo,
                               sizeof(KernelDebuggerInfo),
                               NULL
                             );

    //
    // Under Hydra, we don't want to shutdown the system just
    // because the Win32 subsystem is going away.  In case of non-console CSRSS,
    // causing the process to terminate is sufficient.
    //
    if ((NtCurrentPeb()->SessionId == 0) || 
          (NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled)) {

        lReturn = RtlUnhandledExceptionFilter(ExceptionInfo);

        if (lReturn != EXCEPTION_CONTINUE_EXECUTION)
        {
            //
            // We are hosed, so raise a fatal system error to shutdown the system.
            // (Basically a user mode KeBugCheck).
            //

            Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                         (BOOLEAN)TRUE,
                                         TRUE,
                                         &WasEnabled
                                       );

            if (Status == STATUS_NO_TOKEN) {

                //
                // No thread token, use the process token
                //

                Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                                             (BOOLEAN)TRUE,
                                             FALSE,
                                             &WasEnabled
                                           );
                }

            RtlInitUnicodeString( &UnicodeParameter, L"Windows SubSystem" );
            Parameters[ 0 ] = (ULONG_PTR)&UnicodeParameter;
            Parameters[ 1 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionCode;
            Parameters[ 2 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress;
            Parameters[ 3 ] = (ULONG_PTR)ExceptionInfo->ContextRecord;
            Status = NtRaiseHardError( STATUS_SYSTEM_PROCESS_TERMINATED,
                                       4,
                                       1,
                                       Parameters,
                                       OptionShutdownSystem,
                                       &Response
                                     );
        }
    }

    if (lReturn != EXCEPTION_CONTINUE_EXECUTION)
    {
        //
        // If this returns, giveup
        //

        NtTerminateProcess(NtCurrentProcess(),ExceptionInfo->ExceptionRecord->ExceptionCode);
    }

    return lReturn;
}


NTSTATUS
CsrLoadServerDll(
    IN PCH ModuleName,
    IN PCH InitRoutineString,
    IN ULONG ServerDllIndex
    )
{
    NTSTATUS Status;
    ANSI_STRING ModuleNameString;
    UNICODE_STRING ModuleNameString_U;
    HANDLE ModuleHandle;
    PCSR_SERVER_DLL LoadedServerDll;
    STRING ProcedureNameString;
    PCSR_SERVER_DLL_INIT_ROUTINE ServerDllInitialization;
    ULONG n;

    if (ServerDllIndex >= CSR_MAX_SERVER_DLL) {
        return( STATUS_TOO_MANY_NAMES );
        }

    if (CsrLoadedServerDll[ ServerDllIndex ] != NULL) {
        return( STATUS_INVALID_PARAMETER );
        }

    ASSERT( ModuleName != NULL );
    RtlInitAnsiString( &ModuleNameString, ModuleName );

    if (ServerDllIndex != CSRSRV_SERVERDLL_INDEX) {
        Status = RtlAnsiStringToUnicodeString(&ModuleNameString_U, &ModuleNameString, TRUE);
        if (!NT_SUCCESS(Status)) {
            return Status;
            }
        Status = LdrLoadDll( UNICODE_NULL, NULL, &ModuleNameString_U, &ModuleHandle );
        if ( !NT_SUCCESS(Status) ) {

            PUNICODE_STRING ErrorStrings[2];
            UNICODE_STRING ErrorDllPath;
            ULONG ErrorResponse;
            NTSTATUS ErrorStatus;

            ErrorStrings[0] = &ModuleNameString_U;
            ErrorStrings[1] = &ErrorDllPath;
            RtlInitUnicodeString(&ErrorDllPath,L"Default Load Path");

            //
            // need to get image name
            //

            ErrorStatus = NtRaiseHardError(
                            (NTSTATUS)STATUS_DLL_NOT_FOUND,
                            2,
                            0x00000003,
                            (PULONG_PTR)ErrorStrings,
                            OptionOk,
                            &ErrorResponse
                            );

            }
        RtlFreeUnicodeString(&ModuleNameString_U);
        if (!NT_SUCCESS( Status )) {
            return( Status );
            }
        }
    else {
        ModuleHandle = NULL;
        }

    n = sizeof( *LoadedServerDll ) + ModuleNameString.MaximumLength;

    LoadedServerDll = RtlAllocateHeap( CsrHeap, MAKE_TAG( INIT_TAG ), n );
    if (LoadedServerDll == NULL) {
        if (ModuleHandle != NULL) {
            LdrUnloadDll( ModuleHandle );
            }

        return( STATUS_NO_MEMORY );
        }

    RtlZeroMemory( LoadedServerDll, n );
    LoadedServerDll->SharedStaticServerData = CsrSrvSharedSectionHeap;
    LoadedServerDll->Length = n;
    LoadedServerDll->CsrInitializationEvent = CsrInitializationEvent;
    LoadedServerDll->ModuleName.Length = ModuleNameString.Length;
    LoadedServerDll->ModuleName.MaximumLength = ModuleNameString.MaximumLength;
    LoadedServerDll->ModuleName.Buffer = (PCH)(LoadedServerDll+1);
    if (ModuleNameString.Length != 0) {
        strncpy( LoadedServerDll->ModuleName.Buffer,
                 ModuleNameString.Buffer,
                 ModuleNameString.Length
               );
        }

    LoadedServerDll->ServerDllIndex = ServerDllIndex;
    LoadedServerDll->ModuleHandle = ModuleHandle;

    if (ModuleHandle != NULL) {

        RtlInitString(
            &ProcedureNameString,
            (InitRoutineString == NULL) ? "ServerDllInitialization" : InitRoutineString);

        Status = LdrGetProcedureAddress( ModuleHandle,
                                         &ProcedureNameString,
                                         0,
                                         (PVOID *) &ServerDllInitialization
                                       );
        }
    else {
        ServerDllInitialization = CsrServerDllInitialization;
        Status = STATUS_SUCCESS;
        }

    if (NT_SUCCESS( Status )) {
        try {
            Status = (*ServerDllInitialization)( LoadedServerDll );
            }
        except ( CsrUnhandledExceptionFilter( GetExceptionInformation() ) ){
            Status = GetExceptionCode();
            }
        if (NT_SUCCESS( Status )) {
            CsrTotalPerProcessDataLength += (ULONG)QUAD_ALIGN(LoadedServerDll->PerProcessDataLength);

            CsrLoadedServerDll[ LoadedServerDll->ServerDllIndex ] =
                LoadedServerDll;
            if ( LoadedServerDll->SharedStaticServerData != CsrSrvSharedSectionHeap ) {
                CsrSrvSharedStaticServerData[LoadedServerDll->ServerDllIndex] = LoadedServerDll->SharedStaticServerData;
                }
            }
        else {
            if (ModuleHandle != NULL) {
                LdrUnloadDll( ModuleHandle );
                }

            RtlFreeHeap( CsrHeap, 0, LoadedServerDll );
            }
        }
    else {
        if (ModuleHandle != NULL) {
            LdrUnloadDll( ModuleHandle );
            }

        RtlFreeHeap( CsrHeap, 0, LoadedServerDll );
        }

    return( Status );
}


ULONG
CsrSrvClientConnect(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status;
    PCSR_CLIENTCONNECT_MSG a = (PCSR_CLIENTCONNECT_MSG)&m->u.ApiMessageData;
    PCSR_SERVER_DLL LoadedServerDll;

    *ReplyStatus = CsrReplyImmediate;

    if (a->ServerDllIndex >= CSR_MAX_SERVER_DLL) {
        return( (ULONG)STATUS_TOO_MANY_NAMES );
        }

    if (CsrLoadedServerDll[ a->ServerDllIndex ] == NULL) {
        return( (ULONG)STATUS_INVALID_PARAMETER );
        }

    if (!CsrValidateMessageBuffer(m, &a->ConnectionInformation, a->ConnectionInformationLength, sizeof(BYTE))) {
        return( (ULONG)STATUS_INVALID_PARAMETER );
        }

    LoadedServerDll = CsrLoadedServerDll[ a->ServerDllIndex ];

    if (LoadedServerDll->ConnectRoutine) {

        Status = (LoadedServerDll->ConnectRoutine)(
                        (CSR_SERVER_QUERYCLIENTTHREAD())->Process,
                        a->ConnectionInformation,
                        &a->ConnectionInformationLength
                        );
        }
    else {
        Status = STATUS_SUCCESS;
        }

    return( (ULONG)Status );
}


NTSTATUS
CsrSrvCreateSharedSection(
    IN PCH SizeParameter
    )
{
    NTSTATUS Status;
    LARGE_INTEGER SectionSize;
    SIZE_T ViewSize;
    ULONG HeapSize;
    ULONG AllocationAttributes;
    PCH s;
    ULONG FirstCsr = (NtCurrentPeb()->SessionId == 0);

#if defined(_WIN64)
    PVOID BaseAddress;
    SIZE_T RegionSize;
#endif

    if (SizeParameter == NULL) {
        return STATUS_INVALID_PARAMETER;
        }

    s = SizeParameter;
    while (*s) {
        if (*s == ',') {
            *s++ = '\0';
            break;
            }
        else {
            s++;
            }
        }


    if (!*s) {
        return( STATUS_INVALID_PARAMETER );
        }

    Status = RtlCharToInteger( SizeParameter,
                               0,
                               &HeapSize
                             );
    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    HeapSize = ROUND_UP_TO_PAGES( HeapSize * 1024 );
    CsrSrvSharedSectionSize = HeapSize;

    SectionSize.LowPart = CsrSrvSharedSectionSize;
    SectionSize.HighPart = 0;

    if (FirstCsr) {
        AllocationAttributes = SEC_BASED | SEC_RESERVE;
    }
    else {
        AllocationAttributes = SEC_RESERVE;
    }

    Status = NtCreateSection( &CsrSrvSharedSection,
                              SECTION_ALL_ACCESS,
                              (POBJECT_ATTRIBUTES) NULL,
                              &SectionSize,
                              PAGE_EXECUTE_READWRITE,
                              AllocationAttributes,
                              (HANDLE) NULL
                            );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    ViewSize = 0;

#if defined(_WIN64)
    CsrSrvSharedSectionBase = (PVOID)CSR_SYSTEM_SHARED_ADDRESS;
#else
    if (FirstCsr) {
        CsrSrvSharedSectionBase = NULL;
    }
    else {

        //
        // Retrieve the value of CsrSrvSharedSectionBase from registry
        // This is saved by the First CSRSS process and used by others
        //


        HANDLE hKey;
        OBJECT_ATTRIBUTES   Obja;
        ULONG               Attributes;
        UNICODE_STRING      KeyName;

        Attributes = OBJ_CASE_INSENSITIVE;

        RtlInitUnicodeString( &KeyName, CSR_BASE_PATH );

        InitializeObjectAttributes(&Obja,
                                   &KeyName,
                                   Attributes,
                                   NULL,
                                   NULL);

        Status = NtOpenKey(&hKey,
                           KEY_READ,
                           &Obja);

        if (NT_SUCCESS(Status)) {

            ULONG  BufferLength;
            ULONG  ResultLength;
            BYTE   PrivateKeyValueInformation[ sizeof( KEY_VALUE_PARTIAL_INFORMATION ) +
                                                + sizeof(DWORD) ];

            BufferLength = sizeof( PrivateKeyValueInformation );

            RtlInitUnicodeString( &KeyName, L"CsrSrvSharedSectionBase" );

            if (NT_SUCCESS(Status = NtQueryValueKey( hKey,
                                                    &KeyName,
                                                    KeyValuePartialInformation,
                                                    PrivateKeyValueInformation,
                                                    BufferLength,
                                                    &ResultLength
                                                    ))) {

                RtlMoveMemory( &CsrSrvSharedSectionBase,
                   (( PKEY_VALUE_PARTIAL_INFORMATION )
                        PrivateKeyValueInformation )->Data,
                   (( PKEY_VALUE_PARTIAL_INFORMATION )
                        PrivateKeyValueInformation )->DataLength
                 );

            }

            ASSERT(NT_SUCCESS(Status));

            NtClose(hKey);

        }

        if (!NT_SUCCESS(Status)) {

            ASSERT(NT_SUCCESS(Status));

            return Status;
        }

    }
#endif

#if defined(_WIN64)

    // For compatibility reasons, on Win64 the csrss shared section
    // needs to be at an address below 2GB.  Since it is difficult to
    // find an address in the middle of the address space that is
    // guaranteed to be available in all processes, the memory
    // manager reserves an address at the top of the 2GB range.
    // To use this memory, CSRSS first unreserves the memory and
    // then maps in the section.  A possible race condition exits
    // if another thread tries to allocate the memory at the same
    // time, but this is highly unlikely since in the current NT
    // code the mapping and unmapping will always occure in DLL_PROCESS_ATTACH
    // in kernel32.dll.  This code executely when the first thread
    // of the process is initialized, and all newly created threads
    // are blocked untill this code completes.

    BaseAddress = (PVOID)CSR_SYSTEM_SHARED_ADDRESS;
    RegionSize = CsrSrvSharedSectionSize;

    Status = NtFreeVirtualMemory(NtCurrentProcess(),
                                 &BaseAddress,
                                 &RegionSize,
                                 MEM_RELEASE
                                );

    if (!NT_SUCCESS(Status)) {
        NtClose( CsrSrvSharedSection );
        return Status;
    }
#endif

    Status = NtMapViewOfSection( CsrSrvSharedSection,
                                 NtCurrentProcess(),
                                 &CsrSrvSharedSectionBase,
                                 0,     // Zerobits?
                                 0,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 MEM_TOP_DOWN,
                                 PAGE_EXECUTE_READWRITE
                               );
    if (!NT_SUCCESS( Status )) {

#if defined(_WIN64)

        // For this code to execute, either the race condition
        // described above occured for some unknown reason or
        // the memory manager or process is corrupt.  With the lack
        // of an atom uncommit and map, the best that can be done is
        // try to reallocate the memory.  If this fails, everything
        // is hopeless.

        BaseAddress = (PVOID)CSR_SYSTEM_SHARED_ADDRESS;
        RegionSize = CsrSrvSharedSectionSize;
        NtAllocateVirtualMemory(NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                &RegionSize,
                                MEM_RESERVE,
                                PAGE_READONLY
                               );
#endif

        NtClose( CsrSrvSharedSection );
        return( Status );
        }
    CsrSrvSharedSectionHeap = CsrSrvSharedSectionBase;

    if (IsTerminalServer() && FirstCsr) {
        //
        //save CsrSrvSharedSectionBase in registry for other csrs
        //
        HKEY hKey;
        OBJECT_ATTRIBUTES   Obja;
        ULONG               Attributes;
        UNICODE_STRING      KeyName;
        DWORD               dwDisposition;

        Attributes = OBJ_CASE_INSENSITIVE;

        RtlInitUnicodeString( &KeyName, CSR_BASE_PATH );

        InitializeObjectAttributes(&Obja,
                                   &KeyName,
                                   Attributes,
                                   NULL,
                                   NULL);


        Status = NtCreateKey(&hKey,
                             KEY_WRITE,
                             &Obja,
                             0,
                             NULL,
                             REG_OPTION_VOLATILE,
                             &dwDisposition);



        if (NT_SUCCESS(Status)) {

            RtlInitUnicodeString( &KeyName, L"CsrSrvSharedSectionBase" );

            Status =  NtSetValueKey(
                            hKey,
                            &KeyName,
                            0,
                            REG_DWORD,
                            (LPBYTE)&CsrSrvSharedSectionBase,
                            sizeof(CsrSrvSharedSectionBase)
                            );

            ASSERT(NT_SUCCESS(Status));

            NtClose(hKey);
        } else {

            ASSERT(NT_SUCCESS(Status));

        }

    }

    if (RtlCreateHeap( HEAP_ZERO_MEMORY | HEAP_CLASS_7,
                       CsrSrvSharedSectionHeap,
                       HeapSize,
                       4*1024,
                       0,
                       0
                     ) == NULL
       ) {
        NtUnmapViewOfSection( NtCurrentProcess(),
                              CsrSrvSharedSectionBase
                            );
        NtClose( CsrSrvSharedSection );
        return( STATUS_NO_MEMORY );
        }

    CsrSharedBaseTag = RtlCreateTagHeap( CsrSrvSharedSectionHeap,
                                         0,
                                         L"CSRSHR!",
                                         L"!CSRSHR\0"
                                         L"INIT\0"
                                       );
    CsrSrvSharedStaticServerData = (PVOID *)RtlAllocateHeap(
                                            CsrSrvSharedSectionHeap,
                                            MAKE_SHARED_TAG( SHR_INIT_TAG ),
                                            CSR_MAX_SERVER_DLL * sizeof(PVOID)
                                            );

	if (CsrSrvSharedStaticServerData == NULL) {
		return STATUS_NO_MEMORY;
	}
    NtCurrentPeb()->ReadOnlySharedMemoryBase = CsrSrvSharedSectionBase;
    NtCurrentPeb()->ReadOnlySharedMemoryHeap = CsrSrvSharedSectionHeap;
    NtCurrentPeb()->ReadOnlyStaticServerData = (PVOID *)CsrSrvSharedStaticServerData;

    return( STATUS_SUCCESS );
}


NTSTATUS
CsrSrvAttachSharedSection(
    IN PCSR_PROCESS Process OPTIONAL,
    OUT PCSR_API_CONNECTINFO p
    )
{
    NTSTATUS Status;
    SIZE_T ViewSize;

#if defined(_WIN64)
    PVOID BaseAddress;
    SIZE_T RegionSize;
#endif

    if (ARGUMENT_PRESENT( Process )) {

#if defined(_WIN64)

        BaseAddress = (PVOID)CSR_SYSTEM_SHARED_ADDRESS;
        RegionSize = CsrSrvSharedSectionSize;

        Status = NtFreeVirtualMemory(Process->ProcessHandle,
                                     &BaseAddress,
                                     &RegionSize,
                                     MEM_RELEASE
                                    );
        if(!NT_SUCCESS(Status)) {
           return Status;
           }
#endif

        ViewSize = 0;
        Status = NtMapViewOfSection( CsrSrvSharedSection,
                                     Process->ProcessHandle,
                                     &CsrSrvSharedSectionBase,
                                     0,
                                     0,
                                     NULL,
                                     &ViewSize,
                                     ViewUnmap,
                                     SEC_NO_CHANGE,
                                     PAGE_EXECUTE_READ
                                   );
        if (!NT_SUCCESS( Status )) {

#if defined(_WIN64)
            BaseAddress = (PVOID)CSR_SYSTEM_SHARED_ADDRESS;
            RegionSize = CsrSrvSharedSectionSize;

            NtAllocateVirtualMemory(Process->ProcessHandle,
                                    &BaseAddress,
                                    0,
                                    &RegionSize,
                                    MEM_RESERVE,
                                    PAGE_READONLY
                                   );
#endif

            return( Status );
            }
        }

    p->SharedSectionBase = CsrSrvSharedSectionBase;
    p->SharedSectionHeap = CsrSrvSharedSectionHeap;
    p->SharedStaticServerData = CsrSrvSharedStaticServerData;

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\csr\server\wait.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    wait.c

Abstract:

    This module contains the primitives to implement the Wait functions
    on the Server side of the Client-Server Runtime Subsystem to the
    Session Manager SubSystem.

Author:

    Steve Wood (stevewo) 8-Oct-1990

Revision History:

--*/

#include "csrsrv.h"

BOOLEAN
CsrInitializeWait(
    IN CSR_WAIT_ROUTINE WaitRoutine,
    IN PCSR_THREAD WaitingThread,
    IN OUT PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    OUT PCSR_WAIT_BLOCK *WaitBlockPtr
    )

{
    ULONG Length;
    PCSR_WAIT_BLOCK WaitBlock;

    Length = sizeof( *WaitBlock ) - sizeof( WaitBlock->WaitReplyMessage ) +
             WaitReplyMessage->h.u1.s1.TotalLength;

    WaitBlock = RtlAllocateHeap( CsrHeap, MAKE_TAG( WAIT_TAG ), Length );
    if (WaitBlock == NULL) {
        WaitReplyMessage->ReturnValue = (ULONG)STATUS_NO_MEMORY;
        return( FALSE );
        }

    WaitBlock->Length = Length;
    WaitBlock->WaitingThread = WaitingThread;
    WaitBlock->WaitParameter = WaitParameter;
    WaitBlock->WaitRoutine = WaitRoutine;
    WaitBlock->UserLink.Flink = WaitBlock->UserLink.Blink = NULL;
    WaitBlock->Link.Flink = WaitBlock->Link.Blink = NULL;
    RtlMoveMemory( &WaitBlock->WaitReplyMessage,
                   WaitReplyMessage,
                   WaitReplyMessage->h.u1.s1.TotalLength
                 );
    *WaitBlockPtr = WaitBlock;
    return TRUE;
}

BOOLEAN
CsrCreateWait(
    IN PLIST_ENTRY WaitQueue,
    IN CSR_WAIT_ROUTINE WaitRoutine,
    IN PCSR_THREAD WaitingThread,
    IN OUT PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PLIST_ENTRY UserLinkListHead OPTIONAL
    )
{
    PCSR_WAIT_BLOCK WaitBlock;

    if (!CsrInitializeWait( WaitRoutine,
                            WaitingThread,
                            WaitReplyMessage,
                            WaitParameter,
                            &WaitBlock
                          )
       ) {
        return FALSE;
        }

    AcquireWaitListsLock();

    if ( WaitingThread->Flags & CSR_THREAD_DESTROYED ) {
        RtlFreeHeap( CsrHeap, 0, WaitBlock );
        ReleaseWaitListsLock();
        return FALSE;
    }

    WaitingThread->WaitBlock = WaitBlock;

    InsertTailList( WaitQueue, &WaitBlock->Link );

    if ( ARGUMENT_PRESENT(UserLinkListHead) ) {
        InsertTailList( UserLinkListHead, &WaitBlock->UserLink );
        }

    ReleaseWaitListsLock();
    return( TRUE );
}


BOOLEAN
CsrNotifyWaitBlock(
    IN PCSR_WAIT_BLOCK WaitBlock,
    IN PLIST_ENTRY WaitQueue,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags,
    IN BOOLEAN DereferenceThread
    )
{
    if ((*WaitBlock->WaitRoutine)( WaitQueue,
                                   WaitBlock->WaitingThread,
                                   &WaitBlock->WaitReplyMessage,
                                   WaitBlock->WaitParameter,
                                   SatisfyParameter1,
                                   SatisfyParameter2,
                                   WaitFlags
                                 )
       ) {

        //
        // we don't take any locks other than the waitlist lock
        // because the only thing we have to worry about is the thread
        // going away beneath us and that's prevented by having
        // DestroyThread and DestroyProcess take the waitlist lock.
        //

        WaitBlock->WaitingThread->WaitBlock = NULL;
        if (WaitBlock->WaitReplyMessage.CaptureBuffer != NULL) {
            CsrReleaseCapturedArguments(&WaitBlock->WaitReplyMessage);
        }
        NtReplyPort( WaitBlock->WaitingThread->Process->ClientPort,
                     (PPORT_MESSAGE)&WaitBlock->WaitReplyMessage
                   );

        if (DereferenceThread) {
            if ( WaitBlock->Link.Flink ) {
                RemoveEntryList( &WaitBlock->Link );
                }
            if ( WaitBlock->UserLink.Flink ) {
                RemoveEntryList( &WaitBlock->UserLink );
                }
            CsrDereferenceThread(WaitBlock->WaitingThread);
            RtlFreeHeap( CsrHeap, 0, WaitBlock );
            }
        else {

            //
            // indicate that this wait has been satisfied.  when the
            // console unwinds to the point where it can release the
            // console lock, it will dereference the thread.
            //

            WaitBlock->WaitRoutine = NULL;
            }
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}

BOOLEAN
CsrNotifyWait(
    IN PLIST_ENTRY WaitQueue,
    IN BOOLEAN SatisfyAll,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_WAIT_BLOCK WaitBlock;
    BOOLEAN Result;

    Result = FALSE;

    AcquireWaitListsLock();

    ListHead = WaitQueue;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        WaitBlock = CONTAINING_RECORD( ListNext, CSR_WAIT_BLOCK, Link );
        ListNext = ListNext->Flink;
        if (WaitBlock->WaitRoutine) {
            Result |= CsrNotifyWaitBlock( WaitBlock,
                                          WaitQueue,
                                          SatisfyParameter1,
                                          SatisfyParameter2,
                                          0,
                                          FALSE
                                        );
            if (!SatisfyAll) {
                break;
                }
            }
        }

    ReleaseWaitListsLock();
    return( Result );
}

VOID
CsrDereferenceWait(
    IN PLIST_ENTRY WaitQueue
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_WAIT_BLOCK WaitBlock;

    AcquireProcessStructureLock();
    AcquireWaitListsLock();

    ListHead = WaitQueue;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        WaitBlock = CONTAINING_RECORD( ListNext, CSR_WAIT_BLOCK, Link );
        ListNext = ListNext->Flink;
        if (!WaitBlock->WaitRoutine) {
            if ( WaitBlock->Link.Flink ) {
                RemoveEntryList( &WaitBlock->Link );
                }
            if ( WaitBlock->UserLink.Flink ) {
                RemoveEntryList( &WaitBlock->UserLink );
                }
            CsrDereferenceThread(WaitBlock->WaitingThread);
            RtlFreeHeap( CsrHeap, 0, WaitBlock );
            }
        }

    ReleaseWaitListsLock();
    ReleaseProcessStructureLock();
}

VOID
CsrMoveSatisfiedWait(
    IN PLIST_ENTRY DstWaitQueue,
    IN PLIST_ENTRY SrcWaitQueue
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_WAIT_BLOCK WaitBlock;

    AcquireWaitListsLock();

    ListHead = SrcWaitQueue;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        WaitBlock = CONTAINING_RECORD( ListNext, CSR_WAIT_BLOCK, Link );
        ListNext = ListNext->Flink;
        if (!WaitBlock->WaitRoutine) {
            RemoveEntryList( &WaitBlock->Link );
            InsertTailList( DstWaitQueue, &WaitBlock->Link );
            }
        }

    ReleaseWaitListsLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\conreqst.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    conreqst.c

Abstract:

    This module implements the POSIX console API calls

Author:

    Avi Nathan (avin) 23-Jul-1991

Revision History:

    Ellen Aycock-Wright (ellena) 15-Sept-1991 Modified for POSIX

--*/

#include "psxdll.h"


NTSTATUS
SendConsoleRequest(IN OUT PSCREQUESTMSG Request)
{
    HANDLE   SessionPort;
    NTSTATUS Status;

    PORT_MSG_TOTAL_LENGTH(*Request) = sizeof(SCREQUESTMSG);
    PORT_MSG_DATA_LENGTH(*Request) = sizeof(SCREQUESTMSG) - sizeof(PORT_MESSAGE);
    PORT_MSG_ZERO_INIT(*Request) = 0L;

    SessionPort = ((PPEB_PSX_DATA)(NtCurrentPeb()->SubSystemData))->SessionPortHandle;

    Status = NtRequestWaitReplyPort(SessionPort, (PPORT_MESSAGE)Request,
            (PPORT_MESSAGE) Request);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("PSXDLL: Unable to send CON request: %X\n", Status));
	if (0xffffffff == Status) {
		return STATUS_UNSUCCESSFUL;
	}

	//
	// Probably somebody shot posix.exe, or he died for some other
	// reason.  We'll shoot the user's process for him.
	//
	_exit(99);
    }
    ASSERT(PORT_MSG_TYPE(*Request) == LPC_REPLY);

    return Request->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\dllext.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dllext.c

Abstract:

    Client implementation of C Language Extensions (Chapter 8 of 1003.1)

Author:

    Ellen Aycock-Wright (ellena) 15-Oct-1991

Revision History:

--*/

#include <stdio.h>
#include <fcntl.h>
#include "psxdll.h"

extern FILE *_getstream(void);

int
__cdecl
fileno(FILE *stream)
{
    return(stream->_file);
}

#if 0
FILE *
fdopen(int fildes, const char *type)
{
	FILE *stream;
	int mode;
	int streamflag = 0;

	//
	// XXX.mjb:  we need fcntl to check modes and validity of fildes
	//

	if (NULL == (stream = _getstream())) {
		return NULL;
	}
	switch (*type) {
	case 'r':
		mode = O_RDONLY;
		streamflag |= _IOREAD;
		break;
	case 'w':
		mode = O_WRONLY;
		streamflag |= _IOWRT;
		break;
	case 'a':
		mode = O_WRONLY | O_APPEND;
		streamflag |= _IOWRT;
		// XXX.mjb: should be _IOWRT | _IOAPPEND;
		break;
	default:
		errno = EINVAL;
		return NULL;
	}

	switch (*++type) {
	case '\0':
		break;
	case '+':
		mode |= O_RDWR;
		mode &= ~(O_RDONLY | O_WRONLY);
		streamflag |= _IOWRT;
		streamflag &= (_IOREAD | _IOWRT);
		break;
	default:
		errno = EINVAL;
		return NULL;
	}

	stream->_flag = streamflag;
	stream->_cnt = 0;
	stream->_base = stream->_ptr = NULL;
	stream->_file = fildes;
	return stream;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\crtsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    crtsup.c

Abstract:

    This module contains support routines used by the Posix C runtimes.

Author:

    Ellen Aycock-Wright (ellena) 07-Aug-1991

Environment:

    User Mode only

Revision History:

--*/

#include "psxmsg.h"
#include "psxdll.h"


char *
__cdecl
__PdxGetCmdLine(
    VOID
    )

/*++

Routine Description:

    The command line of the current process is available using this
    API.

Arguments:

    None.

Return Value:

    The address of the current processes command line is returned.  The
    return value is a pointer to null terminate string.

--*/

{
    return PsxAnsiCommandLine.Buffer;
}

int
PdxStatusToErrno(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This procedure converts an NT status code to an
    equivalent errno value. BUG BUG it is duplicated in the
    server as PsxStatusToErrno to avoid calling the server.

    The conversion is a function of the status code class.

Arguments:

    Class - Supplies the status code class to use.

    Status - Supplies the status code to convert.

Return Value:

    Returns an equivalent error code to the supplied status code.

--*/

{
    ULONG Error;

    switch (Status) {

    case STATUS_INVALID_PARAMETER:
        Error = EINVAL;
        break;

    case STATUS_DIRECTORY_NOT_EMPTY:
        // Error = ENOTEMPTY;
	Error = EEXIST;
        break;

    case STATUS_OBJECT_PATH_INVALID:
    case STATUS_NOT_A_DIRECTORY:
        Error = ENOTDIR;
        break;

    case STATUS_OBJECT_PATH_SYNTAX_BAD:
	// this for the rename test; 'old' has component too long.
	Error = ENAMETOOLONG;
	break;

    case STATUS_OBJECT_NAME_COLLISION:
        Error = EEXIST;
        break;

    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_DELETE_PENDING:
        Error = ENOENT;
        break;

    case STATUS_NO_MEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        Error = ENOMEM;
        break;

    case STATUS_CANNOT_DELETE:
	Error = ETXTBUSY;
	break;

    case STATUS_DISK_FULL:
	Error = ENOSPC;
	break;

    case STATUS_MEDIA_WRITE_PROTECTED:
	Error = EROFS;
	break;

    case STATUS_OBJECT_NAME_INVALID:
	Error = ENAMETOOLONG;
	break;

    case STATUS_FILE_IS_A_DIRECTORY:
	Error = EISDIR;
	break;

    case STATUS_NOT_SAME_DEVICE:
	Error = EXDEV;
	break;

    default :
        Error = EACCES;
    }

    return Error;
}

//
// Copied from the server side.
//
int
PdxStatusToErrnoPath(
	PUNICODE_STRING Path
	)
{
	NTSTATUS Status;
	OBJECT_ATTRIBUTES Obj;
	HANDLE FileHandle;
	ULONG DesiredAccess;
	IO_STATUS_BLOCK Iosb;
	ULONG Options;
	PWCHAR pwc, pwcSav;
	ULONG MinLen;

	PSX_GET_SIZEOF(DOSDEVICE_X_W,MinLen);

	DesiredAccess = SYNCHRONIZE;
	Options = FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE;

	pwcSav = NULL;

	for (;;) {
		//
		// Remove trailing component.
		//

		pwc = wcsrchr(Path->Buffer, L'\\');

		if (pwcSav)
			*pwcSav = L'\\';

		if (NULL == pwc) {
			break;
		}
		*pwc = UNICODE_NULL;
		pwcSav = pwc;

		Path->Length = wcslen(Path->Buffer) * sizeof(WCHAR);

		if (Path->Length <= MinLen) {
			*pwcSav = L'\\';
			break;
		}
      
		InitializeObjectAttributes(&Obj, Path, 0, NULL, NULL);

		Status = NtOpenFile(&FileHandle, DesiredAccess, &Obj,
			&Iosb,
			FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
			Options);
		if (NT_SUCCESS(Status)) {
			NtClose(FileHandle);\
		}
		if (STATUS_NOT_A_DIRECTORY == Status) {
			*pwcSav = L'\\';
			Path->Length = wcslen(Path->Buffer) * sizeof(WCHAR);
			return ENOTDIR;
		}
	}
	Path->Length = wcslen(Path->Buffer) * sizeof(WCHAR);
	return ENOENT;
}

int __cdecl
raise(int sig)
{
	return kill(getpid(), sig);
}

/*
 * This routine is called by heapinit(), in crt32psx/winheap.  We
 * would have a reference forwarder in psxdll.def, except RtlProcessHeap
 * is a macro and can't be forwarded.
 */
void *
GetProcessHeap(void)
{
	return (void *)RtlProcessHeap();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\dllfile.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dllfile.c

Abstract:

    Client implementation of File and Directory functions for POSIX.

Author:

    Mark Lucovsky (markl) 15-Dec-1989

Revision History:

--*/

#include <unistd.h>
#include <sys/stat.h>
#include "psxdll.h"

int __cdecl
closedir(DIR *dirp)
{
	int r = 0;

	try {
		if (-1 == close(dirp->Directory)) {
			return -1;
		}
		dirp->Directory = -1;
		dirp->Index = (unsigned long)-1;

		RtlFreeHeap(PdxHeap, 0, (PVOID)dirp);

	} except (EXCEPTION_EXECUTE_HANDLER) {
		r = -1;
	}

	return r;
}

DIR * __cdecl
opendir(const char *dirname)
{
	DIR *ReturnedDir;
	int fd, i;

	ReturnedDir = RtlAllocateHeap(PdxHeap, 0, sizeof(DIR));
	if (NULL == ReturnedDir) {
		errno = ENOMEM;
		return NULL;
	}

	fd = open(dirname, O_RDONLY);
	if (-1 == fd) {
		RtlFreeHeap(PdxHeap, 0, (PVOID)ReturnedDir);
		return NULL;
	}

	i = fcntl(fd, F_SETFD, FD_CLOEXEC);
	if (0 != i) {
	    close(fd);
	    RtlFreeHeap(PdxHeap, 0, (PVOID)ReturnedDir);
        return NULL;
	}

	ReturnedDir->Directory = fd;
	ReturnedDir->Dirent.d_name[0] = '\0';
	ReturnedDir->Index = 0;
	ReturnedDir->RestartScan = FALSE;

	return ReturnedDir;
}

struct dirent * __cdecl
readdir(DIR *dirp)
{
	PSX_API_MSG m;
	PPSX_READDIR_MSG args;
	NTSTATUS Status;
	char *buf;

	args = &m.u.ReadDir;

	buf = &dirp->Dirent.d_name[0];

again:
	for (;;) {
		PSX_FORMAT_API_MSG(m, PsxReadDirApi, sizeof(*args));
		args->FileDes = dirp->Directory;
		args->Buf = buf;
		args->Nbytes = PATH_MAX;
		args->RestartScan = dirp->RestartScan;
		dirp->RestartScan = 0;

		Status = NtRequestWaitReplyPort(PsxPortHandle,
			(PPORT_MESSAGE)&m, (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
		ASSERT(NT_SUCCESS(Status));
#endif

		if (EINTR == m.Error && SIGCONT == m.Signal) {
			//
			// The system call was stopped and continued.  Call
			// again instead of returning EINTR.
			//
			continue;
		}
		if (m.Error) {
			errno = m.Error;
			return NULL;
		}
		break;
	}

	if (0 == m.ReturnValue) {
		return NULL;
	}

	//
	// Skip dot and dot-dot.
	//

	if (m.ReturnValue <= 2 && buf[0] == '.') {
		if (m.ReturnValue == 1 || buf[1] == '.') {
			goto again;
		}
	}

	try {
		++dirp->Index;

		dirp->Dirent.d_name[m.ReturnValue] = '\0';
		return &dirp->Dirent;

	} except (EXCEPTION_EXECUTE_HANDLER) {
		errno = EFAULT;
	}
	// we've taken an exception.
	return NULL;
}

void
__cdecl
rewinddir(DIR *dirp)
{
	dirp->RestartScan = TRUE;
	dirp->Index = 0;
}

int __cdecl
chdir(const char *path)
{
	NTSTATUS Status;
	HANDLE Directory;
	IO_STATUS_BLOCK Iosb;
	OBJECT_ATTRIBUTES ObjA;
	UNICODE_STRING Path_U;
	ANSI_STRING Path_A;
	PANSI_STRING pCWD;
	auto sigset_t set, oset;
	int ret_val = 0;

	if (!PdxCanonicalize((PSZ)path, &Path_U, PdxHeap)) {
		return -1;
	}
	InitializeObjectAttributes(&ObjA, &Path_U, OBJ_INHERIT, NULL, NULL);

	//
	// Make sure that the path is to a directory
	//

	Status = NtOpenFile(&Directory, SYNCHRONIZE, &ObjA, &Iosb,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            	FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE);
	if (!NT_SUCCESS(Status)) {
		if (STATUS_OBJECT_PATH_NOT_FOUND == Status) {
			errno = PdxStatusToErrnoPath(&Path_U);
		} else {
			errno = PdxStatusToErrno(Status);
		}
		RtlFreeHeap(PdxHeap, 0, (PVOID)Path_U.Buffer);
		return -1;
	}

	Status = NtClose(Directory);
	if (!NT_SUCCESS(Status)) {
	    KdPrint(("PSXDLL: NtClose: 0x%x\n", Status));
	}

	RtlUnicodeStringToAnsiString(&Path_A, &Path_U, TRUE);
	RtlFreeHeap(PdxHeap, 0, (PVOID)Path_U.Buffer);

	pCWD = &PdxDirectoryPrefix.NtCurrentWorkingDirectory;

	//
	// The path was opened ok. Make sure that there is space for the
	// pathname in the PdxDirectoryPrefix buffer.
	//

	if (Path_A.Length > pCWD->MaximumLength + 2) {
		RtlFreeAnsiString(&Path_A);
		errno = ENOENT;
		return -1;
	}

	//
	// Keep the process from trying to use his CWD while we're modifying
	// it.
	//

	sigfillset(&set);
	sigprocmask(SIG_BLOCK, &set, &oset);

	//
	// Update NtCurrentWorkingDirectory
	//

	RtlMoveMemory(pCWD->Buffer, Path_A.Buffer, Path_A.Length);
	if ('\\' != pCWD->Buffer[Path_A.Length - 1]) {
		pCWD->Buffer[Path_A.Length] = '\\';
		pCWD->Buffer[Path_A.Length + 1] = '\0';
		pCWD->Length = Path_A.Length + 1;
	} else {
		pCWD->Buffer[Path_A.Length + 1] = '\0';
		pCWD->Length = Path_A.Length;
	}

	//
	// Set length of translated current working directory to zero.
	// getcwd() uses this as its hint to translate NtCurrentWorkingDirectory
	// to PsxCurrentWorkingDirectory.
	//

	PdxDirectoryPrefix.PsxCurrentWorkingDirectory.Length = 0;

	//
	// Update the PsxRoot.
	//

	RtlMoveMemory(PdxDirectoryPrefix.PsxRoot.Buffer, Path_A.Buffer,
		PdxDirectoryPrefix.PsxRoot.Length);

	RtlFreeAnsiString(&Path_A);
	sigprocmask(SIG_SETMASK, &oset, NULL);

	return 0;
}

char *
__cdecl
getcwd(char *buf, size_t size)
{
	USHORT i, j, CwdSize;
	PANSI_STRING pPsxCwd, pNtCwd, pPsxRoot;

	if (size <= 0) {
		errno = EINVAL;
		return NULL;
	}

	//
	// Note that NtCwd should always have a trailing backslash.
	//

	pNtCwd = &PdxDirectoryPrefix.NtCurrentWorkingDirectory;
	pPsxCwd = &PdxDirectoryPrefix.PsxCurrentWorkingDirectory;
	pPsxRoot = &PdxDirectoryPrefix.PsxRoot;

	CwdSize = pNtCwd->Length - pPsxRoot->Length;
	if (1 == CwdSize) {
		//
		// If the CWD is "/", then we'll have a trailing slash and
		// we'll need space for it.
		//
		++CwdSize;
	}
	if (size < CwdSize) {
		errno = ERANGE;
		return NULL;
	}

	if (0 == pPsxCwd->Length) {
		for (i = 0, j = pPsxRoot->Length; i < CwdSize - 1; i++, j++) {
			pPsxCwd->Buffer[i] = (pNtCwd->Buffer[j] == '\\') ?
				'/' : pNtCwd->Buffer[j];
		}
		pPsxCwd->Buffer[CwdSize] = '\0';
		pPsxCwd->Length = CwdSize - 1;

	}

	try {
		RtlMoveMemory(buf, pPsxCwd->Buffer, pPsxCwd->Length);
		buf[pPsxCwd->Length] = '\0';
	} except (EXCEPTION_EXECUTE_HANDLER) {
		errno = EFAULT;
		buf = NULL;
	}

	return buf;
}

mode_t
__cdecl
umask(mode_t cmask)
{
    PSX_API_MSG m;
    NTSTATUS Status;
    PPSX_UMASK_MSG args;

    args = &m.u.Umask;
    PSX_FORMAT_API_MSG(m, PsxUmaskApi, sizeof(*args));

    args->Cmask = cmask;

    Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
            			    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(Status));
#endif

    if (m.Error) {
        errno = (int)m.Error;
        return (mode_t)-1;
    }
    return (mode_t)m.ReturnValue;
}

int
__cdecl
mkdir(const char *path, mode_t mode)
{
    PSX_API_MSG m;
    NTSTATUS Status;
    PPSX_MKDIR_MSG args;
    UNICODE_STRING Path_U;

    args = &m.u.MkDir;
    PSX_FORMAT_API_MSG(m, PsxMkDirApi, sizeof(*args));

    if (!PdxCanonicalize((PSZ)path, &Path_U, PdxPortHeap)) {
        return -1;
    }

    args->Path_U = Path_U;
    args->Path_U.Buffer = (PVOID)((PCHAR)Path_U.Buffer +
		PsxPortMemoryRemoteDelta);
    args->Mode = mode;

    Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
            			    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(Status));
#endif

    RtlFreeHeap(PdxPortHeap, 0, (PVOID)Path_U.Buffer);

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }
    return (int)m.ReturnValue;
}


int
__cdecl
mkfifo(const char *path, mode_t mode)
{
	PSX_API_MSG m;
	NTSTATUS Status;
	PPSX_MKFIFO_MSG args;
	PVOID p;

	args = &m.u.MkFifo;

	PSX_FORMAT_API_MSG(m,PsxMkFifoApi,sizeof(*args));

	if (!PdxCanonicalize((PSZ)path, &args->Path_U, PdxPortHeap)) {
		return -1;
	}

	p = args->Path_U.Buffer;
	args->Path_U.Buffer = (PWSTR)((PCHAR)p + PsxPortMemoryRemoteDelta);
	args->Mode = mode;
	
	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
            			    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
	ASSERT(NT_SUCCESS(Status));
#endif

	RtlFreeHeap(PdxPortHeap, 0, p);
	
	if (m.Error) {
		errno = (int)m.Error;
		return -1;
	}
	return m.ReturnValue;
}

int
__cdecl
rmdir(const char *path)
{
	PSX_API_MSG m;
	NTSTATUS Status;
	PPSX_RMDIR_MSG args;
	PVOID p;
	
	args = &m.u.RmDir;
	
	PSX_FORMAT_API_MSG(m,PsxRmDirApi,sizeof(*args));

	if (!PdxCanonicalize((PSZ)path, &args->Path_U, PdxPortHeap)) {
		return -1;
	}

	p = args->Path_U.Buffer;
	args->Path_U.Buffer = (PWSTR)((PCHAR)p + PsxPortMemoryRemoteDelta);

	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
		(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
	ASSERT(NT_SUCCESS(Status));
#endif

	RtlFreeHeap(PdxPortHeap, 0, p);
	
	if (m.Error) {
		errno = (int)m.Error;
		return -1;
	}
	return (int)m.ReturnValue;
}

int
__cdecl
stat(const char *path, struct stat *buf)
{
	PSX_API_MSG m;
	NTSTATUS Status;
	PPSX_STAT_MSG args;
	struct stat *tmpbuf;
	void *p;
	int r;

	args = &m.u.Stat;
	PSX_FORMAT_API_MSG(m, PsxStatApi, sizeof(*args));

	if (!PdxCanonicalize((PSZ)path, &args->Path_U, PdxPortHeap)) {
		return -1;
	}

	p = args->Path_U.Buffer;
	args->Path_U.Buffer = (PWSTR)((PCHAR)p + PsxPortMemoryRemoteDelta);

	tmpbuf = RtlAllocateHeap(PdxPortHeap, 0, sizeof(struct stat));
	ASSERT(NULL != tmpbuf);

	args->StatBuf = (struct stat *)((PCHAR)tmpbuf + PsxPortMemoryRemoteDelta);
	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
        	(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
	ASSERT(NT_SUCCESS(Status));
#endif

	RtlFreeHeap(PdxPortHeap, 0, p);

	if (m.Error) {
		RtlFreeHeap(PdxPortHeap, 0, (PVOID)tmpbuf);
		errno = (int)m.Error;
		return -1;
	}

	r = 0;

	try {
		(void)memcpy(buf, tmpbuf, sizeof(struct stat));
	} except (EXCEPTION_EXECUTE_HANDLER) {
		r = -1;
		errno = EFAULT;
	}

	RtlFreeHeap(PdxPortHeap, 0, (PVOID)tmpbuf);
	return r;
}

int
__cdecl
fstat(int fildes, struct stat *buf)
{
	PSX_API_MSG m;
	NTSTATUS Status;
	PPSX_FSTAT_MSG args;
	struct stat *tmpbuf;
	int r;

	args = &m.u.FStat;
	PSX_FORMAT_API_MSG(m, PsxFStatApi, sizeof(*args));

	args->FileDes = fildes;

	tmpbuf = RtlAllocateHeap(PdxPortHeap, 0, sizeof(struct stat));
        if (! tmpbuf) {
            errno = ENOMEM;
            return -1;
        }

	args->StatBuf = (struct stat *)((PCHAR)tmpbuf + PsxPortMemoryRemoteDelta);
	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
        	(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
	ASSERT(NT_SUCCESS(Status));
#endif

	if (m.Error) {
		RtlFreeHeap(PdxPortHeap, 0, (PVOID)tmpbuf);
		errno = (int)m.Error;
		return -1;
	}

	r = 0;

	try {
		(void)memcpy(buf, tmpbuf, sizeof(struct stat));
	} except (EXCEPTION_EXECUTE_HANDLER) {
		r = -1;
		errno = EFAULT;
	}
	RtlFreeHeap(PdxPortHeap, 0, (PVOID)tmpbuf);
	return r;
}

int
__cdecl
access(const char *path, int amode)
{
    PSX_API_MSG m;
    NTSTATUS Status;

    PPSX_ACCESS_MSG args;

    if (0 != (amode & ~(W_OK | R_OK | X_OK))) {
	errno = EINVAL;
	return -1;
    }

    args = &m.u.Access;

    PSX_FORMAT_API_MSG(m,PsxAccessApi,sizeof(*args));

    if (!PdxCanonicalize((PSZ)path, &args->Path_U, PdxPortHeap)) {
        return -1;
    }

    m.DataBlock = args->Path_U.Buffer;
    args->Path_U.Buffer = (PWSTR)((PCHAR)m.DataBlock + PsxPortMemoryRemoteDelta);
    args->Amode = amode;

    Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
    		(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(Status));
#endif

    RtlFreeHeap(PdxPortHeap, 0, (PVOID)m.DataBlock);

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }
    return m.ReturnValue;
}

int
__cdecl
chmod(const char *path, mode_t mode)
{
    PSX_API_MSG m;
    NTSTATUS Status;
    PPSX_CHMOD_MSG args;

    args = &m.u.Chmod;

    PSX_FORMAT_API_MSG(m,PsxChmodApi,sizeof(*args));

    if (!PdxCanonicalize((PSZ)path, &args->Path_U, PdxPortHeap)) {
        return -1;
    }

    m.DataBlock = args->Path_U.Buffer;
    args->Path_U.Buffer = (PWSTR)((PCHAR)m.DataBlock + PsxPortMemoryRemoteDelta);
    args->Mode = mode;

    Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
		(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(Status));
#endif

    RtlFreeHeap(PdxPortHeap, 0, (PVOID)m.DataBlock);

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }
    return m.ReturnValue;
}

int
__cdecl
chown(const char *path, uid_t owner, gid_t group)
{
    PSX_API_MSG m;
    NTSTATUS Status;
    PPSX_CHOWN_MSG args;

    args = &m.u.Chown;

    PSX_FORMAT_API_MSG(m, PsxChownApi, sizeof(*args));

    if (!PdxCanonicalize((PSZ)path, &args->Path_U, PdxPortHeap)) {
        return -1;
    }

    m.DataBlock = args->Path_U.Buffer;
    args->Path_U.Buffer = (PWSTR)((PCHAR)m.DataBlock + PsxPortMemoryRemoteDelta);
    args->Owner = owner;
    args->Group = group;

    Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
		(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(Status));
#endif

    RtlFreeHeap(PdxPortHeap, 0, (PVOID)m.DataBlock);

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }
    return m.ReturnValue;
}

int
__cdecl
utime(const char *path, const struct utimbuf *times)
{
	PSX_API_MSG m;
	NTSTATUS Status;

	PPSX_UTIME_MSG args;

	args = &m.u.Utime;

	PSX_FORMAT_API_MSG(m, PsxUtimeApi, sizeof(*args));

	if (!PdxCanonicalize((PSZ)path, &args->Path_U, PdxPortHeap)) {
        	return -1;
	}

	m.DataBlock = args->Path_U.Buffer;
	args->Path_U.Buffer = (PWSTR)((PCHAR)m.DataBlock +
		PsxPortMemoryRemoteDelta);
	args->TimesSpecified = (struct utimbuf *)times;

	if (NULL != times) {
		args->Times = *times;
	}

	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
            	(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
	ASSERT(NT_SUCCESS(Status));
#endif

	RtlFreeHeap(PdxPortHeap, 0, (PVOID)m.DataBlock);

	if (m.Error) {
        	errno = (int)m.Error;
        	return -1;
    	}
    	return m.ReturnValue;
}

long
__cdecl
pathconf(const char *path, int name)
{
	PSX_API_MSG m;
	NTSTATUS Status;
	PPSX_PATHCONF_MSG args;

	args = &m.u.PathConf;
	PSX_FORMAT_API_MSG(m, PsxPathConfApi, sizeof(*args));

    if (!PdxCanonicalize((PSZ)path, &args->Path, PdxPortHeap)) {
        return -1;
    }

    m.DataBlock = args->Path.Buffer;
    args->Path.Buffer = (PWSTR)((PCHAR)m.DataBlock + PsxPortMemoryRemoteDelta);
    args->Name = name;

    Status = NtRequestWaitReplyPort(PsxPortHandle,
		(PPORT_MESSAGE)&m, (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(Status));
#endif

    RtlFreeHeap(PdxPortHeap, 0, (PVOID)m.DataBlock);

	if (m.Error) {
		errno = (int)m.Error;
		return -1;
	}
	return((long)(m.ReturnValue));
}

long
__cdecl
fpathconf(int fildes, int name)
{
	PSX_API_MSG        m;
	NTSTATUS           Status;
	PPSX_FPATHCONF_MSG args;

	args = &m.u.FPathConf;
	PSX_FORMAT_API_MSG(m, PsxFPathConfApi, sizeof(*args));

	args->FileDes = fildes;
	args->Name = name;

	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
      		(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
	ASSERT(NT_SUCCESS(Status));
#endif

	if (m.Error) {
		errno = (int)m.Error;
		return -1;
	}
	return m.ReturnValue;
}

int __cdecl
rename(const char *old, const char *new)
{
	NTSTATUS Status;
	UNICODE_STRING old_U, new_U;
	PSX_API_MSG m;
	PPSX_RENAME_MSG args;
	sigset_t set, oset;
	int r;				// ret val
	static char path[PATH_MAX];
	char *pch, c;
	WCHAR *pwc;
	int i;
	struct stat st_buf1, st_buf2;
	static int been_here = 0;	// prevent infinite recursion

	args = &m.u.Rename;
	PSX_FORMAT_API_MSG(m, PsxRenameApi, sizeof(*args));

	if (!PdxCanonicalize((PSZ)old, &old_U, PdxPortHeap)) {
		return -1;
	}

	if (!PdxCanonicalize((PSZ)new, &new_U, PdxPortHeap)) {
		RtlFreeHeap(PdxPortHeap, 0, (PVOID)old_U.Buffer);
		return -1;
	}

	//
	// 1003.1-90 (5.5.3.4):  EISDIR ... The /new/ argument points
	// to a directory, and the /old/ argument points to a file that
	// is not a directory.
	//
	//			ENOTDIR ... the /old/ argument names a
	// directory and the /new/ argument names a nondirectory file.
	//

	i = errno;
	if (0 == stat(old, &st_buf1) && 0 == stat(new, &st_buf2)) {
		if (S_ISDIR(st_buf2.st_mode) && S_ISREG(st_buf1.st_mode)) {
			RtlFreeHeap(PdxPortHeap, 0, (PVOID)old_U.Buffer);
			RtlFreeHeap(PdxPortHeap, 0, (PVOID)new_U.Buffer);
			errno = EISDIR;
			return -1;
		}
		if (S_ISREG(st_buf2.st_mode) && S_ISDIR(st_buf1.st_mode)) {
			RtlFreeHeap(PdxPortHeap, 0, (PVOID)old_U.Buffer);
			RtlFreeHeap(PdxPortHeap, 0, (PVOID)new_U.Buffer);
			errno = ENOTDIR;
			return -1;
		}
	}
	errno = i;

	//
	// 1003.1-90 (5.5.3.4):  EINVAL ... The /new/ directory
	// pathname contains a path prefix that names the /old/ directory.
	//

	pwc = wcsrchr(new_U.Buffer, L'\\');
	ASSERT(NULL != pwc);
	*pwc = 0;

	if (0 == wcsncmp(new_U.Buffer, old_U.Buffer, old_U.Length)) {
		RtlFreeHeap(PdxPortHeap, 0, (PVOID)old_U.Buffer);
		RtlFreeHeap(PdxPortHeap, 0, (PVOID)new_U.Buffer);
		errno = EINVAL;
		return -1;
	}
	*pwc = L'\\';			// put it back

	args->OldName = old_U;
	args->NewName = new_U;

	args->OldName.Buffer =
		 (PVOID)((PCHAR)old_U.Buffer + PsxPortMemoryRemoteDelta);
	args->NewName.Buffer =
		 (PVOID)((PCHAR)new_U.Buffer + PsxPortMemoryRemoteDelta);

	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
		(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
	ASSERT(NT_SUCCESS(Status));
#endif

	RtlFreeHeap(PdxPortHeap, 0, (PVOID)new_U.Buffer);
	RtlFreeHeap(PdxPortHeap, 0, (PVOID)old_U.Buffer);

	if (0 == m.Error) {
		return m.ReturnValue;
	}
	if (EACCES != m.Error) {
		errno = m.Error;	
		return -1;
	}

	//
	// The rename operation failed because the target already
	// exists.  This happens when trying to rename a directory
	// over an existing directory, which POSIX requires but
	// NT filesystems don't support.  We emulate here.
	//

	if (been_here) {
		errno = EACCES;
		return -1;
	}
	been_here++;

	// block all signals during the operation.

	sigfillset(&set);
	sigprocmask(SIG_SETMASK, &set, &oset);

	r = 0;

	//
	// Figure out a temporary pathname to use.  The temporary
	// dir is created in the same directory as 'new'.
	//

	strcpy(path, new);

	// take care of paths that end in slash...

	for (;;) {
		i = strlen(path) - 1;
		if ('/' == path[i]) {
			path[i] = '\0';
		} else {
			break;
		}
	}

	pch = strrchr(path, '/');
	if (NULL != pch) {
		++pch;
		strcpy(pch, "_psxtmp.d");
	} else {
		// 'new' is in the cwd

		strcpy(path, "_psxtmp.d");
		pch = path;
	}

	for (c = 'a'; ; c++) {
		if (c > 'z') {
			errno = EEXIST;
			return -1;
		}
		*pch = c;

		if (-1 == (r = rename(new, path))) {
			if (EEXIST == errno) {
				// try the next letter for tmp path
				continue;
			}
			errno = EACCES; 		// reset errno
			break;
		}
		if (-1 == (r = rename(old, new))) {
			(void)rename(path, new);
			break;
		}
		if (-1 == rmdir(path)) {
			if (-1 == (r = rename(new, old))) {
				//
				// If we don't bail here, the following call
				// to rename will recurse infinitely.
				//
				break;
			}
			(void)rename(path, new);
			r = -1;
			break;
		}
		break;
	}
	been_here = 0;
	sigprocmask(SIG_SETMASK, &oset, NULL);
	return r;
}

int
__cdecl
unlink(const char *path)
{
	PSX_API_MSG m;
	NTSTATUS Status;
	PPSX_UNLINK_MSG args;

	args = &m.u.Unlink;
	PSX_FORMAT_API_MSG(m, PsxUnlinkApi, sizeof(*args));

	if (!PdxCanonicalize((PSZ)path, &args->Path_U, PdxPortHeap)) {
		return -1;
	}

	m.DataBlock = args->Path_U.Buffer;
	args->Path_U.Buffer = (PWSTR)((PCHAR)m.DataBlock +
		PsxPortMemoryRemoteDelta);

	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
        	(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
	ASSERT(NT_SUCCESS(Status));
#endif

	RtlFreeHeap(PdxPortHeap, 0, (PVOID)m.DataBlock);

	if (m.Error) {
		errno = (int)m.Error;
		return -1;
	}
	return 0;
}

int
__cdecl
link(const char *existing, const char *new)
{
	PPSX_LINK_MSG args;
	PSX_API_MSG m;
	UNICODE_STRING old_U, new_U;
	NTSTATUS Status;

	args = &m.u.Link;
	PSX_FORMAT_API_MSG(m, PsxLinkApi, sizeof(*args));

	if (!PdxCanonicalize((PSZ)existing, &old_U, PdxPortHeap)) {
		return -1;
	}

	if (!PdxCanonicalize((PSZ)new, &new_U, PdxPortHeap)) {
		RtlFreeHeap(PdxPortHeap, 0, (PVOID)old_U.Buffer);
		return -1;
	}

	args->OldName = old_U;
	args->NewName = new_U;

	args->OldName.Buffer =
		 (PVOID)((PCHAR)old_U.Buffer + PsxPortMemoryRemoteDelta);
	args->NewName.Buffer =
		 (PVOID)((PCHAR)new_U.Buffer + PsxPortMemoryRemoteDelta);

	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
		(PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
	ASSERT(NT_SUCCESS(Status));
#endif

	RtlFreeHeap(PdxPortHeap, 0, (PVOID)new_U.Buffer);
	RtlFreeHeap(PdxPortHeap, 0, (PVOID)old_U.Buffer);

	if (0 != m.Error) {
		errno = m.Error;
		return -1;
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\coninit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    coninit.c

Abstract:

    This module initialize the connection with the session console port

Author:

    Avi Nathan (avin) 23-Jul-1991

Revision History:

    Ellen Aycock-Wright (ellena) 15-Sept-1991 Modified for POSIX

--*/

#include <stdio.h>
#include "psxdll.h"

NTSTATUS
PsxInitializeSessionPort(
	IN ULONG UniqueId
	)
{
    PSXSESCONNECTINFO ConnectionInfoIn;
    ULONG ConnectionInfoInLength;

    CHAR            SessionName[PSX_SES_BASE_PORT_NAME_LENGTH];
    STRING          SessionPortName;
    UNICODE_STRING  SessionPortName_U;
    STRING          SessionDataName;
    UNICODE_STRING  SessionDataName_U;

    NTSTATUS        Status;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    HANDLE          SessionPortHandle;
    HANDLE          SectionHandle;
    SIZE_T          ViewSize = 0L;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PVOID           PsxSessionDataBaseAddress;

    ConnectionInfoInLength = sizeof(ConnectionInfoIn);

    CONSTRUCT_PSX_SES_NAME(SessionName, PSX_SES_BASE_PORT_PREFIX, UniqueId);

    RtlInitAnsiString(&SessionPortName, SessionName);
    RtlAnsiStringToUnicodeString(&SessionPortName_U, &SessionPortName, TRUE);

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    //
    // get the session communication port handle. this handle will be used
    // to send console requests to psxses.exe for this session.
    //

    Status = NtConnectPort(&SessionPortHandle, &SessionPortName_U, &DynamicQos,
                           NULL, NULL, NULL, NULL, NULL);
    RtlFreeUnicodeString(&SessionPortName_U);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("PSXDLL: Unable to connect to %s - Status == %X\n",
            SessionPortName.Buffer, Status));
        return Status;
    }


    //
    // open the session data section and map it to this process
    //

    CONSTRUCT_PSX_SES_NAME(SessionName, PSX_SES_BASE_DATA_PREFIX, UniqueId);

    RtlInitAnsiString(&SessionDataName, SessionName);

    Status = RtlAnsiStringToUnicodeString(&SessionDataName_U, &SessionDataName,
                                          TRUE);
    ASSERT(NT_SUCCESS(Status));

    InitializeObjectAttributes(&ObjectAttributes, &SessionDataName_U, 0, NULL,
                               NULL);

    Status = NtOpenSection(&SectionHandle, SECTION_MAP_WRITE,
						   &ObjectAttributes);

    RtlFreeUnicodeString(&SessionDataName_U);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Let MM locate the view
    //

    PsxSessionDataBaseAddress = 0;

    Status = NtMapViewOfSection(SectionHandle, NtCurrentProcess(),
                                &PsxSessionDataBaseAddress, 0L, 0L, NULL,
                                &ViewSize, ViewUnmap, 0L, PAGE_READWRITE);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // record the session port in the PEB.
    //
    {
        PPEB_PSX_DATA   Peb;

        Peb = (PPEB_PSX_DATA)(NtCurrentPeb()->SubSystemData);
        Peb->SessionPortHandle = SessionPortHandle;
        Peb->SessionDataBaseAddress = PsxSessionDataBaseAddress;
    }

    // BUGBUG! find cleanup code and close the port, or let exit cleanup

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\dllinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contains the initialization code for the POSIX Subsystem
    Client DLL.

Author:

    Mark Lucovsky (markl) 27-Jun-1989

Environment:

    User Mode only

Revision History:

    Ellen Aycock-Wright (ellena) 03-Jan-1991
    Converted to DLL initialization routine.

--*/

#include <nt.h>
#include <ntrtl.h>
#include "psxdll.h"

extern void ClientOpen(int);

ULONG_PTR PsxPortMemoryRemoteDelta;
PVOID PsxPortMemoryBase;

BOOLEAN
PsxDllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function is the DLL initialization routine for the POSIX Emulation
    Subsystem Client DLL.  This function gets control when the applications
    links to this DLL are snapped.

Arguments:

    Context - Supplies an optional context buffer that will be restored
              after all DLL initialization has been completed.  If this
              parameter is NULL then this is a dynamic snap of this module.
              Otherwise this is a static snap prior to the user process
              gaining control.

Return Value:

    False if initialization failed.

--*/
{
   PPEB Peb;
    PPEB_PSX_DATA PebPsxData;
    NTSTATUS Status;

    if (Reason != DLL_PROCESS_ATTACH) {
        return TRUE;
    }

    //
    // Remember our DLL handle in a global variable.
    //

    PsxDllHandle = DllHandle;

    PdxHeap = RtlCreateHeap( HEAP_GROWABLE | HEAP_NO_SERIALIZE,
                             NULL,
                             64 * 1024, // Initial size of heap is 64K
                             4 * 1024,
                             0,
                             NULL
                           );

    if (PdxHeap == NULL) {
        return FALSE;
    }

    Status = PsxInitDirectories();
    if ( !NT_SUCCESS( Status )) {
        return FALSE;
    }

    Status = PsxConnectToServer();
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Peb = NtCurrentPeb();

    //
    // This is not really an ANSI_STRING but an undocumented data
    // structure.  Read crt32psx\startup\crt0.c for the code that
    // interprets this.
    //


    PsxAnsiCommandLine = *(PANSI_STRING)&(Peb->ProcessParameters->CommandLine);
    if (ARGUMENT_PRESENT(Context)) {
        PebPsxData = (PPEB_PSX_DATA)Peb->SubSystemData;
        PebPsxData->ClientStartAddress = (PVOID)CONTEXT_TO_PROGRAM_COUNTER(Context);
        PROGRAM_COUNTER_TO_CONTEXT(Context, (ULONG_PTR) PdxProcessStartup);
    }

    return TRUE;
}

NTSTATUS
PsxInitDirectories()
{

    PdxDirectoryPrefix.NtCurrentWorkingDirectory.Buffer =
                    RtlAllocateHeap(PdxHeap, 0,2*PATH_MAX);
    PdxDirectoryPrefix.NtCurrentWorkingDirectory.Length = 0;
    PdxDirectoryPrefix.NtCurrentWorkingDirectory.MaximumLength = 2*PATH_MAX;

    PdxDirectoryPrefix.PsxCurrentWorkingDirectory.Buffer =
                    RtlAllocateHeap(PdxHeap, 0,PATH_MAX+1);
    PdxDirectoryPrefix.PsxCurrentWorkingDirectory.Length = 0;
    PdxDirectoryPrefix.PsxCurrentWorkingDirectory.MaximumLength = PATH_MAX+1;

    PdxDirectoryPrefix.PsxRoot.Buffer = RtlAllocateHeap(PdxHeap, 0,2*PATH_MAX);
    PdxDirectoryPrefix.PsxRoot.Length = 0;
    PdxDirectoryPrefix.PsxRoot.MaximumLength = 2*PATH_MAX;

    //
    // Check that memory allocations worked. If not, then bail out
    //

    ASSERT(PdxDirectoryPrefix.NtCurrentWorkingDirectory.Buffer);
    ASSERT(PdxDirectoryPrefix.PsxCurrentWorkingDirectory.Buffer);
    ASSERT(PdxDirectoryPrefix.PsxRoot.Buffer);

    if ( (PdxDirectoryPrefix.NtCurrentWorkingDirectory.Buffer  == NULL) ||
         (PdxDirectoryPrefix.PsxCurrentWorkingDirectory.Buffer == NULL) ||
         (PdxDirectoryPrefix.PsxRoot.Buffer == NULL) ) {

        return ( STATUS_NO_MEMORY );
    }
    return ( STATUS_SUCCESS );
}

NTSTATUS
PsxConnectToServer(VOID)
{
    UNICODE_STRING PsxPortName;
    PSX_API_CONNECTINFO ConnectionInformation;
    ULONG ConnectionInformationLength;
    PULONG AmIBeingDebugged;
    REMOTE_PORT_VIEW ServerView;
    HANDLE PortSection;
    PPEB Peb;
    PPEB_PSX_DATA PebPsxData;
    PORT_VIEW ClientView;
    LARGE_INTEGER SectionSize;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    NTSTATUS Status;

    ConnectionInformationLength = sizeof(ConnectionInformation);

    //
    // Create a section to contain the Port Memory.  Port Memory is private
    // memory that is shared between the POSIX client and server processes.
    // This allows data that is too large to fit into an API request message
    // to be passed to the POSIX server.
    //

    SectionSize.LowPart = PSX_CLIENT_PORT_MEMORY_SIZE;
    SectionSize.HighPart = 0;

    // SEC_RESERVE

    Status = NtCreateSection(&PortSection, SECTION_ALL_ACCESS, NULL,
                         &SectionSize, PAGE_READWRITE, SEC_COMMIT, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("PSXDLL: NtCreateSection: 0x%x\n", Status));
        return Status;
    }

    //
    // Get the Peb address.  Allocate the POSIX subsystem specific portion
    // within the Peb.  This structure will be filled in by the server
    // process as part of the connect logic.
    //

    Peb = NtCurrentPeb();
    Peb->SubSystemData = RtlAllocateHeap(Peb->ProcessHeap, 0,
        sizeof(PEB_PSX_DATA));
    if (! Peb->SubSystemData) {
        NtClose(PortSection);
        return STATUS_NO_MEMORY;
    }

    PebPsxData = (PPEB_PSX_DATA)Peb->SubSystemData;
    PebPsxData->Length = sizeof(PEB_PSX_DATA);

    //
    // Connect to the POSIX Emulation Subsystem server.  This includes a
    // description of the Port Memory section so that the LPC connection
    // logic can make the section visible to both the client and server
    // processes.  Also pass information the POSIX server needs in the
    // connection information structure.
    //

    ClientView.Length = sizeof(ClientView);
    ClientView.SectionHandle = PortSection;
    ClientView.SectionOffset = 0;
    ClientView.ViewSize = SectionSize.LowPart;
    ClientView.ViewBase = 0;
    ClientView.ViewRemoteBase = 0;

    ServerView.Length = sizeof(ServerView);
    ServerView.ViewSize = 0;
    ServerView.ViewBase = 0;

    ConnectionInformation.SignalDeliverer = _PdxSignalDeliverer;
    ConnectionInformation.NullApiCaller = _PdxNullApiCaller;
    ConnectionInformation.DirectoryPrefix = &PdxDirectoryPrefix;
    ConnectionInformation.InitialPebPsxData.Length = PebPsxData->Length;

    //
    // Set up the security quality of service parameters to use over the
    // port.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    PSX_GET_SESSION_OBJECT_NAME(&PsxPortName, PSX_SS_API_PORT_NAME);

    Status = NtConnectPort(&PsxPortHandle, &PsxPortName, &DynamicQos,
               &ClientView, &ServerView, NULL,
               (PVOID)&ConnectionInformation,
               (PULONG)&ConnectionInformationLength);

    NtClose(PortSection);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("PSXDLL: Unable to connect to Posix server: %lx\n",
            Status));
        return Status;
    }

    Status = NtRegisterThreadTerminatePort(PsxPortHandle);
    ASSERT(NT_SUCCESS(Status));

    PsxPortMemoryBase = ClientView.ViewBase;
    PsxPortMemoryRemoteDelta = (ULONG_PTR)ClientView.ViewRemoteBase -
                   (ULONG_PTR)ClientView.ViewBase;

    RtlMoveMemory((PVOID)PebPsxData,
           (PVOID)&ConnectionInformation.InitialPebPsxData,
               PebPsxData->Length);

    PdxPortHeap = RtlCreateHeap( HEAP_NO_SERIALIZE,
                                 ClientView.ViewBase,
                                 ClientView.ViewSize,
                                 ClientView.ViewSize,
                                 0,
                                 0
                               );

    if (PdxPortHeap == NULL) {
        KdPrint(("PsxConnectToServer: RtlCreateHeap failed\n"));
        return STATUS_NO_MEMORY;
    }

    //
    // Connect to the session console port and
    // set the port handle in the PEB.
    //

    Status = PsxInitializeSessionPort(HandleToUlong(PebPsxData->SessionPortHandle));
    if (!NT_SUCCESS(Status)) {
        KdPrint(("PsxConnectToServer: PsxInitSessionPort failed\n"));
        return Status;
    }
    return STATUS_SUCCESS;
}


//
// User mode process entry point.
//

VOID
PdxProcessStartup(
    IN PPEB Peb
    )

{
    PPEB_PSX_DATA PebPsxData;
    PFNPROCESS StartAddress;
    int ReturnCodeFromMain;

    PebPsxData = (PPEB_PSX_DATA)Peb->SubSystemData;
    StartAddress = (PFNPROCESS)(PebPsxData->ClientStartAddress);

    ReturnCodeFromMain = (*StartAddress) (0, NULL);

    _exit(ReturnCodeFromMain);

    NtTerminateProcess(NtCurrentProcess(),STATUS_ACCESS_DENIED);

}


VOID
PdxNullApiCaller(
    IN PCONTEXT Context
    )
{
    PdxNullPosixApi();
#ifdef _X86_
    Context->Eax = 0;
#endif
    NtContinue(Context,FALSE);
    //NOTREACHED
}


VOID
PdxSignalDeliverer (
    IN PCONTEXT Context,
    IN sigset_t PreviousBlockMask,
    IN int Signal,
    IN _handler Handler
    )
{
    (Handler)(Signal);
    sigprocmask(SIG_SETMASK, &PreviousBlockMask, NULL);


#ifdef _X86_
    Context->Eax = 0;
#endif
    NtContinue(Context, FALSE);
    //NOTREACHED
}

VOID
__PdxInitializeData(
    IN int *perrno,
    IN char ***penviron
    )
/*++

Routine Description:

    This function is called from the RTL startup code to notify the DLL of
    the location of the variable 'errno'. Necessary because DLLs cannot
    export data.

Arguments:

    perrno -  Supplies the address of errno - declared in rtl/startup.c

Return Value:
    None.

--*/
{
    Errno = perrno;
    Environ = penviron;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\dllio.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

   dllio.c

Abstract:

   Client implementation of Input and Output Primitives for POSIX

Author:

   Mark Lucovsky     21-Feb-1989

Revision History:

--*/

#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdarg.h>
#include "psxdll.h"

int
__cdecl
close(int fildes)
{
    PSX_API_MSG m;
    NTSTATUS st;
    PPSX_CLOSE_MSG args;

    args = &m.u.Close;
    PSX_FORMAT_API_MSG(m, PsxCloseApi, sizeof(*args));

    args->FileDes = fildes;

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
        (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }
    return m.ReturnValue;
}

int
__cdecl
creat(const char *path, mode_t mode)
{
    return open(path, O_CREAT | O_WRONLY | O_TRUNC, mode);
}

off_t
__cdecl
lseek(int fildes, off_t offset, int whence)
{
    PSX_API_MSG m;
    NTSTATUS st;
    PPSX_LSEEK_MSG args;

    args = &m.u.Lseek;
    PSX_FORMAT_API_MSG(m, PsxLseekApi, sizeof(*args));

    args->FileDes = fildes;
    args->Whence = whence;
    args->Offset = offset;

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }
    return args->Offset;
}

int
__cdecl
open(const char *path, int oflag, ...)
{
    PSX_API_MSG m;
    NTSTATUS st;
    PPSX_OPEN_MSG args;
    int i;

    va_list va_arg;

    va_start(va_arg, oflag);

    args = &m.u.Open;
    PSX_FORMAT_API_MSG(m, PsxOpenApi, sizeof(*args));

    args->Flags = oflag;

    if (oflag & O_CREAT) {

        //
        // Create requires a third parameter of type mode_t
        // which supplies the mode for a file being created
        //

        args->Mode = va_arg(va_arg, mode_t);
    }

    va_end(va_arg);

    if (!PdxCanonicalize((PSZ)path, &args->Path_U, PdxPortHeap)) {
        return -1;
    }

    ASSERT(NULL != wcschr(args->Path_U.Buffer, L'\\'));

    m.DataBlock = args->Path_U.Buffer;
    args->Path_U.Buffer = (PWSTR)((PCHAR)m.DataBlock +
         PsxPortMemoryRemoteDelta);

    for (;;) {
         st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
         (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
         ASSERT(NT_SUCCESS(st));
#endif

        if (EINTR == m.Error && SIGCONT == m.Signal) {
            //
            // The syscall was stopped and continued.  Call again
            // instead of returning EINTR.
            //

            PSX_FORMAT_API_MSG(m, PsxOpenApi, sizeof(*args));
            continue;
        }
        if (m.Error) {
                args->Path_U.Buffer = m.DataBlock;
                RtlFreeHeap(PdxPortHeap, 0, (PVOID)args->Path_U.Buffer);
                errno = (int)m.Error;
                return -1;
        }

        // successful return
        break;
    }

    args->Path_U.Buffer = m.DataBlock;
    RtlFreeHeap(PdxPortHeap, 0, (PVOID)args->Path_U.Buffer);

    return m.ReturnValue;
}

int
__cdecl
pipe(int *fildes)
{
    PSX_API_MSG m;
    NTSTATUS st;
    PPSX_PIPE_MSG args;

    args = &m.u.Pipe;
    PSX_FORMAT_API_MSG(m, PsxPipeApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }

    try {
        fildes[0] = args->FileDes0;
        fildes[1] = args->FileDes1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        st = STATUS_UNSUCCESSFUL;
    }
    if (!NT_SUCCESS(st)) {
        errno = EFAULT;
        return -1;
    }

    return 0;
}

int
__cdecl
read(int fildes, void *buf, unsigned int nbyte)
{
    PSX_API_MSG m;
    PPSX_READ_MSG args;
    NTSTATUS Status;
    PVOID SesBuf;
    SCREQUESTMSG Request;
    int flags;

    args = &m.u.Read;

    PSX_FORMAT_API_MSG(m, PsxReadApi, sizeof(*args));

    for (;;) {
        args->FileDes = fildes;
        args->Buf = buf;
        args->Nbytes = nbyte;
        args->Command = IO_COMMAND_DONE;

        Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(Status));
#endif

        if (EINTR == m.Error && SIGCONT == m.Signal) {
            //
            // The system call was stopped and continued.  Call again
            // instead of returning EINTR.
            //
            PSX_FORMAT_API_MSG(m, PsxReadApi, sizeof(*args));
            continue;
        }
        if (m.Error) {
            errno = (int)m.Error;
            return -1;
        }
        break;
    }
    if (IO_COMMAND_DONE == args->Command) {
        return m.ReturnValue;
    }

    ASSERT(IO_COMMAND_DO_CONSIO == args->Command);

    flags = args->Scratch1; // do nonblocking io?

    //
    // The server says we should read data from the console.
    //

    if (nbyte > PSX_CON_PORT_DATA_SIZE) {
        nbyte = PSX_CON_PORT_DATA_SIZE;
    }
    SesBuf = ((PPEB_PSX_DATA)NtCurrentPeb()->SubSystemData)->SessionDataBaseAddress;
    Request.Request = ConRequest;
    Request.d.Con.Request = ScReadFile;
    Request.d.Con.d.IoBuf.Handle = (HANDLE)args->FileDes;
    Request.d.Con.d.IoBuf.Len = nbyte;

    if (flags & O_NONBLOCK) {
        Request.d.Con.d.IoBuf.Flags = PSXSES_NONBLOCK;
    } else {
        Request.d.Con.d.IoBuf.Flags = 0;
    }

    Status = SendConsoleRequest(&Request);

    //
    // Want to handle any signals generated as a result of console
    // operations.
    //

    PdxNullPosixApi();

    if (0 != Status) {
        errno = Status;
        return -1;
    }

    nbyte = Request.d.Con.d.IoBuf.Len;
    if (-1 == nbyte) {
        KdPrint(("PSXDLL: Didn't expect to get here\n"));
        errno = EINTR;
        return -1;
    }

    memcpy(buf, SesBuf, nbyte);
    return nbyte;
}


ssize_t
__cdecl
write(int fildes, const void *buf, unsigned int nbyte)
{
    PSX_API_MSG m;
    PPSX_WRITE_MSG args;
    NTSTATUS Status;
    PVOID SesBuf;
    SCREQUESTMSG Request;
    int flags;

    args = &m.u.Write;

    PSX_FORMAT_API_MSG(m, PsxWriteApi, sizeof(*args));

    args->FileDes = fildes;
    args->Buf = (void *)buf;
    args->Nbytes = nbyte;
    args->Command = IO_COMMAND_DONE;

    for (;;) {
        Status = NtRequestWaitReplyPort(PsxPortHandle,
            (PPORT_MESSAGE)&m, (PPORT_MESSAGE)&m);
        if (!NT_SUCCESS(Status)) {
#ifdef PSX_MORE_ERRORS
            KdPrint(("PSXDLL: write: NtRequestWaitReplyPort: 0x%x\n", Status));
#endif
            _exit(0);
        }

        if (m.Error == EINTR && m.Signal == SIGCONT) {
            //
            // The system call was stopped and continued.  Call
            // again instead of returning EINTR.
            //
            PSX_FORMAT_API_MSG(m, PsxWriteApi, sizeof(*args));
            continue;
        }
        if (m.Error) {
                errno = (int)m.Error;
                return -1;
        }
        break;
    }
    if (IO_COMMAND_DONE == args->Command) {
        return m.ReturnValue;
    }
    ASSERT(IO_COMMAND_DO_CONSIO == args->Command);

    flags = args->Scratch1;

    if (nbyte > PSX_CON_PORT_DATA_SIZE) {
        nbyte = PSX_CON_PORT_DATA_SIZE;
    }
    SesBuf = ((PPEB_PSX_DATA)(NtCurrentPeb()->SubSystemData))->SessionDataBaseAddress;
    Request.Request = ConRequest;
    Request.d.Con.Request = ScWriteFile;
    Request.d.Con.d.IoBuf.Handle = (HANDLE)args->FileDes;
    Request.d.Con.d.IoBuf.Len = nbyte;

    if (flags & O_NONBLOCK) {
        Request.d.Con.d.IoBuf.Flags = PSXSES_NONBLOCK;
    }

    memcpy(SesBuf, buf, nbyte);

    Status = SendConsoleRequest(&Request);
    if (!NT_SUCCESS(Status)) {
        errno = PdxStatusToErrno(Status);
        return -1;
    }

    //
    // Want to handle any signals generated as a result of console
    // operations.
    //

    PdxNullPosixApi();

    if (-1 == Request.d.Con.d.IoBuf.Len) {
        errno = EBADF;
    }
    return Request.d.Con.d.IoBuf.Len;
}

int
__cdecl
dup(int fildes)
{
    return fcntl(fildes, F_DUPFD, 0);
}

int
__cdecl
dup2(int fd, int fd2)
{
    PSX_API_MSG m;
    NTSTATUS st;
    PPSX_DUP2_MSG args;

    args = &m.u.Dup2;
    PSX_FORMAT_API_MSG(m, PsxDup2Api, sizeof(*args));

    args->FileDes = fd;
    args->FileDes2 = fd2;

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
            (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }

    return (int)m.ReturnValue;
}

int
__cdecl
fcntl(int fildes, int cmd, ...)
{
    PSX_API_MSG m;
    NTSTATUS Status;
    PPSX_FCNTL_MSG args;
    struct flock *pf, **ppf, *tpf = NULL;
    int i;

    va_list optarg;

    va_start(optarg, cmd);

    args = &m.u.Fcntl;
    PSX_FORMAT_API_MSG(m, PsxFcntlApi, sizeof(*args));

    args->FileDes = fildes;
    args->Command = cmd;

    switch (cmd) {
    case F_DUPFD:

        // third arg is type int

        args->u.i = va_arg(optarg, int);
        va_end(optarg);
        break;

    case F_GETFD:

        // no third arg

        va_end(optarg);
        break;

    case F_SETFD:

        // third arg is type int

        args->u.i = va_arg(optarg, int);
        va_end(optarg);
        break;

    case F_GETFL:

        // no third arg

        va_end(optarg);
        break;

    case F_SETFL:
        // third arg is type int

        args->u.i = va_arg(optarg, int);
        va_end(optarg);
        break;

    case F_GETLK:
    case F_SETLK:
    case F_SETLKW:

        // third arg is type struct flock*

        pf = va_arg(optarg, struct flock *);
        va_end(optarg);

        tpf = RtlAllocateHeap(PdxPortHeap, 0, sizeof(struct flock));
        if (NULL == tpf) {
            errno = ENOMEM;
            return -1;
        }

        Status = STATUS_SUCCESS;
        try {
            memcpy((PVOID)tpf, (PVOID)pf, sizeof(struct flock));
        } except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_UNSUCCESSFUL;
        }
        if (!NT_SUCCESS(Status)) {
            RtlFreeHeap(PdxPortHeap, 0, (PVOID)tpf);
            errno = EFAULT;
            return -1;
        }

        args->u.pf = (struct flock *)((PCHAR)tpf + PsxPortMemoryRemoteDelta);

        break;
#if DBG
    case 99:
        // no third arg
        va_end(optarg);
        break;
#endif
    default:
        // unknown command
        va_end(optarg);
        errno = EINVAL;
        return -1;
    }

    for (;;) {
        Status = NtRequestWaitReplyPort(PsxPortHandle,
            (PPORT_MESSAGE)&m, (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
        if (!NT_SUCCESS(Status)) {
            KdPrint(("PSXDLL: fcntl: NtRequest: 0x%x\n", Status));
            NtTerminateProcess(NtCurrentProcess(), 1);
        }
        ASSERT(NT_SUCCESS(Status));
#endif

        if (m.Error == EINTR && m.Signal == SIGCONT) {
            PSX_FORMAT_API_MSG(m, PsxFcntlApi, sizeof(*args));
            continue;
        }
        if (m.Error) {
            if (NULL != tpf) {
                RtlFreeHeap(PdxPortHeap, 0, (PVOID)tpf);
            }
            errno = (int)m.Error;
            return -1;
        }

        // successful return

        break;
    }

    if (NULL != tpf) {
        // copy the flock back to the caller's address

        if (F_GETLK == cmd) {
            //
            // Copy the retrieved lock back into the user's buf.
            //
            memcpy((PVOID)pf, (PVOID)tpf, sizeof(struct flock));
        }
        RtlFreeHeap(PdxPortHeap, 0, (PVOID)tpf);
    }

    return (int)m.ReturnValue;
}

int
__cdecl
isatty(int fd)
{
    PSX_API_MSG m;
    NTSTATUS Status;
    PPSX_ISATTY_MSG args;
    SCREQUESTMSG Request;

    args = &m.u.Isatty;
    PSX_FORMAT_API_MSG(m, PsxIsattyApi, sizeof(*args));

    args->FileDes = fd;
    args->Command = IO_COMMAND_DONE;

    Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
            (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(Status));
#endif

    if (m.Error) {
            errno = (int)m.Error;
            return 0;
    }

    if (IO_COMMAND_DONE == args->Command) {
        return m.ReturnValue;
    }
    ASSERT(IO_COMMAND_DO_CONSIO == args->Command);

    Request.Request = ConRequest;
    Request.d.Con.Request = ScIsatty;
    Request.d.Con.d.IoBuf.Handle = (HANDLE)args->FileDes;

    Status = SendConsoleRequest(&Request);
    if (!NT_SUCCESS(Status)) {
        errno = PdxStatusToErrno(Status);
        return 0;
    }

    //
    // When the request returns, Len holds the value we're
    // supposed to return, 0 or 1, and -1 for error.
    //

    if (-1 == Request.d.Con.d.IoBuf.Len) {
        errno = EBADF;
        return 0;
    }
    return Request.d.Con.d.IoBuf.Len;
}

//
// isatty2 -- just like isatty, but more permissive.  Will return
//      TRUE if fd open on a console window, even if _POSIX_TERM is
//      not set.
//

int
__cdecl
isatty2(int fd)
{
    PSX_API_MSG m;
    NTSTATUS Status;
    PPSX_ISATTY_MSG args;
    SCREQUESTMSG Request;

    args = &m.u.Isatty;
    PSX_FORMAT_API_MSG(m, PsxIsattyApi, sizeof(*args));

    args->FileDes = fd;
    args->Command = IO_COMMAND_DONE;

    Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
            (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(Status));
#endif

    if (m.Error) {
            errno = (int)m.Error;
            return 0;
    }

    if (IO_COMMAND_DONE == args->Command) {
        return m.ReturnValue;
    }
    ASSERT(IO_COMMAND_DO_CONSIO == args->Command);

    Request.Request = ConRequest;
    Request.d.Con.Request = ScIsatty2;
    Request.d.Con.d.IoBuf.Handle = (HANDLE)args->FileDes;

    Status = SendConsoleRequest(&Request);
    if (!NT_SUCCESS(Status)) {
        errno = PdxStatusToErrno(Status);
        return 0;
    }

    //
    // When the request returns, Len holds the value we're
    // supposed to return, 0 or 1, and -1 for error.
    //

    if (-1 == Request.d.Con.d.IoBuf.Len) {
        errno = EBADF;
        return 0;
    }
    return Request.d.Con.d.IoBuf.Len;
}

int
__cdecl
ftruncate(int fildes, off_t len)
{
    PSX_API_MSG m;
    PPSX_FTRUNCATE_MSG args;
    NTSTATUS Status;

    args = &m.u.Ftruncate;

    PSX_FORMAT_API_MSG(m, PsxFtruncateApi, sizeof(*args));

    args->FileDes = fildes;
    args->Length = len;

    Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                (PPORT_MESSAGE)&m);
    if (!NT_SUCCESS(Status)) {
        return -1;
    }

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\dllname.c ===
#include "psxdll.h"

#if DBG
VOID DumpNames(PSZ, PSTRING );
#endif //DBG

PSTRING
SetPrefix(
    char **Source
    )
{
    static STRING SparePrefix;  // pointer to this may be returned
    static char PrefixBuf[512];

    //
    // Test for leading slash. This tells us whether to start at the root
    // or at the current working directory.
    //

    if (!IS_POSIX_PATH_SEPARATOR(*Source)) {
        // relative pathname
        return &PdxDirectoryPrefix.NtCurrentWorkingDirectory;
    }

    if (!IS_POSIX_PATH_SEPARATOR(&(*Source)[1])) {
        // first char is slash, but second is not. Start at root.
        return &PdxDirectoryPrefix.PsxRoot;
    }
    if (IS_POSIX_PATH_SEPARATOR(&(*Source)[2])) {
        // first three chars are slashes; interpreted as single slash.
        return &PdxDirectoryPrefix.PsxRoot;
    }

    //
    // The path starts with "//something":
    //  //X/        is \DosDevices\X:\
    //

    memset(PrefixBuf, 0, sizeof(PrefixBuf));
    PSX_GET_SESSION_NAME_A(PrefixBuf, DOSDEVICE_A);

    strncat(PrefixBuf, &(*Source)[2], 1);   // get "X"
    strcat(PrefixBuf, ":");         // make "X:"
    *Source += 3;

    SparePrefix.Buffer = PrefixBuf;
    SparePrefix.Length = (USHORT)strlen(PrefixBuf);
    SparePrefix.MaximumLength = sizeof(PrefixBuf);

    return &SparePrefix;
}

BOOLEAN
PdxCanonicalize(
    IN PCHAR PathName,
    OUT PUNICODE_STRING CanonPath_U,
    IN PVOID Heap
    )

/*++

Routine Description:

    This function accepts a POSIX pathname and converts it into a
    Unicode NT pathname.

Arguments:

    PathName - Supplies the POSIX pathname to be translated.

    CanonPath_U - Returns the canonicalized Unicode NT pathname. On a
        successful call, storage is allocated and the CannonPath_U->Buffer
    points to the allocated storage.

    Heap - Supplies the heap that should be used to allocate storage from
        to store the canonicalized pathname.

Return Value:

    TRUE - The pathname was successfully canonicalized.  Storage was
        allocated, and the CanonPath_U string is initialized.

    FALSE - The pathname was not canonicalized. No Storage was
        allocated, and the CanonPath_U string is not initialized.  The
        'errno' variable is set appropriately in this case.


--*/

{
    ANSI_STRING AnsiCanonPath;
    PANSI_STRING CanonPath_A;
    LONG    PathNameLength;
    char    *Source, *Dest, *pch;
    PSTRING Prefix;
    ULONG   UnicodeLength;
    NTSTATUS Status;

    CanonPath_A = &AnsiCanonPath;
    CanonPath_A->Buffer = NULL;

    try {
        PathNameLength = strlen(PathName);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        PathNameLength = -1;
    }
    if (PathNameLength == -1) {
        errno = EFAULT;
        return FALSE;
    }
    if (PathNameLength == 0) {
        errno = ENOENT;
        return FALSE;
    }
    if (PathNameLength > PATH_MAX) {
        errno = ENAMETOOLONG;
        return FALSE;
    }

    Source = PathName;

    Prefix = SetPrefix(&Source);

    CanonPath_A->MaximumLength = (USHORT)(PathNameLength + Prefix->Length + 1);
    CanonPath_A->Buffer = RtlAllocateHeap(Heap, 0, CanonPath_A->MaximumLength);
    if (NULL == CanonPath_A->Buffer) {
        errno = ENOMEM;
        return FALSE;
    }

    //
    // Copy the prefix
    //

    RtlCopyString(CanonPath_A, Prefix);

    Dest = CanonPath_A->Buffer + CanonPath_A->Length;

    while ('\0' != *Source) switch (*Source) {
    case '/':
        // Skip adjacent /'s

        if (Dest[-1] != '\\') {
            *Dest++ = '\\';
        }

        while (IS_POSIX_PATH_SEPARATOR(Source)) {
            Source++;
        }
        break;
    case '.':
        //
        // Eat single dots as in "/./".  For dot-dot back up one level.
        // Any other dot is just a filename character.
        //

        if (IS_POSIX_DOT(Source)) {
            Source++;
            break;
        }
        if (IS_POSIX_DOT_DOT(Source)) {
            UNICODE_STRING U;
            OBJECT_ATTRIBUTES Obj;
            HANDLE FileHandle;
            IO_STATUS_BLOCK Iosb;

            // back up destination string looking for a \.

            do {
                Dest--;
            } while (*Dest != '\\');

            //
            // Make sure the directory that we're using dot-dot
            // in actually exists.
            //

            if (Dest == CanonPath_A->Buffer +
                PdxDirectoryPrefix.PsxRoot.Length) {
                *(Dest + 1) = '\000';
            } else {
                *Dest = '\000';
            }

            CanonPath_A->Length = (USHORT)strlen(CanonPath_A->Buffer);
            Status = RtlAnsiStringToUnicodeString(&U, CanonPath_A,
                TRUE);
            if (!NT_SUCCESS(Status)) {
                RtlFreeHeap(Heap, 0, CanonPath_A->Buffer);
                errno = ENOMEM;
                return FALSE;
            }
            InitializeObjectAttributes(&Obj, &U, 0, NULL, 0);
            Status = NtOpenFile(&FileHandle, SYNCHRONIZE, &Obj,
                &Iosb,
                FILE_SHARE_READ|FILE_SHARE_WRITE|
                FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT |
                FILE_DIRECTORY_FILE);
            RtlFreeUnicodeString(&U);
            if (!NT_SUCCESS(Status)) {
                RtlFreeHeap(Heap, 0, CanonPath_A->Buffer);
                errno = PdxStatusToErrno(Status);
                return FALSE;
            }
            NtClose(FileHandle);

            //
            // Back up to previous component:  "\a\b\c\" to "\a\b\".
            // But if we come to the root, we stay there.
            //

            do {
                if (Dest == CanonPath_A->Buffer +
                    PdxDirectoryPrefix.PsxRoot.Length) {
                    *Dest++ = '\\';
                    break;
                }
                Dest--;
            } while (*Dest != '\\');

            // Advance source past the dot-dot

            Source += 2;
            break;
        }

        // This dot is just a filename character.
        //FALLTHROUGH

    default:
        //
        // Copy a pathname component.  If the pathname component
        // is too long, return ENAMETOOLONG.  Note that using a
        // constant NAME_MAX is bogus, since it could be different
        // for different filesystems.
        //

        pch = strchr(Source, '/');
        if (NULL == pch) {
            // this is the last component in the path.

            if (strlen(Source) > NAME_MAX) {
                errno = ENAMETOOLONG;
                RtlFreeHeap(Heap, 0, CanonPath_A->Buffer);
                return FALSE;
            }
        } else {
            if (pch - Source > NAME_MAX) {
                errno = ENAMETOOLONG;
                RtlFreeHeap(Heap, 0, CanonPath_A->Buffer);
                return FALSE;

            }
        }

        while (*Source != '\0' && *Source != '/') {
            *Dest++ = *Source++;
        }
    }

    //
    // Make sure that we never give back "/DosDevices/C:" ... the
    // Object Manager doesn't deal with that, we need a trailing
    // slash.
    //

    if (Dest == CanonPath_A->Buffer + PdxDirectoryPrefix.PsxRoot.Length) {
        if (Dest[-1] != '\\') {
            *Dest++ = '\\';
        }
    }

    CanonPath_A->Length = (USHORT)((ULONG_PTR)Dest - (ULONG_PTR)CanonPath_A->Buffer);
    CanonPath_A->Buffer[CanonPath_A->Length] = '\0';

    // Convert ansi pathname to unicode - use internal heap for Buffer

    UnicodeLength = RtlAnsiStringToUnicodeSize(CanonPath_A);
    CanonPath_U->MaximumLength = (USHORT)UnicodeLength;
    CanonPath_U->Buffer = RtlAllocateHeap(Heap, 0, UnicodeLength);

    if (NULL == CanonPath_U->Buffer) {
        RtlFreeHeap(Heap, 0, CanonPath_A->Buffer);
        errno = ENOMEM;
        return FALSE;
    }

    Status = RtlAnsiStringToUnicodeString(CanonPath_U, CanonPath_A, FALSE);
    ASSERT(NT_SUCCESS(Status));

    RtlFreeHeap(Heap, 0, CanonPath_A->Buffer);
    return TRUE;
}

#if DBG
VOID
DumpNames(
    IN PSZ PathName,
    IN PSTRING CanonPath_A
    )
{
    USHORT i;
    PSZ p;

    KdPrint(("Input Path: \"%s\"\n",PathName));
    KdPrint(("Output Path: \"%Z\"\n", CanonPath_A));
}

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\dllproc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dllproc.c

Abstract:

    This module implements POSIX process structure APIs

Author:

    Mark Lucovsky (markl) 27-Jun-1989

Revision History:

--*/

#include <sys\utsname.h>
#include <unistd.h>
#include <time.h>
#include <string.h>
#include <stdarg.h>

#ifdef _ALPHA_
#include "psxalpha.h"
#endif
#ifdef _MIPS_
#include "psxmips.h"
#endif
#ifdef _PPC_
#include "psxppc.h"
#endif
#ifdef _X86_
#include "psxi386.h"
#endif
#ifdef _IA64_
#include "psxia64.h"
#endif

#include "psxdll.h"

void
__cdecl
_exit(int status)
{
    PSX_API_MSG m;
    PPSX_EXIT_MSG args;
    NTSTATUS st;

    args = &m.u.Exit;

    PSX_FORMAT_API_MSG(m, PsxExitApi, sizeof(*args));

    args->ExitStatus = (ULONG)status;

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                (PPORT_MESSAGE)&m);

#ifdef PSX_MORE_ERRORS
    if (!NT_SUCCESS(st)) {
        KdPrint(("PSXDLL: _exit: 0x%x\n", st));
    }
#endif
    NtTerminateProcess(NtCurrentProcess(), 0);
}

gid_t
__cdecl
getegid(void)
{
    PSX_API_MSG m;
    PPSX_GETIDS_MSG args;
    NTSTATUS st;

    args = &m.u.GetIds;

    PSX_FORMAT_API_MSG(m, PsxGetIdsApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    return args->EffectiveGid;
}

gid_t
__cdecl
getgid(void)
{
    PSX_API_MSG m;
    PPSX_GETIDS_MSG args;
    NTSTATUS st;

    args = &m.u.GetIds;

    PSX_FORMAT_API_MSG(m, PsxGetIdsApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    return args->RealGid;
}

uid_t
__cdecl
geteuid(void)
{
    PSX_API_MSG m;
    PPSX_GETIDS_MSG args;
    NTSTATUS st;

    args = &m.u.GetIds;

    PSX_FORMAT_API_MSG(m, PsxGetIdsApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    return args->EffectiveUid;
}

uid_t
__cdecl
getuid(void)
{
    PSX_API_MSG m;
    PPSX_GETIDS_MSG args;
    NTSTATUS st;

    args = &m.u.GetIds;

    PSX_FORMAT_API_MSG(m, PsxGetIdsApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    return args->RealUid;
}

pid_t
__cdecl
getppid(void)
{
    PSX_API_MSG m;
    PPSX_GETIDS_MSG args;
    NTSTATUS st;

    args = &m.u.GetIds;

    PSX_FORMAT_API_MSG(m, PsxGetIdsApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    return args->ParentPid;
}

pid_t
__cdecl
getpid(void)
{
    PSX_API_MSG m;
    PPSX_GETIDS_MSG args;
    NTSTATUS st;

    args = &m.u.GetIds;

    PSX_FORMAT_API_MSG(m, PsxGetIdsApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    return args->Pid;
}

pid_t
__cdecl
getpgrp(void)
{
    PSX_API_MSG m;
    PPSX_GETIDS_MSG args;
    NTSTATUS st;

    args = &m.u.GetIds;

    PSX_FORMAT_API_MSG(m, PsxGetIdsApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    return args->GroupId;
}

pid_t
__cdecl
setsid(void)
{
    PSX_API_MSG m;
    NTSTATUS st;

    PSX_FORMAT_API_MSG(m, PsxSetSidApi, 0);

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    if (m.Error) {
        errno = m.Error;
        return -1;
    }
    return (pid_t)m.ReturnValue;
}

int
__cdecl
setpgid(pid_t pid, pid_t pgid)
{
    PSX_API_MSG m;
    PPSX_SETPGROUPID_MSG args;
    NTSTATUS st;

    args = &m.u.SetPGroupId;

    PSX_FORMAT_API_MSG(m, PsxSetPGroupIdApi, sizeof(*args));

    args->Pid = pid;
    args->Pgid = pgid;

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }
    return (int)m.ReturnValue;
}

pid_t
__cdecl
waitpid(pid_t pid, int *stat_loc, int options)
{
    PSX_API_MSG m;
    PPSX_WAITPID_MSG args;
    NTSTATUS st;

    args = &m.u.WaitPid;

    PSX_FORMAT_API_MSG(m, PsxWaitPidApi, sizeof(*args));

    args->Pid = pid;
    args->Options = options;

    for (;;) {
        st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                        (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
        if (!NT_SUCCESS(st)) {
            KdPrint(("PSXDLL: waitpid: 0x%x\n", st));
        }
        ASSERT(NT_SUCCESS(st));
#endif

        if (EINTR == m.Error && SIGCONT == m.Signal) {
            // We were stopped and then continued.  Continue
            // waiting.

            PSX_FORMAT_API_MSG(m, PsxWaitPidApi, sizeof(*args));
            continue;
        }

        if (m.Error) {
            errno = (int)m.Error;
            return -1;
        }
        if (NULL != stat_loc) {
            try {
                *stat_loc = args->StatLocValue;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                errno = EFAULT;
                m.ReturnValue = (ULONG)-1;
            }
        }
        return (int)m.ReturnValue;
    }
}

pid_t
__cdecl
wait(int *stat_loc)
{
    PSX_API_MSG m;
    PPSX_WAITPID_MSG args;
    NTSTATUS st;

    args = &m.u.WaitPid;

    PSX_FORMAT_API_MSG(m, PsxWaitPidApi, sizeof(*args));

    args->Pid = (pid_t)-1;
    args->Options = (pid_t)0;

    for (;;) {
        st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
            (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
        if (!NT_SUCCESS(st)) {
            KdPrint(("PSXDLL: wait: NtRequest: 0x%x\n", st));
        }
        ASSERT(NT_SUCCESS(st));
#endif

        if (EINTR == m.Error && SIGCONT == m.Signal) {
            // We were stopped and continued.  Continue waiting.
            PSX_FORMAT_API_MSG(m, PsxWaitPidApi, sizeof(*args));
            continue;
        }

        if (m.Error) {
            errno = (int)m.Error;
            return -1;
        }
        if (ARGUMENT_PRESENT(stat_loc)) {
            try {
                    *stat_loc = args->StatLocValue;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                errno = EFAULT;
                m.ReturnValue = (ULONG)-1;
            }
        }
        return (int)m.ReturnValue;
    }
}

pid_t
__cdecl
fork(void)
{
    PSX_API_MSG m;
    NTSTATUS st;
    PPSX_FORK_MSG args;
    PTEB ThreadInfo;

    args = &m.u.Fork;

again:
    PSX_FORMAT_API_MSG(m, PsxForkApi, sizeof(*args));

    ThreadInfo = NtCurrentTeb();
    args->StackBase = ThreadInfo->NtTib.StackBase;
    args->StackLimit = ThreadInfo->NtTib.StackLimit;
    args->StackAllocationBase = ThreadInfo->DeallocationStack;
#ifdef  _IA64_
    args->BStoreLimit = ThreadInfo->BStoreLimit;
#endif

    try {
        st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                (PPORT_MESSAGE)&m);
    } except (EXCEPTION_EXECUTE_HANDLER) {
    KdPrint(("PSXDLL: fork: took an exception\n"));
    KdPrint(("PSXDLL: exception is 0x%x\n", GetExceptionCode()));
    }
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif

    if (st == PSX_FORK_RETURN) {
        st = PsxConnectToServer();
        if (!NT_SUCCESS(st)) {
            KdPrint(("PsxConnectToServer: 0x%x\n", st));
            NtTerminateProcess(NtCurrentProcess(), 1);
            ASSERT(0);
        }

        // take any pending signals now.
        PdxNullPosixApi();
        return 0;
    }
    if (EINTR == m.Error) {
        // try again.
        goto again;
    }

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }

    return (int)m.ReturnValue;
}

//
// vexec -- Varargs exec program, called by execl*.
//

int
vexec(const char *path, const char *arg0, char * const envp[], va_list arglist)
{
    NTSTATUS st;
    PSX_API_MSG m;
    PPSX_EXEC_MSG args;

    char **ppch;
    char *pch, *pcharg;
    int i;
    int retval = 0;
    char *Args;         // the args + env for the call

    va_list save_arglist;

    try {
        if (0 == *path) {
            errno = ENOENT;
            return -1;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        errno = EFAULT;
        retval = -1;
    }
    if (0 != retval) {
        return retval;
    }

    args = &m.u.Exec;
    PSX_FORMAT_API_MSG(m, PsxExecApi, sizeof(*args));

    if (!PdxCanonicalize((PSZ)path, &args->Path, PdxHeap)) {
        return -1;
    }

    Args = RtlAllocateHeap(PdxPortHeap, 0, ARG_MAX);
    if (NULL == Args) {
        errno = ENOMEM;
        return -1;
    }

    args->Args = Args + PsxPortMemoryRemoteDelta;

    //
    // Port Memory Setup is same as for execve, see below.
    //

    //
    // first we count the strings so we know how much space to leave
    // for pointers.
    //

    save_arglist = arglist;

    for (i = 0, pcharg = va_arg(arglist, char *); NULL != pcharg;
        pcharg = va_arg(arglist, char *)) {
        ++i;
    }
    ++i;        // add one for arg0
    for (ppch = (char **)envp; NULL != *ppch; ++ppch)
        ++i;
    i += 2;     // add space for the NULL pointers

    pch = Args + sizeof(char *) * i;

    if (pch > Args + ARG_MAX) {
        RtlFreeHeap(PdxPortHeap, 0, (PVOID)Args);
        errno = E2BIG;
        return -1;
    }

    ppch = (char **)Args;

    arglist = save_arglist;     // restart arglist

    try {
        pcharg = (char *)arg0;
        while (NULL != pcharg) {
            if (pch + strlen(pcharg) + 1 > Args + ARG_MAX) {
                RtlFreeHeap(PdxPortHeap, 0, (PVOID)Args);
                errno = E2BIG;
                return -1;
            }
            *ppch = pch - (ULONG_PTR)Args;
            ppch++;
            (void)strcpy(pch, pcharg);
            pcharg = va_arg(arglist, char *);

            pch += strlen(pch);
            *pch++ = '\0';
        }
        *ppch = NULL;
        ppch++;

        while (NULL != *envp) {
            if (pch + strlen(*envp) + 1 > Args + ARG_MAX) {
                RtlFreeHeap(PdxPortHeap, 0, (PVOID)Args);
                errno = E2BIG;
                return -1;
            }
            *ppch = pch - (ULONG_PTR)Args;
            ppch++;
            (void)strcpy(pch, *envp);
            envp++;

            pch += strlen(pch);
            *pch++ = '\0';
        }
        *ppch = NULL;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        errno = EFAULT;
        retval = -1;
    }
    if (0 != retval) {
        RtlFreeHeap(PdxPortHeap, 0, (PVOID)Args);
        return -1;
    }

    (void)NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
    //
    // If we get here, there's been an error.
    //

    errno = (int)m.Error;
    RtlFreeHeap(PdxHeap, 0, (PVOID)&args->Path);
    RtlFreeHeap(PdxPortHeap, 0, (PVOID)Args);

    return -1;
}

int
__cdecl
execve(const char *path, char * const argv[], char * const envp[])
{
    NTSTATUS st;
    PSX_API_MSG m;
    PPSX_EXEC_MSG args;
    PCHAR Args;         // allocate args + environ

    char **ppch;
    char *pch;
    int i;
    int retval = 0;

    try {
        if (0 == strlen(path)) {
            errno = ENOENT;
            return -1;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        retval = -1;
        errno = EFAULT;
    }
    if (0 != retval) {
        return -1;
    }

    args = &m.u.Exec;
    PSX_FORMAT_API_MSG(m, PsxExecApi, sizeof(*args));

    if (!PdxCanonicalize((PSZ)path, &args->Path, PdxHeap)) {
        return -1;
    }

    //
    // Copy the caller's environment into view memory so that it may
    // be transmitted to the "overlaid" process.  We set up the port
    // memory to look like:
    //
    //  ClientPortMemory:
    //      argv[0]
    //      argv[1]
    //      ...
    //      NULL
    //      envp[0]
    //      envp[1]
    //      ...
    //      NULL
    //      <argv strings>
    //      <environ strings>
    //
    // The argv and envp pointers are converted to offsets relative to
    // ClientPortMemory.
    //
    // Because we need all this memory for args and environ, we destroy
    // the heap and recreate it if the call fails.
    //

    Args = RtlAllocateHeap(PdxPortHeap, 0, ARG_MAX);
    if (NULL == Args) {
        errno = ENOMEM;
        return -1;
    }

    args->Args = Args + PsxPortMemoryRemoteDelta;

    try {

        // first we count the strings so we know how much space to leave
        // for pointers.

        for (i = 0, ppch = (char **)argv; NULL != *ppch; ++ppch)
            ++i;
        for (ppch = (char **)envp; NULL != *ppch; ++ppch)
            ++i;
        i += 2;     // add space for the NULL pointers

        pch = Args + sizeof(char *) * i;

        if (pch > Args + ARG_MAX) {
            RtlFreeHeap(PdxPortHeap, 0, (PVOID)Args);
            errno = E2BIG;
            return -1;
        }

        ppch = (char **)Args;

        while (NULL != *argv) {
            if (pch + strlen(*argv) + 1 > Args + ARG_MAX) {
                RtlFreeHeap(PdxPortHeap, 0, (PVOID)Args);
                errno = E2BIG;
                return -1;
            }
            *ppch = pch - (ULONG_PTR)Args;
            ppch++;
            (void)strcpy(pch, *argv);
            argv++;

            pch += strlen(pch);
            *pch++ = '\0';
        }
        *ppch = NULL;
        ppch++;

        while (NULL != *envp) {
            if (pch + strlen(*envp) + 1 > Args + ARG_MAX) {
                RtlFreeHeap(PdxPortHeap, 0, (PVOID)Args);
                errno = E2BIG;
                return -1;
            }
            *ppch = pch - (ULONG_PTR)Args;
            ppch++;
            (void)strcpy(pch, *envp);
            envp++;

            pch += strlen(pch);
            *pch++ = '\0';
        }
        *ppch = NULL;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        retval = -1;
        errno = EFAULT;
    }
    if (0 != retval) {
        return -1;
    }

    (void)NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
    //
    // If we get here, there's been an error.
    //

    errno = (int)m.Error;
    RtlFreeHeap(PdxHeap, 0, (PVOID)&args->Path);
    RtlFreeHeap(PdxPortHeap, 0, (PVOID)Args);

    return -1;
}

int
__cdecl
execv(const char *path, char * const argv[])
{
    return execve(path, argv, environ);
}

int
__cdecl
execl(const char *path, const char *arg0, ...)
{
    va_list args;
    int retval;

    va_start(args, arg0);

    retval = vexec(path, arg0, environ, args);

    va_end(args);

    return retval;
}

int
__cdecl
execle(const char *path, const char *arg0, ...)
{
    va_list args;
    char * const *Env;
    int retval;

    va_start(args, arg0);

    // Skip up to the NULL, then one more, to find environ.

    do {
        Env = va_arg(args, char * const *);
    } while (NULL != Env);

    Env = va_arg(args, char * const *);

    va_end(args);

    if (NULL == Env) {
        return EINVAL;
    }

    // Restart the arglist traversal

    va_start(args, arg0);

    retval = vexec(path, arg0, Env, args);

    va_end(args);

    return retval;
}

int
__cdecl
execlp(const char *file, const char *arg0, ...)
{
    char *pch;
    char *path;
    static char buf[PATH_MAX + 1];
    va_list args;
    int retval = 0;
    BOOLEAN done = FALSE;

    va_start(args, arg0);

    //
    // 1003.1-1990 (3.1.2.2):  If the file argument contains a slash
    // character, the file argument shall be used as the pathname for
    // this file....
    //

    try {
        if ('\0' == *file) {
            errno = ENOENT;
            va_end(args);
            return -1;
        }
        if (NULL != (pch = strchr(file, '/'))) {
            if (-1 == access(file, F_OK)) {
                va_end(args);
                return -1;
            }
            retval = vexec(file, arg0, environ, args);
            va_end(args);
            return retval;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        errno = EFAULT;
        retval = -1;
    }
    if (0 != retval) {
        va_end(args);
        return -1;
    }

    //
    // ... Otherwise, the path prefix for this file is obtained by a
    // search of the directories passed as the environment variable
    // PATH.
    //

    if (NULL == (path = getenv("PATH"))) {
        //
        // The file name doesn't contain a slash, and we have
        // no PATH.  We just try for it in the current working
        // directory, and will return ENOENT if it's not there.
        //
        retval = vexec(file, arg0, environ, args);
        va_end(args);
        return retval;
    }

    errno = 0;
    do {
        pch = strchr(path, ':');
        if (NULL == pch) {
            done = TRUE;
        } else {
            *pch = '\0';
        }
        if (strlen(path) + strlen(file) + 1 > PATH_MAX) {
            if (pch) {
                *pch = ':';
            }
            errno = ENAMETOOLONG;
            va_end(args);
            return -1;
        }
        strcpy(buf, path);
        if (!done) {
            *pch = ':';
            path = pch + 1;
        }
        if (strlen(buf) > 0) {
            // this case is "::" in the PATH
            strcat(buf, "/");
        }
        strcat(buf, file);

        // avoid trying to execute files that do not exist.

        if (-1 != access(buf, F_OK)) {
            (void)vexec(buf, arg0, environ, args);
            break;
        }
    } while (!done);

    va_end(args);

    if (0 == errno) {
        //
        // We went all the way through the PATH without finding
        // a file to exec.  Since errno didn't get set by execve(),
        // we set it here.
        //

        errno = ENOENT;
    }

    return -1;
}

int
__cdecl
execvp(const char *file, char * const argv[])
{
    char *pch;
    char *path;
    static char buf[PATH_MAX + 1];
    BOOLEAN done = FALSE;
    int retval = 0;

    //
    // 1003.1-1990 (3.1.2.2):  If the file argument contains a slash
    // character, the file argument shall be used as the pathname for
    // this file....
    //

    try {
        if ('\0' == *file) {
            errno = ENOENT;
            return -1;
        }
        if (NULL != (pch = strchr(file,  '/'))) {
            if (-1 == access(file, F_OK)) {
                return -1;
            }
            return execve(file, argv, environ);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        errno = EFAULT;
        retval = -1;
    }
    if (0 != retval) {
        return -1;
    }

    //
    // ... Otherwise, the path prefix for this file is obtained by a
    // search of the directories passed as the environment variable
    // PATH.
    //

    if (NULL == (path = getenv("PATH"))) {
        return execve(file, argv, environ);
    }

    errno = 0;

    do {
        pch = strchr(path, ':');
        if (NULL == pch) {
            done = TRUE;
        } else {
            *pch = '\0';
        }
        if (strlen(path) + strlen(file) + 1 > PATH_MAX) {
            if (pch) {
                *pch = ':';
            }
            errno = ENAMETOOLONG;
            return -1;
        }
        strcpy(buf, path);
        if (!done) {
            *pch = ':';
            path = pch + 1;
        }
        if (strlen(buf) > 0) {
            // this case is "::" in the PATH
            strcat(buf, "/");
        }
        strcat(buf, file);

        // avoid trying to execute files that do not exist

        if (-1 != access(buf, F_OK)) {
            (void)execve(buf, argv, environ);
            break;
        }
    } while (!done);

    if (0 == errno) {

        //
        // We went all the way through the PATH without finding
        // a file to exec.  Since errno didn't get set by execve(),
        // we set it here.
        //

        errno = ENOENT;
    }

    return -1;
}

#define COMPUTERNAME_ROOT   \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName"
#define NON_VOLATILE_COMPUTERNAME   L"ComputerName"
#define COMPUTERNAME_VALUE_NAME     L"ComputerName"
#define VALUE_BUFFER_SIZE   \
    (sizeof(KEY_VALUE_PARTIAL_INFORMATION)  \
    + (_POSIX_NAME_MAX * sizeof(WCHAR)))

int __cdecl
uname(struct utsname *name)
{
    NTSTATUS Status;
    SYSTEM_PROCESSOR_INFORMATION
            ProcInfo;
    UNICODE_STRING
            KeyName,
            Class,
            ValueName,
            Computer_U;
    ANSI_STRING
            Computer_A;
    OBJECT_ATTRIBUTES
            ObjectAttributes;
    HANDLE  hKey = NULL,
            hSubKey = NULL;
    WCHAR   ValueBuf[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION
            pKeyValueInfo = (PVOID)ValueBuf;
    ULONG   ValueLength;
    char    *pchProcType,           // processor type
            *pchNode = "";          // node name
    int retval = 0;

    Status = NtQuerySystemInformation(SystemProcessorInformation,
        (PVOID)&ProcInfo, sizeof(ProcInfo), NULL);
    if (!NT_SUCCESS(Status)) {
        errno = PdxStatusToErrno(Status);
        return -1;
    }

    switch (ProcInfo.ProcessorArchitecture) {
    case PROCESSOR_ARCHITECTURE_INTEL:
        if (ProcInfo.ProcessorLevel == 3) {
            pchProcType = "i386";
        } else if (ProcInfo.ProcessorLevel == 4) {
            pchProcType = "i486";
        } else if (ProcInfo.ProcessorLevel == 5) {
            pchProcType = "Pentium";
        } else {
            pchProcType = "Intel Unknown";
        }
        break;

    case PROCESSOR_ARCHITECTURE_IA64:
        pchProcType = "IA64";
        break;

    case PROCESSOR_ARCHITECTURE_MIPS:
        pchProcType = "R4000";
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
        if (ProcInfo.ProcessorLevel == 21064) {
            pchProcType = "Alpha 21064";
        } else if (ProcInfo.ProcessorLevel == 21164) {
            pchProcType = "Alpha 21164";
        } else {
            pchProcType = "Alpha Unknown";
        }
        break;

    case PROCESSOR_ARCHITECTURE_PPC:
        if (ProcInfo.ProcessorLevel == 1) {
            pchProcType = "PowerPC 601";
        } else if (ProcInfo.ProcessorLevel == 3) {
            pchProcType = "PowerPC 603";
        } else if (ProcInfo.ProcessorLevel == 4) {
            pchProcType = "PowerPC 604";
        } else if (ProcInfo.ProcessorLevel == 6) {
            pchProcType = "PowerPC 603+";
        } else if (ProcInfo.ProcessorLevel == 9) {
            pchProcType = "PowerPC 604+";
        } else if (ProcInfo.ProcessorLevel == 20) {
            pchProcType = "PowerPC 620";
        } else {
            pchProcType = "PowerPC Unknown";
        }
        break;

    default:
        pchProcType = "unknown";
        break;
    }

    //
    // Find the node name:  this code lifted from
    // windows/base/client/compname.c
    //

    RtlInitUnicodeString(&KeyName, COMPUTERNAME_ROOT);
    InitializeObjectAttributes(&ObjectAttributes, &KeyName,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("PSXDLL: NtOpenKey: 0x%x\n", Status));
        goto done;
    }

    RtlInitUnicodeString(&KeyName, NON_VOLATILE_COMPUTERNAME);
    InitializeObjectAttributes(&ObjectAttributes, &KeyName,
        OBJ_CASE_INSENSITIVE, hKey, NULL);

    Status = NtOpenKey(&hSubKey, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("PSXDLL: NtOpenKey: 0x%x\n", Status));
        goto done;
    }

    RtlInitUnicodeString(&ValueName, COMPUTERNAME_VALUE_NAME);

    Status = NtQueryValueKey(hSubKey, &ValueName,
        KeyValuePartialInformation,
        (PVOID)pKeyValueInfo, VALUE_BUFFER_SIZE, &ValueLength);
    ASSERT(ValueLength < VALUE_BUFFER_SIZE);

    if (!NT_SUCCESS(Status)) {
        KdPrint(("PSXDLL: NtQueryValueKey: 0x%x\n", Status));
        goto done;
    }
    if (pKeyValueInfo->DataLength == 0) {
        goto done;
    }

    Computer_U.Buffer = (PVOID)&pKeyValueInfo->Data;
    Computer_U.Length = Computer_U.MaximumLength =
         (USHORT)pKeyValueInfo->DataLength;

    Status = RtlUnicodeStringToAnsiString(&Computer_A, &Computer_U, TRUE);
    if (!NT_SUCCESS(Status)) {
        goto done;
    }
    pchNode = Computer_A.Buffer;

done:
    if (NULL != hSubKey) {
        NtClose(hSubKey);
    }
    if (NULL != hKey) {
        NtClose(hKey);
    }

    try {
        strncpy((PCHAR)name->sysname, (PCHAR)UNAME_SYSNAME, sizeof(name->sysname));
        strncpy((PCHAR)name->release, (PCHAR)UNAME_RELEASE, sizeof(name->release));
        strncpy((PCHAR)name->version, (PCHAR)UNAME_VERSION, sizeof(name->version));
        strncpy((PCHAR)name->nodename, (PCHAR)pchNode, sizeof(name->nodename));
        strncpy((PCHAR)name->machine, (PCHAR)pchProcType, sizeof(name->machine));
    } except (EXCEPTION_EXECUTE_HANDLER) {
        errno = EFAULT;
        retval = -1;
    }
    RtlFreeAnsiString(&Computer_A);
    return retval;
}

char * __cdecl
getenv(const char *name)
{
    char **ppch;
    char *pch;

    try {
        for (ppch = environ; NULL != *ppch; ++ppch) {
            if (NULL == (pch = strchr(*ppch, '='))) {
                continue;
            }
            *pch = '\0';            // delete the equals
            if (0 == strcmp(*ppch, name)) {
                *pch = '=';
                return pch + 1;
            }
            *pch = '=';
        }
        return NULL;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        errno = EFAULT;
    }
    return NULL;
}

time_t __cdecl
time(time_t *tloc)
{
    LARGE_INTEGER TimeOfDay;
    ULONG PosixTime;

    NtQuerySystemTime(&TimeOfDay);
    if (RtlTimeToSecondsSince1970(&TimeOfDay, &PosixTime)) {
        if (ARGUMENT_PRESENT(tloc)) {
        try {
                *tloc = PosixTime;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            errno = EFAULT;
        }
        }
    } else {
        PosixTime = (ULONG)-1;      // Time not within range of 1970 - 2105
    }
    return (time_t)PosixTime;
}


clock_t
__cdecl
times(struct tms *buffer)
{
    PSX_API_MSG m;
    PPSX_GETPROCESSTIMES_MSG args;
    LARGE_INTEGER TimeOfDay;
    ULONG Remainder;
    NTSTATUS st;
    int retval = 0;

    args = &m.u.GetProcessTimes;

    PSX_FORMAT_API_MSG(m, PsxGetProcessTimesApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
            (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    if (m.Error) {
            errno = (int)m.Error;
            return -1;
    }

    try {
        *buffer = args->ProcessTimes;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        errno = EFAULT;
        retval = -1;
    }
    if (0 != retval) {
        return -1;
    }

    NtQuerySystemTime(&TimeOfDay);

    TimeOfDay = RtlExtendedLargeIntegerDivide(TimeOfDay, 10000L,
        &Remainder);

    return TimeOfDay.LowPart;
}

long
__cdecl
sysconf(int name)
{
    PSX_API_MSG m;
    PPSX_SYSCONF_MSG args;
    NTSTATUS st;

    args = &m.u.Sysconf;

    args->Name = name;

    PSX_FORMAT_API_MSG(m, PsxSysconfApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
        (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif

    if (0 != m.Error) {
        errno = m.Error;
        return -1;
    }
    return m.ReturnValue;
}

int
__cdecl
getgroups(int gidsetsize, gid_t *grouplist)
{
    PSX_API_MSG m;
    PPSX_GETGROUPS_MSG args;
    NTSTATUS st;

    args = &m.u.GetGroups;
    args->GroupList = grouplist;
    args->NGroups = gidsetsize;

    //
    // The Posix server will write group id's into the group
    // array with NtWriteVirtualMemory, unless gidsetsize is
    // 0.  In that case, he returns the size required and does
    // not try to write the list.
    //

    PSX_FORMAT_API_MSG(m, PsxGetGroupsApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                    (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif
    if (0 != m.Error) {
        errno = m.Error;
        return -1;
    }
    return m.ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\makefile.inc ===
$(O)\psxdll.def: psxdll.src
    $(TARGET_CPP) /EP $(CDEFINES) psxdll.src > $(O)\psxdll.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\dllreg.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dllreg.c

Abstract:

    This module implements POSIX registry APIs

Author:

    Matthew Bradburn (mattbr) 13-Dec-1995

Revision History:

--*/

#include <sys\utsname.h>
#include <unistd.h>
#include <string.h>
#include <stdarg.h>
#include "psxdll.h"


//
// First guess for value size.
//

#define KEY_WORK_AREA 256

int
__cdecl
getreg(char *path, int *type, void *data, size_t *size)
{
    NTSTATUS Status;
    UNICODE_STRING Key_U, Value_U;
    ANSI_STRING Key_A, Value_A;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE hKey = NULL;
    CHAR *pch;
    PKEY_VALUE_PARTIAL_INFORMATION pInfo = NULL;
    UCHAR Buffer[KEY_WORK_AREA];
    ULONG RequestLength, ResultLength;
    int r = 0;

    Key_U.Buffer = NULL;
    Value_U.Buffer = NULL;

    if (strlen(path) > PATH_MAX) {
        errno = ENAMETOOLONG;
        return -1;
    }

    //
    // Split the path into key and value.
    //

    pch = strrchr(path, '\\');
    if (NULL == pch) {
        errno = ENOENT;
        return -1;
    }

    Value_A.Buffer = pch + 1;
    Value_A.Length = (USHORT)strlen(Value_A.Buffer);
    Value_A.MaximumLength = Value_A.Length + 1;

    Key_A.Buffer = path;
    Key_A.Length = (USHORT)(pch - path);
    Key_A.MaximumLength = Key_A.Length + 1;

    Status = RtlAnsiStringToUnicodeString(&Key_U, &Key_A, TRUE);
    if (!NT_SUCCESS(Status)) {
        errno = PdxStatusToErrno(Status);
        r = -1;
        goto out;
    }

    Status = RtlAnsiStringToUnicodeString(&Value_U, &Value_A, TRUE);
    if (!NT_SUCCESS(Status)) {
        errno = PdxStatusToErrno(Status);
        r = -1;
        goto out;
    }

    InitializeObjectAttributes(&ObjA, &Key_U, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtOpenKey(&hKey, KEY_READ, &ObjA);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("PSXDLL: NtOpenKey: 0x%x\n", Status));
        errno = PdxStatusToErrno(Status);
        r = -1;
        goto out;
    }

    RequestLength = KEY_WORK_AREA;
    pInfo = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;

    for (;;) {

        Status = NtQueryValueKey(hKey, &Value_U, KeyValuePartialInformation,
            (PVOID)pInfo, RequestLength, &ResultLength);

        if (Status == STATUS_BUFFER_OVERFLOW) {

            //
            // Try to get a bigger buffer.
            //

            if (pInfo != (PKEY_VALUE_PARTIAL_INFORMATION)Buffer) {

                RtlFreeHeap(PdxHeap, 0, pInfo);
            }

            RequestLength += 512;
            pInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                        RtlAllocateHeap(PdxHeap, 0, RequestLength);

            if (NULL == pInfo) {
                errno = ENOMEM;
                r = -1;
                goto out;
            }
        } else {
            break;
        }
    }

    if (!NT_SUCCESS(Status)) {

        r = -1;
        errno = PdxStatusToErrno(Status);

    } else {

        if (pInfo->DataLength > *size) {
            *size = pInfo->DataLength;
            *type = 0;
            errno = E2BIG;
            r = -1;

        } else {

            *size = pInfo->DataLength;
            *type = pInfo->Type;
            memcpy(data, pInfo->Data, pInfo->DataLength);
        }
    }

out:

    if (pInfo != NULL && pInfo != (PKEY_VALUE_PARTIAL_INFORMATION)Buffer) {
        RtlFreeHeap(PdxHeap, 0, pInfo);
    }

    if (Key_U.Buffer != NULL) {
        RtlFreeUnicodeString(&Key_U);
    }
    if (Value_U.Buffer != NULL) {
        RtlFreeUnicodeString(&Value_U);
    }
    if (hKey != NULL) {
        NtClose(hKey);
    }
    if (pInfo != NULL) {
        RtlFreeHeap(PdxHeap, 0, (PVOID)pInfo);
    }

    return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\dllsig.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dllsig.c

Abstract:

    Posix Signal Handling RTL

Author:

    Mark Lucovsky (markl) 10-Mar-1989

Revision History:

--*/

#include "psxdll.h"
#include <excpt.h>

#define _SIGNULLSET 0x0
#define _SIGFULLSET 0x7ffff // ((1<<SIGTTOU) - 1)

int
__cdecl
sigemptyset(sigset_t *set)
{
	int r = 0;
try {
    *set = _SIGNULLSET;
} except (EXCEPTION_EXECUTE_HANDLER) {
	KdPrint(("PSXDLL: error in sigemptyset\n"));
	KdPrint(("PSXDLL: set is 0x%x\n", set));
	KdPrint(("PSXDLL: exception code 0x%x\n", GetExceptionCode()));
}
    return r;
}

int
__cdecl
sigfillset(sigset_t *set)
{
	int r = 0;

	try {
		*set = _SIGFULLSET;
	} except (EXCEPTION_EXECUTE_HANDLER) {
		errno = EFAULT;
		r = -1;
	}
	return r;
}

int __cdecl
sigaddset(sigset_t *set, int signo)
{
	sigset_t SignoAsMask;
	int r = 0;

	if (signo < 1 || signo > SIGTTOU) {
		errno = EINVAL;
		return -1;
	}

	SignoAsMask = (ULONG)(1l << (ULONG)(signo-1) );

	try {
		*set |= SignoAsMask;
	} except (EXCEPTION_EXECUTE_HANDLER) {
		errno = EFAULT;
		r = -1;
	}
	return r;
}

int __cdecl
sigdelset(sigset_t *set, int signo)
{
	sigset_t SignoAsMask;
	int r = 0;

	if (signo < 1 || signo > SIGTTOU) {
		errno = EINVAL;
		return -1;
	}

	SignoAsMask = (ULONG)(1l << (ULONG)(signo-1) );

	try {
		*set &= ~SignoAsMask;
	} except (EXCEPTION_EXECUTE_HANDLER) {
		errno = EFAULT;
		r = -1;
	}
	return r;
}

int __cdecl
sigismember(const sigset_t *set, int signo)
{
	sigset_t SignoAsMask;
	int r = 0;

	if (signo < 1 || signo > SIGTTOU) {
		errno = EINVAL;
		return -1;
	}

	SignoAsMask = (ULONG)(1L << (ULONG)(signo-1));

	try {
		if (*set & SignoAsMask) {
			return 1;
		}
	} except (EXCEPTION_EXECUTE_HANDLER) {
		errno = EFAULT;
		r = -1;
	}
	return r;
}


//
// System Services
//

int
__cdecl
sigaction(int sig, const struct sigaction *act, struct sigaction *oact)
{
    PSX_API_MSG m;
    NTSTATUS st;
    int r = 0;

    PPSX_SIGACTION_MSG args;

    args = &m.u.SigAction;

    PSX_FORMAT_API_MSG(m, PsxSigActionApi, sizeof(*args));

    args->Sig = (ULONG)sig;
    args->ActSpecified = (struct sigaction *)act;

    if (ARGUMENT_PRESENT(act)) {
	try {
	        args->Act = *act;
	} except (EXCEPTION_EXECUTE_HANDLER) {
		KdPrint(("PSXDLL: err in sigaction\n"));
		errno = EFAULT;
		r = -1;
	}
	if (r != 0) {
		return r;
	}
    }

    args->OactSpecified = oact;

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                (PPORT_MESSAGE)&m);

    if (!NT_SUCCESS(st)) {
#ifdef PSX_MORE_ERRORS
	    KdPrint(("PSXDLL: sigaction: NtRequestWaitReplyPort: 0x%x\n", st));
#endif
        _exit(25);
    }

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    } else {
        if (ARGUMENT_PRESENT(oact)) {
	    try {
            	*oact = args->Oact;
	    } except (EXCEPTION_EXECUTE_HANDLER) {
		errno = EFAULT;
		r = -1;
	    }
	    if (r != 0) {
		return r;
	    }
        }
        return (int)m.ReturnValue;
    }
}

int
__cdecl
sigprocmask(int how, const sigset_t *set, sigset_t *oset)
{
    PSX_API_MSG m;
    NTSTATUS st;
    int r = 0;

    PPSX_SIGPROCMASK_MSG args;

    args = &m.u.SigProcMask;

    PSX_FORMAT_API_MSG(m, PsxSigProcMaskApi, sizeof(*args));

    args->How = (ULONG)how;
    args->SetSpecified = (sigset_t *)set;
    if (ARGUMENT_PRESENT(set)) {
	try {
        	args->Set = *set;
	} except (EXCEPTION_EXECUTE_HANDLER) {
		r = -1;
		errno = EFAULT;
	}
	if (0 != r) {
		return r;
	}
    }

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
				(PPORT_MESSAGE)&m);

#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    } else {
        if (ARGUMENT_PRESENT(oset)) {
	    try {
            	*oset = args->Oset;
	    } except (EXCEPTION_EXECUTE_HANDLER) {
		errno = EFAULT;
		r = -1;
	    }
	    if (0 != r) {
		return r;
	    }
        }
        return (int)m.ReturnValue;
    }
}

int
__cdecl
sigsuspend(const sigset_t *sigmask)
{
	PSX_API_MSG m;
	NTSTATUS st;
	
	PPSX_SIGSUSPEND_MSG args;
	
	args = &m.u.SigSuspend;
	PSX_FORMAT_API_MSG(m, PsxSigSuspendApi, sizeof(*args));

	args->SigMaskSpecified = (PVOID)1;

	st = STATUS_SUCCESS;

	try {
		args->SigMask = *sigmask;
	} except (EXCEPTION_EXECUTE_HANDLER) {
		st = STATUS_UNSUCCESSFUL;
	}
	if (!NT_SUCCESS(st)) {
		errno = EFAULT;
		return -1;
	}

	for (;;) {
		st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
			(PPORT_MESSAGE)&m);
		if (!NT_SUCCESS(st)) {
		    _exit(26);
		}

		if (EINTR == m.Error && SIGCONT == m.Signal) {
			//
			// We were stopped and continued.  Continue
			// suspending.
			//
			PSX_FORMAT_API_MSG(m, PsxSigSuspendApi, sizeof(*args));
			continue;
		}

		if (m.Error) {
			errno = (int)m.Error;
			return -1;
		} 
		return (int)m.ReturnValue;
	}
}

int
__cdecl
pause(void)
{
	PSX_API_MSG m;
	NTSTATUS st;

	PPSX_SIGSUSPEND_MSG args;

	args = &m.u.SigSuspend;

	PSX_FORMAT_API_MSG(m, PsxSigSuspendApi, sizeof(*args));

	args->SigMaskSpecified = NULL;

	for (;;) {
		st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
	        	(PPORT_MESSAGE)&m);
		if (!NT_SUCCESS(st)) {
#ifdef PSX_MORE_ERRORS
			KdPrint(("PSXDLL: pause: Request: 0x%x\n", st));
#endif
            _exit(27);
		}

		if (EINTR == m.Error && SIGCONT == m.Signal) {
			//
			// The syscall was stopped and continues.  Call
			// again instead of returning EINTR.
			//
			
			PSX_FORMAT_API_MSG(m, PsxSigSuspendApi, sizeof(*args));
			continue;
		}
    		if (m.Error) {
		        errno = (int)m.Error;
		        return -1;
    		}
        	return (int)m.ReturnValue;
    	}
}

VOID
PdxNullPosixApi()
{
    PSX_API_MSG m;
    NTSTATUS st;

    PSX_FORMAT_API_MSG(m, PsxNullApi, 0);

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
	if (!NT_SUCCESS(st)) {
		KdPrint(("PSXDLL: PdxNullPosixApi: NtRequestWaitReplyPort: 0x%x\n", st));
	}
#endif
}

int
__cdecl
kill(pid_t pid, int sig)
{
    PSX_API_MSG m;
    NTSTATUS st;

    PPSX_KILL_MSG args;

    args = &m.u.Kill;

    PSX_FORMAT_API_MSG(m, PsxKillApi, sizeof(*args));

    args->Pid = pid;
    args->Sig = (ULONG)sig;

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                (PPORT_MESSAGE)&m);
	if (!NT_SUCCESS(st)) {
#ifdef PSX_MORE_ERRORS
		KdPrint(("PSXDLL: kill: NtRequestWaitReplyPort: 0x%x\n", st));
#endif
        _exit(28);
	}

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    } else {
        return (int)m.ReturnValue;
    }
}

#ifndef SIG_ERR
#define SIG_ERR 0
#endif

_handler __cdecl
signal(int sig, _handler handler)
{
	struct sigaction act, oact;

	act.sa_handler = handler;
	act.sa_flags = 0;
	sigemptyset((sigset_t *)&act.sa_mask);

	if (-1 == sigaction(sig, (struct sigaction *)&act,
		(struct sigaction *)&oact)) {
		return SIG_ERR;
	}
	return oact.sa_handler;	
}

int
__cdecl
sigpending(sigset_t *set)
{
    PSX_API_MSG m;
    PPSX_SIGPENDING_MSG args;
    NTSTATUS st;
    int r = 0;

    args = &m.u.SigPending;

    PSX_FORMAT_API_MSG(m, PsxSigPendingApi, sizeof(*args));

    st = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                (PPORT_MESSAGE)&m);
#ifdef PSX_MORE_ERRORS
    ASSERT(NT_SUCCESS(st));
#endif

    if (m.Error) {
        errno = (int)m.Error;
        return -1;
    }

    try {
    	*set = args->Set;
    } except (EXCEPTION_EXECUTE_HANDLER) {
	errno = EFAULT;
	r = -1;
    }
    return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\psxdll.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    pdxdll.h

Abstract:

    Posix Subsystem Dll Private Types and Prototypes

Author:

    Mark Lucovsky (markl) 04-Oct-1989

Revision History:

--*/

#ifndef _PDXP_
#define _PDXP_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <excpt.h>
#include <sys\types.h>
#include <string.h>
#include <limits.h>
#include <signal.h>
#include <errno.h>
#include <dirent.h>
#include <fcntl.h>
#include <sys\stat.h>
#include <sys\wait.h>
#include <ntsm.h>
#include <unistd.h>
#include "psxmsg.h"
#define NTPSX_ONLY
#include "sesport.h"

int *Errno;
#define errno	(*Errno)

char ***Environ;
#define environ (*Environ)

//
// The PsxDllHandle global variable contains the DLL handle for the WINDLL
// client stubs executable.
//

HANDLE PsxDllHandle;

//
// The connection to the Server is described by the PsxPortHandle global
// variable.  The connection is established when the PsxConnectToServer
// function is called.
//

UNICODE_STRING PsxPortName;
HANDLE PsxPortHandle;

extern ULONG_PTR PsxPortMemoryRemoteDelta;

PVOID PdxHeap;
PVOID PdxPortHeap;
PSX_DIRECTORY_PREFIX PdxDirectoryPrefix;

ANSI_STRING PsxAnsiCommandLine;

//
// PathName Conversion Macros
//

#define IS_POSIX_PATH_SEPARATOR(s) (*(s) == '/' )
#define IS_POSIX_DOT(s) ( s[0] == '.' && ( s[1] == '/' || s[1] == '\0') )
#define IS_POSIX_DOT_DOT(s) ( s[0] == '.' && s[1] == '.' && ( s[2] == '/' || s[2] == '\0') )
#define IN_PORTABLE_CHARACTER_SET(c) (\
            ((c)>='A' && (c)<='Z') || \
            ((c)>='a' && (c)<='z') || \
            ((c)>='0' && (c)<='9') || \
            ((c)=='.')             || \
            ((c)=='_')             || \
            ((c)=='-')               )

typedef int (__cdecl * PFNPROCESS)(ULONG argc,
			   PCHAR *argv
			  );

//
// Stuff for the uname() syscall.
//

#define UNAME_SYSNAME	"Windows NT"
#define UNAME_RELEASE	"3"
#define UNAME_VERSION	"5"

//
// Prototypes
//

void
ClientOpen(
    IN int fd
    );

VOID
PdxProcessStartup(
    IN PPEB Peb
    );

NTSTATUS
PsxConnectToServer();

NTSTATUS
PsxInitDirectories();

VOID
PdxNullPosixApi();

int
PdxStatusToErrno(NTSTATUS);

int
PdxStatusToErrnoPath(PUNICODE_STRING);

VOID
_PdxSignalDeliverer (
    IN PCONTEXT Context,
    IN sigset_t PreviousBlockMask,
    IN int Signal,
    IN _handler Handler
    );

VOID
PdxSignalDeliverer (
    IN PCONTEXT Context,
    IN sigset_t PreviousBlockMask,
    IN int Signal,
    IN _handler Handler
    );

VOID
_PdxNullApiCaller(
    IN PCONTEXT Context
    );

VOID
PdxNullApiCaller(
    IN PCONTEXT Context
    );


BOOLEAN
PdxCanonicalize(
    IN PSZ PathName,
    OUT PUNICODE_STRING CanonPath,
    IN PVOID Heap
    );

//
// Routines defined in coninit.c
//

NTSTATUS PsxInitializeSessionPort(IN ULONG UniqueId);


//
// Routines defined in conrqust.c
//

NTSTATUS SendConsoleRequest(IN OUT PSCREQUESTMSG Request);

#endif // _PDXP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\subsys\posix\client\sysdb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    sysdb.c

Abstract:

    Client side of system database (password and group) access routines.

Author:

    Matthew Bradburn (mattbr) 04-Mar-1992

Revision History:

--*/

#include <unistd.h>
#include <pwd.h>
#include <grp.h>
#include <stdio.h>
#include "psxdll.h"

extern PVOID PsxPortMemoryBase;

static char pwbuf[ARG_MAX];
static char grbuf[ARG_MAX];

struct passwd *
__cdecl
getpwuid(uid_t uid)
{
	PSX_API_MSG m;
	PPSX_GETPWUID_MSG args;
	NTSTATUS Status;
	struct passwd *tmpbuf;

	args = &m.u.GetPwUid;
	PSX_FORMAT_API_MSG(m, PsxGetPwUidApi, sizeof(*args));

	args->Uid = uid;
    args->PwBuf = RtlAllocateHeap(PdxPortHeap, 0, ARG_MAX);
    ASSERT(args->PwBuf != NULL);
    args->PwBuf = (struct passwd *)((PCHAR)args->PwBuf +
                                    PsxPortMemoryRemoteDelta);

	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                        (PPORT_MESSAGE)&m);

    args->PwBuf = (struct passwd *)((PCHAR)args->PwBuf -
                                    PsxPortMemoryRemoteDelta);

	if (0 != m.Error) {
        RtlFreeHeap(PdxPortHeap, 0, args->PwBuf);
		return NULL;
	}

	(void)memcpy(pwbuf, args->PwBuf, args->Length);

    RtlFreeHeap(PdxPortHeap, 0, args->PwBuf);

	tmpbuf = (struct passwd *)pwbuf;
	tmpbuf->pw_name += (ULONG_PTR)tmpbuf;
	tmpbuf->pw_dir += (ULONG_PTR)tmpbuf;
	tmpbuf->pw_shell += (ULONG_PTR)tmpbuf;

	return tmpbuf;
}

struct passwd *
__cdecl
getpwnam(const char *name)
{
	PSX_API_MSG m;
	PPSX_GETPWNAM_MSG args;
	NTSTATUS Status;
	struct passwd *tmpbuf;

	args = &m.u.GetPwNam;
	PSX_FORMAT_API_MSG(m, PsxGetPwNamApi, sizeof(*args));

	if ('\0' == *name) {
		return NULL;
	}

	args->Name = (PCHAR)RtlAllocateHeap(PdxPortHeap, 0, ARG_MAX);
        if (! args->Name) {
            errno = ENOMEM;
            return NULL;
        }

	strcpy(args->Name,name);
	args->Name += PsxPortMemoryRemoteDelta;
	args->PwBuf = (struct passwd *)(args->Name + strlen(name) + 1);

	//
	// Make sure buffer is properly aligned.
	//

	while ((ULONG_PTR)args->PwBuf & 0x3)
		args->PwBuf = (PVOID)((ULONG_PTR)args->PwBuf + 1);


	Status = NtRequestWaitReplyPort(PsxPortHandle, (PPORT_MESSAGE)&m,
                                        (PPORT